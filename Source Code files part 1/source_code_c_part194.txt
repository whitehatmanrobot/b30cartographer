)) {
                goto success_exit;
            }
        }
    } else {       
        // Login only if required
        if (!LoginRequired())
            goto success_exit;
        
        wcscpy(UserNameBuffer,L"Administrator");
        RtlZeroMemory( PasswordBuffer, sizeof(PasswordBuffer) );        

        while (FailureCount < MAX_FAILURES) {
            //
            // get the password
            //

            RcMessageOut( MSG_LOGON_PROMPT_PASSWORD );
            RtlZeroMemory( PasswordBuffer, sizeof(PasswordBuffer) );
            RcPasswordIn(PasswordBuffer, sizeof(PasswordBuffer)/sizeof(WCHAR));

            //
            // authorize the logon attempt
            //
            Status = RcAuthorizePasswordLogon( UserNameBuffer, PasswordBuffer, NtInstall );
            RtlSecureZeroMemory(PasswordBuffer, sizeof(PasswordBuffer));
              
            if(NT_SUCCESS(Status)) {
                goto success_exit;
            }

            RcMessageOut( MSG_LOGON_FAILURE );
            FailureCount += 1;
        }        
    }

    RcMessageOut( MSG_LOGON_FAILUE_BAD );
    RcMessageOut( MSG_REBOOT_NOW );
    RcTextOut(L"\r\n");

    //
    // wait for the use to press ENTER
    //
    while (SpInputGetKeypress() != ASCI_CR);
        
    return 0;

success_exit:
    //
    // Enable the set command if specified  and not already
    // enabled (would be enabled if registries are corrupted)
    // 
    if (bRegCorrupted) {
        //AllowAllPaths = TRUE;
        //RcSetSETCommandStatus(TRUE);
    } else {
        RcSetSETCommandStatus(IsSetCommandEnabled());
    }
        
    //
    // set the current drive to the selected install.
    //
    _CurDrive = SelectedInstall->DriveLetter;

    //
    // set the current dir to the correct one.
    //
    RtlZeroMemory( Buffer, sizeof(Buffer) );

    wcscat( Buffer, L"\\" );
    wcsncat(Buffer, 
            SelectedInstall->Path,
            MAX_APPEND_SIZE(Buffer));
    Buffer[MAX_COPY_SIZE(Buffer)] = L'\0';
    wcscat( Buffer, L"\\" );

    u = RcToUpper(SelectedInstall->DriveLetter) - L'A';

    if(_CurDirs[u]) {
        SpMemFree(_CurDirs[u]);
    }

    _CurDirs[u] = SpDupStringW( Buffer );
    firstTime = FALSE;
    RcPurgeHistoryBuffer();
    
    return 1;
}

/*++

Routine Description:

    Checks the "SecurityLevel" value under 
    HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Setup\RecoveryConsole to see
    if login is needed or not
    
Arguments:
    None

Return Value:

    TRUE if Login is required or FALSE otherwise 
--*/
BOOLEAN
LoginRequired(
    VOID
    )
{    
    BOOLEAN         bLogin = TRUE;
    PWSTR           szValueName = L"SecurityLevel";
    HANDLE          hKey = NULL;
    UNICODE_STRING  unicodeStr;
    NTSTATUS        status;
    BYTE            buffer[ sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                                    MAX_PATH * sizeof(WCHAR) ];
    ULONG           ulResultLen = 0;                                    
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
    OBJECT_ATTRIBUTES   stObjAttr;
    
    PWSTR   szWinLogonKey = 
              L"\\registry\\machine\\xSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\RecoveryConsole";

    RtlZeroMemory(buffer, sizeof(buffer));
    
    //
    // Load the SOFTWARE hive
    //    
    if (RcOpenHive( gszSoftwareHiveName, gszSoftwareHiveKey )) {
        //
        // Open the key
        //        
        INIT_OBJA( &stObjAttr, &unicodeStr, szWinLogonKey );
        
        status = ZwOpenKey( &hKey, KEY_ALL_ACCESS, &stObjAttr );

        if (NT_SUCCESS(status)) {
            RtlInitUnicodeString( &unicodeStr, szValueName );
            
            //
            // read the value
            //
            status = ZwQueryValueKey( hKey,
                        &unicodeStr,                
                        KeyValuePartialInformation,
                        pKeyValueInfo,
                        sizeof(buffer),
                        &ulResultLen );

            if (NT_SUCCESS(status) && (pKeyValueInfo->Type == REG_DWORD)) {
                bLogin = !(*((PDWORD)(pKeyValueInfo->Data)) == 1);
            }            
        }    

        if (hKey)
            ZwClose(hKey);

        // close the hive
        RcCloseHive( gszSoftwareHiveKey );
    }
    
    
    return bLogin;
}


/*++

Routine Description:

    Checks the "SetCommand" value under 
    HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Setup\RecoveryConsole to see
    if SET command needs to be enabled or disabled
    
Arguments:
    None

Return Value:

    TRUE if Login is required or FALSE otherwise 
--*/
BOOLEAN
IsSetCommandEnabled(
    VOID
    )
{
    BOOLEAN         bSetEnabled = FALSE;
    PWSTR           szValueName = L"SetCommand";
    HANDLE          hKey = NULL;
    UNICODE_STRING  unicodeStr;
    NTSTATUS        status;
    BYTE            buffer[ sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                                    MAX_PATH * sizeof(WCHAR) ];
    ULONG           ulResultLen = 0;                                    
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
    OBJECT_ATTRIBUTES   stObjAttr;
    
    PWSTR   szWinLogonKey = 
              L"\\registry\\machine\\xSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\RecoveryConsole";

    RtlZeroMemory(buffer, sizeof(buffer));
    
    //
    // Load the SOFTWARE hive
    //    
    if (RcOpenHive( gszSoftwareHiveName, gszSoftwareHiveKey )) {
        //
        // Open the key
        //        
        INIT_OBJA( &stObjAttr, &unicodeStr, szWinLogonKey );
        
        status = ZwOpenKey( &hKey, KEY_ALL_ACCESS, &stObjAttr );

        if (NT_SUCCESS(status)) {
            RtlInitUnicodeString( &unicodeStr, szValueName );
            
            //
            // read the value
            //
            status = ZwQueryValueKey( hKey,
                        &unicodeStr,                
                        KeyValuePartialInformation,
                        pKeyValueInfo,
                        sizeof(buffer),
                        &ulResultLen );

            if (NT_SUCCESS(status) && (pKeyValueInfo->Type == REG_DWORD)) {
                bSetEnabled = (*((PDWORD)(pKeyValueInfo->Data)) == 1);
            }            
        }    

        if (hKey)
            ZwClose(hKey);

        // close the hive
        RcCloseHive( gszSoftwareHiveKey );
    }
    
    
    return bSetEnabled;
}



LARGE_INTEGER
RcGetTimeZoneBias(
    VOID
    )
/*++

Routine Description:

    Reads the bias information from 
    "\\HKLM\\System\\CurrentControlSet\\Control\\TimeZoneInformation"
    key's "Bias" value. We use our own conversion routine because
    RtlSetTimeZoneInformation() updates the system time (which we
    don't want to change).

Arguments:

    none
    
Return Value:
    0   if error, otherwise value stored in the registry 
    for the key (could be zero).

--*/
{
    LARGE_INTEGER       lBias;
    OBJECT_ATTRIBUTES   stObjAttr;
    HANDLE              hKey = NULL;
    NTSTATUS            status;
    UNICODE_STRING      unicodeStr;
    unsigned            uIndex;
    ULONG               uControl = -1;
    WCHAR               szKeyName[MAX_PATH];
    BYTE                dataBuff[MAX_PATH + 
                            sizeof(KEY_VALUE_PARTIAL_INFORMATION)];
    KEY_VALUE_PARTIAL_INFORMATION   *pKeyData = 
                        (KEY_VALUE_PARTIAL_INFORMATION*)dataBuff;
    ULONG               ulResultLen = 0;         
    UNICODE_STRING      szValueName;
    DWORD               dwDaylightBias = 0;
    DWORD               dwStandardBias = 0;
    BOOLEAN             bSysHiveOpened;

    lBias.QuadPart = 0;             
    
    //
    // open the system hive & determine correct control set to use
    //
    bSysHiveOpened = RcOpenHive(gszSystemHiveName, gszSystemHiveKey);
    
    if (bSysHiveOpened && RcDetermineCorrectControlKey(&uControl)) {
            
        //
        // open the key and read the
        //            
        RtlZeroMemory(pKeyData, sizeof(dataBuff));

        swprintf(szKeyName, 
            L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Control\\TimeZoneInformation",
            uControl);             

        INIT_OBJA(&stObjAttr, &unicodeStr, szKeyName);
        RtlInitUnicodeString(&szValueName, L"Bias");

        status = ZwOpenKey(&hKey, KEY_READ, &stObjAttr);

        if (!NT_SUCCESS(status)) {
            KdPrint(("SPCMDCON: RcGetTimeZoneBias - Couldnot open hive key: %ws(%lx)\n", 
                    szKeyName, status));
        } else {
            //
            // Query the "Bias" value under the key
            //
            status = ZwQueryValueKey( hKey,
                            &szValueName,
                            KeyValuePartialInformation,
                            pKeyData,
                            sizeof(dataBuff),
                            &ulResultLen );

            if (NT_SUCCESS(status) && (pKeyData->Type == REG_DWORD)) {
                lBias.QuadPart = Int32x32To64(*(DWORD*)(pKeyData->Data) * 60,
                                            10000000);
                
                
                RtlZeroMemory(pKeyData, sizeof(dataBuff));
                RtlInitUnicodeString(&szValueName, L"DaylightBias");

                //
                // Query the "DaylightBias" value under the key
                //
                status = ZwQueryValueKey( hKey,
                                &szValueName,
                                KeyValuePartialInformation,
                                pKeyData,
                                sizeof(dataBuff),
                                &ulResultLen );

                if (NT_SUCCESS(status) && (pKeyData->Type == REG_DWORD)) {
                    dwDaylightBias = *(DWORD*)(pKeyData->Data);        

                    if (dwDaylightBias == 0 ) {
                        //
                        // there could be a standard bias
                        //
                        RtlZeroMemory(pKeyData, sizeof(dataBuff));
                        RtlInitUnicodeString(&szValueName, L"StandardBias");

                        //
                        // Query the "StandardBias" value under the key
                        //
                        status = ZwQueryValueKey( hKey,
                                        &szValueName,
                                        KeyValuePartialInformation,
                                        pKeyData,
                                        sizeof(dataBuff),
                                        &ulResultLen );
                                        
                        if (NT_SUCCESS(status) && 
                                (pKeyData->Type == REG_DWORD)) {
                            dwStandardBias = *(DWORD*)(pKeyData->Data);
                        }                        
                    }                   
                    
                    lBias.QuadPart += Int32x32To64((dwDaylightBias + dwStandardBias) * 60,
                                                10000000);  
                } else {
                    lBias.QuadPart = 0;  // 
                }
            }

            if (!NT_SUCCESS(status))
                KdPrint(("SPCMDCON: RcGetTimeZoneBias Error:(%lx)", status));
        }
        
        if (hKey)
            ZwClose(hKey);        
    }

    if (bSysHiveOpened)
        RcCloseHive(gszSystemHiveKey);    
        
    return lBias;
}



BOOLEAN
RcIsValidSystemHive(
    VOID
    )
/*++

Routine Description:

   Verifies whether the system hive of the selected NT install
   is fine. Checks for the presence of "Control\Lsa" and 
   "Control\SessionManager" currently under ControlSet.

Arguments:

    none
    
Return Value:

   TRUE - indicates system hive is fine
   FALSE - indicates system hive is corrupted

--*/
{
    BOOLEAN             bResult = FALSE;    
    OBJECT_ATTRIBUTES   stObjAttr;
    HANDLE              hKey = NULL;
    NTSTATUS            status;
    UNICODE_STRING      unicodeStr;
    unsigned            uIndex;
    ULONG               uControl = -1;
    WCHAR               szKeyName[MAX_PATH];
    BOOLEAN             bSysHiveOpened;
    KEY_CHECK_STRUCT    aKeysToCheck[] = {
         { L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Control\\Lsa", TRUE },
         { L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Control\\Session Manager", TRUE } }; 
            
    //
    // open the system hive & determine correct control set to use
    //
    bSysHiveOpened = RcOpenHive(gszSystemHiveName, gszSystemHiveKey);
    
    if ( bSysHiveOpened && RcDetermineCorrectControlKey(&uControl)) {
        
        bResult = TRUE;

        //
        // open each of the key and then close it to verify its presence
        //
        for (uIndex = 0; 
                uIndex < (sizeof(aKeysToCheck) / sizeof(KEY_CHECK_STRUCT));
                uIndex++) {

            if (aKeysToCheck[uIndex].bControlSet)               
                swprintf(szKeyName, aKeysToCheck[uIndex].szKeyName, uControl);             
            else
                wcscpy(szKeyName, aKeysToCheck[uIndex].szKeyName);
                
            INIT_OBJA(&stObjAttr, &unicodeStr, szKeyName);
        
            status = ZwOpenKey(&hKey, KEY_READ, &stObjAttr);

            if (!NT_SUCCESS(status)) {
                KdPrint(("SPCMDCON: RcIsValidSystemHive - Couldnot open hive key: %ws(%lx)\n", 
                    szKeyName, status));
                    
                bResult = FALSE;
                break;
            }

            if (hKey)
                ZwClose(hKey);
        }
    }

    if (bSysHiveOpened)
        RcCloseHive(gszSystemHiveKey);
    
    return bResult;
}



BOOLEAN
RcOpenHive(
    PWSTR   szHiveName,
    PWSTR   szHiveKey
    )
/*++

Routine Description:

   Opens the requested hive of the selected NT install.

Arguments:

   szHiveName   - hive file name (just file name alone)
   szHiveKey    - the key into which the hive needs to be loaded

Return Value:

   TRUE - indicates sucess
   FALSE - indicates failure

--*/
{
    PWSTR       Hive = NULL;
    PWSTR       HiveKey = NULL;
    PUCHAR      buffer = NULL;
    PWSTR       PartitionPath = NULL;
    NTSTATUS    Status;
    BOOLEAN     bResult = FALSE;


    if ((SelectedInstall == NULL) || (szHiveName == NULL) || (szHiveKey == NULL)) {
        return FALSE;
    }

    //
    // Allocate buffers.
    //
    Hive = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    HiveKey = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    buffer = SpMemAlloc(BUFFERSIZE);

    //
    // Get the name of the target patition.
    //
    SpNtNameFromRegion(
        SelectedInstall->Region, // SelectedInstall is a global defined in cmdcons.h
        _CmdConsBlock->TemporaryBuffer,
        _CmdConsBlock->TemporaryBufferSize,
        PartitionOrdinalCurrent
        );

    PartitionPath = SpDupStringW(_CmdConsBlock->TemporaryBuffer);

    //
    // Load the hive
    //
    wcscpy(Hive,PartitionPath);
    SpConcatenatePaths(Hive,SelectedInstall->Path);
    SpConcatenatePaths(Hive,L"system32\\config");
    SpConcatenatePaths(Hive,szHiveName);

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\x<hivename>.
    //
    wcscpy(HiveKey, szHiveKey);

    //
    // Attempt to load the key.
    //
    Status = SpLoadUnloadKey(NULL,NULL,HiveKey,Hive);

    if (NT_SUCCESS(Status))
        bResult = TRUE;
    else
        DEBUG_PRINTF(("CMDCONS: Unable to load hive %ws to key %ws (%lx)\n",Hive,HiveKey,Status));
          

    if (Hive != NULL)
        SpMemFree( Hive );

    if (HiveKey != NULL)
        SpMemFree( HiveKey );

    if (buffer != NULL)        
        SpMemFree( buffer );

    return bResult;
}



BOOLEAN
RcCloseHive(
    PWSTR   szHiveKey 
    )
/*++

Routine Description:

   Closes the specified hive of the selected NT install.

Arguments:

   szHiveKey  - specifies the key of the hive to be unloaded

Return Value:

   TRUE - indicates sucess
   FALSE - indicates failure

--*/
{
    NTSTATUS    TmpStatus;
    BOOLEAN     bResult = FALSE;

    if (szHiveKey != NULL) {
        //
        // Unload the hive
        //
        TmpStatus = SpLoadUnloadKey( NULL, NULL, szHiveKey, NULL );

        if (NT_SUCCESS(TmpStatus)) {
            bResult = TRUE;
        } else {
            KdPrint(("CMDCONS: warning: unable to unload key %ws (%lx)\n", szHiveKey, TmpStatus));
        }            
    }            
    
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\expand.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    expand.c

Abstract:

    This module implements the file expand command.

Author:

    Mike Sliger (msliger) 29-Apr-1999

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop



//
// structure tunneled thru SpExpandFile to carry info to/from callback
//
typedef struct {
    LPWSTR  FileSpec;
    BOOLEAN DisplayFiles;
    BOOLEAN MatchedAnyFiles;
    ULONG   NumberOfFilesDone;
    BOOLEAN UserAborted;
    BOOLEAN OverwriteExisting;
} EXPAND_CONTEXT;

BOOLEAN
pRcCheckForBreak( VOID );

EXPAND_CALLBACK_RESULT
pRcExpandCallback(
    EXPAND_CALLBACK_MESSAGE Message,
    PWSTR                   FileName,
    PLARGE_INTEGER          FileSize,
    PLARGE_INTEGER          FileTime,
    ULONG                   FileAttributes,
    PVOID                   UserData
    );

BOOL
pRcPatternMatch(
    LPWSTR pszString,
    LPWSTR pszPattern,
    IN BOOL fImplyDotAtEnd
    );



ULONG
RcCmdExpand(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    PLINE_TOKEN Token;
    LPWSTR Arg;
    LPWSTR SrcFile = NULL;
    LPWSTR DstFile = NULL;
    LPWSTR FileSpec = NULL;
    LPWSTR SrcNtFile = NULL;
    LPWSTR DstNtPath = NULL;
    LPWSTR s;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    LPWSTR YesNo;
    WCHAR Text[3];
    IO_STATUS_BLOCK  status_block;
    FILE_BASIC_INFORMATION fileInfo;
    WCHAR * pos;
    ULONG CopyFlags = 0;
    BOOLEAN DisplayFileList = FALSE;
    BOOLEAN OverwriteExisting = NoCopyPrompt;
    EXPAND_CONTEXT Context;

    ASSERT(TokenizedLine->TokenCount >= 1);

    if (RcCmdParseHelp( TokenizedLine, MSG_EXPAND_HELP )) {
        goto exit;
    }

    //
    //  Parse command line
    //

    for( Token = TokenizedLine->Tokens->Next;
         Token != NULL;
         Token = Token->Next ) {

        Arg = Token->String;
        if(( Arg[0] == L'-' ) || ( Arg[0] == L'/' )) {
            switch( Arg[1] ) {
            case L'F':
            case L'f':
                if(( Arg[2] == L':' ) && ( FileSpec == NULL )) {
                    FileSpec = &Arg[3];
                } else {
                    RcMessageOut(MSG_SYNTAX_ERROR);
                    goto exit;
                }
                break;

            case L'D':
            case L'd':
                if ( Arg[2] == L'\0' ) {
                    DisplayFileList = TRUE;
                } else {
                    RcMessageOut(MSG_SYNTAX_ERROR);
                    goto exit;
                }
                break;

            case L'Y':
            case L'y':
                if ( Arg[2] == L'\0' ) {
                    OverwriteExisting = TRUE;
                } else {
                    RcMessageOut(MSG_SYNTAX_ERROR);
                    goto exit;
                }
                break;

            default:
                RcMessageOut(MSG_SYNTAX_ERROR);
                goto exit;
            }
        } else if( SrcFile == NULL ) {
            SrcFile = Arg;
        } else if( DstFile == NULL ) {
            DstFile = SpDupStringW( Arg );
        } else {
            RcMessageOut(MSG_SYNTAX_ERROR);
            goto exit;
        }
    }

    if(( SrcFile == NULL ) ||
        (( DstFile != NULL ) && ( DisplayFileList == TRUE ))) {

        RcMessageOut(MSG_SYNTAX_ERROR);
        goto exit;
    }

    if ( RcDoesPathHaveWildCards( SrcFile )) {
        RcMessageOut(MSG_DIR_WILDCARD_NOT_SUPPORTED);
        goto exit;
    }

    //
    // Translate the source name to the NT namespace
    //

    if (!RcFormFullPath( SrcFile, _CmdConsBlock->TemporaryBuffer, TRUE )) {
        RcMessageOut(MSG_INVALID_PATH);
        goto exit;
    }

    SrcNtFile = SpDupStringW( _CmdConsBlock->TemporaryBuffer );

    if ( !DisplayFileList ) {
        BOOLEAN OnRemovableMedia;

        //
        // Create a destination path name when the user did not
        // provide one.  We use the current drive and directory.
        //
        if( DstFile == NULL ) {
            RcGetCurrentDriveAndDir( _CmdConsBlock->TemporaryBuffer );
            DstFile = SpDupStringW( _CmdConsBlock->TemporaryBuffer );
        }

        //
        // create the destination paths
        //
        if (!RcFormFullPath( DstFile, _CmdConsBlock->TemporaryBuffer, FALSE )) {
            RcMessageOut(MSG_INVALID_PATH);
            goto exit;
        }

        if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,FALSE,FALSE)) {
            RcMessageOut(MSG_ACCESS_DENIED);
            goto exit;
        }

        if (!RcFormFullPath( DstFile, _CmdConsBlock->TemporaryBuffer, TRUE )) {
            RcMessageOut(MSG_INVALID_PATH);
            goto exit;
        }

        DstNtPath = SpDupStringW( _CmdConsBlock->TemporaryBuffer );

        //
        // check for removable media
        //
        Status  = RcIsFileOnRemovableMedia(DstNtPath, &OnRemovableMedia);

        if (AllowRemovableMedia == FALSE && (!NT_SUCCESS(Status) || OnRemovableMedia)) {
            RcMessageOut(MSG_ACCESS_DENIED);
            goto exit;
        }
    }

    //
    // setup context for callbacks
    //

    RtlZeroMemory(&Context, sizeof(Context));
    Context.FileSpec = FileSpec;
    Context.DisplayFiles = DisplayFileList;
    Context.OverwriteExisting = OverwriteExisting;

    if ( DisplayFileList ) {
        pRcEnableMoreMode();
    }

    Status = SpExpandFile( SrcNtFile, DstNtPath, pRcExpandCallback, &Context );

    pRcDisableMoreMode();

    if( !NT_SUCCESS(Status) && !Context.UserAborted ) {

        RcNtError( Status, MSG_CANT_EXPAND_FILE );

    } else if (( Context.NumberOfFilesDone == 0 ) &&
               ( Context.MatchedAnyFiles == FALSE ) &&
               ( Context.FileSpec != NULL )) {

        RcMessageOut( MSG_EXPAND_NO_MATCH, Context.FileSpec, SrcFile );
    }

    if ( Context.MatchedAnyFiles ) {
        if ( DisplayFileList ) {
            RcMessageOut( MSG_EXPAND_SHOWN, Context.NumberOfFilesDone );
        } else {
            RcMessageOut( MSG_EXPAND_COUNT, Context.NumberOfFilesDone );
        }
    }

exit:

    if( SrcNtFile ) {
        SpMemFree( SrcNtFile );
    }

    if( DstFile ) {
        SpMemFree( DstFile );
    }

    if( DstNtPath ) {
        SpMemFree( DstNtPath );
    }

    return 1;
}



EXPAND_CALLBACK_RESULT
pRcExpandCallback(
    EXPAND_CALLBACK_MESSAGE Message,
    PWSTR                   FileName,
    PLARGE_INTEGER          FileSize,
    PLARGE_INTEGER          FileTime,
    ULONG                   FileAttributes,
    PVOID                   UserData
    )
{
    EXPAND_CONTEXT * Context = (EXPAND_CONTEXT * ) UserData;
    LPWSTR YesNo;
    EXPAND_CALLBACK_RESULT rc;
    WCHAR Text[3];

    switch ( Message )
    {
    case EXPAND_COPY_FILE:

        //
        // Watch for Ctl-C or ESC while processing
        //
        if ( pRcCheckForBreak() ) {
            Context->UserAborted = TRUE;
            return( EXPAND_ABORT );
        }

        //
        // See if filename matches filespec pattern, if any
        //
        if ( Context->FileSpec != NULL ) {

            //
            // To be "*.*"-friendly, we need to know if there is a real
            // dot in the last element of the string to be matched
            //

            BOOL fAllowImpliedDot = TRUE;
            LPWSTR p;

            for ( p = FileName; *p != L'\0'; p++ ) {
                if ( *p == L'.' ) {
                    fAllowImpliedDot = FALSE;
                } else if ( *p == L'\\' ) {
                    fAllowImpliedDot = TRUE;
                }
            }
            
            if ( !pRcPatternMatch( FileName,
                                   Context->FileSpec,
                                   fAllowImpliedDot )) {
                //
                // File doesn't match given spec: skip it
                //
                return( EXPAND_SKIP_THIS_FILE );
            }
        }

        Context->MatchedAnyFiles = TRUE;    // don't report "no matches"

        if ( Context->DisplayFiles ) {

            //
            // We're just listing file names, and we must do it now, because
            // we're going to tell ExpandFile to skip this one, so this will
            // be the last we here about it.
            //
            WCHAR LineOut[50];
            WCHAR *p;

            //
            // Format the date and time, which go first.
            //
            RcFormatDateTime(FileTime,LineOut);
            RcTextOut(LineOut);

            //
            // 2 spaces for separation
            //
            RcTextOut(L"  ");

            //
            // File attributes.
            //
            p = LineOut;

            *p++ = L'-';

            if(FileAttributes & FILE_ATTRIBUTE_ARCHIVE) {
                *p++ = L'a';
            } else {
                *p++ = L'-';
            }
            if(FileAttributes & FILE_ATTRIBUTE_READONLY) {
                *p++ = L'r';
            } else {
                *p++ = L'-';
            }
            if(FileAttributes & FILE_ATTRIBUTE_HIDDEN) {
                *p++ = L'h';
            } else {
                *p++ = L'-';
            }
            if(FileAttributes & FILE_ATTRIBUTE_SYSTEM) {
                *p++ = L's';
            } else {
                *p++ = L'-';
            }

            *p++ = L'-';
            *p++ = L'-';
            *p++ = L'-';
            *p = 0;

            RcTextOut(LineOut);

            //
            // 2 spaces for separation
            //
            RcTextOut(L"  ");

            //
            // Now, put the size in there. Right justified and space padded
            // up to 8 chars. Otherwise unjustified or padded.
            //
            RcFormat64BitIntForOutput(FileSize->QuadPart,LineOut,TRUE);
            if(FileSize->QuadPart > 99999999i64) {
                RcTextOut(LineOut);
            } else {
                RcTextOut(LineOut+11);          // outputs 8 chars
            }

            RcTextOut(L" ");

            //
            // Finally, put the filename on the line.
            //

            if( !RcTextOut( FileName ) || !RcTextOut( L"\r\n" )) {

                Context->UserAborted = TRUE;
                return( EXPAND_ABORT );      /* user aborted display output */
            }

            Context->NumberOfFilesDone++;

            return( EXPAND_SKIP_THIS_FILE );

        }   // end if DisplayFiles

        //
        // This file qualified, and we're not just displaying, so tell
        // ExpandFile to do it.
        //
        return( EXPAND_COPY_THIS_FILE );

    case EXPAND_COPIED_FILE:

        //
        // Notification that a file has been copied successfully.
        //

        RcMessageOut( MSG_EXPANDED, FileName);
        Context->NumberOfFilesDone++;

        return( EXPAND_NO_ERROR );

    case EXPAND_QUERY_OVERWRITE:

        //
        // Query for approval to overwrite an existing file.
        //

        if ( Context->OverwriteExisting ) {
            return( EXPAND_COPY_THIS_FILE );
        }

        rc = EXPAND_SKIP_THIS_FILE;

        YesNo = SpRetreiveMessageText( ImageBase, MSG_YESNOALLQUIT, NULL, 0 );
        if ( YesNo ) {

            RcMessageOut( MSG_COPY_OVERWRITE_QUIT, FileName );
            if( RcLineIn( Text, 2 ) ) {
                if (( Text[0] == YesNo[2] ) || ( Text[0] == YesNo[3] )) {

                    //
                    // Yes, we may overwrite this file
                    //
                    rc = EXPAND_COPY_THIS_FILE;

                } else if (( Text[0] == YesNo[4] ) || ( Text[0] == YesNo[5] )) {

                    //
                    // All, we may overwrite this file, and don't prompt again
                    //
                    Context->OverwriteExisting = TRUE;
                    rc = EXPAND_COPY_THIS_FILE;

                } else if (( Text[0] == YesNo[6] ) || ( Text[0] == YesNo[7] )) {

                    //
                    // No, and stop too.
                    //
                    Context->UserAborted = TRUE;
                    rc = EXPAND_ABORT;
                }
            }
            SpMemFree( YesNo );
        }

        return( rc );

    case EXPAND_NOTIFY_MULTIPLE:

        //
        // We're being advised that the source contains multiple files.
        // If we don't have a selective filespec, we'll abort.
        //

        if ( Context->FileSpec == NULL ) {

            RcMessageOut( MSG_FILESPEC_REQUIRED );
            Context->UserAborted = TRUE;
            return ( EXPAND_ABORT );
        }

        return ( EXPAND_CONTINUE );

    case EXPAND_NOTIFY_CANNOT_EXPAND:

        //
        // We're being advised that the source file format is not
        // recognized.  We display the file name and abort.
        //

        RcMessageOut( MSG_CANT_EXPAND_FILE, FileName );
        Context->UserAborted = TRUE;

        return ( EXPAND_ABORT );

    case EXPAND_NOTIFY_CREATE_FAILED:

        //
        // We're being advised that the current target file cannot be
        // created.  We display the file name and abort.
        //

        RcMessageOut( MSG_EXPAND_FAILED, FileName );
        Context->UserAborted = TRUE;

        return ( EXPAND_ABORT );

    default:

        //
        // Ignore any unexpected callback.
        //

        return( EXPAND_NO_ERROR );
    }
}



BOOLEAN
pRcCheckForBreak( VOID )
{
    while ( SpInputIsKeyWaiting() ) {

        ULONG Key = SpInputGetKeypress();

        switch ( Key ) {

        case ASCI_ETX:
        case ASCI_ESC:
            RcMessageOut( MSG_BREAK );
            return TRUE;

        default:
            break;
        }
    }

    return FALSE;
}



//
// pRcPatternMatch() & helpers
//

#define WILDCARD    L'*'    /* zero or more of any character */
#define WILDCHAR    L'?'    /* one of any character (does not match END) */
#define END         L'\0'   /* terminal character */
#define DOT         L'.'    /* may be implied at end ("hosts" matches "*.") */

static int __inline Lower(c)
{
    if ((c >= L'A') && (c <= L'Z'))
    {
        return(c + (L'a' - L'A'));
    }
    else
    {
        return(c);
    }
}


static int __inline CharacterMatch(WCHAR chCharacter, WCHAR chPattern)
{
    if (Lower(chCharacter) == Lower(chPattern))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


BOOL
pRcPatternMatch(
    LPWSTR pszString,
    LPWSTR pszPattern,
    IN BOOL fImplyDotAtEnd
    )
{
    /* RECURSIVE */

    //
    //  This function does not deal with 8.3 conventions which might
    //  be expected for filename comparisons.  (In an 8.3 environment,
    //  "alongfilename.html" would match "alongfil.htm")
    //
    //  This code is NOT MBCS-enabled
    //

    for ( ; ; )
    {
        switch (*pszPattern)
        {

        case END:

            //
            //  Reached end of pattern, so we're done.  Matched if
            //  end of string, no match if more string remains.
            //

            return(*pszString == END);

        case WILDCHAR:

            //
            //  Next in pattern is a wild character, which matches
            //  anything except end of string.  If we reach the end
            //  of the string, the implied DOT would also match.
            //

            if (*pszString == END)
            {
                if (fImplyDotAtEnd == TRUE)
                {
                    fImplyDotAtEnd = FALSE;
                }
                else
                {
                    return(FALSE);
                }
            }
            else
            {
                pszString++;
            }

            pszPattern++;

            break;

        case WILDCARD:

            //
            //  Next in pattern is a wildcard, which matches anything.
            //  Find the required character that follows the wildcard,
            //  and search the string for it.  At each occurence of the
            //  required character, try to match the remaining pattern.
            //
            //  There are numerous equivalent patterns in which multiple
            //  WILDCARD and WILDCHAR are adjacent.  We deal with these
            //  before our search for the required character.
            //
            //  Each WILDCHAR burns one non-END from the string.  An END
            //  means we have a match.  Additional WILDCARDs are ignored.
            //

            for ( ; ; )
            {
                pszPattern++;

                if (*pszPattern == END)
                {
                    return(TRUE);
                }
                else if (*pszPattern == WILDCHAR)
                {
                    if (*pszString == END)
                    {
                        if (fImplyDotAtEnd == TRUE)
                        {
                            fImplyDotAtEnd = FALSE;
                        }
                        else
                        {
                            return(FALSE);
                        }
                    }
                    else
                    {
                        pszString++;
                    }
                }
                else if (*pszPattern != WILDCARD)
                {
                    break;
                }
            }

            //
            //  Now we have a regular character to search the string for.
            //

            while (*pszString != END)
            {
                //
                //  For each match, use recursion to see if the remainder
                //  of the pattern accepts the remainder of the string.
                //  If it does not, continue looking for other matches.
                //

                if (CharacterMatch(*pszString, *pszPattern) == TRUE)
                {
                    if (pRcPatternMatch(pszString + 1, pszPattern + 1, fImplyDotAtEnd) == TRUE)
                    {
                        return(TRUE);
                    }
                }

                pszString++;
            }

            //
            //  Reached end of string without finding required character
            //  which followed the WILDCARD.  If the required character
            //  is a DOT, consider matching the implied DOT.
            //
            //  Since the remaining string is empty, the only pattern which
            //  could match after the DOT would be zero or more WILDCARDs,
            //  so don't bother with recursion.
            //

            if ((*pszPattern == DOT) && (fImplyDotAtEnd == TRUE))
            {
                pszPattern++;

                while (*pszPattern != END)
                {
                    if (*pszPattern != WILDCARD)
                    {
                        return(FALSE);
                    }

                    pszPattern++;
                }

                return(TRUE);
            }

            //
            //  Reached end of the string without finding required character.
            //

            return(FALSE);
            break;

        default:

            //
            //  Nothing special about the pattern character, so it
            //  must match source character.
            //

            if (CharacterMatch(*pszString, *pszPattern) == FALSE)
            {
                if ((*pszPattern == DOT) &&
                    (*pszString == END) &&
                    (fImplyDotAtEnd == TRUE))
                {
                    fImplyDotAtEnd = FALSE;
                }
                else
                {
                    return(FALSE);
                }
            }

            if (*pszString != END)
            {
                pszString++;
            }

            pszPattern++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\extprog.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    extprog.c

Abstract:

    This module implements all commands that
    execute external programs.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop


#define FLG_GOT_P       0x00000100
#define FLG_GOT_R       0x00000200
#define FLG_DRIVE_MASK  0x000000ff

#define FLG_GOT_Q       0x00000100
#define FLG_GOT_FS      0x00000200
#define FLG_GOT_FAT     0x10000000
#define FLG_GOT_FAT32   0x20000000
#define FLG_GOT_NTFS    0x40000000

LPCWSTR szAutochkExe = L"AUTOCHK.EXE";
LPCWSTR szAutofmtExe = L"AUTOFMT.EXE";

BOOLEAN SawInterimMsgs;
ULONG ChkdskMessageId;

VOID
SpPtDetermineRegionSpace(
    IN PDISK_REGION pRegion
    );

LPWSTR
pRcDoesFileExist(
    IN LPCWSTR PathPart1,
    IN LPCWSTR PathPart2,   OPTIONAL
    IN LPCWSTR PathPart3    OPTIONAL
    );

NTSTATUS
pRcAutochkProgressHandler(
    IN PSETUP_FMIFS_MESSAGE Message
    );



PWSTR
RcLocateImage(
    IN PWSTR ImageName
    )
{
    LPWSTR BinaryName;
    ULONG i;
    WCHAR buf[ MAX_PATH + 1 ];
    LPWSTR p,s;
    NTSTATUS Status;


    //
    // Locate the binary. First see if we can find it
    // on the setup boot media (boot floppies, ~bt directory, etc).
    // If not, we have to try to grab it from the setup media (CD-ROM,
    // ~ls directory, etc).
    //
    BinaryName = pRcDoesFileExist(
        _CmdConsBlock->BootDevicePath,
        _CmdConsBlock->DirectoryOnBootDevice,
        ImageName
        );
    if (BinaryName) {
        return BinaryName;
    }

    //
    // look for a local $WIN_NT$.~LS source
    //

    for (i=0; i<26; i++) {
        BOOLEAN OnRemovableMedia;

        swprintf( buf, L"\\??\\%c:",i+L'A');
        Status = RcIsFileOnRemovableMedia(buf, &OnRemovableMedia);

        if (NT_SUCCESS(Status) && !OnRemovableMedia) {
            BinaryName = pRcDoesFileExist(
                buf,
                ((!IsNEC_98) ? L"\\$win_nt$.~ls\\i386\\" : L"\\$win_nt$.~ls\\nec98\\"),
                ImageName
                );
            if (BinaryName) {
                return BinaryName;
            }
        }
    }

    if (BinaryName == NULL) {
        //
        // look for the CDROM drive letter
        //
        for (i=0; i<26; i++) {
            swprintf( buf, L"\\??\\%c:",i+L'A');
            if (RcIsFileOnCDROM(buf) == STATUS_SUCCESS) {
                BinaryName = pRcDoesFileExist(
                    buf,
                    ((!IsNEC_98) ? L"\\i386\\" : L"\\nec98\\"),
                    ImageName
                    );
                if (BinaryName) {
                    return BinaryName;
                }
            }
        }
    }

    //
    // failed to find the image on any installation media
    //

    if (InBatchMode) {
        RcMessageOut( MSG_FAILED_COULDNT_FIND_BINARY_ANYWHERE, ImageName );
        return NULL;
    }

    //
    // ask the user to type its location
    //
    RcMessageOut( MSG_COULDNT_FIND_BINARY, ImageName );

    //
    // prepend \\??\\ to it
    //
    swprintf( buf, L"\\??\\");
    RcLineIn( &(buf[4]), MAX_PATH-4 );

    //
    // append the name of the program if it exists
    //
    BinaryName = pRcDoesFileExist( buf, NULL, ImageName );
    if (BinaryName == NULL) {
        //
        // assume that if it failed, the user just specified the entire file path
        //
        BinaryName = pRcDoesFileExist( buf, NULL, NULL );
        //
        // if we still can't find it, print an error, return.
        //
        if (BinaryName == NULL) {
            RcMessageOut( MSG_FAILED_COULDNT_FIND_BINARY_ANYWHERE, ImageName );
            return NULL;
        }
    }

    return BinaryName;
}


ULONG
RcCmdChkdsk(
    IN PTOKENIZED_LINE TokenizedLine
    )

/*++

Routine Description:

    Top-level routine supporting the chkdsk command in the setup diagnostic
    command interpreter.

    Chkdsk may be specified entirely without arguments, in which case the
    current drive is implied with no switches. Optionally, the following
    switches are accepted, and passed directly to autochk.

    /p - check even if not dirty
    /r - recover (implies /p)
    x: - drive letter of drive to check

    In addition we always pass /t which causes autochk to call setup's
    IOCTL_SETUP_FMIFS_MESSAGE to communicate progress.

Arguments:

    TokenizedLine - supplies structure built by the line parser describing
        each string on the line as typed by the user.

Return Value:

    None.

--*/

{
    PLINE_TOKEN Token;
    LPCWSTR Arg;
    unsigned Flags;
    BOOLEAN b;
    BOOLEAN doHelp;
    LPWSTR ArgList,p,q,s,AutochkBinary;
    ULONG AutochkStatus;
    ULONG i;
    NTSTATUS Status = 0;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES Obja;
    ULONG n;
    LARGE_INTEGER Time;
    PFILE_FS_VOLUME_INFORMATION VolumeInfo;
    PFILE_FS_SIZE_INFORMATION SizeInfo;
    LPWSTR Numbers[5];
    WCHAR buf[ MAX_PATH + 1 ];

    //
    // There should be at least one token for CHKDSK itself.
    // There could be additional ones for arguments.
    //
    ASSERT(TokenizedLine->TokenCount >= 1);

    if (RcCmdParseHelp( TokenizedLine, MSG_CHKDSK_HELP )) {
        return 1;
    }

    Flags = 0;
    b = TRUE;
    doHelp = FALSE;
    Token = TokenizedLine->Tokens->Next;
    while(b && Token) {

        Arg = Token->String;

        if((Arg[0] == L'-') || (Arg[0] == L'/')) {
            switch(Arg[1]) {

            case L'p':
            case L'P':
                if(Flags & FLG_GOT_P) {
                    b = FALSE;
                } else {
                    Flags |= FLG_GOT_P;
                }
                break;

            case L'r':
            case L'R':
                if(Flags & FLG_GOT_R) {
                    b = FALSE;
                } else {
                    Flags |= FLG_GOT_R;
                }
                break;
            default:
                b = FALSE;
                break;
            }
        } else {
            //
            // Not arg, could be drive spec
            //
            if(RcIsAlpha(Arg[0]) && (Arg[1] == L':') && !Arg[2]) {
                if(Flags & FLG_DRIVE_MASK) {
                    b = FALSE;
                } else {
                    Flags |= (unsigned)RcToUpper(Arg[0]);
                }
            } else {
                b = FALSE;
            }
        }

        Token = Token->Next;
    }

    if(!b) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    //
    // Check drive.
    //
    if(!(Flags & FLG_DRIVE_MASK)) {
        Flags |= (unsigned)RcGetCurrentDriveLetter();
    }
    if(!RcIsDriveApparentlyValid((WCHAR)(Flags & FLG_DRIVE_MASK))) {
        RcMessageOut(MSG_INVALID_DRIVE);
        return 1;
    }

    //
    // find the autochk.exe image
    //

    AutochkBinary = RcLocateImage( (PWSTR)szAutochkExe );
    if (AutochkBinary == NULL) {
        return 1;
    }

    //
    // Get volume info and print initial report.
    // NOTE: we do NOT leave the handle open, even though we may need it
    // later, since that could interfere with autochk's ability to
    // check the disk!
    //
    p = SpMemAlloc(100);
    swprintf(p,L"\\DosDevices\\%c:\\",(WCHAR)(Flags & FLG_DRIVE_MASK));
    INIT_OBJA(&Obja,&UnicodeString,p);

    Status = ZwOpenFile(
                &Handle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE
                );

    SpMemFree(p);

    if(NT_SUCCESS(Status)) {

        VolumeInfo = _CmdConsBlock->TemporaryBuffer;

        Status = ZwQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    VolumeInfo,
                    _CmdConsBlock->TemporaryBufferSize,
                    FileFsVolumeInformation
                    );

        ZwClose(Handle);

        if(NT_SUCCESS(Status)) {
            //
            // To mimic chkdsk running from cmd.exe, we want to print out
            // a nice 2 lines like
            //
            //      Volume VOLUME_LABEL created DATE TIME
            //      Volume Serial Number is xxxx-xxxx
            //
            // But, some volumes won't have labels and some file systems
            // don't support recording the volume creation time. If there's
            // no volume creation time, we don't print out the first time
            // at all. If there is a volume creation time, we are careful
            // to distinguish the cases where there's a label and where
            // there's no label.
            //
            // The serial number is always printed.
            //
            n = VolumeInfo->VolumeSerialNumber;
            if(Time.QuadPart = VolumeInfo->VolumeCreationTime.QuadPart) {
                //
                // Save values since we need to recycle the temporary buffer.
                //
                VolumeInfo->VolumeLabel[VolumeInfo->VolumeLabelLength/sizeof(WCHAR)] = 0;
                p = SpDupStringW(VolumeInfo->VolumeLabel);

                RcFormatDateTime(&Time,_CmdConsBlock->TemporaryBuffer);
                q = SpDupStringW(_CmdConsBlock->TemporaryBuffer);

                RcMessageOut(
                    *p ? MSG_CHKDSK_REPORT_1a : MSG_CHKDSK_REPORT_1b,
                    q,
                    p
                    );

                SpMemFree(q);
                SpMemFree(p);
            }

            RcMessageOut(MSG_CHKDSK_REPORT_2,n >> 16,n & 0xffff);
        }
    }

    //
    // Build argument list.
    //
    ArgList = SpMemAlloc(200);
    p = ArgList;
    *p++ = L'-';
    *p++ = L't';
    if(Flags & FLG_GOT_P) {
        *p++ = L' ';
        *p++ = L'-';
        *p++ = L'p';
    }
    if(Flags & FLG_GOT_R) {
        *p++ = L' ';
        *p++ = L'-';
        *p++ = L'r';
    }
    *p++ = L' ';
    wcscpy(p,L"\\DosDevices\\");
    p += wcslen(p);
    *p++ = (WCHAR)(Flags & FLG_DRIVE_MASK);
    *p++ = L':';
    *p = 0;

    if (!InBatchMode) {
        SpSetAutochkCallback(pRcAutochkProgressHandler);
        SawInterimMsgs = FALSE;
        ChkdskMessageId = MSG_CHKDSK_CHECKING_1;
    }
    Status = SpExecuteImage(AutochkBinary,&AutochkStatus,1,ArgList);
    if (!InBatchMode) {
        SpSetAutochkCallback(NULL);
    }

    if(NT_SUCCESS(Status)) {

        switch(AutochkStatus) {

        case 0:     // success

            if(SawInterimMsgs) {
                //
                // Success, and chkdsk actually ran.
                //
                RcMessageOut(MSG_CHKDSK_COMPLETE);
            } else {
                //
                // Success, but it doesn't seem like we actually did much.
                // Tell the user something meaningful.
                //
                RcMessageOut(MSG_VOLUME_CLEAN);
            }
            break;

        case 3:     // serious error, not fixed

            RcTextOut(L"\n");
            RcMessageOut(MSG_VOLUME_CHECKED_BUT_HOSED);
            break;

        default:    // errs fixed, also happens when no disk in drive or unsupported fs

            if(SawInterimMsgs) {
                if(Flags & FLG_GOT_R) {
                    RcMessageOut(MSG_VOLUME_CHECKED_AND_FIXED);
                } else {
                    RcMessageOut(MSG_VOLUME_CHECKED_AND_FOUND);
                }
            } else {
                RcMessageOut(MSG_CHKDSK_UNSUPPORTED_VOLUME);
            }
            break;
        }

        //
        // Get size info for additional reporting
        //
        p = SpMemAlloc(100);
        swprintf(p,L"\\DosDevices\\%c:\\",(WCHAR)(Flags & FLG_DRIVE_MASK));
        INIT_OBJA(&Obja,&UnicodeString,p);

        Status = ZwOpenFile(
                    &Handle,
                    FILE_READ_ATTRIBUTES,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE
                    );

        SpMemFree(p);

        if(NT_SUCCESS(Status)) {

            SizeInfo = _CmdConsBlock->TemporaryBuffer;

            Status = ZwQueryVolumeInformationFile(
                        Handle,
                        &IoStatusBlock,
                        SizeInfo,
                        _CmdConsBlock->TemporaryBufferSize,
                        FileFsSizeInformation
                        );

            ZwClose(Handle);

            if(NT_SUCCESS(Status)) {

                p = (LPWSTR)((UCHAR *)_CmdConsBlock->TemporaryBuffer + sizeof(FILE_FS_SIZE_INFORMATION));

                //
                // Total disk space, in K
                //
                RcFormat64BitIntForOutput(
                    ((SizeInfo->TotalAllocationUnits.QuadPart * SizeInfo->SectorsPerAllocationUnit) * SizeInfo->BytesPerSector) / 1024i64,
                    p,
                    FALSE
                    );

                Numbers[0] = SpDupStringW(p);

                //
                // Available disk space, in K
                //
                RcFormat64BitIntForOutput(
                    ((SizeInfo->AvailableAllocationUnits.QuadPart * SizeInfo->SectorsPerAllocationUnit) * SizeInfo->BytesPerSector) / 1024i64,
                    p,
                    FALSE
                    );

                Numbers[1] = SpDupStringW(p);

                //
                // Bytes per cluster
                //
                RcFormat64BitIntForOutput(
                    (LONGLONG)SizeInfo->SectorsPerAllocationUnit * (LONGLONG)SizeInfo->BytesPerSector,
                    p,
                    FALSE
                    );

                Numbers[2] = SpDupStringW(p);

                //
                // Total clusters
                //
                RcFormat64BitIntForOutput(
                    SizeInfo->TotalAllocationUnits.QuadPart,
                    p,
                    FALSE
                    );

                Numbers[3] = SpDupStringW(p);

                //
                // Available clusters
                //
                RcFormat64BitIntForOutput(
                    SizeInfo->AvailableAllocationUnits.QuadPart,
                    p,
                    FALSE
                    );

                Numbers[4] = SpDupStringW(p);

                RcMessageOut(
                    MSG_CHKDSK_REPORT_3,
                    Numbers[0],
                    Numbers[1],
                    Numbers[2],
                    Numbers[3],
                    Numbers[4]
                    );

                for(n=0; n<5; n++) {
                    SpMemFree(Numbers[n]);
                }
            }
        }
    } else {
        RcNtError(Status,MSG_VOLUME_NOT_CHECKED);
    }

    SpMemFree(ArgList);
    SpMemFree(AutochkBinary);

    return 1;
}


LPWSTR
pRcDoesFileExist(
    IN LPCWSTR PathPart1,
    IN LPCWSTR PathPart2,   OPTIONAL
    IN LPCWSTR PathPart3    OPTIONAL
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    LPWSTR p;

    wcscpy(_CmdConsBlock->TemporaryBuffer,PathPart1);
    if(PathPart2) {
        SpConcatenatePaths(_CmdConsBlock->TemporaryBuffer,PathPart2);
    }
    if(PathPart3) {
        SpConcatenatePaths(_CmdConsBlock->TemporaryBuffer,PathPart3);
    }

    INIT_OBJA(&Obja,&UnicodeString,_CmdConsBlock->TemporaryBuffer);

    Status = ZwOpenFile(
                &Handle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_NON_DIRECTORY_FILE
                );

    if(NT_SUCCESS(Status)) {
        ZwClose(Handle);
        p = SpDupStringW(_CmdConsBlock->TemporaryBuffer);
    } else {
        p = NULL;
    }

    return(p);
}


NTSTATUS
pRcAutochkProgressHandler(
    IN PSETUP_FMIFS_MESSAGE Message
    )
{
    ULONG Percent;

    //
    // We're getting called in the context of a process other than usetup.exe,
    // which means we have no access to things like the video buffer.
    // In some cases we need to attach to usetup.exe so the right thing happens
    // if we try to access the screen or get keyboard input, etc.
    //

    switch(Message->FmifsPacketType) {

    case FmIfsPercentCompleted:

        //
        // The packet is in user-mode address space, so we need to pull out
        // the percent complete value before attaching to usetup.exe.
        //
        // The bandwidth for communication between autochk and us is very
        // limited. If the drive is clean and is thus not checked, we'll see
        // only a 100% complete message. Thus we have to guess what happened
        // so we can print out something meaningful to the user if the volume
        // appears clean.
        //
        Percent = ((PFMIFS_PERCENT_COMPLETE_INFORMATION)Message->FmifsPacket)->PercentCompleted;
        if(Percent == 100) {
            //
            // Avoid printing 100% if we didn't actually do anything.
            //
            if(!SawInterimMsgs) {
                break;
            }
        } else {
            SawInterimMsgs = TRUE;
        }

        KeAttachProcess(PEProcessToPKProcess(_CmdConsBlock->UsetupProcess));

        if(!Percent) {
            RcMessageOut(ChkdskMessageId);
            ChkdskMessageId = MSG_CHKDSK_CHECKING_2;
        }

        RcMessageOut(MSG_VOLUME_PERCENT_COMPLETE,Percent);
        RcTextOut(L"\r");
        KeDetachProcess();

        break;

    default:

        KdPrint(("SPCMDCON: Unhandled fmifs message type %u\r\n",Message->FmifsPacketType));
        break;
    }

    return(STATUS_SUCCESS);
}


ULONG
RcCmdFormat(
    IN PTOKENIZED_LINE TokenizedLine
    )

/*++

Routine Description:

    Top-level routine supporting the chkdsk command in the setup diagnostic
    command interpreter.

    Chkdsk may be specified entirely without arguments, in which case the
    current drive is implied with no switches. Optionally, the following
    switches are accepted, and passed directly to autochk.

    /p - check even if not dirty
    /r - recover (implies /p)
    x: - drive letter of drive to check

    In addition we always pass /t which causes autochk to call setup's
    IOCTL_SETUP_FMIFS_MESSAGE to communicate progress.

Arguments:

    TokenizedLine - supplies structure built by the line parser describing
        each string on the line as typed by the user.

Return Value:

    None.

--*/

{
    PLINE_TOKEN Token;
    LPCWSTR Arg;
    unsigned Flags;
    BOOLEAN b;
    BOOLEAN doHelp;
    LPWSTR ArgList,p,q,s,AutofmtBinary;
    ULONG AutofmtStatus;
    ULONG i;
    NTSTATUS Status = 0;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES Obja;
    ULONG n;
    LARGE_INTEGER Time;
    PFILE_FS_VOLUME_INFORMATION VolumeInfo;
    PFILE_FS_SIZE_INFORMATION SizeInfo;
    LPWSTR Numbers[5];
    WCHAR buf[ MAX_PATH + 1 ];
    ULONG PartitionOrdinal = 0;
    PDISK_REGION PartitionRegion;
    PWSTR PartitionPath;
    FilesystemType FileSystemType;
    WCHAR   FullPath[MAX_PATH] = {0};
    
    //
    // There should be at least one token for FORMAT itself.
    // There could be additional ones for arguments.
    //
    ASSERT(TokenizedLine->TokenCount >= 1);

    if (RcCmdParseHelp( TokenizedLine, MSG_FORMAT_HELP )) {
        return 1;
    }

    Flags = 0;
    b = TRUE;
    doHelp = FALSE;
    Token = TokenizedLine->Tokens->Next;
    while(b && Token) {

        Arg = Token->String;

        if((Arg[0] == L'-') || (Arg[0] == L'/')) {
            switch(Arg[1]) {

            case L'q':
            case L'Q':
                if(Flags & FLG_GOT_Q) {
                    b = FALSE;
                } else {
                    Flags |= FLG_GOT_Q;
                }
                break;

            case L'f':
            case L'F':
                if (Arg[2] == L's' || Arg[2] == L'S' || Arg[3] == L':') {
                    if(Flags & FLG_GOT_FS) {
                        b = FALSE;
                    } else {
                        s = wcschr(Arg,L' ');
                        if (s) {
                            *s = 0;
                        }
                        if (_wcsicmp(&Arg[4],L"fat") == 0) {
                            Flags |= FLG_GOT_FS;
                            Flags |= FLG_GOT_FAT;
                        } else if (_wcsicmp(&Arg[4],L"fat32") == 0) {
                            Flags |= FLG_GOT_FS;
                            Flags |= FLG_GOT_FAT32;
                        } else if (_wcsicmp(&Arg[4],L"ntfs") == 0) {
                            Flags |= FLG_GOT_FS;
                            Flags |= FLG_GOT_NTFS;
                        } else {
                            b = FALSE;
                        }
                    }
                } else {
                    b = FALSE;
                }
                break;
            default:
                b = FALSE;
                break;
            }
        } else {
            //
            // Not arg, could be drive spec
            //
            if(RcIsAlpha(Arg[0]) && (Arg[1] == L':') && !Arg[2]) {
                if(Flags & FLG_DRIVE_MASK) {
                    b = FALSE;
                } else {
                    Flags |= (unsigned)RcToUpper(Arg[0]);
                }
            } else if (Arg[0] == L'\\') {
                wcscpy(FullPath, Arg);
            } else {
                b = FALSE;
            }
        }

        Token = Token->Next;
    }

    if(!b) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    //
    // Check drive.
    //
    if (FullPath[0] == UNICODE_NULL) {
        if(!(Flags & FLG_DRIVE_MASK)) {
            RcMessageOut(MSG_INVALID_DRIVE);
            return 1;
        }
        
        if(!RcIsDriveApparentlyValid((WCHAR)(Flags & FLG_DRIVE_MASK))) {
            RcMessageOut(MSG_INVALID_DRIVE);
            return 1;
        }
    }        

    //
    // we don't allow formatting removable media
    //
    if (FullPath[0] == UNICODE_NULL) {
        swprintf(TemporaryBuffer, L"\\??\\%c:",(WCHAR)(Flags & FLG_DRIVE_MASK));        
    } else {
        wcscpy(TemporaryBuffer, FullPath);
    }

    Status = RcIsFileOnRemovableMedia(TemporaryBuffer, &b);

    if (NT_SUCCESS(Status) && b) {
        RcMessageOut(MSG_CANNOT_FORMAT_REMOVABLE);
        return 1;
    }

    //
    // Locate the autofmt.exe binary
    //

    AutofmtBinary = RcLocateImage( (PWSTR)szAutofmtExe );
    if (AutofmtBinary == NULL) {
        return 1;
    }

    if (!InBatchMode) {
        LPWSTR YesNo;
        WCHAR Text[3];
        YesNo = SpRetreiveMessageText( ImageBase, MSG_YESNO, NULL, 0 );
        if( YesNo ) {
            p = TemporaryBuffer;
            *p++ = (WCHAR)(Flags & FLG_DRIVE_MASK);
            *p++ = L':';
            *p = 0;
            RcMessageOut( MSG_FORMAT_HEADER, TemporaryBuffer );
            if( RcLineIn( Text, 2 ) ) {
                if( (Text[0] == YesNo[2]) || (Text[0] == YesNo[3]) ) {
                    //
                    // the answer was no
                    //
                    return 1;
                }
            }
            SpMemFree( YesNo );
        }
    }

    //
    // get the partion region
    //
    if (FullPath[0] == UNICODE_NULL) {
        p = TemporaryBuffer;
        *p++ = (WCHAR)(Flags & FLG_DRIVE_MASK);
        *p++ = L':';
        *p = 0;
        PartitionRegion = SpRegionFromDosName(TemporaryBuffer);

        //
        // Make SURE it's not partition0!  The results of formatting partition0
        // are so disasterous that this warrants a special check.
        //
        PartitionOrdinal = SpPtGetOrdinal(PartitionRegion,PartitionOrdinalCurrent);

        //
        // Get the device path of the partition to format
        //
        SpNtNameFromRegion(
            PartitionRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );
    } else {
        PartitionRegion = SpRegionFromNtName(FullPath, PartitionOrdinalCurrent);

        if (PartitionRegion) {            
            PartitionOrdinal = SpPtGetOrdinal(PartitionRegion, PartitionOrdinalCurrent);
        } else {
            PartitionOrdinal = 0;   // will err out below
        }            
        
        wcscpy(TemporaryBuffer, FullPath);
    }

    if(!PartitionOrdinal) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        
        return 1;
    }

    //
    // Build argument list.
    //
    ArgList = SpMemAlloc(4096);
    p = ArgList;
    wcscpy(p,TemporaryBuffer);

    
    p += wcslen(p);
    *p++ = L' ';
    *p++ = L'-';
    *p++ = L't';
    *p++ = L' ';
    if(Flags & FLG_GOT_Q) {
        *p++ = L'-';
        *p++ = L'Q';
        *p++ = L' ';
    }
    if(Flags & FLG_GOT_FS) {
        if (Flags & FLG_GOT_FAT) {
            wcscpy(p,L"/fs:fat ");
            FileSystemType = FilesystemFat;
        } else if (Flags & FLG_GOT_FAT32) {
            wcscpy(p,L"/fs:fat32 ");
            FileSystemType = FilesystemFat32;
        } else if (Flags & FLG_GOT_NTFS) {
            wcscpy(p,L"/fs:ntfs ");
            FileSystemType = FilesystemNtfs;
        }
        p += wcslen(p);
    } else {
        FileSystemType = FilesystemNtfs;
        wcscpy(p,L"/fs:ntfs ");
        p += wcslen(p);
    }
    *p = 0;

    if (!InBatchMode) {
        SpSetAutochkCallback(pRcAutochkProgressHandler);
        SawInterimMsgs = FALSE;
        ChkdskMessageId = MSG_FORMAT_FORMATTING_1;
    }
    Status = SpExecuteImage(AutofmtBinary,&AutofmtStatus,1,ArgList);
    if (!InBatchMode) {
        SpSetAutochkCallback(NULL);
    }

    if(!NT_SUCCESS(Status)) {
        RcNtError(Status,MSG_VOLUME_NOT_FORMATTED);
    } else {
        PartitionRegion->Filesystem = FileSystemType;
        SpFormatMessage( PartitionRegion->TypeName,
                         sizeof(PartitionRegion->TypeName),
                         SP_TEXT_FS_NAME_BASE + PartitionRegion->Filesystem );
        //
        //  Reset the volume label
        //
        PartitionRegion->VolumeLabel[0] = L'\0';
        SpPtDetermineRegionSpace( PartitionRegion );        
    }

    SpMemFree(ArgList);
    SpMemFree(AutofmtBinary);

    return 1;
}


typedef struct _FDISK_REGION {
    PWSTR DeviceName;
    PDISK_REGION Region;
    ULONGLONG MaxSize;
    ULONGLONG RequiredSize;
} FDISK_REGION, *PFDISK_REGION;


BOOL
RcFdiskRegionEnum(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Context
    )
{
    WCHAR DeviceName[256];
    PWSTR s;
    PFDISK_REGION FDiskRegion = (PFDISK_REGION)Context;
    ULONGLONG RegionSizeMB;

    //
    // skip container partitions & continue on
    //
    if (Region && (Region->ExtendedType == EPTContainerPartition)) {
        return TRUE; 
    }
    
    SpNtNameFromRegion(Region,
        DeviceName,
        sizeof(DeviceName),
        PartitionOrdinalCurrent);
        
    s = wcsrchr(DeviceName,L'\\');
    
    if (s == NULL) {
        return TRUE;
    }

    *s = 0;

    RegionSizeMB = SpPtSectorCountToMB(Disk->HardDisk, Region->SectorCount);

    if ((RegionSizeMB > FDiskRegion->MaxSize) &&
        (RegionSizeMB >= FDiskRegion->RequiredSize) &&
        (Region->PartitionedSpace == FALSE) &&
        (_wcsicmp(DeviceName, FDiskRegion->DeviceName) == 0)){
        
        FDiskRegion->MaxSize = RegionSizeMB;
        FDiskRegion->Region = Region;

        //
        // This partition meets the criteria we were searching for,
        // return FALSE to stop the enumeration
        //

        return FALSE;
    }

    //
    // This partition does not meet the criteria, return TRUE to continue
    // the enumeration.
    //

    return TRUE;
}


ULONG
RcCmdFdisk(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    NTSTATUS        Status;
    PDISK_REGION    InstallRegion;
    PDISK_REGION    SystemPartitionRegion;
    PWCHAR          DeviceName;
    PWCHAR          Action;
    PWCHAR          Operand;
    ULONG           DesiredMB;
    FDISK_REGION    FDiskRegion;
    UNICODE_STRING  UnicodeString;
    PWCHAR          szPartitionSize = 0;
    BOOLEAN         bPrompt = TRUE;

    if (RcCmdParseHelp( TokenizedLine, MSG_FDISK_HELP )) {
        return 1;
    }

    if (TokenizedLine->TokenCount >= 3) {
        Action = TokenizedLine->Tokens->Next->String;
        DeviceName = TokenizedLine->Tokens->Next->Next->String;

        if (_wcsicmp(Action,L"/delete")==0) {
        
            if (DeviceName[1] == L':') {
                InstallRegion = SpRegionFromDosName(DeviceName);
            } else {
                InstallRegion = SpRegionFromNtName(DeviceName,0);
            }

            if (InstallRegion == NULL) {
                RcMessageOut(MSG_SYNTAX_ERROR);
                return 1;
            }

            if (InBatchMode)
                bPrompt = FALSE;
            else
                pRcCls();
            
            SpPtDoDelete(InstallRegion, DeviceName, bPrompt);

            if (bPrompt)
                pRcCls();

        } else if (_wcsicmp(Action,L"/add")==0) {        
            DesiredMB = 0;
            if (TokenizedLine->TokenCount >= 4) {
                szPartitionSize = TokenizedLine->Tokens->Next->Next->Next->String;
                RtlInitUnicodeString(&UnicodeString, szPartitionSize);
                RtlUnicodeStringToInteger(&UnicodeString, 10, &DesiredMB);
            }
            
            FDiskRegion.DeviceName = DeviceName;
            FDiskRegion.Region = NULL;
            FDiskRegion.MaxSize = 0;
            FDiskRegion.RequiredSize = DesiredMB;
            SpEnumerateDiskRegions( (PSPENUMERATEDISKREGIONS)RcFdiskRegionEnum, (ULONG_PTR)&FDiskRegion );

            if (FDiskRegion.Region) {
                // try to create the partition of the given size
                if (!SpPtDoCreate(FDiskRegion.Region,NULL,TRUE,DesiredMB,0,FALSE)) {
                    pRcCls();
                    // ask the user to give correct (aligned) size showing him the limits
                    if(!SpPtDoCreate(FDiskRegion.Region,NULL,FALSE,DesiredMB,0,FALSE)) {
                        pRcCls();
                        RcMessageOut(MSG_FDISK_INVALID_PARTITION_SIZE, szPartitionSize, DeviceName);                    
                    } else {
                        pRcCls();
                    }                        
                }
            } else {
                // could not find a region to create the partition of the specified size
                RcMessageOut(MSG_FDISK_INVALID_PARTITION_SIZE, szPartitionSize, DeviceName);
            }
        }

        if(SelectedInstall != NULL) {
            //
            // Get the Region pointer for the region we have logged into as it may
            // may have changed after operations on the Disk partition.
            //
            SelectedInstall->Region = SpRegionFromNtName(
                                                SelectedInstall->NtNameSelectedInstall,
                                                PartitionOrdinalCurrent
                                                );

            //
            // If we do not get a region corresponding to the Selected Install region name 
            // we set the name of the selected region to 0.
            // (this can occur if the partition we have logged in is deleted)
            //
            if (!SelectedInstall->Region)
                    SelectedInstall->NtNameSelectedInstall[0] = 0;
        }

        RcInitializeCurrentDirectories();
        
        return 1;
    }

    pRcCls();

    Status = SpPtPrepareDisks(
        _CmdConsBlock->SifHandle,
        &InstallRegion,
        &SystemPartitionRegion,
        _CmdConsBlock->SetupSourceDevicePath,
        _CmdConsBlock->DirectoryOnSetupSource,
        FALSE
        );
    if(!NT_SUCCESS(Status)) {
        KdPrint(("SPCMDCON: SpPtPrepareDisks() failes, err=%08x\r\n",Status));
        pRcCls();
        return 1;
    }

    if(SelectedInstall != NULL) {
        //
        // Get the Region pointer for the region we have logged into as it may
        // may have changed after operations on the Disk partition.
        //
        SelectedInstall->Region = SpRegionFromNtName(
                                                SelectedInstall->NtNameSelectedInstall,
                                                PartitionOrdinalCurrent
                                                );

        //
        // If we do not get a region corresponding to the Selected Install region name 
        // we set the name of the selected region to 0.
        // (this can occur if the partition we have logged in is deleted)
        //
        if (!SelectedInstall->Region)
                SelectedInstall->NtNameSelectedInstall[0] = 0;
    }

    RcInitializeCurrentDirectories();
    pRcCls();

    return 1;
}


ULONG
RcCmdMakeDiskRaw(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    BOOLEAN Successfull = FALSE;

#ifndef OLD_PARTITION_ENGINE

    if (TokenizedLine->TokenCount > 1) {
        WCHAR           Buffer[256];
        UNICODE_STRING  UniStr;
        ULONG DriveIndex = -1;

        RtlInitUnicodeString(&UniStr, TokenizedLine->Tokens->Next->String);

        if (NT_SUCCESS(RtlUnicodeStringToInteger(&UniStr, 10, &DriveIndex))) {
            BOOLEAN Confirmed = FALSE;
            
            swprintf(Buffer, 
                    L"Convert %d drive to raw  [y/n] ? ", 
                    DriveIndex);

            RcTextOut(Buffer);
            
            if( RcLineIn(Buffer,2) ) {
                if((Buffer[0] == L'y') || (Buffer[0] == L'Y')) {
                    //
                    // Wants to do it.
                    //
                    Confirmed = TRUE;
                }
            }

            if (Confirmed) {                    
                Successfull = SpPtMakeDiskRaw(DriveIndex);       
            } else {
                Successfull = TRUE;
            }                
        }            
    }

    if (!Successfull) {
        RcTextOut(L"Either MakeDiskRaw [disk-number] syntax is wrong or the command failed");
    }
#endif    
    
    return 1;
}

NTSTATUS
RcDisplayNtInstalls(
    IN PLIST_ENTRY  NtInstalls
    )
/*++

Routine Description:

    Do a simple display of the NT Installs described in
    the NtInstalls linked list
    
Arguments:

                    
    NtInstalls   - Linked List containing description of NT installs
    
Return:

    STATUS_SUCCESS  if nt installs were successfully displayed
    
    otherwise, error status    
   

--*/
{
    PLIST_ENTRY         Next;
    PNT_INSTALLATION    NtInstall;
    
    //
    // make sure we have something to display
    //
    ASSERT(NtInstalls);
    if (!NtInstalls) {
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_ERROR_LEVEL, 
           "SPCMDCON: RcDisplayNtInstalls: incoming NT Installs list is NULL\r\n"
           ));
        return STATUS_INVALID_PARAMETER;
    }

    ASSERT(! IsListEmpty(NtInstalls));
    if(IsListEmpty(NtInstalls)) {
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_INFO_LEVEL, 
           "SPCMDCON: RcDisplayNtInstalls: incoming NT Installs list is empty\r\n"
           ));
        return STATUS_NOT_FOUND;
    }
    
    pRcEnableMoreMode();

    //
    // show how many installs we have 
    //
    RcMessageOut(MSG_BOOTCFG_SCAN_RESULTS_TITLE,
                 InstallCountFullScan
                 );
    
    //
    // iterate through the database and report
    //
    Next = NtInstalls->Flink;
    while ((UINT_PTR)Next != (UINT_PTR)NtInstalls) {
        NtInstall = CONTAINING_RECORD( Next, NT_INSTALLATION, ListEntry );
        Next = NtInstall->ListEntry.Flink;
    
        RcMessageOut(MSG_BOOTCFG_SCAN_RESULTS_ENTRY,
                     NtInstall->InstallNumber,
                     NtInstall->DriveLetter,
                     NtInstall->Path
                     );
    }
    
    pRcDisableMoreMode();

    return STATUS_SUCCESS;
}


NTSTATUS
RcPerformFullNtInstallsScan(
    VOID
    )
/*++

Routine Description:

    Convenience routine for launching a full scan for NT Installs
    
Arguments:

    none
    
Return:

    STATUS_SUCCESS      if scan was successful
    
    otherwise, error status
        
--*/
{
    PRC_SCAN_RECURSION_DATA     RecursionData;

    //
    // the list should be empty before we do this.  If
    // someone wants to rescan the disk, they should
    // empty the list first
    //
    ASSERT(IsListEmpty(&NtInstallsFullScan));
    if (! IsListEmpty(&NtInstallsFullScan)) {
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_ERROR_LEVEL, 
           "SPCMDCON: RcPerformFullNtInstallsScan: NTInstallsFullScan list is NOT empty\r\n"
           ));
        return STATUS_UNSUCCESSFUL;
    }
    ASSERT(InstallCountFullScan == 0);
    if (InstallCountFullScan != 0) {
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_ERROR_LEVEL, 
           "SPCMDCON: RcPerformFullNtInstallsScan: NTInstallsFullScan count > 0\r\n"
           ));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Let the user know what we are doing and that 
    // this could take a while
    //
    RcMessageOut(MSG_BOOTCFG_SCAN_NOTIFICATION);

    //
    // do a depth first search through directory tree
    // and store the install info
    //

    //
    // Initialize the structure that will be maintained during
    // the recursive enumeration of the directories.
    //
    RecursionData = SpMemAlloc(sizeof(RC_SCAN_RECURSION_DATA));
    RtlZeroMemory(RecursionData, sizeof(RC_SCAN_RECURSION_DATA));

    //
    // Build up a menu of partitions and free spaces.
    //
    SpEnumerateDiskRegions(RcScanDisksForNTInstallsEnum,
                           (ULONG_PTR)RecursionData
                           );

    //
    // there should be at least one install, otherwise
    // there is not point in fixing the boot config
    //
    if(InstallCountFullScan == 0) {
        
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_ERROR_LEVEL, 
           "SPCMDCON: RcPerformFullNtInstallsScan: Full Scan returned 0 hits!\r\n"
           ));

        RcMessageOut(MSG_BOOTCFG_SCAN_FAILURE);
        
        ASSERT(InstallCountFullScan > 0);

        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RcGetBootEntries(
    IN PLIST_ENTRY  BootEntries,
    IN PULONG       BootEntriesCnt  
    )
/*++

Routine Description:

   Get a list of current boot entries in the boot list
    
Arguments:

    BootEntriesCnt  - the number of boot entries displayed
              
Return:

    STATUS_SUCCESS  if successful and BootEntriesCnt is valid
    
    otherwise, error status
    
--*/
{
    NTSTATUS        status;

    ASSERT(BootEntries);
    ASSERT(IsListEmpty(BootEntries));
    if (! IsListEmpty(BootEntries)) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SPCMDCON: RcGetBootEntries: BootEntries list is not empty\r\n"
                    ));

        return STATUS_INVALID_PARAMETER;
    }

    ASSERT(BootEntriesCnt);
    if (! BootEntriesCnt) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SPCMDCON: RcGetBootEntries: BootEntriesCnt is NULL\r\n"
                    ));

        return STATUS_INVALID_PARAMETER;
    }

    //
    // get an export of the loaded boot entries
    //
    status = SpExportBootEntries(BootEntries,
                                 BootEntriesCnt
                                );
    if (! NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SPCMDCON: RcGetBootEntries: failed to get export list: Status = %lx\r\n",
                   status
                    ));
        return status;
    }

    if (IsListEmpty(BootEntries)) {
        
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_INFO_LEVEL, 
           "SPCMDCON: RcGetBootEntries: boot entries exported list is empty\r\n"
           ));

        status = STATUS_NOT_FOUND;
    }

    return status;
}

NTSTATUS
RcDisplayBootEntries(
    IN PLIST_ENTRY  BootEntries,
    IN ULONG        BootEntriesCnt  
    )
/*++

Routine Description:

   Display the list of current boot entries in the boot list
    
Arguments:

    BootEntriesCnt  - the number of boot entries displayed
              
Return:

    STATUS_SUCCESS  if successful and BootEntriesCnt is valid
    
    otherwise, error status
    
--*/
{
    PSP_EXPORTED_BOOT_ENTRY BootEntry;
    PLIST_ENTRY             Next;
    ULONG                   i;

    ASSERT(BootEntries);
    ASSERT(! IsListEmpty(BootEntries));
    if (IsListEmpty(BootEntries)) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SPCMDCON: RcDisplayBootEntries: BootEntries list is empty\r\n"
                    ));

        return STATUS_INVALID_PARAMETER;
    }
    
    ASSERT(BootEntriesCnt > 0);
    if (BootEntriesCnt == 0) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SPCMDCON: RcDisplayBootEntries: BootEntriesCnt is 0\r\n"
                    ));

        return STATUS_INVALID_PARAMETER;
    }

    pRcEnableMoreMode();

    RcMessageOut(MSG_BOOTCFG_EXPORT_HEADER,
                 BootEntriesCnt
                 );

    i=0;
            
    Next = BootEntries->Flink;
    while ((UINT_PTR)Next != (UINT_PTR)BootEntries) {
        BootEntry = CONTAINING_RECORD( Next, SP_EXPORTED_BOOT_ENTRY, ListEntry );
        Next = BootEntry->ListEntry.Flink;
    
        RcMessageOut(MSG_BOOTCFG_EXPORT_ENTRY,
                     i+1,
                     BootEntry->LoadIdentifier,
                     BootEntry->OsLoadOptions,
                     BootEntry->DriverLetter,
                     BootEntry->OsDirectory
                    );
    
        i++;
    }

    ASSERT(i == BootEntriesCnt);

    pRcDisableMoreMode();

    return STATUS_SUCCESS;
}

RcGetAndDisplayBootEntries(
    IN  ULONG    NoEntriesMessageId,
    OUT PULONG   BootEntriesCnt       OPTIONAL
    )
/*++

Routine Description:

    Get and Display the boot entries currently in the boot list
    
Arguments:

    NoEntriesMessageId  - the message id of the message that should be
                          displayed if there are no boot entries
    BootEntriesCnt      - on exit and if not NULL, points to the # of
                          boot entries displayed                        
    
Return:

    STATUS_SUCCESS  if nt installs were successfully displayed
                    and BootEntriesCnt is valid
                    
    otherwise, error status    
   

--*/
{
    LIST_ENTRY          BootEntries;
    ULONG               cnt;
    NTSTATUS            status;

    if (BootEntriesCnt) {
        *BootEntriesCnt = 0;
    }

    InitializeListHead( &BootEntries );

    //
    // get the boot entries export 
    //
    status = RcGetBootEntries(&BootEntries,
                              &cnt
                              );

    //
    // if there are no boot entries to choose as default, return
    //
    if (status == STATUS_NOT_FOUND) {

        RcMessageOut(NoEntriesMessageId);

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_INFO_LEVEL, 
                   "SPCMDCON: RcCmdBootCfg:(list) no boot entries found: Status = %lx\r\n",
                   status
                   ));

        return status;
    } else if (! NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_INFO_LEVEL, 
                   "SPCMDCON: RcCmdBootCfg:(list) failed to get boot entries: Status = %lx\r\n",
                   status
                   ));

        return status;
    }

    status = RcDisplayBootEntries(&BootEntries,
                                  cnt
                                  );
    if (! NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_INFO_LEVEL, 
                   "SPCMDCON: RcCmdBootCfg:(list) failed to display boot entries: Status = %lx\r\n",
                   status
                   ));

        return status;
    }

    status = SpFreeExportedBootEntries(&BootEntries, 
                                       cnt
                                       );
    if (! NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_INFO_LEVEL, 
                   "SPCMDCON: RcCmdBootCfg:(list) failed freeing export list: Status = %lx\r\n",
                   status
                   ));

    }

    //
    // send out the boot entries count if the user wants it
    //
    if (BootEntriesCnt != NULL) {
        *BootEntriesCnt = cnt;
    }

    return status;
}


ULONG
RcCmdBootCfg(
    IN PTOKENIZED_LINE TokenizedLine
    )
/*++

Routine Description:

    Provides support for managing boot configuration
    
Arguments:

    (command console standard args)
    
Return:

    routine always returns 1 for cmdcons. 
    
    errors are handled through messaging
    
--*/
{
    PWCHAR          Action;
    PWCHAR          Operand;
    BOOLEAN         bPrompt;
    PWCHAR          DeviceName;
    PDISK_REGION    InstallRegion;
    NTSTATUS        status;
    
    if (RcCmdParseHelp( TokenizedLine, MSG_BOOTCFG_HELP )) {
        return 1;
    }

    bPrompt = (InBatchMode ? FALSE : TRUE);
    
    if (TokenizedLine->TokenCount >= 2) {

        Action = TokenizedLine->Tokens->Next->String;

        //
        // turn the redirect switches off in the boot config
        //
        if (_wcsicmp(Action,L"/disableems")==0) {

            status = SpSetRedirectSwitchMode(DisableRedirect,
                                              NULL,
                                              NULL
                                              );
            if (NT_SUCCESS(status)) {
                
                RcMessageOut(MSG_BOOTCFG_DISABLEREDIRECT_SUCCESS);

            } else {

                RcMessageOut(MSG_BOOTCFG_REDIRECT_FAILURE_UPDATING);
            
            }

            return 1;
        }

        //
        // manage the redirect switches
        //
        if (_wcsicmp(Action,L"/ems")==0 && (TokenizedLine->TokenCount >= 3)) {
            
            PWSTR       portU;
            PCHAR       port;
            PWSTR       baudrateU;
            PCHAR       baudrate;
            ULONG       size;
            BOOLEAN     setBaudRate;

            //
            // setting the baudrate info is optional
            //
            setBaudRate = FALSE;
            baudrateU   = NULL;
            baudrate    = NULL;

            //
            // get the redirect port (or useBiosSettings)
            //
            portU = SpDupStringW(TokenizedLine->Tokens->Next->Next->String);

            //
            // convert the argument to a char string
            //
            size = wcslen(portU)+1;
            port = SpMemAlloc(size);
            ASSERT(port);

            status = RtlUnicodeToMultiByteN(
                                            port,
                                            size,
                                            NULL,
                                            portU,
                                            size*sizeof(WCHAR)
                                            );
            ASSERT(NT_SUCCESS(status));
            if (! NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_SETUP_ID, 
                           DPFLTR_INFO_LEVEL, 
                           "SPCMDCON: RcCmdBootCfg:(redirect) failed unicode conversion: Status = %lx\r\n"
                           ));
                return 1;
            }
            
            //
            // if there is another arg, take it as the baudrate
            // otherwise don't worry about including any baudrate paramters
            //
            if (TokenizedLine->TokenCount >= 4) {

                baudrateU = SpDupStringW(TokenizedLine->Tokens->Next->Next->Next->String);

                //
                // convert the argument to a char string
                //
                size = wcslen(baudrateU)+1;
                baudrate = SpMemAlloc(size);
                ASSERT(baudrate);

                status = RtlUnicodeToMultiByteN(
                                                baudrate,
                                                size,
                                                NULL,
                                                baudrateU,
                                                size*sizeof(WCHAR)
                                                );
                ASSERT(NT_SUCCESS(status));
                if (! NT_SUCCESS(status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, 
                               DPFLTR_INFO_LEVEL, 
                               "SPCMDCON: RcCmdBootCfg:(redirect) failed unicode conversion: Status = %lx\r\n",
                               status
                               ));
                    return 1;
                }

                setBaudRate = TRUE;

            } 
            
            //
            // update both the port and baudrate redirect settings
            //
            status = SpSetRedirectSwitchMode(UseUserDefinedRedirectAndBaudRate,
                                             port,
                                             (setBaudRate ? baudrate : NULL)
                                             );
            //
            // display the appropriate message based on what we set
            //
            if (NT_SUCCESS(status)) {
                if (setBaudRate) {
                    
                    RcMessageOut(MSG_BOOTCFG_ENABLE_REDIRECT_SUCCESS,
                                 portU,
                                 baudrateU
                                 );
                
                } else {

                    RcMessageOut(MSG_BOOTCFG_ENABLE_REDIRECT_PORT_SUCCESS,
                                 portU
                                 );
                
                }

            } else {
                RcMessageOut(MSG_BOOTCFG_REDIRECT_FAILURE_UPDATING);
            }

            if (baudrateU) {
                SpMemFree(baudrateU);
            }
            if (baudrate) {
                SpMemFree(baudrate);
            }
            SpMemFree(portU);
            SpMemFree(port);
            
            return 1;
        }

        //
        // List the entries in the boot list
        //
        if (_wcsicmp(Action,L"/list")==0) {

            ULONG               BootEntriesCnt;

            //
            // display the current boot list
            //
            status = RcGetAndDisplayBootEntries(MSG_BOOTCFG_LIST_NO_ENTRIES, 
                                                NULL
                                                );
            if (! NT_SUCCESS(status)) {
            
                KdPrintEx((DPFLTR_SETUP_ID, 
                           DPFLTR_INFO_LEVEL, 
                           "SPCMDCON: RcCmdBootCfg:(list) failed to list boot entries: Status = %lx\r\n",
                           status
                           ));
            
            }

            return 1;
        }

        //
        // set the default boot entry
        //
        if (_wcsicmp(Action,L"/default")==0) {

            ULONG               BootEntriesCnt;
            ULONG               InstallNumber;
            WCHAR               buffer[3];
            UNICODE_STRING      UnicodeString;
            NTSTATUS            Status;

            //
            // display the current boot list
            //
            status = RcGetAndDisplayBootEntries(MSG_BOOTCFG_DEFAULT_NO_ENTRIES, 
                                                &BootEntriesCnt
                                                );
            if (status == STATUS_NOT_FOUND) {
                
                //
                // no boot entries in the list to set as default
                // this is not an error condition, just return
                //
                return 1;
            
            } else if (! NT_SUCCESS(status)) {
            
                KdPrintEx((DPFLTR_SETUP_ID, 
                           DPFLTR_INFO_LEVEL, 
                           "SPCMDCON: RcCmdBootCfg:(default) failed to list boot entries: Status = %lx\r\n",
                           status
                           ));
            
                return 1;
            
            }

            //
            // get user's install selection
            //
            RcMessageOut(MSG_BOOTCFG_ADD_QUERY);
            RcLineIn(buffer, sizeof(buffer) / sizeof(WCHAR));
            
            if (wcslen(buffer) > 0) {
            
                RtlInitUnicodeString( &UnicodeString, buffer );
                Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &InstallNumber );
                
                if (! NT_SUCCESS(Status) ||
                    !((InstallNumber >= 1) && (InstallNumber <= BootEntriesCnt))) {
            
                    RcMessageOut(MSG_BOOTCFG_INVALID_SELECTION, buffer);
            
                } else {
            
                    //
                    // the user gave us a valid install number, so try to set the default
                    //

                    status = SpSetDefaultBootEntry(InstallNumber);
                    
                    if (NT_SUCCESS(status)) {
                        
                        RcMessageOut(MSG_BOOTCFG_DEFAULT_SUCCESS);
                    
                    } else {

                        KdPrintEx((DPFLTR_SETUP_ID, 
                                   DPFLTR_ERROR_LEVEL, 
                                   "SPCMDCON: RcCmdBootCfg:(default) failed to set default: Status = %lx\r\n",
                                   status
                                   ));

                        RcMessageOut(MSG_BOOTCFG_DEFAULT_FAILURE);
                    
                    }

                }
            }

            return 1;
        }


        //
        // Scan the disks on the machine and report NT installs
        //
        if (_wcsicmp(Action,L"/scan")==0) {
    
            //
            // Ensure that we have the full scan of the disks
            //
            if (IsListEmpty(&NtInstallsFullScan)) {
                status = RcPerformFullNtInstallsScan();
                
                //
                // if there are no boot entries, then return
                //
                if (! NT_SUCCESS(status)) {

                    KdPrintEx((DPFLTR_SETUP_ID, 
                               DPFLTR_ERROR_LEVEL, 
                               "SPCMDCON: RcCmdBootCfg:(scan) full scan return 0 hits: Status = %lx\r\n",
                               status
                               ));

                    return 1;
                }
            }

            //
            // display discovered installs
            //
            status = RcDisplayNtInstalls(&NtInstallsFullScan);
            
            if (! NT_SUCCESS(status)) {
                
                KdPrintEx((DPFLTR_SETUP_ID, 
                           DPFLTR_ERROR_LEVEL, 
                           "SPCMDCON: RcCmdBootCfg:(scan) failed while displaying installs: Status = %lx\r\n",
                           status
                           ));
            
            }

            return 1;
        } 
        
        //
        // Provide support for reconstructing the boot configuration
        // 
        // This command iterates through all the existing Nt Installs
        // and prompts the user to add the installs into the boot
        // configuration
        //
        if (_wcsicmp(Action,L"/rebuild")==0) {

            ULONG               i;
            PNT_INSTALLATION    pInstall;
            WCHAR               buffer[256];
            PWSTR               LoadIdentifier;
            PWSTR               OsLoadOptions;
            BOOLEAN             writeInstall;
            BOOLEAN             writeAllInstalls;
            PLIST_ENTRY         Next;
            PNT_INSTALLATION    NtInstall;

            writeAllInstalls = FALSE;
            LoadIdentifier   = NULL;
            OsLoadOptions    = NULL;
            
            //
            // Ensure that we have the full scan of the disks
            //
            if (IsListEmpty(&NtInstallsFullScan)) {
                status = RcPerformFullNtInstallsScan();
                
                //
                // if there are no boot entries, then return
                //
                if (! NT_SUCCESS(status)) {

                    KdPrintEx((DPFLTR_SETUP_ID, 
                               DPFLTR_ERROR_LEVEL, 
                               "SPCMDCON: RcCmdBootCfg:(rebuild) full scan return 0 hits: Status = %lx\r\n",
                               status
                               ));

                    return 1;
                }
            }

            //
            // show how many installs we have 
            //
            RcMessageOut(MSG_BOOTCFG_SCAN_RESULTS_TITLE,
                         InstallCountFullScan
                         );

            //
            // For each of the discovered NT installs, ask the user
            // if they want to include it in the boot configuration
            //
            Next = NtInstallsFullScan.Flink;
            
            while ((UINT_PTR)Next != (UINT_PTR)&NtInstallsFullScan) {
                
                NtInstall = CONTAINING_RECORD( Next, NT_INSTALLATION, ListEntry );
                Next = NtInstall->ListEntry.Flink;
                
                writeInstall = TRUE;

                //
                // show the install under consideration
                //
                RcMessageOut(MSG_BOOTCFG_SCAN_RESULTS_ENTRY,
                             NtInstall->InstallNumber,
                             NtInstall->Region->DriveLetter,
                             NtInstall->Path
                            );

                //
                // if we are not in batch mode and the user doesn't want
                // to install all of the discoveries, then ask them
                // if they want to install the current one.
                //
                if (bPrompt && !writeAllInstalls) {
                
                    LPWSTR          YesNo;
                    WCHAR           Text[3];

                    //
                    // prompt user for action
                    //
                    YesNo = SpRetreiveMessageText( ImageBase, MSG_YESNOALL, NULL, 0 );
                    if( YesNo ) {
                        
                        //
                        // query the user for an (Yes, No, All) action
                        //
                        RcMessageOut(MSG_BOOTCFG_INSTALL_DISCOVERY_QUERY);
                        
                        if( RcLineIn( Text, 2 ) ) {
                            if( (Text[0] == YesNo[0]) || (Text[0] == YesNo[1]) ) {
                                writeInstall = FALSE;
                            } else if ((Text[0] == YesNo[4]) || (Text[0] == YesNo[5])) {
                                writeAllInstalls = TRUE;
                            }
                        } else {
                            writeInstall = FALSE;
                        }
                        SpMemFree( YesNo );
                    }
                }
                
                //
                // if we should write the discovery, then do it...
                //
                if (writeInstall) {
                    
                    //
                    // if we are not in batch mode, then prompt them for the necessary input
                    //
                    if (bPrompt) {
                    
                        ASSERT(LoadIdentifier == NULL);
                        ASSERT(OsLoadOptions == NULL);

                        //
                        // prompt user for load identifier
                        //
                        RcMessageOut(MSG_BOOTCFG_INSTALL_LOADIDENTIFIER_QUERY);
                        RcLineIn(buffer, sizeof(buffer)/sizeof(WCHAR));
                        LoadIdentifier = SpDupStringW(buffer);

                        //
                        // prompt user for load os load options
                        //
                        RcMessageOut(MSG_BOOTCFG_INSTALL_OSLOADOPTIONS_QUERY);
                        RcLineIn(buffer, sizeof(buffer)/sizeof(WCHAR));
                        OsLoadOptions = SpDupStringW(buffer);
                    
                    } else {
                          
                        LPWSTR   s;
                        LPWSTR   p;
                        NTSTATUS Status;
                        
                        s = SpRetreiveMessageText( ImageBase, 
                                                   MSG_BOOTCFG_BATCH_LOADID, 
                                                   NULL, 
                                                   0);
                        ASSERT(s);

                        //
                        // terminate the string at the %0
                        //
                        p = SpDupStringW(s);
                        SpMemFree(s);
                        s = wcsstr(p, L"%0");
                        
                        // make sure we found the %0
                        ASSERT(s);
                        ASSERT(s < (p + wcslen(p)));

                        if (s) {
                            // terminate at the %
                            *s = L'\0';
                        } else {
                            // otherwise just use all of p
                            NOTHING;
                        }

                        //
                        // construct the default load identifier
                        //
                        swprintf(_CmdConsBlock->TemporaryBuffer, L"%s%d", p, NtInstall->InstallNumber);
                        LoadIdentifier = SpDupStringW(_CmdConsBlock->TemporaryBuffer);
                        
                        //
                        // construct the default os load options 
                        //
                        swprintf(_CmdConsBlock->TemporaryBuffer, L"/fastdetect");
                        OsLoadOptions = SpDupStringW(_CmdConsBlock->TemporaryBuffer);

                        SpMemFree(p);

                    }
                    
#if defined(_X86_)
                    //
                    // write the discovered install into the boot list
                    //
                    status = SpAddNTInstallToBootList(_CmdConsBlock->SifHandle,
                                                     NtInstall->Region,
                                                     L"",
                                                     NtInstall->Region,
                                                     NtInstall->Path,
                                                     OsLoadOptions,
                                                     LoadIdentifier
                                                     );

#else
                    //
                    // the non-x86 case has not been tested/implemented fully
                    //
                    status = STATUS_UNSUCCESSFUL;                    
#endif 
                    
                    if (LoadIdentifier) {
                        SpMemFree(LoadIdentifier);
                    }
                    if (OsLoadOptions) {
                        SpMemFree(OsLoadOptions);
                    }
                    
                    LoadIdentifier = NULL;
                    OsLoadOptions = NULL;

                    //
                    // if adding the discovered install fails, bail out
                    //
                    if (! NT_SUCCESS(status)) {

                        KdPrintEx((DPFLTR_SETUP_ID, 
                                   DPFLTR_ERROR_LEVEL, 
                                   "SPCMDCON: RcCmdBootCfg:(rebuild) failed adding to boot list: Status = %lx\r\n",
                                   status
                                   ));

                        RcMessageOut(MSG_BOOTCFG_BOOTLIST_ADD_FAILURE);
                        break;
                    }
                }
            }
        
            return 1;
        
        }

        //
        // Provide support for reconstructing the boot configuration
        // 
        // This command displays the known NT installs and prompts
        // the user to install a single entry into the boot
        // configuration
        //
        if (_wcsicmp(Action,L"/add")==0) {

            ULONG               i;
            PNT_INSTALLATION    pInstall;
            ULONG               InstallNumber;
            WCHAR               buffer[256];
            UNICODE_STRING      UnicodeString;
            NTSTATUS            Status;
            PLIST_ENTRY         Next;
            PNT_INSTALLATION    NtInstall;

            //
            // Ensure that we have the full scan of the disks
            //
            if (IsListEmpty(&NtInstallsFullScan)) {
                status = RcPerformFullNtInstallsScan();
                
                //
                // if there are no boot entries, then return
                //
                if (! NT_SUCCESS(status)) {
                    
                    KdPrintEx((DPFLTR_SETUP_ID, 
                               DPFLTR_ERROR_LEVEL, 
                               "SPCMDCON: RcCmdBootCfg:(rebuild) full scan return 0 hits: Status = %lx\r\n",
                               status
                               ));
                    
                    return 1;
                }
            }

            //
            // display discovered installs
            //
            status = RcDisplayNtInstalls(&NtInstallsFullScan);
            if (! NT_SUCCESS(status)) {
                
                KdPrintEx((DPFLTR_SETUP_ID, 
                           DPFLTR_ERROR_LEVEL, 
                           "SPCMDCON: RcCmdBootCfg:(add) failed while displaying installs: Status = %lx\r\n",
                           status
                           ));
                
                return 1;
            }

            //
            // get user's install selection
            //
            RcMessageOut(MSG_BOOTCFG_ADD_QUERY);
            RcLineIn(buffer, sizeof(buffer) / sizeof(WCHAR));

            if (wcslen(buffer) > 0) {

                RtlInitUnicodeString( &UnicodeString, buffer );
                Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &InstallNumber );
                if (! NT_SUCCESS(Status) ||
                    !((InstallNumber >= 1) && (InstallNumber <= InstallCountFullScan))) {
                    
                    RcMessageOut(MSG_BOOTCFG_INVALID_SELECTION, buffer);
                
                } else {
                    
                    PWSTR   LoadIdentifier;
                    PWSTR   OsLoadOptions;
                    ULONG   i;
                    BOOLEAN saveStatus;

                    //
                    // prompt user for load identifier
                    //
                    RcMessageOut(MSG_BOOTCFG_INSTALL_LOADIDENTIFIER_QUERY);
                    RcLineIn(buffer, sizeof(buffer)/sizeof(WCHAR));
                    LoadIdentifier = SpDupStringW(buffer);

                    //
                    // prompt user for load os load options
                    //
                    RcMessageOut(MSG_BOOTCFG_INSTALL_OSLOADOPTIONS_QUERY);
                    RcLineIn(buffer, sizeof(buffer)/sizeof(WCHAR));
                    OsLoadOptions = SpDupStringW(buffer);

                    //
                    // iterate to the InstallNumber'th node in the discover list
                    //
                    Next = NtInstallsFullScan.Flink;
                    while ((UINT_PTR)Next != (UINT_PTR)&NtInstallsFullScan) {
                        NtInstall = CONTAINING_RECORD( Next, NT_INSTALLATION, ListEntry );
                        Next = NtInstall->ListEntry.Flink;
                    
                        if (NtInstall->InstallNumber == InstallNumber) {
                            break;
                        }
                    }
                    ASSERT(NtInstall);
                    if (! NtInstall) {
                        KdPrintEx((DPFLTR_SETUP_ID, 
                                   DPFLTR_INFO_LEVEL, 
                                   "SPCMDCON: RcCmdBootCfg:(add) failed to find user specified NT Install\r\n"
                                   ));
                        RcMessageOut(MSG_BOOTCFG_ADD_NOT_FOUND);
                        return 1;
                    }

#if defined(_X86_)
                    //
                    // write the discovered install into the boot list
                    //
                    status = SpAddNTInstallToBootList(_CmdConsBlock->SifHandle,
                                                     NtInstall->Region,
                                                     L"",
                                                     NtInstall->Region,
                                                     NtInstall->Path,
                                                     OsLoadOptions,
                                                     LoadIdentifier
                                                     );

#else
                    //
                    // the non-x86 case has not been tested/implemented fully
                    //
                    status = STATUS_UNSUCCESSFUL;
#endif 
                    
                    if (LoadIdentifier) {
                        SpMemFree(LoadIdentifier);
                    }
                    if (OsLoadOptions) {
                        SpMemFree(OsLoadOptions);
                    }
                
                    if (! NT_SUCCESS(status)) {

                        KdPrintEx((DPFLTR_SETUP_ID, 
                                   DPFLTR_ERROR_LEVEL, 
                                   "SPCMDCON: RcCmdBootCfg:(add) failed adding to boot list: Status = %lx\r\n",
                                   status
                                   ));

                        RcMessageOut(MSG_BOOTCFG_BOOTLIST_ADD_FAILURE);
                    }
                }
            }
            
            return 1;
        }
    
    }

    //
    // either no args, or none recognized; default to help 
    //
    pRcEnableMoreMode();
    RcMessageOut(MSG_BOOTCFG_HELP);
    pRcDisableMoreMode();

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\resource.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    resources.c

Abstract:

    This module implements all access to
    the resources.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop


LPCWSTR _DateTimeFormat;


VOID
vRcMessageOut(
    IN ULONG    MessageId,
    IN va_list *arglist
    )
{
    WCHAR *p;
    NTSTATUS Status;

    //
    // Load the message
    //
    p = SpRetreiveMessageText(ImageBase,MessageId,NULL,0);
    if(!p) {
        return;
    }

    Status = SpRtlFormatMessage(
                p,
                0,
                FALSE,
                FALSE,
                FALSE,
                arglist,
                _CmdConsBlock->TemporaryBuffer,
                _CmdConsBlock->TemporaryBufferSize,
                NULL
                );

    SpMemFree(p);

    if(NT_SUCCESS(Status)) {
        RcTextOut(_CmdConsBlock->TemporaryBuffer);
    }
}


VOID
RcMessageOut(
    IN ULONG MessageId,
    ...
    )
{
    va_list arglist;

    va_start(arglist,MessageId);
    vRcMessageOut(MessageId,&arglist);
    va_end(arglist);
}


ULONG
RcFormatDateTime(
    IN  PLARGE_INTEGER Time,
    OUT LPWSTR         Output
    )
{
    TIME_FIELDS TimeFields;
    WCHAR *p,*AmPmSpec;
    LPCWSTR q;
    int i;

    //
    // Load the system date and time format string if not loaded already.
    //
    if(!_DateTimeFormat) {
        _DateTimeFormat = SpRetreiveMessageText(ImageBase,MSG_DATE_TIME_FORMAT,NULL,0);
        if(!_DateTimeFormat) {
            _DateTimeFormat = L"m/d/y h:na*";
        }
    }

    //
    // Translate the last write time to time fields.
    //
    RtlTimeToTimeFields(Time,&TimeFields);

    //
    // Format the date and time.
    //
    p = Output;
    q = _DateTimeFormat;
    AmPmSpec = NULL;

    while(*q != L'*') {

        switch(*q) {

        case L'm':
            i = TimeFields.Month;
            break;

        case L'd':
            i = TimeFields.Day;
            break;

        case L'y':
            i = TimeFields.Year;
            break;

        case L'h':
            i = TimeFields.Hour % 12;
            if(i == 0) {
                i = 12;
            }
            break;

        case L'H':
            i = TimeFields.Hour;
            break;

        case L'n':
            i = TimeFields.Minute;
            break;

        case L'a':
            i = -1;
            AmPmSpec = p++;
            break;

        default:
            i = -1;
            *p++ = *q;
            break;
        }

        if(i != -1) {

            i = i % 100;

            *p++ = (i / 10) + L'0';
            *p++ = (i % 10) + L'0';
        }

        q++;
    }

    if(AmPmSpec) {
        q++;        // q points at am specifier
        if(TimeFields.Hour >= 12) {
            q++;    // q points at pm specifier
        }

        *AmPmSpec = *q;
    }

    *p = 0;

    return (ULONG)(p - Output);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\mbr.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mbr.c

Abstract:

    This module implements the FIXMBR command.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

#include <bootmbr.h>
//
// For NEC98 boot memu code.
//
#include <x86mboot.h>


VOID
RcDetermineDisk0(
    VOID
    );

BOOL
RcDetermineDisk0Enum(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Context
    );

NTSTATUS
RcOpenPartition(
    IN PWSTR DiskDevicePath,
    IN ULONG PartitionNumber,
    OUT HANDLE *Handle,
    IN BOOLEAN NeedWriteAccess
    );

NTSTATUS
RcReadDiskSectors(
    IN HANDLE Handle,
    IN ULONG SectorNumber,
    IN ULONG SectorCount,
    IN ULONG BytesPerSector,
    IN OUT PVOID AlignedBuffer
    );

NTSTATUS
RcWriteDiskSectors(
    IN HANDLE Handle,
    IN ULONG SectorNumber,
    IN ULONG SectorCount,
    IN ULONG BytesPerSector,
    IN OUT PVOID AlignedBuffer
    );


#define MBRSIZE_NEC98 0x2000
#define IPL_SIGNATURE_NEC98 "IPL1"

ULONG
RcCmdFixMBR(
    IN PTOKENIZED_LINE TokenizedLine
    )

/*++

Routine Description:

    Top-level routine supporting the FIXMBR command in the setup diagnostic
    command interpreter.

    FIXMBR writes a new master boot record. It will ask before writing the boot
    record if it cannot detect a valid mbr signature.

Arguments:

    TokenizedLine - supplies structure built by the line parser describing
        each string on the line as typed by the user.

Return Value:

    None.

--*/

{
    WCHAR DeviceName[256];
    ULONG i;
    ULONG SectorCount;
    ULONG BytesPerSector;
    PUCHAR Buffer = NULL;
    UCHAR InfoBuffer[2048];
    ULONG SectorId = 0;
    HANDLE handle = 0;
    NTSTATUS rc;
    PON_DISK_MBR mbr;
    IO_STATUS_BLOCK StatusBlock;
    Int13HookerType Int13Hooker = NoHooker;
    ULONG NextSector;
    WCHAR Text[2];
    PWSTR YesNo = NULL;
    BOOL Confirm = TRUE;
    BOOL SignatureInvalid = FALSE;
    BOOL Int13Detected = FALSE;
    PREAL_DISK_MBR_NEC98 MbrNec98;


    //
    // command is only supported on X86 platforms.
    // Alpha or other RISC platforms don't use
    // mbr code
    //

#ifndef _X86_

    RcMessageOut( MSG_ONLY_ON_X86 );
    return 1;

#else

    if (RcCmdParseHelp( TokenizedLine, MSG_FIXMBR_HELP )) {
        return 1;
    }

    if (TokenizedLine->TokenCount == 2) {
        wcscpy( DeviceName, TokenizedLine->Tokens->Next->String );
    } else {
        RtlZeroMemory(DeviceName,sizeof(DeviceName));
        SpEnumerateDiskRegions( (PSPENUMERATEDISKREGIONS)RcDetermineDisk0Enum, (ULONG_PTR)DeviceName );
    }

    rc = RcOpenPartition( DeviceName, 0, &handle, TRUE );
    if (!NT_SUCCESS(rc)) {
        DEBUG_PRINTF(( "failed to open partition zero!!!!!!" ));
        return 1;
    }

    //
    // get disk geometry
    //

    rc = ZwDeviceIoControlFile(
        handle,
        NULL,
        NULL,
        NULL,
        &StatusBlock,
        IOCTL_DISK_GET_DRIVE_GEOMETRY,
        NULL,
        0,
        InfoBuffer,
        sizeof( InfoBuffer )
        );
    if( !NT_SUCCESS( rc ) ) {
        RcMessageOut( MSG_FIXMBR_READ_ERROR );
        goto cleanup;
    }

    //
    // retrieve the sector size!
    //

    BytesPerSector = ((DISK_GEOMETRY*)InfoBuffer)->BytesPerSector;

    //
    // compute the sector count
    //

    SectorCount = max( 1, (!IsNEC_98
                           ? (sizeof( ON_DISK_MBR )/BytesPerSector)
                           : (MBRSIZE_NEC98/BytesPerSector) ));

    //
    // allocate a buffer twice as big as necessary
    //

    Buffer = SpMemAlloc( 2 * SectorCount * BytesPerSector );

    //
    // align the buffer
    //

    if(!IsNEC_98) {
        mbr = ALIGN( Buffer, BytesPerSector );
    } else {
        MbrNec98 = ALIGN( Buffer, BytesPerSector );
    }

    //
    // take in the sectors
    //

    rc = RcReadDiskSectors(
        handle,
        SectorId,
        SectorCount,
        BytesPerSector,
        (!IsNEC_98 ? (PVOID)mbr : (PVOID)MbrNec98)
        );
    if (!NT_SUCCESS(rc)) {
        RcMessageOut( MSG_FIXMBR_READ_ERROR );
        goto cleanup;
    }

    if ((!IsNEC_98 && U_USHORT(mbr->AA55Signature) != MBR_SIGNATURE) ||
        (IsNEC_98 &&
         ((U_USHORT(MbrNec98->AA55Signature) != MBR_SIGNATURE) ||
          _strnicmp(MbrNec98->IPLSignature,IPL_SIGNATURE_NEC98,sizeof(IPL_SIGNATURE_NEC98)-1)))
        ) {

        SignatureInvalid = TRUE;
        RcMessageOut( MSG_FIXMBR_NO_VALID_SIGNATURE );
    }

    //
    // check for weird int13 hookers
    //
    // No NEC98 supports EZ Drive.
    //
    //
    if (!IsNEC_98) {

        //
        //
        // EZDrive support: if the first entry in the partition table is
        // type 0x55, then the actual partition table is on sector 1.
        //
        // Only for x86 because on non-x86, the firmware can't see EZDrive
        // partitions.
        //
        //

        if (mbr->PartitionTable[0].SystemId == 0x55) {
            Int13Hooker = HookerEZDrive;
            SectorId = 1;
        }

        //
        // Also check for on-track.
        //

        if( mbr->PartitionTable[0].SystemId == 0x54 ) {
            Int13Hooker = HookerOnTrackDiskManager;
            SectorId = 1;
        }

        //
        // there's a define for HookerMax but we don't appear
        // to check for it in setup so I don't check for it here
        //
        //
        // If we have an int13 hooker
        //

        if (Int13Hooker != NoHooker) {
            Int13Detected = TRUE;
            RcMessageOut( MSG_FIXMBR_INT13_HOOKER );
        }

        //
        // we have a valid signature AND int 13 hooker is detected
        //

        if (Int13Detected) {

            //
            // take sector 1 in, since sector 0 is the int hooker boot code
            //

            rc = RcReadDiskSectors(
                handle,
                SectorId,
                SectorCount,
                BytesPerSector,
                mbr
                );

            //
            // sector 1 should look like a valid MBR too
            //

            if (U_USHORT(mbr->AA55Signature) != MBR_SIGNATURE) {
                SignatureInvalid = TRUE;
                RcMessageOut( MSG_FIXMBR_NO_VALID_SIGNATURE );
            }
        }
    }

    RcMessageOut( MSG_FIXMBR_WARNING_BEFORE_PROCEED );

    if (!InBatchMode) {
        YesNo = SpRetreiveMessageText(ImageBase,MSG_YESNO,NULL,0);
        if(!YesNo) {
            Confirm = FALSE;
        }
        while(Confirm) {
            RcMessageOut( MSG_FIXMBR_ARE_YOU_SURE );
            if(RcLineIn(Text,2)) {
                if((Text[0] == YesNo[0]) || (Text[0] == YesNo[1])) {
                    //
                    // Wants to do it.
                    //
                    Confirm = FALSE;
                } else {
                    if((Text[0] == YesNo[2]) || (Text[0] == YesNo[3])) {
                        //
                        // Doesn't want to do it.
                        //
                        goto cleanup;
                    }
                }
            }
        }
    }

    //
    // now we need to slap in new boot code!
    // make sure the boot code starts at the start of the sector.
    //

    if(!IsNEC_98) {
        ASSERT(&((PON_DISK_MBR)0)->BootCode == 0);
    } else {
        ASSERT(&((PREAL_DISK_MBR_NEC98)0)->BootCode == 0);
    }

    RcMessageOut( MSG_FIXMBR_DOING_IT, DeviceName );

    //
    // clobber the existing boot code
    //

    if(!IsNEC_98) {
        RtlMoveMemory(mbr,x86BootCode,sizeof(mbr->BootCode));

        //
        // put a new signature in
        //

        U_USHORT(mbr->AA55Signature) = MBR_SIGNATURE;

    } else {
        //
        // Write MBR in 1st sector.
        //
        RtlMoveMemory(MbrNec98,x86PC98BootCode,0x200);

        //
        // Write continous MBR after 3rd sector.
        //
        RtlMoveMemory((PUCHAR)MbrNec98+0x400,x86PC98BootMenu,MBRSIZE_NEC98-0x400);
    }

    //
    // write out the sector
    //

    rc = RcWriteDiskSectors(
        handle,
        SectorId,
        SectorCount,
        BytesPerSector,
        (!IsNEC_98 ? (PVOID)mbr : (PVOID)MbrNec98)
        );
    if (!NT_SUCCESS( rc )) {
        DEBUG_PRINTF(( "failed writing out new MBR." ));
        RcMessageOut( MSG_FIXMBR_FAILED );
        goto cleanup;
    }

    RcMessageOut( MSG_FIXMBR_DONE );

cleanup:

    if (handle) {
        NtClose(handle);
    }
    if (Buffer) {
        SpMemFree(Buffer);
    }
    if (YesNo) {
        SpMemFree(YesNo);
    }
    return 1;

#endif
}


BOOL
RcDetermineDisk0Enum(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Context
    )

/*++

Routine Description:

    Callback routine passed to SpEnumDiskRegions.

Arguments:

    Region - a pointer to a disk region returned by SpEnumDiskRegions
    Ignore - ignored parameter

Return Value:

    TRUE - to continue enumeration
    FALSE - to end enumeration

--*/

{
    WCHAR ArcName[256];
    PWSTR DeviceName = (PWSTR)Context;


    SpArcNameFromRegion(
        Region,
        ArcName,
        sizeof(ArcName),
        PartitionOrdinalCurrent,
        PrimaryArcPath
        );

    //
    // look for the one with arc path L"multi(0)disk(0)rdisk(0)"
    //

    if( wcsstr( ArcName, L"multi(0)disk(0)rdisk(0)" ) ) {

        *DeviceName = UNICODE_NULL;

        SpNtNameFromRegion(
            Region,
            DeviceName,
            MAX_PATH * sizeof(WCHAR),
            PartitionOrdinalCurrent
            );

        if (*DeviceName != UNICODE_NULL) {
            PWSTR   PartitionKey = wcsstr(DeviceName, L"Partition");

            if (!PartitionKey) {
                PartitionKey = wcsstr(DeviceName, L"partition");
            }

            //
            // partition 0 represents the start of disk
            //
            if (PartitionKey) {
                *PartitionKey = UNICODE_NULL;
                wcscat(DeviceName, L"Partition0");
            } else {
                DeviceName[wcslen(DeviceName) - 1] = L'0';  
            }                
        }            

        return FALSE;
    }

    return TRUE;
}


NTSTATUS
RcReadDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONG   SectorNumber,
    IN     ULONG   SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer
    )

/*++

Routine Description:

    Reads one or more disk sectors.

Arguments:

    Handle - supplies handle to open partition object from which
        sectors are to be read or written.  The handle must be
        opened for synchronous I/O.

Return Value:

    NTSTATUS value indicating outcome of I/O operation.

--*/

{
    LARGE_INTEGER IoOffset;
    ULONG IoSize;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    //
    // Calculate the large integer byte offset of the first sector
    // and the size of the I/O.
    //

    IoOffset.QuadPart = SectorNumber * BytesPerSector;
    IoSize = SectorCount * BytesPerSector;

    //
    // Perform the I/O.
    //

    Status = (NTSTATUS) ZwReadFile(
        Handle,
        NULL,
        NULL,
        NULL,
        &IoStatusBlock,
        AlignedBuffer,
        IoSize,
        &IoOffset,
        NULL
        );
    if (!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to read %u sectors starting at sector %u\n",SectorCount,SectorNumber));
    }

    return(Status);
}


NTSTATUS
RcWriteDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONG   SectorNumber,
    IN     ULONG   SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer
    )

/*++

Routine Description:

    Writes one or more disk sectors.

Arguments:

    Handle - supplies handle to open partition object from which
        sectors are to be read or written.  The handle must be
        opened for synchronous I/O.

Return Value:

    NTSTATUS value indicating outcome of I/O operation.

--*/

{
    LARGE_INTEGER IoOffset;
    ULONG IoSize;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    //
    // Calculate the large integer byte offset of the first sector
    // and the size of the I/O.
    //

    IoOffset.QuadPart = SectorNumber * BytesPerSector;
    IoSize = SectorCount * BytesPerSector;

    //
    // Perform the I/O.
    //

    Status = (NTSTATUS) ZwWriteFile(
        Handle,
        NULL,
        NULL,
        NULL,
        &IoStatusBlock,
        AlignedBuffer,
        IoSize,
        &IoOffset,
        NULL
        );
    if (!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to write %u sectors starting at sector %u\n",SectorCount,SectorNumber));
    }

    return(Status);
}


NTSTATUS
RcOpenPartition(
    IN  PWSTR   DiskDevicePath,
    IN  ULONG   PartitionNumber,
    OUT HANDLE *Handle,
    IN  BOOLEAN NeedWriteAccess
    )

/*++

Routine Description:

    Opens and returns a handle to the specified partition.

Arguments:

    DiskDevicePath - the path to the device.

    PartitionNumber - if the path doesn't already specify the Partition then
                    the function will open the partition specified by this number

    Handle -    where the open handle will be returned.
                The handle is opened for synchronous I/O.

    NeedWriteAccess - true to open in R/W

Return Value:

    NTSTATUS value indicating outcome of I/O operation.

--*/

{
    PWSTR PartitionPath;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Form the pathname of partition.
    //

    PartitionPath = SpMemAlloc((wcslen(DiskDevicePath) * sizeof(WCHAR)) + sizeof(L"\\partition000"));
    if(PartitionPath == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // if partition is already specified in the string, then don't bother appending
    // it
    //

    if (wcsstr( DiskDevicePath, L"Partition" ) == 0) {
        swprintf(PartitionPath,L"%ws\\partition%u",DiskDevicePath,PartitionNumber);
    } else {
        swprintf(PartitionPath,L"%ws",DiskDevicePath);
    }

    //
    // Attempt to open partition0.
    //

    INIT_OBJA(&Obja,&UnicodeString,PartitionPath);

    Status = ZwCreateFile(
        Handle,
        FILE_GENERIC_READ | (NeedWriteAccess ? FILE_GENERIC_WRITE : 0),
        &Obja,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | (NeedWriteAccess ? FILE_SHARE_WRITE : 0),
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
        );
    if (!NT_SUCCESS(Status)) {
        KdPrint(("CMDCONS: Unable to open %ws (%lx)\n",PartitionPath,Status));
    }

    SpMemFree(PartitionPath);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\repair.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    repair.c

Abstract:

    This module contains the code necessary for the
    repair command.

Author:

    Wesley Witt (wesw) 22-Sept-1998

Revision History:


Repair  PathtoERFiles PathtoNTSourceFiles  /NoConfirm /RepairStartup /Registry /RepairFiles

Description:        Replaces the NT4 Emergency Repair Process Screens

Arguments:

PathtoERFiles

    Path to the Emergency Repair Disk Files (Setup.log, autoexec.nt, config.nt).
    If this is not specified, the default is to prompt the user with 2 choices:
    Use a floppy, or use the repair info stored in %windir%\repair

PathtoNTSourceFiles

    Path to the NT CD source files.  By default, this is the CD-ROM if not
    specified. [Kartik Raghavan]  This path does not need to be specified if
    you are repairing the registry and/or the Startup environment.

NoConfirm

    Replace all files in setup.log whose checksums do not match without
    prompting the user.  By default, the user is prompted for each file that
    is different and whether to replace or leave intact.

Registry

    Replace all the registry files in %windir%\system32\config with the original
    copy of the registry saved after setup and located in %windir%\repair.

RepairStartup

    Repair the startup environment / bootfiles/bootsector.
    (This may already be covered in another cmd--Wes?)

Repair Files

    Compares the checksums of the files listed in setup.log to what's
    on system.  If a file doesn't match, then the user is prompted to replace
    the file with the one from the NT Source Files.  The user is not prompted
    if the /NoConfirm switch is specified.

Usage:

    Repair a:\ d:\i386 /RepairStartup
    Repair



--*/

#include "cmdcons.h"
#pragma hdrstop


#define SETUP_REPAIR_DIRECTORY      L"repair"
#define SETUP_LOG_FILENAME          L"\\setup.log"

#define FLG_NO_CONFIRM              0x00000001
#define FLG_STARTUP                 0x00000002
#define FLG_REGISTRY                0x00000004
#define FLG_FILES                   0x00000008


LONG
RcPromptForDisk(
    void
    )
{
    PWSTR TagFile = NULL;
    ULONG i;
    WCHAR DevicePath[MAX_PATH];
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    HANDLE Handle;

/*
    SpGetSourceMediaInfo(
        _CmdConsBlock->SifHandle,
        L"",
        NULL,
        &TagFile,
        NULL
        );
 */
    for (i=0; i<IoGetConfigurationInformation()->CdRomCount; i++) {
        swprintf( DevicePath, L"\\Device\\Cdrom%u", i );
        SpConcatenatePaths( DevicePath, TagFile );
        INIT_OBJA( &ObjectAttributes, &UnicodeString, DevicePath) ;
        Status = ZwCreateFile(
            &Handle,
            FILE_GENERIC_READ,
            &ObjectAttributes,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ,
            FILE_OPEN,
            0,
            NULL,
            0
            );
        if (NT_SUCCESS(Status)) {
            ZwClose(Handle);
            break;
        }
    }




    return -1;
}


ULONG
RcCmdRepair(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    ULONG i;
    PLINE_TOKEN Token;
    ULONG Flags = 0;
    BOOLEAN Rval;
#ifdef _X86_
    ULONG RepairItems[RepairItemMax] = { 0, 0, 0};
#else
    ULONG RepairItems[RepairItemMax] = { 0, 0};
#endif
    PWSTR RepairPath;
    PDISK_REGION Region;
    PWSTR tmp;
    PWSTR PathtoERFiles = NULL;
    PWSTR ErDevicePath = NULL;
    PWSTR ErDirectory = NULL;
    PWSTR PathtoNTSourceFiles = NULL;
    PWSTR SrcDevicePath = NULL;
    PWSTR SrcDirectory = NULL;


    if (RcCmdParseHelp( TokenizedLine, MSG_REPAIR_HELP )) {
        return 1;
    }

    RcMessageOut(MSG_NYI);
    return 1;

    if (TokenizedLine->TokenCount == 1) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    //
    // process the command like tokens looking for the options
    //

    for (i=1,Token=TokenizedLine->Tokens->Next; i<TokenizedLine->TokenCount; i++) {
        if (Token->String[0] == L'/' || Token->String[0] == L'-') {
            if (_wcsicmp(&Token->String[1],L"NoConfirm") == 0) {
                Flags |= FLG_NO_CONFIRM;
            } else if (_wcsicmp(&Token->String[1],L"RepairStartup") == 0) {
                Flags |= FLG_STARTUP;
            } else if (_wcsicmp(&Token->String[1],L"Registry") == 0) {
                Flags |= FLG_REGISTRY;
            } else if (_wcsicmp(&Token->String[1],L"RepairFiles") == 0) {
                Flags |= FLG_FILES;
            }
        }
    }

    if (Flags == 0) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    if (TokenizedLine->Tokens->Next->String[0] != L'/') {
        PathtoERFiles = TokenizedLine->Tokens->Next->String;
        if (TokenizedLine->TokenCount > 2 && TokenizedLine->Tokens->Next->Next->String[0] != L'/') {
            PathtoNTSourceFiles = TokenizedLine->Tokens->Next->Next->String;
        }
    }

    if (Flags & FLG_NO_CONFIRM) {
        SpDrSetRepairFast( TRUE );
    } else {
        SpDrSetRepairFast( FALSE );
    }

    if (Flags & FLG_FILES) {
        RepairItems[RepairFiles] = 1;
    }

    if (Flags & FLG_STARTUP) {
#ifdef _X86_
        RepairItems[RepairBootSect] = 1;
#endif
        RepairItems[RepairNvram] = 1;
    }

    //
    // Get the path to the repair directory
    //

    if (PathtoERFiles == NULL) {
        if (InBatchMode) {
            RcMessageOut(MSG_SYNTAX_ERROR);
            return 1;
        }
        RcMessageOut( MSG_REPAIR_ERFILES_LOCATION );
        if (!RcLineIn(_CmdConsBlock->TemporaryBuffer,_CmdConsBlock->TemporaryBufferSize)) {
            return 1;
        }
    } else {
        wcscpy(_CmdConsBlock->TemporaryBuffer,PathtoERFiles);
        PathtoERFiles = NULL;
    }

    tmp = SpMemAlloc( MAX_PATH );
    if (tmp == NULL) {
        RcMessageOut(STATUS_NO_MEMORY);
        return 1;
    }
    if (!RcFormFullPath( _CmdConsBlock->TemporaryBuffer, tmp, FALSE )) {
        RcMessageOut(MSG_INVALID_PATH);
        SpMemFree(tmp);
        return 1;
    }
    Region = SpRegionFromDosName(tmp);
    if (Region == NULL) {
        SpMemFree(tmp);
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }
    ErDirectory = SpDupStringW( &tmp[2] );
    SpNtNameFromRegion( Region, tmp, MAX_PATH, PartitionOrdinalOnDisk );
    ErDevicePath = SpDupStringW( tmp );
    PathtoERFiles = SpMemAlloc( wcslen(ErDirectory) + wcslen(ErDevicePath) + 16 );
    wcscpy( PathtoERFiles, ErDevicePath );
    wcscat( PathtoERFiles, ErDirectory );
    SpMemFree(tmp);

    //
    // get the path to the nt source files, usually the cd
    //

    if (PathtoNTSourceFiles == NULL) {

    } else {

    }

    //
    // do the repair action(s)
    //
/*
    Rval = SpDoRepair(
        _CmdConsBlock->SifHandle,


        _CmdConsBlock->BootDevicePath,
        _CmdConsBlock->DirectoryOnBootDevice,
        RepairPath,
        RepairItems
        );
*/
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\util.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module implements all utility functions.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop


#include "remboot.h" 

HANDLE NetUseHandles[26] = { NULL };
BOOLEAN RdrIsInKernelMode = FALSE;

RC_ALLOWED_DIRECTORY AllowedDirs[] = {
    { FALSE, L"$WIN_NT$.~BT" },
    { FALSE, L"$WIN_NT$.~LS" },
    { FALSE, L"CMDCONS" },
    { TRUE, L"SYSTEM VOLUME INFORMATION" }
};

BOOLEAN
RcIsPathNameAllowed(
    IN LPCWSTR FullPath,
    IN BOOLEAN RemovableMediaOk,
    IN BOOLEAN Mkdir
    )

/*++

Routine Description:

    This routine verifies that the specified path name is
    allowed based on the security context that the console
    user is logged into.

Arguments:

    FullPath - specifies the full path to be verified.

Return Value:

    FALSE if failure, indicating the path is not allowed.
    TRUE otherwise.

--*/

{
    WCHAR TempBuf[MAX_PATH*2];
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE  Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    BOOL isDirectory = TRUE;
    BOOLEAN OnRemovableMedia;

    //
    // should we bypass security?
    //

    if (AllowAllPaths) {
        return TRUE;
    }

    //
    // some special processing for dos paths
    // we must make sure that only the root and %systemdir% are allowed.
    //

    if (FullPath[1] == L':' && FullPath[2] == L'\\' && FullPath[3] == 0) {
        //
        // root directory is ok.
        //
        return TRUE;
    }

    SpStringToUpper((PWSTR)FullPath);

    if (!RcGetNTFileName((PWSTR)FullPath,TempBuf))
        return FALSE;

    INIT_OBJA(&Obja,&UnicodeString,TempBuf);

    Status = ZwOpenFile(
        &Handle,
        FILE_READ_ATTRIBUTES,
        &Obja,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_DIRECTORY_FILE
        );
    if( !NT_SUCCESS(Status) ) {
        isDirectory = FALSE;

    } else {
        ZwClose( Handle );
    }

    if (isDirectory == FALSE && wcsrchr( FullPath, L'\\' ) == ( &FullPath[2] )) {
        //
        // if the cannonicalized path has only one slash the user is trying to do something
        // to the files in the root, which we allow.
        //
        // however we do not allow users to mess with directories at the root
        //
        if (Mkdir) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

    ASSERT(SelectedInstall != NULL);

    if(SelectedInstall != NULL) {
        //
        // Get the length of the first element in the path
        //
        size_t i;
        LPCWSTR RelPath = FullPath + 3;
        WCHAR SelectedInstallDrive = RcToUpper(SelectedInstall->DriveLetter);

        //
        // See if path begins with the install path
        //
        if(FullPath[0] == SelectedInstallDrive && RcPathBeginsWith(RelPath, SelectedInstall->Path)) {
            return TRUE;
        }

        //
        // See if the path begins with an allowed dir
        //
        for(i = 0; i < sizeof(AllowedDirs) / sizeof(AllowedDirs[0]); ++i) {
            if((!AllowedDirs[i].MustBeOnInstallDrive || FullPath[0] == SelectedInstallDrive) &&
                RcPathBeginsWith(FullPath + 3, AllowedDirs[i].Directory)) {
                return TRUE;
            }
        }
    }

    Status = RcIsFileOnRemovableMedia(TempBuf, &OnRemovableMedia);

    if (NT_SUCCESS(Status) && OnRemovableMedia) {
        if (RemovableMediaOk) {
            return TRUE;
        }
    }

    if (RcIsNetworkDrive(TempBuf) == STATUS_SUCCESS) {
        //
        // Context that was used for connection will do appropriate security checking.
        //
        return TRUE;
    }

    return FALSE;
}


BOOLEAN
RcDoesPathHaveWildCards(
    IN LPCWSTR FullPath
    )

/*++

Routine Description:

    This routine verifies that the specified path name is
    allowed based on the security context that the console
    user is logged into.

Arguments:

    FullPath - specifies the full path to be verified.

Return Value:

    FALSE if failure, indicating the path is not allowed.
    TRUE otherwise.

--*/

{
    if (wcsrchr( FullPath, L'*' )) {
        return TRUE;
    }

    if (wcsrchr( FullPath, L'?' )) {
        return TRUE;
    }

    return FALSE;
}

NTSTATUS
RcIsNetworkDrive(
    IN PWSTR FileName
    )

/*++

Routine Description:

    This routine returns if the FileName given is a network path.

Arguments:

    FileName - specifies the full path to be checked.

Return Value:

    Any other than STATUS_SUCCESS if failure, indicating the path is not on the network, 
    STATUS_SUCCESS otherwise.

--*/

{
    NTSTATUS Status;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;
    PWSTR BaseNtName;

    if (wcsncmp(FileName, L"\\DosDevice", wcslen(L"\\DosDevice")) == 0) {
        Status = GetDriveLetterLinkTarget( FileName, &BaseNtName );

        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    } else {
        BaseNtName = FileName;
    }

    Status = pRcGetDeviceInfo( BaseNtName, &DeviceInfo );
    if(NT_SUCCESS(Status)) {
        if (DeviceInfo.DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM) {
            Status = STATUS_NO_MEDIA;
        }
    }

    return Status;
}


NTSTATUS
RcDoNetUse(
    PWSTR Share, 
    PWSTR User, 
    PWSTR Password, 
    PWSTR Drive
    )

/*++

Routine Description:

    This routine attempts to make a connection using the redirector to the remote server.

Arguments:

    Share - A string of the form "\\server\share"
    
    User  - A string of the form "domain\user"
    
    Password - A string containing the password information.
    
    Drive - Filled in with a string of the form "X", where X is the drive letter the share 
        has been mapped to.

Return Value:

    STATUS_SUCCESS if successful, indicating Drive contains the mapped drive letter,
    otherwise the appropriate error code.

--*/

{
    NTSTATUS Status;
    PWSTR NtDeviceName;
    ULONG ShareLength;
    WCHAR DriveLetter;
    WCHAR temporaryBuffer[128];
    PWCHAR Temp, Temp2;
    HANDLE Handle;
    ULONG EaBufferLength;
    PWSTR UserName; 
    PWSTR DomainName; 
    PVOID EaBuffer;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING UnicodeString2;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_FULL_EA_INFORMATION FullEaInfo;

    //
    // Switch the redirector to kernel-mode security if it is not.
    //
    if (!RdrIsInKernelMode) {
        Status = PutRdrInKernelMode();

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        RdrIsInKernelMode = TRUE;
    }

    //
    // Search for an open drive letter, starting at D: and working up.
    //
    wcscpy(temporaryBuffer, L"\\DosDevices\\D:");
    Temp = wcsstr(temporaryBuffer, L"D:");

    for (DriveLetter = L'D'; (Temp && (DriveLetter <= L'Z')); DriveLetter++) {
        *Temp = DriveLetter;
        
        Status = GetDriveLetterLinkTarget( temporaryBuffer, &Temp2 );

        if (!NT_SUCCESS(Status)) {
            break;
        }
    }

    if (DriveLetter > L'Z') {
        return STATUS_OBJECT_NAME_INVALID;
    }

    //
    // Build the NT device name.
    //
    ShareLength = wcslen(Share);
    NtDeviceName = SpMemAlloc(ShareLength * sizeof(WCHAR) + sizeof(L"\\Device\\LanmanRedirector\\;X:0"));   
    if (NtDeviceName == NULL) {
        return STATUS_NO_MEMORY;
    }
    wcscpy(NtDeviceName, L"\\Device\\LanmanRedirector\\;");
    temporaryBuffer[0] = DriveLetter;
    temporaryBuffer[1] = UNICODE_NULL;
    wcscat(NtDeviceName, temporaryBuffer);
    wcscat(NtDeviceName, L":0");
    wcscat(NtDeviceName, Share + 1);

    //
    // Chop the username and domainname into individual values.
    //
    wcscpy(temporaryBuffer, User);
    DomainName = temporaryBuffer;
    UserName = wcsstr(temporaryBuffer, L"\\");

    if (UserName == NULL) {
        SpMemFree(NtDeviceName);
        return STATUS_OBJECT_NAME_INVALID;
    }
    *UserName = UNICODE_NULL;
    UserName++;

    //
    // Create buffer with user credentials
    //

    EaBufferLength = FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]);
    EaBufferLength += sizeof(EA_NAME_DOMAIN);
    EaBufferLength += (wcslen(DomainName) * sizeof(WCHAR));
    if (EaBufferLength & (sizeof(ULONG) - 1)) {
        //
        // Long align the next entry
        //
        EaBufferLength += (sizeof(ULONG) - (EaBufferLength & (sizeof(ULONG) - 1)));
    }

    EaBufferLength += FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]);
    EaBufferLength += sizeof(EA_NAME_USERNAME);
    EaBufferLength += (wcslen(UserName) * sizeof(WCHAR));
    if (EaBufferLength & (sizeof(ULONG) - 1)) {
        //
        // Long align the next entry
        //
        EaBufferLength += (sizeof(ULONG) - (EaBufferLength & (sizeof(ULONG) - 1)));
    }

    EaBufferLength += FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]);
    EaBufferLength += sizeof(EA_NAME_PASSWORD);
    EaBufferLength += (wcslen(Password) * sizeof(WCHAR));

    EaBuffer = SpMemAlloc(EaBufferLength);
    if (EaBuffer == NULL) {
        SpMemFree(NtDeviceName);
        return STATUS_NO_MEMORY;
    }

    FullEaInfo = (PFILE_FULL_EA_INFORMATION)EaBuffer;

    FullEaInfo->Flags = 0;
    FullEaInfo->EaNameLength = sizeof(EA_NAME_DOMAIN) - 1;
    FullEaInfo->EaValueLength = (wcslen(DomainName)) * sizeof(WCHAR);
    strcpy(&(FullEaInfo->EaName[0]), EA_NAME_DOMAIN);
    memcpy(&(FullEaInfo->EaName[FullEaInfo->EaNameLength + 1]), DomainName, FullEaInfo->EaValueLength);
    FullEaInfo->NextEntryOffset = FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  FullEaInfo->EaNameLength + 1 +
                                  FullEaInfo->EaValueLength;
    if (FullEaInfo->NextEntryOffset & (sizeof(ULONG) - 1)) {
        FullEaInfo->NextEntryOffset += (sizeof(ULONG) - 
                                         (FullEaInfo->NextEntryOffset & 
                                          (sizeof(ULONG) - 1)));
    }


    FullEaInfo = (PFILE_FULL_EA_INFORMATION)(((char *)FullEaInfo) + FullEaInfo->NextEntryOffset);

    FullEaInfo->Flags = 0;
    FullEaInfo->EaNameLength = sizeof(EA_NAME_USERNAME) - 1;
    FullEaInfo->EaValueLength = (wcslen(UserName)) * sizeof(WCHAR);
    strcpy(&(FullEaInfo->EaName[0]), EA_NAME_USERNAME);
    memcpy(&(FullEaInfo->EaName[FullEaInfo->EaNameLength + 1]), UserName, FullEaInfo->EaValueLength);
    FullEaInfo->NextEntryOffset = FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  FullEaInfo->EaNameLength + 1 +
                                  FullEaInfo->EaValueLength;
    if (FullEaInfo->NextEntryOffset & (sizeof(ULONG) - 1)) {
        FullEaInfo->NextEntryOffset += (sizeof(ULONG) - 
                                         (FullEaInfo->NextEntryOffset & 
                                          (sizeof(ULONG) - 1)));
    }


    FullEaInfo = (PFILE_FULL_EA_INFORMATION)(((char *)FullEaInfo) + FullEaInfo->NextEntryOffset);

    FullEaInfo->Flags = 0;
    FullEaInfo->EaNameLength = sizeof(EA_NAME_PASSWORD) - 1;
    FullEaInfo->EaValueLength = (wcslen(Password)) * sizeof(WCHAR);
    strcpy(&(FullEaInfo->EaName[0]), EA_NAME_PASSWORD);
    memcpy(&(FullEaInfo->EaName[FullEaInfo->EaNameLength + 1]), Password, FullEaInfo->EaValueLength);
    FullEaInfo->NextEntryOffset = 0;

    //
    // Now make the connection
    //
    RtlInitUnicodeString(&UnicodeString, NtDeviceName);
    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = ZwCreateFile(&Handle,
                          SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ,
                          FILE_OPEN_IF,
                          (FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT),
                          EaBuffer,
                          EaBufferLength
                         );

    if (NT_SUCCESS(Status) && NT_SUCCESS(IoStatusBlock.Status)) {
        //
        // Save off the handle so we can close it later if need be
        //
        NetUseHandles[DriveLetter - L'A'] = Handle;
        Drive[0] = DriveLetter;
        Drive[1] = L':';
        Drive[2] = UNICODE_NULL;

        //
        // Now create a symbolic link from the dos drive letter to the redirector
        //
        wcscpy(temporaryBuffer, L"\\DosDevices\\");
        wcscat(temporaryBuffer, Drive);
        RtlInitUnicodeString(&UnicodeString2, temporaryBuffer);

        Status = IoCreateSymbolicLink(&UnicodeString2, &UnicodeString);
        if (!NT_SUCCESS(Status)) {
            ZwClose(Handle);
            NetUseHandles[DriveLetter - L'A'] = NULL;
        } else {
            RcAddDrive(DriveLetter);
        }

    }

    SpMemFree(NtDeviceName);
    return Status;
}
        

NTSTATUS
RcNetUnuse(
    PWSTR Drive
    )

/*++

Routine Description:

    This routine closes a network connection.

Arguments:

    Drive - A string of the form "X:", where X is the drive letter returned by a previous call to 
        NetDoNetUse().

Return Value:

    STATUS_SUCCESS if successful, indicating the drive letter has been unmapped,
    otherwise the appropriate error code.

--*/

{
    NTSTATUS Status;
    WCHAR DriveLetter;
    WCHAR temporaryBuffer[128];
    UNICODE_STRING UnicodeString;

    DriveLetter = *Drive;
    if ((DriveLetter >= L'a') && (DriveLetter <= L'z')) {
        DriveLetter = L'A' + (DriveLetter - L'a');
    }

    if ((DriveLetter < L'A') | (DriveLetter > L'Z')) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    if (NetUseHandles[DriveLetter - L'A'] == NULL) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    if (RcGetCurrentDriveLetter() == DriveLetter) {
        return STATUS_CONNECTION_IN_USE;
    }

    wcscpy(temporaryBuffer, L"\\DosDevices\\");
    wcscat(temporaryBuffer, Drive);
    RtlInitUnicodeString(&UnicodeString, temporaryBuffer);

    Status = IoDeleteSymbolicLink(&UnicodeString);

    if (NT_SUCCESS(Status)) {
        ZwClose(NetUseHandles[DriveLetter - L'A']);
        NetUseHandles[DriveLetter - L'A'] = NULL;
        RcRemoveDrive(DriveLetter);
    }

    return Status;
}



NTSTATUS
PutRdrInKernelMode(
    VOID
    )

/*++

Routine Description:

    This routine IOCTLs down to the rdr to force it to use kernel-mode security.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS if successful, otherwise the appropriate error code.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    HANDLE Handle;

    RtlInitUnicodeString(&UnicodeString, DD_NFS_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
                &Handle,
                GENERIC_READ | GENERIC_WRITE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if (!NT_SUCCESS(Status)) {
        KdPrint(("SPCMDCON: Unable to open redirector. %x\n", Status));
        return Status;
    }

    Status = ZwDeviceIoControlFile(Handle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_LMMR_USEKERNELSEC,
                                   NULL,
                                   0,
                                   NULL,
                                   0
                                  );

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;
    }

    ZwClose(Handle);

    return Status;
}

BOOLEAN
RcIsArc(
    VOID
    )

/*++

Routine Description:

    Run time check to determine if this is an Arc system. We attempt to read an
    Arc variable using the Hal. This will fail for Bios based systems.

Arguments:

    None

Return Value:

    True = This is an Arc system.

--*/

{
#ifdef _X86_
    ARC_STATUS ArcStatus = EBADF;
    //
    // Get the env var into the temp buffer.
    //
    UCHAR   wbuff[130];
    //
    // Get the env var into the temp buffer.
    //
    ArcStatus = HalGetEnvironmentVariable(
                    "OsLoader",
                    sizeof(wbuff),
                    wbuff
                    );

    return((ArcStatus == ESUCCESS) ? TRUE: FALSE);
#else
    return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\disksig\disksig.c ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MBR_BOOTCODE_BYTE_OFFSET        (0)
#define MBR_DISK_SIGNATURE_BYTE_OFFSET  (440)
#define MBR_FILLER_OFFSET               (MBR_DISK_SIGNATURE_BYTE_OFFSET + 4)
#define MBR_PARTITION_TABLE_OFFSET      (MBR_FILLER_OFFSET+2)
#define MBR_AA55SIGNATURE_OFFSET        (512-2)



typedef struct _REAL_DISK_PTE {

    UCHAR ActiveFlag;

    UCHAR StartHead;
    UCHAR StartSector;
    UCHAR StartCylinder;

    UCHAR SystemId;

    UCHAR EndHead;
    UCHAR EndSector;
    UCHAR EndCylinder;

    UCHAR RelativeSectors[4];
    UCHAR SectorCount[4];

} REAL_DISK_PTE, *PREAL_DISK_PTE;

REAL_DISK_PTE   *MyPte;

BYTE TemporaryBuffer[4096*16];


int _cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;
    DWORD Size;
    DWORD Signature;
    BOOL rVal;
    DWORD i, j, k;
    DWORD ErrorCode = ERROR_SUCCESS;

    SetErrorMode(SEM_FAILCRITICALERRORS);

    if( (argc == 2) && !_strcmpi( argv[1], "-dump" ) ) {
        //
        // Just dump the signatures.
        //
        for (i=0; i<999; i++) {
            sprintf( (LPSTR)TemporaryBuffer, "\\\\.\\PhysicalDrive%d", i );

            hFile = CreateFile( (LPSTR)TemporaryBuffer,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL );

            if (hFile != INVALID_HANDLE_VALUE) {
                //
                // NOTE: We don't use IOCTL_DISK_GET_DRIVE_LAYOUT_EX
                // since it returns cached signature value.
                //
                if (DeviceIoControl( hFile,
                            IOCTL_DISK_GET_DRIVE_GEOMETRY,
                            NULL,
                            0,
                            TemporaryBuffer,
                            sizeof(TemporaryBuffer),
                            &Size,
                            NULL)) {
                    DWORD SectorSize = ((PDISK_GEOMETRY)(TemporaryBuffer))->BytesPerSector;
                    PUCHAR Sector = (PUCHAR)TemporaryBuffer;
                    DWORD BytesRead = 0;
                    LARGE_INTEGER Offset = {0};
                   
                    //
                    // Read the boot sector (NOTE : This code doesn't handle MBR INT13 hookers)
                    //    
                    if (ReadFile(hFile, Sector, SectorSize, &BytesRead, NULL)) {                        
                        PDWORD OldSignature = (PDWORD)(Sector + MBR_DISK_SIGNATURE_BYTE_OFFSET);

                        printf( "\nMaster Boot Record for PhysicalDrive%d:\n", i);
                        printf( "======================================\n");

                        printf( "Boot Code:\n" );
                        for (j = 0; j < MBR_DISK_SIGNATURE_BYTE_OFFSET; j += 20) {
                            printf( "  " );
                            for( k = 0; k < 20; k++ ) {
                                printf( "0x%02x ", *(PUCHAR)(Sector + (j+k)) );
                            }
                            printf( "\n" );
                        }

                        printf( "\nSignature: 0x%08lx\n", *OldSignature );

                        printf( "\nPartition Table Entries:\n" );
                        MyPte = (PREAL_DISK_PTE)(PUCHAR)(Sector + MBR_PARTITION_TABLE_OFFSET);
                        for( j = 0; j < 4; j++ ) {
                            printf( "  PartitionEntry%d\n", j );
                            printf( "  ActiveFlag:      0x%02lx\n", MyPte->ActiveFlag );
                            printf( "  StartHead:       0x%02lx\n", MyPte->StartHead );
                            printf( "  StartSector:     0x%02lx\n", MyPte->StartSector );
                            printf( "  StartCylinder:   0x%02lx\n", MyPte->StartCylinder );
                            printf( "  SystemId:        0x%02lx\n", MyPte->SystemId );
                            printf( "  EndHead:         0x%02lx\n", MyPte->EndHead );
                            printf( "  EndSector:       0x%02lx\n", MyPte->EndSector );
                            printf( "  EndCylinder:     0x%02lx\n", MyPte->EndCylinder );
                            printf( "  RelativeSectors: 0x%08lx\n", *(DWORD *)(&(MyPte->EndCylinder)) );
                            printf( "  SectorCount:     0x%08lx\n", *(DWORD *)(&(MyPte->SectorCount)) );
                            printf( "\n" );
                            MyPte += 1;
                        }

                        printf( "AA55Signature: 0x%2lx%2lx\n", *(Sector+MBR_AA55SIGNATURE_OFFSET), *(Sector+MBR_AA55SIGNATURE_OFFSET+1) );

                    
                    } else {
                        ErrorCode = GetLastError();
                        printf( "Failed to read sector 0 (Error: %d)\n", ErrorCode );
                    }                    
                } else {
                    ErrorCode = GetLastError();
                    printf( "Failed to retrieve disk geometry information (Error: %d)\n", ErrorCode );
                }                    

                CloseHandle( hFile );
            } else {
                ErrorCode = GetLastError();
                printf( "Failed to open the physical disk (Error: %d)\n", ErrorCode );
            }                
        }
    } else if( (argc == 4) && !_strcmpi( argv[1], "-set" ) ) {
        //
        // Get the disk number.
        //
        i = strtoul( argv[2], NULL, 16 );

        //
        // Get the Signature.
        //
        Signature = strtoul( argv[3], NULL, 16 );

        sprintf( (LPSTR)TemporaryBuffer, "\\\\.\\PhysicalDrive%d", i );

        hFile = CreateFile( (LPSTR)TemporaryBuffer,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            INVALID_HANDLE_VALUE );
                            
        if (hFile != INVALID_HANDLE_VALUE) {

            if (DeviceIoControl( hFile,
                        IOCTL_DISK_GET_DRIVE_GEOMETRY,
                        NULL,
                        0,
                        TemporaryBuffer,
                        sizeof(TemporaryBuffer),
                        &Size,
                        NULL)) {
                DWORD SectorSize = ((PDISK_GEOMETRY)(TemporaryBuffer))->BytesPerSector;
                PUCHAR Sector = (PUCHAR)TemporaryBuffer;
                DWORD BytesRead = 0;
                LARGE_INTEGER Offset = {0};
               
                //
                // Read the boot sector (NOTE : This code doesn't handle MBR INT13 hookers)
                //    
                if (ReadFile(hFile, Sector, SectorSize, &BytesRead, NULL) && 
                    (BytesRead == SectorSize) &&
                    SetFilePointerEx(hFile, Offset, NULL, FILE_BEGIN)) {
                    
                    DWORD BytesWritten = 0;
                    PDWORD OldSignature = (PDWORD)(Sector + MBR_DISK_SIGNATURE_BYTE_OFFSET);

                    printf( "Setting PhysicalDrive%d Signature=0x%08x\n", i, Signature );
                    *OldSignature = Signature;

                    if (!WriteFile(hFile, Sector, SectorSize, &BytesWritten, NULL)) {
                        ErrorCode = GetLastError();
                    } else if (BytesWritten != SectorSize) {
                        ErrorCode = ERROR_IO_DEVICE;
                    }
                } else {
                    ErrorCode = GetLastError();

                    if (ErrorCode == ERROR_SUCCESS) {
                        ErrorCode = ERROR_IO_DEVICE;
                    }
                }                    
            } else {
                ErrorCode = GetLastError();
            }                

            CloseHandle( hFile );
        } else {
            ErrorCode = GetLastError();
        }            
    } else {
        printf( "Usage: %s <parameters>\n", argv[0] );
        printf( "    Where <parameters> are:\n" );
        printf( "    -dump                              dumps MBR for all disks\n" );
        printf( "    -set <disk num> <hex signature>    sets signature for specified disk\n" );
    }
    
    return ErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\inc\setupdd.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    setupdd.h

Abstract:

    Public header file for setup device driver.

Author:

    Ted Miller (tedm) 11-August-1993

Revision History:

--*/


#ifndef _SETUPDD_
#define _SETUPDD_


#define DD_SETUP_DEVICE_NAME_U  L"\\Device\\Setup"


#define IOCTL_SETUP_START           CTL_CODE(FILE_DEVICE_UNKNOWN,0,METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_SETUP_FMIFS_MESSAGE   CTL_CODE(FILE_DEVICE_UNKNOWN,1,METHOD_BUFFERED,FILE_WRITE_ACCESS)


typedef struct _SETUP_COMMUNICATION {

    union {
        ULONG     RequestNumber;
        NTSTATUS  Status;
        DWORD_PTR UnusedAlign64;
    } u;

    UCHAR Buffer[2048];

} SETUP_COMMUNICATION, *PSETUP_COMMUNICATION;


//
// Input structure for IOCTL_SETUP_START.
//

typedef struct _SETUP_START_INFO {

    //
    // Handles of events used for communication between
    // device driver and user-mode parts of text setup.
    //
    HANDLE RequestReadyEvent;
    HANDLE RequestServicedEvent;

    //
    // Base address of the user-mode process.
    // This is used by the device driver to load massages
    // from the user-mode process' resource tables.
    //
    PVOID UserModeImageBase;

    //
    // System information structure.
    //
    SYSTEM_BASIC_INFORMATION SystemBasicInfo;

    //
    // Address of a buffer in the user process' address space,
    // to be used for same communication.
    //
    PSETUP_COMMUNICATION Communication;

} SETUP_START_INFO, *PSETUP_START_INFO;


//
// Input structure for IOCTL_SETUP_FMIFS_MESSAGE
//

typedef struct _SETUP_DISPLAY_INFO {

    FMIFS_PACKET_TYPE   FmifsPacketType;
    PVOID               FmifsPacket;

} SETUP_FMIFS_MESSAGE, *PSETUP_FMIFS_MESSAGE;




typedef enum {
    SetupServiceDone,
    SetupServiceExecute,
    SetupServiceQueryDirectoryObject,
    SetupServiceFlushVirtualMemory,
    SetupServiceShutdownSystem,
    SetupServiceDeleteKey,
    SetupServiceLoadKbdLayoutDll,
    SetupServiceLockVolume,
    SetupServiceUnlockVolume,
    SetupServiceDismountVolume,
    SetupServiceSetDefaultFileSecurity,
    SetupServiceVerifyFileAccess,
    SetupServiceCreatePageFile,
    SetupServiceGetFullPathName,
    SetupServiceMax
};


typedef struct _SERVICE_EXECUTE {

    PWSTR FullImagePath;
    PWSTR CommandLine;
    ULONG ReturnStatus;

    //
    // The two nul-terminated strings follow in the buffer.
    //
    WCHAR Buffer[1];

} SERVICE_EXECUTE, *PSERVICE_EXECUTE;

typedef struct _SERVICE_DELETE_KEY {

    HANDLE KeyRootDirectory;
    PWSTR  Key;

    //
    // The nul-terminated string follows in the buffer.
    //
    WCHAR Buffer[1];

} SERVICE_DELETE_KEY, *PSERVICE_DELETE_KEY;

typedef struct _SERVICE_QUERY_DIRECTORY_OBJECT {

    HANDLE  DirectoryHandle;
    ULONG   Context;
    BOOLEAN RestartScan;

    //
    // Make sure this fits within the Buffer field of SETUP_COMMUNICATION.
    // It's an arroy of ULONGs to force alignment.
    //
    ULONG  Buffer[256];

} SERVICE_QUERY_DIRECTORY_OBJECT, *PSERVICE_QUERY_DIRECTORY_OBJECT;


typedef struct _SERVICE_FLUSH_VIRTUAL_MEMORY {

    IN PVOID BaseAddress;
    IN SIZE_T RangeLength;

} SERVICE_FLUSH_VIRTUAL_MEMORY, *PSERVICE_FLUSH_VIRTUAL_MEMORY;


typedef struct _SERVICE_LOAD_KBD_LAYOUT_DLL {

    PVOID TableAddress;
    WCHAR DllName[1];

} SERVICE_LOAD_KBD_LAYOUT_DLL, *PSERVICE_LOAD_KBD_LAYOUT_DLL;

typedef struct _SERVICE_LOCK_UNLOCK_VOLUME {

    HANDLE Handle;

} SERVICE_LOCK_UNLOCK_VOLUME, *PSERVICE_LOCK_UNLOCK_VOLUME;

typedef struct _SERVICE_DISMOUNT_VOLUME {

    HANDLE Handle;

} SERVICE_LOCK_DISMOUNT_VOLUME, *PSERVICE_DISMOUNT_VOLUME;

typedef struct _SERVICE_VERIFY_FILE_ACESS {

    ACCESS_MASK DesiredAccess;
    WCHAR       FileName[1];

} SERVICE_VERIFY_FILE_ACCESS, *PSERVICE_VERIFY_FILE_ACCESS;

typedef struct _SERVICE_DEFAULT_FILE_SECURITY {

    WCHAR FileName[1];

} SERVICE_DEFAULT_FILE_SECURITY, *PSERVICE_DEFAULT_FILE_SECURITY;

typedef struct _SERVICE_CREATE_PAGEFILE {

    LARGE_INTEGER MinSize;
    LARGE_INTEGER MaxSize;
    WCHAR FileName[1];

} SERVICE_CREATE_PAGEFILE, *PSERVICE_CREATE_PAGEFILE;

typedef struct _SERVICE_GETFULLPATHNAME {
    WCHAR *NameOut;
    WCHAR FileName[1];
} SERVICE_GETFULLPATHNAME, *PSERVICE_GETFULLPATHNAME;

#endif // ndef _SETUPDD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\cmdcons\services.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    services.c

Abstract:

    This module implements all access to the services db.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

#include "ntregapi.h"

// forward-decl
BOOLEAN RcFindService(
    IN LPCWSTR     ServiceName,
    OUT HANDLE*    KeyHandle
    );
BOOLEAN RcFindServiceByDisplayName(
    IN HANDLE      ServicesKey,
    IN LPCWSTR     ServiceName,
    OUT HANDLE*    KeyHandle
    );
BOOLEAN RcGetStartType(
    IN HANDLE      hKey,
    OUT DWORD       *start_type
    );
BOOLEAN RcSetStartType(
    IN HANDLE      hKey,
    OUT DWORD      start_type
    );
BOOLEAN RcPrintStartType(
    IN ULONG       msg_id,
    IN DWORD       start_type
    );

RcOpenHive(
    PWSTR   szHiveName,
    PWSTR   szHiveKey
    );

BOOLEAN
RcCloseHive(
    PWSTR   szHiveKey 
    );
    
BOOLEAN RcOpenSystemHive();
BOOLEAN RcCloseSystemHive();
BOOLEAN RcDetermineCorrectControlKey(
    OUT DWORD *    pCorrectKey
    );


ULONG
RcCmdEnableService(
    IN PTOKENIZED_LINE TokenizedLine
    )

/*++

Routine Description:

    Top-level routine supporting the enable command in the setup diagnostic
    command interpreter.

Arguments:

    TokenizedLine - supplies structure built by the line parser describing
        each string on the line as typed by the user.

Return Value:

    None.

--*/

{
    DWORD           correctKey = 0;
    DWORD           new_start_type = 4;
    DWORD           start_type = 0;
    HANDLE          hkey = 0;

    ASSERT(TokenizedLine->TokenCount >= 1);

    // there should be three tokens,
    //    enable_service
    //    the name of the service/driver to be enabled
    //    the start_type of the service

    if (RcCmdParseHelp( TokenizedLine, MSG_SERVICE_ENABLE_HELP )) {
        return 1;
    }

    if(TokenizedLine->TokenCount == 2) {
        // just display the current setting

        RcOpenSystemHive();

        if( RcFindService( TokenizedLine->Tokens->Next->String, &hkey ) ) {
            RcMessageOut( MSG_SERVICE_FOUND, TokenizedLine->Tokens->Next->String );
            if( RcGetStartType(hkey, &start_type ) ) {
                RcPrintStartType( MSG_SERVICE_CURRENT_STATE, start_type );
                RcMessageOut( MSG_START_TYPE_NOT_SPECIFIED );
            }
        } else {
            RcMessageOut( MSG_SERVICE_NOT_FOUND, TokenizedLine->Tokens->Next->String );
        }
        NtClose( hkey );

        RcCloseSystemHive();

    } else if(TokenizedLine->TokenCount == 3) {
        // change the setting
        RcOpenSystemHive();

        if( RcFindService( TokenizedLine->Tokens->Next->String, &hkey ) ) {
            RcMessageOut( MSG_SERVICE_FOUND, TokenizedLine->Tokens->Next->String );
            // we found it - open and retrieve the start type
            if( RcGetStartType(hkey, &start_type ) ) {

                if( !_wcsicmp( TokenizedLine->Tokens->Next->Next->String, L"SERVICE_BOOT_START" ) ) {
                    new_start_type = 0;
                } else if( !_wcsicmp( TokenizedLine->Tokens->Next->Next->String, L"SERVICE_SYSTEM_START" ) ) {
                    new_start_type = 1;
                } else if( !_wcsicmp( TokenizedLine->Tokens->Next->Next->String, L"SERVICE_AUTO_START" ) ) {
                    new_start_type = 2;
                } else if( !_wcsicmp( TokenizedLine->Tokens->Next->Next->String, L"SERVICE_DEMAND_START" ) ) {
                    new_start_type = 3;
                } else {
                    new_start_type = -1;
                }

                if( new_start_type == start_type ) {
                    // the service is already in the state
                    RcPrintStartType( MSG_SERVICE_SAME_STATE, start_type );
                } else if( new_start_type != -1 ) {
                    // print the old start type
                    RcPrintStartType( MSG_SERVICE_CURRENT_STATE, start_type );

                    // setup the service
                    if( RcSetStartType( hkey, new_start_type  ) ) {
                        RcPrintStartType( MSG_SERVICE_CHANGE_STATE, new_start_type );
                    }
                } else {
                    RcMessageOut( MSG_SERVICE_ENABLE_SYNTAX_ERROR );
                }
            }

            // close the key
            NtClose( hkey );

        } else {
            // we couldn't find the service - report an error
            RcMessageOut( MSG_SERVICE_NOT_FOUND, TokenizedLine->Tokens->Next->String );
        }

        RcCloseSystemHive();

    } else {
        // oops, we didn't get two or three parameters, print a help string.
        pRcEnableMoreMode();
        RcMessageOut( MSG_SERVICE_ENABLE_HELP );
        pRcDisableMoreMode();
    }

    return 1;
}

ULONG
RcCmdDisableService(
    IN PTOKENIZED_LINE TokenizedLine
    )

/*++

Routine Description:

    Top-level routine supporting the disable command in the setup diagnostic
    command interpreter.

Arguments:

    TokenizedLine - supplies structure built by the line parser describing
        each string on the line as typed by the user.

Return Value:

    None.

--*/

{
    HANDLE          hkey;
    DWORD           start_type;
    WCHAR           start_type_string[10];
    PLINE_TOKEN     Token;
    BOOL            syntaxError = FALSE;
    BOOL            doHelp = FALSE;
    LPCWSTR         Arg;


    if (RcCmdParseHelp( TokenizedLine, MSG_SERVICE_DISABLE_HELP )) {
        return 1;
    }

    RtlZeroMemory( (VOID *)&start_type_string, sizeof( WCHAR ) * 10 );

    // the command will print the old start_type of the
    // service before it asks for verification to disable it.

    if(TokenizedLine->TokenCount == 2) {

        // find the service key
        RcOpenSystemHive();
        if( RcFindService( TokenizedLine->Tokens->Next->String, &hkey ) ) {
            RcMessageOut( MSG_SERVICE_FOUND, TokenizedLine->Tokens->Next->String );
            // we found it - open and retrieve the start type
            if( RcGetStartType(hkey, &start_type ) ) {
                if( start_type != SERVICE_DISABLED ) {
                    // print the old start type
                    RcPrintStartType( MSG_SERVICE_CURRENT_STATE, start_type );
                    // disable the service
                    if( RcSetStartType( hkey, SERVICE_DISABLED  ) ) {
                        RcPrintStartType( MSG_SERVICE_CHANGE_STATE, SERVICE_DISABLED );
                    }
                } else {
                    RcMessageOut( MSG_SERVICE_ALREADY_DISABLED, TokenizedLine->Tokens->Next->String );
                }
            }
            // close the key
            NtClose( hkey );

        } else {
            // we couldn't find the service - report an error
            RcMessageOut( MSG_SERVICE_NOT_FOUND, TokenizedLine->Tokens->Next->String );
        }
        RcCloseSystemHive();

    } else {
        // oops, we didn't get two parameters, print a help string.
        pRcEnableMoreMode();
        RcMessageOut( MSG_SERVICE_DISABLE_HELP );
        pRcDisableMoreMode();
    }

    return 1;
}

BOOLEAN
RcFindService(
    IN LPCWSTR ServiceName,
    OUT PHANDLE KeyHandle
    )

/*++

Routine Description:
   Attempts to find and open the registry key for a particular
   service by its key name in

   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services.

   If it fails, it will call RcFindServiceByDisplayName() to
   locate the service by the DisplayName string value.

Arguments:

   ServiceName - the name of the service as a wstring.

   KeyHandle - pointer to a HANDLE where the function should
               return the open registry handle.

               this handle needs to be closed when the key is no
               longer needed.

Return Value:

   TRUE indicates sucess.
   FALSE indicates that it couldn't find the service or failure.

--*/

{
    NTSTATUS                      Status;
    WCHAR                         RegPath[ MAX_PATH ];
    OBJECT_ATTRIBUTES             Obja;
    DWORD                         correctKey;

    UNICODE_STRING                ServiceString;
    HANDLE                        ServiceKeyHandle;


    // zero out the buffer
    RtlZeroMemory( (VOID * )&RegPath,
        sizeof( WCHAR ) * MAX_PATH );

    // find the correct controlset key
    if( !RcDetermineCorrectControlKey( &correctKey ) ) {
        return FALSE;
    }

    // prepend HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services to
    // the supplied parameter
    swprintf( RegPath, L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Services\\", correctKey );
    wcscat( RegPath, ServiceName );

    // build the unicode string
    RtlInitUnicodeString( &ServiceString, RegPath );
    InitializeObjectAttributes( &Obja,&ServiceString,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    // attempt to open the key.
    Status = ZwOpenKey( &ServiceKeyHandle, KEY_ALL_ACCESS, &Obja );

    if( NT_SUCCESS( Status) ) {
        // if we suceeded, set and return
        // the handle.
        *KeyHandle = ServiceKeyHandle;
    } else {

        // build the unicode string
        swprintf( RegPath, L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Services", correctKey );
        RtlInitUnicodeString( &ServiceString, RegPath );
        InitializeObjectAttributes( &Obja,&ServiceString,
            OBJ_CASE_INSENSITIVE, NULL, NULL);

        // open a handle to \\registry\\machine\\xSYSTEM\\ControlSet%03d\\Services
        if( NT_SUCCESS( ZwOpenKey( &ServiceKeyHandle, KEY_ALL_ACCESS, &Obja ) ) ) {
            if( !RcFindServiceByDisplayName( ServiceKeyHandle, ServiceName, KeyHandle ) ) {
                // if we failed, NULL out KeyHandle, and return FALSE.
                DEBUG_PRINTF(( "CMDCONS: failed to find key!\n" ));
                *KeyHandle = INVALID_HANDLE_VALUE;
                if( !NT_SUCCESS( NtClose( ServiceKeyHandle ) ) ) {
                    DEBUG_PRINTF(( "CMDCONS: failed to close service key handle\n" ));
                }
                return FALSE;
            }


            // we found the key!
            // close the service key handle
            if( !NT_SUCCESS( NtClose( ServiceKeyHandle ) ) ) {
                DEBUG_PRINTF(( "CMDCONS: failed to close service key handle\n" ));
            }
        } else {
            DEBUG_PRINTF(( "CMDCONS: failed to open service key handle\n" ));
            RcMessageOut( MSG_SYSTEM_MISSING_CURRENT_CONTROLS );
        }
    }

    // return true
    return TRUE;
}

// buffersizes
#define sizeof_buffer1 sizeof( KEY_FULL_INFORMATION ) + (MAX_PATH+1) * sizeof( WCHAR )
#define sizeof_buffer2 sizeof( KEY_BASIC_INFORMATION ) + (MAX_PATH+1) * sizeof( WCHAR )
#define sizeof_buffer3 sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + (MAX_PATH+1) * sizeof( WCHAR )

BOOLEAN
RcFindServiceByDisplayName(
    IN HANDLE ServicesKey,
    IN LPCWSTR ServiceName,
    OUT PHANDLE KeyHandle
    )

/*++

Routine Description:
   Attempts to find and open the registry key for a particular
   service by the DisplayName string value.

Arguments:

   SevicesKey - an open handle to the correct Services Key to search under

   ServiceName - the name of the service as a wstring.

   KeyHandle - pointer to a HANDLE where the function should
               return the open registry handle.

               this handle needs to be closed when the key is no
               longer needed.


Return Value:

   TRUE indicates sucess.
   FALSE indicates that it couldn't find the service or failure.

--*/
{

    WCHAR                            ValueName[] = L"DisplayName";

    BYTE                             buffer1[ sizeof_buffer1 ];
    BYTE                             buffer2[ sizeof_buffer2 ];
    BYTE                             buffer3[ sizeof_buffer3 ];

    KEY_FULL_INFORMATION             * pKeyFullInfo;
    KEY_BASIC_INFORMATION            * pKeyBasicInfo;
    KEY_VALUE_PARTIAL_INFORMATION    * pKeyValuePartialInfo;
    ULONG                            actualBytes;
    ULONG                            loopCount;
    ULONG                            keyCount;
    OBJECT_ATTRIBUTES                Obja;
    HANDLE                           newHandle;
    UNICODE_STRING                   unicodeString;
    BOOL                             keyFound = FALSE;

    // zero out the buffer
    RtlZeroMemory( (VOID * ) &(buffer1[0]), sizeof_buffer1 );

    pKeyFullInfo= (KEY_FULL_INFORMATION*) &( buffer1[0] );
    pKeyBasicInfo = (KEY_BASIC_INFORMATION* ) &( buffer2[0] );
    pKeyValuePartialInfo = (KEY_VALUE_PARTIAL_INFORMATION* ) &(buffer3[0]);

    // do a ZwQueryKey() to find out the number of subkeys.
    if( !NT_SUCCESS( ZwQueryKey( ServicesKey,
        KeyFullInformation,
        pKeyFullInfo,
        sizeof_buffer1,
        &actualBytes ) ) ) {
        *KeyHandle = INVALID_HANDLE_VALUE;
        DEBUG_PRINTF(( "FindServiceByDisplayName: failed to get number of keys!\n" ));
        return FALSE;
    }

    keyCount = pKeyFullInfo->SubKeys;

    // loop
    for( loopCount = 0; loopCount < keyCount; loopCount++ ) {
        // zero out the buffer
        RtlZeroMemory( (VOID * ) &(buffer2[0]), sizeof_buffer2 );

        // zero out the buffer
        RtlZeroMemory( (VOID * ) &(buffer3[0]), sizeof_buffer3 );

        // do an ZwEnumerateKey() to find the name of the subkey
        ZwEnumerateKey( ServicesKey,
            loopCount,
            KeyBasicInformation,
            pKeyBasicInfo,
            sizeof_buffer2,
            &actualBytes );

        // setup the ZwOpenKey() with the name we just got back
        RtlInitUnicodeString( &unicodeString, pKeyBasicInfo->Name );
        InitializeObjectAttributes( &Obja, &unicodeString,
            OBJ_CASE_INSENSITIVE, ServicesKey, NULL);

        // do a ZwOpenKey() to open the key
        if( !NT_SUCCESS( ZwOpenKey( &newHandle, KEY_ALL_ACCESS, &Obja ) ) ) {
            DEBUG_PRINTF(( "FindServiceByDisplayName: failed to open the subkey?!\n" ));
        }

        // do a ZwQueryKeyValue() to find the key value DisplayName if it exists
        RtlInitUnicodeString( &unicodeString, ValueName );

        if( !NT_SUCCESS( ZwQueryValueKey( newHandle,
            &unicodeString,
            KeyValuePartialInformation,
            pKeyValuePartialInfo,
            sizeof_buffer3,
            &actualBytes
            )
            )
            ) {
            DEBUG_PRINTF(( "FindServiceByDisplayName: display name get failed\n" ));
        } else {
            // if the ZwQueryKeyValue() succeeded
            if( pKeyValuePartialInfo->Type != REG_SZ ) {
                DEBUG_PRINTF(( "FindServiceByDisplayName: paranoia!! mismatched key type?!\n" ));
            } else {
                // paranoia check SUCCEEDED
                // if the value matches, break out of the loop
                if( _wcsicmp( (WCHAR*)&(pKeyValuePartialInfo->Data[0]), ServiceName ) == 0 ) {
                    keyFound = TRUE;
                    break;
                }
            }
        }

        // close the key
        if( !NT_SUCCESS( ZwClose( newHandle ) ) ) {
            DEBUG_PRINTF(( "FindServiceByDisplayName: Failure closing the handle!!" ));
        }
    }

    // return the handle to the opened key.
    if( keyFound == TRUE ) {
        *KeyHandle = newHandle;
        return TRUE;
    }

    *KeyHandle = INVALID_HANDLE_VALUE;
    return FALSE;
}

BOOLEAN
RcGetStartType(
    IN HANDLE hKey,
    OUT PULONG start_type
    )

/*++

Routine Description:
   Given an open service key, gets the start_type of the service.

Arguments:

   hKey - a handle to the open service key

   start_type - integer indicating the start type of the service

               SERVICE_BOOT_START   - 0x0
               SERVICE_SYSTEM_START - 0x1
               SERVICE_AUTO_START   - 0x2
               SERVUCE_DEMAMD_START - 0x3
               SERVICE_DISABLED     - 0x4

Return Value:

   TRUE indicates sucess.
   FALSE indicates failure.

--*/

{
    BYTE                                   buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 100 ]; // just grab a bunch of bytes
    ULONG                                  resultSize;
    KEY_VALUE_PARTIAL_INFORMATION          * keyPartialInfo;
    UNICODE_STRING                         StartKey;
    WCHAR                                  KEY_NAME[] = L"Start";


    RtlZeroMemory( (VOID * )&(buffer[0]),
        sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 100 );

    keyPartialInfo = (KEY_VALUE_PARTIAL_INFORMATION*)&(buffer[0]);

    ASSERT( keyPartialInfo );

    RtlInitUnicodeString( &StartKey, KEY_NAME );

    if( !NT_SUCCESS( ZwQueryValueKey( hKey,
        &StartKey,
        KeyValuePartialInformation,
        keyPartialInfo,
        sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 100,
        &resultSize
        )
        )
        ) {
        DEBUG_PRINTF(( "CMDCONS: start type get failed\n" ));
        RcMessageOut( MSG_SERVICE_MISSING_START_KEY );
        *start_type = -1;
        return FALSE;
    }

    // paranoia check
    if( keyPartialInfo->Type != REG_DWORD ) {
        RcMessageOut( MSG_SERVICE_MISSING_START_KEY );
        DEBUG_PRINTF(( "CMDCONS: mismatched key type?!\n" ));
        *start_type = -1;
        return FALSE;
    }

    *start_type = *( (DWORD*) &(keyPartialInfo->Data[0]) );
    return TRUE;
}

BOOLEAN
RcSetStartType(
    IN HANDLE hKey,
    IN DWORD start_type
    )

/*++

Routine Description:
   Given an open service key, sets the start_type of the service.

Arguments:

   hKey - a handle to the open service key

   start_type - integer indicating the start type of the service

               SERVICE_BOOT_START   - 0x0
               SERVICE_SYSTEM_START - 0x1
               SERVICE_AUTO_START   - 0x2
               SERVUCE_DEMAMD_START - 0x3
               SERVICE_DISABLED     - 0x4

Return Value:

   TRUE indicates sucess.
   FALSE indicates failure.

--*/

{
    UNICODE_STRING                         StartKey;


    RtlInitUnicodeString( &StartKey, L"Start" );

    if( NT_SUCCESS( ZwSetValueKey( hKey,
        &StartKey,
        0,
        REG_DWORD,
        &start_type,
        sizeof( DWORD )
        )
        )
        ) {
        return TRUE;
    }

    RcMessageOut( MSG_SERVICE_MISSING_START_KEY );
    DEBUG_PRINTF(( "CMDCONS: start type get failed\n" ));
    return FALSE;
}

BOOLEAN
RcPrintStartType(
    ULONG msg_id,
    DWORD start_type
    )

/*++

Routine Description:

   Prints the start_type.

Arguments:

   start_type - integer indicating the start type of the service

               SERVICE_BOOT_START   - 0x0
               SERVICE_SYSTEM_START - 0x1
               SERVICE_AUTO_START   - 0x2
               SERVUCE_DEMAMD_START - 0x3
               SERVICE_DISABLED     - 0x4

Return Value:

   TRUE - indicates sucess
   FALSE - indicates failure

--*/

{
    switch( start_type ) {
    case 0:
        RcMessageOut( msg_id, L"SERVICE_BOOT_START" );
        break;
    case 1:
        RcMessageOut( msg_id, L"SERVICE_SYSTEM_START" );
        break;
    case 2:
        RcMessageOut( msg_id, L"SERVICE_AUTO_START" );
        break;
    case 3:
        RcMessageOut( msg_id, L"SERVICE_DEMAND_START" );
        break;
    case 4:
        RcMessageOut( msg_id, L"SERVICE_DISABLED" );
        break;
    default:
        break;
    }
    return TRUE;
}

BOOLEAN
RcOpenSystemHive(
    VOID
    )

/*++

Routine Description:

   Opens the SYSTEM hive of the selected NT install.

Arguments:

   None.

Return Value:

   TRUE - indicates sucess
   FALSE - indicates failure

--*/

{
    PWSTR Hive = NULL;
    PWSTR HiveKey = NULL;
    PUCHAR buffer = NULL;
    PWSTR PartitionPath = NULL;
    NTSTATUS Status;


    if (SelectedInstall == NULL) {
        return FALSE;
    }

    //
    // Allocate buffers.
    //

    Hive = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    HiveKey = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    buffer = SpMemAlloc(BUFFERSIZE);

    //
    // Load the SYSTEM hive
    //

    wcscpy(Hive,SelectedInstall->NtNameSelectedInstall);
    SpConcatenatePaths(Hive,SelectedInstall->Path);
    SpConcatenatePaths(Hive,L"system32\\config");
    SpConcatenatePaths(Hive,L"system");

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\x<hivename>.
    //

    wcscpy(HiveKey,L"\\registry\\machine\\xSYSTEM");

    //
    // Attempt to load the key.
    //

    Status = SpLoadUnloadKey(NULL,NULL,HiveKey,Hive);
    if(!NT_SUCCESS(Status)) {
        DEBUG_PRINTF(("CMDCONS: Unable to load hive %ws to key %ws (%lx)\n",Hive,HiveKey,Status));

        SpMemFree( Hive );
        SpMemFree( HiveKey );
        SpMemFree( buffer );

        return FALSE;
    }

    SpMemFree( Hive );
    SpMemFree( HiveKey );
    SpMemFree( buffer );

    return TRUE;
}

BOOLEAN
RcCloseSystemHive(
    VOID
    )

/*++

Routine Description:

   Closes the SYSTEM hive of the selected NT install.

Arguments:

   none.

Return Value:

   TRUE - indicates sucess
   FALSE - indicates failure

--*/

{
    PWSTR HiveKey = NULL;
    NTSTATUS TmpStatus;


    //
    // Allocate buffers.
    //

    HiveKey = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    wcscpy(HiveKey,L"\\registry\\machine\\xSYSTEM");

    //
    // Unload the SYSTEM hive
    //

    TmpStatus  = SpLoadUnloadKey(NULL,NULL,HiveKey,NULL);
    if(!NT_SUCCESS(TmpStatus)) {
        KdPrint(("CMDCONS: warning: unable to unload key %ws (%lx)\n",HiveKey,TmpStatus));
        SpMemFree( HiveKey );
        return FALSE;
    }

    SpMemFree( HiveKey );

    return TRUE;
}

BOOLEAN
RcDetermineCorrectControlKey(
    OUT PULONG pCorrectKey
    )

/*++

Routine Description:

   Parses the select node and finds the correct ControlSetXXX to use.

Arguments:

   pCorrectKey - pointer to a DWORD which will contain the number.

Return Value:

   TRUE - indicates sucess
   FALSE - indicates failure

--*/

{
    NTSTATUS                      Status;
    WCHAR                         RegPath[ MAX_PATH ];
    OBJECT_ATTRIBUTES             Obja;

    UNICODE_STRING                SelectString;
    HANDLE                        SelectKeyHandle;

    BYTE                                   buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 100 ]; // just grab a bunch of bytes
    ULONG                                  resultSize = 0;
    KEY_VALUE_PARTIAL_INFORMATION          * keyPartialInfo;
    UNICODE_STRING                         SelectValue;
    WCHAR                                  VALUE_NAME[] = L"Current";


    RtlZeroMemory( (VOID * )&(buffer[0]),
        sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 100 );

    keyPartialInfo = (KEY_VALUE_PARTIAL_INFORMATION*)&(buffer[0]);

    ASSERT( keyPartialInfo );

    *pCorrectKey = -1;

    // prepend HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services to
    // the supplied parameter
    wcscpy( RegPath, L"\\registry\\machine\\xSYSTEM\\Select" );

    // build the unicode string
    RtlInitUnicodeString( &SelectString, RegPath );
    InitializeObjectAttributes( &Obja,&SelectString,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    // we need to determine the correct ControlSet to open
    Status = ZwOpenKey( &SelectKeyHandle, KEY_ALL_ACCESS, &Obja );

    if( NT_SUCCESS( Status ) ) {
        RtlInitUnicodeString( &SelectValue, VALUE_NAME );

        Status = ZwQueryValueKey( SelectKeyHandle,
            &SelectValue,
            KeyValuePartialInformation,
            keyPartialInfo,
            sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 100,
            &resultSize
            );

        if( !NT_SUCCESS(Status) || Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
            // couldn't find correct control value!
            DEBUG_PRINTF(( "CMDCONS: failed to find correct control value!\n" ));
        } else {
            // we found a control value
            // check if it's ok
            if( keyPartialInfo->Type != REG_DWORD ) {
                // paranoia check failed
                DEBUG_PRINTF(( "CMDCONS: paranoia check failed?!\n" ));
                DEBUG_PRINTF(( "CMDCONS: mismatched key type?!\n" ));
                DEBUG_PRINTF(( "CMDCONS: key type of %d?!\n", keyPartialInfo->Type ));
                DEBUG_PRINTF(( "CMDCONS: resultsize of %d?!\n", resultSize ));
            } else {
                // parnoia check sucess
                *pCorrectKey = *( (DWORD*) &(keyPartialInfo->Data[0]) );
                Status = NtClose( SelectKeyHandle );
                if( !NT_SUCCESS ( Status ) ) {
                    DEBUG_PRINTF(( "CMDCONS: failure closing handle?!\n" ));
                }
                return TRUE;
            }
        }
    }

    // failed to find the Select node.
    RcMessageOut( MSG_SYSTEM_MISSING_CURRENT_CONTROLS );
    DEBUG_PRINTF(( "CMDCONS: failed to find select node!\n", *pCorrectKey ));

    Status = NtClose( SelectKeyHandle );
    if( !NT_SUCCESS ( Status ) ) {
        DEBUG_PRINTF(( "CMDCONS: failure closing handle?!\n" ));
    }

    return FALSE;
}


ULONG
RcCmdListSvc(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    #define DISPLAY_BUFFER_SIZE 512
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ServiceKeyHandle = NULL;
    ULONG ControlSetNumber;
    ULONG cb;
    ULONG KeyCount;
    ULONG i;
    HANDLE ValueHandle;
    ULONG StartType;
    PWSTR DisplayBuffer = NULL;
    PKEY_BASIC_INFORMATION bi;
    PKEY_VALUE_PARTIAL_INFORMATION pi;
    WCHAR ServiceName[64];
    PWSTR DisplayName;
    static ULONG StartTypeIds[] = { 
                                  MSG_SVCTYPE_BOOT,
                                  MSG_SVCTYPE_SYSTEM,
                                  MSG_SVCTYPE_AUTO,
                                  MSG_SVCTYPE_MANUAL,
                                  MSG_SVCTYPE_DISABLED
                                };
    static WCHAR *StartTypeStr[sizeof(StartTypeIds)/sizeof(ULONG)] = { 0 };
    static WCHAR *DefaultSvcTypes[sizeof(StartTypeIds)/sizeof(ULONG)] = 
                    { L"Boot", L"System", L"Auto", L"Manual", L"Disabled" };

    if (!StartTypeStr[0]) {
      //
      // load all the service type strings
      //
      ULONG Index;
      
      for (Index = 0; Index < sizeof(StartTypeIds)/sizeof(ULONG); Index++) {
        StartTypeStr[Index] = SpRetreiveMessageText(ImageBase, StartTypeIds[Index],
                                          NULL, 0);

        if (!StartTypeStr[Index])
          StartTypeStr[Index] = DefaultSvcTypes[Index];
      }
    }

    if (RcCmdParseHelp( TokenizedLine, MSG_LISTSVC_HELP )) {
        return 1;
    }

    if (!RcOpenSystemHive()) {
        return 1;
    }

    pRcEnableMoreMode();

    if (!RcDetermineCorrectControlKey( &ControlSetNumber ) ) {
        goto exit;
    }

    DisplayBuffer = (PWSTR) SpMemAlloc( DISPLAY_BUFFER_SIZE );
    if (DisplayBuffer == NULL) {
        goto exit;
    }

    swprintf( _CmdConsBlock->TemporaryBuffer, L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Services\\", ControlSetNumber );
    RtlInitUnicodeString( &UnicodeString, _CmdConsBlock->TemporaryBuffer );
    InitializeObjectAttributes( &Obja, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL );

    Status = ZwOpenKey( &ServiceKeyHandle, KEY_ALL_ACCESS, &Obja );
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    Status = ZwQueryKey(
        ServiceKeyHandle,
        KeyFullInformation,
        _CmdConsBlock->TemporaryBuffer,
        _CmdConsBlock->TemporaryBufferSize,
        &cb
        );
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    KeyCount = ((KEY_FULL_INFORMATION*)_CmdConsBlock->TemporaryBuffer)->SubKeys;
    bi = (PKEY_BASIC_INFORMATION)_CmdConsBlock->TemporaryBuffer;
    pi = (PKEY_VALUE_PARTIAL_INFORMATION)_CmdConsBlock->TemporaryBuffer;

    for (i=0; i<KeyCount; i++) {

        RtlZeroMemory( DisplayBuffer, DISPLAY_BUFFER_SIZE );
        RtlZeroMemory( _CmdConsBlock->TemporaryBuffer, _CmdConsBlock->TemporaryBufferSize );

        Status = ZwEnumerateKey(
            ServiceKeyHandle,
            i,
            KeyBasicInformation,
            _CmdConsBlock->TemporaryBuffer,
            _CmdConsBlock->TemporaryBufferSize,
            &cb
            );
        if (!NT_SUCCESS(Status)) {
            goto exit;
        }

        wcsncpy( ServiceName, bi->Name, (sizeof(ServiceName)/sizeof(WCHAR))-1 );

        RtlInitUnicodeString( &UnicodeString, bi->Name );
        InitializeObjectAttributes( &Obja, &UnicodeString, OBJ_CASE_INSENSITIVE, ServiceKeyHandle, NULL );

        Status = ZwOpenKey( &ValueHandle, KEY_ALL_ACCESS, &Obja );
        if (!NT_SUCCESS(Status)) {
            goto exit;
        }

        RtlInitUnicodeString( &UnicodeString, L"Start" );

        Status = ZwQueryValueKey(
            ValueHandle,
            &UnicodeString,
            KeyValuePartialInformation,
            _CmdConsBlock->TemporaryBuffer,
            _CmdConsBlock->TemporaryBufferSize,
            &cb
            );
        if (!NT_SUCCESS(Status)) {
            ZwClose( ValueHandle );
            continue;
        }

        if (pi->Type != REG_DWORD) {
            StartType = 5;
        } else {
            StartType = *(PULONG)&(pi->Data[0]);
        }

        RtlInitUnicodeString( &UnicodeString, L"DisplayName" );

        Status = ZwQueryValueKey(
            ValueHandle,
            &UnicodeString,
            KeyValuePartialInformation,
            _CmdConsBlock->TemporaryBuffer,
            _CmdConsBlock->TemporaryBufferSize,
            &cb
            );
        if (NT_SUCCESS(Status)) {
            DisplayName = (PWSTR)&(pi->Data[0]);
        } else {
            DisplayName = NULL;
        }

        ZwClose( ValueHandle );

        if (StartType != 5) {
            swprintf( DisplayBuffer, L"%-15s  %-8s  %s\r\n",
                ServiceName,
                StartTypeStr[StartType],
                DisplayName == NULL ? L"" : DisplayName
                );
            if (!RcTextOut( DisplayBuffer )){
                goto exit;
            }
        }
    }

exit:
    if (ServiceKeyHandle) {
        ZwClose( ServiceKeyHandle );
    }
    
    RcCloseSystemHive();

    if (DisplayBuffer) {
        SpMemFree(DisplayBuffer);
    }

    pRcDisableMoreMode();

    return 1;
}

#define VERIFIER_DRV_LEVEL  L"VerifyDriverLevel"
#define VERIFIER_DRIVERS    L"VerifyDrivers"
#define VERIFIER_IO_LEVEL   L"IoVerifierLevel"
#define VERIFIER_QUERY_INFO L"Flags = %ld; IO Level = %ld\r\nDrivers = %ws\r\n"
#define MEMMGR_PATH L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Control\\Session Manager\\Memory Management"
#define IOSYS_PATH  L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Control\\Session Manager\\I/O System"
#define SYS_HIVE_NAME L"system"
#define SYS_HIVE_KEY  L"\\registry\\machine\\xSYSTEM"

ULONG
RcCmdVerifier(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
  BOOLEAN ShowHelp = FALSE;
  WCHAR *Args[128] = {0};
  ULONG Index;
  PLINE_TOKEN CurrToken = 0;
  WCHAR Drivers[256] = {0};
  DWORD Flags = -1;
  DWORD IoLevel = -1;
  BOOLEAN DisplaySettings = FALSE;
  UNICODE_STRING UnicodeString;
  ULONG NumArgs = 0;
  BOOLEAN UseDefFlags = TRUE;
  BOOLEAN UseDefIoLevel = TRUE;
  BOOLEAN ResetSettings = FALSE;
  
  if (RcCmdParseHelp(TokenizedLine, MSG_VERIFIER_HELP)) {
    return 1;
  }

  //
  // parse the arguments
  //
  Index = 0;
  CurrToken = TokenizedLine->Tokens;
  
  do {
    Args[Index] = CurrToken->String;
    CurrToken = CurrToken->Next;
    Index++;
  }
  while ((Index < TokenizedLine->TokenCount) && 
          (Index < sizeof(Args)/sizeof(PWCHAR)) && CurrToken);   

  NumArgs = min(TokenizedLine->TokenCount, Index);          

  if (TokenizedLine->TokenCount == 2) {
    //
    // should be one of /all, /reset, /query
    //
    if (!_wcsicmp(Args[1], L"/all")) {
      wcscpy(Drivers, L"*");
      Flags = 0;
      IoLevel = 1;
    } else if (!_wcsicmp(Args[1], L"/reset")) {
      Drivers[0] = 0;
      Flags = 0;
      IoLevel = 1;
      ResetSettings = TRUE;
    } else if (!_wcsicmp(Args[1], L"/query")) {      
      DisplaySettings = TRUE;
    } else {
      ShowHelp = TRUE;
    }
  } else {
    ULONG NextArg = 1;
    
    if (!_wcsicmp(Args[NextArg], L"/flags")) {
      RtlInitUnicodeString(&UnicodeString, Args[NextArg + 1]);
      RtlUnicodeStringToInteger(&UnicodeString, 10, &Flags);
      NextArg += 2;
      UseDefFlags = FALSE;
    } 

    if (!_wcsicmp(Args[NextArg], L"/iolevel")) {
      RtlInitUnicodeString(&UnicodeString, Args[NextArg + 1]);
      RtlUnicodeStringToInteger(&UnicodeString, 10, &IoLevel);
      NextArg += 2;
      UseDefIoLevel = FALSE;        
    }

    if (!_wcsicmp(Args[NextArg], L"/driver")) {
      ULONG Len = 0;
      Drivers[0] = 0;

      for (Index = NextArg + 1; Index < NumArgs; Index++) {
        wcscat(Drivers, Args[Index]);
        wcscat(Drivers, L" ");
      }

      if (!Drivers[0])
        ShowHelp = TRUE;  // need a driver name
    } else if (!_wcsicmp(Args[NextArg], L"/all")) {
      wcscpy(Drivers, L"*");
    } else {
      ShowHelp = TRUE;
    }        
  }

  //
  // Verify the arguments
  //
  if (!ShowHelp) {
    ShowHelp = !DisplaySettings && !ResetSettings &&
      (Flags == -1) && (IoLevel == -1) && (!Drivers[0]);
  }

  if (ShowHelp) {
    pRcEnableMoreMode();
    RcMessageOut(MSG_VERIFIER_HELP);    
    pRcDisableMoreMode();
  } else {
    ULONG ControlSetNumber = 0;
    HANDLE MemMgrKeyHandle = NULL;
    HANDLE IOMgrKeyHandle = NULL;
    OBJECT_ATTRIBUTES ObjAttrs;
    BOOLEAN KeysOpened = FALSE;
    PVOID TemporaryBuffer = _CmdConsBlock->TemporaryBuffer;
    ULONG TemporaryBufferSize = _CmdConsBlock->TemporaryBufferSize;      
    NTSTATUS Status;
    BOOLEAN SysHiveOpened;

    //
    // open the system hive & determine correct control set to use
    //
    SysHiveOpened = (BOOLEAN)RcOpenHive(SYS_HIVE_NAME, SYS_HIVE_KEY);

    //
    // get the control set which we are going to manipulate
    //
    if (SysHiveOpened && RcDetermineCorrectControlKey(&ControlSetNumber)) {
      //
      // open "Memory Management" subkey under "SM"
      //
      swprintf((PWSTR)TemporaryBuffer, MEMMGR_PATH, ControlSetNumber);           

      RtlInitUnicodeString(&UnicodeString, (PWSTR)TemporaryBuffer);
      InitializeObjectAttributes(&ObjAttrs, &UnicodeString, 
            OBJ_CASE_INSENSITIVE, NULL, NULL);

      Status = ZwOpenKey(&MemMgrKeyHandle, KEY_ALL_ACCESS, &ObjAttrs);

      if (NT_SUCCESS(Status)) {
        //
        // open "I/O System" subkey under "SM"
        //
        swprintf((PWSTR)TemporaryBuffer, IOSYS_PATH, ControlSetNumber);
             
        RtlInitUnicodeString(&UnicodeString, (PWSTR)TemporaryBuffer);
        InitializeObjectAttributes(&ObjAttrs, &UnicodeString, 
              OBJ_CASE_INSENSITIVE, NULL, NULL);

        Status = ZwOpenKey(&IOMgrKeyHandle, KEY_ALL_ACCESS, &ObjAttrs);

        if (!NT_SUCCESS(Status)) {
          ULONG Disposition = 0;
          
          //
          // Create "I/O System" subkey under "SM", if it does not exist
          //
          Status = ZwCreateKey(&IOMgrKeyHandle, KEY_ALL_ACCESS, &ObjAttrs,
                        0, NULL, REG_OPTION_NON_VOLATILE, NULL);
        }                        

        if (NT_SUCCESS(Status))
          KeysOpened = TRUE;
      }
    }

    if (KeysOpened) {
      ULONG ByteCount = 0;
      ULONG KeyCount = 0;
      PKEY_VALUE_FULL_INFORMATION ValueFullInfo;
      WCHAR ValueName[256];
      ULONG Len;
           
      if (DisplaySettings) {
        //
        // Query the Flags and Drivers 
        //
        Flags = 0;
        Drivers[0] = 0;
        
        for(Index=0; ;Index++){
          Status = ZwEnumerateValueKey(
                      MemMgrKeyHandle,
                      Index,
                      KeyValueFullInformation,
                      TemporaryBuffer,
                      TemporaryBufferSize,
                      &ByteCount
                      );
                      
          if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_NO_MORE_ENTRIES)
              Status = STATUS_SUCCESS;

            break;                
          }

          ValueFullInfo = (PKEY_VALUE_FULL_INFORMATION)TemporaryBuffer;
          Len = ValueFullInfo->NameLength / sizeof(WCHAR);
          wcsncpy(ValueName, ValueFullInfo->Name, Len);
          ValueName[Len] = 0;
          
          if ((!_wcsicmp(ValueName, VERIFIER_DRV_LEVEL)) && 
               (ValueFullInfo->Type == REG_DWORD)) {
            Flags = *(PDWORD)(((PUCHAR)ValueFullInfo) + ValueFullInfo->DataOffset);
          } else if ((!_wcsicmp(ValueName, VERIFIER_DRIVERS)) &&
                     (ValueFullInfo->Type == REG_SZ)) {
            Len = ValueFullInfo->DataLength / sizeof(WCHAR);                     
            wcsncpy(Drivers, (PWSTR)(((PUCHAR)ValueFullInfo) + ValueFullInfo->DataOffset),
                      Len);
            Drivers[Len] = 0;                      
          }              
        }

        //
        // Query the IO level
        //
        for(Index=0; ;Index++){
          Status = ZwEnumerateValueKey(
                      IOMgrKeyHandle,
                      Index,
                      KeyValueFullInformation,
                      TemporaryBuffer,
                      TemporaryBufferSize,
                      &ByteCount
                      );
                      
          if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_NO_MORE_ENTRIES)
              Status = STATUS_SUCCESS;

            break;                
          }

          ValueFullInfo = (PKEY_VALUE_FULL_INFORMATION)TemporaryBuffer;
          Len = ValueFullInfo->NameLength / sizeof(WCHAR);
          wcsncpy(ValueName, ValueFullInfo->Name, Len);
          ValueName[Len] = 0;
          
          if ((!_wcsicmp(ValueName, VERIFIER_IO_LEVEL)) && 
               (ValueFullInfo->Type == REG_DWORD)) {
            IoLevel = *(PDWORD)(((PUCHAR)ValueFullInfo) + ValueFullInfo->DataOffset);
          }
        }

        if (IoLevel == 3)
          IoLevel = 2;
        else
          IoLevel = 1;
          
        //
        // format the output and display it
        //
        swprintf((PWSTR)TemporaryBuffer, VERIFIER_QUERY_INFO,
            Flags, IoLevel, Drivers);

        RcTextOut((PWSTR)TemporaryBuffer);            
      } else {
        //
        // If IO verify bit is not set, then clear IoLevel
        //
        if (!(Flags & 0x10))
          IoLevel = 0;  

        if (IoLevel == 2)
          IoLevel = 3;  // actual value stored in the registry

        if (IoLevel != 3)
          UseDefIoLevel = TRUE;

        //
        // set IO level
        //
        RtlInitUnicodeString(&UnicodeString, VERIFIER_IO_LEVEL);
        
        if (UseDefIoLevel) {
          Status = ZwDeleteValueKey(IOMgrKeyHandle, &UnicodeString);
        } else {
          Status = ZwSetValueKey(IOMgrKeyHandle, &UnicodeString, 0, REG_DWORD,
                      &IoLevel, sizeof(DWORD));                
        }

        //
        // set the DRV verification level
        //
        RtlInitUnicodeString(&UnicodeString, VERIFIER_DRV_LEVEL);        

        if (UseDefFlags) {
          Status = ZwDeleteValueKey(MemMgrKeyHandle, &UnicodeString);
        } else {
          Status = ZwSetValueKey(MemMgrKeyHandle, &UnicodeString, 0, REG_DWORD,
                    &Flags, sizeof(DWORD));                
        }

        //
        // set the drivers to be verified
        //
        RtlInitUnicodeString(&UnicodeString, VERIFIER_DRIVERS);

        if (Drivers[0]) {
          Status = ZwSetValueKey(MemMgrKeyHandle, &UnicodeString, 0, REG_SZ,
                    Drivers, (wcslen(Drivers) + 1) * sizeof(WCHAR));                
        } else {
          Status = ZwDeleteValueKey(MemMgrKeyHandle, &UnicodeString);
        }
      }
    }

    if (MemMgrKeyHandle)
      ZwClose(MemMgrKeyHandle);

    if (IOMgrKeyHandle)
      ZwClose(IOMgrKeyHandle);

    if (SysHiveOpened)
        RcCloseHive(SYS_HIVE_KEY);          
  }
  
  return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\bootini.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bootini.c

Abstract:

    Code to lay boot blocks on x86, and to configure for boot loader,
    including munging/creating boot.ini and bootsect.dos.

Author:

    Ted Miller (tedm) 12-November-1992

Revision History:

    Sunil Pai ( sunilp ) 2-November-1993 rewrote for new text setup

--*/


#include "spprecmp.h"
#pragma hdrstop

#include "spboot.h"
#include "bootvar.h"
#include "spfile.h" //NEC98
#include <hdlsblk.h>
#include <hdlsterm.h>

extern PDISK_REGION  TargetRegion_Nec98; //NEC98

SIGNATURED_PARTITIONS SignedBootVars;

BOOLEAN
SpHasMZHeader(
    IN PWSTR   FileName
    );

NTSTATUS
Spx86WriteBootIni(
    IN PWCHAR BootIni,
    IN PWSTR **BootVars,
    IN ULONG Timeout,
    IN PWSTR Default,
    IN ULONG Count
    );

//
// DefSwitches support
//
UCHAR DefSwitches[128];
UCHAR DefSwitchesNoRedirect[128];

//
// Routines
//

BOOLEAN
Spx86InitBootVars(
    OUT PWSTR        **BootVars,
    OUT PWSTR        *Default,
    OUT PULONG       Timeout
    )
{
    WCHAR       BootIni[512];
    HANDLE      FileHandle;
    HANDLE      SectionHandle;
    PVOID       ViewBase;
    NTSTATUS    Status;
    ULONG       FileSize;
    PUCHAR      BootIniBuf;
    PDISK_REGION CColonRegion;
    BOOTVAR     i;
    PUCHAR      p;
    ULONG       index;

    //
    // Initialize the defaults
    //

    for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
        BootVars[i] = (PWSTR *)SpMemAlloc( sizeof ( PWSTR * ) );
        ASSERT( BootVars[i] );
        *BootVars[i] = NULL;
    }
    *Default = NULL;
    *Timeout  = DEFAULT_TIMEOUT;


    //
    // See if there is a valid C: already.  If not, then silently fail.
    //

    if (!IsNEC_98 // NEC98
#if defined(REMOTE_BOOT)
        || RemoteBootSetup
#endif // defined(REMOTE_BOOT)
        ) {

#if defined(REMOTE_BOOT)
        if (RemoteBootSetup && !RemoteInstallSetup) {
            ASSERT(RemoteBootTargetRegion != NULL);
            CColonRegion = RemoteBootTargetRegion;
        } else
#endif // defined(REMOTE_BOOT)
        {
            CColonRegion = SpPtValidSystemPartition();
            if(!CColonRegion) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no C:, no boot.ini!\n"));
                return(TRUE);
            }
        }

        //
        // Form name of file.  Boot.ini better not be on a doublespace drive.
        //

        ASSERT(CColonRegion->Filesystem != FilesystemDoubleSpace);
        SpNtNameFromRegion(CColonRegion,BootIni,sizeof(BootIni),PartitionOrdinalCurrent);
        SpConcatenatePaths(BootIni,WBOOT_INI);

        //
        // Open and map the file.
        //

        FileHandle = 0;
        Status = SpOpenAndMapFile(BootIni,&FileHandle,&SectionHandle,&ViewBase,&FileSize,FALSE);
        if(!NT_SUCCESS(Status)) {
            return TRUE;
        }

        //
        // Allocate a buffer for the file.
        //

        BootIniBuf = SpMemAlloc(FileSize+1);
        ASSERT(BootIniBuf);
        RtlZeroMemory(BootIniBuf, FileSize+1);

        //
        // Transfer boot.ini into the buffer.  We do this because we also
        // want to place a 0 byte at the end of the buffer to terminate
        // the file.
        //
        // Guard the RtlMoveMemory because if we touch the memory backed by boot.ini
        // and get an i/o error, the memory manager will raise an exception.

        try {
            RtlMoveMemory(BootIniBuf,ViewBase,FileSize);
        }
        except( IN_PAGE_ERROR ) {
            //
            // Do nothing, boot ini processing can proceed with whatever has been
            // read
            //
        }

        //
        // Not needed since buffer has already been zeroed, however just do this
        // just the same
        //
        BootIniBuf[FileSize] = 0;

        //
        // Cleanup
        //
        SpUnmapFile(SectionHandle,ViewBase);
        ZwClose(FileHandle);

    } else { //NEC98
        //
        // Serch for all drive which include boot.ini file.
        //
        FileSize = 0;
        BootIniBuf = SpCreateBootiniImage(&FileSize);

        if(BootIniBuf == NULL){
            return(TRUE);
        }

    } //NEC98


    //
    // Do the actual processing of the file.
    //
    SppProcessBootIni(BootIniBuf, BootVars, Default, Timeout);

    //
    // Dump the boot vars
    //
    KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Spx86InitBootVars - Boot.ini entries:\n") );
    for( index = 0; BootVars[OSLOADPARTITION][index] ; index++ ) {
        KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "    BootVar: %d\n    =========\n", index) );
        KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "        OsLoadpartition: %ws\n", BootVars[OSLOADPARTITION][index]) );
        KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "        OsLoadFileName: %ws\n\n", BootVars[OSLOADFILENAME][index]) );
    }


    //
    // Dump the signatures too...
    //
    KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Spx86InitBootVars - Boot.ini signed entries:\n") );
    {
    SIGNATURED_PARTITIONS *my_ptr = &SignedBootVars;
        do{
            if( my_ptr->SignedString ) {
                KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Signature entry:\n================\n") );
                KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "    %ws\n", my_ptr->SignedString) );
                KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "    %ws\n", my_ptr->MultiString) );

            };
            my_ptr = my_ptr->Next;
        } while( my_ptr );
    }


    //
    // Scan the Buffer to see if there is a DefSwitches line,
    // to move into new boot.ini in the  [boot loader] section.
    // If no DefSwitches, just point to a null string to be moved.
    //

    DefSwitches[0] = '\0';
    for(p=BootIniBuf; *p && (p < BootIniBuf+FileSize-(sizeof("DefSwitches")-1)); p++) {
      if(!_strnicmp(p,"DefSwitches",sizeof("DefSwitches")-1)) {
          index = 0;
          while ((*p != '\r') && (*p != '\n') && *p && (index < sizeof(DefSwitches)-4)) {
              DefSwitches[index++] = *p++;
          }
          DefSwitches[index++] = '\r';
          DefSwitches[index++] = '\n';
          DefSwitches[index] = '\0';
          break;
      }
    }

    //
    // get a copy of the defswitches without any redirection switches
    //
    strcpy(DefSwitchesNoRedirect, DefSwitches);

    //
    // Now add any headless parameters to the default switches.
    // Scan the Buffer to see if there's already a headless line.
    // If so, keep it.
    //
    for(p=BootIniBuf; *p && (p < BootIniBuf+FileSize-(sizeof("redirect=")-1)); p++) {


        if(!_strnicmp(p,"[Operat",sizeof("[Operat")-1)) {

            //
            // We're past the [Boot Loader] section.  Stop looking.
            //
            break;
        }


        if(!_strnicmp(p,"redirect=",sizeof("redirect=")-1)) {

            PUCHAR      q = p;
            UCHAR       temp;

            while ((*p != '\r') && (*p != '\n') && *p) {
                p++;
            }
            temp = *p;
            *p = '\0';
            strcat(DefSwitches, q);
            strcat(DefSwitches, "\r\n");
            *p = temp;
        }
    }

    //
    // Now look for a 'redirectbaudrate' line.
    //
    for(p=BootIniBuf; *p && (p < BootIniBuf+FileSize-(sizeof("redirectbaudrate=")-1)); p++) {


        if(!_strnicmp(p,"[Operat",sizeof("[Operat")-1)) {

            //
            // We're past the [Boot Loader] section.  Stop looking.
            //
            break;
        }


        if(!_strnicmp(p,"redirectbaudrate=",sizeof("redirectbaudrate=")-1)) {

            PUCHAR      q = p;
            UCHAR       temp;

            while ((*p != '\r') && (*p != '\n') && *p) {
                p++;
            }
            temp = *p;
            *p = '\0';
            strcat(DefSwitches, q);
            strcat(DefSwitches, "\r\n");
            *p = temp;
        }
    }

    SpMemFree(BootIniBuf);
    return( TRUE );
}


BOOLEAN
Spx86FlushBootVars(
    IN PWSTR **BootVars,
    IN ULONG Timeout,
    IN PWSTR Default
    )
{
    PDISK_REGION CColonRegion;
    WCHAR        *BootIni;
    WCHAR        *BootIniBak;
    BOOLEAN      BootIniBackedUp = FALSE;

    NTSTATUS Status;

    //
    // See if there is a valid C: already.  If not, then fail.
    //
#if defined(REMOTE_BOOT)
    // On a remote boot machine, it's acceptable to have no local disk.
    //
#endif // defined(REMOTE_BOOT)

    if (!IsNEC_98){ //NEC98
        CColonRegion = SpPtValidSystemPartition();
        if(!CColonRegion) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no C:, no boot.ini!\n"));
#if defined(REMOTE_BOOT)
            if (RemoteBootSetup && !RemoteInstallSetup) {
                return(TRUE);
            }
#endif // defined(REMOTE_BOOT)
            return(FALSE);
        }
    } else {
        //
        // CColonRegion equal TargetRegion on NEC98.
        //
        CColonRegion = TargetRegion_Nec98;
    } //NEC98


    //
    // Allocate the buffers to 2K worth of stack space.
    //

    BootIni = SpMemAlloc(512*sizeof(WCHAR));
    if (!BootIni) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: No memory for boot.ini!\n"));
        return FALSE;
    }

    BootIniBak = SpMemAlloc(512*sizeof(WCHAR));
    if (!BootIniBak) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: No memory for boot.ini.bak!\n"));
        SpMemFree(BootIni);
        return FALSE;
    }

    //
    // Form name of file.  Boot.ini better not be on a doublespace drive.
    //

    ASSERT(CColonRegion->Filesystem != FilesystemDoubleSpace);
    SpNtNameFromRegion(CColonRegion,BootIni,512*sizeof(WCHAR),PartitionOrdinalCurrent);
    wcscpy(BootIniBak, BootIni);
    SpConcatenatePaths(BootIni,WBOOT_INI);
    SpConcatenatePaths(BootIniBak,WBOOT_INI_BAK);


    //
    // If Boot.ini already exists, delete any backup bootini
    // rename the existing bootini to the backup bootini, if unable
    // to rename, delete the file
    //

    if( SpFileExists( BootIni, FALSE ) ) {

        if( SpFileExists( BootIniBak, FALSE ) ) {
            SpDeleteFile( BootIniBak, NULL, NULL);
        }

        Status = SpRenameFile( BootIni, BootIniBak, FALSE );
        if (!(BootIniBackedUp = NT_SUCCESS( Status ))) {
            SpDeleteFile( BootIni, NULL, NULL );
        }
    }

    //
    // Write boot.ini.
    //

    Status = Spx86WriteBootIni(
                 BootIni,
                 BootVars,
                 Timeout,
                 Default,
                 0         // write all lines
                 );

    if(!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error writing boot.ini!\n"));
        goto cleanup;
    }

cleanup:

    //
    // If we were unsuccessful in writing out boot ini then try recovering
    // the old boot ini from the backed up file, else delete the backed up
    // file.
    //

    if( !NT_SUCCESS(Status) ) {

        //
        // If the backup copy of boot ini exists then delete incomplete boot
        // ini and rename the backup copy of boot into bootini
        //
        if ( BootIniBackedUp ) {
            SpDeleteFile( BootIni, NULL, NULL );
            SpRenameFile( BootIniBak, BootIni, FALSE );
        }

    }
    else {

        SpDeleteFile( BootIniBak, NULL, NULL );

    }

    SpMemFree(BootIni);
    SpMemFree(BootIniBak);

    return( NT_SUCCESS(Status) );
}


PCHAR
Spx86ConvertToSignatureArcName(
    IN PWSTR ArcPathIn,
    IN ULONG Signature
    )
{
    PWSTR s,p,b;
    PWSTR UseSignatures;
    SIGNATURED_PARTITIONS *SignedEntries = &SignedBootVars;

    KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Spx86ConvertToSignatureArcName - Incoming ArcPath: %ws\n\tIncoming Signature %lx\n", ArcPathIn, Signature ) );

    //
    // First, check for any boot.ini entries that already had a 'signature'
    // string.
    //
    do {
        if( (SignedEntries->MultiString) && (SignedEntries->SignedString) ) {
            if( !_wcsicmp( ArcPathIn, SignedEntries->MultiString ) ) {

                //
                // We hit.  Convert the signatured string
                // to ASCII and return.
                //

                KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Spx86ConvertToSignatureArcName - Matched a multi-signed boot.ini entry:\n") );
                KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "\t%ws\n\t%ws\n", SignedEntries->MultiString, SignedEntries->SignedString) );
                return SpToOem( SignedEntries->SignedString );
            }

        }

        SignedEntries = SignedEntries->Next;
    } while( SignedEntries );

#if 0
    //
    // Don't do this because winnt.exe and CDROM-boot installs won't
    // have this entry set, so we won't use signature entries, which
    // is a mistake.
    //
    UseSignatures = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,L"UseSignatures",0);
    if (UseSignatures == NULL || _wcsicmp(UseSignatures,WINNT_A_YES_W) != 0) {
        //
        // Just return the string we came in with.
        //
        return SpToOem(ArcPathIn);
    }
#endif

    if (_wcsnicmp( ArcPathIn, L"scsi(", 5 ) != 0) {
        //
        // If he's anything but a "scsi(..." entry,
        // just return the string that was sent in.
        //
        return SpToOem(ArcPathIn);
    }
    
    if( Signature ) {
        b = (PWSTR)TemporaryBuffer;
        p = ArcPathIn;
        s = wcschr( p, L')' ) + 1;
        swprintf( b, L"signature(%x)%ws", Signature, s );
        return SpToOem( b );
    } else {
        //
        // Just return the string we came in with.
        //
        return SpToOem(ArcPathIn);
    }
}


NTSTATUS
Spx86WriteBootIni(
    IN PWCHAR BootIni,
    IN PWSTR **BootVars,
    IN ULONG Timeout,
    IN PWSTR Default,
    IN ULONG Count
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING BootIni_U;
    HANDLE fh = NULL;
    PCHAR Default_O, Osloadpartition_O, Osloadfilename_O, Osloadoptions_O, Loadidentifier_O;
    FILE_BASIC_INFORMATION BasicInfo;
    OBJECT_ATTRIBUTES oa;
    ULONG i;
    NTSTATUS Status1;
    NTSTATUS Status;
    PWSTR s;
    PDISK_REGION Region;
    WCHAR   _Default[MAX_PATH] = {0};
    extern ULONG DefaultSignature;

    //
    // Open Bootini file.  Open if write through because we'll be shutting down
    // shortly (this is for safety).
    //

    RtlInitUnicodeString(&BootIni_U,BootIni);
    InitializeObjectAttributes(&oa,&BootIni_U,OBJ_CASE_INSENSITIVE,NULL,NULL);
    Status = ZwCreateFile(
                &fh,
                FILE_GENERIC_WRITE | DELETE,
                &oa,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,                      // no sharing
                FILE_OVERWRITE_IF,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_WRITE_THROUGH,
                NULL,
                0
                );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws for writing!\n", BootIni));
        goto cleanup;
    }

    //
    // make sure there is a Default specified before we use it.
    //
    if (Default != NULL) {
    
        //
        // use the temporary buffer to form the FLEXBOOT section.
        // and then write it out
        //

        s = NULL;
        s = wcschr( Default, L'\\' );
        if( s ) {
            //
            // Save off the Default string, then terminate
            // the Default string where the directory path starts.
            //
            wcscpy( _Default, Default );
            *s = L'\0';
            s = wcschr( _Default, L'\\' );
        }

        if( ForceBIOSBoot ) {
            //
            // If ForceBIOSBoot is TRUE, then we want to
            // force a "multi(..." string.  Don't even bother calling
            // Spx86ConvertToSignatureArcName on the off chance
            // that we may get erroneously converted.
            //

            if (_wcsnicmp( Default, L"scsi(", 5 ) == 0) {
            PWSTR MyStringPointer = NULL;

                //
                // Darn!  We have a string that the old standard
                // thought should be converted into a signature(...
                // string, but we didn't write out a miniport driver.
                // That can happen if someone asked us not to via
                // an unattend switch.
                //
                // We need to change the "scsi(" to "multi("
                //
                // We must preserve Default because we use it later
                // for comparison.
                //
                MyStringPointer = SpScsiArcToMultiArc( Default );

                if( MyStringPointer ) {
                    Default_O = SpToOem( MyStringPointer );
                } else {
                    //
                    // We're in trouble.  Take a shot though.  Just
                    // change the "scsi(" part to "multi(".
                    //
                    wcscpy( TemporaryBuffer, L"multi" );
                    wcscat( TemporaryBuffer, &Default[4] );

                    Default_O = SpToOem( TemporaryBuffer );
                }
            } else {
                //
                // Just convert to ANSI.
                //
                Default_O = SpToOem( Default );

            }
        } else {
            Default_O = Spx86ConvertToSignatureArcName( Default, DefaultSignature );
        }

        if( s ) {
            //
            // We need to append our directory path back on.
            //
            strcpy( (PCHAR)TemporaryBuffer, Default_O );
            SpMemFree( Default_O );
            Default_O = SpToOem( s );
            strcat( (PCHAR)TemporaryBuffer, Default_O );
            SpMemFree( Default_O );
            Default_O = SpDupString( (PCHAR)TemporaryBuffer );
        }


        if (Default_O == NULL) {
            Default_O = SpToOem( Default );
        }
    
    } else {

        //
        // the Default was not set, so make a null Default_O
        //
        Default_O = SpDupString("");

    }
    
    ASSERT( Default_O );

    //
    // See if we should use the loaded redirect switches, 
    // if there were any, or insert user defined swithes
    //
    if(RedirectSwitchesMode != UseDefaultSwitches) {

        //
        // get a copy of the switches up to the [operat region
        //
        strcpy(DefSwitches, DefSwitchesNoRedirect);

        //
        // insert our custom switch(s) if appropriate
        //
        switch(RedirectSwitchesMode){
        case DisableRedirect: {   
        
            //
            // we don't have to do anything here
            //

            break;
        }
        case UseUserDefinedRedirect: {
            
            sprintf((PUCHAR)TemporaryBuffer, 
                    "redirect=%s\r\n",
                    RedirectSwitches.port
                    );

            (void)StringCchCatA(DefSwitches, 
                            sizeof(DefSwitches)/sizeof(DefSwitches[0]),
                            (PUCHAR)TemporaryBuffer);
            
            break;
        }
        case UseUserDefinedRedirectAndBaudRate: {
            
            sprintf((PUCHAR)TemporaryBuffer, 
                    "redirect=%s\r\n",
                    RedirectSwitches.port
                    );

            (void)StringCchCatA(DefSwitches, 
                            sizeof(DefSwitches)/sizeof(DefSwitches[0]),
                            (PUCHAR)TemporaryBuffer);
            
            
            sprintf((PUCHAR)TemporaryBuffer, 
                    "redirectbaudrate=%s\r\n",
                    RedirectSwitches.baudrate
                    );

            (void)StringCchCatA(DefSwitches, 
                            sizeof(DefSwitches)/sizeof(DefSwitches[0]),
                            (PUCHAR)TemporaryBuffer);
            break;
        }
        default:{
            ASSERT(0);
        }
        } 

    } else {
        
        //
        // Make sure the required headless settings are already in the DefSwitches string before
        // we write it out.
        //
        _strlwr( DefSwitches );

        if( !strstr(DefSwitches, "redirect") ) {

            PUCHAR  p;
            HEADLESS_RSP_QUERY_INFO Response;
            SIZE_T      Length;


            //
            // There are no headless settings.  See if we need to add any.
            //
            Length = sizeof(HEADLESS_RSP_QUERY_INFO);
            Status = HeadlessDispatch(HeadlessCmdQueryInformation,
                                      NULL,
                                      0,
                                      &Response,
                                      &Length
                                     );

            p=NULL;

            if (NT_SUCCESS(Status) && 
                (Response.PortType == HeadlessSerialPort) &&
                Response.Serial.TerminalAttached) {

                if (Response.Serial.UsedBiosSettings) {

                    strcat(DefSwitches, "redirect=UseBiosSettings\r\n");

                } else {

                    switch (Response.Serial.TerminalPort) {
                    case ComPort1:
                        p = "redirect=com1\r\n";
                        break;
                    case ComPort2:
                        p = "redirect=com2\r\n";
                        break;
                    case ComPort3:
                        p = "redirect=com3\r\n";
                        break;
                    case ComPort4:
                        p = "redirect=com4\r\n";
                        break;
                    default:
                        ASSERT(0);
                        p = NULL;
                        break;
                    }

                    if (p) {
                        strcat(DefSwitches, p);
                    }                        

                    //
                    // Now take care of the 'redirectbaudrate' entry.
                    //
                    switch (Response.Serial.TerminalBaudRate) {
                    case 115200:
                        p = "redirectbaudrate=115200\r\n";
                        break;
                    case 57600:
                        p = "redirectbaudrate=57600\r\n";
                        break;
                    case 19200:
                        p = "redirectbaudrate=19200\r\n";
                        break;
                    default:
                        p = "redirectbaudrate=9600\r\n";
                        break;
                    }

                    strcat(DefSwitches, p);
                }
            }
        }        
    }

    sprintf(
        (PUCHAR)TemporaryBuffer,
        "%s%s%s%s%s%ld%s%s%s%s%s",
        FLEXBOOT_SECTION2,
        CRLF,
        DefSwitches,
        TIMEOUT,
        EQUALS,
        Timeout,
        CRLF,
        DEFAULT,
        EQUALS,
        Default_O,
        CRLF
        );

    SpMemFree( Default_O );

    Status = ZwWriteFile(
                fh,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                TemporaryBuffer,
                strlen((PUCHAR)TemporaryBuffer) * sizeof(UCHAR),
                NULL,
                NULL
                );

    if(!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error writing %s section to %ws!\n", FLEXBOOT_SECTION2, BootIni));
        goto cleanup;
    }

    //
    // Now write the BOOTINI_OS_SECTION label to boot.ini
    //

    sprintf(
        (PUCHAR)TemporaryBuffer,
        "%s%s",
        BOOTINI_OS_SECTION,
        CRLF
        );

    Status = ZwWriteFile(
                fh,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                TemporaryBuffer,
                strlen((PUCHAR)TemporaryBuffer) * sizeof(UCHAR),
                NULL,
                NULL
                );

    if(!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error writing %s section to %ws!\n", BOOTINI_OS_SECTION, BootIni));
        goto cleanup;
    }

    //
    // run through all the systems that we have and write them out
    //

    for( i = 0; BootVars[OSLOADPARTITION][i] ; i++ ) {

        //
        // If we were told to write a specified number of lines, exit
        // when we have done that.
        //

        if (Count && (i == Count)) {
            Status = STATUS_SUCCESS;
            goto cleanup;
        }

        ASSERT( BootVars[OSLOADFILENAME][i] );
        ASSERT( BootVars[OSLOADOPTIONS][i] );
        ASSERT( BootVars[LOADIDENTIFIER][i] );

        //
        // On some upgrades, if we're upgrading a "signature" entry,
        // then we may not have a DefaultSignature.  I fixed that case over
        // in Spx86ConvertToSignatureArcName.  The other case is where
        // we have a DefaultSignature, but there are also some "scsi(..."
        // entries in the boot.ini that don't pertain to the entry we're
        // upgrading.  For that case, we need to send in a signature
        // of 0 here, which will force Spx86ConvertToSignatureArcName
        // to return us the correct item.
        //

        //
        // You thought the hack above was gross...  This one's even
        // worse.  Problem: we don't think we need a miniport to boot,
        // but there are some other boot.ini entries (that point to our
        // partition) that do.  We always want to leave existing
        // boot.ini entries alone though, so we'll leave those broken.
        //
        // Solution: if the OSLOADPARTITION that we're translating ==
        // Default, && ForceBIOSBoot is TRUE && we're translating
        // the first OSLOADPARTITION (which is the one for our Default),
        // then just don't call Spx86ConvertToSignatureArcName.
        // This is bad because it assumes that our entry is the first,
        // which it is, but it's a shakey assumption.
        //

        if( !_wcsicmp( BootVars[OSLOADPARTITION][i], Default ) ) {
            //
            // This might be our Default entry.  Make sure it
            // really is and if so, process it the same way.
            //
            if( i == 0 ) {
                //
                // It is.
                //
                if( ForceBIOSBoot ) {

                    //
                    // If ForceBIOSBoot is TRUE, then we want to
                    // force a "multi(..." string.  Don't even bother calling
                    // Spx86ConvertToSignatureArcName on the off chance
                    // that we may get erroneously converted.
                    //
                    if (_wcsnicmp( BootVars[OSLOADPARTITION][i], L"scsi(", 5 ) == 0) {
                    PWSTR MyStringPointer = NULL;

                        //
                        // Darn!  We have a string that the old standard
                        // thought should be converted into a signature(...
                        // string, but we didn't write out a miniport driver.
                        // That can happen if someone asked us not to via
                        // an unattend switch.
                        //
                        // We need to change the "scsi(" to "multi("
                        //
                        MyStringPointer = SpScsiArcToMultiArc( BootVars[OSLOADPARTITION][i] );

                        if( MyStringPointer ) {
                            Osloadpartition_O = SpToOem( MyStringPointer );
                        } else {
                            //
                            // We're in trouble.  Take a shot though.  Just
                            // change the "scsi(" part to "multi(".
                            //
                            wcscpy( TemporaryBuffer, L"multi" );
                            wcscat( TemporaryBuffer, &BootVars[OSLOADPARTITION][i][4] );

                            Osloadpartition_O = SpToOem( TemporaryBuffer );
                        }

                    } else {
                        //
                        // Just convert to ANSI.
                        //
                        Osloadpartition_O = SpToOem( BootVars[OSLOADPARTITION][i] );

                    }

                } else {
                    //
                    // We may need to convert this entry.
                    //
                    Osloadpartition_O = Spx86ConvertToSignatureArcName( BootVars[OSLOADPARTITION][i], DefaultSignature );
                }
            } else {
                //
                // This entry looks just like our Default, but it's point
                // to a different installation.  Just call Spx86ConvertToSignatureArcName
                //
                Osloadpartition_O = Spx86ConvertToSignatureArcName( BootVars[OSLOADPARTITION][i], DefaultSignature );
            }
        } else {
            //
            // This entry doesn't even look like our string.  Send in a
            // 0x0 DefaultSignature so that it will only get translated if it
            // matches some entry that we know was signed in the original boot.ini.
            //
            Osloadpartition_O = Spx86ConvertToSignatureArcName( BootVars[OSLOADPARTITION][i], 0 );
        }

        //
        // Insurance...
        //
        if (Osloadpartition_O == NULL) {
            Osloadpartition_O = SpToOem( BootVars[OSLOADPARTITION][i] );
        }


        Osloadfilename_O  = SpToOem( BootVars[OSLOADFILENAME][i]  );
        Osloadoptions_O   = SpToOem( BootVars[OSLOADOPTIONS][i]   );
        Loadidentifier_O  = SpToOem( BootVars[LOADIDENTIFIER][i]  );

        sprintf(
            (PUCHAR)TemporaryBuffer,
            "%s%s%s%s %s%s",
            Osloadpartition_O,
            Osloadfilename_O,
            EQUALS,
            Loadidentifier_O,
            Osloadoptions_O,
            CRLF
            );

        SpMemFree( Osloadpartition_O );
        SpMemFree( Osloadfilename_O  );
        SpMemFree( Osloadoptions_O   );
        SpMemFree( Loadidentifier_O  );

        Status = ZwWriteFile(
                    fh,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    TemporaryBuffer,
                    strlen((PUCHAR)TemporaryBuffer) * sizeof(UCHAR),
                    NULL,
                    NULL
                    );

        if(!NT_SUCCESS( Status )) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error writing %s section entry to %ws!\n", BOOTINI_OS_SECTION, BootIni));
            goto cleanup;
        }
    }


    //
    // Finally write the old operating system line to boot.ini
    // (but only if not installing on top of Win9x) and if it was
    // not specifically disabled
    //
    if (!DiscardOldSystemLine && (WinUpgradeType != UpgradeWin95)) {
        Status = ZwWriteFile(
                    fh,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    OldSystemLine,
                    strlen(OldSystemLine) * sizeof(UCHAR),
                    NULL,
                    NULL
                    );

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                DPFLTR_ERROR_LEVEL, 
                "SETUP: Error writing %s section line to %ws!\n", 
                BOOTINI_OS_SECTION, 
                BootIni));
                
            goto cleanup;
        }
    }

cleanup:

    if( !NT_SUCCESS(Status) ) {

        if( fh ) {
            ZwClose( fh );
        }

    }
    else {

        //
        // Set the hidden, system, readonly attributes on bootini.  ignore
        // error
        //

        RtlZeroMemory( &BasicInfo, sizeof( FILE_BASIC_INFORMATION ) );
        BasicInfo.FileAttributes = FILE_ATTRIBUTE_READONLY |
                                   FILE_ATTRIBUTE_HIDDEN   |
                                   FILE_ATTRIBUTE_SYSTEM   |
                                   FILE_ATTRIBUTE_ARCHIVE
                                   ;

        Status1 = SpSetInformationFile(
                      fh,
                      FileBasicInformation,
                      sizeof(BasicInfo),
                      &BasicInfo
                      );

        if(!NT_SUCCESS(Status1)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to change attribute of %ws. Status = (%lx). Ignoring error.\n",BootIni,Status1));
        }

        ZwClose( fh );

    }

    //
    // If we copied out the Default, then
    // put the original copy of Default back
    //
    if (Default != NULL) {
        wcscpy(Default, _Default);
    }

    return Status;

}

VOID
SppProcessBootIni(
    IN  PCHAR  BootIni,
    OUT PWSTR  **BootVars,
    OUT PWSTR  *Default,
    OUT PULONG Timeout
    )

/*++

Routine Description:

    Look through the [operating systems] section and save all lines
    except the one for "C:\" (previous operating system) and one other
    optionally specified line.

    Filters out the local boot line (C:\$WIN_NT$.~BT) if present.

Arguments:

Return Value:

--*/

{
    PCHAR sect,s,p,n;
    PWSTR tmp;
    CHAR Key[MAX_PATH], Value[MAX_PATH], RestOfLine[MAX_PATH];
    ULONG NumComponents;
    BOOTVAR i;
    ULONG DiskSignature,digval;
    SIGNATURED_PARTITIONS *SignedBootIniVars = &SignedBootVars;;

    //
    // Process the flexboot section, extract timeout and default
    //

    sect = SppFindSectionInBootIni(BootIni, FLEXBOOT_SECTION1);
    if (!sect) {
        sect = SppFindSectionInBootIni(BootIni, FLEXBOOT_SECTION2);
    }
    if (!sect) {
        sect = SppFindSectionInBootIni(BootIni, FLEXBOOT_SECTION3);
    }
    if ( sect ) {
        while (sect = SppNextLineInSection(sect))  {
            if( SppProcessLine( sect, Key, Value, RestOfLine) ) {
                if ( !_stricmp( Key, TIMEOUT ) ) {
                    *Timeout = atol( Value );
                }
                else if( !_stricmp( Key, DEFAULT ) ) {
                    *Default = SpToUnicode( Value );
                }
            }
        }
    }

    //
    // Process the operating systems section
    //

    sect = SppFindSectionInBootIni(BootIni,BOOTINI_OS_SECTION);
    if(!sect) {
        return;
    }

    NumComponents = 0;

    while(sect = SppNextLineInSection(sect)) {
        if( SppProcessLine( sect, Key, Value, RestOfLine)) {
            PCHAR OsLoaddir;

            //
            // Check if the line is the old bootloader line in which case just
            // save it above, else add it to the BootVars structure
            //

            if (!IsNEC_98) { //NEC98
                if( !_stricmp( Key, "C:\\" ) ) {
                    sprintf( OldSystemLine, "%s=%s %s\r\n", Key, Value, RestOfLine );
                } else {

                    //
                    // Ignore if local boot directory.  This automatically
                    // filters out that directory when boot.ini is later flushed.
                    //
                    if(_strnicmp(Key,"C:\\$WIN_NT$.~BT",15) && (OsLoaddir = strchr(Key,'\\'))) {
                        //
                        // Get the ARC name of the x86 system partition region.
                        //
                        PDISK_REGION SystemPartitionRegion;
                        WCHAR SystemPartitionPath[256];

                        NumComponents++;
                        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                            BootVars[i] = SpMemRealloc( BootVars[i],  (NumComponents + 1) * sizeof( PWSTR * ) );
                            ASSERT( BootVars[i] );
                            BootVars[i][NumComponents] = NULL;
                        }

                        SystemPartitionRegion = SpPtValidSystemPartition();
#if defined(REMOTE_BOOT)
                        ASSERT(SystemPartitionRegion ||
                               (RemoteBootSetup && !RemoteInstallSetup));
#else
                        ASSERT(SystemPartitionRegion);
#endif // defined(REMOTE_BOOT)

                        if (SystemPartitionRegion) {
                            SpArcNameFromRegion(
                                SystemPartitionRegion,
                                SystemPartitionPath,
                                sizeof(SystemPartitionPath),
                                PartitionOrdinalOriginal,
                                PrimaryArcPath
                                );

                            BootVars[OSLOADER][NumComponents - 1] = SpMemAlloc((wcslen(SystemPartitionPath)*sizeof(WCHAR))+sizeof(L"ntldr")+sizeof(WCHAR));
                            wcscpy(BootVars[OSLOADER][NumComponents - 1],SystemPartitionPath);
                            SpConcatenatePaths(BootVars[OSLOADER][NumComponents - 1],L"ntldr");

                            BootVars[SYSTEMPARTITION][NumComponents - 1] = SpDupStringW( SystemPartitionPath );
                        }

                        BootVars[LOADIDENTIFIER][NumComponents - 1]  = SpToUnicode( Value );
                        BootVars[OSLOADOPTIONS][NumComponents - 1]   = SpToUnicode( RestOfLine );

                        *OsLoaddir = '\0';

                        //
                        // Now convert the signature entry into a 'multi...' entry.
                        //
                        s = strstr( Key, "signature(" );
                        if (s) {

                            s += 10;
                            p = strchr( s, ')' );
                            if (p) {

                                //
                                // We've got a boot.ini entry with a 'signature' string.
                                // Let's save it off before we convert it into a 'multi'
                                // string so we can convert back easily when we're ready
                                // to write out the boot.ini.
                                //
                                if( SignedBootIniVars->SignedString != NULL ) {
                                    //
                                    // We've used this entry, get another...
                                    //
                                    SignedBootIniVars->Next = SpMemAlloc(sizeof(SIGNATURED_PARTITIONS));
                                    SignedBootIniVars = SignedBootIniVars->Next;

                                    //
                                    // Make sure...
                                    //
                                    SignedBootIniVars->Next = NULL;
                                    SignedBootIniVars->SignedString = NULL;
                                    SignedBootIniVars->MultiString = NULL;
                                }
                                SignedBootIniVars->SignedString = SpToUnicode( Key );


                                *p = 0;
                                DiskSignature = 0;
                                for (n=s; *n; n++) {
                                    if (isdigit((int)(unsigned char)*n)) {
                                        digval = *n - '0';
                                    } else if (isxdigit((int)(unsigned char)*n)) {
                                        digval = toupper(*n) - 'A' + 10;
                                    } else {
                                        digval = 0;
                                    }
                                    DiskSignature = DiskSignature * 16 + digval;
                                }
                                *p = ')';


                                //
                                // !!! ISSUE : 4/27/01 : vijayj !!!
                                //
                                // Sometimes we might map a arcname to wrong region on
                                // disk.
                                //
                                // Although we compute a new multi(0)... style arcname 
                                // from the nt device name, we don't have an entry in 
                                // the map which actually maps the scsi(0)... style 
                                // arcname to nt device name.
                                //
                                // In a multi installation scenario, if the current installation
                                // is on a disk which is not visible by firmware and the
                                // boot.ini has scsi(...) entry for this installation we
                                // would convert it into multi(0)... format which could be
                                // similar to the actual multi(0) disk. If this is the case
                                // and another installation exists on the first disk also
                                // with the same partition number and WINDOWS directory
                                // then we would end up using the first disk region as the
                                // region to upgrade and fail subsequently while trying
                                // to match unique IDs. User will end up with "unable to
                                // locate installation to upgrade message". 
                                // 
                                // Since the probability of all this conditions being replicated
                                // on different machines is very very less, currently
                                // I am not going to fix this.
                                //
                                

                                //
                                // We've isolated the signature.  Now go find a disk
                                // with that signature and get his ARC path.
                                //
                                for(i=0; (ULONG)i<HardDiskCount; i++) {
                                    if (HardDisks[i].Signature == DiskSignature) {
                                        tmp = SpNtToArc( HardDisks[i].DevicePath, PrimaryArcPath );
                                        if( tmp ) {
                                            wcscpy( (PWSTR)TemporaryBuffer, tmp );
                                            SpMemFree(tmp);
                                            p = strstr( Key, "partition(" );
                                            if( p ) {
                                                tmp = SpToUnicode(p);
                                                if( tmp ) {
                                                    wcscat( (PWSTR)TemporaryBuffer, tmp );
                                                    SpMemFree(tmp);
                                                    BootVars[OSLOADPARTITION][NumComponents - 1] = SpDupStringW( (PWSTR)TemporaryBuffer );
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                                if ((ULONG)i == HardDiskCount) {
                                    BootVars[OSLOADPARTITION][NumComponents - 1] = SpToUnicode( Key );
                                }

                                //
                                // Save off the 'multi' entry in our list of signatures.
                                //
                                SignedBootIniVars->MultiString = SpDupStringW( BootVars[OSLOADPARTITION][NumComponents - 1] );
                            }
                        } else {
                            BootVars[OSLOADPARTITION][NumComponents - 1] = SpToUnicode( Key );
                        }

                        *OsLoaddir = '\\';
#if defined(REMOTE_BOOT)
                        if (RemoteBootSetup && !RemoteInstallSetup) {
                            BootVars[OSLOADFILENAME][NumComponents - 1] = SpToUnicode( strrchr(OsLoaddir,'\\') );
                        } else
#endif // defined(REMOTE_BOOT)
                        {
                            BootVars[OSLOADFILENAME][NumComponents - 1] = SpToUnicode( OsLoaddir );
                        }
                    }
                }
            } else { //NEC98
                if (_strnicmp(Key,"C:\\$WIN_NT$.~BT",15) && (OsLoaddir = strchr( Key, '\\' ))) {

                    NumComponents++;
                    for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                        BootVars[i] = SpMemRealloc( BootVars[i],  (NumComponents + 1) * sizeof( PWSTR * ) );
                        ASSERT( BootVars[i] );
                        BootVars[i][NumComponents] = NULL;
                    }

                    BootVars[OSLOADER][NumComponents - 1] = SpMemAlloc(sizeof(L"ntldr")+sizeof(WCHAR));
                    wcscpy(BootVars[OSLOADER][NumComponents - 1],L"\\");
                    SpConcatenatePaths(BootVars[OSLOADER][NumComponents - 1],L"ntldr");

                    BootVars[SYSTEMPARTITION][NumComponents - 1] = SpToUnicode( Key );

                    BootVars[LOADIDENTIFIER][NumComponents - 1]  = SpToUnicode( Value );
                    BootVars[OSLOADOPTIONS][NumComponents - 1]   = SpToUnicode( RestOfLine );
                    *OsLoaddir = '\0';
                    BootVars[OSLOADPARTITION][NumComponents - 1]   = SpToUnicode( Key );
                    *OsLoaddir = '\\';
                    BootVars[OSLOADFILENAME][NumComponents - 1]   = SpToUnicode( OsLoaddir );


                    ASSERT( BootVars[OSLOADER][NumComponents - 1]        );
                    ASSERT( BootVars[SYSTEMPARTITION][NumComponents - 1] );
                    ASSERT( BootVars[LOADIDENTIFIER][NumComponents - 1]  );
                    ASSERT( BootVars[OSLOADOPTIONS][NumComponents - 1]   );
                    ASSERT( BootVars[OSLOADPARTITION][NumComponents - 1] );
                    ASSERT( BootVars[OSLOADPARTITION][NumComponents - 1] );
                }
            } //NEC98
        }
    }
    return;
}


PCHAR
SppNextLineInSection(
    IN PCHAR p
    )
{
    //
    // Find the next \n.
    //
    p = strchr(p,'\n');
    if(!p) {
        return(NULL);
    }

    //
    // skip crs, lfs, spaces, and tabs.
    //

    while(*p && strchr("\r\n \t",*p)) {
        p++;
    }

    // detect if at end of file or section
    if(!(*p) || (*p == '[')) {
        return(NULL);
    }

    return(p);
}


PCHAR
SppFindSectionInBootIni(
    IN PCHAR p,
    IN PCHAR Section
    )
{
    ULONG len = strlen(Section);

    do {

        //
        // Skip space at front of line
        //
        while(*p && ((*p == ' ') || (*p == '\t'))) {
            p++;
        }

        if(*p) {

            //
            // See if this line matches.
            //
            if(!_strnicmp(p,Section,len)) {
                return(p);
            }

            //
            // Advance to the start of the next line.
            //
            while(*p && (*p != '\n')) {
                p++;
            }

            if(*p) {    // skip nl if that terminated the loop.
                p++;
            }
        }
    } while(*p);

    return(NULL);
}


BOOLEAN
SppProcessLine(
    IN PCHAR Line,
    IN OUT PCHAR Key,
    IN OUT PCHAR Value,
    IN OUT PCHAR RestOfLine
    )
{
    PCHAR p = Line, pLine = Line, pToken;
    CHAR  savec;
    BOOLEAN Status = FALSE;

    //
    // Determine end of line
    //

    if(!p) {
        return( Status );
    }

    while( *p && (*p != '\r') && (*p != '\n') ) {
        p++;
    }

    //
    // back up from this position to squeeze out any whitespaces at the
    // end of the line
    //

    while( ((p - 1) >= Line) && strchr(" \t", *(p - 1)) ) {
        p--;
    }

    //
    // terminate the line with null temporarily
    //

    savec = *p;
    *p = '\0';

    //
    // Start at beginning of line and pick out the key
    //

    if ( SppNextToken( pLine, &pToken, &pLine ) ) {
        CHAR savec1 = *pLine;

        *pLine = '\0';
        strcpy( Key, pToken );
        *pLine = savec1;

        //
        // Get next token, it should be a =
        //

        if ( SppNextToken( pLine, &pToken, &pLine ) && *pToken == '=') {

             //
             // Get next token, it will be the value
             //

             if( SppNextToken( pLine, &pToken, &pLine ) ) {
                savec1 = *pLine;
                *pLine = '\0';
                strcpy( Value, pToken );
                *pLine = savec1;

                //
                // if another token exists then take the whole remaining line
                // and make it the RestOfLine token
                //

                if( SppNextToken( pLine, &pToken, &pLine ) ) {
                    strcpy( RestOfLine, pToken );
                }
                else {
                    *RestOfLine = '\0';
                }

                //
                // We have a well formed line
                //

                Status = TRUE;
             }
        }

    }
    *p = savec;
    return( Status );
}


BOOLEAN
SppNextToken(
    PCHAR p,
    PCHAR *pBegin,
    PCHAR *pEnd
    )
{
    BOOLEAN Status = FALSE;

    //
    // Validate pointer
    //

    if( !p ) {
        return( Status );
    }

    //
    // Skip whitespace
    //

    while (*p && strchr( " \t", *p ) ) {
        p++;
    }

    //
    // Valid tokens are "=", space delimited strings, quoted strings
    //

    if (*p) {
        *pBegin = p;
        if ( *p == '=' ) {
            *pEnd = p + 1;
            Status = TRUE;
        }
        else if ( *p == '\"' ) {
            if ( p = strchr( p + 1, '\"' ) ) {
                *pEnd = p + 1;
                Status = TRUE;
            }
        }
        else {
            while (*p && !strchr(" \t\"=", *p) ) {
                p++;
            }
            *pEnd = p;
            Status = TRUE;
        }
    }
    return( Status );
}


//
// Boot code stuff.
//

NTSTATUS
pSpBootCodeIo(
    IN     PWSTR     FilePath,
    IN     PWSTR     AdditionalFilePath, OPTIONAL
    IN     ULONG     BytesToRead,
    IN OUT PUCHAR   *Buffer,
    IN     ULONG     OpenDisposition,
    IN     BOOLEAN   Write,
    IN     ULONGLONG Offset,
    IN     ULONG     BytesPerSector
    )
{
    PWSTR FullPath;
    PUCHAR buffer = NULL;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    LARGE_INTEGER LargeZero;
    PVOID UnalignedMem,AlignedBuffer;

    LargeZero.QuadPart = Offset;

    //
    // Form the name of the file.
    //
    wcscpy((PWSTR)TemporaryBuffer,FilePath);
    if(AdditionalFilePath) {
        SpConcatenatePaths((PWSTR)TemporaryBuffer,AdditionalFilePath);
    }
    FullPath = SpDupStringW((PWSTR)TemporaryBuffer);

    //
    // Open the file.
    //
    INIT_OBJA(&Obja,&UnicodeString,FullPath);
    Status = ZwCreateFile(
                &Handle,
                Write ? FILE_GENERIC_WRITE : FILE_GENERIC_READ,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                OpenDisposition,
                FILE_SYNCHRONOUS_IO_NONALERT | (Write ? FILE_WRITE_THROUGH : 0),
                NULL,
                0
                );

    if(NT_SUCCESS(Status)) {

        //
        // Allocate a buffer if we are reading.
        // Otherwise the caller passed us the buffer.
        //
        buffer = Write ? *Buffer : SpMemAlloc(BytesToRead);

        //
        // Read or write the disk -- properly aligned. Note that we force at least
        // 512-byte alignment, since there's a hard-coded alignment requirement
        // in the FT driver that must be satisfied.
        //
        if(BytesPerSector < 512) {
            BytesPerSector = 512;
        }
        UnalignedMem = SpMemAlloc(BytesToRead + BytesPerSector);
        AlignedBuffer = ALIGN(UnalignedMem,BytesPerSector);

        if(Write) {
            RtlMoveMemory(AlignedBuffer,buffer,BytesToRead);
        }

        Status = Write

               ?
                    ZwWriteFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        AlignedBuffer,
                        BytesToRead,
                        &LargeZero,
                        NULL
                        )
                :

                    ZwReadFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        AlignedBuffer,
                        BytesToRead,
                        &LargeZero,
                        NULL
                        );

        if(NT_SUCCESS(Status)) {
            if(!Write) {
                RtlMoveMemory(buffer,AlignedBuffer,BytesToRead);
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP: Unable to %ws %u bytes from %ws (%lx)\n",
                Write ? L"write" : L"read",
                BytesToRead,
                FullPath,
                Status
                ));
        }

        SpMemFree(UnalignedMem);

        //
        // Close the file.
        //
        ZwClose(Handle);

    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: pSpBootCodeIo: Unable to open %ws (%lx)\n",FullPath,Status));
    }

    SpMemFree(FullPath);

    if(!Write) {
        if(NT_SUCCESS(Status)) {
            *Buffer = buffer;
        } else {
            if(buffer) {
                SpMemFree(buffer);
            }
        }
    }

    return(Status);
}


BOOLEAN
pSpScanBootcode(
    IN PVOID Buffer,
    IN PCHAR String
    )

/*++

Routine Description:

    Look in a boot sector to find an identifying string.  The scan starts
    at offset 128 and continues through byte 509 of the buffer.
    The search is case-sensitive.

    Arguments:

    Buffer - buffer to scan

    String - string to scan for

    Return Value:


--*/

{
    ULONG len = strlen(String);
    ULONG LastFirstByte = 510 - len;
    ULONG i;
    PCHAR p = Buffer;

    //
    // Use the obvious brute force method.
    //
    for(i=128; i<LastFirstByte; i++) {
        if(!strncmp(p+i,String,len)) {
            return(TRUE);
        }
    }

    return(FALSE);
}


VOID
SpDetermineOsTypeFromBootSector(
    IN  PWSTR     CColonPath,
    IN  PUCHAR    BootSector,
    OUT PUCHAR   *OsDescription,
    OUT PBOOLEAN  IsNtBootcode,
    OUT PBOOLEAN  IsOtherOsInstalled,
    IN  WCHAR     DriveLetter
    )
{
    PWSTR   description;
    PWSTR   *FilesToLookFor;
    ULONG   FileCount;
    BOOLEAN PossiblyChicago = FALSE;

    PWSTR MsDosFiles[2] = { L"MSDOS.SYS" , L"IO.SYS"    };

    //
    // Some versions of PC-DOS have ibmio.com, others have ibmbio.com.
    //
  //PWSTR PcDosFiles[2] = { L"IBMDOS.COM", L"IBMIO.COM" };
    PWSTR PcDosFiles[1] = { L"IBMDOS.COM" };

    PWSTR Os2Files[2]   = { L"OS2LDR"    , L"OS2KRNL"   };

    //
    // Check for nt boot code.
    //
    if(pSpScanBootcode(BootSector,"NTLDR")) {

        *IsNtBootcode = TRUE;
        *IsOtherOsInstalled = FALSE;
        description = L"";

    } else {

        //
        // It's not NT bootcode.
        //
        *IsNtBootcode = FALSE;
        *IsOtherOsInstalled = TRUE;

        //
        // Check for MS-DOS.
        //
        if (pSpScanBootcode(BootSector,((!IsNEC_98) ? "MSDOS   SYS" : "IO      SYS"))) { //NEC98

            FilesToLookFor = MsDosFiles;
            FileCount = ELEMENT_COUNT(MsDosFiles);
            description = L"MS-DOS";
            PossiblyChicago = TRUE; // Chicago uses same signature files

        } else {

            //
            // Check for PC-DOS.
            //
            if(pSpScanBootcode(BootSector,"IBMDOS  COM")) {

                FilesToLookFor = PcDosFiles;
                FileCount = ELEMENT_COUNT(PcDosFiles);
                description = L"PC-DOS";

            } else {

                //
                // Check for OS/2.
                //
                if(pSpScanBootcode(BootSector,"OS2")) {

                    FilesToLookFor = Os2Files;
                    FileCount = ELEMENT_COUNT(Os2Files);
                    description = L"OS/2";

                } else {
                    //
                    // Not NT, DOS, or OS/2.
                    // It's just plain old "previous operating system."
                    // Fetch the string from the resources.
                    //
                    WCHAR   DriveLetterString[2];

                    DriveLetterString[0] = DriveLetter;
                    DriveLetterString[1] = L'\0';
                    SpStringToUpper(DriveLetterString);
                    FilesToLookFor = NULL;
                    FileCount = 0;
                    description = (PWSTR)TemporaryBuffer;
                    SpFormatMessage(description,sizeof(TemporaryBuffer),SP_TEXT_PREVIOUS_OS, DriveLetterString);
                }
            }
        }

        //
        // If we think we have found an os, check to see whether
        // its signature files are present.
        // We could have, say, a disk where the user formats is using DOS
        // and then installs NT immediately thereafter.
        //
        if(FilesToLookFor) {

            //
            // Copy CColonPath into a larger buffer, because
            // SpNFilesExist wants to append a backslash onto it.
            //
            wcscpy((PWSTR)TemporaryBuffer,CColonPath);

            if(!SpNFilesExist((PWSTR)TemporaryBuffer,FilesToLookFor,FileCount,FALSE)) {

                //
                // Ths os is not really there.
                //
                *IsOtherOsInstalled = FALSE;
                description = L"";
            } else if(PossiblyChicago) {

                wcscpy((PWSTR)TemporaryBuffer, CColonPath);
                SpConcatenatePaths((PWSTR)TemporaryBuffer, L"IO.SYS");

                if(SpHasMZHeader((PWSTR)TemporaryBuffer)) {
                    description = L"Microsoft Windows";
                }
            }
        }
    }

    //
    // convert the description to oem text.
    //
    *OsDescription = SpToOem(description);
}


VOID
SpLayBootCode(
    IN OUT PDISK_REGION CColonRegion
    )
{
    PUCHAR NewBootCode;
    ULONG BootCodeSize;
    PUCHAR ExistingBootCode;
    NTSTATUS Status;
    PUCHAR ExistingBootCodeOs;
    PWSTR CColonPath;
    HANDLE  PartitionHandle;
    PWSTR BootsectDosName = L"\\bootsect.dos";
    PWSTR OldBootsectDosName = L"\\bootsect.bak";
    PWSTR BootSectDosFullName, OldBootSectDosFullName, p;
    BOOLEAN IsNtBootcode,OtherOsInstalled, FileExist;
    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK   IoStatusBlock;
    BOOLEAN BootSectorCorrupt = FALSE;
    ULONG   MirrorSector;
    ULONG   BytesPerSector;
    ULONGLONG  ActualSectorCount, hidden_sectors, super_area_size;
    UCHAR   SysId;

    ULONGLONG HiddenSectorCount,VolumeSectorCount; //NEC98
    PUCHAR   DiskArraySectorData,TmpBuffer; //NEC98


    ExistingBootCode = NULL;
    BytesPerSector = HardDisks[CColonRegion->DiskNumber].Geometry.BytesPerSector;

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_INITING_FLEXBOOT,DEFAULT_STATUS_ATTRIBUTE);

    switch(CColonRegion->Filesystem) {

    case FilesystemNewlyCreated:

        //
        // If the filesystem is newly-created, then there is
        // nothing to do, because there can be no previous
        // operating system.
        //
        return;

    case FilesystemNtfs:

        NewBootCode = (!IsNEC_98) ? NtfsBootCode : PC98NtfsBootCode; //NEC98
        BootCodeSize = (!IsNEC_98) ? sizeof(NtfsBootCode) : sizeof(PC98NtfsBootCode); //NEC98
        ASSERT(BootCodeSize == 8192);
        break;

    case FilesystemFat:

        NewBootCode = (!IsNEC_98) ? FatBootCode : PC98FatBootCode; //NEC98
        BootCodeSize = (!IsNEC_98) ? sizeof(FatBootCode) : sizeof(PC98FatBootCode); //NEC98
        ASSERT(BootCodeSize == 512);
        break;

    case FilesystemFat32:
        //
        // Special hackage required for Fat32 because its NT boot code
        // is discontiguous.
        //
        ASSERT(sizeof(Fat32BootCode) == 1536);
        NewBootCode = (!IsNEC_98) ? Fat32BootCode : PC98Fat32BootCode; //NEC98
        BootCodeSize = 512;
        break;

    default:

        if (RepairItems[RepairBootSect]) {
            BootSectorCorrupt = TRUE;
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: bogus filesystem %u for C:!\n",CColonRegion->Filesystem));
            ASSERT(0);
            return;
        }
    }

    //
    // Form the device path to C: and open the partition.
    //

    SpNtNameFromRegion(CColonRegion,(PWSTR)TemporaryBuffer,sizeof(TemporaryBuffer),PartitionOrdinalCurrent);
    CColonPath = SpDupStringW((PWSTR)TemporaryBuffer);
    INIT_OBJA(&Obja,&UnicodeString,CColonPath);

    Status = ZwCreateFile(
        &PartitionHandle,
        FILE_GENERIC_READ | FILE_GENERIC_WRITE,
        &Obja,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
        );

    if (!NT_SUCCESS(Status)) {
        KdPrintEx ((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open the partition for C:!\n"));
        ASSERT(0);
        return;
    }

    //
    // Allocate a buffer and read in the boot sector(s) currently on the disk.
    //

    if (BootSectorCorrupt) {

        //
        // We can't determine the file system type from the boot sector, so
        // we assume it's NTFS if we find a mirror sector, and FAT otherwise.
        //

        if (MirrorSector = NtfsMirrorBootSector (PartitionHandle,
            BytesPerSector, &ExistingBootCode)) {

            //
            // It's NTFS - use the mirror boot sector
            //

            NewBootCode = (!IsNEC_98) ? NtfsBootCode : PC98NtfsBootCode; //NEC98
            BootCodeSize = (!IsNEC_98) ? sizeof(NtfsBootCode) : sizeof(PC98NtfsBootCode); //NEC98
            ASSERT(BootCodeSize == 8192);

            CColonRegion->Filesystem = FilesystemNtfs;
            IsNtBootcode = TRUE;

        } else {

            //
            // It's FAT - create a new boot sector
            //

            NewBootCode = (!IsNEC_98) ? FatBootCode : PC98FatBootCode; //NEC98
            BootCodeSize = (!IsNEC_98) ? sizeof(FatBootCode) : sizeof(PC98FatBootCode); //NEC98
            ASSERT(BootCodeSize == 512);

            CColonRegion->Filesystem = FilesystemFat;
            IsNtBootcode = FALSE;

            SpPtGetSectorLayoutInformation (CColonRegion, &hidden_sectors,
                &ActualSectorCount);

            //
            // No alignment requirement here
            //
            ExistingBootCode = SpMemAlloc(BytesPerSector);

            //
            // This will actually fail with STATUS_BUFFER_TOO_SMALL but it will fill in
            // the bpb, which is what we want
            //
            FmtFillFormatBuffer (
               ActualSectorCount,
               BytesPerSector,
               HardDisks[CColonRegion->DiskNumber].Geometry.SectorsPerTrack,
               HardDisks[CColonRegion->DiskNumber].Geometry.TracksPerCylinder,
               hidden_sectors,
               ExistingBootCode,
               BytesPerSector,
               &super_area_size,
               NULL,
               0,
               &SysId
               );
        }

        Status = STATUS_SUCCESS;

    } else if (
        RepairItems[RepairBootSect] &&
        CColonRegion->Filesystem == FilesystemNtfs &&
        (MirrorSector = NtfsMirrorBootSector (PartitionHandle, BytesPerSector,
            &ExistingBootCode))
        ) {

        //
        // We use the mirror sector to repair a NTFS file system
        //

    } else {

        //
        // Just use the existing boot code.
        //

        Status = pSpBootCodeIo(
                        CColonPath,
                        NULL,
                        BootCodeSize,
                        &ExistingBootCode,
                        FILE_OPEN,
                        FALSE,
                        0,
                        BytesPerSector
                        );

        if(CColonRegion->Filesystem == FilesystemNtfs) {
            MirrorSector = NtfsMirrorBootSector(PartitionHandle,BytesPerSector,NULL);
        }
    }

    if(NT_SUCCESS(Status)) {

        //
        // Determine the type of operating system the existing boot sector(s) are for
        // and whether that os is actually installed. Note that we don't need to call
        // this for NTFS.
        //
        if (BootSectorCorrupt) {

            OtherOsInstalled = FALSE;
            ExistingBootCodeOs = NULL;

        } else if(CColonRegion->Filesystem != FilesystemNtfs) {

            SpDetermineOsTypeFromBootSector(
                CColonPath,
                ExistingBootCode,
                &ExistingBootCodeOs,
                &IsNtBootcode,
                &OtherOsInstalled,
                CColonRegion->DriveLetter
                );

        } else {

            IsNtBootcode = TRUE;
            OtherOsInstalled = FALSE;
            ExistingBootCodeOs = NULL;
        }

        //
        //  lay down the new boot code
        //
        if(OtherOsInstalled) {

            if(RepairItems[RepairBootSect]) {

                p = (PWSTR)TemporaryBuffer;
                wcscpy(p,CColonPath);
                SpConcatenatePaths(p,OldBootsectDosName);
                OldBootSectDosFullName = SpDupStringW(p);
                p = (PWSTR)TemporaryBuffer;
                wcscpy(p,CColonPath);
                SpConcatenatePaths(p,BootsectDosName);
                BootSectDosFullName = SpDupStringW(p);

                //
                // If bootsect.dos already exists, we need to delete
                // bootsect.pre, which may or may not exist and
                // rename the bootsect.dos to bootsect.pre.
                //

                FileExist = SpFileExists(BootSectDosFullName, FALSE);
                if (SpFileExists(OldBootSectDosFullName, FALSE) && FileExist) {

                    SpDeleteFile(CColonPath,OldBootsectDosName,NULL);
                }
                if (FileExist) {
                    SpRenameFile(BootSectDosFullName, OldBootSectDosFullName, FALSE);
                }
                SpMemFree(BootSectDosFullName);
                SpMemFree(OldBootSectDosFullName);
            } else {

                //
                // Delete bootsect.dos in preparation for rewriting it below.
                // Doing this leverages code to set its attributes in SpDeleteFile.
                // (We need to remove read-only attribute before overwriting).
                //
                SpDeleteFile(CColonPath,BootsectDosName,NULL);
            }

            //
            // Write out the existing (old) boot sector into c:\bootsect.dos.
            //
            Status = pSpBootCodeIo(
                            CColonPath,
                            BootsectDosName,
                            BootCodeSize,
                            &ExistingBootCode,
                            FILE_OVERWRITE_IF,
                            TRUE,
                            0,
                            BytesPerSector
                            );

            //
            // Set the description text to the description calculated
            // by SpDetermineOsTypeFromBootSector().
            //
            _snprintf(
                OldSystemLine,
                sizeof(OldSystemLine),
                "C:\\ = \"%s\"\r\n",
                ExistingBootCodeOs
                );

        } // end if(OtherOsInstalled)


        if(NT_SUCCESS(Status)) {

            //
            // Transfer the bpb from the existing boot sector into the boot code buffer
            // and make sure the physical drive field is set to hard disk (0x80).
            //
            // The first three bytes of the NT boot code are going to be something like
            // EB 3C 90, which is intel jump instruction to an offset in the boot sector,
            // past the BPB, to continue execution.  We want to preserve everything in the
            // current boot sector up to the start of that code.  Instead of harcoding
            // a value, we'll use the offset of the jump instruction to determine how many
            // bytes must be preserved.
            //
            RtlMoveMemory(NewBootCode+3,ExistingBootCode+3,NewBootCode[1]-1);
            if(CColonRegion->Filesystem != FilesystemFat32) {
                //
                // On fat32 this overwrites the BigNumFatSecs field,
                // a very bad thing to do indeed!
                //
                NewBootCode[36] = 0x80;
            }

            //
            // get Hidden sector informatin.
            //
            if (IsNEC_98) { //NEC98
                SpPtGetSectorLayoutInformation(
                    CColonRegion,
                    &HiddenSectorCount,
                    &VolumeSectorCount    // not used
                    );
                //
                // write Hidden sector informatin.
                //
                if (!RepairWinnt) {  // for install a partition where before DOS 3.x
                    *((ULONG *)&(NewBootCode[0x1c])) = (ULONG)HiddenSectorCount;
                    if(*((USHORT *)&(NewBootCode[0x13])) != 0) {
                        *((ULONG *)&(NewBootCode[0x20])) = 0L;
                    }
                }
            } //NEC98

            //
            // Write out boot code buffer, which now contains the valid bpb,
            // to the boot sector(s).
            //
            Status = pSpBootCodeIo(
                            CColonPath,
                            NULL,
                            BootCodeSize,
                            &NewBootCode,
                            FILE_OPEN,
                            TRUE,
                            0,
                            BytesPerSector
                            );

            //
            // Special case for Fat32, which has a second sector of boot code
            // at sector 12, discontiguous from the code on sector 0.
            //
            if(NT_SUCCESS(Status) && (CColonRegion->Filesystem == FilesystemFat32)) {

                NewBootCode = (!IsNEC_98) ? Fat32BootCode + 1024
                                          : PC98Fat32BootCode + 1024; //NEC98

                Status = pSpBootCodeIo(
                                CColonPath,
                                NULL,
                                BootCodeSize,
                                &NewBootCode,
                                FILE_OPEN,
                                TRUE,
                                12*512,
                                BytesPerSector
                                );
            }

            //
            // Update the mirror boot sector.
            //
            if((CColonRegion->Filesystem == FilesystemNtfs) && MirrorSector) {
                WriteNtfsBootSector(PartitionHandle,BytesPerSector,NewBootCode,MirrorSector);
            }
        }

        if(ExistingBootCodeOs) {
            SpMemFree(ExistingBootCodeOs);
        }
    }

    if(ExistingBootCode) {
        SpMemFree(ExistingBootCode);
    }

    SpMemFree(CColonPath);
    ZwClose (PartitionHandle);

    //
    // Handle the error case.
    //
    if(!NT_SUCCESS(Status)) {

        WCHAR   DriveLetterString[2];

        DriveLetterString[0] = CColonRegion->DriveLetter;
        DriveLetterString[1] = L'\0';
        SpStringToUpper(DriveLetterString);
        SpStartScreen(SP_SCRN_CANT_INIT_FLEXBOOT,
                      3,
                      HEADER_HEIGHT+1,
                      FALSE,
                      FALSE,
                      DEFAULT_ATTRIBUTE,
                      DriveLetterString,
                      DriveLetterString
                      );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

        SpInputDrain();
        while(SpInputGetKeypress() != KEY_F3) ;

        SpDone(0,FALSE,TRUE);
    }
}


#if defined(REMOTE_BOOT)
BOOLEAN
Spx86FlushRemoteBootVars(
    IN PDISK_REGION TargetRegion,
    IN PWSTR **BootVars,
    IN PWSTR Default
    )
{
    WCHAR BootIni[512];
    NTSTATUS Status;


    //
    // Form the path to boot.ini.
    //

    SpNtNameFromRegion(TargetRegion,BootIni,sizeof(BootIni),PartitionOrdinalCurrent);
    SpConcatenatePaths(BootIni,WBOOT_INI);

    //
    // If Boot.ini already exists, delete it.
    //

    if( SpFileExists( BootIni, FALSE ) ) {
        SpDeleteFile( BootIni, NULL, NULL );
    }

    Status = Spx86WriteBootIni(
                 BootIni,
                 BootVars,
                 1,        // timeout
                 Default,
                 1         // only write one line
                 );

    if(!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error writing boot.ini!\n"));
        goto cleanup;
    }

cleanup:

    return( NT_SUCCESS(Status) );

}
#endif // defined(REMOTE_BOOT)


BOOLEAN
SpHasMZHeader(
    IN PWSTR   FileName
    )
{
    HANDLE   FileHandle;
    HANDLE   SectionHandle;
    PVOID    ViewBase;
    ULONG    FileSize;
    NTSTATUS Status;
    PUCHAR   Header;
    BOOLEAN  Ret = FALSE;

    //
    // Open and map the file.
    //
    FileHandle = 0;
    Status = SpOpenAndMapFile(FileName,
                              &FileHandle,
                              &SectionHandle,
                              &ViewBase,
                              &FileSize,
                              FALSE
                              );
    if(!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Header = (PUCHAR)ViewBase;

    //
    // Guard with try/except in case we get an inpage error
    //
    try {
        if((FileSize >= 2) && (Header[0] == 'M') && (Header[1] == 'Z')) {
            Ret = TRUE;
        }
    } except(IN_PAGE_ERROR) {
        //
        // Do nothing, we simply want to return FALSE.
        //
    }

    SpUnmapFile(SectionHandle, ViewBase);
    ZwClose(FileHandle);

    return Ret;
}

//
// NEC98
//
PUCHAR
SpCreateBootiniImage(
    OUT PULONG   FileSize
)

{

    PUCHAR BootIniBuf,IniImageBuf,IniImageBufSave,IniCreateBuf,IniCreateBufSave;
    PUCHAR FindSectPtr;
    PUCHAR sect; // point to target section. if it is NULL,not existing target section.
    PUCHAR pArcNameA;
    WCHAR  TempBuffer[256];
    WCHAR  TempArcPath[256];
    ULONG  NtDirLen,TotalNtDirlen,CreateBufCnt;
    ULONG  Timeout;
    ULONG  Disk;
    ULONG  BootiniSize;
    ULONG  ArcNameLen;
    PDISK_REGION pRegion;
    HANDLE fh;
    HANDLE SectionHandle;
    PVOID  ViewBase;

#define   Default_Dir "\\MOCHI"

    if(!HardDiskCount){
         return(NULL);
    }
    //
    // Create basic style of boot.ini image and progress pointer end of line.
    //

    NtDirLen = TotalNtDirlen = CreateBufCnt = 0;
    IniCreateBufSave = IniCreateBuf = SpMemAlloc(1024);
    RtlZeroMemory(IniCreateBuf,1024);
    Timeout = DEFAULT_TIMEOUT;
    sprintf(
        IniCreateBuf,
        "%s%s%s%s%ld%s%s%s%s%s%s%s%s",
        FLEXBOOT_SECTION2, // [boot loader]
        CRLF,
        TIMEOUT,
        EQUALS,
        Timeout,
        CRLF,
        DEFAULT,
        EQUALS,
        "c:",
        Default_Dir,
        CRLF,
        BOOTINI_OS_SECTION, // [operating systems]
        CRLF
        );

    sect = SppFindSectionInBootIni(IniCreateBuf,FLEXBOOT_SECTION2);
    if(sect == NULL){
        return(NULL);
    }
    for( IniCreateBuf = sect; *IniCreateBuf && (*IniCreateBuf != '\n'); IniCreateBuf++,CreateBufCnt++);
    CreateBufCnt++;

    sect = SppFindSectionInBootIni(IniCreateBuf,TIMEOUT);
    if(sect == NULL){
        return(NULL);
    }
    for( IniCreateBuf = sect; *IniCreateBuf && (*IniCreateBuf != '\n'); IniCreateBuf++,CreateBufCnt++);
    CreateBufCnt++;

    sect = SppFindSectionInBootIni(IniCreateBuf,DEFAULT);
    if(sect == NULL){
        return(NULL);
    }
    for( IniCreateBuf = sect; *IniCreateBuf && (*IniCreateBuf != '\n'); IniCreateBuf++,CreateBufCnt++);
    CreateBufCnt++;

    sect = SppFindSectionInBootIni(IniCreateBuf,BOOTINI_OS_SECTION);
    if(sect == NULL){
        return(NULL);
    }
    for( IniCreateBuf = sect; *IniCreateBuf && (*IniCreateBuf != '\n'); IniCreateBuf++,CreateBufCnt++);
    IniCreateBuf++;
    CreateBufCnt++;


    //
    // Read boot.ini files from all drives.(except sleep and non bootable drives.)
    //

    for(Disk=0; Disk < HardDiskCount; Disk++){

        for(pRegion=PartitionedDisks[Disk].PrimaryDiskRegions; pRegion;pRegion=pRegion->Next){

            if(!pRegion->PartitionedSpace) {
                continue;
            }

            SpNtNameFromRegion(
                            pRegion,
                            TempBuffer,
                            sizeof(TempBuffer),
                            PartitionOrdinalCurrent
                            );


            SpConcatenatePaths(TempBuffer,WBOOT_INI);

            //
            // Open and map the boot.ini file.
            //
            fh = 0;
            if(!NT_SUCCESS(SpOpenAndMapFile(TempBuffer,&fh,&SectionHandle,&ViewBase,&BootiniSize,FALSE))) {
                 continue;
            }

            //
            // Allocate a buffer for the file.
            //

            IniImageBuf = SpMemAlloc(BootiniSize+1);
            IniImageBufSave = IniImageBuf;
            ASSERT(IniImageBuf);
            RtlZeroMemory(IniImageBuf, BootiniSize+1);

            //
            // Transfer boot.ini into the buffer.  We do this because we also
            // want to place a 0 byte at the end of the buffer to terminate
            // the file.
            //
            // Guard the RtlMoveMemory because if we touch the memory backed by boot.ini
            // and get an i/o error, the memory manager will raise an exception.

            try {
                RtlMoveMemory(IniImageBuf,ViewBase,BootiniSize);
            }
            except( IN_PAGE_ERROR ) {
            //
            // Do nothing, boot ini processing can proceed with whatever has been
            // read
            //
            }

            //
            // check out existing target section in boot.ini
            //

            sect = SppFindSectionInBootIni(IniImageBuf,FLEXBOOT_SECTION2);
            if(sect==NULL){
                            SpMemFree(IniImageBufSave);
                            SpUnmapFile(SectionHandle,ViewBase);
                            ZwClose(fh);
                            continue;
            }

            sect = SppFindSectionInBootIni(IniImageBuf,DEFAULT);
            if(sect==NULL){
                            SpMemFree(IniImageBufSave);
                            SpUnmapFile(SectionHandle,ViewBase);
                            ZwClose(fh);
                            continue;
            }


            sect = SppFindSectionInBootIni(IniImageBuf,BOOTINI_OS_SECTION);
            if(sect == NULL){
                SpUnmapFile(SectionHandle,ViewBase);
                ZwClose(fh);
                continue;
            }

            //
            // move pointer to end of line and skip the space.
            //

            for( IniImageBuf = sect; *IniImageBuf && (*IniImageBuf != '\n'); IniImageBuf++ );
            for( ; *IniImageBuf && (( *IniImageBuf == ' ' ) || (*IniImageBuf == '\t')) ; IniImageBuf++ );

            IniImageBuf++;
            FindSectPtr = IniImageBuf;

            //
            //  NOTE:
            //  override arc name when boot path written as "C:", not as arc name.
            //
            ArcNameLen = 0;
            pArcNameA = (PUCHAR)NULL;

            if( ( *(IniImageBuf+1) == L':' )&&( *(IniImageBuf+2) == L'\\' ) ) {

                //
                // This is NEC98 legacy style format, like "C:\WINNT=...",
                // So translate to arc name for boot.ini in NT 5.0
                //
                SpArcNameFromRegion(pRegion,
                                    TempArcPath,
                                    sizeof(TempArcPath),
                                    PartitionOrdinalOriginal,
                                    PrimaryArcPath
                    );

                pArcNameA = SpToOem(TempArcPath);

                if( pArcNameA ) {
                    ArcNameLen = strlen(pArcNameA);
                    IniImageBuf += 2;
                    FindSectPtr = IniImageBuf;
                }
            }

            for( NtDirLen = 0 ; *IniImageBuf && (*IniImageBuf != '\n');NtDirLen++,IniImageBuf++);
            NtDirLen++;

            if( ArcNameLen && pArcNameA ) { // Only case of override arc path.
                RtlMoveMemory( IniCreateBuf+TotalNtDirlen, pArcNameA, ArcNameLen );
                TotalNtDirlen += ArcNameLen;
                SpMemFree(pArcNameA);
            }

            RtlMoveMemory(IniCreateBuf+TotalNtDirlen,FindSectPtr,NtDirLen);
            TotalNtDirlen += NtDirLen;
            SpMemFree(IniImageBufSave);
            SpUnmapFile(SectionHandle,ViewBase);
            ZwClose(fh);

        }
    }

    if(TotalNtDirlen == 0){
        SpMemFree(IniCreateBufSave);
        return(NULL);
    }

    BootIniBuf = SpMemAlloc(CreateBufCnt + TotalNtDirlen + 1);

    if(!(BootIniBuf)){
        SpMemFree(IniCreateBufSave);
        return(NULL);
    }

    if(FileSize) {
        *FileSize = CreateBufCnt + TotalNtDirlen;
    }

    RtlZeroMemory(BootIniBuf,CreateBufCnt + TotalNtDirlen + 1);
    RtlMoveMemory(BootIniBuf,IniCreateBufSave,CreateBufCnt + TotalNtDirlen);
    BootIniBuf[CreateBufCnt + TotalNtDirlen] = 0;
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Create NT List\n%s\n",BootIniBuf));
    SpMemFree(IniCreateBufSave);
    return(BootIniBuf);
}

//
// NEC98
//
BOOLEAN
SppReInitializeBootVars_Nec98(
    OUT PWSTR        **BootVars,
    OUT PWSTR        *Default,
    OUT PULONG       Timeout
    )
{
    WCHAR  BootIni[512];
    HANDLE FileHandle;
    HANDLE SectionHandle;
    PVOID ViewBase;
    NTSTATUS Status;
    ULONG FileSize;
    PUCHAR BootIniBuf;
    PDISK_REGION CColonRegion;
    BOOTVAR i;
    PUCHAR  p;
    ULONG   index;

    PUCHAR TmpBootIniBuf;
    PUCHAR pBuf;
    PUCHAR pTmpBuf;
    PUCHAR pArcNameA;
    PUCHAR NtDir;
    ULONG ArcNameLen;
    ULONG NtDirLen;
    WCHAR TempArcPath[256];
    BOOLEAN IsChanged = FALSE;
    SIZE_T Length;
    HEADLESS_RSP_QUERY_INFO Response;

    //
    // Initialize the defaults
    //

    for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
        if(BootVars[i]){
            SpMemFree(BootVars[i]);
        }
    }

    for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
        BootVars[i] = (PWSTR *)SpMemAlloc( sizeof ( PWSTR * ) );
        ASSERT( BootVars[i] );
        *BootVars[i] = NULL;
    }

    *Default = NULL;
    *Timeout = DEFAULT_TIMEOUT;

    //
    // Just clear BOOTVARS[] when fresh setup.
    //

    if(NTUpgrade != UpgradeFull)
        return TRUE;


    //
    // See if there is a valid C: already.  If not, then silently fail.
    //

#if defined(REMOTE_BOOT)
    if (RemoteBootSetup && !RemoteInstallSetup) {
        ASSERT(RemoteBootTargetRegion != NULL);
        CColonRegion = RemoteBootTargetRegion;
    } else
#endif // defined(REMOTE_BOOT)
    {
        CColonRegion = TargetRegion_Nec98;
    }

    //
    // Form name of file.  Boot.ini better not be on a doublespace drive.
    //

    ASSERT(CColonRegion->Filesystem != FilesystemDoubleSpace);
    SpNtNameFromRegion(CColonRegion,BootIni,sizeof(BootIni),PartitionOrdinalCurrent);
    SpConcatenatePaths(BootIni,WBOOT_INI);

    //
    // Open and map the file.
    //

    FileHandle = 0;
    Status = SpOpenAndMapFile(BootIni,&FileHandle,&SectionHandle,&ViewBase,&FileSize,FALSE);
    if(!NT_SUCCESS(Status)) {
        return TRUE;
    }

    //
    // Allocate a buffer for the file.
    //

    BootIniBuf = SpMemAlloc(FileSize+1);
    ASSERT(BootIniBuf);
    RtlZeroMemory(BootIniBuf, FileSize+1);

    //
    // Transfer boot.ini into the buffer.  We do this because we also
    // want to place a 0 byte at the end of the buffer to terminate
    // the file.
    //
    // Guard the RtlMoveMemory because if we touch the memory backed by boot.ini
    // and get an i/o error, the memory manager will raise an exception.

    try {
        RtlMoveMemory(BootIniBuf,ViewBase,FileSize);
    }
    except( IN_PAGE_ERROR ) {
        //
        // Do nothing, boot ini processing can proceed with whatever has been
        // read
        //
    }

    //
    // Not needed since buffer has already been zeroed, however just do this
    // just the same
    //
    BootIniBuf[FileSize] = 0;
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Create NT List\n%s\n",BootIniBuf));

//***
    TmpBootIniBuf = SpMemAlloc(FileSize+256);
    RtlZeroMemory(TmpBootIniBuf,FileSize+256);
    RtlMoveMemory(TmpBootIniBuf,BootIniBuf,FileSize);

    pBuf = SppFindSectionInBootIni(BootIniBuf,BOOTINI_OS_SECTION);
    pTmpBuf = SppFindSectionInBootIni(TmpBootIniBuf,BOOTINI_OS_SECTION);

    if (pBuf && pTmpBuf) {
        while( *pBuf && (pBuf < BootIniBuf+FileSize-(sizeof("C:\\")-1)) ) {

            if((!_strnicmp(pBuf,"C:\\",sizeof("C:\\")-1))||
               (!_strnicmp(pBuf,"c:\\",sizeof("c:\\")-1))) {

                ArcNameLen = 0;
                pArcNameA = NULL;

                p = strchr(pBuf+3,'='); // *(pBuf+3) == '\\'

                if((p != pBuf+3) && (*p == '=')) {

                    NtDirLen = (ULONG)(p - (pBuf+3));
                    NtDir = SpMemAlloc(NtDirLen+1);
                    RtlZeroMemory(NtDir,NtDirLen+1);
                    RtlMoveMemory(NtDir,pBuf+3,NtDirLen);

                    if(SpIsNtInDirectory(TargetRegion_Nec98,SpToUnicode(NtDir))){

                        SpArcNameFromRegion(TargetRegion_Nec98,
                                            TempArcPath,
                                            sizeof(TempArcPath),
                                            PartitionOrdinalOriginal,
                                            PrimaryArcPath
                            );

                        if(pArcNameA=SpToOem(TempArcPath)) {

                            ArcNameLen = strlen(pArcNameA);
                            RtlMoveMemory(pTmpBuf,pArcNameA,ArcNameLen);
                            pBuf += 2;
                            pTmpBuf += ArcNameLen;

                            if( !IsChanged)
                                IsChanged = TRUE;

                            SpMemFree(NtDir);
                            continue;
                        }
                    }
                    SpMemFree(NtDir);
                }
            }
            *pTmpBuf = *pBuf;
            pBuf++;
            pTmpBuf++;
        }
    }        

    if (IsChanged) {
        if (pTmpBuf) {
            *pTmpBuf = 0;
        }            

        SpMemFree(BootIniBuf);
        BootIniBuf = TmpBootIniBuf;
        TmpBootIniBuf = (PUCHAR)NULL;

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
            "SETUP: Create New NT List\n%s\n",BootIniBuf));
    } else {
        SpMemFree(TmpBootIniBuf);
        TmpBootIniBuf = (PUCHAR)NULL;
    }

    //
    // Cleanup
    //
    SpUnmapFile(SectionHandle,ViewBase);
    ZwClose(FileHandle);


    //
    // Do the actual processing of the file.
    //
    SppProcessBootIni(BootIniBuf, BootVars, Default, Timeout);

    //
    // Scan the Buffer to see if there is a DefSwitches line,
    // to move into new boot.ini in the  [boot loader] section.
    // If no DefSwitches, just point to a null string to be moved.
    //

    DefSwitches[0] = '\0';
    for(p=BootIniBuf; *p && (p < BootIniBuf+FileSize-(sizeof("DefSwitches")-1)); p++) {
      if(!_strnicmp(p,"DefSwitches",sizeof("DefSwitches")-1)) {
          index = 0;
          while ((*p != '\r') && (*p != '\n') && *p && (index < sizeof(DefSwitches)-4)) {
              DefSwitches[index++] = *p++;
          }
          DefSwitches[index++] = '\r';
          DefSwitches[index++] = '\n';
          DefSwitches[index] = '\0';
          break;
      }
    }


    //
    // Now add any headless parameters to the default switches.
    //
    Length = sizeof(HEADLESS_RSP_QUERY_INFO);
    Status = HeadlessDispatch(HeadlessCmdQueryInformation,
                              NULL,
                              0,
                              &Response,
                              &Length
                             );

    if (NT_SUCCESS(Status) && 
        (Response.PortType == HeadlessSerialPort) &&
        Response.Serial.TerminalAttached) {
        
        if (Response.Serial.UsedBiosSettings) {

            p = "redirect=UseBiosSettings\r\n";

        } else {

            switch (Response.Serial.TerminalPort) {
            case ComPort1:
                p = "redirect=com1\r\n";
                break;
            case ComPort2:
                p = "redirect=com2\r\n";
                break;
            case ComPort3:
                p = "redirect=com3\r\n";
                break;
            case ComPort4:
                p = "redirect=com4\r\n";
                break;
            default:
                ASSERT(0);
                p = NULL;
                break;
            }

        }

        if (p != NULL) {
            strcat(DefSwitches, p);
        }

    }

    SpMemFree(BootIniBuf);
    return( TRUE );
}

//
// NEC98
//
NTSTATUS
SppRestoreBootCode(
    VOID
    )
{

//
// Restore previous OS boot code to boot sector from bootsect.dos.
//

    WCHAR p1[256] = {0};
    PUCHAR BootSectBuf;
    PUCHAR BootCodeBuf;
    HANDLE   FileHandle;
    HANDLE   SectionHandle;
    PVOID    ViewBase;
    ULONG    FileSize;
    NTSTATUS Status;
    PDISK_REGION SystemRegion;
//
// add some code to determine bytes per sector.
//
    ULONG   BytesPerSector;

//    BytesPerSector = HardDisks[SystemPartitionRegion->DiskNumber].Geometry.BytesPerSector;
    BytesPerSector = 512;       //???

    wcscpy(p1,NtBootDevicePath);
    SpConcatenatePaths(p1,L"bootsect.dos");

    FileHandle = 0;
    Status = SpOpenAndMapFile(p1,&FileHandle,&SectionHandle,&ViewBase,&FileSize,FALSE);

    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    BootCodeBuf = SpMemAlloc(FileSize+1);

    try {
        RtlMoveMemory(BootCodeBuf,ViewBase,FileSize);
    }
    except( IN_PAGE_ERROR ) {
        //
        // Do nothing, boot ini processing can proceed with whatever has been
        // read
        //
    }

    Status = pSpBootCodeIo(
            NtBootDevicePath,
                    NULL,
                    2048,
                    &BootSectBuf,
                    FILE_OPEN,
                    FALSE,
                    0,
                    BytesPerSector
                    );

    if(!NT_SUCCESS(Status)) {
        SpMemFree(BootCodeBuf);
        SpUnmapFile(SectionHandle,ViewBase);
        ZwClose(FileHandle);
        return(Status);
    }

    //
    // Keep dirty flag in FAT BPB, to avoid confusion in disk management.
    //
    SystemRegion = SpRegionFromNtName(NtBootDevicePath, PartitionOrdinalCurrent);
    
    if(SystemRegion && (SystemRegion->Filesystem != FilesystemNtfs)) {
        BootCodeBuf[0x25] = BootSectBuf[0x25]; // Dirty flag in BPB.
    }

    RtlMoveMemory(BootSectBuf,BootCodeBuf,512);

    pSpBootCodeIo(
        NtBootDevicePath,
        NULL,
        2048,
        &BootSectBuf,
        FILE_OPEN,
        TRUE,
        0,
        BytesPerSector
        );

    SpMemFree(BootCodeBuf);
    SpMemFree(BootSectBuf);
    SpUnmapFile(SectionHandle,ViewBase);
    ZwClose(FileHandle);
    
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\bootvar.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    bootvar.h

Abstract:

    Header file for functions to deal with boot.ini boot variables.

Author:

    Chuck Lenzmeier (chuckl) 6-Jan-2001
        extracted boot.ini-specific items from spboot.h

Revision History:

--*/

#ifndef _BOOTVAR_H_
#define _BOOTVAR_H_

typedef enum _BOOTVAR {
    LOADIDENTIFIER = 0,
    OSLOADER,
    OSLOADPARTITION,
    OSLOADFILENAME,
    OSLOADOPTIONS,
    SYSTEMPARTITION
    } BOOTVAR;

#define FIRSTBOOTVAR    LOADIDENTIFIER
#define LASTBOOTVAR     SYSTEMPARTITION
#define MAXBOOTVARS     LASTBOOTVAR+1

#define LOADIDENTIFIERVAR      "LoadIdentifier"
#define OSLOADERVAR            "OsLoader"
#define OSLOADPARTITIONVAR     "OsLoadPartition"
#define OSLOADFILENAMEVAR      "OsLoadFilename"
#define OSLOADOPTIONSVAR       "OsLoadOptions"
#define SYSTEMPARTITIONVAR     "SystemPartition"

#define DEFAULT_TIMEOUT 20

VOID
SpAddBootSet(
    IN PWSTR *BootSet,
    IN BOOLEAN Default,
    IN ULONG Signature
    );

VOID
SpDeleteBootSet(
    IN  PWSTR *BootSet,
    OUT PWSTR *OldOsLoadOptions  OPTIONAL
    );

BOOLEAN
SpFlushBootVars(
    );

#endif // _BOOTVAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\bpb.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    bpb.h

Abstract:

    This module contains the declarations for packed and
    unpacked Bios Parameter Block

Author:

    Bill McJohn     [BillMc]        24-September-1993

Revision History:

    Adapted from utils\ifsutil\inc\bpb.hxx

--*/

#if !defined( _BPB_DEFN_ )
#define _BPB_DEFN_

#define cOEM    8
#define cLABEL    11
#define cSYSID    8

typedef struct _PACKED_BIOS_PARAMETER_BLOCK {
    UCHAR  BytesPerSector[2];                       //  offset = 0x000
    UCHAR  SectorsPerCluster[1];                    //  offset = 0x002
    UCHAR  ReservedSectors[2];                      //  offset = 0x003
    UCHAR  Fats[1];                                 //  offset = 0x005
    UCHAR  RootEntries[2];                          //  offset = 0x006
    UCHAR  Sectors[2];                              //  offset = 0x008
    UCHAR  Media[1];                                //  offset = 0x00A
    UCHAR  SectorsPerFat[2];                        //  offset = 0x00B
    UCHAR  SectorsPerTrack[2];                      //  offset = 0x00D
    UCHAR  Heads[2];                                //  offset = 0x00F
    UCHAR  HiddenSectors[4];                        //  offset = 0x011
    UCHAR  LargeSectors[4];                         //  offset = 0x015
} PACKED_BIOS_PARAMETER_BLOCK;                      //  sizeof = 0x019
typedef PACKED_BIOS_PARAMETER_BLOCK *PPACKED_BIOS_PARAMETER_BLOCK;

typedef struct BIOS_PARAMETER_BLOCK {
    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  Fats;
    USHORT RootEntries;
    USHORT Sectors;
    UCHAR  Media;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT Heads;
    ULONG  HiddenSectors;
    ULONG  LargeSectors;
} BIOS_PARAMETER_BLOCK;
typedef BIOS_PARAMETER_BLOCK *PBIOS_PARAMETER_BLOCK;

#if !defined( _UCHAR_DEFINED_ )

#define _UCHAR_DEFINED_

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//
typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

#define CopyUchar1(Dst,Src) {                                \
    ((PUCHAR1)(Dst))->Uchar[0] = ((PUCHAR1)(Src))->Uchar[0]; \
}

#define CopyUchar2(Dst,Src) {                                \
    ((PUCHAR2)(Dst))->Uchar[0] = ((PUCHAR2)(Src))->Uchar[0]; \
    ((PUCHAR2)(Dst))->Uchar[1] = ((PUCHAR2)(Src))->Uchar[1]; \
}

#define CopyUchar4(Dst,Src) {                                \
    ((PUCHAR4)(Dst))->Uchar[0] = ((PUCHAR4)(Src))->Uchar[0]; \
    ((PUCHAR4)(Dst))->Uchar[1] = ((PUCHAR4)(Src))->Uchar[1]; \
    ((PUCHAR4)(Dst))->Uchar[2] = ((PUCHAR4)(Src))->Uchar[2]; \
    ((PUCHAR4)(Dst))->Uchar[3] = ((PUCHAR4)(Src))->Uchar[3]; \
}

#endif // _UCHAR_DEFINED_

//
//  This macro takes a Packed BPB and fills in its Unpacked equivalent
//
#define UnpackBios(Bios,Pbios) {                                          \
    CopyUchar2(&((Bios)->BytesPerSector),    (Pbios)->BytesPerSector   ); \
    CopyUchar1(&((Bios)->SectorsPerCluster), (Pbios)->SectorsPerCluster); \
    CopyUchar2(&((Bios)->ReservedSectors),   (Pbios)->ReservedSectors  ); \
    CopyUchar1(&((Bios)->Fats),              (Pbios)->Fats             ); \
    CopyUchar2(&((Bios)->RootEntries),       (Pbios)->RootEntries      ); \
    CopyUchar2(&((Bios)->Sectors),           (Pbios)->Sectors          ); \
    CopyUchar1(&((Bios)->Media),             (Pbios)->Media            ); \
    CopyUchar2(&((Bios)->SectorsPerFat),     (Pbios)->SectorsPerFat    ); \
    CopyUchar2(&((Bios)->SectorsPerTrack),   (Pbios)->SectorsPerTrack  ); \
    CopyUchar2(&((Bios)->Heads),             (Pbios)->Heads            ); \
    CopyUchar4(&((Bios)->HiddenSectors),     (Pbios)->HiddenSectors    ); \
    CopyUchar4(&((Bios)->LargeSectors),      (Pbios)->LargeSectors     ); \
}


//
//  This macro takes an Unpacked BPB and fills in its Packed equivalent
//
#define PackBios(Bios,Pbios) {                                            \
    CopyUchar2((Pbios)->BytesPerSector,    &((Bios)->BytesPerSector)   ); \
    CopyUchar1((Pbios)->SectorsPerCluster, &((Bios)->SectorsPerCluster)); \
    CopyUchar2((Pbios)->ReservedSectors,   &((Bios)->ReservedSectors)  ); \
    CopyUchar1((Pbios)->Fats,              &((Bios)->Fats)             ); \
    CopyUchar2((Pbios)->RootEntries,       &((Bios)->RootEntries)      ); \
    CopyUchar2((Pbios)->Sectors,           &((Bios)->Sectors)          ); \
    CopyUchar1((Pbios)->Media,             &((Bios)->Media)            ); \
    CopyUchar2((Pbios)->SectorsPerFat,     &((Bios)->SectorsPerFat)    ); \
    CopyUchar2((Pbios)->SectorsPerTrack,   &((Bios)->SectorsPerTrack)  ); \
    CopyUchar2((Pbios)->Heads,             &((Bios)->Heads)            ); \
    CopyUchar4((Pbios)->HiddenSectors,     &((Bios)->HiddenSectors)    ); \
    CopyUchar4((Pbios)->LargeSectors,      &((Bios)->LargeSectors)     ); \
}

//
//  And now, an extended BPBP:
//
typedef struct _PACKED_EXTENDED_BIOS_PARAMETER_BLOCK {
    UCHAR  IntelNearJumpCommand[1];
    UCHAR  BootStrapJumpOffset[2];
    UCHAR  OemData[cOEM];

    PACKED_BIOS_PARAMETER_BLOCK Bpb;
    UCHAR   PhysicalDrive[1];           // 0 = removable, 80h = fixed
    UCHAR   CurrentHead[1];             // not used by fs utils
    UCHAR   Signature[1];               // boot signature
    UCHAR   SerialNumber[4];            // volume serial number
    UCHAR   Label[cLABEL];              // volume label, padded with spaces
    UCHAR   SystemIdText[cSYSID];       // system ID, (e.g. FAT or HPFS)
    UCHAR   StartBootCode;              // first byte of boot code

} PACKED_EXTENDED_BIOS_PARAMETER_BLOCK, *PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK;

typedef struct _EXTENDED_BIOS_PARAMETER_BLOCK {
    UCHAR  IntelNearJumpCommand;
    USHORT BootStrapJumpOffset;
    UCHAR  OemData[cOEM];

    BIOS_PARAMETER_BLOCK Bpb;
    UCHAR   PhysicalDrive;
    UCHAR   CurrentHead;
    UCHAR   Signature;
    ULONG   SerialNumber;
    UCHAR   Label[11];
    UCHAR   SystemIdText[8];

} EXTENDED_BIOS_PARAMETER_BLOCK, *PEXTENDED_BIOS_PARAMETER_BLOCK;

//
// This macro unpacks a Packed Extended BPB.
//
#define UnpackExtendedBios( Bios, Pbios ) {                                 \
    CopyUchar1( &((Bios)->IntelNearJumpCommand), (Pbios)->IntelNearJumpCommand );    \
    CopyUchar2( &((Bios)->BootStrapJumpOffset),  (Pbios)->BootStrapJumpOffset  );    \
    memcpy( (Bios)->OemData,        (Pbios)->OemData,       cOEM );         \
    UnpackBios( &((Bios)->Bpb), &((Pbios)->Bpb));                           \
    CopyUchar1( &((Bios)->PhysicalDrive),   (Pbios)->PhysicalDrive );       \
    CopyUchar1( &((Bios)->CurrentHead),     (Pbios)->CurrentHead );         \
    CopyUchar1( &((Bios)->Signature),       (Pbios)->Signature )            \
    CopyUchar4( &((Bios)->SerialNumber),    (Pbios)->SerialNumber );        \
    memcpy( (Bios)->Label,          (Pbios)->Label,        cLABEL );        \
    memcpy( (Bios)->SystemIdText,   (Pbios)->SystemIdText,  cSYSID );       \
}

//
// This macro packs a Packed Extended BPB.
//
#define PackExtendedBios( Bios, Pbios ) {                                   \
    PackBios( &((Bios)->Bpb), &((Pbios)->Bpb));                             \
    CopyUchar1( (Pbios)->IntelNearJumpCommand,  &((Bios)->IntelNearJumpCommand)  );    \
    CopyUchar2( (Pbios)->BootStrapJumpOffset,   &((Bios)->BootStrapJumpOffset)   );    \
    memcpy( (Pbios)->OemData,        (Bios)->OemData,       cOEM );         \
    CopyUchar1( (Pbios)->PhysicalDrive,     &((Bios)->PhysicalDrive ));     \
    CopyUchar1( (Pbios)->CurrentHead,       &((Bios)->CurrentHead ));       \
    CopyUchar1( (Pbios)->Signature,         &((Bios)->Signature));          \
    CopyUchar4( (Pbios)->SerialNumber,      &((Bios)->SerialNumber ));      \
    memcpy( (Pbios)->Label,           (Bios)->Label,           cLABEL );    \
    memcpy( (Pbios)->SystemIdText,    (Bios)->SystemIdText,    cSYSID );    \
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\cvf.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cvf.hxx

Abstract:

    This module contains basic declarations and definitions for
    the double-space file system format.  Note that more extensive
    description of the file system structures may be found in
    ntos\fastfat\cvf.h

Author:

    Bill McJohn     [BillMc]        24-September-1993

Revision History:

    Adapted from utils\ufat\inc\cvf.hxx

--*/

#if !defined( _CVF_DEFN_ )
#define _CVF_DEFN_

#include "bpb.h"

// Manifest constants for fixed values on a Double Space drive:
//
CONST DoubleSpaceBytesPerSector = 512;
CONST DoubleSpaceLog2BytesPerSector = 9;
CONST DoubleSpaceSectorsPerCluster = 16;
CONST DoubleSpaceLog2SectorsPerCluster = 4;
CONST DoubleSpaceReservedSectors = 16;
CONST DoubleSpaceFats = 1;
CONST DoubleSpaceSectorsInRootDir = 32;
CONST DoubleSpaceRootEntries = 512;
CONST DoubleSpaceMediaByte = 0xf8;
CONST DoubleSpaceSectorsPerTrack = 0x11;
CONST DoubleSpaceHeads = 6;
CONST DoubleSpaceHiddenSectors = 0;
CONST DoubleSpaceReservedSectors2 = 31;
CONST DSBytesPerBitmapPage = 2048;
CONST DSSectorsPerBitmapPage = 4;

CONST ULONG EIGHT_MEG = 8 * 1024L * 1024L;

CONST DbSignatureLength = 4;
CONST UCHAR FirstDbSignature[4 /* DbSignatureLength */] = { (UCHAR)0xf8, 'D', 'R', 0 };
CONST UCHAR SecondDbSignature[4 /* DbSignatureLength */] = "MDR";

#if 0
// INLINE
ULONG
ComputeMaximumCapacity(
    IN ULONG HostDriveSize
    )
/*++

Routine Description:

    This function computes the maximum capacity for a compressed
    volume file on a host volume of a given size.

Arguments:

    HostDriveSize   --  Supplies the size in bytes of the host drive.

Return Value:

    The appropriate Maximum Capacity.

--*/
{
    ULONG MaxCap;

    if( HostDriveSize < 20 * 1024L * 1024L ) {

        MaxCap = 16 * HostDriveSize;

    } else if ( HostDriveSize < 64 * 1024L * 1024L ) {

        MaxCap = 8 * HostDriveSize;

    } else {

        MaxCap = 4 * HostDriveSize;
    }

    if( MaxCap < 4 * 1024L * 1024L ) {

        MaxCap = 4 * 1024L * 1024L;

    } else if( MaxCap > 512 * 1024L * 1024L ) {

        MaxCap = 512 * 1024L * 1024L;
    }

    return MaxCap;
}
#endif

typedef struct _PACKED_CVF_HEADER {

    //
    //  First a typical start of a boot sector
    //

    UCHAR Jump[1];                                  // offset = 0x000   0
    UCHAR JmpOffset[2];
    UCHAR Oem[8];                                   // offset = 0x003   3
    PACKED_BIOS_PARAMETER_BLOCK PackedBpb;          // offset = 0x00B  11

    //
    //  Now the DblSpace extensions
    //

    UCHAR CvfFatExtensionsLbnMinus1[2];             // offset = 0x024  36
    UCHAR LogOfBytesPerSector[1];                   // offset = 0x026  38
    UCHAR DosBootSectorLbn[2];                      // offset = 0x027  39
    UCHAR DosRootDirectoryOffset[2];                // offset = 0x029  41
    UCHAR CvfHeapOffset[2];                         // offset = 0x02B  43
    UCHAR CvfFatFirstDataEntry[2];                  // offset = 0x02D  45
    UCHAR CvfBitmap2KSize[1];                       // offset = 0x02F  47
    UCHAR Reserved1[2];                             // offset = 0x030  48
    UCHAR LogOfSectorsPerCluster[1];                // offset = 0x032  50
    UCHAR Reserved2[2];                             // offset = 0x033
    UCHAR MinFile[4];                               // offset = 0x035
    UCHAR Reserved3[4];                             // offset = 0x039
    UCHAR Is12BitFat[1];                            // offset = 0x03D  61
    UCHAR CvfMaximumCapacity[2];                    // offset = 0x03E  62
    UCHAR StartBootCode;

} PACKED_CVF_HEADER;                                // sizeof = 0x040  64
typedef PACKED_CVF_HEADER *PPACKED_CVF_HEADER;

//
//  For the unpacked version we'll only define the necessary field and skip
//  the jump and oem fields.
//

typedef struct _CVF_HEADER {

    UCHAR Jump;
    USHORT JmpOffset;
 
    UCHAR Oem[8];
    BIOS_PARAMETER_BLOCK Bpb;

    USHORT CvfFatExtensionsLbnMinus1;
    UCHAR  LogOfBytesPerSector;
    USHORT DosBootSectorLbn;
    USHORT DosRootDirectoryOffset;
    USHORT CvfHeapOffset;
    USHORT CvfFatFirstDataEntry;
    UCHAR  CvfBitmap2KSize;
    UCHAR  LogOfSectorsPerCluster;
    UCHAR  Is12BitFat;
    ULONG  MinFile;
    USHORT CvfMaximumCapacity;

} CVF_HEADER;
typedef CVF_HEADER *PCVF_HEADER;

//
//  Here is NT's typical routine/macro to unpack the cvf header because DOS
//  doesn't bother to naturally align anything.
//
//      VOID
//      CvfUnpackCvfHeader (
//          IN OUT PCVF_HEADER UnpackedHeader,
//          IN PPACKED_CVF_HEADER PackedHeader
//          );
//

#define CvfUnpackCvfHeader(UH,PH) {                                                      \
                                                                                         \
    memcpy( &(UH)->Jump,        &(PH)->Jump,        1 );                                 \
    memcpy( &(UH)->JmpOffset,   &(PH)->JmpOffset,   2 );                                 \
    memcpy( &(UH)->Oem,     &(PH)->Oem,     8 );                                         \
    UnpackBios( &(UH)->Bpb, &(PH)->PackedBpb );                                          \
    CopyUchar2( &(UH)->CvfFatExtensionsLbnMinus1, &(PH)->CvfFatExtensionsLbnMinus1[0] ); \
    CopyUchar1( &(UH)->LogOfBytesPerSector,       &(PH)->LogOfBytesPerSector[0]       ); \
    CopyUchar2( &(UH)->DosBootSectorLbn,          &(PH)->DosBootSectorLbn[0]          ); \
    CopyUchar2( &(UH)->DosRootDirectoryOffset,    &(PH)->DosRootDirectoryOffset[0]    ); \
    CopyUchar2( &(UH)->CvfHeapOffset,             &(PH)->CvfHeapOffset[0]             ); \
    CopyUchar2( &(UH)->CvfFatFirstDataEntry,      &(PH)->CvfFatFirstDataEntry[0]      ); \
    CopyUchar1( &(UH)->CvfBitmap2KSize,           &(PH)->CvfBitmap2KSize[0]           ); \
    CopyUchar1( &(UH)->LogOfSectorsPerCluster,    &(PH)->LogOfSectorsPerCluster[0]    ); \
    CopyUchar1( &(UH)->Is12BitFat,                &(PH)->Is12BitFat[0]                ); \
    CopyUchar4( &(UH)->MinFile,                   &(PH)->MinFile[0]                   ); \
    CopyUchar2( &(UH)->CvfMaximumCapacity,        &(PH)->CvfMaximumCapacity[0]        ); \
}


#define CvfPackCvfHeader(PH,UH) {                                                    \
                                                                                     \
    memcpy( &(PH)->Jump,        &(UH)->Jump,        1 );                             \
    memcpy( &(PH)->JmpOffset,   &(UH)->JmpOffset,   2 );                             \
    memcpy( &(PH)->Oem,     &(UH)->Oem,     8 );                                     \
    PackBios( &(UH)->Bpb,   &(PH)->PackedBpb,  );                                    \
    CopyUchar2( (PH)->CvfFatExtensionsLbnMinus1, &(UH)->CvfFatExtensionsLbnMinus1 ); \
    CopyUchar1( (PH)->LogOfBytesPerSector,       &(UH)->LogOfBytesPerSector       ); \
    CopyUchar2( (PH)->DosBootSectorLbn,          &(UH)->DosBootSectorLbn          ); \
    CopyUchar2( (PH)->DosRootDirectoryOffset,    &(UH)->DosRootDirectoryOffset    ); \
    CopyUchar2( (PH)->CvfHeapOffset,             &(UH)->CvfHeapOffset             ); \
    CopyUchar2( (PH)->CvfFatFirstDataEntry,      &(UH)->CvfFatFirstDataEntry      ); \
    CopyUchar1( (PH)->CvfBitmap2KSize,           &(UH)->CvfBitmap2KSize           ); \
    CopyUchar1( (PH)->LogOfSectorsPerCluster,    &(UH)->LogOfSectorsPerCluster    ); \
    CopyUchar1( (PH)->Is12BitFat,                &(UH)->Is12BitFat                ); \
    CopyUchar4( (PH)->MinFile,                   &(UH)->MinFile                   ); \
    CopyUchar2( (PH)->CvfMaximumCapacity,        &(UH)->CvfMaximumCapacity        ); \
    memset( (PH)->Reserved1, 0,  2 );                                                \
    memset( (PH)->Reserved2, 0,  2 );                                                \
    memset( (PH)->Reserved3, 0,  4 );                                                \
}


//
//  The CVF FAT EXTENSIONS is a table is ULONG entries.  Each entry corresponds
//  to a FAT cluster.  The entries describe where in the CVF_HEAP to locate
//  the data for the cluster.  It indicates if the data is compressed and the
//  length of the compressed and uncompressed form.
//

typedef struct _CVF_FAT_EXTENSIONS {

    ULONG CvfHeapLbnMinus1               : 21;
    ULONG Reserved                       :  1;
    ULONG CompressedSectorLengthMinus1   :  4;
    ULONG UncompressedSectorLengthMinus1 :  4;
    ULONG IsDataUncompressed             :  1;
    ULONG IsEntryInUse                   :  1;

} CVF_FAT_EXTENSIONS;
typedef CVF_FAT_EXTENSIONS *PCVF_FAT_EXTENSIONS;


//
//  Some sizes are fixed so we'll declare them as manifest constants
//
#define CVF_MINIMUM_DISK_SIZE            (512 * 1024L)
#define CVF_FATFAILSAFE                  (1024L)
#define CVF_MIN_HEAP_SECTORS             (60)
#define CVF_RESERVED_AREA_1_SECTOR_SIZE  (1)
#define CVF_RESERVED_AREA_2_SECTOR_SIZE  (31)
#define CVF_RESERVED_AREA_4_SECTOR_SIZE  (2)


#endif // _CVF_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\dynupdt.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dynupdt.h

Abstract:

    Dynamic Update support for text setup. Portions moved from i386\win31upg.c

Author:

    Ovidiu Temereanca (ovidiut) 20-Aug-2000

Revision History:

--*/


#pragma once

//
// Globals
//

extern HANDLE g_UpdatesCabHandle;
extern PVOID g_UpdatesSifHandle;
extern HANDLE g_UniprocCabHandle;
extern PVOID g_UniprocSifHandle;

//
// Dynamic update boot driver path in NT namespace
//
extern PWSTR DynUpdtBootDriverPath;


//
// Prototypes
//


BOOLEAN
SpInitAlternateSource (
    VOID
    );

VOID
SpUninitAlternateSource (
    VOID
    );

BOOLEAN
SpInitializeUpdatesCab (
    IN      PWSTR UpdatesCab,
    IN      PWSTR UpdatesSifSection,
    IN      PWSTR UniprocCab,
    IN      PWSTR UniprocSifSection
    );

PWSTR
SpNtPathFromDosPath (
    IN      PWSTR DosPath
    );

PDISK_REGION
SpPathComponentToRegion(
    IN PWSTR PathComponent
    );

PWSTR
SpGetDynamicUpdateBootDriverPath(
    IN  PWSTR   NtBootPath,
    IN  PWSTR   NtBootDir,
    IN  PVOID   InfHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\diamond.c ===
#include "spprecmp.h"
#pragma hdrstop
#include <diamondd.h>

#define SETUP_FDI_POOL_TAG   0x44465053      // 'SPFD'

#ifdef DeleteFile
#undef DeleteFile   // we mean "DeleteFile", not "DeleteFileA"
#endif

HFDI FdiContext;
ERF FdiError;

//
// Gloabls used when copying a file.
// Setup opens the source and target files and maps the source.
// To avoid opening and closing the source and target multiple times
// and to maintain a mapped file inplementation, we'll fake the i/o calls.
// These globals remember state about the source (cabinet) and target
// files currently in use.
//
PUCHAR SpdSourceAddress;
ULONG SpdSourceFileSize;

typedef struct {
    PEXPAND_CALLBACK    Callback;
    PVOID               CallbackContext;
    LPWSTR              DestinationPath;
} EXPAND_CAB_CONTEXT;

typedef struct _DRIVER_CAB_CONTEXT {
    PCWSTR  FileName;
    PCSTR   FileNameA;
    USHORT  FileDate;
    USHORT  FileTime;
} DRIVER_CAB_CONTEXT, *PDRIVER_CAB_CONTEXT;

DRIVER_CAB_CONTEXT DriverContext;

typedef struct _MY_FILE_STATE {
    ULONG Signature;
    union {
        LONG FileOffset;
        HANDLE Handle;
    } u;
} MY_FILE_STATE, *PMY_FILE_STATE;

#define SOURCE_FILE_SIGNATURE 0x45f3ec83
#define TARGET_FILE_SIGNATURE 0x46f3ec83

MY_FILE_STATE CurrentTargetFile;

INT_PTR
DIAMONDAPI
SpdNotifyFunction(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Perameters
    );

INT_PTR
DIAMONDAPI
SpdNotifyFunctionCabinet(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    );

INT_PTR
DIAMONDAPI
SpdNotifyFunctionDriverCab(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Perameters
    );


INT_PTR
DIAMONDAPI
SpdFdiOpen(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    );

int
DIAMONDAPI
SpdFdiClose(
    IN INT_PTR Handle
    );


VOID
pSpdInitGlobals(
    IN PVOID SourceBaseAddress,
    IN ULONG SourceFileSize
    )
{
    SpdSourceAddress = SourceBaseAddress;
    SpdSourceFileSize = SourceFileSize;
}



BOOLEAN
SpdIsCabinet(
    IN PVOID SourceBaseAddress,
    IN ULONG SourceFileSize,
    OUT PBOOLEAN ContainsMultipleFiles
    )
{
    FDICABINETINFO CabinetInfo;
    INT_PTR h;
    BOOLEAN b;

    *ContainsMultipleFiles = FALSE;

    ASSERT(FdiContext);
    if(!FdiContext) {
        return(FALSE);
    }

    //
    // Save away globals for later use.
    //
    pSpdInitGlobals(SourceBaseAddress,SourceFileSize);

    //
    // 'Open' the file so we can pass a handle that will work
    // with SpdFdiRead and SpdFdiWrite.
    //
    h = SpdFdiOpen("",0,0);
    if(h == -1) {
        return(FALSE);
    }

    //
    // We don't trust diamond to be robust.
    //

    memset(&CabinetInfo, 0, sizeof(CabinetInfo));

    try {
        b = FDIIsCabinet(FdiContext,h,&CabinetInfo) ? TRUE : FALSE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }

    //
    // If spanned or more than one file inside, report it as multiple
    //

    if (b) {
        if ((CabinetInfo.cFolders > 1) || (CabinetInfo.cFiles > 1)) {
            *ContainsMultipleFiles = TRUE;
        }
    }

    //
    // 'Close' the file.
    //
    SpdFdiClose(h);

    return(b);
}



BOOLEAN
SpdIsCompressed(
    IN PVOID SourceBaseAddress,
    IN ULONG SourceFileSize
    )
{
    BOOLEAN Result = FALSE;
    BOOLEAN bMultiple = FALSE;

    Result = SpdIsCabinet(SourceBaseAddress,
                          SourceFileSize,
                          &bMultiple);

    //
    // Compressed files with more than one contained file s/b treated as
    // an uncompressed file and copied as is.  We're not prepared to uncompress
    // multiple files from one file.
    //

    if (Result && bMultiple) {
        Result = FALSE;
    }

    return(Result);
}



NTSTATUS
SpdDecompressFile(
    IN PVOID  SourceBaseAddress,
    IN ULONG  SourceFileSize,
    IN HANDLE DestinationHandle
    )
{
    BOOL b;

    ASSERT(FdiContext);

    //
    // Save away globals for later use.
    //
    pSpdInitGlobals(SourceBaseAddress,SourceFileSize);

    CurrentTargetFile.Signature = TARGET_FILE_SIGNATURE;
    CurrentTargetFile.u.Handle = DestinationHandle;

    //
    // Get the copy going. Note that we pass empty cabinet filenames
    // because we've already opened the files.
    //
    b = FDICopy(FdiContext,"","",0,SpdNotifyFunction,NULL,NULL);

    return(b ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


NTSTATUS
SpdDecompressCabinet(
    IN PVOID            SourceBaseAddress,
    IN ULONG            SourceFileSize,
    IN PWSTR            DestinationPath,
    IN PEXPAND_CALLBACK Callback,
    IN PVOID            CallbackContext
    )
{
    BOOL b;
    EXPAND_CAB_CONTEXT NotifyContext;

    ASSERT(FdiContext);

    //
    // Save away globals for later use.
    //
    pSpdInitGlobals(SourceBaseAddress,SourceFileSize);

    CurrentTargetFile.Signature = TARGET_FILE_SIGNATURE;
    CurrentTargetFile.u.Handle = INVALID_HANDLE_VALUE;

    //
    // Tunnel expand context info into SpdNotifyFunctionCabinet
    //
    NotifyContext.Callback = Callback;
    NotifyContext.CallbackContext = CallbackContext;
    NotifyContext.DestinationPath = DestinationPath;

    //
    // Get the copy going. Note that we pass empty cabinet filenames
    // because we've already opened the files.
    //
    b = FDICopy(FdiContext,"","",0,SpdNotifyFunctionCabinet,NULL,&NotifyContext);

    if ( CurrentTargetFile.u.Handle != INVALID_HANDLE_VALUE ) {

        //
        //  FDI had some error, so we need to close & destroy the target
        //  file-in-progress.  Note that FDI calls it's FDIClose callback
        //  but in our implementation, that has no effect on the target
        //  file.
        //

        FILE_DISPOSITION_INFORMATION FileDispositionDetails;
        IO_STATUS_BLOCK IoStatusBlock;

        FileDispositionDetails.DeleteFile = TRUE;

        ZwSetInformationFile( CurrentTargetFile.u.Handle,
                              &IoStatusBlock,
                              &FileDispositionDetails,
                              sizeof(FileDispositionDetails),
                              FileDispositionInformation );

        ZwClose( CurrentTargetFile.u.Handle );

        b = FALSE;  // make sure we report failure
    }

    return(b ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


NTSTATUS
SpdDecompressFileFromDriverCab(
    IN PWSTR SourceFileName,
    IN PVOID  SourceBaseAddress,
    IN ULONG  SourceFileSize,
    IN HANDLE DestinationHandle,
    OUT PUSHORT pDate,
    OUT PUSHORT pTime
    )
{
    BOOL b;

    ASSERT(FdiContext);
    ASSERT(DriverContext.FileName == NULL);
    ASSERT(DriverContext.FileNameA == NULL);

    //
    // Save away globals for later use.
    //
    pSpdInitGlobals(SourceBaseAddress,SourceFileSize);

    CurrentTargetFile.Signature = TARGET_FILE_SIGNATURE;
    CurrentTargetFile.u.Handle = DestinationHandle;
    DriverContext.FileName = SpDupStringW(SourceFileName);

    if (!DriverContext.FileName) {
        return(STATUS_NO_MEMORY);
    }

    DriverContext.FileNameA = SpToOem((PWSTR)DriverContext.FileName);

    //
    // Get the copy going. Note that we pass empty cabinet filenames
    // because we've already opened the files.
    //
    b = FDICopy(FdiContext,"","",0,SpdNotifyFunctionDriverCab,NULL,NULL);

    ASSERT(DriverContext.FileName != NULL);
    SpMemFree( (PWSTR)DriverContext.FileName );
    DriverContext.FileName = NULL;

    if (DriverContext.FileNameA) {
        SpMemFree( (PSTR)DriverContext.FileNameA );
        DriverContext.FileNameA = NULL;
    }

    *pDate = DriverContext.FileDate;
    *pTime = DriverContext.FileTime;


    return(b ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}



INT_PTR
DIAMONDAPI
SpdNotifyFunction(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    )
{
    switch(Operation) {

    case fdintCABINET_INFO:
    case fdintNEXT_CABINET:
    case fdintPARTIAL_FILE:

        //
        // Cabinet management functions which we don't use.
        // Return success.
        //
        return(0);

    case fdintCOPY_FILE:

        //
        // Diamond is asking us whether we want to copy the file.
        // We need to return a file handle to indicate that we do.
        //
        return((INT_PTR)&CurrentTargetFile);

    case fdintCLOSE_FILE_INFO:

        //
        // Diamond is done with the target file and wants us to close it.
        // (ie, this is the counterpart to fdint_COPY_FILE).
        // We manage our own file i/o so ignore this.
        //
        return(TRUE);
    }

    return 0;
}


INT_PTR
DIAMONDAPI
SpdNotifyFunctionCabinet(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    )
{
    EXPAND_CAB_CONTEXT * Context = (EXPAND_CAB_CONTEXT *) Parameters->pv;
    NTSTATUS Status;
    ULONG FileNameLength;
    ULONG Disposition;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    union {
        FILE_BASIC_INFORMATION       FileBasicDetails;
        FILE_RENAME_INFORMATION      FileRenameDetails;
        FILE_DISPOSITION_INFORMATION FileDispositionDetails;
        WCHAR                        PathName[CB_MAX_FILENAME * 2];
    } U;
    HANDLE TempHandle;

    //
    // These values are retained between fdintCOPY_FILE and fdintCLOSE_FILE_INFO
    //
    static WCHAR FileName[CB_MAX_FILENAME];
    static LARGE_INTEGER FileSize;
    static LARGE_INTEGER FileTime;
    static ULONG FileAttributes;


    switch ( Operation ) {

    case fdintCOPY_FILE:

        //
        // Diamond is asking us whether we want to copy the file.
        // Convert everything we're given to the form needed to
        // call the client back to ask it about this file.
        // We need to return a file handle to indicate that we do.
        //

        Status = RtlMultiByteToUnicodeN (
            FileName,
            sizeof(FileName),
            &FileNameLength,
            Parameters->psz1,
            strlen(Parameters->psz1)
            );

        if (!NT_SUCCESS(Status)) {
            //
            // failed to translate, ignore file
            //
            return(-1);
        }

        FileName[ FileNameLength / sizeof(WCHAR) ] = L'\0';

        FileSize.LowPart = Parameters->cb;
        FileSize.HighPart = 0;

        SpTimeFromDosTime( Parameters->date,
                           Parameters->time,
                           &FileTime );

        FileAttributes = Parameters->attribs &
                                (FILE_ATTRIBUTE_ARCHIVE  |
                                 FILE_ATTRIBUTE_READONLY |
                                 FILE_ATTRIBUTE_HIDDEN   |
                                 FILE_ATTRIBUTE_SYSTEM);

        Disposition = Context->Callback( EXPAND_COPY_FILE,
                                         FileName,
                                         &FileSize,
                                         &FileTime,
                                         FileAttributes,
                                         Context->CallbackContext);

        if ( Disposition == EXPAND_ABORT ) {
            return(-1);     // tell FDI to abort
        } else if ( Disposition != EXPAND_COPY_THIS_FILE ) {
            return(0);      // tell FDI to skip this file
        }

        //
        // see if target file already exists
        //
        wcscpy( U.PathName, Context->DestinationPath );
        SpConcatenatePaths( U.PathName, FileName );

        INIT_OBJA( &Obja, &UnicodeString, U.PathName );

        Status = ZwCreateFile( &TempHandle,
                               FILE_GENERIC_READ,
                               &Obja,
                               &IoStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               0,                       // no sharing
                               FILE_OPEN,               // fail if not existing
                               FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                               NULL,
                               0
                               );

        if ( NT_SUCCESS(Status) ) {

            //
            // Target file already exists.  Check for over-write.
            //
            Status = ZwQueryInformationFile( TempHandle,
                                             &IoStatusBlock,
                                             &U.FileBasicDetails,
                                             sizeof(FILE_BASIC_INFORMATION),
                                             FileBasicInformation );

            ZwClose( TempHandle );

            if ( NT_SUCCESS(Status) &&
               ( U.FileBasicDetails.FileAttributes & FILE_ATTRIBUTE_READONLY )) {

                //
                // target file is read-only: report error
                //
                Disposition = Context->Callback( EXPAND_NOTIFY_CREATE_FAILED,
                                                 FileName,
                                                 &FileSize,
                                                 &FileTime,
                                                 FileAttributes,
                                                 Context->CallbackContext);

                if ( Disposition != EXPAND_CONTINUE ) {
                    return(-1); // tell FDI to abort
                }

                return (0); // tell FDI to just skip this target file
            }

            //
            // ask client about overwrite
            //
            Disposition = Context->Callback( EXPAND_QUERY_OVERWRITE,
                                             FileName,
                                             &FileSize,
                                             &FileTime,
                                             FileAttributes,
                                             Context->CallbackContext);

            if ( Disposition == EXPAND_ABORT ) {
                return(-1); // tell FDI to abort
            } else if ( Disposition != EXPAND_COPY_THIS_FILE ) {
                return(0);  // tell FDI to skip this file
            }
        }       // end if target file already exists

        //
        // create temporary target file
        //
        wcscpy( U.PathName, Context->DestinationPath );
        SpConcatenatePaths( U.PathName, L"$$TEMP$$.~~~" );

        //
        // see if target file exists
        //
        INIT_OBJA( &Obja, &UnicodeString, U.PathName );

        Status = ZwCreateFile( &CurrentTargetFile.u.Handle,
                               FILE_GENERIC_WRITE,
                               &Obja,
                               &IoStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               0,                       // no sharing
                               FILE_OVERWRITE_IF,       // allow overwrite
                               FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                               NULL,
                               0
                               );

        if ( !NT_SUCCESS(Status) ) {

            //
            // advise client we can't create this file
            //
            Disposition = Context->Callback( EXPAND_NOTIFY_CREATE_FAILED,
                                             FileName,
                                             &FileSize,
                                             &FileTime,
                                             FileAttributes,
                                             Context->CallbackContext);

            if ( Disposition != EXPAND_CONTINUE ) {
                return(-1); // tell FDI to abort
            }

            return (0); // tell FDI to just skip this target file
        }

        //
        // target file created: give the handle to FDI to expand
        //

        return( (INT_PTR) &CurrentTargetFile );     // target "handle"

    case fdintCLOSE_FILE_INFO:

        //
        // Diamond is done with the target file and wants us to close it.
        //

        ASSERT( CurrentTargetFile.Signature == TARGET_FILE_SIGNATURE );
        ASSERT( CurrentTargetFile.u.Handle != INVALID_HANDLE_VALUE );

        if (( CurrentTargetFile.Signature == TARGET_FILE_SIGNATURE ) &&
            ( CurrentTargetFile.u.Handle != INVALID_HANDLE_VALUE )) {

            //
            // set target file's true name (overwriting old file)
            //
            U.FileRenameDetails.ReplaceIfExists = TRUE;
            U.FileRenameDetails.RootDirectory = NULL;
            U.FileRenameDetails.FileNameLength = wcslen( FileName ) * sizeof(WCHAR);
            wcscpy( U.FileRenameDetails.FileName, FileName );

            Status = ZwSetInformationFile( CurrentTargetFile.u.Handle,
                                           &IoStatusBlock,
                                           &U.FileRenameDetails,
                                           sizeof(U.FileRenameDetails) +
                                               U.FileRenameDetails.FileNameLength,
                                           FileRenameInformation );

            if ( !NT_SUCCESS(Status) ) {

                //
                // Unable to change temp name to true name.  Change to delete
                // on close, close it, and tell the user it didn't work.
                //

                U.FileDispositionDetails.DeleteFile = TRUE;

                ZwSetInformationFile( CurrentTargetFile.u.Handle,
                                      &IoStatusBlock,
                                      &U.FileDispositionDetails,
                                      sizeof(U.FileDispositionDetails),
                                      FileDispositionInformation );

                ZwClose( CurrentTargetFile.u.Handle );

                CurrentTargetFile.u.Handle = INVALID_HANDLE_VALUE;

                Disposition = Context->Callback( EXPAND_NOTIFY_CREATE_FAILED,
                                                 FileName,
                                                 &FileSize,
                                                 &FileTime,
                                                 FileAttributes,
                                                 Context->CallbackContext);

                if ( Disposition != EXPAND_CONTINUE ) {
                    return(-1); // tell FDI to abort
                }

                return (TRUE);  // keep FDI going
            }

            //
            // try to set file's last-modifed time
            //
            Status = ZwQueryInformationFile( CurrentTargetFile.u.Handle,
                                             &IoStatusBlock,
                                             &U.FileBasicDetails,
                                             sizeof(U.FileBasicDetails),
                                             FileBasicInformation );

            if (NT_SUCCESS(Status) ) {

                U.FileBasicDetails.LastWriteTime = FileTime;

                ZwSetInformationFile( CurrentTargetFile.u.Handle,
                                      &IoStatusBlock,
                                      &U.FileBasicDetails,
                                      sizeof(U.FileBasicDetails),
                                      FileBasicInformation );
            }

            //
            // Note that we did not put any attributes on this file.
            // The client callback code may do that if it so desires.
            //

            ZwClose( CurrentTargetFile.u.Handle );

            CurrentTargetFile.u.Handle = INVALID_HANDLE_VALUE;

            //
            // Tell client it has been done
            //
            Disposition = Context->Callback( EXPAND_COPIED_FILE,
                                             FileName,
                                             &FileSize,
                                             &FileTime,
                                             FileAttributes,
                                             Context->CallbackContext);

            if ( Disposition == EXPAND_ABORT ) {

                return(-1); // tell FDI to abort now
            }
        }

        return(TRUE);
        break;

    default:
        //
        // Cabinet management functions which we don't use.
        // Return success.
        //
        return 0;
    }
}


INT_PTR
DIAMONDAPI
SpdNotifyFunctionDriverCab(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    )
{
    BOOLEAN extract;
    PWSTR CabNameW;
    ULONG Size;
    ULONG StringSize;
    NTSTATUS Status;

    switch(Operation) {

    case fdintCABINET_INFO:
    case fdintNEXT_CABINET:
    case fdintPARTIAL_FILE:

        //
        // Cabinet management functions which we don't use.
        // Return success.
        //
        return(0);

    case fdintCOPY_FILE:

        //
        // Diamond is asking us whether we want to copy the file.
        // We need to return a file handle to indicate that we do.
        //

        //
        // diamond is an ansi API -- we need to convert to unicode string
        //

        extract = FALSE;
        if (DriverContext.FileNameA) {
          if (_stricmp(DriverContext.FileNameA, Parameters->psz1) == 0) {
            extract = TRUE;
          }
        } else {

            StringSize = strlen(Parameters->psz1);
            CabNameW = SpMemAlloc ((StringSize+1) * sizeof(WCHAR));
            if (!CabNameW) {
                //
                // we're out of memory, abort
                //
                return(-1);
            }

            Status = RtlMultiByteToUnicodeN (
                CabNameW,
                StringSize * sizeof(WCHAR),
                &Size,
                Parameters->psz1,
                StringSize
                );

            if (!NT_SUCCESS(Status)) {
                //
                // failed to translate, abort
                //
                SpMemFree(CabNameW);
                return(-1);
            }

            extract = FALSE;

            //
            // null terminate
            //
            CabNameW[StringSize] = 0;
            if (_wcsicmp(DriverContext.FileName, CabNameW) == 0) {
                extract = TRUE;
            }

            SpMemFree( CabNameW );
        }

        if (extract) {
            return((INT_PTR)&CurrentTargetFile);
        } else {
            return (INT_PTR)NULL;
        }

    case fdintCLOSE_FILE_INFO:

        //
        // Diamond is done with the target file and wants us to close it.
        // (ie, this is the counterpart to fdint_COPY_FILE).
        // We manage our own file i/o so ignore this
        // (first we grab the file date and time)
        //
        DriverContext.FileDate = Parameters->date;
        DriverContext.FileTime = Parameters->time;
        return(TRUE);
    }

    return 0;
}



PVOID
DIAMONDAPI
SpdFdiAlloc(
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    Callback used by FDICopy to allocate memory.

Arguments:

    NumberOfBytes - supplies desired size of block.

Return Value:

    Returns pointer to a block of cache-aligned memory.
    Does not return if memory cannot be allocated.

--*/

{
    PVOID p;

    p = ExAllocatePoolWithTag(PagedPoolCacheAligned,NumberOfBytes,SETUP_FDI_POOL_TAG);

    if(!p) {
        SpOutOfMemory();
    }

    return(p);
}


VOID
DIAMONDAPI
SpdFdiFree(
    IN PVOID Block
    )

/*++

Routine Description:

    Callback used by FDICopy to free a memory block.
    The block must have been allocated with SpdFdiAlloc().

Arguments:

    Block - supplies pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
    ExFreePool(Block);
}


INT_PTR
DIAMONDAPI
SpdFdiOpen(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    )

/*++

Routine Description:

    Callback used by FDICopy to open files.

    In our implementation, the source and target files are already opened
    by the time we can get to this point so we don'tt ever actually open
    anything here.

    However diamond may 'open' the source file more than once because it
    wants 2 different states.  We support that here by using our own
    'handles' with special meaning to us.

Arguments:

    FileName - supplies name of file to be opened. Ignored.

    oflag - supplies flags for open. Ignored.

    pmode - supplies additional flags for open. Ignored.

Return Value:



--*/

{
    PMY_FILE_STATE State;

    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(oflag);
    UNREFERENCED_PARAMETER(pmode);

    //
    // Note: we only support opening the source (cabinet) file, which we
    // carefully pass in to FDICopy() as the empty string.
    //
    ASSERT(*FileName == 0);
    if(*FileName) {
        return(-1);
    }

    State = SpMemAlloc(sizeof(MY_FILE_STATE));

    State->u.FileOffset = 0;
    State->Signature = SOURCE_FILE_SIGNATURE;

    return((INT_PTR)State);
}


UINT
DIAMONDAPI
SpdFdiRead(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to read from a file.

    We assume that diamond is going to read only from the cabinet file.

Arguments:

    Handle - supplies handle to open file to be read from.

    pv - supplies pointer to buffer to receive bytes we read.

    ByteCount - supplies number of bytes to read.

Return Value:

    Number of bytes read or -1 if an error occurs.

--*/

{
    UINT rc;
    PMY_FILE_STATE State;
    LONG RealByteCount;

    State = (PMY_FILE_STATE)Handle;

    //
    // Assume failure.
    //
    rc = (UINT)(-1);

    //
    // Only read the source with this routine.
    //
    ASSERT(State->Signature == SOURCE_FILE_SIGNATURE);
    if(State->Signature == SOURCE_FILE_SIGNATURE) {

        RealByteCount = (LONG)ByteCount;
        if(State->u.FileOffset + RealByteCount > (LONG)SpdSourceFileSize) {
            RealByteCount = (LONG)SpdSourceFileSize - State->u.FileOffset;
        }
        if(RealByteCount < 0) {
            RealByteCount = 0;
        }

        try {

            RtlCopyMemory(
                pv,
                SpdSourceAddress + State->u.FileOffset,
                (ULONG)RealByteCount
                );

            State->u.FileOffset += RealByteCount;

            rc = RealByteCount;

        } except(EXCEPTION_EXECUTE_HANDLER) {
            ;
        }
    }

    return(rc);
}


UINT
DIAMONDAPI
SpdFdiWrite(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to write to a file.

    We assume that diamond is going to write only to the target file.

Arguments:

    Handle - supplies handle to open file to be written to.

    pv - supplies pointer to buffer containing bytes to write.

    ByteCount - supplies number of bytes to write.

Return Value:

    Number of bytes written (ByteCount) or -1 if an error occurs.

--*/

{
    UINT rc;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    PMY_FILE_STATE State;

    State = (PMY_FILE_STATE)Handle;

    //
    // Assume failure.
    //
    rc = (UINT)(-1);

    //
    // Only write the target with this routine.
    //
    ASSERT(State->Signature == TARGET_FILE_SIGNATURE);
    if(State->Signature == TARGET_FILE_SIGNATURE) {

        Status = ZwWriteFile(
                    (HANDLE)State->u.Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    pv,
                    ByteCount,
                    NULL,
                    NULL
                    );

        if(NT_SUCCESS(Status)) {
            rc = ByteCount;
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpdFdiWrite: Status %lx writing to target file\n",Status));
        }
    }

    return(rc);
}


int
DIAMONDAPI
SpdFdiClose(
    IN INT_PTR Handle
    )

/*++

Routine Description:

    Callback used by FDICopy to close files.

    In our implementation, the source and target files are managed
    elsewhere so we don't actually need to close any files.
    However we may need to free some state information.

Arguments:

    Handle - handle of file to close.

Return Value:

    0 (success).

--*/

{
    PMY_FILE_STATE State = (PMY_FILE_STATE)Handle;

    //
    // Only 'close' the source file.
    //
    if(State->Signature == SOURCE_FILE_SIGNATURE) {
        SpMemFree(State);
    }

    return(0);
}


LONG
DIAMONDAPI
SpdFdiSeek(
    IN INT_PTR  Handle,
    IN long Distance,
    IN int  SeekType
    )

/*++

Routine Description:

    Callback used by FDICopy to seek files.

    We assume that we can seek only in the source file.

Arguments:

    Handle - handle of file to close.

    Distance - supplies distance to seek. Interpretation of this
        parameter depends on the value of SeekType.

    SeekType - supplies a value indicating how Distance is to be
        interpreted; one of SEEK_SET, SEEK_CUR, SEEK_END.

Return Value:

    New file offset.

--*/

{
    PMY_FILE_STATE State = (PMY_FILE_STATE)Handle;
    LONG rc;

    //
    // Assume failure.
    //
    rc = -1L;

    //
    // Only allow seeking in the source.
    //
    ASSERT(State->Signature == SOURCE_FILE_SIGNATURE);

    if(State->Signature == SOURCE_FILE_SIGNATURE) {

        switch(SeekType) {

        case SEEK_CUR:

            //
            // Distance is an offset from the current file position.
            //
            State->u.FileOffset += Distance;
            break;

        case SEEK_END:

            //
            // Distance is an offset from the end of file.
            //
            State->u.FileOffset = SpdSourceFileSize - Distance;
            break;

        case SEEK_SET:

            //
            // Distance is the new absolute offset.
            //
            State->u.FileOffset = (ULONG)Distance;
            break;
        }

        if(State->u.FileOffset < 0) {
            State->u.FileOffset = 0;
        }

        if(State->u.FileOffset > (LONG)SpdSourceFileSize) {
            State->u.FileOffset = SpdSourceFileSize;
        }

        //
        // Return successful status.
        //
        rc = State->u.FileOffset;
    }

    return(rc);
}


VOID
SpdInitialize(
    VOID
    )
{
    FdiContext = FDICreate(
                    SpdFdiAlloc,
                    SpdFdiFree,
                    SpdFdiOpen,
                    SpdFdiRead,
                    SpdFdiWrite,
                    SpdFdiClose,
                    SpdFdiSeek,
                    cpuUNKNOWN,
                    &FdiError
                    );

    if(FdiContext == NULL) {
        SpOutOfMemory();
    }

    RtlZeroMemory(&DriverContext, sizeof(DriverContext) );

}


VOID
SpdTerminate(
    VOID
    )
{
    FDIDestroy(FdiContext);

    FdiContext = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\dynupdt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dynupdt.c

Abstract:

    Dynamic Update support for text setup. Portions moved from i386\win31upg.c

Author:

    Ovidiu Temereanca (ovidiut) 20-Aug-2000

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

//
// Macros
//
#define MAX_SECTION_NAME_LENGTH 14
#define UPDATES_SECTION_NAME    L"updates"
#define UNIPROC_SECTION_NAME    L"uniproc"

//
// Globals
//

HANDLE g_UpdatesCabHandle = NULL;
PVOID g_UpdatesSifHandle = NULL;
HANDLE g_UniprocCabHandle = NULL;
PVOID g_UniprocSifHandle = NULL;


WCHAR
SpExtractDriveLetter(
    IN PWSTR PathComponent
    );


BOOLEAN
SpInitAlternateSource (
    VOID
    )
{
    PWSTR p;
    PWSTR path;
    NTSTATUS Status;
    ULONG ErrorLine;
    WCHAR updatesCab[MAX_PATH];
    WCHAR updatesSif[MAX_PATH];
    WCHAR updatesSifSection[MAX_SECTION_NAME_LENGTH];
    WCHAR uniprocCab[MAX_PATH];
    WCHAR uniprocSif[MAX_PATH];
    WCHAR uniprocSifSection[MAX_SECTION_NAME_LENGTH];
    BOOLEAN bUniprocCab = FALSE;
    BOOLEAN b = FALSE;

    //
    // look if section [SetupParams] has an UpdatedSources key
    //
    p = SpGetSectionKeyIndex (WinntSifHandle, SIF_SETUPPARAMS, SIF_UPDATEDSOURCES, 0);
    if (!p) {
        return FALSE;
    }
    path = SpNtPathFromDosPath (p);
    if (!path) {
        goto exit;
    }

    b = SUCCEEDED (StringCchCopyW (updatesCab, ELEMENT_COUNT(updatesCab), path));
    SpMemFree (path);
    if (!b) {
        goto exit;
    }

    b = FALSE;

    //
    // this always works because the 2 buffers have identical sizes
    //
    ASSERT (ELEMENT_COUNT(updatesSif) >= ELEMENT_COUNT(updatesCab));
    wcscpy (updatesSif, updatesCab);
    p = wcsrchr (updatesSif, L'.');
    if (!p) {
        p = wcsrchr (updatesSif, 0);
    }
    if (FAILED (StringCchCopyW (p, updatesSif + ELEMENT_COUNT(updatesSif) - p, L".sif"))) {
        goto exit;
    }

    //
    // load the sif
    //
    Status = SpLoadSetupTextFile (
                updatesSif,
                NULL,                  // No image already in memory
                0,                     // Image size is empty
                &g_UpdatesSifHandle,
                &ErrorLine,
                FALSE,
                FALSE
                );
    if (!NT_SUCCESS (Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: SpInitAlternateSource: Unable to read %ws. ErrorLine = %ld, Status = %lx \n",
            updatesSif,
            ErrorLine,
            Status
            ));
        goto exit;
    }

    ASSERT (ELEMENT_COUNT(updatesSifSection) >= ELEMENT_COUNT(UPDATES_SECTION_NAME));
    wcscpy (updatesSifSection, UPDATES_SECTION_NAME);

    if (!SpSearchTextFileSection (g_UpdatesSifHandle, updatesSifSection) ||
        SpCountLinesInSection (g_UpdatesSifHandle, updatesSifSection) == 0) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: SpInitAlternateSource: Section [%ws] not found or empty in %ws.\n",
            updatesSifSection,
            updatesSif
            ));
        goto exit;
    }

    p = SpGetSectionKeyIndex (WinntSifHandle, SIF_SETUPPARAMS, SIF_UPDATEDSOURCES, 1);
    if (p && *p) {
        path = SpNtPathFromDosPath (p);
        if (!path) {
            goto exit;
        }

        b = SUCCEEDED (StringCchCopyW (uniprocCab, ELEMENT_COUNT(uniprocCab), path));
        SpMemFree (path);
        if (!b) {
            goto exit;
        }

        b = FALSE;

        ASSERT (ELEMENT_COUNT(uniprocSif) >= ELEMENT_COUNT(uniprocCab));
        wcscpy (uniprocSif, uniprocCab);
        p = wcsrchr (uniprocSif, L'.');
        if (!p) {
            p = wcsstr (uniprocSif, 0);
        }
        if (FAILED (StringCchCopyW (p, uniprocSif + ELEMENT_COUNT(uniprocSif) - p, L".sif"))) {
            goto exit;
        }
        //
        // load the sif
        //
        Status = SpLoadSetupTextFile (
                    uniprocSif,
                    NULL,                  // No image already in memory
                    0,                     // Image size is empty
                    &g_UniprocSifHandle,
                    &ErrorLine,
                    FALSE,
                    FALSE
                    );
        if (!NT_SUCCESS (Status)) {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: SpInitAlternateSource: Unable to read %ws. ErrorLine = %ld, Status = %lx \n",
                uniprocSif,
                ErrorLine,
                Status
                ));
            goto exit;
        }

        ASSERT (ELEMENT_COUNT(uniprocSifSection) >= ELEMENT_COUNT(UNIPROC_SECTION_NAME));
        wcscpy (uniprocSifSection, UNIPROC_SECTION_NAME);

        if (!SpSearchTextFileSection (g_UniprocSifHandle, uniprocSifSection) ||
            SpCountLinesInSection (g_UniprocSifHandle, uniprocSifSection) == 0) {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: SpInitAlternateSource: Section [%ws] not found or empty in %ws.\n",
                uniprocSifSection,
                uniprocSif
                ));
            goto exit;
        }
        bUniprocCab = TRUE;
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SpInitAlternateSource: Using alternate sources: %ws\n", updatesCab));

    b = SpInitializeUpdatesCab (
            updatesCab,
            updatesSifSection,
            bUniprocCab ? uniprocCab : NULL,
            bUniprocCab ? uniprocSifSection : NULL
            );

exit:
    if (!b) {
        SpUninitAlternateSource ();
    }

    return b;
}


VOID
SpUninitAlternateSource (
    VOID
    )
{
    if (g_UpdatesSifHandle) {
        SpFreeTextFile (g_UpdatesSifHandle);
        g_UpdatesSifHandle = NULL;
    }
    if (g_UniprocSifHandle) {
        SpFreeTextFile (g_UniprocSifHandle);
        g_UniprocSifHandle = NULL;
    }
}


BOOLEAN
SpInitializeUpdatesCab (
    IN      PWSTR UpdatesCab,
    IN      PWSTR UpdatesSifSection,
    IN      PWSTR UniprocCab,
    IN      PWSTR UniprocSifSection
    )
{
    PWSTR CabFileSection;
    NTSTATUS Status;
    PWSTR DriverCabName, DriverCabPath;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    CABDATA *MyCabData, *MyList = NULL;
    DWORD i;
    BOOLEAN b = TRUE;

    INIT_OBJA (&Obja, &UnicodeString, UpdatesCab);
    Status = ZwCreateFile (&g_UpdatesCabHandle,
                           FILE_GENERIC_READ,
                           &Obja,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ,
                           FILE_OPEN,
                           0,
                           NULL,
                           0 );
    if (!NT_SUCCESS (Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open cab file %ws. Status = %lx \n", UpdatesCab, Status));
        return FALSE;
    }
    //
    // create the list entry
    //
    MyCabData = SpMemAlloc (sizeof(CABDATA));
    MyCabData->CabName = SpDupStringW (UpdatesCab);
    MyCabData->CabHandle = g_UpdatesCabHandle;
    MyCabData->CabSectionName = SpDupStringW (UpdatesSifSection);
    MyCabData->CabInfHandle = g_UpdatesSifHandle;
    MyCabData->Next = MyList;
    MyList = MyCabData;

    if (UniprocCab) {
        INIT_OBJA (&Obja, &UnicodeString, UniprocCab);
        Status = ZwCreateFile (&g_UniprocCabHandle,
                               FILE_GENERIC_READ,
                               &Obja,
                               &IoStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ,
                               FILE_OPEN,
                               0,
                               NULL,
                               0 );
        if (!NT_SUCCESS (Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open cab file %ws. Status = %lx \n", UniprocCab, Status));
            b = FALSE;
            goto exit;
        }
        //
        // create the list entry
        //
        MyCabData = SpMemAlloc (sizeof(CABDATA));
        MyCabData->CabName = SpDupStringW (UniprocCab);
        MyCabData->CabHandle = g_UniprocCabHandle;
        MyCabData->CabSectionName = SpDupStringW (UniprocSifSection);
        MyCabData->CabInfHandle = g_UniprocSifHandle;
        MyCabData->Next = MyList;
        MyList = MyCabData;
    }

exit:
    if (b) {
        //
        // insert it at the beginning
        //
        while (MyList && MyList->Next) {
            MyList = MyList->Next;
        }
        if (MyList) {
            MyList->Next = CabData;
            CabData = MyList;
        }
    } else {
        //
        // destroy MyList
        //
        while (MyList) {
            MyCabData = MyList->Next;
            MyList = MyCabData;
            SpMemFree (MyCabData->CabName);
            SpMemFree (MyCabData->CabSectionName);
            SpMemFree (MyCabData);
        }
    }

    return b;
}


PWSTR
SpNtPathFromDosPath (
    IN      PWSTR DosPath
    )
{
    PDISK_REGION region;
    WCHAR drive[_MAX_DRIVE];
    WCHAR dir[_MAX_DIR];
    WCHAR fname[_MAX_FNAME];
    WCHAR ext[_MAX_EXT];
    PWSTR p;

    if (!DosPath) {
        return NULL;
    }

    region = SpPathComponentToRegion (DosPath);
    if (!region) {
        return NULL;
    }

    if (DosPath[2] != L'\\') {
        return NULL;
    }

    SpNtNameFromRegion (region, TemporaryBuffer, ELEMENT_COUNT(TemporaryBuffer), PartitionOrdinalCurrent);

    if (FAILED (StringCchCatW (TemporaryBuffer, ELEMENT_COUNT(TemporaryBuffer), DosPath + 2))) {
        return NULL;
    }

    return SpDupStringW (TemporaryBuffer);
}



PDISK_REGION
SpPathComponentToRegion(
    IN PWSTR PathComponent
    )

/*++

Routine Description:

    This routine attempts to locate a region descriptor for a
    given DOS path component.  If the DOS path component does
    not start with x:, then this fails.

Arguments:

    PathComponent - supplies a component from the DOS search path,
        for which a region esacriptor is desired.

Return Value:

    Pointer to disk region; NULL if none found with drive letter
    that starts the dos component.

--*/

{
    WCHAR c;
    ULONG disk;
    PDISK_REGION region;

    c = SpExtractDriveLetter(PathComponent);
    if(!c) {
        return(NULL);
    }

    for(disk=0; disk<HardDiskCount; disk++) {

        for(region=PartitionedDisks[disk].PrimaryDiskRegions; region; region=region->Next) {
            if(region->DriveLetter == c) {
                ASSERT(region->PartitionedSpace);
                return(region);
            }
        }

        //
        // Do not see extended partition on PC98.
        //
        for(region=PartitionedDisks[disk].ExtendedDiskRegions; region; region=region->Next) {
            if(region->DriveLetter == c) {
                ASSERT(region->PartitionedSpace);
                return(region);
            }
        }
    }

    return(NULL);
}


WCHAR
SpExtractDriveLetter(
    IN PWSTR PathComponent
    )
{
    WCHAR c;

    if((wcslen(PathComponent) >= 2) && (PathComponent[1] == L':')) {

        c = RtlUpcaseUnicodeChar(PathComponent[0]);
        if((c >= L'A') && (c <= L'Z')) {
            return(c);
        }
    }

    return(0);
}


PWSTR
SpGetDynamicUpdateBootDriverPath(
    IN  PWSTR   NtBootPath,
    IN  PWSTR   NtBootDir,
    IN  PVOID   InfHandle
    )
/*++

Routine Description:

    Gets the dynamic update boot driver directory's root
    path. 

Arguments:

    NtBootPath - Boot path in NT namespace

    NtBootDir  - Boot directory under boot path (like $WIN_NT$.~BT)

    InfHandle  - Winnt.sif handle

Return Value:

    Returns the dynamic update boot driver root path if successful 
    otherwise returns NULL

--*/
{
    PWSTR   DriverDir = NULL; 

    if (NtBootPath && NtBootDir && InfHandle) {
        PWSTR   Present = SpGetSectionKeyIndex(InfHandle,
                            WINNT_SETUPPARAMS_W,
                            WINNT_SP_DYNUPDTBOOTDRIVERPRESENT_W,
                            0);

        PWSTR   Dir = SpGetSectionKeyIndex(InfHandle,
                            WINNT_SETUPPARAMS_W,
                            WINNT_SP_DYNUPDTBOOTDRIVERROOT_W,
                            0);

        if (Dir && Present && !_wcsicmp(Present, L"yes")) {
            WCHAR   Buffer[MAX_PATH];

            wcscpy(Buffer, NtBootPath);
            SpConcatenatePaths(Buffer, NtBootDir);

            //
            // NOTE : Currently ignore boot driver root path
            //
            // SpConcatenatePaths(Buffer, Dir);            

            DriverDir = SpDupStringW(Buffer);
        }
    }

    return DriverDir;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\graphics.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    graphics.c

Abstract:

    Bitmap display support with text mode for
    upgrade. This file has implementation for the
    three core abstractions i.e. Bitmap,
    Animated bitmap and Graphics Progress bar.

    In upgrade graphics mode, we have one primary
    graphics thread running in the foreground.
    This thread paints the background, creates
    animated bitmap(s) and updates a single
    progress bar. An upgrade specific callback
    is registered which calculates the overall
    progress.

    Although we are in graphics mode during upgrade,
    all the regular textmode output is still
    written to a buffer. When we hit some error
    or require user intervention we switch back
    to the actual textmode and copy all the cached
    information to actual video memory. One can
    switch to textmode from graphics but not
    vice-versa.

    Note : For each animated bitmap a separate
    thread is started while animating. Using lot
    of animated bitmaps can slow down the actual
    text mode setup thread.

Author:

    Vijay Jayaseelan (vijayj)  01 July 2000

Revision History:

    None

--*/

#include "spprecmp.h"
#include "ntddser.h"
#include "bootvid.h"
#include "resource.h"
#include <hdlsblk.h>
#include <hdlsterm.h>
#pragma hdrstop

////////////////////////////////////////////////////////////////
//
// Global data
//
////////////////////////////////////////////////////////////////

//
// The primary upgrade graphics thread handle
//
HANDLE  GraphicsThreadHandle = NULL;

//
// Variable which indicates that upgrade graphics
// thread needs to be stopped or not
//
BOOLEAN     StopGraphicsThread = FALSE;
KSPIN_LOCK  GraphicsThreadLock;

//
// Upgrade graphics overall progress indication
//
ULONG       ProgressPercentage = 0;
KSPIN_LOCK  ProgressLock;

//
// For synchronizing access to VGA memory
//
BOOLEAN     InVgaDisplay = FALSE;
KSPIN_LOCK  VgaDisplayLock;


////////////////////////////////////////////////////////////////
//
// Atomic operations to stop main graphics thread
//
////////////////////////////////////////////////////////////////

static
__inline
BOOLEAN
UpgradeGraphicsThreadGetStop(
    VOID
    )
/*++

Routine Description:

    Finds out whether the primary upgrade graphics thread
    needs to be stopped

Arguments:

    None.

Return Value:

    TRUE or FALSE

--*/
{
    KIRQL   OldIrql;
    BOOLEAN Result;

    KeAcquireSpinLock(&GraphicsThreadLock, &OldIrql);

    Result = StopGraphicsThread;

    KeReleaseSpinLock(&GraphicsThreadLock, OldIrql);

    return Result;
}

static
VOID
__inline
UpgradeGraphicsThreadSetStop(
    BOOLEAN Stop
    )
/*++

Routine Description:

    Sets the global synchronized state, indicating
    whether to stop the primary graphics thread.

    Note : Once the thread is stopped, it can be
    restarted.

Arguments:

    Stop : Indicates whether to stop the primary graphics
           thread or not i.e. TRUE or FALSE

Return Value:

    None.

--*/
{
    KIRQL   OldIrql;

    KeAcquireSpinLock(&GraphicsThreadLock, &OldIrql);

    StopGraphicsThread = Stop;

    KeReleaseSpinLock(&GraphicsThreadLock, OldIrql);
}


////////////////////////////////////////////////////////////////
//
// Atomic progress bar percentage routines
//
////////////////////////////////////////////////////////////////

static
__inline
ULONG
GetSetupProgress(
    VOID
    )
/*++

Routine Description:

    Gets the overall progress, in terms of percentage,
    for the textmode setup. Since multiple threads
    are touching the shared overall progress ULONG
    its protected.

Arguments:

    None.

Return Value:

    The overall progress

--*/
{
    ULONG   PercentageFill;
    KIRQL   OldIrql;

    KeAcquireSpinLock(&ProgressLock, &OldIrql);

    PercentageFill = ProgressPercentage;

    KeReleaseSpinLock(&ProgressLock, OldIrql);

    return PercentageFill;
}

static
__inline
VOID
SetSetupProgress(
    ULONG   Fill
    )
/*++

Routine Description:

    Sets the overall progress, in terms of percentage
    for the textmode setup. Since multiple threads
    are touching the shared overall progress ULONG
    its protected.

Arguments:

    Fill : The new percentage to set.

Return Value:

    None.

--*/
{
    KIRQL   OldIrql;

    KeAcquireSpinLock(&ProgressLock, &OldIrql);

    ProgressPercentage = Fill;

    KeReleaseSpinLock(&ProgressLock, OldIrql);
}

////////////////////////////////////////////////////////////////
//
// Graphics progress bar methods
//
////////////////////////////////////////////////////////////////

TM_GRAPHICS_PRGBAR_HANDLE
TextmodeGraphicsProgBarCreate(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG Length,
    IN ULONG Height,
    IN ULONG ForegroundColor,
    IN ULONG BackgroundColor,
    IN ULONG InitialFill
    )
/*++

Routine Description:

    Creates a graphics progress bar object, with the
    specified attributes.

    Note : This graphics progress bar will use solid
    fill using the current palette, while updating
    progress i.e. drawing background and foreground.

Arguments:

    X - Top left X coordinate

    Y - Top left Y coordinate

    Length - Length of the progress bar in pixels

    Heigth - Height of the progress bar in pixels

    ForegroundColor - Index in palette, indicating
                      foreground color

    BackgroundColor - Index in palette, indicating
                      background color

    IntialFill - Initial percentage that needs to
                 be filled

Return Value:

    Handle to the graphics progress bar object,
    if successful otherwise NULL

--*/
{
    TM_GRAPHICS_PRGBAR_HANDLE hPrgBar = NULL;

    if (Length > Height) {
        hPrgBar = (TM_GRAPHICS_PRGBAR_HANDLE)
                    SpMemAlloc(sizeof(TM_GRAPHICS_PRGBAR));

        if (hPrgBar) {
            RtlZeroMemory(hPrgBar, sizeof(TM_GRAPHICS_PRGBAR));

            hPrgBar->X = X;
            hPrgBar->Y = Y;
            hPrgBar->Length = Length;
            hPrgBar->Height = Height;
            hPrgBar->Fill = InitialFill;
            hPrgBar->ForegroundColor = ForegroundColor;
            hPrgBar->BackgroundColor = BackgroundColor;
        }
    }

    return hPrgBar;
}

TM_GRAPHICS_PRGBAR_HANDLE
TextmodeGraphicsProgBarCreateUsingBmps(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG Length,
    IN ULONG Height,
    IN ULONG BackgroundId,
    IN ULONG ForegroundId,
    IN ULONG InitialFill
    )
/*++

Routine Description:

    Creates a graphics progress bar object, with the
    specified attributes.

    Note : This graphics progress bar will use the
    given bitmaps to update the background and foreground.
    Both background and foreground bitmap are assumed
    to be 1 pixel wide. Background bitmap's height is
    assumed to be "Height" pixels where as foreground
    bitmap's height is assumed be to "Height - 2" pixels.

Arguments:

    X - Top left X coordinate

    Y - Top left Y coordinate

    Length - Length of the progress bar in pixels

    Heigth - Height of the bakground bitmap, in pixels

    BackgroundId - Background bitmap resource ID

    ForegroundId - Foreground bitmap resource ID

    IntialFill - Initial percentage that needs to
                 be filled

    Note : Its assumed that the foreground and background
    bitmaps are in 4bpp i.e. 16 colors format.

Return Value:

    Handle to the graphics progress bar object,
    if successful otherwise NULL

--*/
{
    TM_GRAPHICS_PRGBAR_HANDLE  hPrgBar = NULL;
    TM_BITMAP_HANDLE            hBackground = TextmodeBitmapCreate(BackgroundId);
    TM_BITMAP_HANDLE            hForeground = TextmodeBitmapCreate(ForegroundId);

    if (!hBackground && hForeground) {
        TextmodeBitmapDelete(hForeground);
    }

    if (!hForeground&& hBackground) {
        TextmodeBitmapDelete(hBackground);
    }

    if (hForeground && hBackground) {
        hPrgBar = TextmodeGraphicsProgBarCreate(X,
                        Y,
                        Length,
                        Height,
                        0,
                        0,
                        InitialFill);

        if (hPrgBar) {
            hPrgBar->Background = hBackground;
            hPrgBar->Foreground = hForeground;
        } else {
            TextmodeBitmapDelete(hForeground);
            TextmodeBitmapDelete(hBackground);
        }
    }

    return hPrgBar;
}


NTSTATUS
TextmodeGraphicsProgBarDelete(
    IN TM_GRAPHICS_PRGBAR_HANDLE hPrgBar
    )
/*++

Routine Description:

    Deletes the graphics progress bar object. Frees
    up an any allocated resources.

Arguments:

    hPrgBar - Handle to the graphics progress bar object

Return Value:

    STATUS_SUCCESS, if successful otherwise appropriate
    error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (hPrgBar) {
        SpMemFree(hPrgBar);
        Status = STATUS_SUCCESS;
    }

    return Status;
}

NTSTATUS
TextmodeGraphicsProgBarRefresh(
    IN TM_GRAPHICS_PRGBAR_HANDLE hPrgBar,
    IN BOOLEAN UpdateBackground
    )
/*++

Routine Description:

    Repaints the graphics progress bar

Arguments:

    hPrgBar - Handle to the graphics progress bar object

    UpgradeBackground - Indicates whether the background
                        also needs to be repainted or not.

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (hPrgBar) {
        ULONG   FillLength = hPrgBar->Fill * (hPrgBar->Length - 2) / 100;

        if (hPrgBar->Background && hPrgBar->Foreground) {
            //
            // Bitmapped progress bar
            //
            ULONG Index;

            if (UpdateBackground) {
                for (Index=0; Index < hPrgBar->Length; Index++) {
                    TextmodeBitmapDisplay(hPrgBar->Background,
                        hPrgBar->X + Index,
                        hPrgBar->Y);
                }
            }

            if (FillLength) {
                ULONG   Count = FillLength;

                for (Index=1; Index <= Count; Index++) {
                    TextmodeBitmapDisplay(hPrgBar->Foreground,
                        hPrgBar->X + Index,
                        hPrgBar->Y + 1);
                }
            }
        } else {
            //
            // Solid fill progress bar
            //
            if (UpdateBackground) {
                VgaGraphicsSolidColorFill(hPrgBar->X, hPrgBar->Y,
                    hPrgBar->X + hPrgBar->Length, hPrgBar->Y + hPrgBar->Height,
                    hPrgBar->BackgroundColor);
            }

            if (FillLength)  {
                VgaGraphicsSolidColorFill(hPrgBar->X + 1, hPrgBar->Y + 1,
                    hPrgBar->X + FillLength, hPrgBar->Y + hPrgBar->Height - 1,
                    hPrgBar->ForegroundColor);
            }
        }

        Status = STATUS_SUCCESS;
    }

    return Status;
}

NTSTATUS
TextmodeGraphicsProgBarUpdate(
    IN TM_GRAPHICS_PRGBAR_HANDLE hPrgBar,
    IN ULONG Fill
    )
/*++

Routine Description:

    Updates the progress bar fill percentage, and repaints
    if needed.

    Note : The percentage can be increasing or decreasing
    w.r.t to previous fill percentage

Arguments:

    hPrgBar - Handle to the graphics progress bar object

    Fill - The new fill percentage.

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (Fill > 100) {
        Fill = 100;
    }

    if (hPrgBar && (hPrgBar->Fill != Fill)) {
        //
        // Note : Make sure we leave one pixel at the start and end
        // in the background to emulate a bounding rectangle
        // around the current fill
        //
        ULONG OldFillLength = hPrgBar->Fill * (hPrgBar->Length - 2) / 100;
        ULONG NewFillLength = Fill * (hPrgBar->Length - 2) / 100;
        ULONG Index;

        if (OldFillLength != NewFillLength) {
            if (OldFillLength < NewFillLength) {
                //
                // increasing
                //
                if (hPrgBar->Foreground && hPrgBar->Background) {
                    for (Index = OldFillLength; Index < NewFillLength; Index++) {
                        TextmodeBitmapDisplay(hPrgBar->Foreground,
                            hPrgBar->X + Index + 1,
                            hPrgBar->Y + 1);
                    }
                } else {
                    VgaGraphicsSolidColorFill(hPrgBar->X + OldFillLength + 1, hPrgBar->Y + 1,
                        hPrgBar->X + NewFillLength, hPrgBar->Y + hPrgBar->Height - 1,
                        hPrgBar->ForegroundColor);
                }
            } else {
                //
                // decreasing
                //
                if (hPrgBar->Foreground && hPrgBar->Background) {
                    for (Index = NewFillLength; Index <= OldFillLength; Index++) {
                        TextmodeBitmapDisplay(hPrgBar->Background,
                            hPrgBar->X + Index,
                            hPrgBar->Y);
                    }
                } else {
                    VgaGraphicsSolidColorFill(hPrgBar->X + NewFillLength, hPrgBar->Y + 1,
                        hPrgBar->X + OldFillLength, hPrgBar->Y + hPrgBar->Height - 1,
                        hPrgBar->BackgroundColor);
                }
            }

            hPrgBar->Fill = Fill;
        }

        Status = STATUS_SUCCESS;
    }

    return Status;
}

////////////////////////////////////////////////////////////////
//
// Bitmap methods
//
////////////////////////////////////////////////////////////////

TM_BITMAP_HANDLE
TextmodeBitmapCreate(
    IN ULONG BitmapResourceId
    )
/*++

Routine Description:

    Creates a bitmap object using the given resource Id.

    Note : The resource is currently assumed to be present
    in usetup.exe module. The bitmap is assumed to be in
    4bpp or 16 colors format.

Arguments:

    BitmapResourceId - the bitmap resource Id.

Return Value:

    Handle to the new bitmap object, if successful,
    otherwise NULL

--*/
{
    TM_BITMAP_HANDLE    hBitmap = NULL;
    ULONG_PTR           ResourceIdPath[3];
    PUCHAR              Bitmap = NULL;
    NTSTATUS            Status;
    PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry = NULL;

    if (BitmapResourceId) {
        ResourceIdPath[0] = 2;
        ResourceIdPath[1] = BitmapResourceId;
        ResourceIdPath[2] = 0;

        Status = LdrFindResource_U(ResourceImageBase,
                        ResourceIdPath,
                        3,
                        &ResourceDataEntry);

        if (NT_SUCCESS(Status)) {
            Status = LdrAccessResource(ResourceImageBase,
                            ResourceDataEntry,
                            &Bitmap,
                            NULL);

            if (NT_SUCCESS(Status)) {
                hBitmap = (TM_BITMAP_HANDLE)SpMemAlloc(sizeof(TM_BITMAP));

                if (hBitmap) {
                    RtlZeroMemory(hBitmap, sizeof(TM_BITMAP));

                    //
                    // All we have and need is actual bitmap data
                    //
                    hBitmap->Data = (PVOID)Bitmap;
                }
            }
        }
    }

    return hBitmap;
}

TM_BITMAP_HANDLE
TextmodeBitmapCreateFromFile(
    IN PWSTR FileName
    )
/*++

Routine Description:

    Creates a bitmap object using the given fully qualified
    NT pathname for the bitmap file.

    Note : The bitmap is assumed to be in 4bpp or 16 color
    format

Arguments:

    FileName - Fully qualified NT pathname for
               the bitmap file

Return Value:

    Handle to the new bitmap object if successful,
    otherwise NULL.

--*/
{
    TM_BITMAP_HANDLE    hBitmap = NULL;
    HANDLE              FileHandle = NULL, SectionHandle = NULL;
    PVOID               ViewBase = NULL;
    ULONG               FileSize = 0;

    if (FileName && *FileName &&
        NT_SUCCESS(SpOpenAndMapFile(FileName,
                                    &FileHandle,
                                    &SectionHandle,
                                    &ViewBase,
                                    &FileSize,
                                    FALSE))) {

        hBitmap = (TM_BITMAP_HANDLE)SpMemAlloc(sizeof(TM_BITMAP));

        if (hBitmap) {
            RtlZeroMemory(hBitmap, sizeof(TM_BITMAP));
            wcscpy(hBitmap->FileName, FileName);
            hBitmap->ViewBase = ViewBase;
            hBitmap->Data = ((PCHAR)ViewBase) + sizeof(BITMAPFILEHEADER);
            hBitmap->FileHandle = FileHandle;
            hBitmap->SectionHandle = SectionHandle;
        }
    }

    return hBitmap;
}

NTSTATUS
TextmodeBitmapDelete(
    IN TM_BITMAP_HANDLE hBitmap
    )
/*++

Routine Description:

    Delete the bitmap object and frees up any allocated
    resources.

Arguments:

    hBitmap - Handle to the bitmap object

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (hBitmap) {
        if (hBitmap->SectionHandle != NULL) {
            SpUnmapFile(hBitmap->SectionHandle, hBitmap->ViewBase);
        }

        if (hBitmap->FileHandle != NULL) {
            Status = ZwClose(hBitmap->FileHandle);
        } else {
            Status = STATUS_SUCCESS;
        }

        SpMemFree(hBitmap);
    }

    return Status;
}

NTSTATUS
TextmodeBitmapDisplay(
    IN TM_BITMAP_HANDLE hBitmap,
    IN ULONG X,
    IN ULONG Y
    )
/*++

Routine Description:

    Displays the given bitmap at the specified
    coordinates.

Arguments:

    hBitmap - Handle to the bitmap object

    X - Top left X coordinate

    Y - Top left Y coordinate

Return Value:

    STATUS_SUCCESS, if successful, otherwise
    appropriate error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;


    if (hBitmap) {
        VgaGraphicsBitBlt(hBitmap->Data, X, Y);
        Status = STATUS_SUCCESS;
    }

    return Status;
}

////////////////////////////////////////////////////////////////
//
// Animated bitmap methods
//
////////////////////////////////////////////////////////////////

__inline
NTSTATUS
TextmodeAnimatedBitmapSetStopAnimating(
    IN TM_ANIMATED_BITMAP_HANDLE hBitmap,
    IN BOOLEAN StopAnimating
    )
/*++

Routine Description:

    Sets the (shared) attribute which indicates
    whether the animation for the animated bitmap
    needs to be stopped or not.

Arguments:

    hBitmap - Handle to the animated bitmap object

    StopAnimating - Whether to stop the animation or not

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (hBitmap) {
        InterlockedExchange(&(hBitmap->StopAnimating), (LONG)StopAnimating);
        Status = STATUS_SUCCESS;
    }

    return Status;
}


__inline
NTSTATUS
TextmodeAnimatedBitmapGetStopAnimating(
    IN TM_ANIMATED_BITMAP_HANDLE hBitmap,
    IN PBOOLEAN StopAnimating
    )
/*++

Routine Description:

    Gets the (shared) attribute which indicates whether the
    animated bitmap is currently being animated or not.

Arguments:

    hBitmap - Handle to the animated bitmap object

    StopAnimating - Place holder for boolean value indicating
                    whether animation is in progress or not.

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (hBitmap && StopAnimating) {
        *StopAnimating = (BOOLEAN)InterlockedExchange(&(hBitmap->StopAnimating),
                                    hBitmap->StopAnimating);
        Status = STATUS_SUCCESS;                                    
    }

    return Status;
}


TM_ANIMATED_BITMAP_HANDLE
TextmodeAnimatedBitmapCreate(
    IN ULONG  *ResourceIds
    )
/*++

Routine Description:

    Creates a animated bitmap, given the list of resource
    ids each bitmaps, in sequence.

    Note : The bitmap format needs to adhere to 4bpp or
           16 colors. The resource is assumed to be
           present in usetup.exe

Arguments:

    ResourceIds - Array of resource ids for the bitmaps
                  to be animated, in sequence. A "0" id
                  indicates the termination for array.

Return Value:

    Handle to the newly created animated bitmap object, if
    successful, otherwise NULL.

--*/
{
    TM_ANIMATED_BITMAP_HANDLE   hAnimatedBitmap = NULL;
    ULONG   Count = 0;
    ULONG   Index;

    if (ResourceIds) {
        for (Index = 0; ResourceIds[Index]; Index++) {
            Count++;
        }
    }

    if (Count) {
        ULONG               BitmapsLoaded = 0;
        TM_BITMAP_HANDLE    hBitmap;

        hAnimatedBitmap = (TM_ANIMATED_BITMAP_HANDLE)
                            SpMemAlloc(sizeof(TM_ANIMATED_BITMAP));

        if (hAnimatedBitmap) {
            RtlZeroMemory(hAnimatedBitmap, sizeof(TM_ANIMATED_BITMAP));

            hAnimatedBitmap->StopAnimating = FALSE;

            for (Index = 0; Index < Count; Index++) {
                hBitmap = TextmodeBitmapCreate(ResourceIds[Index]);

                if (hBitmap) {
                    hAnimatedBitmap->Bitmaps[BitmapsLoaded++] = hBitmap;
                }
            }

            if (!BitmapsLoaded) {
                SpMemFree(hAnimatedBitmap);
                hAnimatedBitmap = NULL;
            } else {
                hAnimatedBitmap->CurrentBitmap = 0; // the first bitmap
            }
        }
    }

    return hAnimatedBitmap;
}


TM_ANIMATED_BITMAP_HANDLE
TextmodeAnimatedBitmapCreateFromFiles(
    IN WCHAR    *FileNames[]
    )
/*++

Routine Description:

    Creates a animated bitmap, given the list of bitmap
    filenames, in sequence.

    Note : The bitmap format needs to adhere to 4bpp or
           16 colors.

Arguments:

    FileNames - Null terminated array of filenames for
                the bitmaps to be animated, in sequence.

Return Value:

    Handle to the newly created animated bitmap object, if
    successful, otherwise NULL.

--*/
{
    TM_ANIMATED_BITMAP_HANDLE   hAnimatedBitmap = NULL;
    ULONG   FileCount = 0;
    ULONG   Index;

    if (FileNames) {
        for (Index = 0; FileNames[Index]; Index++) {
            FileCount++;
        }
    }

    if (FileCount) {
        ULONG               BitmapsLoaded = 0;
        TM_BITMAP_HANDLE    hBitmap;

        hAnimatedBitmap = (TM_ANIMATED_BITMAP_HANDLE)
                            SpMemAlloc(sizeof(TM_ANIMATED_BITMAP));

        if (hAnimatedBitmap) {
            RtlZeroMemory(hAnimatedBitmap, sizeof(TM_ANIMATED_BITMAP));
            hAnimatedBitmap->StopAnimating = FALSE;

            for (Index = 0; Index < FileCount; Index++) {
                hBitmap = TextmodeBitmapCreateFromFile(FileNames[Index]);

                if (hBitmap) {
                    hAnimatedBitmap->Bitmaps[BitmapsLoaded++] = hBitmap;
                }
            }

            if (!BitmapsLoaded) {
                SpMemFree(hAnimatedBitmap);
                hAnimatedBitmap = NULL;
            } else {
                hAnimatedBitmap->CurrentBitmap = 0; // the first bitmap
            }
        }
    }

    return hAnimatedBitmap;
}


NTSTATUS
TextmodeAnimatedBitmapDelete(
    IN TM_ANIMATED_BITMAP_HANDLE hAnimatedBitmap
    )
/*++

Routine Description:

    Delete the given animated bitmap object and frees
    up an resource associated with the object.

    Note : This will stop the animation thread, if
    required.

Arguments:

    hAnimatedBitmap - Handle to the animated bitmap object

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (hAnimatedBitmap) {
        ULONG   Index;

        //
        // First, try to terminate the thread
        //
        TextmodeAnimatedBitmapSetStopAnimating(hAnimatedBitmap, TRUE);

        //
        // Wait, till the animator thread stops
        //
        Status = ZwWaitForSingleObject(hAnimatedBitmap->ThreadHandle, FALSE, NULL);

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP: DeleteTextmodeAnimatedBitmap() : Wait filed for %lX with %lX\n",
                hAnimatedBitmap->ThreadHandle,
                Status));
        }

        Status = STATUS_SUCCESS;

        if (hAnimatedBitmap->ThreadHandle){
            ZwClose(hAnimatedBitmap->ThreadHandle);
        }
        //
        // Delete each bitmap
        //
        for (Index=0;
            ((Index < MAX_ANIMATED_BITMAPS) && hAnimatedBitmap->Bitmaps[Index]);
            Index++) {

            if (NT_SUCCESS(Status)) {
                Status = TextmodeBitmapDelete(hAnimatedBitmap->Bitmaps[Index]);
            }
        }

        //
        // Free the animated bitmap
        //
        SpMemFree(hAnimatedBitmap);
    }

    return Status;
}

NTSTATUS
TextmodeAnimateBitmapAnimateNext(
    IN TM_ANIMATED_BITMAP_HANDLE hBitmap
    )
/*++

Routine Description:

    Animates rather draws the next bitmap in the sequence.

Arguments:

    hBitmap - Handle to the animated bitmap object

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code.

--*/
{
    TM_BITMAP_HANDLE hCurrBitmap;
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (hBitmap) {
        hCurrBitmap = hBitmap->Bitmaps[hBitmap->CurrentBitmap];
        Status = TextmodeBitmapDisplay( hCurrBitmap, hBitmap->X, hBitmap->Y);

        hBitmap->CurrentBitmap++;

        if ((hBitmap->CurrentBitmap >= MAX_ANIMATED_BITMAPS) ||
            (hBitmap->Bitmaps[hBitmap->CurrentBitmap] == NULL)) {
            hBitmap->CurrentBitmap = 0; // start over again
        }
    }

    return Status;
}

NTSTATUS
TextmodeAnimatedBitmapAnimate(
    IN TM_ANIMATED_BITMAP_HANDLE hBitmap,
    IN ULONG X,
    IN ULONG Y,
    IN ULONG Speed
    )
/*++

Routine Description:

    Starts the animation for the given animated bitmap by
    drawing the bitmaps in sequence at the specified
    coordinates.

    Note : This call would create a separate system
    thread for actually animating the bitmap and would return
    immediately.

Arguments:

    hBitmap - Handle to the animated bitmap object

    X - Top left X coordinate for the animation space

    Y - Top left Y coordinate for the animation space

    Speed - Time interval between changing of bitmaps
            in animation sequence, in milliseconds.

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (hBitmap) {
        hBitmap->FlipTime = Speed;
        hBitmap->X = X;
        hBitmap->Y = Y;

        Status = PsCreateSystemThread(&(hBitmap->ThreadHandle),
                    THREAD_ALL_ACCESS,
                    NULL,
                    NtCurrentProcess(),
                    NULL,
                    TextmodeAnimatedBitmapAnimator,
                    hBitmap);
    }

    return Status;
}

VOID
TextmodeAnimatedBitmapAnimator(
    IN PVOID Context
    )
/*++

Routine Description:

    The worker routine which runs as a separate thread doing
    the actual animation for a animated bitmap.

Arguments:

    Context - Handle to the animated bitmap object type cast
              into PVOID type.

Return Value:

    None.

--*/
{
    LARGE_INTEGER               DelayTime;
    TM_ANIMATED_BITMAP_HANDLE   hBitmap = (TM_ANIMATED_BITMAP_HANDLE)Context;
    TM_BITMAP_HANDLE            hCurrBitmap = NULL;

    if (Context) {
        BOOLEAN     StopAnimating = FALSE;
        NTSTATUS    Status;

        DelayTime.HighPart = -1;                 // relative time
        DelayTime.LowPart = (ULONG)(-10000 * hBitmap->FlipTime);  // secs in 100ns interval

        Status = TextmodeAnimatedBitmapGetStopAnimating(hBitmap, &StopAnimating);

        while (NT_SUCCESS(Status) && !StopAnimating) {
            hCurrBitmap = hBitmap->Bitmaps[hBitmap->CurrentBitmap];
            TextmodeBitmapDisplay(hCurrBitmap, hBitmap->X, hBitmap->Y);
            KeDelayExecutionThread(KernelMode, FALSE, &DelayTime);

            hBitmap->CurrentBitmap++;

            if ((hBitmap->CurrentBitmap >= MAX_ANIMATED_BITMAPS) ||
                (hBitmap->Bitmaps[hBitmap->CurrentBitmap] == NULL)) {
                hBitmap->CurrentBitmap = 0; // start over again
            }

            Status = TextmodeAnimatedBitmapGetStopAnimating(hBitmap, &StopAnimating);
        }
    }

    PsTerminateSystemThread(STATUS_SUCCESS);
}

////////////////////////////////////////////////////////////////
//
//    VGA graphics methods
//
//    Note : VgaXXXX rountines are defined basically
//    to segregate the video memory update routines
//    from the other abstractions. Right now most of
//    these routine delegate the actual work to the
//    real implementation in bootvid.dll, but in
//    future if bootvid.dll goes away, all we need
//    to do is implement this interface.
//    Also note that, these routine synchronize the
//    access, so that only one thread at a time
//    updates the video memory.
//
////////////////////////////////////////////////////////////////

__inline
VOID
VgaDisplayAcquireLock(
    VOID
    )
/*++

Routine Description:

    Acquires the lock to the video memory, so that
    only one thread a time writes to the video memory.

    Note : If the lock is already held by another thread,
    then the calling thread is put to sleep. The calling
    thread wakes up after every 100 millisecond and
    checks for the lock. It falls out of sleep based on
    whether the lock is already held or not.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL   OldIrql;

    KeAcquireSpinLock(&VgaDisplayLock, &OldIrql);

    while (InVgaDisplay) {
        LARGE_INTEGER   DelayTime;

        DelayTime.HighPart = -1;                 // relative time
        DelayTime.LowPart = (ULONG)(-10000 * 100);  // 100ms interval

        KeReleaseSpinLock(&VgaDisplayLock, OldIrql);
        KeDelayExecutionThread(KernelMode, FALSE, &DelayTime);
        KeAcquireSpinLock(&VgaDisplayLock, &OldIrql);
    }

    InVgaDisplay = TRUE;

    KeReleaseSpinLock(&VgaDisplayLock, OldIrql);
}

__inline
VOID
VgaDisplayReleaseLock(
    VOID
    )
/*++

Routine Description:

    Release the video memory lock which was held.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL   OldIrql;

    KeAcquireSpinLock(&VgaDisplayLock, &OldIrql);

    InVgaDisplay = FALSE;

    KeReleaseSpinLock(&VgaDisplayLock, OldIrql);
}

NTSTATUS
VgaGraphicsInit(
    PSP_VIDEO_VARS VideoVars
    )
/*++

Routine Description:

    Initializes the video card and switches it into
    640 * 480 * 16 colors mode.


Arguments:

    VideoVars - Pointer to SP_VIDEO_VARS containing
                graphics mode index and handle to the
                display.

Return Value:

    Appropriate NTSTATUS value.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    
    VgaDisplayAcquireLock();
    
    //
    // Set the desired graphics mode.
    //
    VideoMode.RequestedMode = VideoVars->GraphicsModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(VideoVars->hDisplay,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_VIDEO_SET_CURRENT_MODE,
                    &VideoMode,
                    sizeof(VideoMode),
                    NULL,
                    0);

    if(NT_SUCCESS(Status)) {    
        VidInitialize(FALSE);
        VidResetDisplay(FALSE);
    }        

    VgaDisplayReleaseLock();

    return Status;
}

NTSTATUS
VgaGraphicsTerminate(
    PSP_VIDEO_VARS VideoVars
    )
/*++

Routine Description:

    Terminates the 640 * 480 * 16 color mode & switches
    it back to regular text mode. Also clears the display.

Arguments:

    VideoVars - Pointer to SP_VIDEO_VARS containing
                text mode index and handle to the
                display.

Return Value:

    Appropriate NTSTATUS value.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    
    VgaDisplayAcquireLock();

    VidResetDisplay(FALSE);

    //
    // Switch the adapter to textmode again.
    //
    VideoMode.RequestedMode = VideoVars->VideoModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(VideoVars->hDisplay,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_VIDEO_SET_CURRENT_MODE,
                    &VideoMode,
                    sizeof(VideoMode),
                    NULL,
                    0);
   
    VgaDisplayReleaseLock();

    return Status;
}

__inline
VOID
VgaGraphicsSolidColorFill(
    IN ULONG x1,
    IN ULONG y1,
    IN ULONG x2,
    IN ULONG y2,
    IN ULONG Color
    )
/*++

Routine Description:

    Fills the given rectangle with the specified
    color.

Arguments:

    x1 - Top left x coordinate

    y1 - Top left y coordinate

    x2 - Bottom right x coordinate

    y2 - Bottom right y coordinate

    Color - Index into the current palette table
            indicating the color to be filled inside
            the rectangle.

Return Value:

    None.

--*/
{
    VgaDisplayAcquireLock();

    VidSolidColorFill(x1, y1, x2, y2, Color);

    VgaDisplayReleaseLock();
}

__inline
VOID
VgaGraphicsBitBlt(
    IN PUCHAR Buffer,
    IN ULONG x,
    IN ULONG y
    )
/*++

Routine Description:

    BitBlts the given bitmap at the specified
    coordinates.

Arguments:

    Buffer - The actual bitmap date (i.e. starting
             with the color table information)

    x - Top left x coordinate
    y - Top left y coordinate

Return Value:

    None.

--*/
{
    VgaDisplayAcquireLock();

    VidBitBlt(Buffer, x, y);

    VgaDisplayReleaseLock();
}


////////////////////////////////////////////////////////////////
//
// Upgrade graphics routines
//
////////////////////////////////////////////////////////////////

__inline
BOOLEAN
QuitGraphicsThread(
    VOID
    )
/*++

Routine Description:

    Indiates whether the primary upgrade graphics thread
    needs to be stopped or not based on user input
    (ESC key).

    Note : This feature is only enable in pre-release
           builds.

Arguments:

    None.

Return Value:

    TRUE if the upgrade graphics thread needs to be stopped
    else FALSE.

--*/
{
    BOOLEAN Result = FALSE;

/*
#ifdef PRERELEASE
    Result = SpInputIsKeyWaiting() && (SpInputGetKeypress() == ASCI_ESC);
#endif
*/

    return Result;
}

NTSTATUS
UpgradeGraphicsInit(
    VOID
    )
/*++

Routine Description:

    Does the needed global initialization for the
    upgrade graphics mode.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS, if successful with initialzation,
    otherwise appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Initialize global spin locks
    //
    KeInitializeSpinLock(&VgaDisplayLock);
    KeInitializeSpinLock(&ProgressLock);
    KeInitializeSpinLock(&GraphicsThreadLock);

    return Status;
}

NTSTATUS
UpgradeGraphicsStart(
    VOID
    )
/*++

Routine Description:

    Starts of the upgrade graphics

Arguments:

    None.

Return Value:

    STATUS_SUCCESS, if the upgrade graphics was started,
    else appropriate error code.

--*/
{
    NTSTATUS Status;

    Status = PsCreateSystemThread(&GraphicsThreadHandle,
                        THREAD_ALL_ACCESS,
                        NULL,
                        NtCurrentProcess(),
                        NULL,
                        UpgradeGraphicsThread,
                        NULL);



#ifdef _GRAPHICS_TESTING_

    Status = ZwWaitForSingleObject(GraphicsThreadHandle, FALSE, NULL);

#endif

    return Status;
}

VOID
UpgradeGraphicsThread(
    IN PVOID Context
    )
/*++

Routine Description:

    The primary upgrade graphics worker thread, which
    paints the background, updates the progress bar
    and starts the animation.

Arguments:

    Context - Ignored

Return Value:

    None.

--*/
{
    BOOLEAN                     Stop = FALSE;
    TM_GRAPHICS_PRGBAR_HANDLE   hProgBar;
    TM_ANIMATED_BITMAP_HANDLE   hAnimation = NULL;
    TM_BITMAP_HANDLE            hBitmap = NULL;
    LARGE_INTEGER               DelayTime;
    NTSTATUS                    Status;
    WCHAR                       Buffer[MAX_PATH];
    ULONG                       BitmapIds[] = {
                                    IDB_WORKING1, IDB_WORKING2,
                                    IDB_WORKING3, IDB_WORKING4,
                                    IDB_WORKING5, IDB_WORKING6,
                                    IDB_WORKING7, IDB_WORKING8,
                                    IDB_WORKING9, IDB_WORKING10,
                                    IDB_WORKING11, IDB_WORKING12,
                                    IDB_WORKING13, IDB_WORKING14,
                                    IDB_WORKING15, IDB_WORKING16,
                                    IDB_WORKING17, IDB_WORKING18,
                                    IDB_WORKING19, IDB_WORKING20,
                                    0 };

    ULONG                       SrvBitmapIds[] = {
                                    IDB_SRV_WORKING1, IDB_SRV_WORKING2,
                                    IDB_SRV_WORKING3, IDB_SRV_WORKING4,
                                    IDB_SRV_WORKING5, IDB_SRV_WORKING6,
                                    IDB_SRV_WORKING7, IDB_SRV_WORKING8,
                                    IDB_SRV_WORKING9, IDB_SRV_WORKING10,
                                    IDB_SRV_WORKING11, IDB_SRV_WORKING12,
                                    IDB_SRV_WORKING13, IDB_SRV_WORKING14,
                                    IDB_SRV_WORKING15, IDB_SRV_WORKING16,
                                    IDB_SRV_WORKING17, IDB_SRV_WORKING18,
                                    IDB_SRV_WORKING19, IDB_SRV_WORKING20,
                                    0 };
    //
    // Initialize graphics mode
    //
    Status = VgaGraphicsInit(&VideoVars);

    if (NT_SUCCESS(Status)) {
        //
        // Create the background bitmap
        //
        if (Win9xRollback) {
            hBitmap = TextmodeBitmapCreate(IDB_RESTORE_BK);
        } else {
            if (!AdvancedServer)
            {
                hBitmap = TextmodeBitmapCreate(IDB_BACKGROUND1);
            }
            else
            {
                hBitmap = TextmodeBitmapCreate(IDB_BACKGROUND2);
            }
        }

        if (hBitmap) {
            //
            // Create the animated bitmap
            //
            if (!AdvancedServer)
            {
                hAnimation = TextmodeAnimatedBitmapCreate(BitmapIds);
            }
            else
            {
                hAnimation = TextmodeAnimatedBitmapCreate(SrvBitmapIds);
            }


            if (hAnimation) {
                //
                // Create the bitmapped graphics progress bar
                //
                hProgBar = TextmodeGraphicsProgBarCreateUsingBmps(28, 352,
                                123, 14,
                                IDB_BACKCELL, IDB_FORECELL, 0);

                if (hProgBar) {
                    BOOLEAN Refreshed = FALSE;
                    ULONG   Fill = 0;
                    BOOLEAN Increase = TRUE;

                    //
                    // Render background
                    //
                    TextmodeBitmapDisplay(hBitmap, 0, 0);

                    //
                    // Start the animation
                    //
                    Status = TextmodeAnimatedBitmapAnimate(hAnimation, 542, 460, 100);

                    //
                    // Note : Failure to start the animation is not a critical
                    // error
                    //
                    if (!NT_SUCCESS(Status)) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                            "SETUP:Upgrade graphics thread failed to "
                            "animate : %lx error code\r\n",
                            Status));
                    }

                    DelayTime.HighPart = -1;                 // relative time
                    DelayTime.LowPart = (ULONG)(-10000 * 500);  // 1000 msec interval

                    //
                    // Render graphics progress bar
                    //
                    TextmodeGraphicsProgBarRefresh(hProgBar, TRUE);

                    Fill = GetSetupProgress();
                    Stop = UpgradeGraphicsThreadGetStop();

                    //
                    // Continue on till user asks us to stop, or the main
                    // textmode thread encounters an error and stops us
                    //
                    while (!Stop && !QuitGraphicsThread()) {
                        //
                        // Update the graphics progress bar
                        //
                        TextmodeGraphicsProgBarUpdate(hProgBar, Fill);

                        //
                        // Sleep for 0.5 secs
                        //
                        KeDelayExecutionThread(KernelMode, FALSE, &DelayTime);

                        Fill = GetSetupProgress();
                        Stop = UpgradeGraphicsThreadGetStop();

#ifdef _GRAPHICS_TESTING_

                        if (Increase) {
                            if (Fill < 100) {
                                Fill++;
                                SetSetupProgress(Fill);
                            } else {
                                Increase = FALSE;
                            }
                        }

                        if (!Increase) {
                            if (Fill <= 0) {
                                Increase = TRUE;
                            } else {
                                Fill--;
                                SetSetupProgress(Fill);
                            }
                        }

#endif _GRAPHICS_TESTING_

                    }

                    //
                    // Was graphics thread stopped by the main
                    // textmode setup, then most probably we
                    // encountered an error or user intervention
                    // is required
                    //
                    Stop = UpgradeGraphicsThreadGetStop();

                    //
                    // Delete the graphics progress bar
                    //
                    TextmodeGraphicsProgBarDelete(hProgBar);
                }

                //
                // Stop the animation, and delete the animated
                // bitmap object
                //
                TextmodeAnimatedBitmapDelete(hAnimation);
            }

            //
            // Delete the background bitmap object
            //
            TextmodeBitmapDelete(hBitmap);
        }
    }        

    //
    // If graphics thread was stopped by user intervention
    // then we need to switch to textmode
    //
    if (!Stop) {
        spvidSpecificReInitialize();
        SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
    }

    PsTerminateSystemThread(Status);
}

VOID
GraphicsModeProgressUpdate(
    IN TM_SETUP_MAJOR_EVENT MajorEvent,
    IN TM_SETUP_MINOR_EVENT MinorEvent,
    IN PVOID Context,
    IN PVOID EventData
    )
/*++

Routine Description:

    Callback which updates the over all progress during
    upgrade graphics mode.

    Note : The single progress bar in upgrade graphics mode
           is used in place of all the various different
           progress bars which are used through out the
           textmode.

           The single progress bar is divided into ranges
           as shown below for the various major events
           across the textmode setup:

           ------------------------------------------
               Range(%)        MajorEvent
           ------------------------------------------
                00-05        InitializationEvent

                05-20        PartitioningEvent
                              (Includes chkdsk)

                20-40        Backup (if enabled)
                20-40        Uninstall (if enabled)

                20/40-90     FileCopyEvent
                              (Actual file copying)

                90-98        SavingSettingsEvent

                98-100       SetupCompleted
           ------------------------------------------

Arguments:

    MajorEvent - Indicates the major type of the event
                 which happened.

    MinorEvent - Indicates the minor type of the event
                 which happened.

    Context - Context data which was registered when
              we register for callback.

    EventData - More detailed event specific data

Return Value:

    None.

--*/
{
    static BOOLEAN Add = TRUE;
    static ULONG LastPercentage = 0;
    static ULONG BackupAllocation = 0;
    BOOLEAN SkipSpew = FALSE;
    ULONG Delta = 0;
    ULONG PercentageFill = 0;

    PercentageFill = GetSetupProgress();

    switch (MajorEvent) {
        case InitializationEvent:
            switch (MinorEvent) {
                case InitializationStartEvent:
                    PercentageFill = 2;
                    break;

                case InitializationEndEvent:
                    PercentageFill = 5;
                    break;

                default:
                    break;
            }

            break;

        case PartitioningEvent:
            switch (MinorEvent) {
                case ValidatePartitionEvent:
                    Delta = (15 * (*(PULONG)EventData)) / 200;
                    PercentageFill = 5 + Delta;

                    break;

                case FormatPartitionEvent:
                    //
                    // In cases of upgrade (we won't be formatting)
                    //
                    break;

                default:
                    break;
            }

            break;

        case FileCopyEvent:
            switch (MinorEvent) {
                case FileCopyStartEvent:
                    LastPercentage = PercentageFill = 20 + BackupAllocation;
                    break;

                case OneFileCopyEvent:
                    Delta = ((70 - BackupAllocation) * (*(PULONG)EventData)) / 100;
                    PercentageFill = 20 + Delta + BackupAllocation;

                    if ((PercentageFill - LastPercentage) > 5) {
                        LastPercentage = PercentageFill;
                    } else {
                        SkipSpew = TRUE;
                    }

                    break;

                case FileCopyEndEvent:
                    PercentageFill = 90;

                    break;

                default:
                    break;
            }

            break;

        case BackupEvent:
            switch (MinorEvent) {
                case BackupStartEvent:
                    LastPercentage = PercentageFill = 20;
                    BackupAllocation = 20;
                    break;

                case OneFileBackedUpEvent:
                    Delta = (20 * (*(PULONG)EventData)) / 100;
                    PercentageFill = 20 + Delta;

                    if ((PercentageFill - LastPercentage) > 5) {
                        LastPercentage = PercentageFill;
                    } else {
                        SkipSpew = TRUE;
                    }

                    break;

                case BackupEndEvent:
                    PercentageFill = 40;
                    break;
            }

            break;

        case UninstallEvent:
            switch (MinorEvent) {
                case UninstallStartEvent:
                    LastPercentage = PercentageFill = 20;
                    break;

                case UninstallUpdateEvent:
                    Delta = (70 * (*(PULONG)EventData)) / 100;
                    PercentageFill = 20 + Delta;

                    if ((PercentageFill - LastPercentage) > 5) {
                        LastPercentage = PercentageFill;
                    } else {
                        SkipSpew = TRUE;
                    }

                    break;

                case UninstallEndEvent:
                    PercentageFill = 90;
                    break;

                default:
                    break;
            }

            break;

        case SavingSettingsEvent:
            switch (MinorEvent) {
                case SavingSettingsStartEvent:
                    PercentageFill = 90;
                    break;

                case SaveHiveEvent:
                    if (PercentageFill < 98) {
                        if (Add) {
                            PercentageFill += 1;
                            Add = FALSE;
                        } else {
                            Add = TRUE;
                        }
                    }

                    break;

                case SavingSettingsEndEvent:
                    if (PercentageFill < 98) {
                        PercentageFill = 98;
                    }

                    break;

                default:
                    break;
            }

            break;


        case SetupCompletedEvent:
            PercentageFill = 100;

            break;

        default:
            break;
    }

    if (!SkipSpew) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
            "Setup Event : %ld, %ld, %ld, [%ld], (%ld)\n",
            MajorEvent,
            MinorEvent,
            EventData ? *(PULONG)EventData : 0,
            Delta,
            PercentageFill
            ));
    }

    SetSetupProgress(PercentageFill);
}


NTSTATUS
SpvidSwitchToTextmode(
    VOID
    )
/*++

Routine Description:

    Switches from upgrade graphics mode to the regular
    textmode.

    Note : The actual work of switching the graphics
           back to the regular VGA textmode happens
           as a method in video specific reinitialize
           method.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropirate
    error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (SP_IS_UPGRADE_GRAPHICS_MODE()) {
        if (GraphicsThreadHandle){
            //
            // Stop the primary upgrade graphics thread
            //
            UpgradeGraphicsThreadSetStop(TRUE);

            //
            // Wait for the graphics thread to terminate
            //
            Status = ZwWaitForSingleObject(GraphicsThreadHandle, FALSE, NULL);

            ZwClose(GraphicsThreadHandle);
        }
        //
        // Switch back to textmode
        //
        spvidSpecificReInitialize();
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\graphics.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    graphics.h

Abstract:

    Bitmap display support with text mode for
    upgrade. This file has three core abstractions
    Bitmap, Animated bitmap and Graphics 
    Progress bar.

Author:

    Vijay Jayaseelan (vijayj)  01 July 2000    

Revision History:

    None

--*/

#ifndef _GRAPHICS_H_ 
#define _GRAPHICS_H_

#include "spprecmp.h"
#pragma hdrstop

#define MAX_ANIMATED_BITMAPS 256

//
// Bitmap abstraction
//
// A textmode bitmap can be created using a resource ID
// or a fully qualified bitmap file name.
//
// Note : Since currently we support only 640 * 480 * 16 (colors)
//        VGA mode, its necessary that all the bitmap
//        resources and files adhere to this format.
//
typedef struct _TM_BITMAP {
    PVOID   ViewBase;
    PVOID   Data;
    WCHAR   FileName[MAX_PATH];
    HANDLE  FileHandle;
    HANDLE  SectionHandle;
} TM_BITMAP, *PTM_BITMAP, *TM_BITMAP_HANDLE;


//
// Bitmap methods
//
TM_BITMAP_HANDLE
TextmodeBitmapCreate(
    IN ULONG ResourceId
    );

TM_BITMAP_HANDLE
TextmodeBitmapCreateFromFile(
    IN PWSTR FileName
    );

NTSTATUS
TextmodeBitmapDelete(
    IN TM_BITMAP_HANDLE hBitmap
    );

NTSTATUS
TextmodeBitmapDisplay(
    IN TM_BITMAP_HANDLE hBitmap,
    IN ULONG X,
    IN ULONG Y
    );

//
// Animated bitmap abstraction
//
// Animated bitmap consists of multiple bitmaps of the same
// size. Each next bitmap is drawn at the same location 
// after the specified time out, creating an illusion of
// animation.
//
// Note : Since animated bitmap is just a collection of
//        regular textmode bitmap abstraction, its format
//        is also restricted as regular textmode bitmap.
//
typedef struct _TM_ANIMATED_BITMAP {
    TM_BITMAP_HANDLE    Bitmaps[MAX_ANIMATED_BITMAPS];
    ULONG               FlipTime;
    ULONG               CurrentBitmap;
    ULONG               X;
    ULONG               Y;
    HANDLE              ThreadHandle;
    LONG                StopAnimating;
} TM_ANIMATED_BITMAP, *PTM_ANIMATED_BITMAP, *TM_ANIMATED_BITMAP_HANDLE;


//
// Animated bitmap methods
//
TM_ANIMATED_BITMAP_HANDLE
TextmodeAnimatedBitmapCreate(
    IN ULONG *ResourceIds
    );

TM_ANIMATED_BITMAP_HANDLE
TextmodeAnimatedBitmapCreateFromFiles(
    IN WCHAR *FileNames[]
    );

NTSTATUS
TexmodeAnimatedBitmapDelete(
    IN TM_ANIMATED_BITMAP_HANDLE hAnimatedBitmap
    );

NTSTATUS
TextmodeAnimatedBitmapAnimate(
    IN TM_ANIMATED_BITMAP_HANDLE hAnimatedBitmap,
    IN ULONG X,
    IN ULONG Y,
    IN ULONG Speed
    );

VOID
TextmodeAnimatedBitmapAnimator(
    IN PVOID Context
    );


//
// Progress Bar abstraction
//
// Note : Progress bar can use bitmaps or solid
// fills based on the way its created. In case
// the progress bar uses bitmaps, then the 
// foreground & background bitmaps are each 1 pixel
// wide and background bitmap is assumed to be
// 2 pixels shorter than foreground bitmap.
// 
//
typedef struct _TM_GRAPHICS_PRGBAR {
    ULONG   X;
    ULONG   Y;
    ULONG   Length;
    ULONG   Height;
    ULONG   BackgroundColor;    
    ULONG   ForegroundColor;
    ULONG   Fill;
    TM_BITMAP_HANDLE Background;
    TM_BITMAP_HANDLE Foreground;
} TM_GRAPHICS_PRGBAR, *TM_GRAPHICS_PRGBAR_HANDLE;

//
// Progress bar methods
//
TM_GRAPHICS_PRGBAR_HANDLE
TextmodeGraphicsProgBarCreate(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG Length,
    IN ULONG Height,
    IN ULONG ForegroundColor,
    IN ULONG BackgroundColor,
    IN ULONG InitialFill
    );

TM_GRAPHICS_PRGBAR_HANDLE
TextmodeGraphicsProgBarCreateUsingBmps(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG Length,
    IN ULONG Height,
    IN ULONG BackgroundBmpId,
    IN ULONG CellBmpId,
    IN ULONG InitialFill
    );
    

NTSTATUS
TextmodeGraphicsProgBarUpdate(
    IN TM_GRAPHICS_PRGBAR_HANDLE hPrgBar,
    IN ULONG Fill
    );

NTSTATUS
TextmodeGraphicsProgBarRefresh(
    IN TM_GRAPHICS_PRGBAR_HANDLE hPrgBar,
    IN BOOLEAN UpdateBackground
    );    

NTSTATUS
TextmodeGraphicsProgBarDelete(
    IN TM_GRAPHICS_PRGBAR_HANDLE hPrgBar
    );


//    
// Vga graphics interface
//
NTSTATUS
VgaGraphicsInit(
    PSP_VIDEO_VARS VideoVars
    );

NTSTATUS
VgaGraphicsTerminate(
    PSP_VIDEO_VARS VideoVars
    );

VOID
VgaGraphicsSolidColorFill(
    IN ULONG x1,
    IN ULONG y1,
    IN ULONG x2,
    IN ULONG y2,
    IN ULONG Color
    );

VOID
VgaGraphicsBitBlt(
    IN PUCHAR Buffer,
    IN ULONG x,
    IN ULONG y
    );

//
// Misc functions
//
NTSTATUS
UpgradeGraphicsInit(
    VOID
    );

NTSTATUS
UpgradeGraphicsStart(
    VOID
    );
    
VOID
GraphicsModeProgressUpdate(
    IN TM_SETUP_MAJOR_EVENT MajorEvent,
    IN TM_SETUP_MINOR_EVENT MinorEvent,
    IN PVOID Context,
    IN PVOID EventData
    );

VOID
UpgradeGraphicsThread(
    IN PVOID Context
    );    

//
// Indicates that graphics mode is needed for upgrade
// cases, with actual textmode running in the background
//
#define SP_IS_UPGRADE_GRAPHICS_MODE() (VideoVars.UpgradeGraphicsMode)

#define SP_SET_UPGRADE_GRAPHICS_MODE(_Value)              \
            (VideoVars.UpgradeGraphicsMode = (_Value));

//
// #define _GRAPHICS_TESTING_  TRUE            
//

#endif // for _GRAPHICS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\rtl_buffer.c ===
// from base\ntdll\buffer.c
// belongs in base\ntos\rtl\buffer.c
/*++

Copyright (c) Microsoft Corporation

Module Name:

    buffer.c

Abstract:

    The module implements a buffer in the style popularized by
    Michael J. Grier (MGrier), where some amount (like MAX_PATH)
    of storage is preallocated (like on the stack) and if the storage
    needs grow beyond the preallocated size, the heap is used.

Author:

    Jay Krell (a-JayK) June 2000

Environment:

    User Mode or Kernel Mode (but don't preallocate much on the stack in kernel mode)

Revision History:

--*/

#include "spprecmp.h"

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant
#define _NTOS_ /* prevent #including ntos.h, only use functions exported from ntdll/ntoskrnl 
                  for usermode/kernelmode portability */
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <limits.h>
#include "ntrtlstringandbuffer.h"

NTSTATUS
NTAPI
RtlpEnsureBufferSize (
    IN ULONG    Flags,
    IN OUT PRTL_BUFFER Buffer,
    IN SIZE_T          Size
    )
/*++

Routine Description:

    This function ensures Buffer can hold Size bytes, or returns
    an error. It either bumps Buffer->Size closer to Buffer->StaticSize,
    or heap allocates.

Arguments:

    Buffer - a Buffer object, see also RtlInitBuffer.

    Size - the number of bytes the caller wishes to store in Buffer->Buffer.


Return Value:

     STATUS_SUCCESS
     STATUS_NO_MEMORY

--*/
{
    PUCHAR Temp;

    if ((Flags & ~(RTL_ENSURE_BUFFER_SIZE_NO_COPY)) != 0) {
        return STATUS_INVALID_PARAMETER;
    }
    if (Buffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (Size <= Buffer->Size) {
        return STATUS_SUCCESS;
    }
    // Size <= Buffer->StaticSize does not imply static allocation, it
    // could be heap allocation that the client poked smaller.
    if (Buffer->Buffer == Buffer->StaticBuffer && Size <= Buffer->StaticSize) {
        Buffer->Size = Size;
        return STATUS_SUCCESS;
    }
    //
    // The realloc case was messed up in Whistler, and got removed.
    // Put it back in Blackcomb.
    //
    Temp = (PUCHAR)RtlAllocateStringRoutine(Size);
    if (Temp == NULL) {
        return STATUS_NO_MEMORY;
    }

    if ((Flags & RTL_ENSURE_BUFFER_SIZE_NO_COPY) == 0) {
        RtlCopyMemory(Temp, Buffer->Buffer, Buffer->Size);
    }

    if (RTLP_BUFFER_IS_HEAP_ALLOCATED(Buffer)) {
        RtlFreeStringRoutine(Buffer->Buffer);
        Buffer->Buffer = NULL;
    }
    ASSERT(Temp != NULL);
    Buffer->Buffer = Temp;
    Buffer->Size = Size;

    return STATUS_SUCCESS;
}

NTSTATUS
NTAPI
RtlMultiAppendUnicodeStringBuffer (
    OUT PRTL_UNICODE_STRING_BUFFER Destination,
    IN  ULONG                      NumberOfSources,
    IN  const UNICODE_STRING*      SourceArray
    )
/*++

Routine Description:


Arguments:

    Destination -
    NumberOfSources -
    SourceArray -

Return Value:

     STATUS_SUCCESS
     STATUS_NO_MEMORY
     STATUS_NAME_TOO_LONG

--*/
{
    SIZE_T Length;
    ULONG i;
    NTSTATUS Status;
    const SIZE_T CharSize = sizeof(*Destination->String.Buffer);
    const ULONG OriginalDestinationLength = Destination->String.Length;

    Length = OriginalDestinationLength;
    for (i = 0 ; i != NumberOfSources ; ++i) {
        Length += SourceArray[i].Length;
        if (Length > MAX_UNICODE_STRING_MAXLENGTH) {
            return STATUS_NAME_TOO_LONG;
        }
    }
    Length += CharSize;
    if (Length > MAX_UNICODE_STRING_MAXLENGTH) {
        return STATUS_NAME_TOO_LONG;
    }

    Status = RtlEnsureBufferSize(0, &Destination->ByteBuffer, Length);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Destination->String.MaximumLength = (USHORT)Length;
    Destination->String.Length = (USHORT)(Length - CharSize);
    Destination->String.Buffer = (PWSTR)Destination->ByteBuffer.Buffer;
    Length = OriginalDestinationLength;
    for (i = 0 ; i != NumberOfSources ; ++i) {
        RtlMoveMemory(
            Destination->String.Buffer + Length / CharSize,
            SourceArray[i].Buffer,
            SourceArray[i].Length);
        Length += SourceArray[i].Length;
    }
    Destination->String.Buffer[Length / CharSize] = 0;
    return STATUS_SUCCESS;
}

NTSTATUS
NTAPI
RtlInitAnsiStringBuffer(
    PRTL_ANSI_STRING_BUFFER StringBuffer,
    PUCHAR                  StaticBuffer,
    SIZE_T                  StaticSize
    )
{
    PANSI_STRING String;
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    if (!RTL_SOFT_VERIFY(StringBuffer != NULL)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (StaticSize < sizeof(StringBuffer)->MinimumStaticBufferForTerminalNul
        || StaticBuffer == NULL) {
        StaticSize = sizeof(StringBuffer->MinimumStaticBufferForTerminalNul);
        StaticBuffer = StringBuffer->MinimumStaticBufferForTerminalNul;
    }
    if (StaticSize > MAX_UNICODE_STRING_MAXLENGTH) {
        StaticSize = MAX_UNICODE_STRING_MAXLENGTH;
    }

    RtlInitBuffer(&StringBuffer->ByteBuffer, StaticBuffer, StaticSize);

    String = &StringBuffer->String;
    String->Length = 0;
    String->MaximumLength = (RTL_STRING_LENGTH_TYPE)StaticSize;
    String->Buffer = StaticBuffer;
    StaticBuffer[0] = 0;

    NtStatus = STATUS_SUCCESS;
Exit:
    return NtStatus;
}

VOID
NTAPI
RtlFreeAnsiStringBuffer(
    PRTL_ANSI_STRING_BUFFER StringBuffer
    )
{
    if (StringBuffer != NULL) {
        const PRTL_BUFFER ByteBuffer = &StringBuffer->ByteBuffer;
        RtlFreeBuffer(ByteBuffer);

        //
        // ok for reuse or repeat free
        //
        RtlInitAnsiStringBuffer(StringBuffer, ByteBuffer->StaticBuffer, ByteBuffer->StaticSize);
    }
}

NTSTATUS
NTAPI
RtlAssignAnsiStringBufferFromUnicodeString(
    PRTL_ANSI_STRING_BUFFER StringBuffer,
    PCUNICODE_STRING UnicodeString
    )
{
    PANSI_STRING String;
    PRTL_BUFFER  ByteBuffer;
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    if (!RTL_SOFT_VERIFY(StringBuffer != NULL)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (!RTL_SOFT_VERIFY(UnicodeString != NULL)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    ByteBuffer = &StringBuffer->ByteBuffer;

    NtStatus =
        RtlEnsureBufferSize(
            RTL_ENSURE_BUFFER_SIZE_NO_COPY,
            ByteBuffer,
            (RTL_STRING_GET_LENGTH_CHARS(UnicodeString) * 2) + 1);
    if (!NT_SUCCESS(NtStatus)) {
        goto Exit;
    }

    String = &StringBuffer->String;

    String->Length = 0;
    String->MaximumLength = (RTL_STRING_LENGTH_TYPE)ByteBuffer->Size;
    String->Buffer = (PSTR)ByteBuffer->Buffer;
    NtStatus = RtlUnicodeStringToAnsiString(String, UnicodeString, FALSE);
    if (!NT_SUCCESS(NtStatus)) {
        goto Exit;
    }
    RTL_STRING_NUL_TERMINATE(String);

    NtStatus = STATUS_SUCCESS;
Exit:
    return NtStatus;
}

NTSTATUS
NTAPI
RtlAssignAnsiStringBufferFromUnicode(
    PRTL_ANSI_STRING_BUFFER StringBuffer,
    PCWSTR Unicode
    )
{
    UNICODE_STRING UnicodeString;
    NTSTATUS NtStatus;

    NtStatus = RtlInitUnicodeStringEx(&UnicodeString, Unicode);
    if (!NT_SUCCESS(NtStatus)) {
        goto Exit;
    }
    
    NtStatus = RtlAssignAnsiStringBufferFromUnicodeString(StringBuffer, &UnicodeString);
    if (!NT_SUCCESS(NtStatus)) {
        goto Exit;
    }

    NtStatus = STATUS_SUCCESS;
Exit:
    return NtStatus;
}

NTSTATUS
NTAPI
RtlUnicodeStringBufferEnsureTrailingNtPathSeperator(
    PRTL_UNICODE_STRING_BUFFER StringBuffer
    )
{
    PUNICODE_STRING String = NULL;
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    const WCHAR SeperatorChar = L'\\';
    const static UNICODE_STRING SeperatorString = RTL_CONSTANT_STRING(L"\\");

    if (!RTL_SOFT_VERIFY(StringBuffer != NULL)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    String = &StringBuffer->String;
    if (String->Length == 0 || RTL_STRING_GET_LAST_CHAR(String) != SeperatorChar) {
        NtStatus = RtlAppendUnicodeStringBuffer(StringBuffer, &SeperatorString);
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }
    }
    NtStatus = STATUS_SUCCESS;
Exit:
    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\ntrtlp.h ===
// from base\ntos\rtl\ntrtlp.h
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntrtlp.h

Abstract:

    Include file for NT runtime routines that are callable by both
    kernel mode code in the executive and user mode code in various
    NT subsystems, but which are private interfaces.

Author:

    David N. Cutler (davec) 15-Aug-1989

Environment:

    These routines are dynamically linked in the caller's executable and
    are callable in either kernel mode or user mode.

Revision History:

--*/

#ifndef _NTRTLP_
#define _NTRTLP_
#include <ntos.h>
#include <nturtl.h>
#include <zwapi.h>
#include <sxstypes.h>

//#if defined(_AMD64_)
//#include "amd64\ntrtlamd64.h"

//#elif defined(_X86_)
//#include "i386\ntrtl386.h"

//#elif defined(_IA64_)
//#include "ia64\ntrtli64.h"

//#else
//#error "no target architecture"
//#endif

#ifdef BLDR_KERNEL_RUNTIME
#undef try
#define try if(1)
#undef except
#define except(a) else if (0)
#undef finally
#define finally if (1)
#undef GetExceptionCode
#define GetExceptionCode() 1
#define finally if (1)
#endif

#include "string.h"
#include "wchar.h"

#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))

#if !defined(NTOS_KERNEL_RUNTIME) && !defined(BLDR_KERNEL_RUNTIME)

#if DBG
PCUNICODE_STRING RtlpGetImagePathName(VOID);
#define RtlpGetCurrentProcessId() (HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess))
#define RtlpGetCurrentThreadId() (HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread))
#endif

#endif

#define RTLP_GOOD_DOS_ROOT_PATH                                            0
#define RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX                              1 /* \\?\ */
#define RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX                          2 /* \\?\unc */
#define RTLP_BAD_DOS_ROOT_PATH_NT_PATH                                     3 /* \??\, this is only rough */
#define RTLP_BAD_DOS_ROOT_PATH_MACHINE_NO_SHARE                            4 /* \\machine or \\?\unc\machine */

CONST CHAR*
RtlpDbgBadDosRootPathTypeToString(
    IN ULONG     Flags,
    IN ULONG     RootType
    );

NTSTATUS
RtlpCheckForBadDosRootPath(
    IN ULONG             Flags,
    IN PCUNICODE_STRING  RootString,
    OUT ULONG*           RootType
    );

NTSTATUS
NTAPI
RtlpBadDosRootPathToEmptyString(
    IN     ULONG            Flags,
    IN OUT PUNICODE_STRING  Path
    );

#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_IN_FLAG_OLD (0x00000010)

//
// This bit means to do extra validation on \\? paths, to reject \\?\a\b,
// To only allow \\? followed by the documented forms \\?\unc\foo and \\?\c:
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_IN_FLAG_STRICT_WIN32NT (0x00000020)

#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_OUT_TYPE_MASK                    (0x0000000F)

//
// These bits add more information to RtlPathTypeUncAbsolute, which is what \\?
// is reported as.
//

//
// The path starts "\\?".
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_OUT_FLAG_WIN32NT                 (0x00000010)

//
// The path starts "\\?\x:".
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_OUT_FLAG_WIN32NT_DRIVE_ABSOLUTE  (0x00000020)

//
// The path starts "\\?\unc".
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_OUT_FLAG_WIN32NT_UNC_ABSOLUTE    (0x00000040)

//
//future this would indicate \\machine instead of \\machine\share
//define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_OUT_FLAG_WIN32NT_UNC_MACHINE_ONLY (0x00000080)
//future this would indicate \\ or \\?\unc
//define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_OUT_FLAG_WIN32NT_UNC_EMPTY        (0x00000100)
//

//
// So far, this means something like \\?\a was seen, instead of \\?\unc or \\?\a:
// You have to request it with RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_IN_FLAG_STRICT_WIN32NT.
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_OUT_FLAG_INVALID       (0x00000200)

//
// stuff like \\ \\? \\?\unc \\?\unc\
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_OUT_FLAG_INCOMPLETE_ROOT (0x00000400)

NTSTATUS
NTAPI
RtlpDetermineDosPathNameTypeEx(
    IN ULONG            InFlags,
    IN PCUNICODE_STRING DosPath,
    OUT RTL_PATH_TYPE*  OutType,
    OUT ULONG*          OutFlags
    );

#define RTLP_IMPLIES(x,y) ((x) ? (y) : TRUE)

#endif  // _NTRTLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\rtl_error.c ===
// from base\ntos\rtl\error.c
// should be gotten from a static .lib
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains a routine for converting NT status codes
    to DOS/OS|2 error codes.

Author:

    David Treadwell (davidtr)   04-Apr-1991

Revision History:

--*/
#include "spprecmp.h"

#define _NTOS_ /* prevent #including ntos.h, only use functions exports from ntdll/ntoskrnl */
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "winerror.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE, RtlGetLastNtStatus)
#pragma alloc_text(PAGE, RtlGetLastWin32Error)
#pragma alloc_text(PAGE, RtlNtStatusToDosError)
#pragma alloc_text(PAGE, RtlRestoreLastWin32Error)
#pragma alloc_text(PAGE, RtlSetLastWin32Error)
#pragma alloc_text(PAGE, RtlSetLastWin32ErrorAndNtStatusFromNtStatus)
#endif

//
// Ensure that the Registry ERROR_SUCCESS error code and the
// NO_ERROR error code remain equal and zero.
//

#if ERROR_SUCCESS != 0 || NO_ERROR != 0
#error Invalid value for ERROR_SUCCESS.
#endif

NTSYSAPI
ULONG
RtlNtStatusToDosError (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine converts an NT status code to its DOS/OS|2 equivalent.
    Remembers the Status code value in the TEB.

Arguments:

    Status - Supplies the status value to convert.

Return Value:

    The matching DOS/OS|2 error code.

--*/

{
    PTEB Teb;

    Teb = NtCurrentTeb();

    if (Teb) {
        try {
            Teb->LastStatusValue = Status;
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    return RtlNtStatusToDosErrorNoTeb( Status );
}


NTSYSAPI
NTSTATUS
NTAPI
RtlGetLastNtStatus(
	VOID
	)
{
	return NtCurrentTeb()->LastStatusValue;
}

NTSYSAPI
LONG
NTAPI
RtlGetLastWin32Error(
	VOID
	)
{
	return NtCurrentTeb()->LastErrorValue;
}

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
	NTSTATUS Status
	)
{
	//
	// RtlNtStatusToDosError stores into NtCurrentTeb()->LastStatusValue.
	//
	RtlSetLastWin32Error(RtlNtStatusToDosError(Status));
}

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32Error(
	LONG Win32Error
	)
{
//
// Arguably this should clear or reset the last nt status, but it does not
// touch it.
//
	NtCurrentTeb()->LastErrorValue = Win32Error;
}

NTSYSAPI
VOID
NTAPI
RtlRestoreLastWin32Error(
	LONG Win32Error
	)
{
#if DBG
	if ((LONG)NtCurrentTeb()->LastErrorValue != Win32Error)
#endif
		NtCurrentTeb()->LastErrorValue = Win32Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\rtl_findcharinunicodestring.c ===
// from base\ntos\rtl\rtlfindcharinunicodestring
// should be gotten from a static .lib
/*++

Copyright (c) Microsoft Corporation

Module Name:

    rtlfindcharinunicodestring.c

Abstract:

    This module implements NLS support functions for NT.

Author:

    Mark Lucovsky (markl) 16-Apr-1991

Environment:

    Kernel or user-mode

Revision History:

    16-Feb-1993    JulieB    Added Upcase Rtl Routines.
    08-Mar-1993    JulieB    Moved Upcase Macro to ntrtlp.h.
    02-Apr-1993    JulieB    Fixed RtlAnsiCharToUnicodeChar to use transl. tbls.
    02-Apr-1993    JulieB    Fixed BUFFER_TOO_SMALL check.
    28-May-1993    JulieB    Fixed code to properly handle DBCS.
    November 30, 2001 JayKrell broken out of nls.c for easier reuse

--*/

#include "spprecmp.h"

WCHAR
RtlDowncaseUnicodeChar(
    IN WCHAR SourceCharacter
    )
{
    return SpToLower(SourceCharacter);
}

NTSTATUS
RtlFindCharInUnicodeString(
    ULONG Flags,
    PCUNICODE_STRING StringToSearch,
    PCUNICODE_STRING CharSet,
    USHORT *NonInclusivePrefixLength
    )
{
    NTSTATUS Status;
    USHORT PrefixLengthFound = 0;
    USHORT CharsToSearch = 0;
    int MovementDirection = 0;
    PCWSTR Cursor = NULL;
    BOOLEAN Found = FALSE;
    USHORT CharSetChars = 0;
    PCWSTR CharSetBuffer = NULL;
    USHORT i;

    if (NonInclusivePrefixLength != 0)
        *NonInclusivePrefixLength = 0;

    if (((Flags & ~(RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END |
                    RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET |
                    RTL_FIND_CHAR_IN_UNICODE_STRING_CASE_INSENSITIVE)) != 0) ||
        (NonInclusivePrefixLength == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = RtlValidateUnicodeString(0, StringToSearch);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Status = RtlValidateUnicodeString(0, CharSet);
    if (!NT_SUCCESS(Status))
        goto Exit;

    CharsToSearch = StringToSearch->Length / sizeof(WCHAR);
    CharSetChars = CharSet->Length / sizeof(WCHAR);
    CharSetBuffer = CharSet->Buffer;

    if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END) {
        MovementDirection = -1;
        Cursor = StringToSearch->Buffer + CharsToSearch - 1;
    } else {
        MovementDirection = 1;
        Cursor = StringToSearch->Buffer;
    }

    if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_CASE_INSENSITIVE) {
        // Unicode standard says to always do case insensitive comparisons in lower case since the case mappings are
        // asymmetric.
        WCHAR CharSetStackBuffer[32]; // optimized pre-downcased for case insensitive

        // Optimization for the case of a relatively small char set to match
        if (CharSetChars <= RTL_NUMBER_OF(CharSetStackBuffer)) {

            for (i=0; i<CharSetChars; i++)
                CharSetStackBuffer[i] = RtlDowncaseUnicodeChar(CharSetBuffer[i]);

            while (CharsToSearch != 0) {
                const WCHAR wch = RtlDowncaseUnicodeChar(*Cursor);

                if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET) {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == CharSetStackBuffer[i])
                            break;
                    }

                    if (i == CharSetChars)
                        break;
                } else {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == CharSetStackBuffer[i])
                            break;
                    }

                    if (i != CharSetChars)
                        break;
                }

                CharsToSearch--;
                Cursor += MovementDirection;
            }
        } else {
            while (CharsToSearch != 0) {
                const WCHAR wch = RtlDowncaseUnicodeChar(*Cursor);

                if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET) {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == RtlDowncaseUnicodeChar(CharSetBuffer[i])) {
                            break;
                        }
                    }

                    if (i == CharSetChars)
                        break;
                } else {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == RtlDowncaseUnicodeChar(CharSetBuffer[i])) {
                            break;
                        }
                    }

                    if (i != CharSetChars)
                        break;
                }

                CharsToSearch--;
                Cursor += MovementDirection;
            }
        }
    } else {
        if (CharSetChars == 1) {
            // Significant optimization for looking for one character.
            const WCHAR wchSearchChar = CharSetBuffer[0];

            if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET) {
                while (CharsToSearch != 0) {
                    if (*Cursor != wchSearchChar)
                        break;
                    CharsToSearch--;
                    Cursor += MovementDirection;
                }
            } else {
                while (CharsToSearch != 0) {
                    if (*Cursor == wchSearchChar)
                        break;
                    CharsToSearch--;
                    Cursor += MovementDirection;
                }
            }
        } else {
            while (CharsToSearch != 0) {
                const WCHAR wch = *Cursor;

                if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET) {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == CharSetBuffer[i])
                            break;
                    }

                    if (i == CharSetChars)
                        break;

                } else {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == CharSetBuffer[i])
                            break;
                    }

                    if (i != CharSetChars)
                        break;
                }

                CharsToSearch--;
                Cursor += MovementDirection;
            }
        }
    }

    if (CharsToSearch == 0) {
        Status = STATUS_NOT_FOUND;
        goto Exit;
    }

    CharsToSearch--;

    if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END)
        PrefixLengthFound = (USHORT) (CharsToSearch * sizeof(WCHAR));
    else
        PrefixLengthFound = (USHORT) (StringToSearch->Length - (CharsToSearch * sizeof(WCHAR)));

    *NonInclusivePrefixLength = PrefixLengthFound;

    Status = STATUS_SUCCESS;

Exit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\rtl_validateunicodestring.c ===
// from base\ntos\rtl\rtlvalidateunicodestring.c
// should be gotten from a static .lib
/*++

Copyright (c) Microsoft Corporation

Module Name:

    rtlvalidateunicodestring.c

Abstract:

    This module implements NLS support functions for NT.

Author:

    Mark Lucovsky (markl) 16-Apr-1991

Environment:

    Kernel or user-mode

Revision History:

    16-Feb-1993    JulieB    Added Upcase Rtl Routines.
    08-Mar-1993    JulieB    Moved Upcase Macro to ntrtlp.h.
    02-Apr-1993    JulieB    Fixed RtlAnsiCharToUnicodeChar to use transl. tbls.
    02-Apr-1993    JulieB    Fixed BUFFER_TOO_SMALL check.
    28-May-1993    JulieB    Fixed code to properly handle DBCS.
    November 30, 2001 JayKrell broken out of nls.c for easier reuse

--*/
#include "spprecmp.h"

NTSTATUS
RtlValidateUnicodeString(
    ULONG Flags,
    const UNICODE_STRING *String
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(Flags == 0);

    if (Flags != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (String != NULL) {
        if (((String->Length % 2) != 0) ||
            ((String->MaximumLength % 2) != 0) ||
            (String->Length > String->MaximumLength)) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        if (((String->Length != 0) ||
             (String->MaximumLength != 0)) &&
            (String->Buffer == NULL)) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\rtl_path.c ===
// from base\ntdll\curdir.c
// belongs in base\ntos\rtl\path.c
/*++

Copyright (c) Microsoft Corporation

Module Name:

    path.c

Abstract:

Author:

    Jay Krell (JayKrell)

Revision History:

Environment:

    ntdll.dll and setupdd.sys, not ntoskrnl.exe

--*/

#include "spprecmp.h"

#pragma warning(disable:4201)   // nameless struct/union

#define _NTOS_ /* prevent #including ntos.h, only use functions exports from ntdll/ntoskrnl */
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntrtlp.h"

#define IS_PATH_SEPARATOR_U(ch) (((ch) == L'\\') || ((ch) == L'/'))

extern const UNICODE_STRING RtlpEmptyString = RTL_CONSTANT_STRING(L"");
extern const UNICODE_STRING RtlpSlashSlashDot       = RTL_CONSTANT_STRING( L"\\\\.\\" );
extern const UNICODE_STRING RtlpDosDevicesPrefix    = RTL_CONSTANT_STRING( L"\\??\\" );

//
// \\? is referred to as the "Win32Nt" prefix or root.
// Paths that start with \\? are referred to as "Win32Nt" paths.
// Fudging the \\? to \?? converts the path to an Nt path.
//
extern const UNICODE_STRING RtlpWin32NtRoot         = RTL_CONSTANT_STRING( L"\\\\?" );
extern const UNICODE_STRING RtlpWin32NtRootSlash    = RTL_CONSTANT_STRING( L"\\\\?\\" );
extern const UNICODE_STRING RtlpWin32NtUncRoot      = RTL_CONSTANT_STRING( L"\\\\?\\UNC" );
extern const UNICODE_STRING RtlpWin32NtUncRootSlash = RTL_CONSTANT_STRING( L"\\\\?\\UNC\\" );

#define DPFLTR_LEVEL_STATUS(x) ((NT_SUCCESS(x) \
                                    || (x) == STATUS_OBJECT_NAME_NOT_FOUND    \
                                    ) \
                                ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)

RTL_PATH_TYPE
NTAPI
RtlDetermineDosPathNameType_Ustr(
    IN PCUNICODE_STRING String
    )

/*++

Routine Description:

    This function examines the Dos format file name and determines the
    type of file name (i.e.  UNC, DriveAbsolute, Current Directory
    rooted, or Relative.)

Arguments:

    DosFileName - Supplies the Dos format file name whose type is to be
        determined.

Return Value:

    RtlPathTypeUnknown - The path type can not be determined

    RtlPathTypeUncAbsolute - The path specifies a Unc absolute path
        in the format \\server-name\sharename\rest-of-path

    RtlPathTypeLocalDevice - The path specifies a local device in the format
        \\.\rest-of-path or \\?\rest-of-path.  This can be used for any device
        where the nt and Win32 names are the same. For example mailslots.

    RtlPathTypeRootLocalDevice - The path specifies the root of the local
        devices in the format \\. or \\?

    RtlPathTypeDriveAbsolute - The path specifies a drive letter absolute
        path in the form drive:\rest-of-path

    RtlPathTypeDriveRelative - The path specifies a drive letter relative
        path in the form drive:rest-of-path

    RtlPathTypeRooted - The path is rooted relative to the current disk
        designator (either Unc disk, or drive). The form is \rest-of-path.

    RtlPathTypeRelative - The path is relative (i.e. not absolute or rooted).

--*/

{
    RTL_PATH_TYPE ReturnValue;
    const PCWSTR DosFileName = String->Buffer;

#define ENOUGH_CHARS(_cch) (String->Length >= ((_cch) * sizeof(WCHAR)))

    if ( ENOUGH_CHARS(1) && IS_PATH_SEPARATOR_U(*DosFileName) ) {
        if ( ENOUGH_CHARS(2) && IS_PATH_SEPARATOR_U(*(DosFileName+1)) ) {
            if ( ENOUGH_CHARS(3) && (DosFileName[2] == '.' ||
                                     DosFileName[2] == '?') ) {

                if ( ENOUGH_CHARS(4) && IS_PATH_SEPARATOR_U(*(DosFileName+3)) ){
                    // "\\.\" or "\\?\"
                    ReturnValue = RtlPathTypeLocalDevice;
                    }
                else if ( String->Length == (3 * sizeof(WCHAR)) ){
                    // "\\." or \\?"
                    ReturnValue = RtlPathTypeRootLocalDevice;
                    }
                else {
                    // "\\.x" or "\\?x"
                    ReturnValue = RtlPathTypeUncAbsolute;
                    }
                }
            else {
                // "\\x"
                ReturnValue = RtlPathTypeUncAbsolute;
                }
            }
        else {
            // "\x"
            ReturnValue = RtlPathTypeRooted;
            }
        }
    //
    // the "*DosFileName" is left over from the PCWSTR version
    // Win32 and DOS don't allow embedded nuls and much code limits
    // drive letters to strictly 7bit a-zA-Z so it's ok.
    //
    else if (ENOUGH_CHARS(2) && *DosFileName && *(DosFileName+1)==L':') {
        if (ENOUGH_CHARS(3) && IS_PATH_SEPARATOR_U(*(DosFileName+2))) {
            // "x:\"
            ReturnValue = RtlPathTypeDriveAbsolute;
            }
        else  {
            // "c:x"
            ReturnValue = RtlPathTypeDriveRelative;
            }
        }
    else {
        // "x", first char is not a slash / second char is not colon
        ReturnValue = RtlPathTypeRelative;
        }
    return ReturnValue;

#undef ENOUGH_CHARS
}

NTSTATUS
NTAPI
RtlpDetermineDosPathNameTypeEx(
    IN ULONG            InFlags,
    IN PCUNICODE_STRING DosPath,
    OUT RTL_PATH_TYPE*  OutType,
    OUT ULONG*          OutFlags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    RTL_PATH_TYPE PathType = 0;
    BOOLEAN Win32Nt = FALSE;
    BOOLEAN Win32NtUncAbsolute = FALSE;
    BOOLEAN Win32NtDriveAbsolute = FALSE;
    BOOLEAN IncompleteRoot = FALSE;
    RTL_PATH_TYPE PathTypeAfterWin32Nt = 0;

    if (OutType != NULL
        ) {
        *OutType = RtlPathTypeUnknown;
    }
    if (OutFlags != NULL
        ) {
        *OutFlags = 0;
    }
    if (
           !RTL_SOFT_VERIFY(DosPath != NULL)
        || !RTL_SOFT_VERIFY(OutType != NULL)
        || !RTL_SOFT_VERIFY(OutFlags != NULL)
        || !RTL_SOFT_VERIFY(
                (InFlags & ~(RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_IN_FLAG_OLD | RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_IN_FLAG_STRICT_WIN32NT))
                == 0)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    PathType = RtlDetermineDosPathNameType_Ustr(DosPath);
    *OutType = PathType;
    if (InFlags & RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_IN_FLAG_OLD)
        goto Exit;

    if (DosPath->Length == sizeof(L"\\\\") - sizeof(DosPath->Buffer[0])
        ) {
        IncompleteRoot = TRUE;
    }
    else if (RtlEqualUnicodeString(&RtlpWin32NtRoot, DosPath, TRUE)
        ) {
        IncompleteRoot = TRUE;
        Win32Nt = TRUE;
    }
    else if (RtlEqualUnicodeString(&RtlpWin32NtRootSlash, DosPath, TRUE)
        ) {
        IncompleteRoot = TRUE;
        Win32Nt = TRUE;
    }
    else if (RtlPrefixUnicodeString(&RtlpWin32NtRootSlash, DosPath, TRUE)
        ) {
        Win32Nt = TRUE;
    }

    if (Win32Nt) {
        if (RtlEqualUnicodeString(&RtlpWin32NtUncRoot, DosPath, TRUE)
            ) {
            IncompleteRoot = TRUE;
            Win32NtUncAbsolute = TRUE;
        }
        else if (RtlEqualUnicodeString(&RtlpWin32NtUncRootSlash, DosPath, TRUE)
            ) {
            IncompleteRoot = TRUE;
            Win32NtUncAbsolute = TRUE;
        }
        else if (RtlPrefixUnicodeString(&RtlpWin32NtUncRootSlash, DosPath, TRUE)
            ) {
            Win32NtUncAbsolute = TRUE;
        }
        if (Win32NtUncAbsolute
            ) {
            Win32NtDriveAbsolute = FALSE;
        } else if (!IncompleteRoot) {
            const RTL_STRING_LENGTH_TYPE i = RtlpWin32NtRootSlash.Length;
            UNICODE_STRING PathAfterWin32Nt = *DosPath;

            PathAfterWin32Nt.Buffer +=  i / sizeof(PathAfterWin32Nt.Buffer[0]);
            PathAfterWin32Nt.Length = PathAfterWin32Nt.Length - i;
            PathAfterWin32Nt.MaximumLength = PathAfterWin32Nt.MaximumLength - i;

            PathTypeAfterWin32Nt = RtlDetermineDosPathNameType_Ustr(&PathAfterWin32Nt);
            if (PathTypeAfterWin32Nt == RtlPathTypeDriveAbsolute) {
                Win32NtDriveAbsolute = TRUE;
            }
            else {
                Win32NtDriveAbsolute = FALSE;
            }

            if (InFlags & RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_IN_FLAG_STRICT_WIN32NT
                ) {
                if (!RTL_SOFT_VERIFY(Win32NtDriveAbsolute
                    )) {
                    *OutFlags |= RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_OUT_FLAG_INVALID;
                    // we still succeed the function call
                }
            }
        }
    }

    ASSERT(RTLP_IMPLIES(Win32NtDriveAbsolute, Win32Nt));
    ASSERT(RTLP_IMPLIES(Win32NtUncAbsolute, Win32Nt));
    ASSERT(!(Win32NtUncAbsolute && Win32NtDriveAbsolute));

    if (IncompleteRoot)
        *OutFlags |= RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_OUT_FLAG_INCOMPLETE_ROOT;
    if (Win32Nt)
        *OutFlags |= RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_OUT_FLAG_WIN32NT;
    if (Win32NtUncAbsolute)
        *OutFlags |= RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_OUT_FLAG_WIN32NT_UNC_ABSOLUTE;
    if (Win32NtDriveAbsolute)
        *OutFlags |= RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_OUT_FLAG_WIN32NT_DRIVE_ABSOLUTE;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

#define RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS_OR_NT   (0x00000001)
#define RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS         (0x00000002)
#define RTLP_LAST_PATH_ELEMENT_PATH_TYPE_NT               (0x00000003)
#define RTLP_LAST_PATH_ELEMENT_PATH_TYPE_DOS              (0x00000004)


NTSTATUS
NTAPI
RtlpGetLengthWithoutLastPathElement(
    IN  ULONG            Flags,
    IN  ULONG            PathType,
    IN  PCUNICODE_STRING Path,
    OUT ULONG*           LengthOut
    )
/*++

Routine Description:

    Report how long Path would be if you remove its last element.
    This is much simpler than RtlRemoveLastDosPathElement.
    It is used to implement the other RtlRemoveLast*PathElement.

Arguments:

    Flags - room for future expansion
    Path - the path is is an NT path or a full DOS path; the various relative DOS
        path types do not work, see RtlRemoveLastDosPathElement for them.

Return Value:

    STATUS_SUCCESS - the usual hunky-dory
    STATUS_NO_MEMORY - the usual stress
    STATUS_INVALID_PARAMETER - the usual bug

--*/
{
    ULONG Length = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    RTL_PATH_TYPE DosPathType = RtlPathTypeUnknown;
    ULONG DosPathFlags = 0;
    ULONG AllowedDosPathTypeBits =   (1UL << RtlPathTypeRooted)
                                   | (1UL << RtlPathTypeUncAbsolute)
                                   | (1UL << RtlPathTypeDriveAbsolute)
                                   | (1UL << RtlPathTypeLocalDevice)     // "\\?\"
                                   | (1UL << RtlPathTypeRootLocalDevice) // "\\?"
                                   ;
    WCHAR PathSeperators[2] = { '/', '\\' };

#define LOCAL_IS_PATH_SEPARATOR(ch_) ((ch_) == PathSeperators[0] || (ch_) == PathSeperators[1])

    if (LengthOut != NULL) {
        *LengthOut = 0;
    }

    if (   !RTL_SOFT_VERIFY(Path != NULL)
        || !RTL_SOFT_VERIFY(Flags == 0)
        || !RTL_SOFT_VERIFY(LengthOut != NULL)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Length = RTL_STRING_GET_LENGTH_CHARS(Path);

    switch (PathType)
    {
    default:
    case RTLP_LAST_PATH_ELEMENT_PATH_TYPE_DOS:
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    case RTLP_LAST_PATH_ELEMENT_PATH_TYPE_NT:
        //
        // RtlpDetermineDosPathNameTypeEx calls it "rooted"
        // only backslashes are seperators
        // path must start with backslash
        // second char must not be backslash
        //
        AllowedDosPathTypeBits = (1UL << RtlPathTypeRooted);
        PathSeperators[0] = '\\';
        if (Length > 0 && Path->Buffer[0] != '\\'
            ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        if (Length > 1 && Path->Buffer[1] == '\\'
            ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        break;
    case RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS:
        AllowedDosPathTypeBits &= ~(1UL << RtlPathTypeRooted);
        break;
    case RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS_OR_NT:
        break;
    }

    if (Length == 0) {
        goto Exit;
    }

    Status = RtlpDetermineDosPathNameTypeEx(
                RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_IN_FLAG_STRICT_WIN32NT,
                Path,
                &DosPathType,
                &DosPathFlags
                );

    if (!RTL_SOFT_VERIFY(NT_SUCCESS(Status))) {
        goto Exit;
    }
    if (!RTL_SOFT_VERIFY((1UL << DosPathType) & AllowedDosPathTypeBits)
        ) {
        //KdPrintEx();
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (!RTL_SOFT_VERIFY(
           (DosPathFlags & RTLP_DETERMINE_DOS_PATH_NAME_TYPE_EX_OUT_FLAG_INVALID) == 0
            )) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // skip one or more trailing path seperators
    for ( ; Length != 0 && LOCAL_IS_PATH_SEPARATOR(Path->Buffer[Length - 1]) ; --Length) {
        // nothing
    }
    // skip trailing path element
    for ( ; Length != 0 && !LOCAL_IS_PATH_SEPARATOR(Path->Buffer[Length - 1]) ; --Length) {
        // nothing
    }
    // skip one or more in between path seperators
    for ( ; Length != 0 && LOCAL_IS_PATH_SEPARATOR(Path->Buffer[Length - 1]) ; --Length) {
        // nothing
    }
    // put back a trailing path seperator, for the sake of c:\ vs. c:
    if (Length != 0) {
        ++Length;
    }

    //
    // Should optionally check for "bad dos roots" here.
    //

    *LengthOut = Length;
    Status = STATUS_SUCCESS;
Exit:
    return Status;
#undef LOCAL_IS_PATH_SEPARATOR
}


NTSTATUS
NTAPI
RtlGetLengthWithoutLastNtPathElement(
    IN  ULONG            Flags,
    IN  PCUNICODE_STRING Path,
    OUT ULONG*           LengthOut
    )
/*++

Routine Description:

    Report how long Path would be if you remove its last element.

Arguments:

    Flags - room for future expansion
    Path - the path is is an NT path; the various DOS path types
        do not work, see RtlRemoveLastDosPathElement for them.

Return Value:

    STATUS_SUCCESS - the usual hunky-dory
    STATUS_NO_MEMORY - the usual stress
    STATUS_INVALID_PARAMETER - the usual bug

--*/
{
    NTSTATUS Status = RtlpGetLengthWithoutLastPathElement(Flags, RTLP_LAST_PATH_ELEMENT_PATH_TYPE_NT, Path, LengthOut);
    return Status;
}


NTSTATUS
NTAPI
RtlGetLengthWithoutLastFullDosOrNtPathElement(
    IN  ULONG            Flags,
    IN  PCUNICODE_STRING Path,
    OUT ULONG*           LengthOut
    )
/*++

Routine Description:

    Report how long Path would be if you remove its last element.

Arguments:

    Flags - room for future expansion
    Path - the path is is an NT path; the various DOS path types
        do not work, see RtlRemoveLastDosPathElement for them.

Return Value:

    STATUS_SUCCESS - the usual hunky-dory
    STATUS_NO_MEMORY - the usual stress
    STATUS_INVALID_PARAMETER - the usual bug

--*/
{
    NTSTATUS Status = RtlpGetLengthWithoutLastPathElement(Flags, RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS_OR_NT, Path, LengthOut);
    return Status;
}

NTSTATUS
RtlpCheckForBadDosRootPath(
    IN ULONG             Flags,
    IN PCUNICODE_STRING  Path,
    OUT ULONG*           RootType
    )
/*++

Routine Description:

    
Arguments:

    Flags - room for future binary compatible expansion

    Path - the path to be checked

    RootType - fairly specifically what the string is
        RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX       - \\? or \\?\
        RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX   - \\?\unc or \\?\unc\
        RTLP_BAD_DOS_ROOT_PATH_NT_PATH              - \??\ but this i only a rough check
        RTLP_BAD_DOS_ROOT_PATH_MACHINE_NO_SHARE     - \\machine or \\?\unc\machine
        RTLP_GOOD_DOS_ROOT_PATH                     - none of the above, seems ok

Return Value:

    STATUS_SUCCESS - 
    STATUS_INVALID_PARAMETER -
        Path is NULL
        or Flags uses undefined values
--*/
{
    ULONG Length = 0;
    ULONG Index = 0;
    BOOLEAN Unc = FALSE;
    BOOLEAN Unc1 = FALSE;
    BOOLEAN Unc2 = FALSE;
    ULONG PiecesSeen = 0;

    if (RootType != NULL) {
        *RootType = 0;
    }

    if (!RTL_SOFT_VERIFY(Path != NULL) ||
        !RTL_SOFT_VERIFY(RootType != NULL) ||
        !RTL_SOFT_VERIFY(Flags == 0)) {

        return STATUS_INVALID_PARAMETER;
    }

    Length = Path->Length / sizeof(Path->Buffer[0]);

    if (Length < 3 || !RTL_IS_PATH_SEPARATOR(Path->Buffer[0])) {
        *RootType = RTLP_GOOD_DOS_ROOT_PATH;
        return STATUS_SUCCESS;
    }

    // prefix \??\ (heuristic, doesn't catch many NT paths)
    if (RtlPrefixUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpDosDevicesPrefix), RTL_CONST_CAST(PUNICODE_STRING)(Path), TRUE)) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_NT_PATH;
        return STATUS_SUCCESS;
    }

    if (!RTL_IS_PATH_SEPARATOR(Path->Buffer[1])) {
        *RootType = RTLP_GOOD_DOS_ROOT_PATH;
        return STATUS_SUCCESS;
    }

    // == \\?
    if (RtlEqualUnicodeString(Path, &RtlpWin32NtRoot, TRUE)) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX;
        return STATUS_SUCCESS;
    }
    if (RtlEqualUnicodeString(Path, &RtlpWin32NtRootSlash, TRUE)) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX;
        return STATUS_SUCCESS;
    }

    // == \\?\unc
    if (RtlEqualUnicodeString(Path, &RtlpWin32NtUncRoot, TRUE)) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX;
        return STATUS_SUCCESS;
    }
    if (RtlEqualUnicodeString(Path, &RtlpWin32NtUncRootSlash, TRUE)) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX;
        return STATUS_SUCCESS;
    }

    // prefix \\ or \\?\unc
    // must check the longer string first, or avoid the short circuit (| instead of ||)
    Unc1 = RtlPrefixUnicodeString(&RtlpWin32NtUncRootSlash, Path, TRUE);

    if (RTL_IS_PATH_SEPARATOR(Path->Buffer[1])) {
        Unc2 = TRUE;
    }
    else {
        Unc2 = FALSE;
    }

    Unc = Unc1 || Unc2;

    if (!Unc)  {
        *RootType = RTLP_GOOD_DOS_ROOT_PATH;
        return STATUS_SUCCESS;
    }

    //
    // it's unc, see if it is only a machine (note that it'd be really nice if FindFirstFile(\\machine\*)
    // just worked and we didn't have to care..)
    //
    
    // point index at a slash that precedes the machine, anywhere in the run of slashes,
    // but after the \\? stuff
    if (Unc1) {
        Index = (RtlpWin32NtUncRootSlash.Length / sizeof(RtlpWin32NtUncRootSlash.Buffer[0])) - 1;
    } else {
        ASSERT(Unc2);
        Index = 1;
    }
    ASSERT(RTL_IS_PATH_SEPARATOR(Path->Buffer[Index]));
    Length = Path->Length/ sizeof(Path->Buffer[0]);

    //
    // skip leading slashes
    //
    for ( ; Index < Length && RTL_IS_PATH_SEPARATOR(Path->Buffer[Index]) ; ++Index) {
        PiecesSeen |= 1;
    }
    // skip the machine name
    for ( ; Index < Length && !RTL_IS_PATH_SEPARATOR(Path->Buffer[Index]) ; ++Index) {
        PiecesSeen |= 2;
    }
    // skip the slashes between machine and share
    for ( ; Index < Length && RTL_IS_PATH_SEPARATOR(Path->Buffer[Index]) ; ++Index) {
        PiecesSeen |= 4;
    }

    //
    // Skip the share (make sure it's at least one char).
    //

    if (Index < Length && !RTL_IS_PATH_SEPARATOR(Path->Buffer[Index])) {
        PiecesSeen |= 8;
    }

    if (PiecesSeen != 0xF) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_MACHINE_NO_SHARE;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
NTAPI
RtlpBadDosRootPathToEmptyString(
    IN     ULONG            Flags,
    IN OUT PUNICODE_STRING  Path
    )
/*++

Routine Description:

    
Arguments:

    Flags - room for future binary compatible expansion

    Path - the path to be checked and possibly emptied

Return Value:

    STATUS_SUCCESS - 
    STATUS_INVALID_PARAMETER -
        Path is NULL
        or Flags uses undefined values
--*/
{
    NTSTATUS Status;
    ULONG    RootType = 0;

    UNREFERENCED_PARAMETER (Flags);

    Status = RtlpCheckForBadDosRootPath(0, Path, &RootType);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // this is not invalid parameter, our contract is we
    // go \\machine\share to empty \\?\c: to empty, etc.
    //

    if (RootType != RTLP_GOOD_DOS_ROOT_PATH) {
        if (RootType == RTLP_BAD_DOS_ROOT_PATH_NT_PATH) {
            return STATUS_INVALID_PARAMETER;
        }
        Path->Length = 0;
    }
    return STATUS_SUCCESS;
}


NTSTATUS
NTAPI
RtlGetLengthWithoutLastFullDosPathElement(
    IN  ULONG            Flags,
    IN  PCUNICODE_STRING Path,
    OUT ULONG*           LengthOut
    )
/*++

Routine Description:

    Given a fulldospath, like c:\, \\machine\share, \\?\unc\machine\share, \\?\c:,
    return (in an out parameter) the length if the last element was cut off.

Arguments:

    Flags - room for future binary compatible expansion

    Path - the path to be truncating

    LengthOut - the length if the last path element is removed

Return Value:

    STATUS_SUCCESS - 
    STATUS_INVALID_PARAMETER -
        Path is NULL
        or LengthOut is NULL
        or Flags uses undefined values
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING CheckRootString = { 0 };

    //
    // parameter validation is done in RtlpGetLengthWithoutLastPathElement
    //

    Status = RtlpGetLengthWithoutLastPathElement(Flags, RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS, Path, LengthOut);
    if (!(NT_SUCCESS(Status))) {
        goto Exit;
    }

    CheckRootString.Buffer = Path->Buffer;
    CheckRootString.Length = (USHORT)(*LengthOut * sizeof(*Path->Buffer));
    CheckRootString.MaximumLength = CheckRootString.Length;
    if (!NT_SUCCESS(Status = RtlpBadDosRootPathToEmptyString(0, &CheckRootString))) {
        goto Exit;
    }
    *LengthOut = RTL_STRING_GET_LENGTH_CHARS(&CheckRootString);

    Status = STATUS_SUCCESS;
Exit:
#if DBG
    DbgPrintEx(
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, Path, Status);
#endif
    return Status;
}


NTSTATUS
NTAPI
RtlAppendPathElement(
    IN     ULONG                      Flags,
    IN OUT PRTL_UNICODE_STRING_BUFFER Path,
    PCUNICODE_STRING                  ConstElement
    )
/*++

Routine Description:

    This function appends a path element to a path.
    For now, like:
        typedef PRTL_UNICODE_STRING_BUFFER PRTL_MUTABLE_PATH;
        typedef PCUNICODE_STRING           PCRTL_CONSTANT_PATH_ELEMENT;
    Maybe something higher level in the future.
    
    The result with regard to trailing slashes aims to be similar to the inputs.
    If either Path or ConstElement contains a trailing slash, the result has a trailing slash.
    The character used for the in between and trailing slash is picked among the existing
    slashes in the strings.

Arguments:

    Flags - the ever popular "room for future binary compatible expansion"

    Path -
        a string representing a path using \\ or / as seperators

    ConstElement -
        a string representing a path element
        this can actually contain multiple \\ or / delimited path elements
          only the start and end of the string are examined for slashes

Return Value:

    STATUS_SUCCESS - 
    STATUS_INVALID_PARAMETER -
        Path is NULL
        or LengthOut is NULL
    STATUS_NO_MEMORY - RtlHeapAllocate failed
    STATUS_NAME_TOO_LONG - the resulting string does not fit in a UNICODE_STRING, due to its
        use of USHORT instead of ULONG or SIZE_T
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING InBetweenSlashString = RtlpEmptyString;
    UNICODE_STRING TrailingSlashString =  RtlpEmptyString;
    WCHAR Slashes[] = {0,0,0,0};
    ULONG i;
    UNICODE_STRING PathsToAppend[3]; // possible slash, element, possible slash
    WCHAR PathSeperators[2] = { '/', '\\' };
    const ULONG ValidFlags = 
              RTL_APPEND_PATH_ELEMENT_ONLY_BACKSLASH_IS_SEPERATOR
            | RTL_APPEND_PATH_ELEMENT_BUGFIX_CHECK_FIRST_THREE_CHARS_FOR_SLASH_TAKE_FOUND_SLASH_INSTEAD_OF_FIRST_CHAR
            ;
    const ULONG InvalidFlags = ~ValidFlags;

#define LOCAL_IS_PATH_SEPARATOR(ch_) ((ch_) == PathSeperators[0] || (ch_) == PathSeperators[1])

    if (   !RTL_SOFT_VERIFY((Flags & InvalidFlags) == 0)
        || !RTL_SOFT_VERIFY(Path != NULL)
        || !RTL_SOFT_VERIFY(ConstElement != NULL)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ((Flags & RTL_APPEND_PATH_ELEMENT_ONLY_BACKSLASH_IS_SEPERATOR) != 0) {
        PathSeperators[0] = '\\';
    }

    if (ConstElement->Length != 0) {

        UNICODE_STRING Element = *ConstElement;

        //
        // Note leading and trailing slashes on the inputs.
        // So that we know if an in-between slash is needed, and if a trailing slash is needed,
        // and to guide what sort of slash to place.
        //
        i = 0;
        if (Path->String.Length != 0) {
            ULONG j;
            ULONG Length = Path->String.Length / sizeof(WCHAR);
            //
            // for the sake for dos drive paths, check the first three chars for a slash
            //
            for (j = 0 ; j < 3 && j  < Length ; ++j) {
                if (LOCAL_IS_PATH_SEPARATOR(Path->String.Buffer[j])) {
                    if (Flags & RTL_APPEND_PATH_ELEMENT_BUGFIX_CHECK_FIRST_THREE_CHARS_FOR_SLASH_TAKE_FOUND_SLASH_INSTEAD_OF_FIRST_CHAR) {
                        Slashes[i] = Path->String.Buffer[j];
                        break;
                    }
                    Slashes[i] = Path->String.Buffer[0];
                    break;
                }
            }
            i += 1;
            if (LOCAL_IS_PATH_SEPARATOR(Path->String.Buffer[Path->String.Length/sizeof(WCHAR) - 1])) {
                Slashes[i] = Path->String.Buffer[Path->String.Length/sizeof(WCHAR) - 1];
            }
        }
        i = 2;
        if (LOCAL_IS_PATH_SEPARATOR(Element.Buffer[0])) {
            Slashes[i] = Element.Buffer[0];
        }
        i += 1;
        if (LOCAL_IS_PATH_SEPARATOR(Element.Buffer[Element.Length/sizeof(WCHAR) - 1])) {
            Slashes[i] = Element.Buffer[Element.Length/sizeof(WCHAR) - 1];
        }

        if (!Slashes[1] && !Slashes[2]) {
            //
            // first string lacks trailing slash and second string lacks leading slash,
            // must insert one; we favor the types we have, otherwise use a default
            //
            InBetweenSlashString.Length = sizeof(WCHAR);
            InBetweenSlashString.Buffer = RtlPathSeperatorString.Buffer;
            if ((Flags & RTL_APPEND_PATH_ELEMENT_ONLY_BACKSLASH_IS_SEPERATOR) == 0) {
                if (Slashes[3]) {
                    InBetweenSlashString.Buffer = &Slashes[3];
                } else if (Slashes[0]) {
                    InBetweenSlashString.Buffer = &Slashes[0];
                }
            }
        }

        if (Slashes[1] && !Slashes[3]) {
            //
            // first string has a trailing slash and second string does not,
            // must add one, the same type
            //
            TrailingSlashString.Length = sizeof(WCHAR);
            if ((Flags & RTL_APPEND_PATH_ELEMENT_ONLY_BACKSLASH_IS_SEPERATOR) == 0) {
                TrailingSlashString.Buffer = &Slashes[1];
            } else {
                TrailingSlashString.Buffer = RtlPathSeperatorString.Buffer;
            }
        }

        if (Slashes[1] && Slashes[2]) {
            //
            // have both trailing and leading slash, remove leading
            //
            Element.Buffer += 1;
            Element.Length -= sizeof(WCHAR);
            Element.MaximumLength -= sizeof(WCHAR);
        }

        i = 0;
        PathsToAppend[i++] = InBetweenSlashString;
        PathsToAppend[i++] = Element;
        PathsToAppend[i++] = TrailingSlashString;
        Status = RtlMultiAppendUnicodeStringBuffer(Path, RTL_NUMBER_OF(PathsToAppend), PathsToAppend);
        if (!NT_SUCCESS(Status))
            goto Exit;
    }
    Status = STATUS_SUCCESS;
Exit:
#if DBG
    DbgPrintEx(
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ, %wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, Path ? &Path->String : NULL, ConstElement, Status);
#endif
    return Status;
#undef LOCAL_IS_PATH_SEPARATOR
}

//
// FUTURE-2002/02/20-ELi
// Spelling mistake (Separators)
// This function does not appear to be used and is exported
// Figure out if it can be removed
//
NTSTATUS
NTAPI
RtlGetLengthWithoutTrailingPathSeperators(
    IN  ULONG            Flags,
    IN  PCUNICODE_STRING Path,
    OUT ULONG*           LengthOut
    )
/*++

Routine Description:

    This function computes the length of the string (in characters) if
    trailing path seperators (\\ and /) are removed.

Arguments:

    Path -
        a string representing a path using \\ or / as seperators

    LengthOut -
        the length of String (in characters) having removed trailing characters

Return Value:

    STATUS_SUCCESS - 
    STATUS_INVALID_PARAMETER -
        Path is NULL
        or LengthOut is NULL
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index = 0;
    ULONG Length = 0;

    if (LengthOut != NULL) {
        //
        // Arguably this should be Path->Length / sizeof(*Path->Buffer), but as long
        // as the callstack is all high quality code, it doesn't matter.
        //
        *LengthOut = 0;
    }
    if (   !RTL_SOFT_VERIFY(Path != NULL)
        || !RTL_SOFT_VERIFY(LengthOut != NULL)
        || !RTL_SOFT_VERIFY(Flags == 0)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    Length = Path->Length / sizeof(*Path->Buffer);
    for (Index = Length ; Index != 0 ; --Index) {
        if (!RTL_IS_PATH_SEPARATOR(Path->Buffer[Index - 1])) {
            break;
        }
    }
    //*LengthOut = (Length - Index);
    *LengthOut = Index;

    Status = STATUS_SUCCESS;
Exit:
#if DBG
    DbgPrintEx(
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, Path, Status);
#endif
    return Status;
}


NTSTATUS
NTAPI
RtlpApplyLengthFunction(
    IN ULONG     Flags,
    IN SIZE_T    SizeOfStruct,
    IN OUT PVOID UnicodeStringOrUnicodeStringBuffer,
    NTSTATUS (NTAPI* LengthFunction)(ULONG, PCUNICODE_STRING, ULONG*)
    )
/*++

Routine Description:

    This function is common code for patterns like
        #define RtlRemoveTrailingPathSeperators(Path_) \
            (RtlpApplyLengthFunction((Path_), sizeof(*(Path_)), RtlGetLengthWithoutTrailingPathSeperators))

    #define RtlRemoveLastPathElement(Path_) \
        (RtlpApplyLengthFunction((Path_), sizeof(*(Path_)), RtlGetLengthWithoutLastPathElement))

    Note that shortening a UNICODE_STRING only changes the length, whereas
    shortening a RTL_UNICODE_STRING_BUFFER writes a terminal nul.

    I expect this pattern will be less error prone than having clients pass the UNICODE_STRING
    contained in the RTL_UNICODE_STRING_BUFFER followed by calling RTL_NUL_TERMINATE_STRING.

    And, that pattern cannot be inlined with a macro while also preserving that we
    return an NTSTATUS.

Arguments:

    Flags - the ever popular "room for future binary compatible expansion"

    UnicodeStringOrUnicodeStringBuffer - 
        a PUNICODE_STRING or PRTL_UNICODE_STRING_BUFFER, as indicated by
        SizeOfStruct

    SizeOfStruct - 
        a rough type indicator of UnicodeStringOrUnicodeStringBuffer, to allow for overloading in C

    LengthFunction -
        computes a length for UnicodeStringOrUnicodeStringBuffer to be shortened too

Return Value:

    STATUS_SUCCESS - 
    STATUS_INVALID_PARAMETER -
        SizeOfStruct not one of the expected sizes
        or LengthFunction is NULL
        or UnicodeStringOrUnicodeStringBuffer is NULL


--*/
{
    PUNICODE_STRING UnicodeString = NULL;
    PRTL_UNICODE_STRING_BUFFER UnicodeStringBuffer = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Length = 0;

    if (!RTL_SOFT_VERIFY(UnicodeStringOrUnicodeStringBuffer != NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (!RTL_SOFT_VERIFY(LengthFunction != NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (!RTL_SOFT_VERIFY(Flags == 0)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    switch (SizeOfStruct)
    {
        default:
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        case sizeof(*UnicodeString):
            UnicodeString = UnicodeStringOrUnicodeStringBuffer;
            break;
        case sizeof(*UnicodeStringBuffer):
            UnicodeStringBuffer = UnicodeStringOrUnicodeStringBuffer;
            UnicodeString = &UnicodeStringBuffer->String;
            break;
    }

    Status = (*LengthFunction)(Flags, UnicodeString, &Length);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    if (Length > (UNICODE_STRING_MAX_BYTES / sizeof(UnicodeString->Buffer[0])) ) {
        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }
    UnicodeString->Length = (USHORT)(Length * sizeof(UnicodeString->Buffer[0]));
    if (UnicodeStringBuffer != NULL) {
        RTL_NUL_TERMINATE_STRING(UnicodeString);
    }
    Status = STATUS_SUCCESS;
Exit:
#if DBG
    DbgPrintEx(
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, UnicodeString, Status);
#endif
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sources.inc.

!ENDIF

TARGETNAME=setupdd
TARGETPATH=obj
TARGETTYPE=EXPORT_DRIVER

DLLDEF=..\setupdd.def

INCLUDES=..;          \
 ..\i386;             \
 ..\..\inc;           \
 ..\..\user\$(O);     \
 ..\..\..\inc;        \
 ..\..\user;          \
 $(NET_INC_PATH);     \
 $(BASE_INC_PATH);    \
 $(DS_INC_PATH);      \
 $(DDK_INC_PATH);     \
 $(DRIVERS_INC_PATH); \
 $(PROJECT_ROOT)\ntos\inc;

SOURCES=\
 ..\rtl_buffer.c \
 ..\rtl_error.c \
 ..\rtl_path.c  \
 ..\rtl_findcharinunicodestring.c \
 ..\rtl_validateunicodestring.c \
 ..\spasmcabs.c \
 ..\diamond.c   \
 ..\graphics.c  \
 ..\dynupdt.c   \
 ..\sparc.c     \
 ..\spboot.c    \
 ..\spconfig.c  \
 ..\spcopy.c    \
 ..\spdblspc.c  \
 ..\spdisk.c    \
 ..\spdriver.c  \
 ..\spdsputl.c  \
 ..\spfatfmt.c  \
 ..\spfile.c    \
 ..\spfontup.c  \
 ..\spfsrec.c   \
 ..\spgauge.c   \
 ..\sphelp.c    \
 ..\sphw.c      \
 ..\spkbd.c     \
 ..\splddrv.c   \
 ..\spmemory.c  \
 ..\spmenu.c    \
 ..\spmsg.c     \
 ..\spnetupg.c  \
 ..\spntfix.c   \
 ..\spnttree.c  \
 ..\spntupg.c   \
 ..\sppart2.c   \
 ..\sppartit.c  \
 ..\sppart3.c   \
 ..\spswitch.c  \
 ..\spptdump.c  \
 ..\spptwrt.c   \
 ..\spreg.c     \
 ..\spres.rc    \
 ..\spsetup.c   \
 ..\spsif.c     \
 ..\spstring.c  \
 ..\spsysprp.c  \
 ..\sptarget.c  \
 ..\sptxtfil.c  \
 ..\spudp.c     \
 ..\spupgcfg.c  \
 ..\sputil.c    \
 ..\spvideo.c   \
 ..\spvidfb.c   \
 ..\spvidvga.c  \
 ..\spdrsif.c   \
 ..\spdrpset.c  \
 ..\spdrmmgr.c  \
 ..\spdr.c      \
 ..\spdrutil.c  \
 ..\spterm.c    \
 ..\spres.rc    \
 ..\spcab.c     \
 ..\spwin.c     \
 ..\spprintf.c  \

PRECOMPILED_INCLUDE=..\spprecmp.h

!IF $(IA64)
C_DEFINES= $(C_DEFINES) -DUNICODE_SETUPLDR -DEFI_NVRAM_ENABLED
!ENDIF

C_DEFINES=$(C_DEFINES) -DTRY_ALL_COMPRESSION_ALGORITHMS=0

TARGETLIBS= \
    $(PROJECT_ROOT)\ntsetup\complnce\kernel\$(O)\complnce_k.lib \
    $(SDK_LIB_PATH)\fdi.lib    \
    $(SDK_LIB_PATH)\fci.lib    \
    ..\..\spddlang\sbcs\$(O)\spddlang.lib  \
    $(BASE_LIB_PATH)\patchbc.lib    \
    $(BASE_LIB_PATH)\bootvid.lib \

#
# Definition of PRERELEASE
#

!include $(PROJECT_ROOT)\ntsetup\sources.inc

# No overflow detection in textmode setup
BUFFER_OVERFLOW_CHECKS=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sparc.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    sparc.h

Abstract:

    Header file for functions to deal with ARC paths and variables.

Author:

    Ted Miller (tedm) 22-Sep-1993

Revision History:

--*/


#ifndef _SPARC_DEFN_
#define _SPARC_DEFN_

VOID
SpInitializeArcNames(
    PVIRTUAL_OEM_SOURCE_DEVICE  OemDevices
    );

VOID
SpFreeArcNames(
    VOID
    );

PWSTR
SpArcToNt(
    IN PWSTR ArcPath
    );

PWSTR
SpNtToArc(
    IN PWSTR            NtPath,
    IN ENUMARCPATHTYPE  ArcPathType
    );

PWSTR
SpScsiArcToMultiArc(
    IN PWSTR ArcPath
    );

PWSTR
SpMultiArcToScsiArc(
    IN PWSTR ArcPath
    );

PWSTR
SpNormalizeArcPath(
    IN PWSTR Path
    );

VOID
SpGetEnvVarComponents (
    IN  PCHAR    EnvValue,
    OUT PCHAR  **EnvVarComponents,
    OUT PULONG   PNumComponents
    );

VOID
SpGetEnvVarWComponents(
    IN  PCHAR    EnvValue,
    OUT PWSTR  **EnvVarComponents,
    OUT PULONG   PNumComponents
    );

VOID
SpFreeEnvVarComponents (
    IN PVOID *EnvVarComponents
    );

#endif // ndef _SPARC_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sparc.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    sparc.c

Abstract:

    Functions to deal with ARC paths and variables.

Author:

    Ted Miller (tedm) 22-Sep-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

//
// Define maximum number of components in a semi-colon separated list
// of arc paths.
//
#define MAX_COMPONENTS 20

//
// We maintain a list of all arcnames in the system and their NT equivalents.
// This makes translations very easy.
//
typedef struct _ARCNAME_TRANSLATION {

    struct _ARCNAME_TRANSLATION *Next;

    PWSTR ArcPath;
    PWSTR NtPath;

} ARCNAME_TRANSLATION, *PARCNAME_TRANSLATION;

PARCNAME_TRANSLATION ArcNameTranslations;


//
// Function prototypes.
//
VOID
SppFreeComponents(
    IN PVOID *EnvVarComponents
    );

VOID
SppInitializeHardDiskArcNames(
    VOID
    );

extern PSETUP_COMMUNICATION CommunicationParams;

VOID
SpInitializeArcNames(
    PVIRTUAL_OEM_SOURCE_DEVICE  OemDevices
    )
{
    UNICODE_STRING UnicodeString;
    HANDLE DirectoryHandle;
    HANDLE ObjectHandle;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    BOOLEAN RestartScan;
    ULONG Context;
    BOOLEAN MoreEntries;
    PWSTR ArcName;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    WCHAR ArcNameDirectory[] = L"\\ArcName";
    PARCNAME_TRANSLATION Translation;

    //
    // Only call this routine once.
    //
    ASSERT(ArcNameTranslations == NULL);

    //
    // First, do hard disks specially.  For each hard disk in the system,
    // open it and check its signature against those in the firmware
    // disk information.
    //
    SppInitializeHardDiskArcNames();

    //
    // Open the \ArcName directory.
    //
    INIT_OBJA(&Obja,&UnicodeString,ArcNameDirectory);

    Status = ZwOpenDirectoryObject(&DirectoryHandle,DIRECTORY_ALL_ACCESS,&Obja);

    if(NT_SUCCESS(Status)) {

        RestartScan = TRUE;
        Context = 0;
        MoreEntries = TRUE;

        do {

            Status = SpQueryDirectoryObject(
                        DirectoryHandle,
                        RestartScan,
                        &Context
                        );

            if(NT_SUCCESS(Status)) {

                DirInfo = (POBJECT_DIRECTORY_INFORMATION)
                            ((PSERVICE_QUERY_DIRECTORY_OBJECT)&CommunicationParams->Buffer)->Buffer;

                SpStringToLower(DirInfo->Name.Buffer);

                //
                // Make sure this name is a symbolic link.
                //
                if(DirInfo->Name.Length
                && (DirInfo->TypeName.Length >= (sizeof(L"SymbolicLink") - sizeof(WCHAR)))
                && !_wcsnicmp(DirInfo->TypeName.Buffer,L"SymbolicLink",12))
                {
                    ArcName = SpMemAlloc(DirInfo->Name.Length + sizeof(ArcNameDirectory) + sizeof(WCHAR));

                    wcscpy(ArcName,ArcNameDirectory);
                    SpConcatenatePaths(ArcName,DirInfo->Name.Buffer);

                    //
                    // We have the entire arc name in ArcName.  Now open it as a symbolic link.
                    //
                    INIT_OBJA(&Obja,&UnicodeString,ArcName);

                    Status = ZwOpenSymbolicLinkObject(
                                &ObjectHandle,
                                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                &Obja
                                );

                    if(NT_SUCCESS(Status)) {

                        //
                        // Finally, query the object to get the link target.
                        //
                        UnicodeString.Buffer = TemporaryBuffer;
                        UnicodeString.Length = 0;
                        UnicodeString.MaximumLength = sizeof(TemporaryBuffer);

                        Status = ZwQuerySymbolicLinkObject(
                                    ObjectHandle,
                                    &UnicodeString,
                                    NULL
                                    );

                        if(NT_SUCCESS(Status)) {

                            //
                            // nul-terminate the returned string
                            //
                            UnicodeString.Buffer[UnicodeString.Length/sizeof(WCHAR)] = 0;

                            //
                            // Ignore this entry if it's a hard disk or hard disk partition.
                            //
                            if(_wcsnicmp(UnicodeString.Buffer,L"\\Device\\Harddisk",16)) {

                                //
                                // Create an arcname translation entry.
                                //
                                Translation = SpMemAlloc(sizeof(ARCNAME_TRANSLATION));
                                Translation->Next = ArcNameTranslations;
                                ArcNameTranslations = Translation;

                                //
                                // Leave out the \ArcName\ part.
                                //
                                Translation->ArcPath = SpNormalizeArcPath(
                                                            ArcName
                                                          + (sizeof(ArcNameDirectory)/sizeof(WCHAR))
                                                            );

                                Translation->NtPath = SpDupStringW(UnicodeString.Buffer);
                            }

                        } else {
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to query symbolic link %ws (%lx)\n",ArcName,Status));
                        }

                        ZwClose(ObjectHandle);
                    } else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open symbolic link %ws (%lx)\n",ArcName,Status));
                    }

                    SpMemFree(ArcName);
                }

            } else {

                MoreEntries = FALSE;
                if(Status == STATUS_NO_MORE_ENTRIES) {
                    Status = STATUS_SUCCESS;
                }
            }

            RestartScan = FALSE;

        } while(MoreEntries);

        ZwClose(DirectoryHandle);

    } else {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open \\ArcName directory (%lx)\n",Status));
    }

    //
    // Add OEM virtual device arc name translations if any at
    // the front of the list
    //
    if (NT_SUCCESS(Status) && OemDevices) {
        PVIRTUAL_OEM_SOURCE_DEVICE  CurrDevice = OemDevices;
        WCHAR   RamDeviceName[MAX_PATH];

        while (CurrDevice) {
            PARCNAME_TRANSLATION NewTranslation;

            NewTranslation = SpMemAlloc(sizeof(ARCNAME_TRANSLATION));

            if (!NewTranslation) {
                Status = STATUS_NO_MEMORY;
                break;
            }                

            //
            // create the new translation
            //            
            RamDeviceName[0] = UNICODE_NULL;
            RtlZeroMemory(NewTranslation, sizeof(ARCNAME_TRANSLATION));

            NewTranslation->ArcPath = SpDupStringW(CurrDevice->ArcDeviceName);

            swprintf(RamDeviceName, L"%ws%d", RAMDISK_DEVICE_NAME, CurrDevice->DeviceId);
            NewTranslation->NtPath = SpDupStringW(RamDeviceName);

            //
            // add the new translation at the start of the linked list
            //
            NewTranslation->Next = ArcNameTranslations;
            ArcNameTranslations = NewTranslation;

            //
            // process the next device
            //
            CurrDevice = CurrDevice->Next;
        }
    }    

    //
    // If we couldn't gather arcname translations, something is
    // really wrong with the system.
    //
    if(!NT_SUCCESS(Status)) {

        SpStartScreen(
                SP_SCRN_COULDNT_INIT_ARCNAMES,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE
                );
        if(KbdLayoutInitialized) {
            SpContinueScreen(
                    SP_SCRN_F3_TO_REBOOT,
                    3,
                    1,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );
            SpDisplayStatusText(SP_STAT_F3_EQUALS_EXIT, DEFAULT_STATUS_ATTRIBUTE);
            SpInputDrain();
            while(SpInputGetKeypress() != KEY_F3);
            SpDone(0, FALSE, TRUE);
        } else {
            //
            // we haven't loaded the layout dll yet, so we can't prompt for a keypress to reboot
            //
            SpContinueScreen(
                    SP_SCRN_POWER_DOWN,
                    3,
                    1,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );

            SpDisplayStatusText(SP_STAT_KBD_HARD_REBOOT, DEFAULT_STATUS_ATTRIBUTE);

            while(TRUE);    // Loop forever
        }
    }
}


VOID
SpFreeArcNames(
    VOID
    )
{
    PARCNAME_TRANSLATION pTrans,pNext;

    for(pTrans=ArcNameTranslations; pTrans; pTrans=pNext) {

        pNext = pTrans->Next;

        SpMemFree(pTrans->ArcPath);
        SpMemFree(pTrans->NtPath);
        SpMemFree(pTrans);
    }

    ArcNameTranslations = NULL;
}


VOID
SppInitializeHardDiskArcNames(
    VOID
    )
/*++

Routine Description:

    This routine attempts to match NT-visible hard disks to their
    firmware-visible ARC equivalents.  The basic algorithm is as
    follows:

        A match occurs when the disk's signature, checksum, and
        valid partition indicator match the values passed by
        setupldr in the ARC_DISK_INFORMATION structure.

        If no match for the NT disk is found, no arcname is
        created.  Thus, the user may not install NT onto this
        drive.  (the case where the disk will be made visible
        to NTLDR through the installation of NTBOOTDD.SYS is
        a special case that is handled separately)

        If a single match is found, we have found a simple
        ARC<->NT translation.  The arcname is created.

        If more than one match is found, we have a complicated
        ARC<->NT translation.  We assume that there is only one
        valid arcname for any disk.  (This is a safe assumption
        only when we booted via SETUPLDR, since NTLDR may load
        NTBOOTDD.SYS and cause SCSI disks that have the BIOS
        enabled to be visible through both a scsi()... name and
        a multi()... name.)  Thus this means we have two disks
        in the system whose first sector is identical.  In this
        case we do some heuristic comparisons between the ARC
        name and the NT name to attempt to resolve this.

Arguments:

    None.  All ARC name translations will be added to the global
           ArcNameTranslations list.

Return Value:

    None.

--*/

{
    PWSTR DiskName;
    ULONG disk;
    ULONG DiskCount;
    PARCNAME_TRANSLATION Translation;
    HANDLE hPartition;
    NTSTATUS Status;
    PVOID Buffer;
    IO_STATUS_BLOCK StatusBlock;
    ULONG BufferSize;
    PDISK_GEOMETRY Geometry;
    LARGE_INTEGER Offset;
    BOOLEAN ValidPartitionTable;
    ULONG Signature;
    ULONG i;
    ULONG Checksum;
    PDISK_SIGNATURE_INFORMATION DiskSignature;
    PDISK_SIGNATURE_INFORMATION DupSignature;

    //
    // Allocate buffer for disk name.
    //
    DiskName = SpMemAlloc(64 * sizeof(WCHAR));

    DiskCount = IoGetConfigurationInformation()->DiskCount;

    //
    // For each hard disk in the system, open partition 0 and read sector 0.
    //
    for(disk=0; disk<DiskCount; disk++) {

#if defined(_AMD64_) || defined(_X86_)
        BOOLEAN Matched = FALSE;
        
        enum {
            NoEZDisk,
            EZDiskDetected,
            NeedToMark
        };

        CHAR EZDiskStatus = NoEZDisk;
#endif // defined(_AMD64_) || defined(_X86_)

        swprintf(DiskName, L"\\Device\\HardDisk%u", disk);

        //
        // open the partition read-write since we may need to mark EZDISKs
        //
        Status = SpOpenPartition(DiskName,0,&hPartition,TRUE);

        if(NT_SUCCESS(Status)) {

            //
            // Initially use a 1k buffer to read partition information.
            //
            BufferSize = 1024;
            Buffer = TemporaryBuffer;
            //
            // Issue device control to get partition information.
            //
retrydevctrl:
            RtlZeroMemory(Buffer, BufferSize);
            Status = ZwDeviceIoControlFile( hPartition,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &StatusBlock,
                                            IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                            NULL,
                                            0,
                                            Buffer,
                                            BufferSize );
            if (Status==STATUS_BUFFER_TOO_SMALL) {

                //
                // Double buffer size and try again.
                //
                BufferSize = BufferSize * 2;
                ASSERT(BufferSize <= sizeof(TemporaryBuffer));

                goto retrydevctrl;
            }

            Geometry = (PDISK_GEOMETRY)Buffer;
            if (!NT_SUCCESS(Status) || (0 == Geometry->BytesPerSector)) {
                //
                // Skip this disk
                //
                goto errSkipDisk;
            }

            //
            // Read the first two sectors off the drive.
            //
            BufferSize = Geometry->BytesPerSector;
            Buffer = ALIGN(Buffer, BufferSize);
            Offset.QuadPart = 0;

            Status = ZwReadFile(hPartition,
                                NULL,
                                NULL,
                                NULL,
                                &StatusBlock,
                                Buffer,
                                BufferSize * 2,
                                &Offset,
                                NULL);
            if (!NT_SUCCESS(Status)) {
                //
                // Skip this disk
                //
                goto errSkipDisk;
            }

#if defined(_AMD64_) || defined(_X86_)
            //
            // Check for EZDrive disk.  If we have one, use sector 1
            // instead of sector 0.
            //
            // We do this only on amd64/x86 because the firmware doesn't
            // know about EZDrive, and so we must use sector 0 to match what
            // the firmware did.
            //
            if((BufferSize >= 512)
            && (((PUSHORT)Buffer)[510 / 2] == 0xaa55)
            && ((((PUCHAR)Buffer)[0x1c2] == 0x54) || (((PUCHAR)Buffer)[0x1c2] == 0x55))) {
                EZDiskStatus = EZDiskDetected;

ezdisk:
                //
                // we need to try sector 1
                //
                Buffer = (PUCHAR) Buffer + BufferSize;
            }
#endif // defined(_AMD64_) || defined(_X86_)

            //
            // Now we have the sector, we can compute the signature,
            // the valid partition indicator, and the checksum.
            //

            if (!IsNEC_98) { //NEC98
                Signature = ((PULONG)Buffer)[PARTITION_TABLE_OFFSET/2-1];
            } //NEC98

            if ((!IsNEC_98) ? (((PUSHORT)Buffer)[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) :
                              ((((PUSHORT)Buffer)[BufferSize/2 - 1 ] != BOOT_RECORD_SIGNATURE) ||
                               (BufferSize == 256))) { //NEC98
                ValidPartitionTable = FALSE;
            } else {
                ValidPartitionTable = TRUE;
            }


            Checksum = 0;
            for (i=0;i<128;i++) {
                Checksum += ((PULONG)Buffer)[i];
            }
            Checksum = 0-Checksum;

            //
            // Scan the list of arc disk information attempting to match
            // signatures
            //


            //
            // Dump the signature info:
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SppInitializeHardDiskArcNames : About to start searching for disk with signature: 0x%08lx\n", Signature));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SppInitializeHardDiskArcNames : About to start searching for disk with checksum: 0x%08lx\n", Checksum));
            DiskSignature = DiskSignatureInformation;
            i = 0;
            while( DiskSignature != NULL ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SppInitializeHardDiskArcNames : Signature Info %d\n================================================\n", i ));
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "    Signature: 0x%08lx\n", DiskSignature->Signature ));
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "     CheckSum: 0x%08lx\n", DiskSignature->CheckSum ));
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "      ArcPath: %ws\n", DiskSignature->ArcPath ));
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "       xInt13: %ws\n\n", DiskSignature->xInt13 ? L"yes" : L"no" ));
                i++;
                DiskSignature = DiskSignature->Next;
            }
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "\n\n"));


            DiskSignature = DiskSignatureInformation;
            while (DiskSignature != NULL) {

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "    SppInitializeHardDiskArcNames : Current signature: 0x%08lx\n", DiskSignature->Signature));
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "    SppInitializeHardDiskArcNames : Current checksum: 0x%08lx\n", DiskSignature->CheckSum));
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "    SppInitializeHardDiskArcNames : Current ArcPath: %ws\n", DiskSignature->ArcPath));

                if( DiskSignature->Signature == Signature ) {

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "        SppInitializeHardDiskArcNames : We matched signatures.\n"));

                    if( DiskSignature->ValidPartitionTable == ValidPartitionTable ) {

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "            SppInitializeHardDiskArcNames : The partition is valid.\n"));

                        //
                        // Match the checksum only on non-GPT disks since the protective MBR may have been modified
                        //
                        if( DiskSignature->IsGPTDisk || DiskSignature->CheckSum == Checksum ) {


                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                SppInitializeHardDiskArcNames : We matched the checksum.\n"));


                            //
                            // Found the first match, check for another match
                            //
                            DupSignature = DiskSignature->Next;
                            while (DupSignature != NULL) {
                                if ((DupSignature->Signature == Signature) &&
                                    (DupSignature->ValidPartitionTable == ValidPartitionTable) &&
                                    (DiskSignature->IsGPTDisk || DupSignature->CheckSum == Checksum)) {


                                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                    SppInitializeHardDiskArcNames : We found a second match!\n"));


                                    //
                                    // Found a second match.
                                    // For amd64/x86, we assume that \Device\HardDisk<n> will usually
                                    // correspond to multi(0)disk(0)rdisk(<n>).  On ARC, we will rely on
                                    // setupldr to guarantee uniqueness (since we can't install to anything
                                    // ARC firmware can't see, this is OK).
                                    //
#if defined(_AMD64_) || defined(_X86_)
                                    if (!IsNEC_98) { //NEC98
                                        PWSTR DupArcName;
                                        ULONG MatchLen;

                                        DupArcName = SpMemAlloc(64 * sizeof(WCHAR));
                                        MatchLen = swprintf(DupArcName, L"multi(0)disk(0)rdisk(%u)", disk);


                                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                        SppInitializeHardDiskArcNames : 2nd match's arcname: %ws\n", DupArcName));
                                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                        SppInitializeHardDiskArcNames : Current arcpath: %ws\n", DiskSignature->ArcPath));


                                        if(_wcsnicmp(DupArcName, DiskSignature->ArcPath, MatchLen)) {
                                            //
                                            // If our first match isn't the right one, continue searching.
                                            //
                                            DiskSignature = NULL;

                                            while(DupSignature) {

                                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                            SppInitializeHardDiskArcNames : Current arcname: %ws\n", DupSignature->ArcPath));
                                                if(!_wcsnicmp(DupArcName, DupSignature->ArcPath, MatchLen)) {

                                                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                                SppInitializeHardDiskArcNames : We matched the ArcPath.\n"));
                                                    DiskSignature = DupSignature;
                                                    break;

                                                } else {

                                                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                                SppInitializeHardDiskArcNames : We didn't match the ArcPath.\n"));

                                                }
                                                DupSignature = DupSignature->Next;
                                            }

                                            if(!DiskSignature) {

                                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SppInitializeHardDiskArcNames : We have 2 matching signatures and checksums, but couldn't find any matching ArcPaths.\n"));
                                                SpBugCheck(SETUP_BUGCHECK_BOOTPATH, 1, 0, 0);
                                            }
                                        }

                                        SpMemFree(DupArcName);
                                        break;

                                    } else {
                                        SpBugCheck(SETUP_BUGCHECK_BOOTPATH, 1, 0, 0); //NEC98
                                    }
#else
                                    SpBugCheck(SETUP_BUGCHECK_BOOTPATH, 1, 0, 0);
#endif // defined(_AMD64_) || defined(_X86_)
                                }

                                DupSignature = DupSignature->Next;
                            }

                            //
                            // We have the match
                            //
#if defined(_AMD64_) || defined(_X86_)
                            Matched = TRUE;
                            Status = STATUS_SUCCESS;

                            //
                            // try to mark the EZDisk if needed; if this fails, we won't create the translation
                            //
                            if(NeedToMark == EZDiskStatus) {
                                //
                                // Need to stamp 0x55 to make this type of EZDisk detectable by other components.
                                //
                                Buffer = (PUCHAR) Buffer - BufferSize;
                                ((PUCHAR) Buffer)[0x1c2] = 0x55;
                                Offset.QuadPart = 0;
                                Status = ZwWriteFile(hPartition, NULL, NULL, NULL, &StatusBlock, Buffer, BufferSize, &Offset, NULL);

                                if(NT_SUCCESS(Status)) {
                                    //
                                    // Shutdown now to give the user a chance to reboot textmode from harddisk.
                                    // Cannot wait here since the keyboard is not yet functional.
                                    //
                                    SpDone(SP_SCRN_AUTOCHK_REQUIRES_REBOOT, TRUE, FALSE);
                                }
                            }

                            if(NT_SUCCESS(Status))
#endif // defined(_AMD64_) || defined(_X86_)
                            {
                                //
                                // create the translation
                                //
                                Translation = SpMemAlloc(sizeof(ARCNAME_TRANSLATION));
                                Translation->Next = ArcNameTranslations;
                                ArcNameTranslations = Translation;

                                Translation->ArcPath = SpDupStringW(DiskSignature->ArcPath);
                                Translation->NtPath  = SpDupStringW(DiskName);
                            }


                            break;




                        } else {
                            //
                            // checksum test.
                            //
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                SppInitializeHardDiskArcNames : We didn't match the checksum.\n"));
                        }
                        } else {
                            //
                            // validity test.
                            //
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "            SppInitializeHardDiskArcNames : The partition isn't valid.\n"));
                    }
                } else {
                    //
                    // Signature test.
                    //
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "        SppInitializeHardDiskArcNames : We didn't match signatures.\n"));
                }

                DiskSignature = DiskSignature->Next;
            }

#if defined(_AMD64_) || defined(_X86_)
            if(!Matched && NoEZDisk == EZDiskStatus) {
                //
                // no match; there may be an undetected variant of EZDisk that we may need to mark
                //
                EZDiskStatus = NeedToMark;
                goto ezdisk;
            }
#endif // defined(_AMD64_) || defined(_X86_)

errSkipDisk:
            ZwClose(hPartition);
        }
    }

    SpMemFree(DiskName);
}


PWSTR
pSpArcToNtWorker(
    IN PWSTR CompleteArcPath,
    IN PWSTR ArcPathPrefix,
    IN PWSTR NtPathPrefix
    )
{
    ULONG matchLen;
    PWSTR translatedPath;
    PWSTR q,RestOfPath;

    translatedPath = NULL;
    matchLen = wcslen(ArcPathPrefix);

    //
    // We must take care the case that ArcPathPrefix has no value.
    // _wcsnicmp() will return zero, when matchLen is zero.
    //
    if(matchLen && !_wcsnicmp(ArcPathPrefix,CompleteArcPath,matchLen)) {

        translatedPath = SpMemAlloc(2048);

        wcscpy(translatedPath,NtPathPrefix);

        RestOfPath = CompleteArcPath + matchLen;

        //
        // If the next component is partition(n), convert that to partitionn.
        //
        if(!_wcsnicmp(RestOfPath,L"partition(",10)) {

            if(q = wcschr(RestOfPath+10,L')')) {

                *q = 0;

                SpConcatenatePaths(translatedPath,L"partition");
                wcscat(translatedPath,RestOfPath+10);

                *q = ')';

                RestOfPath = q+1;
            }
        }

        if(*RestOfPath) {       // avoid trailing backslash.
            SpConcatenatePaths(translatedPath,RestOfPath);
        }

        q = translatedPath;
        translatedPath = SpDupStringW(q);
        SpMemFree(q);
    }

    return(translatedPath);
}


PWSTR
pSpNtToArcWorker(
    IN PWSTR CompleteNtPath,
    IN PWSTR NtPathPrefix,
    IN PWSTR ArcPathPrefix
    )
{
    ULONG matchLen;
    PWSTR translatedPath;
    PWSTR p,RestOfPath;

    translatedPath = NULL;
    matchLen = wcslen(NtPathPrefix);

    //
    // We must take care the case that NtPathPrefix has no value.
    // _wcsnicmp() will return zero, when matchLen is zero.
    //
    if(matchLen && !_wcsnicmp(NtPathPrefix,CompleteNtPath,matchLen) && ((*(CompleteNtPath + matchLen) == L'\\') || (*(CompleteNtPath + matchLen) == L'\0'))) {

        translatedPath = SpMemAlloc(2048);

        wcscpy(translatedPath,ArcPathPrefix);

        RestOfPath = CompleteNtPath + matchLen;

        //
        // If the next component is partitionn, convert that to partition(n).
        //
        if(!_wcsnicmp(RestOfPath,L"\\partition",10)) {

            WCHAR c;

            //
            // Figure out where the partition ordinal ends.
            //
            SpStringToLong(RestOfPath+10,&p,10);

            c = *p;
            *p = 0;

            wcscat(translatedPath,L"partition(");
            wcscat(translatedPath,RestOfPath+10);
            wcscat(translatedPath,L")");

            *p = c;
            RestOfPath = p;
        }

        if(*RestOfPath) {       // avoid trailing backslash.
            SpConcatenatePaths(translatedPath,RestOfPath);
        }

        p = translatedPath;
        translatedPath = SpDupStringW(p);
        SpMemFree(p);
    }

    return(translatedPath);
}


PWSTR
SpArcToNt(
    IN PWSTR ArcPath
    )
{
    PARCNAME_TRANSLATION Translation;
    PWSTR NormalizedArcPath;
    PWSTR Result;

    NormalizedArcPath = SpNormalizeArcPath(ArcPath);
    Result = NULL;

    for(Translation=ArcNameTranslations; Translation; Translation=Translation->Next) {

        Result = pSpArcToNtWorker(
                    NormalizedArcPath,
                    Translation->ArcPath,
                    Translation->NtPath
                    );

        if(Result) {
            break;
        }
    }

#if defined(_AMD64_) || defined(_X86_)
    if(!Result && HardDisksDetermined) {

        ULONG i;

        for(i=0; i<HardDiskCount; i++) {

            //
            // The disk may not have an equivalent nt path.
            //
            if(HardDisks[i].DevicePath[0]) {

                Result = pSpArcToNtWorker(
                            NormalizedArcPath,
                            HardDisks[i].ArcPath,
                            HardDisks[i].DevicePath
                            );
            }

            if(Result) {
                break;
            }
        }
    }
#endif // defined(_AMD64_) || defined(_X86_)

    SpMemFree(NormalizedArcPath);
    return(Result);
}


PWSTR
SpNtToArc(
    IN PWSTR            NtPath,
    IN ENUMARCPATHTYPE  ArcPathType
    )
/*++

Routine Description:


    Given a pathname n the NT-namespace, return an equivalent path
    in the ARC namespace.

    On amd64/x86, we can have disks attached to scsi adapters with
    BIOSes. Those disks are accessible both via multi()-style arc names
    and scsi()-style names.  The above search returns the mutli()-style
    one first, which is fine.  But sometimes we want to find the scsi
    one.  That one is referred to as the 'secondary' arc path.
    We declare that this concept is amd64/x86-specific.

Arguments:

    NtPath - supplies NT path to translate into ARC.

    ArcPathType - see above.  This parameter is ignored
        on non-x86 platforms.

Return Value:

    Pointer to wide-character string containing arc path, or NULL
    if there is no equivalent arc path for the given nt path.

--*/
{
    PARCNAME_TRANSLATION Translation;
    PWSTR Result;

    Result = NULL;

    for(Translation=ArcNameTranslations; Translation; Translation=Translation->Next) {

        Result = pSpNtToArcWorker(
                    NtPath,
                    Translation->NtPath,
                    Translation->ArcPath
                    );

        if(Result) {
            break;
        }
    }

#if defined(_AMD64_) || defined(_X86_)
    //
    // If we are supposed to find a secondary arc path and we already
    // found a primary one, forget the primary one we found.
    //
    if((ArcPathType != PrimaryArcPath) && Result) {
        SpMemFree(Result);
        Result = NULL;
    }

    if(!Result && HardDisksDetermined) {

        ULONG i;

        for(i=0; i<HardDiskCount; i++) {
            //
            // The disk may not have an equivalent arc path.
            //
            if(HardDisks[i].ArcPath[0]) {

                Result = pSpNtToArcWorker(
                            NtPath,
                            HardDisks[i].DevicePath,
                            HardDisks[i].ArcPath
                            );
            }

            if(Result) {
                break;
            }
        }
    }
#else
    UNREFERENCED_PARAMETER(ArcPathType);
#endif // defined(_AMD64_) || defined(_X86_)

    return(Result);
}


PWSTR
SpScsiArcToMultiArc(
    IN PWSTR ArcPath
    )
/*
    Convert a "scsi(..." arcpath into a "multi(..." arcpath, if possible.

*/
{
PWSTR   p = NULL;
PWSTR   q = NULL;

    //
    // First convert the path into the device path
    //
    p = SpArcToNt( ArcPath );

    if( p ) {
        //
        // Now convert that device path into an arcpath.
        //
        q = SpNtToArc( p,
                       PrimaryArcPath );

        SpMemFree(p);
    }

    return q;
}


PWSTR
SpMultiArcToScsiArc(
    IN PWSTR ArcPath
    )
/*
    Convert a "multi(..." arcpath into a "scsi(..." arcpath, if possible.

*/
{
PWSTR   p = NULL;
PWSTR   q = NULL;

    //
    // First convert the path into the device path
    //
    p = SpArcToNt( ArcPath );

    if( p ) {
        //
        // Now convert that device path into an arcpath.
        //
        q = SpNtToArc( p,
                       SecondaryArcPath );

        SpMemFree(p);
    }

    return q;
}



VOID
SpGetEnvVarComponents(
    IN  PCHAR    EnvValue,
    OUT PCHAR  **EnvVarComponents,
    OUT PULONG   PNumComponents
    )

/*++

Routine Description:

    This routine takes an environment variable string and turns it into
    the constituent value strings:

    Example EnvValue = "Value1;Value2;Value3" is turned into:

    "Value1", "Value2", "Value3"

    The following are valid value strings:

    1. "     "                                      :one null value is found
    2. ";;;;    "                                   :five null values are found
    3. " ;Value1    ;   Value2;Value3;;;;;;;   ;"   :12 value strings are found,
                                                    :9 of which are null

    The value strings returned suppress all whitespace before and after the
    value. Embedded whitespaces are treated as valid.


Arguments:

    EnvValue:  ptr to zero terminated environment value string

    EnvVarComponents: ptr to a PCHAR * variable to receive the buffer of
                      ptrs to the constituent value strings.

    PNumComponents: ptr to a ULONG to receive the number of value strings found

Return Value:

    None.

        - *PNumComponent field gets the number of value strings found
        - if the number is non zero the *EnvVarComponents field gets the
          ptr to the buffer containing ptrs to value strings

--*/

{
    PCHAR pchStart, pchEnd, pchNext;
    PCHAR pchComponents[MAX_COMPONENTS + 1];
    ULONG NumComponents, i;
    PCHAR pch;
    PCHAR *ppch;
    ULONG size;

    ASSERT(EnvValue);

    //
    // Initialise the ptr array with nulls
    //
    for (i = 0; i < (MAX_COMPONENTS+1); i++) {
        pchComponents[i] = NULL;
    }

    *EnvVarComponents = NULL;

    //
    // Initialise ptrs to search components
    //
    pchStart      = EnvValue;
    NumComponents = 0;


    //
    // search till either pchStart reaches the end or till max components
    // is reached.
    //
    while (*pchStart && NumComponents < MAX_COMPONENTS) {

        //
        // find the beginning of next variable value
        //
        while (*pchStart!=0 && isspace(*pchStart)) {
            pchStart++;
        }

        if (*pchStart == 0) {
            break;
        }

        //
        // In the midst of a value
        //
        pchEnd = pchStart;
        while (*pchEnd!=0 && *pchEnd!=';') {
            pchEnd++;
        }

        //
        // Process the value found, remove any spaces at the end
        //
        while((pchEnd > pchStart) && isspace(*(pchEnd-1))) {
            pchEnd--;
        }

        //
        // spit out the value found
        //

        size = (ULONG)(pchEnd - pchStart);
        pch = SpMemAlloc(size+1);
        ASSERT(pch);

        strncpy (pch, pchStart, size);
        pch[size]=0;
        pchComponents[NumComponents++]=pch;

        //
        // variable value end has been reached, find the beginning
        // of the next value
        //
        if ((pchNext = strchr(pchEnd, ';')) == NULL) {
            break; // out of the big while loop because we are done
        }

        //
        // reinitialise
        //
        pchStart = pchNext + 1;

    } // end while.

    //
    // Get memory to hold an environment pointer and return that
    //
    ppch = (PCHAR *)SpMemAlloc((NumComponents+1)*sizeof(PCHAR));

    //
    // the last one is NULL because we initialised the array with NULLs
    //
    for(i = 0; i <= NumComponents; i++) {
        ppch[i] = pchComponents[i];
    }

    *EnvVarComponents = ppch;

    //
    // Update the number of elements field and return.
    //
    *PNumComponents = NumComponents;
}



VOID
SpGetEnvVarWComponents(
    IN  PCHAR    EnvValue,
    OUT PWSTR  **EnvVarComponents,
    OUT PULONG   PNumComponents
    )

/*++

Routine Description:

    This routine takes an environment variable string and turns it into
    the constituent value strings:

    Example EnvValue = "Value1;Value2;Value3" is turned into:

    "Value1", "Value2", "Value3"

    The following are valid value strings:

    1. "     "                                      :one null value is found
    2. ";;;;    "                                   :five null values are found
    3. " ;Value1    ;   Value2;Value3;;;;;;;   ;"   :12 value strings are found,
                                                    :9 of which are null

    If an invalid component (contains embedded white space) is found in the
    string then this routine attempts to resynch to the next value, no error
    is returned, and a the first part of the invalid value is returned for the
    bad component.

    1.  "    Value1;Bad   Value2; Value3"           : 2 value strings are found

    The value strings returned suppress all whitespace before and after the
    value.


Arguments:

    EnvValue:  ptr to zero terminated environment value string

    EnvVarComponents: ptr to a PWSTR * variable to receive the buffer of
                      ptrs to the constituent value strings.

    PNumComponents: ptr to a ULONG to receive the number of value strings found

Return Value:

    None.

        - *PNumComponent field gets the number of value strings found
        - if the number is non zero the *EnvVarComponents field gets the
          ptr to the buffer containing ptrs to value strings

--*/

{
    PCHAR *Components;
    ULONG Count,i;
    PWSTR *ppwstr;

    //
    // Get components.
    //
    SpGetEnvVarComponents(EnvValue,&Components,&Count);

    ppwstr = SpMemAlloc((Count+1)*sizeof(PWCHAR));
    ASSERT(ppwstr);

    for(i=0; i<Count; i++) {

        ppwstr[i] = SpToUnicode(Components[i]);
        ASSERT(ppwstr[i]);
    }

    ppwstr[Count] = NULL;

    SpFreeEnvVarComponents(Components);

    *PNumComponents = Count;
    *EnvVarComponents = ppwstr;
}


VOID
SpFreeEnvVarComponents (
    IN PVOID *EnvVarComponents
    )
/*++

Routine Description:

    This routine frees up all the components in the ptr array and frees
    up the storage for the ptr array itself too

Arguments:

    EnvVarComponents: the ptr to the PCHAR * or PWSTR * Buffer

Return Value:

    None.

--*/

{
    ASSERT(EnvVarComponents);

    SppFreeComponents(EnvVarComponents);
    SpMemFree(EnvVarComponents);
}


VOID
SppFreeComponents(
    IN PVOID *EnvVarComponents
    )

/*++

Routine Description:

   This routine frees up only the components in the ptr array, but doesn't
   free the ptr array storage itself.

Arguments:

    EnvVarComponents: the ptr to the PCHAR * or PWSTR * Buffer

Return Value:

    None.

--*/

{
    //
    // get all the components and free them
    //
    while(*EnvVarComponents) {
        SpMemFree(*EnvVarComponents++);
    }
}


PWSTR
SpNormalizeArcPath(
    IN PWSTR Path
    )

/*++

Routine Description:

    Transform an ARC path into one with no sets of empty parenthesis
    (ie, transforom all instances of () to (0).).

    The returned path will be all lowercase.

Arguments:

    Path - ARC path to be normalized.

Return Value:

    Pointer to buffer containing normalized path.
    Caller must free this buffer with SpMemFree.

--*/

{
    PWSTR p,q,r;
    PWSTR NormalizedPath;

    NormalizedPath = SpMemAlloc((wcslen(Path)+100)*sizeof(WCHAR));
    ASSERT(NormalizedPath);
    RtlZeroMemory(NormalizedPath,(wcslen(Path)+100)*sizeof(WCHAR));

    for(p=Path; q=wcsstr(p,L"()"); p=q+2) {

        r = NormalizedPath + wcslen(NormalizedPath);
        wcsncpy(r,p,(size_t)(q-p));
        wcscat(NormalizedPath,L"(0)");
    }
    wcscat(NormalizedPath,p);

    NormalizedPath = SpMemRealloc(NormalizedPath,(wcslen(NormalizedPath)+1)*sizeof(WCHAR));
    SpStringToLower(NormalizedPath);
    return(NormalizedPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spbasefile.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spbasefile.h

Abstract:

    see also
        .\spcab.c
        .\spbasefile.c
        .\spbasefile.h
        windows\winstate\...\cablib.c
        windows\winstate\cobra\utils\main\basefile.c
        windows\winstate\cobra\utils\inc\basefile.h

Author:

    Jay Krell (a-JayK) November 2000

Revision History:

        
--*/
#pragma once

#include "windows.h"

BOOL
SpCreateDirectoryA(
    IN      PCSTR FullPath
    );

BOOL
SpCreateDirectoryW(
    IN      PCWSTR FullPath
    );

HANDLE
SpCreateFile1A(
    IN      PCSTR FileName
    );

HANDLE
SpOpenFile1A(
    IN      PCSTR FileName
    );

HANDLE
SpOpenFile1W(
    IN      PCWSTR FileName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spasmcabs.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    spasmcabs.h

Abstract:


Author:

    Jay Krell (JayKrell) May 2002

Revision History:

--*/

#pragma once

NTSTATUS
SpExtractAssemblyCabinets(
//
// so many parameters implies we should take them in a struct..
//
    HANDLE SifHandle,
    IN PCWSTR SourceDevicePath, // \device\harddisk0\partition2
    IN PCWSTR DirectoryOnSourceDevice, // \$win_nt$.~ls
    IN PCWSTR SysrootDevice, // \Device\Harddisk0\Partition2
    IN PCWSTR Sysroot // \WINDOWS.2
    );

//
// The rest is private.
//
#if defined(SP_ASM_CABS_PRIVATE)

typedef struct _SP_EXTRACT_ASMCABS_GLOBAL_CONTEXT SP_EXTRACT_ASMCABS_GLOBAL_CONTEXT, *PSP_EXTRACT_ASMCABS_GLOBAL_CONTEXT;
typedef struct _SP_EXTRACT_ASMCABS_FDICOPY_CONTEXT SP_EXTRACT_ASMCABS_FDICOPY_CONTEXT, *PSP_EXTRACT_ASMCABS_FDICOPY_CONTEXT;
typedef struct _SP_EXTRACT_ASMCABS_FILE_CONTEXT SP_EXTRACT_ASMCABS_FILE_CONTEXT, *PSP_EXTRACT_ASMCABS_FILE_CONTEXT;
typedef struct _SP_ASMS_ERROR_INFORMATION SP_ASMS_ERROR_INFORMATION, *PSP_ASMS_ERROR_INFORMATION;

//
// This should take PCUNICODE_STRING and use Context to efficiently make a nul
// terminated copy, but instead we nul terminate mostly as we go..
//
typedef VOID (CALLBACK * PSP_ASMCABS_FILE_OPEN_UI_CALLBACK)(PVOID Context, PCWSTR LeafCabFileName);

NTSTATUS
SpExtractAssemblyCabinetsInternalNoRetryOrUi(
//
// so many parameters implies we should take them in a struct..
//
    HANDLE SifHandle,
    IN PCWSTR SourceDevicePath, // \device\harddisk0\partition2
    IN PCWSTR DirectoryOnSourceDevice, // \$win_nt$.~ls
    IN PCWSTR SysrootDevice, // \Device\Harddisk0\Partition2
    IN PCWSTR Sysroot, // \WINDOWS.2
    PSP_ASMS_ERROR_INFORMATION ErrorInfo,
    PSP_ASMCABS_FILE_OPEN_UI_CALLBACK FileOpenUiCallback,
    PVOID FileOpenUiCallbackContext
    );

PVOID
DIAMONDAPI
SpAsmCabsMemAllocCallback(
    IN      ULONG Size
    );

VOID
DIAMONDAPI
SpAsmCabsMemFreeCallback(
    IN      PVOID Memory
    );

UINT
DIAMONDAPI
SpAsmCabsReadFileCallback(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    );

UINT
DIAMONDAPI
SpAsmCabsWriteFileCallback(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    );

LONG
DIAMONDAPI
SpAsmCabsSeekFileCallback(
    IN INT_PTR  Handle,
    IN long Distance32,
    IN int  SeekType
    );

INT_PTR
DIAMONDAPI
SpAsmCabsOpenFileForReadCallbackA(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    );

NTSTATUS
SpAsmCabsNewFile(
    PSP_EXTRACT_ASMCABS_FILE_CONTEXT * MyFileHandle
    );

VOID
SpAsmCabsCloseFile(
    PSP_EXTRACT_ASMCABS_FILE_CONTEXT MyFileHandle
    );

int
DIAMONDAPI
SpAsmCabsCloseFileCallback(
    IN INT_PTR Handle
    );

INT_PTR
DIAMONDAPI
SpExtractAsmCabsFdiCopyCallback(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spbasefile.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    spbasefile.c

Abstract:

    see also
        .\spcab.c
        .\spbasefile.c
        .\spbasefile.h
        windows\winstate\...\cablib.c
        windows\winstate\cobra\utils\main\basefile.c
        windows\winstate\cobra\utils\inc\basefile.h

Author:

    Jay Krell (a-JayK) November 2000

Revision History:

--*/
#include "spprecmp.h"
#include "spstrings.h"
#include "spbasefile.h"
#include "spbasefilep.h"
#include "spwin.h"
#include "spcab.h"
#include "spcabp.h"

HANDLE
SpCreateFile1A(
    IN PCSTR FileName
    )
{
    HANDLE Handle;

    Handle = SpWin32CreateFileA(
                    FileName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

    if (Handle == INVALID_HANDLE_VALUE) {
        Handle = NULL;
    }

    return Handle;
}

PSTR
SpJoinPathsA(
    PCSTR a,
    PCSTR b
    )
{
// UNDONE find code elsewhere in setup that does this already
    PSTR Result = NULL;
    SIZE_T alen = 0;
    SIZE_T blen = 0;

    if (a == NULL)
        goto Exit;
    if (b == NULL)
        goto Exit;
    alen = strlen(a);
    blen = strlen(b);

    Result = SpMemAlloc((alen + blen + 2) * sizeof(*Result));
    if (Result == NULL) {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(STATUS_NO_MEMORY);
        goto Exit;
    }

    if (alen != 0) {
        strcpy(Result, a);
        if (a[alen - 1] != '\\')
            strcat(Result, "\\");
     }
     strcat(Result, b);
Exit:
    KdPrintEx((DPFLTR_SETUP_ID, SpPointerToDbgPrintLevel(Result), "SETUP:"__FUNCTION__" exiting\n"));
    return Result;
}

HANDLE
SpOpenFile1A(
    IN PCSTR Ansi
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL     Success = FALSE;
    ANSI_STRING    AnsiString   = { 0 };
    UNICODE_STRING UnicodeString = { 0 };
    HANDLE Handle = NULL;
    
    RtlInitAnsiString(&AnsiString, Ansi);
    AnsiString.Length = AnsiString.MaximumLength; // include terminal nul

    if (!NT_SUCCESS(Status = SpAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE)))
        goto NtExit;
    Handle = SpOpenFile1W(UnicodeString.Buffer);
    if (Handle == NULL || Handle == INVALID_HANDLE_VALUE)
        goto Exit;

Exit:
    SpFreeStringW(&UnicodeString);
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(Handle),
        "SETUP:"__FUNCTION__"(%s) exiting %p\n", Ansi, Handle
        ));
    return Handle;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

HANDLE
SpOpenFile1W(
    IN PCWSTR FileName
    )
{
    HANDLE Handle;

    Handle = SpWin32CreateFileW(
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0, // no share
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (Handle == INVALID_HANDLE_VALUE) {
        Handle = NULL;
    }

    return Handle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spbasefilep.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    spbasefilep.h

Abstract:

    see also
        .\spcab.c
        .\spbasefile.c
        .\spbasefile.h
        windows\winstate\...\cablib.c
        windows\winstate\cobra\utils\main\basefile.c
        windows\winstate\cobra\utils\inc\basefile.h

Author:

    Jay Krell (a-JayK) November 2000

Revision History:


--*/
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spasmcabs.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    spasmcabs.c

Abstract:

    cab extraction in textmode setup

Author:

    Jay Krell (JayKrell) May 2002

Revision History:

    Jay Krell (JayKrell) June 2002
        tested and cleanup error handling
        general ui work:
          put ui retry/skip/cancel ui upon errors
          put leaf file name in progress
          do not put directory names in progress
--*/

/*
[asmcabs]
asms01.cab = 1,124
asms02.cab = 1,124
urt1.cab = 1,1
urtabc.cab = 1,1
...

The first number is from [SourceDisksNames].
The second number is from [WinntDirectories].

The first number is generally 1 for \i386, \ia64, etc., but
55 for \i386 on Win64 is also expected.

The second number is generally either 1 for \windows or 124 for \windows\winsxs.
*/

#include "spprecmp.h"
#include "fdi.h"
#include "fcntl.h"
#include "crt/sys/stat.h"
#include <stdarg.h>
#include "ntrtlstringandbuffer.h"
#include "ntrtlpath.h"
#define SP_ASM_CABS_PRIVATE
#include "spasmcabs.h"

typedef struct _SP_ASMS_ERROR_INFORMATION {
    BOOLEAN     Success;
    ERF         FdiError;
    NTSTATUS    NtStatus;
    RTL_UNICODE_STRING_BUFFER ErrorCabLeafFileName; // "asms01.cab"
    RTL_UNICODE_STRING_BUFFER ErrorNtFilePath;
} SP_ASMS_ERROR_INFORMATION, *PSP_ASMS_ERROR_INFORMATION;
typedef const SP_ASMS_ERROR_INFORMATION *PCSP_ASMS_ERROR_INFORMATION;

VOID
SpAsmsInitErrorInfo(
    PSP_ASMS_ERROR_INFORMATION ErrorInfo
    )
{
    RtlZeroMemory(ErrorInfo, sizeof(*ErrorInfo));
    ASSERT(ErrorInfo->Success == FALSE);
    ASSERT(ErrorInfo->FdiError.fError == FALSE);
    RtlInitUnicodeStringBuffer(&ErrorInfo->ErrorCabLeafFileName, NULL, 0);
    RtlInitUnicodeStringBuffer(&ErrorInfo->ErrorNtFilePath, NULL, 0);
}

VOID
SpAsmsFreeErrorInfo(
    PSP_ASMS_ERROR_INFORMATION ErrorInfo
    )
{
    RtlFreeUnicodeStringBuffer(&ErrorInfo->ErrorCabLeafFileName);
    RtlFreeUnicodeStringBuffer(&ErrorInfo->ErrorNtFilePath);
}

NTSTATUS
SpAsmsCabsTranslateFdiErrorToNtStatus(
    int erfOper
    )
//
// based on base\pnp\setupapi\diamond.c
//
{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    //
    // There is ERROR_INVALID_DATA used by setupapi, but no STATUS_INVALID_DATA.
    //
    const NTSTATUS STATUS_INVALID_DATA = STATUS_INVALID_PARAMETER;
    const NTSTATUS STATUS_FILE_NOT_FOUND = STATUS_OBJECT_NAME_NOT_FOUND;
    const NTSTATUS STATUS_NOT_ENOUGH_MEMORY = STATUS_NO_MEMORY;

    switch(erfOper) {

    case FDIERROR_NONE:
        //
        // We shouldn't see this -- if there was no error
        // then FDICopy should have returned TRUE.
        //
        ASSERT(erfOper != FDIERROR_NONE);
        NtStatus = STATUS_INVALID_DATA;
        break;

    case FDIERROR_CABINET_NOT_FOUND:
        NtStatus = STATUS_FILE_NOT_FOUND;
        break;

    case FDIERROR_CORRUPT_CABINET:
        NtStatus = STATUS_INVALID_DATA;
        break;

    case FDIERROR_ALLOC_FAIL:
        NtStatus = STATUS_NOT_ENOUGH_MEMORY;
        break;

    case FDIERROR_TARGET_FILE:
    case FDIERROR_USER_ABORT:
        NtStatus = STATUS_INTERNAL_ERROR;
        break;

    case FDIERROR_NOT_A_CABINET:
    case FDIERROR_UNKNOWN_CABINET_VERSION:
    case FDIERROR_BAD_COMPR_TYPE:
    case FDIERROR_MDI_FAIL:
    case FDIERROR_RESERVE_MISMATCH:
    case FDIERROR_WRONG_CABINET:
    default:
        //
        // Cabinet is corrupt or not actually a cabinet, etc.
        //
        NtStatus = STATUS_INVALID_DATA;
        break;
    }
    return NtStatus;
}

//
// These must match ntos\ex\pool.c
// We also free strings via RtlFreeUnicodeString which calls RtlFreeStringRoutine->ExFreePool.
//
PVOID
SpAllocateString(
    IN SIZE_T NumberOfBytes
    )
{
    return ExAllocatePoolWithTag(PagedPool,NumberOfBytes,'grtS');
}
const PRTL_ALLOCATE_STRING_ROUTINE RtlAllocateStringRoutine = SpAllocateString;
const PRTL_FREE_STRING_ROUTINE RtlFreeStringRoutine = ExFreePool;

#if DBG
BOOLEAN SpAsmCabs_BreakOnError; // per function bool not doable
#define SP_ASMS_CAB_CALLBACK_EPILOG() \
    do { if (CabResult == -1) { \
        DbgPrintEx(DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: %s: failed with status %lx\n", __FUNCTION__, NtStatus); \
        DbgPrintEx(DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: %s: ?? setupdd!SpAsmCabs_BreakOnError=1 to break\n", __FUNCTION__); \
        if (SpAsmCabs_BreakOnError) { \
            DbgBreakPoint(); \
        } \
    } } while(0)
#else
#define SP_ASMS_CAB_CALLBACK_EPILOG() /* nothing */
#endif

typedef struct _SP_EXTRACT_ASMCABS_GLOBAL_CONTEXT {
    HANDLE FdiHandle;
    PSP_ASMS_ERROR_INFORMATION ErrorInfo;

    //
    // These are shared by FdiCopyCallback and OpenFileForReadCallback.
    // OpenFileForRead doesn't have a context parameter.
    //
    RTL_UNICODE_STRING_BUFFER UnicodeStringBuffer1;
    RTL_UNICODE_STRING_BUFFER UnicodeStringBuffer2;

    PVOID FileOpenUiCallbackContext OPTIONAL;
    PSP_ASMCABS_FILE_OPEN_UI_CALLBACK FileOpenUiCallback;

} SP_EXTRACT_ASMCABS_GLOBAL_CONTEXT, *PSP_EXTRACT_ASMCABS_GLOBAL_CONTEXT;
typedef const SP_EXTRACT_ASMCABS_GLOBAL_CONTEXT *PCSP_EXTRACT_ASMCABS_GLOBAL_CONTEXT;

PSP_EXTRACT_ASMCABS_GLOBAL_CONTEXT SpAsmCabsGlobalContext;

typedef struct _SP_EXTRACT_ASMCABS_FDICOPY_CONTEXT {
    PSP_EXTRACT_ASMCABS_GLOBAL_CONTEXT GlobalContext;

    //
    // The paths in the cab are relative to this directory.
    // The paths in the cab are merely appended to this path,
    //   with a slash between the two parts.
    //
    UNICODE_STRING              DestinationRootDirectory; // "\Device\Harddisk0\Partition3\WINDOWS\WinSxS"

    //
    // LastDirectoryCreated is intended to reduce calls to "CreateDirectory".
    // For every while we extract, we create all the directories in the path,
    // but before we do that, we compare the directory of the file to the
    // directory of the immediately previously extracted file. If they match,
    // then we do not bother creating the directories again.
    // (we are in a secure single threaded environment, the directories cannot
    // disappear out from under us; if this were not the case, we would also
    // hold open a handle to the directory -- not a bad perf optimization besides.)
    //
    RTL_UNICODE_STRING_BUFFER   LastDirectoryCreated; // "\Device\Harddisk0\Partition3\WINDOWS\WinSxS\IA64_Microsoft.Windows.Common-Controls_6595b64144ccf1df_5.82.0.0_x-ww_B9C4A0A5"
} SP_EXTRACT_ASMCABS_FDICOPY_CONTEXT, *PSP_EXTRACT_ASMCABS_FDICOPY_CONTEXT;
typedef const SP_EXTRACT_ASMCABS_FDICOPY_CONTEXT *PCSP_EXTRACT_ASMCABS_FDICOPY_CONTEXT;

typedef struct _SP_EXTRACT_ASMCABS_FILE_CONTEXT {
    //
    // The "real" underlying NT kernel file handle, as you'd expect.
    //
    HANDLE          NtFileHandle;

    //
    // We use this information to more closely emulate the behavior of
    // diamond.c, which does its own pinning of seeks within the size
    // of the file. Diamond.c uses memory mapped i/o. Perhaps we should too.
    //
    LARGE_INTEGER   FileSize;
    LARGE_INTEGER   FileOffset;

    //
    // Like diamond.c, we try to set the filetime when we close a file,
    // but we ignore errors, like diamond.c
    //
    LARGE_INTEGER   FileTime;

    //
    // The path we used to open the file, for debugging and diagnostic
    // purposes. Frequently asked question -- how do I get the path of
    // an opened file? Answer -- you store it yourself when you open it.
    //
    RTL_UNICODE_STRING_BUFFER FilePath;

} SP_EXTRACT_ASMCABS_FILE_CONTEXT, *PSP_EXTRACT_ASMCABS_FILE_CONTEXT;
typedef const SP_EXTRACT_ASMCABS_FILE_CONTEXT *PCSP_EXTRACT_ASMCABS_FILE_CONTEXT;

NTSTATUS
SpAppendNtPathElement(
    PRTL_UNICODE_STRING_BUFFER   Path,
    PCUNICODE_STRING             Element
    )
{
    //
    // RtlJoinMultiplePathPieces would be handy.
    // ("piece" is proposed terminology for "one or more elements")
    //
    return RtlAppendPathElement(
        RTL_APPEND_PATH_ELEMENT_ONLY_BACKSLASH_IS_SEPERATOR,
        Path,
        Element
        );
}

PVOID
DIAMONDAPI
SpAsmCabsMemAllocCallback(
    IN      ULONG Size
    )
{
    return SpMemAlloc(Size);
}

VOID
DIAMONDAPI
SpAsmCabsMemFreeCallback(
    IN      PVOID Memory
    )
{
    if (Memory != NULL)
        SpMemFree(Memory);
}

UINT
DIAMONDAPI
SpAsmCabsReadFileCallback(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    )
{
    //
    // diamond.c uses memory mapped i/o for reading, perhaps we should too.
    //

    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    UINT CabResult = (UINT)-1; // assume failure
    PSP_EXTRACT_ASMCABS_FILE_CONTEXT MyFileHandle = (PSP_EXTRACT_ASMCABS_FILE_CONTEXT)(PVOID)Handle;
    LONG RealByteCount;

    //
    // pin the read to within the file like diamond.c does.
    //
    RealByteCount = (LONG)ByteCount;
    if((MyFileHandle->FileOffset.QuadPart + RealByteCount) > MyFileHandle->FileSize.QuadPart) {
        RealByteCount = (LONG)(MyFileHandle->FileSize.QuadPart - MyFileHandle->FileOffset.QuadPart);
    }
    if(RealByteCount < 0) {
        RealByteCount = 0;
    }

    NtStatus = ZwReadFile(
                MyFileHandle->NtFileHandle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                pv,
                RealByteCount,
                &MyFileHandle->FileOffset,
                NULL
                );
    if(NT_SUCCESS(NtStatus)) {
        MyFileHandle->FileOffset.QuadPart += RealByteCount;
        CabResult = RealByteCount;
    } else {
#if DBG
        DbgPrintEx(DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: %s: Status %lx reading source target file\n", __FUNCTION__, NtStatus);
#endif
    }
    return CabResult;
}

UINT
DIAMONDAPI
SpAsmCabsWriteFileCallback(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    UINT CabResult = (UINT)-1; // assume failure
    PSP_EXTRACT_ASMCABS_FILE_CONTEXT MyFileHandle = (PSP_EXTRACT_ASMCABS_FILE_CONTEXT)(PVOID)Handle;
    const PSP_EXTRACT_ASMCABS_GLOBAL_CONTEXT GlobalContext = SpAsmCabsGlobalContext;

    ASSERT(GlobalContext != NULL);
    ASSERT(MyFileHandle != NULL);

    NtStatus = ZwWriteFile(
                MyFileHandle->NtFileHandle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                pv,
                ByteCount,
                &MyFileHandle->FileOffset,
                NULL
                );

    if(NT_SUCCESS(NtStatus)) {
        MyFileHandle->FileOffset.QuadPart += ByteCount;
        if (MyFileHandle->FileOffset.QuadPart > MyFileHandle->FileSize.QuadPart) {
            MyFileHandle->FileSize = MyFileHandle->FileOffset;
        }
        CabResult = ByteCount;
    } else {
        const PUNICODE_STRING UnicodeString = &MyFileHandle->FilePath.String;
#if DBG
        DbgPrintEx(DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: %s: Status %lx writing to target file %wZ\n", __FUNCTION__, NtStatus, UnicodeString);
#endif
        if (!NT_SUCCESS(RtlAssignUnicodeStringBuffer(&GlobalContext->ErrorInfo->ErrorNtFilePath, UnicodeString))) {
            GlobalContext->ErrorInfo->ErrorNtFilePath.String.Length = 0;
        }
    }

    return CabResult;
}

LONG
DIAMONDAPI
SpAsmCabsSeekFileCallback(
    IN INT_PTR  Handle,
    IN long Distance32,
    IN int  SeekType
    )
{
    FILE_POSITION_INFORMATION CurrentPosition;
    LARGE_INTEGER Distance;
    PSP_EXTRACT_ASMCABS_FILE_CONTEXT MyFileHandle = (PSP_EXTRACT_ASMCABS_FILE_CONTEXT)(PVOID)Handle;
    LONG CabResult = -1; // assume failure
    HANDLE NtFileHandle = MyFileHandle->NtFileHandle;

    Distance.QuadPart = Distance32;

    switch(SeekType) {

    case SEEK_CUR:
        CurrentPosition.CurrentByteOffset.QuadPart =
                (MyFileHandle->FileOffset.QuadPart + Distance.QuadPart);
        break;

    case SEEK_END:
        CurrentPosition.CurrentByteOffset.QuadPart =
            (MyFileHandle->FileSize.QuadPart - Distance.QuadPart);
        break;

    case SEEK_SET:
        CurrentPosition.CurrentByteOffset = Distance;
        break;
    }

    //
    // pin the seek to within the file like diamond.c does.
    //
    if(CurrentPosition.CurrentByteOffset.QuadPart < 0) {
        CurrentPosition.CurrentByteOffset.QuadPart = 0;
    }
    if(CurrentPosition.CurrentByteOffset.QuadPart > MyFileHandle->FileSize.QuadPart) {
        CurrentPosition.CurrentByteOffset = MyFileHandle->FileSize;
    }
    /* We don't need to do this since we specify the offset in the ReadFile/WriteFile calls.
    {
        IO_STATUS_BLOCK IoStatusBlock;
        NtStatus = ZwSetInformationFile(
                    NtFileHandle,
                    &IoStatusBlock,
                    &CurrentPosition,
                    sizeof(CurrentPosition),
                    FilePositionInformation
                    );
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }
    }
    */
    MyFileHandle->FileOffset = CurrentPosition.CurrentByteOffset;
    ASSERT(CurrentPosition.CurrentByteOffset.HighPart == 0);
    CabResult = (LONG)CurrentPosition.CurrentByteOffset.QuadPart;

    return CabResult;
}

INT_PTR
DIAMONDAPI
SpAsmCabsOpenFileForReadCallbackA(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    )
{
    ANSI_STRING AnsiString;
    INT_PTR CabResult = -1; // assume failure
    PSP_EXTRACT_ASMCABS_FILE_CONTEXT MyFileHandle = NULL;
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    FILE_STANDARD_INFORMATION StandardInfo;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    PUNICODE_STRING ErrorNtFilePath = NULL;
    const PSP_EXTRACT_ASMCABS_GLOBAL_CONTEXT GlobalContext = SpAsmCabsGlobalContext;

    ASSERT(GlobalContext != NULL);

    NtStatus = RtlInitAnsiStringEx(&AnsiString, FileName);
    if (!NT_SUCCESS(NtStatus)) {
        goto Exit;
    }
    NtStatus = RtlEnsureUnicodeStringBufferSizeChars(&GlobalContext->UnicodeStringBuffer1, RTL_STRING_GET_LENGTH_CHARS(&AnsiString) + 1);
    if (!NT_SUCCESS(NtStatus)) {
        goto Exit;
    }
    NtStatus = RtlAnsiStringToUnicodeString(&GlobalContext->UnicodeStringBuffer1.String, &AnsiString, FALSE);
    if (!NT_SUCCESS(NtStatus)) {
        goto Exit;
    }
    NtStatus = SpAsmCabsNewFile(&MyFileHandle);
    if (!NT_SUCCESS(NtStatus)) {
        goto Exit;
    }

    InitializeObjectAttributes(&Obja, &GlobalContext->UnicodeStringBuffer1.String, OBJ_CASE_INSENSITIVE, NULL, NULL);
    RTL_STRING_NUL_TERMINATE(Obja.ObjectName);
    NtStatus = ZwCreateFile(
        &MyFileHandle->NtFileHandle,
        FILE_GENERIC_READ,
        &Obja,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ,
        FILE_OPEN,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
        );
    if (!NT_SUCCESS(NtStatus)) {
        ErrorNtFilePath = Obja.ObjectName;
        goto Exit;
    }
    //
    // We don't want ui feedback for the .cab files here.
    //
#if 0
    if (SpAsmCabsGlobalContext->FileOpenUiCallback != NULL) {
        (*SpAsmCabsGlobalContext->FileOpenUiCallback)(SpAsmCabsGlobalContext->FileOpenUiCallbackContext, Obja.ObjectName->Buffer);
    }
#endif
    NtStatus = ZwQueryInformationFile(
                MyFileHandle->NtFileHandle,
                &IoStatusBlock,
                &StandardInfo,
                sizeof(StandardInfo),
                FileStandardInformation
                );
    if (!NT_SUCCESS(NtStatus)) {
        ErrorNtFilePath = Obja.ObjectName;
        goto Exit;
    }

    // ok if this fails
    if (!NT_SUCCESS(RtlAssignUnicodeStringBuffer(&MyFileHandle->FilePath, Obja.ObjectName))) {
        MyFileHandle->FilePath.String.Length = 0;
    }

    MyFileHandle->FileSize = StandardInfo.EndOfFile;

    CabResult = (INT_PTR)MyFileHandle;
    MyFileHandle = NULL;
Exit:
    if (!NT_SUCCESS(NtStatus)) {
        GlobalContext->ErrorInfo->NtStatus = NtStatus;

        if (ErrorNtFilePath != NULL) {
            if (!NT_SUCCESS(RtlAssignUnicodeStringBuffer(&GlobalContext->ErrorInfo->ErrorNtFilePath, ErrorNtFilePath))) {
                GlobalContext->ErrorInfo->ErrorNtFilePath.String.Length = 0;
            }
        }
    }
    SpAsmCabsCloseFile(MyFileHandle);

    SP_ASMS_CAB_CALLBACK_EPILOG();

    return CabResult;
}

NTSTATUS
SpAsmCabsNewFile(
    PSP_EXTRACT_ASMCABS_FILE_CONTEXT * MyFileHandle
    )
{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    ASSERT(MyFileHandle != NULL);
    ASSERT(*MyFileHandle == NULL);

    *MyFileHandle = (PSP_EXTRACT_ASMCABS_FILE_CONTEXT)SpMemAlloc(sizeof(**MyFileHandle));
    if (*MyFileHandle == NULL) {
        NtStatus = STATUS_NO_MEMORY;
        goto Exit;
    }
    RtlZeroMemory(*MyFileHandle, sizeof(**MyFileHandle));
    RtlInitUnicodeStringBuffer(&(*MyFileHandle)->FilePath, NULL, 0);

    NtStatus = STATUS_SUCCESS;
Exit:
    return NtStatus;
}

VOID
SpAsmCabsCloseFile(
    PSP_EXTRACT_ASMCABS_FILE_CONTEXT MyFileHandle
    )
{
    if (MyFileHandle != NULL
        && MyFileHandle != (PSP_EXTRACT_ASMCABS_FILE_CONTEXT)INVALID_HANDLE_VALUE) {

        HANDLE NtFileHandle = MyFileHandle->NtFileHandle;

        if (NtFileHandle != NULL
            && NtFileHandle != INVALID_HANDLE_VALUE) {

            MyFileHandle->NtFileHandle = NULL;
            ZwClose(NtFileHandle);

        }
        SpMemFree(MyFileHandle);
    }
}

int
DIAMONDAPI
SpAsmCabsCloseFileCallback(
    IN INT_PTR Handle
    )
{
    SpAsmCabsCloseFile((PSP_EXTRACT_ASMCABS_FILE_CONTEXT)Handle);
    return 0; // success
}

NTSTATUS
SpSplitFullPathAtDevice(
    PCUNICODE_STRING    FullPath,
    PUNICODE_STRING     Device,
    PUNICODE_STRING     Rest
    )
    //
    // skip four slashes like SpCreateDirectoryForFileA.
    // \device\harddiskn\partitionm\
    //
{
    SIZE_T i = 0;
    SIZE_T j = 0;
    SIZE_T Length = RTL_STRING_GET_LENGTH_CHARS(FullPath);
    const PWSTR Buffer = FullPath->Buffer;
    for (i = 0 ; i != 4 ; ++i )
    {
        for (  ; j != Length ; ++j )
        {
            if (Buffer[j] == '\\')
            {
                ++j;
                break;
            }
        }
    }
    ASSERT(j >= 4);
    Device->Buffer = Buffer;
    RTL_STRING_SET_LENGTH_CHARS_UNSAFE(Device, j - 1);

    Rest->Buffer = Buffer + j;
    RTL_STRING_SET_LENGTH_CHARS_UNSAFE(Rest, Length - j);

    return STATUS_SUCCESS;
}

INT_PTR
DIAMONDAPI
SpExtractAsmCabsFdiCopyCallback(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    )
{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    INT_PTR CabResult = -1; // assume failure
    PSP_EXTRACT_ASMCABS_FILE_CONTEXT MyFileHandle = NULL;
    const PSP_EXTRACT_ASMCABS_FDICOPY_CONTEXT FdiCopyContext = (PSP_EXTRACT_ASMCABS_FDICOPY_CONTEXT)Parameters->pv;
    const PSP_EXTRACT_ASMCABS_GLOBAL_CONTEXT  GlobalContext = FdiCopyContext->GlobalContext;
    IO_STATUS_BLOCK IoStatusBlock;
    PUNICODE_STRING ErrorNtFilePath = NULL;

    switch (Operation)
    {
    case fdintCOPY_FILE:
        {
            ANSI_STRING AnsiString;
            OBJECT_ATTRIBUTES Obja;
            UNICODE_STRING Directory;

            NtStatus = RtlInitAnsiStringEx(&AnsiString, Parameters->psz1);
            if (!NT_SUCCESS(NtStatus)) {
                goto Exit;
            }
            NtStatus = RtlEnsureUnicodeStringBufferSizeChars(&GlobalContext->UnicodeStringBuffer1, RTL_STRING_GET_LENGTH_CHARS(&AnsiString) + 1);
            if (!NT_SUCCESS(NtStatus)) {
                goto Exit;
            }
            NtStatus = RtlAnsiStringToUnicodeString(&GlobalContext->UnicodeStringBuffer1.String, &AnsiString, FALSE);
            if (!NT_SUCCESS(NtStatus)) {
                goto Exit;
            }
            NtStatus = RtlAssignUnicodeStringBuffer(&GlobalContext->UnicodeStringBuffer2, &FdiCopyContext->DestinationRootDirectory);
            if (!NT_SUCCESS(NtStatus)) {
                goto Exit;
            }
            NtStatus = SpAppendNtPathElement(&GlobalContext->UnicodeStringBuffer2, &GlobalContext->UnicodeStringBuffer1.String);
            if (!NT_SUCCESS(NtStatus)) {
                goto Exit;
            }
            InitializeObjectAttributes(
                &Obja,
                &GlobalContext->UnicodeStringBuffer2.String,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            ErrorNtFilePath = Obja.ObjectName;

            NtStatus = SpDeleteFileOrEmptyDirectory(0, Obja.ObjectName);
            if (NtStatus == STATUS_OBJECT_PATH_NOT_FOUND
                || NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

                NtStatus = STATUS_SUCCESS;
            }
            if (!NT_SUCCESS(NtStatus)) {
                goto Exit;
            }

            Directory = *Obja.ObjectName;
            NtStatus = RtlRemoveLastNtPathElement(0, &Directory);
            if (!NT_SUCCESS(NtStatus)) {
                goto Exit;
            }
            //
            // remove last character if it is a backslash
            //
            while (Directory.Length != 0 && RTL_STRING_GET_LAST_CHAR(&Directory) == '\\') {
                Directory.Length -= sizeof(Directory.Buffer[0]);
                Directory.MaximumLength -= sizeof(Directory.Buffer[0]);
            }
            if (!RtlEqualUnicodeString(&Directory, &FdiCopyContext->LastDirectoryCreated.String, TRUE)) {
                //
                // oops...need it split up for the setup utility function actually..
                //
                UNICODE_STRING DirectoryDevice;
                UNICODE_STRING DirectoryTail;

                NtStatus = SpSplitFullPathAtDevice(&Directory, &DirectoryDevice, &DirectoryTail);
                if (!NT_SUCCESS(NtStatus)) {
                    goto Exit;
                }
                NtStatus =
                    SpCreateDirectory_Ustr(
                        &DirectoryDevice,
                        NULL,
                        &DirectoryTail,
                        0, // DirAttrs
                        CREATE_DIRECTORY_FLAG_NO_STATUS_TEXT_UI
                        );
                if (!NT_SUCCESS(NtStatus)) {
                    goto Exit;
                }
                NtStatus = RtlAssignUnicodeStringBuffer(&FdiCopyContext->LastDirectoryCreated, &Directory);
                if (!NT_SUCCESS(NtStatus)) {
                    goto Exit;
                }
            }
            NtStatus = SpAsmCabsNewFile(&MyFileHandle);
            if (!NT_SUCCESS(NtStatus)) {
                goto Exit;
            }
            NtStatus = ZwCreateFile(
                &MyFileHandle->NtFileHandle,
                FILE_GENERIC_WRITE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,                       // no sharing
                FILE_OVERWRITE_IF,       // allow overwrite
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );
            if (!NT_SUCCESS(NtStatus)) {
                goto Exit;
            }
            ErrorNtFilePath = NULL;
            if (SpAsmCabsGlobalContext->FileOpenUiCallback != NULL) {
                (*SpAsmCabsGlobalContext->FileOpenUiCallback)(SpAsmCabsGlobalContext->FileOpenUiCallbackContext, Obja.ObjectName->Buffer);
            }

            // ok if this fails
            if (!NT_SUCCESS(RtlAssignUnicodeStringBuffer(&MyFileHandle->FilePath, Obja.ObjectName))) {
                MyFileHandle->FilePath.String.Length = 0;
            }

            //
            // attribs, date, and time are all available in
            // fdintCLOSE_FILE_INFO, but diamond.c keeps them around
            // from when the open is done.
            //
            MyFileHandle->FileSize.QuadPart = Parameters->cb;
            SpTimeFromDosTime(
                Parameters->date,
                Parameters->time,
                &MyFileHandle->FileTime);

            CabResult = (INT_PTR)MyFileHandle;
            MyFileHandle = NULL;
        }
        break;

    case fdintCLOSE_FILE_INFO:
        {
            FILE_BASIC_INFORMATION FileBasicDetails;
            //
            // Try to set file's last-modifed time, but ignore
            // errors like diamond.c does.
            //
            MyFileHandle = (PSP_EXTRACT_ASMCABS_FILE_CONTEXT)Parameters->hf;
            ASSERT(MyFileHandle != NULL);
            NtStatus = ZwQueryInformationFile(
                MyFileHandle->NtFileHandle,
                &IoStatusBlock,
                &FileBasicDetails,
                sizeof(FileBasicDetails),
                FileBasicInformation );

            if (NT_SUCCESS(NtStatus)) {
                FileBasicDetails.LastWriteTime = MyFileHandle->FileTime;
                ZwSetInformationFile(
                    MyFileHandle->NtFileHandle,
                    &IoStatusBlock,
                    &FileBasicDetails,
                    sizeof(FileBasicDetails),
                    FileBasicInformation);
            }
            SpAsmCabsCloseFile(MyFileHandle);
            MyFileHandle = NULL;
            CabResult = TRUE; // keep FDI going
        }
        break;
    default:
        CabResult = 0;
        break;
    }

    NtStatus = STATUS_SUCCESS;
Exit:
    if (!NT_SUCCESS(NtStatus)) {
        GlobalContext->ErrorInfo->NtStatus = NtStatus;
        if (ErrorNtFilePath != NULL) {
            if (!NT_SUCCESS(RtlAssignUnicodeStringBuffer(&GlobalContext->ErrorInfo->ErrorNtFilePath, ErrorNtFilePath))) {
                GlobalContext->ErrorInfo->ErrorNtFilePath.String.Length = 0;
            }
        }
    }
    SpAsmCabsCloseFile(MyFileHandle);

    SP_ASMS_CAB_CALLBACK_EPILOG();

    return CabResult;
}

NTSTATUS
SpExtractAssemblyCabinetsInternalNoRetryOrUi(
    HANDLE SifHandle,
    IN PCWSTR SourceDevicePath, // \device\harddisk0\partition2
    IN PCWSTR DirectoryOnSourceDevice, // \$win_nt$.~ls
    IN PCWSTR SysrootDevice, // \Device\Harddisk0\Partition2
    IN PCWSTR Sysroot, // \WINDOWS.2
    PSP_ASMS_ERROR_INFORMATION ErrorInfo,
    PSP_ASMCABS_FILE_OPEN_UI_CALLBACK FileOpenUiCallback OPTIONAL,
    PVOID FileOpenUiCallbackContext OPTIONAL
    )
{
    const static WCHAR ConstSectionName[] = L"asmcabs";
    const PWSTR SectionName = (PWSTR)ConstSectionName;
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG LineIndex = 0;
    ULONG LineCount = 0;
    ULONG LineNumber = 0;
    SP_EXTRACT_ASMCABS_GLOBAL_CONTEXT xGlobalContext;
    const PSP_EXTRACT_ASMCABS_GLOBAL_CONTEXT GlobalContext = &xGlobalContext;
    SP_EXTRACT_ASMCABS_FDICOPY_CONTEXT xFdiCopyContext;
    const PSP_EXTRACT_ASMCABS_FDICOPY_CONTEXT FdiCopyContext = &xFdiCopyContext;
    BOOL FdiCopyResult = FALSE;
    UNICODE_STRING              SysrootDeviceString; // \device\harddisk\partition
    UNICODE_STRING              SysrootString; // \windows
    PWSTR                       CabFileName = NULL; // asms02.cab
    UNICODE_STRING              CabFileNameString = { 0 }; // asms02.cab
    RTL_ANSI_STRING_BUFFER      CabFileNameBufferA; // asms02.cab
    PWSTR                       CabMediaShortName = NULL; // "1", "2", etc.
    PWSTR                       CabSetupRelativeDirectory = NULL; // \ia64
    UNICODE_STRING              CabSetupRelativeDirectoryString; // \ia64
    RTL_UNICODE_STRING_BUFFER   CabDirectoryBuffer; // \device\harddisk\partition\$win_nt$.~ls\ia64
    RTL_ANSI_STRING_BUFFER      CabDirectoryBufferA; // \device\harddisk\partition\$win_nt$.~ls\ia64
    UNICODE_STRING              SourceDevicePathString; // \device\harddisk\partition
    UNICODE_STRING              DirectoryOnSourceDeviceString; // \$win_nt$.~ls

    PWSTR                       DestinationDirectoryNumber = NULL;
    PWSTR                       RelativeDestinationDirectory = NULL;
    UNICODE_STRING              RelativeDestinationDirectoryString;
    RTL_UNICODE_STRING_BUFFER   DestinationDirectoryBuffer;

    if (!RTL_VERIFY(SourceDevicePath != NULL)
        || !RTL_VERIFY(DirectoryOnSourceDevice != NULL)
        || !RTL_VERIFY(SysrootDevice != NULL)
        || !RTL_VERIFY(ErrorInfo != NULL)
        || !RTL_VERIFY(Sysroot != NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    ErrorInfo->FdiError.fError = FALSE;
    ErrorInfo->Success = FALSE;
    ErrorInfo->NtStatus = STATUS_SUCCESS;

    SpAsmCabsGlobalContext = GlobalContext;

    RtlZeroMemory(GlobalContext, sizeof(*GlobalContext));
    RtlZeroMemory(FdiCopyContext, sizeof(*FdiCopyContext));
    FdiCopyContext->GlobalContext = GlobalContext;

    GlobalContext->ErrorInfo = ErrorInfo;
    GlobalContext->FileOpenUiCallback = FileOpenUiCallback;
    GlobalContext->FileOpenUiCallbackContext = FileOpenUiCallbackContext;

    RtlInitUnicodeStringBuffer(&GlobalContext->UnicodeStringBuffer1, NULL, 0);
    RtlInitUnicodeStringBuffer(&GlobalContext->UnicodeStringBuffer2, NULL, 0);
    RtlInitUnicodeStringBuffer(&FdiCopyContext->LastDirectoryCreated, NULL, 0);
    RtlInitUnicodeStringBuffer(&CabDirectoryBuffer, NULL, 0);
    RtlInitUnicodeStringBuffer(&DestinationDirectoryBuffer, NULL, 0);

    RtlInitAnsiStringBuffer(&CabFileNameBufferA, NULL, 0);
    RtlInitAnsiStringBuffer(&CabDirectoryBufferA, NULL, 0);

    NtStatus = RtlInitUnicodeStringEx(&SourceDevicePathString, SourceDevicePath);
    if (!NT_SUCCESS(NtStatus)) {
        goto Exit;
    }
    NtStatus = RtlInitUnicodeStringEx(&DirectoryOnSourceDeviceString, DirectoryOnSourceDevice);
    if (!NT_SUCCESS(NtStatus)) {
        goto Exit;
    }
    NtStatus = RtlInitUnicodeStringEx(&SysrootDeviceString, SysrootDevice);
    if (!NT_SUCCESS(NtStatus)) {
        goto Exit;
    }
    NtStatus = RtlInitUnicodeStringEx(&SysrootString, Sysroot);
    if (!NT_SUCCESS(NtStatus)) {
        goto Exit;
    }

    LineCount = SpCountLinesInSection(SifHandle, SectionName);
    if(LineCount == 0) {
        // optional for now
        //SpFatalSifError(SifHandle, SectionName,NULL,0,0);
        goto Success;
    }

    GlobalContext->FdiHandle =
        FDICreate(
            SpAsmCabsMemAllocCallback,
            SpAsmCabsMemFreeCallback,
            SpAsmCabsOpenFileForReadCallbackA,
            SpAsmCabsReadFileCallback,
            SpAsmCabsWriteFileCallback,
            SpAsmCabsCloseFileCallback,
            SpAsmCabsSeekFileCallback,
            cpuUNKNOWN, // ignored
            &ErrorInfo->FdiError
            );
    if (GlobalContext->FdiHandle == NULL) {
        goto FdiError;
    }
    for ( LineNumber = 0 ; LineNumber != LineCount ; ++LineNumber ) {
        //
        // get the filename
        //
        CabFileName = SpGetKeyName(SifHandle, SectionName, LineNumber);
        if (CabFileName == NULL) {
            SpFatalSifError(SifHandle, SectionName, NULL, LineNumber, 0);
            goto Exit;
        }
        if (FileOpenUiCallback != NULL) {
            (*FileOpenUiCallback)(FileOpenUiCallbackContext, CabFileName);
        }
        NtStatus = RtlInitUnicodeStringEx(&CabFileNameString, CabFileName);
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }
        NtStatus = RtlAssignAnsiStringBufferFromUnicode(&CabFileNameBufferA, CabFileName);
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }
        RTL_STRING_NUL_TERMINATE(&CabFileNameBufferA.String);

        //
        // get the source directory information, prompt for media, etc.
        //
        CabMediaShortName = SpGetSectionLineIndex(SifHandle, SectionName, LineNumber, 0);
        if (CabMediaShortName == NULL) {
            SpFatalSifError(SifHandle, SectionName, CabFileName, LineNumber, 0);
            goto Exit;
        }
        SpPromptForSetupMedia(SifHandle, CabMediaShortName, SourceDevicePathString.Buffer);
        SpGetSourceMediaInfo(SifHandle, CabMediaShortName, NULL, NULL, &CabSetupRelativeDirectory);
        if (CabSetupRelativeDirectory == NULL) {
            SpFatalSifError(SifHandle, SectionName, CabFileName, LineNumber, 0);
            goto Exit;
        }

        NtStatus = RtlInitUnicodeStringEx(&CabSetupRelativeDirectoryString, CabSetupRelativeDirectory);
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }

        NtStatus = RtlEnsureUnicodeStringBufferSizeChars(
            &CabDirectoryBuffer,
            RTL_STRING_GET_LENGTH_CHARS(&SourceDevicePathString)
            + 1 // slash
            + RTL_STRING_GET_LENGTH_CHARS(&DirectoryOnSourceDeviceString)
            + 1 // slash
            + RTL_STRING_GET_LENGTH_CHARS(&CabSetupRelativeDirectoryString)
            + 2 // slash and nul
            );
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }

        NtStatus = RtlAssignUnicodeStringBuffer(&CabDirectoryBuffer, &SourceDevicePathString);
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }
        NtStatus = SpAppendNtPathElement(&CabDirectoryBuffer, &DirectoryOnSourceDeviceString);
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }
        NtStatus = SpAppendNtPathElement(&CabDirectoryBuffer, &CabSetupRelativeDirectoryString);
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }
        //
        // Fdi hands us back the concatenation of the path and filename, so make sure there
        // is a slash in there.
        //
        NtStatus = RtlUnicodeStringBufferEnsureTrailingNtPathSeperator(&CabDirectoryBuffer);
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }
        NtStatus = RtlAssignAnsiStringBufferFromUnicodeString(&CabDirectoryBufferA, &CabDirectoryBuffer.String);
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }
        RTL_STRING_NUL_TERMINATE(&CabDirectoryBufferA.String);

        //
        // get the destination directory information
        //
        DestinationDirectoryNumber = SpGetSectionLineIndex(SifHandle, SectionName, LineNumber, 1);
        if (DestinationDirectoryNumber == NULL) {
            SpFatalSifError(SifHandle, SectionName, CabFileName, LineNumber, 1);
            goto Exit;
        }
        RelativeDestinationDirectory = SpLookUpTargetDirectory(SifHandle, DestinationDirectoryNumber);
        if (RelativeDestinationDirectory == NULL) {
            SpFatalSifError(SifHandle, SectionName, CabFileName, LineNumber, 1);
            goto Exit;
        }
        NtStatus = RtlInitUnicodeStringEx(&RelativeDestinationDirectoryString, RelativeDestinationDirectory);
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }

        NtStatus = RtlEnsureUnicodeStringBufferSizeChars(
            &DestinationDirectoryBuffer,
            RTL_STRING_GET_LENGTH_CHARS(&SysrootDeviceString)
            + 1 // slash
            + RTL_STRING_GET_LENGTH_CHARS(&SysrootString)
            + 1 // slash
            + RTL_STRING_GET_LENGTH_CHARS(&RelativeDestinationDirectoryString)
            + 2 // slash and nul
            );
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }

        NtStatus = RtlAssignUnicodeStringBuffer(&DestinationDirectoryBuffer, &SysrootDeviceString);
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }
        NtStatus = SpAppendNtPathElement(&DestinationDirectoryBuffer, &SysrootString);
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }
        NtStatus = SpAppendNtPathElement(&DestinationDirectoryBuffer, &RelativeDestinationDirectoryString);
        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }
        
        FdiCopyContext->DestinationRootDirectory = DestinationDirectoryBuffer.String;

        ErrorInfo->FdiError.fError = FALSE;
        ErrorInfo->Success = FALSE;
        ErrorInfo->NtStatus = STATUS_SUCCESS;

        FdiCopyResult =
            FDICopy(
                GlobalContext->FdiHandle,
                CabFileNameBufferA.String.Buffer, // asms02.cab
                CabDirectoryBufferA.String.Buffer, // "\device\harddisk0\partition2\$win_nt$.~ls\ia64"
                0,
                SpExtractAsmCabsFdiCopyCallback,
                NULL,
                FdiCopyContext);
        if (!FdiCopyResult) {
            NTSTATUS NestedStatus = STATUS_INTERNAL_ERROR;
FdiError:
            NestedStatus = RtlAssignUnicodeStringBuffer(&ErrorInfo->ErrorCabLeafFileName, &CabFileNameString);
            if (!NT_SUCCESS(NestedStatus)) {
                ErrorInfo->ErrorCabLeafFileName.String.Length = 0;
            }
            if (ErrorInfo->NtStatus == STATUS_SUCCESS) {
                if (ErrorInfo->FdiError.fError) {
                    ErrorInfo->NtStatus = SpAsmsCabsTranslateFdiErrorToNtStatus(ErrorInfo->FdiError.erfOper);
                } else {
                    ErrorInfo->NtStatus = STATUS_INTERNAL_ERROR;
                }
            }
            goto Exit;
        }
    }
Success:
    ErrorInfo->FdiError.fError = FALSE;
    ErrorInfo->Success = TRUE;
    ErrorInfo->NtStatus = STATUS_SUCCESS;
Exit:
    RtlFreeUnicodeStringBuffer(&GlobalContext->UnicodeStringBuffer1);
    RtlFreeUnicodeStringBuffer(&GlobalContext->UnicodeStringBuffer2);
    RtlFreeUnicodeStringBuffer(&FdiCopyContext->LastDirectoryCreated);
    RtlFreeUnicodeStringBuffer(&CabDirectoryBuffer);
    RtlFreeUnicodeStringBuffer(&DestinationDirectoryBuffer);
    RtlFreeAnsiStringBuffer(&CabFileNameBufferA);
    RtlFreeAnsiStringBuffer(&CabDirectoryBufferA);
    if (GlobalContext->FdiHandle != NULL) {
        //
        // From experience, we know that FDIDestroy access violates
        // on a NULL FdiHandle.
        //
        FDIDestroy(GlobalContext->FdiHandle);
        GlobalContext->FdiHandle = NULL;
    }
    SpAsmCabsGlobalContext = NULL;
    return STATUS_SUCCESS;
}

typedef struct _SP_ASMS_CAB_FILE_OPEN_UI_CALLBACK_CONTEXT {
    BOOLEAN RedrawEntireScreen;
} SP_ASMS_CAB_FILE_OPEN_UI_CALLBACK_CONTEXT, *PSP_ASMS_CAB_FILE_OPEN_UI_CALLBACK_CONTEXT;
typedef const SP_ASMS_CAB_FILE_OPEN_UI_CALLBACK_CONTEXT *PCSP_ASMS_CAB_FILE_OPEN_UI_CALLBACK_CONTEXT;

VOID
CALLBACK
SpAsmsCabFileOpenUiCallback(
    PVOID VoidContext,
    PCWSTR FileName
    )
{
    const PSP_ASMS_CAB_FILE_OPEN_UI_CALLBACK_CONTEXT Context = (PSP_ASMS_CAB_FILE_OPEN_UI_CALLBACK_CONTEXT)VoidContext;

    ASSERT(Context != NULL);
    //
    // SpCopyFilesScreenRepaint takes a path with or without backslashes
    // and puts on the screen the leaf filename in the lower right.
    //
    // The last parameter is "redraw whole screen" and after
    // any error it should be TRUE. The result with it always
    // false is slightly not great.
    //
    SpCopyFilesScreenRepaint((PWSTR)FileName, NULL, Context->RedrawEntireScreen);
    Context->RedrawEntireScreen = FALSE;
}

NTSTATUS
SpExtractAssemblyCabinets(
    HANDLE SifHandle,
    IN PCWSTR SourceDevicePath, // \device\harddisk0\partition2
    IN PCWSTR DirectoryOnSourceDevice, // \$win_nt$.~ls
    IN PCWSTR SysrootDevice, // \Device\Harddisk0\Partition2
    IN PCWSTR Sysroot // \WINDOWS.2
    )
//
// Wrapper for SpExtractAsmCabs that provides more ui, including
// retry/skip/abort FOR THE WHOLE OPERATION, not per .cab (presently
// we only have on .cab anyway, and the main recoverable error we
// anticipate is the CD being ejected; hopefully we'll play into diskspace
// calculations).
//
{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    BOOLEAN QueueInited = FALSE;
    BOOLEAN RedrawScreen = FALSE;
    const static ULONG ValidKeys[4] = { ASCI_CR, ASCI_ESC, KEY_F3, 0 };
    RTL_UNICODE_STRING_BUFFER FileNameInErrorMessage;
    BOOLEAN PutSeperatorInErrorMessage = FALSE;
    // perhaps just a slash here is better ui
    const static UNICODE_STRING SeperatorInErrorMessageString = RTL_CONSTANT_STRING(L"\\...\\");
    USHORT PrefixLength = 0;
    SP_ASMS_ERROR_INFORMATION xErrorInfo;
    const PSP_ASMS_ERROR_INFORMATION ErrorInfo = &xErrorInfo;
    SP_ASMS_CAB_FILE_OPEN_UI_CALLBACK_CONTEXT CabFileOpenUiCallbackContext = { 0 };

    if (!RTL_VERIFY(SourceDevicePath != NULL)
        || !RTL_VERIFY(DirectoryOnSourceDevice != NULL)
        || !RTL_VERIFY(SysrootDevice != NULL)
        || !RTL_VERIFY(Sysroot != NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    SpAsmsInitErrorInfo(ErrorInfo);
    RtlInitUnicodeStringBuffer(&FileNameInErrorMessage, NULL, 0);
TryAgain:
    if (RedrawScreen) {
        SpCopyFilesScreenRepaint(NULL, NULL, TRUE);
    }
    RedrawScreen = TRUE;
    ErrorInfo->FdiError.fError = FALSE;
    ErrorInfo->Success = FALSE;
    ErrorInfo->NtStatus = STATUS_SUCCESS;
    ErrorInfo->ErrorCabLeafFileName.String.Length = 0;
    ErrorInfo->ErrorNtFilePath.String.Length = 0;
    FileNameInErrorMessage.String.Length = 0;
    SpExtractAssemblyCabinetsInternalNoRetryOrUi(
        SifHandle,
        SourceDevicePath,
        DirectoryOnSourceDevice,
        SysrootDevice,
        Sysroot,
        ErrorInfo,
        SpAsmsCabFileOpenUiCallback,
        &CabFileOpenUiCallbackContext
        );
    if (ErrorInfo->Success) {
        goto Exit;
    }

    //
    // If we failed and we retry, we want the next redraw
    // to redraw the entire screen. (This seems
    // redundant with the local RedrawScreen.)
    //
    CabFileOpenUiCallbackContext.RedrawEntireScreen = TRUE;

    //
    // The copy or verify failed.  Give the user a message and allow retry.
    //

    //
    // the file name in the error messages is given
    // as foo.cab\leaf_path_in_cab
    //
    // This is just a convention invented here.
    // Another idea would be foo.cab(leaf_path)
    // or just foo.cab
    // or just leaf_path
    // or foo.cab(full_path_in_cab)
    // or foo.cab\full_path_in_cab)
    // or destination_directory\full_path_in_cab
    //

    FileNameInErrorMessage.String.Length = 0;
    // setup ui likes nul terminals and unicode_string_buffer always
    // has room for them
    FileNameInErrorMessage.String.Buffer[0] = 0;
    PutSeperatorInErrorMessage = FALSE;
    if (ErrorInfo->ErrorCabLeafFileName.String.Length != 0) {
        RtlAppendUnicodeStringBuffer(
            &FileNameInErrorMessage,
            &ErrorInfo->ErrorCabLeafFileName.String
            );
        PutSeperatorInErrorMessage = TRUE;
    }
    if (ErrorInfo->ErrorNtFilePath.String.Length != 0) {
        if (PutSeperatorInErrorMessage) { 
            NtStatus =
                RtlAppendUnicodeStringBuffer(
                    &FileNameInErrorMessage,
                    &SeperatorInErrorMessageString
                    );
        }
        PrefixLength = 0;
        NtStatus =
            RtlFindCharInUnicodeString(
                RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
                &ErrorInfo->ErrorNtFilePath.String,
                &RtlNtPathSeperatorString,
                &PrefixLength);
        if (NtStatus == STATUS_NOT_FOUND) {
            PrefixLength = 0;
            NtStatus = STATUS_SUCCESS;
        }
        if (NT_SUCCESS(NtStatus)) {
            UNICODE_STRING Leaf;

            Leaf.Buffer = (PWSTR)(PrefixLength + (PUCHAR)ErrorInfo->ErrorNtFilePath.String.Buffer);
            Leaf.Length = (ErrorInfo->ErrorNtFilePath.String.Length - PrefixLength);
            Leaf.MaximumLength = Leaf.Length;

            //
            // remove first character if it is a seperator
            //
            if (!RTL_STRING_IS_EMPTY(&Leaf)) {
                if (Leaf.Buffer[0] == RtlNtPathSeperatorString.Buffer[0]) {
                    Leaf.Buffer += 1;
                    Leaf.Length -= sizeof(Leaf.Buffer[0]);
                    Leaf.MaximumLength -= sizeof(Leaf.Buffer[0]);
                }
                RtlAppendUnicodeStringBuffer(
                    &FileNameInErrorMessage,
                    &Leaf
                    );
            }
        }
    }
    SpStartScreen(
        SP_SCRN_COPY_FAILED,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        FileNameInErrorMessage.String.Buffer
        );

    SpDisplayStatusOptions(
        DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_ENTER_EQUALS_RETRY,
        SP_STAT_ESC_EQUALS_SKIP_FILE,
        SP_STAT_F3_EQUALS_EXIT,
        0
        );

    switch (SpWaitValidKey(ValidKeys,NULL,NULL)) {

    case ASCI_CR:       // retry
        goto TryAgain;

    case ASCI_ESC:      // skip file
        break;

    case KEY_F3:        // exit setup
        SpConfirmExit();
        goto TryAgain;
    }
    SpCopyFilesScreenRepaint(NULL, NULL, TRUE);
Exit:
    SpAsmsFreeErrorInfo(ErrorInfo);
    RtlFreeUnicodeStringBuffer(&FileNameInErrorMessage);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spboot.h ===
/*++

Copyright (c) 1994-2001  Microsoft Corporation

Module Name:

    spboot.h

Abstract:

    Header file for functions to deal with boot variables.

Author:

    Sunil Pai (sunilp) 26-Oct-1993

Revision History:

--*/

#ifndef _SPBOOTVARS_DEFN_
#define _SPBOOTVARS_DEFN_

//
// Define a Unicode string type to be used for storing drive letter
// specifications in upgrade messages (useful because we may not
// have a drive letter, but rather a localizable designator stating
// that the partition is a mirror (eg. "(Mirror):"))
//
typedef WCHAR DRIVELTR_STRING[32];

//
// SP_BOOT_ENTRY is the internal representation of a boot item (or "boot set").
// EFI and ARC NVRAM entries, and boot.ini entries, are kept in this format.
// The NtBootEntry item is the structure passed to/from the NT boot entry APIs.
//
typedef struct _SP_BOOT_ENTRY {
    struct _SP_BOOT_ENTRY *Next;
    PUCHAR AllocationEnd;
    ULONG_PTR Status;
    PWSTR FriendlyName;
    ULONG_PTR FriendlyNameLength;
    PWSTR OsLoadOptions;
    ULONG_PTR OsLoadOptionsLength;
    PFILE_PATH LoaderPath;
    PWSTR LoaderPartitionNtName;
    PDISK_REGION LoaderPartitionDiskRegion;
    PWSTR LoaderFile;
    PFILE_PATH OsPath;
    PWSTR OsPartitionNtName;
    PDISK_REGION OsPartitionDiskRegion;
    PWSTR OsDirectory;
    LOGICAL Processable;
    LOGICAL FailedUpgrade;
    NT_PRODUCT_TYPE ProductType;
    ULONG MajorVersion;
    ULONG MinorVersion;
    ULONG ProductSuiteMask;
    ULONG BuildNumber;
    ULONG ServicePack;
    ULONGLONG KernelVersion;
    LCID LangId;
    PWSTR Pid20Array;
    DRIVELTR_STRING DriveLetterString;
    BOOLEAN UpgradeOnlyCompliance;
    BOOT_ENTRY NtBootEntry;
} SP_BOOT_ENTRY, *PSP_BOOT_ENTRY;

//
//
//
typedef enum {
    UseDefaultSwitches = 0,
    DisableRedirect,
    UseUserDefinedRedirect,
    UseUserDefinedRedirectAndBaudRate
} RedirectSwitchesModeEnum;

#define MAXSIZE_REDIRECT_SWITCH 128

typedef struct _REDIRECT_SWITCHES_ {

    CHAR   port[MAXSIZE_REDIRECT_SWITCH];
    CHAR   baudrate[MAXSIZE_REDIRECT_SWITCH];

} REDIRECT_SWITCHES, PREDIRECT_SWITCHES;

extern RedirectSwitchesModeEnum RedirectSwitchesMode;
extern REDIRECT_SWITCHES RedirectSwitches;

NTSTATUS
SpSetRedirectSwitchMode(
    RedirectSwitchesModeEnum  mode,
    PCHAR                   redirectSwitch,
    PCHAR                   redirectBaudRateSwitch
    );

//
// node for the linked list used to communicate the contents
// of a boot entry outside this library
//
typedef struct _SP_EXPORTED_BOOT_ENTRY_ {
    LIST_ENTRY      ListEntry;
    PWSTR           LoadIdentifier;
    PWSTR           OsLoadOptions;
    WCHAR           DriverLetter;
    PWSTR           OsDirectory;
} SP_EXPORTED_BOOT_ENTRY, *PSP_EXPORTED_BOOT_ENTRY;

NTSTATUS
SpExportBootEntries(
    PLIST_ENTRY     BootEntries,
    PULONG          BootEntryCnt
    );

NTSTATUS
SpFreeExportedBootEntries(
    PLIST_ENTRY     BootEntries,
    ULONG           BootEntryCnt
    );

NTSTATUS
SpAddNTInstallToBootList(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PWSTR        OsLoadOptions,      OPTIONAL
    IN PWSTR        LoadIdentifier      OPTIONAL
    );

NTSTATUS
SpAddUserDefinedInstallationToBootList(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PWSTR        OSLoadOptions,      OPTIONAL
    IN PWSTR        LoadIdentifier      OPTIONAL
    );

NTSTATUS
SpSetDefaultBootEntry(
    ULONG           BootEntryNumber
    );

#define BE_STATUS_ORDERED           0x00000001
#define BE_STATUS_NEW               0x00000002
#define BE_STATUS_DELETED           0x00000004
#define BE_STATUS_FROM_BOOT_INI     0x00000008

#define IS_BOOT_ENTRY_ACTIVE(_be) \
            (((_be)->NtBootEntry.Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) != 0)
#define IS_BOOT_ENTRY_WINDOWS(_be) \
            (((_be)->NtBootEntry.Attributes & BOOT_ENTRY_ATTRIBUTE_WINDOWS) != 0)
#define IS_BOOT_ENTRY_REMOVABLE_MEDIA(_be) \
            (((_be)->NtBootEntry.Attributes & BOOT_ENTRY_ATTRIBUTE_REMOVABLE_MEDIA) != 0)

#define IS_BOOT_ENTRY_ORDERED(_be) \
            (((_be)->Status & BE_STATUS_ORDERED) != 0)
#define IS_BOOT_ENTRY_NEW(_be) \
            (((_be)->Status & BE_STATUS_NEW) != 0)
#define IS_BOOT_ENTRY_DELETED(_be) \
            (((_be)->Status & BE_STATUS_DELETED) != 0)
#define IS_BOOT_ENTRY_FROM_BOOT_INI(_be) \
            (((_be)->Status & BE_STATUS_FROM_BOOT_INI) != 0)

extern PSP_BOOT_ENTRY SpBootEntries;

BOOLEAN
SpInitBootVars(
    );

VOID
SpFreeBootVars(
    );

VOID
SpUpdateRegionForBootEntries(
    VOID
    );

VOID
SpGetNtDirectoryList(
    OUT PWSTR  **DirectoryList,
    OUT PULONG   DirectoryCount
    );

VOID
SpCleanSysPartOrphan(
    VOID
    );

VOID
SpDetermineUniqueAndPresentBootEntries(
    VOID
    );

VOID
SpAddInstallationToBootList(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN BOOLEAN      BaseVideoOption,
    IN PWSTR        OldOsLoadOptions OPTIONAL
    );

VOID
SpRemoveInstallationFromBootList(
    IN  PDISK_REGION     SysPartitionRegion,   OPTIONAL
    IN  PDISK_REGION     NtPartitionRegion,    OPTIONAL
    IN  PWSTR            SysRoot,              OPTIONAL
    IN  PWSTR            SystemLoadIdentifier, OPTIONAL
    IN  PWSTR            SystemLoadOptions,    OPTIONAL
    IN  ENUMARCPATHTYPE  ArcPathType,
#if defined(REMOTE_BOOT)
    IN  BOOLEAN          RemoteBootPath,
#endif // defined(REMOTE_BOOT)
    OUT PWSTR            *OldOsLoadOptions     OPTIONAL
    );

VOID
SpPtDeleteBootSetsForRegion(
    PDISK_REGION region
    );    

#if defined(REMOTE_BOOT)
BOOLEAN
SpFlushRemoteBootVars(
    IN PDISK_REGION TargetRegion
    );
#endif // defined(REMOTE_BOOT)

//
// IsArc() is always true on non-x86 machines except AMD64 for which it is
// always false. On x86, this determination has to be made at run time.
//
#ifdef _X86_
BOOLEAN
SpIsArc(
    VOID
    );
#elif defined(_AMD64_)
#define SpIsArc() FALSE
#else
#define SpIsArc() TRUE
#endif

//
// IsEfi() is always true on IA64 machines. Therefore this determination can
// be made at compile time. When x86 EFI machines are supported, the check
// will need to be made at run time on x86.
//
// Note that EFI_NVRAM_ENABLED is defined in ia64\sources.
//
#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)
#define SpIsEfi() TRUE
#else
BOOLEAN
SpIsEfi(
    VOID
    );
#endif
#else
#define SpIsEfi() FALSE
#endif

PWSTR
SpGetDefaultBootEntry (
    OUT UINT *DefaultSignatureOut
    );


#if defined(_AMD64_) || defined(_X86_)
#include "i386\bootini.h"
#endif // defined(_AMD64_) || defined(_X86_)

#endif // ndef _SPBOOTVARS_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spcab.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    spcab.c

Abstract:

    Cabinet stuff (file compression/decompression)

Author:

    Calin Negreanu (calinn) 27-Apr-2000

Revision History:

    Jay Krell (a-JayK) November 2000 -
        ported from windows\winstate\cobra\utils\cablib\cablib.c to admin\ntsetup\textmode\kernel\spcab.c
        partial nt/unicodification
        gas gauge / progress bar support
--*/

#include "spprecmp.h"
#include "fci.h"
#include "fdi.h"
#include "fcntl.h"
#include "crt/sys/stat.h"
#include "spwin.h"
#include "spcab.h"
#include "spcabp.h"
#include <stdarg.h>
#include "fci.h"
#include "spprintf.h"

/*
PathA on decompression looks like it is set wrong, like it is the full path, including the leaf,
to the .cab, when it is only supposed to be to the directory that contains the .cab.
This is ok, we don't end up using the path, because decompress to fullpaths, not relative paths.
*/

//
// NOTE: fdi opens the cab twice. And we allow that they might seek
// the handles. Thus a small amount of complexity.
//

//
// all these globals except the first should be moved into FDI_CAB_HANDLE.
//
PFDI_CAB_HANDLE g_SpCabFdiHandle;

ANSI_STRING g_CabFileFullPath;
typedef struct _SPCAB_CAB_FILE {
    ULONGLONG Position;
    HANDLE    NtHandle;
    BOOLEAN   Busy;
} SPCAB_CAB_FILE, *PSPCAB_CAB_FILE;
SPCAB_CAB_FILE g_CabFiles[2];
ULONGLONG g_CabFileSize;
ULONGLONG g_CabFileMaximumPosition;
ULONG g_CabLastPercent;
ULONG g_NumberOfOpenCabFiles;

VOID
SpUpdateCabGauge(
    ULONGLONG NewPosition
    )
{
    UINT newPercent;

    if (!RTL_SOFT_VERIFY(g_SpCabFdiHandle != NULL))
        return;
    if (!RTL_SOFT_VERIFY(g_CabFileSize != 0))
        return;

    if (NewPosition > g_CabFileMaximumPosition) {
        g_CabFileMaximumPosition = NewPosition;

        newPercent = (ULONG) (NewPosition * 100 / g_CabFileSize);
        if (newPercent != g_CabLastPercent) {

            g_CabLastPercent = newPercent;
            SpFillGauge (g_SpCabFdiHandle->Gauge, newPercent);

            SendSetupProgressEvent (
                UninstallEvent,
                UninstallUpdateEvent,
                &newPercent
                );
        }
    }
}

BOOLEAN
SpCabIsCabFileName(
    PCSTR FullPath
    )
{
    return g_CabFileFullPath.Buffer != NULL && _stricmp(FullPath, g_CabFileFullPath.Buffer) == 0;
}

PSPCAB_CAB_FILE
SpCabNewCabFile(
    HANDLE NtHandle
    )
{
    ULONG i;

    if (NtHandle == INVALID_HANDLE_VALUE)
        return NULL;

    for (i = 0 ; i < RTL_NUMBER_OF(g_CabFiles) ; ++i) {
        if (!g_CabFiles[i].Busy) {
            g_NumberOfOpenCabFiles += 1;
            g_CabFiles[i].Busy = TRUE;
            g_CabFiles[i].NtHandle = NtHandle;
            g_CabFiles[i].Position = 0;
            return &g_CabFiles[i];
        }
    }
    KdPrint(("SETUP: Ran out of CabFiles g_NumberOfOpenCabFiles:%lu\n", g_NumberOfOpenCabFiles));
    return NULL;
}

VOID
SpCabReleaseCabFile(
    PSPCAB_CAB_FILE CabFile
    )
{
    if (CabFile == NULL)
        return;
    if (!CabFile->Busy)
        return;
    RtlZeroMemory(CabFile, sizeof(*CabFile));
    g_NumberOfOpenCabFiles -= 1;
}

VOID
SpCabCleanupCabGlobals(
    )
{
    ULONG i;

    for (i = 0 ; i < RTL_NUMBER_OF(g_CabFiles) ; ++i) {
        SpCabReleaseCabFile(&g_CabFiles[i]);
    }
    ASSERT(g_NumberOfOpenCabFiles == 0);
    SpDestroyGauge(g_SpCabFdiHandle->Gauge);
    g_SpCabFdiHandle->Gauge = NULL;
    SpFreeStringA(&g_CabFileFullPath);
    g_CabFileSize = 0;
    g_CabFileMaximumPosition = 0;
    g_SpCabFdiHandle = NULL;

    SendSetupProgressEvent (UninstallEvent, UninstallEndEvent, NULL);
}

PSPCAB_CAB_FILE
SpCabFindCabFile(
    HANDLE NtHandle
    )
{
    ULONG i;

    if (NtHandle == INVALID_HANDLE_VALUE)
        return NULL;

    for (i = 0 ; i < RTL_NUMBER_OF(g_CabFiles) ; ++i) {
        if (g_CabFiles[i].NtHandle == NtHandle) {
            return &g_CabFiles[i];
        }
    }
    return NULL;
}


VOID
SpCabCloseHandle(
    HANDLE* HandlePointer
    )
{
    HANDLE Handle = *HandlePointer;

    ASSERT (Handle);    // never NULL

    if (Handle != INVALID_HANDLE_VALUE) {
        *HandlePointer = INVALID_HANDLE_VALUE;
        ZwClose(Handle);
    }
}

INT
DIAMONDAPI
pCabFilePlacedW(
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    PFCI_CAB_HANDLE CabHandle = (PFCI_CAB_HANDLE)Context;

    if (CabHandle == NULL)
        return 0;

    CabHandle->FileCount++;
    CabHandle->FileSize += FileSize;

    return 0;
}

PVOID
DIAMONDAPI
pCabAlloc(
    IN      ULONG Size
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    return SpMemAlloc(Size);
}

VOID
DIAMONDAPI
pCabFree(
    IN      PVOID Memory
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    if (Memory != NULL)
        SpMemFree(Memory);
}

INT_PTR
DIAMONDAPI
pCabOpenForWriteA(
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode,
    OUT     PINT Error,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    HANDLE FileHandle;

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    ASSERT ((oFlag == (_O_CREAT | _O_TRUNC | _O_BINARY | _O_RDWR)) || (oFlag == (_O_CREAT | _O_EXCL | _O_BINARY | _O_RDWR)));
    ASSERT (pMode == (_S_IREAD | _S_IWRITE));

    FileHandle = SpWin32CreateFileA(
                    FileName,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_ARCHIVE,
                    NULL
                    );

    ASSERT (FileHandle);    // never NULL

    if (FileHandle == INVALID_HANDLE_VALUE) {
        *Error = SpGetLastWin32Error();
        FileHandle = (HANDLE)(LONG_PTR)-1;
        goto Exit;
    }
    *Error = 0;
Exit:
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(Handle),
        "SETUP:"__FUNCTION__"(%s) exiting with FileHandle: %p Status:0x%08lx Error:%d\n",
        FileName,  FileHandle, SpGetLastNtStatus(), SpGetLastWin32Error()
        ));
    return (INT_PTR)FileHandle;
}

INT_PTR
DIAMONDAPI
pCabOpenForReadA(
    IN      PSTR FileNameA,
    IN      INT oFlag,
    IN      INT pMode
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    const NTSTATUS StatusGaugeInternalError = STATUS_SUCCESS; // STATUS_INTERNAL_ERROR if
                                                              // gauge was really critical
    const NTSTATUS StatusGaugeNoMemory  = STATUS_SUCCESS; // STATUS_NO_MEMORY if
                                                              // gauge was really critical
    PSPCAB_CAB_FILE CabFile = NULL;
    PVOID Gauge = NULL;

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    ASSERT (oFlag == _O_BINARY);

    FileHandle = SpWin32CreateFileA(
                    FileNameA,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_ARCHIVE,
                    NULL
                    );

    ASSERT (FileHandle);    // never NULL
    if (FileHandle == INVALID_HANDLE_VALUE) {
        FileHandle = (HANDLE)(LONG_PTR)-1;
        goto Exit;
    }

    if (SpCabIsCabFileName(FileNameA)) {
        ULONG CabFileSize32 = 0;

        CabFile = SpCabNewCabFile(FileHandle);
        if (CabFile == NULL) {
            Status = StatusGaugeInternalError;
            goto Exit;
        }
        if (!RTL_VERIFY(g_SpCabFdiHandle != NULL)) {
            Status = StatusGaugeInternalError;
            goto Exit;
        }
        ASSERT((g_CabFileSize == 0) == (g_SpCabFdiHandle->Gauge == NULL));

        if (g_CabFileSize == 0) {
            Status = SpGetFileSize(FileHandle, &CabFileSize32);
            //
            // 0 file size causes an unhandled divide by zero exception in the gauge code
            //
            if (NT_SUCCESS(Status) && CabFileSize32 == 0)
                Status = STATUS_UNSUCCESSFUL;
            if (!NT_SUCCESS(Status)) {
                KdPrintEx((
                    DPFLTR_SETUP_ID,
                    SpNtStatusToDbgPrintLevel(Status),
                    __FUNCTION__" SpGetFileSize(.cab:%s, FileHandle:%p) failed Status:0x%08lx\n",
                    FileNameA,
                    FileHandle,
                    Status
                    ));
                Status = STATUS_SUCCESS; // gauge is sacrificable
                goto Exit;
            }
        }
        if (g_SpCabFdiHandle->Gauge == NULL) {

            // need to update the message
            SpFormatMessage (TemporaryBuffer, sizeof(TemporaryBuffer), SP_TEXT_SETUP_IS_COPYING);

            Gauge =
                SpCreateAndDisplayGauge(CabFileSize32, 0, 15,
                    TemporaryBuffer, NULL, GF_PERCENTAGE, 0);
            if (Gauge == NULL) {
                Status = StatusGaugeNoMemory;
                goto Exit;
            }

            g_SpCabFdiHandle->Gauge = Gauge;
            Gauge = NULL;
            g_CabFileSize = CabFileSize32;

            SendSetupProgressEvent (UninstallEvent, UninstallStartEvent, NULL);
        }
        CabFile = NULL;
    }

Exit:
    if (Gauge != NULL)
        SpDestroyGauge(Gauge);
    if (CabFile != NULL)
        SpCabReleaseCabFile(CabFile);

    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(Handle),
        __FUNCTION__"(%s) exiting with FileHandle:%p Status:0x%08lx Error:%d\n",
        FileNameA,  FileHandle, SpGetLastNtStatus(), SpGetLastWin32Error()
        ));
    return (INT_PTR)FileHandle;
}

UINT
DIAMONDAPI
pCabRead(
    IN      INT_PTR FileHandleInteger,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,          OPTIONAL
    IN      PVOID ContextIgnored OPTIONAL
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    BOOL Result;
    UINT BytesRead;
    HANDLE FileHandle = (HANDLE)FileHandleInteger;
    PSPCAB_CAB_FILE CabFile = NULL;

    Result = SpWin32ReadFile(FileHandle, Buffer, Size, &BytesRead, NULL);
    if (!Result) {
        if (Error != NULL) {
            *Error = SpGetLastWin32Error();
        }
        return ((UINT)(-1));
    }

    if (CabFile = SpCabFindCabFile(FileHandle)) {
        CabFile->Position += BytesRead;

        SpUpdateCabGauge(CabFile->Position);
    }

    if (Error != NULL) {
        *Error = 0;
    }
    return BytesRead;
}

UINT
DIAMONDAPI
pCabRead1(
    IN      INT_PTR FileHandleInteger,
    IN      PVOID Buffer,
    IN      UINT Size
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    const UINT i = pCabRead(FileHandleInteger, Buffer, Size, NULL, NULL);
    return i;
}

UINT
DIAMONDAPI
pCabWrite(
    IN      INT_PTR FileHandleInteger,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    BOOL Result;
    DWORD BytesWritten;
    HANDLE FileHandle = (HANDLE)FileHandleInteger;

    //
    // g_CabNtFileHandle is only set for reading, so..
    //
    ASSERT(SpCabFindCabFile(FileHandle) == NULL);

    Result = SpWin32WriteFile(FileHandle, Buffer, Size, &BytesWritten, NULL/*overlapped*/);
    if (!Result) {
        *Error = SpGetLastWin32Error();
        return (UINT)-1;
    }
    else if (BytesWritten != Size) {
        *Error = -1;
        return (UINT)-1;
    }
    *Error = 0;
    return Size;
}

UINT
DIAMONDAPI
pCabWrite1(
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    INT ErrorIgnored;
    const PVOID ContextIgnored = NULL;

    const BOOL Result = pCabWrite(FileHandle, Buffer, Size, &ErrorIgnored, ContextIgnored);

    return Result;
}

INT
DIAMONDAPI
pCabClose(
    IN      INT_PTR FileHandleInteger,
    OUT     PINT Error,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    HANDLE Handle = (HANDLE)FileHandleInteger;
    PSPCAB_CAB_FILE CabFile = NULL;

    if (CabFile = SpCabFindCabFile(Handle)) {
        SpCabReleaseCabFile(CabFile);
    }

    SpCabCloseHandle(&Handle);
    if (Error != NULL) {
        *Error = 0;
    }
    return 0;
}

INT
DIAMONDAPI
pCabClose1(
    IN      INT_PTR FileHandleInteger
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    const INT Result = pCabClose(FileHandleInteger, NULL, NULL);
    return Result;
}

LONG
DIAMONDAPI
pCabSeek(
    IN      INT_PTR FileHandleInteger,
    IN      LONG Distance,
    IN      INT CrtSeekType,
    OUT     PINT Error,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    ULONG NewPosition = 0;
    ULONG Win32SeekType = FILE_BEGIN;
    HANDLE FileHandle = (HANDLE)FileHandleInteger;
    PSPCAB_CAB_FILE CabFile = NULL;

    CabFile = SpCabFindCabFile (FileHandle);

    switch (CrtSeekType) {
    case SEEK_SET:
        Win32SeekType = FILE_BEGIN;
        break;
    case SEEK_CUR:
        Win32SeekType = FILE_CURRENT;
        break;
    case SEEK_END:
        Win32SeekType = FILE_END;
        break;
    }

    NewPosition = SpSetFilePointer(FileHandle, Distance, NULL, Win32SeekType);

    if (NewPosition == INVALID_SET_FILE_POINTER) {
        if (Error != NULL) {
            *Error = SpGetLastWin32Error();
        }
        return -1;
    }
    if (Error != NULL) {
        *Error = 0;
    }

    if (CabFile != NULL) {
        SpUpdateCabGauge(CabFile->Position = NewPosition);
    }

    return ((LONG)(NewPosition));
}

LONG
DIAMONDAPI
pCabSeek1(
    IN      INT_PTR FileHandleInteger,
    IN      LONG Distance,
    IN      INT CrtSeekType
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    const LONG NewPosition = pCabSeek(FileHandleInteger, Distance, CrtSeekType, NULL, NULL);
    return NewPosition;
}

INT
DIAMONDAPI
pCabDeleteA(
    IN      PSTR FileName,
    OUT     PINT Error,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    if (!SpWin32DeleteFileA(FileName)) {
        *Error = SpGetLastWin32Error();
        return -1;
    }
    *Error = 0;
    return 0;
}

BOOL
DIAMONDAPI
pCabGetTempFileA(
    OUT     PSTR FileName,
    IN      INT FileNameLen,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    static LARGE_INTEGER Counter = { 0 };
    PFCI_CAB_HANDLE cabHandle;

    cabHandle = (PFCI_CAB_HANDLE) Context;
    if (cabHandle == NULL) {
        ASSERT (FALSE);
        return FALSE;
    }

    ASSERT(FileNameLen >= 256);

    //
    // Seeding the counter based on the time should increase reliability
    // in the face of crash/rerun cycles, compared to just starting it at 0.
    //
    // We should/could also/instead loop while the resulting name exists,
    // but I'm putting this in after having tested, so stick with this simpler change.
    //
    if (Counter.QuadPart == 0) {
        KeQuerySystemTime(&Counter); // NtQuerySystemTime in usermode
    }

    Counter.QuadPart += 1;

    if(_snprintf(FileName, 
                 FileNameLen, 
                 "%hs\\spcab%I64d", 
                 cabHandle->PathA.Buffer, 
                 Counter.QuadPart) < 0){
        FileName[FileNameLen - 1] = '\0';
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            __FUNCTION__":(%s) is truncated\n",
            FileName
            ));
        ASSERT (FALSE);
        return FALSE;
    }

    KdPrintEx((
        DPFLTR_SETUP_ID,
        DPFLTR_TRACE_LEVEL,
        __FUNCTION__":%s\n",
        FileName
        ));

    return TRUE;
}

BOOL
DIAMONDAPI
pCabGetNextCabinet(
     IN     PCCAB FciCabParams,
     IN     ULONG PrevCabinetSize,
     IN     PVOID Context
     )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    ASSERTMSG("We fit in a single cabinet.", FALSE);
    return FALSE;
}

LONG
DIAMONDAPI
pCabStatus(
    IN      UINT StatusType,
    IN      ULONG Size1,
    IN      ULONG Size2,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    PFCI_CAB_HANDLE CabHandle = NULL;

    if (StatusType == statusCabinet) {

        CabHandle = (PFCI_CAB_HANDLE) Context;
        if (CabHandle == NULL) {
            return 0;
        }

        CabHandle->CabCount++;
        CabHandle->CompressedSize += Size2;
    }
    return 0;
}

INT_PTR
DIAMONDAPI
pCabGetOpenInfoA(
    IN      PSTR    FileName,
    OUT     USHORT* Date,
    OUT     USHORT* Time,
    OUT     USHORT* Attributes,
    OUT     PINT    Error,
    IN      PVOID   Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    FILETIME LocalFileTime = { 0 };
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    BOOL     DoesFileExist = FALSE;
    WIN32_FILE_ATTRIBUTE_DATA FileAttributeData = { 0 };

    //
    // It seems like it'd be better to open the file, and if that succeeds,
    // get the information from the handle. Anyway, we just mimic the winstate code for now.
    //

    DoesFileExist = SpGetFileAttributesExA(FileName, GetFileExInfoStandard, &FileAttributeData);
    if (DoesFileExist) {

        SpFileTimeToLocalFileTime(&FileAttributeData.ftLastWriteTime, &LocalFileTime);
        SpFileTimeToDosDateTime(&LocalFileTime, Date, Time);

        /*
         * Mask out all other bits except these four, since other
         * bits are used by the cabinet format to indicate a
         * special meaning.
         */
        *Attributes = (USHORT) (FileAttributeData.dwFileAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));

        FileHandle = SpWin32CreateFileA(
                        FileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

        ASSERT (FileHandle);    // never NULL
        if (FileHandle == INVALID_HANDLE_VALUE) {
            *Error = SpGetLastWin32Error();
            return -1;
        }
        *Error = 0;
        return (INT_PTR)FileHandle;
    } else {
        *Error = SpGetLastWin32Error();
        return -1;
    }
}

BOOLEAN
SpCabIsFullPath(
    PCANSI_STRING p
    )
{
    const ULONG Length = p->Length / sizeof(p->Buffer[0]);
    if (Length < 4)
        return FALSE;
    if (p->Buffer[0] == '\\' && p->Buffer[1] == '\\')
        return TRUE;
    if (p->Buffer[1] == ':' && p->Buffer[2] == '\\')
        return TRUE;
    if (   p->Buffer[0] == '\\'
        && p->Buffer[1] == '?'
        && p->Buffer[2] == '?'
        && p->Buffer[3] == '\\'
        )
        return TRUE;
    if (    p->Buffer[0] == '\\'
        && (p->Buffer[1] == 'D' || p->Buffer[1] == 'd' )
        && (p->Buffer[2] == 'E' || p->Buffer[2] == 'e' )
        && (p->Buffer[3] == 'V' || p->Buffer[3] == 'v' )
        )
        return TRUE;
    KdPrint(("SETUP: Warning: "__FUNCTION__"(%Z):FALSE\n", p));
    return FALSE;
}


VOID
pRecordDataLoss (
    VOID
    )

/*++

Routine Description:

  This routine creates a file called dataloss, so that the backup
  CABs don't get removed from the system.

Arguments:

  None.

Return Value:

  None.

--*/

{
    UNICODE_STRING  UnicodeString;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    NTSTATUS Status;

    //
    // We failed to create the subdirectory for this file.
    // Put a file in the ~bt directory to prevent the undo
    // directory from being removed.
    //

    if((wcslen(NtBootDevicePath) + 1/*'\\'*/ + 
        wcslen(DirectoryOnBootDevice) + 1/*'\\'*/ + 1/*'\0'*/) > ARRAYSIZE(TemporaryBuffer)){
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            __FUNCTION__":Buffer is smaller than need\n"));
        ASSERT(FALSE);
        return;
    }

    wcscpy (TemporaryBuffer, NtBootDevicePath);
    SpConcatenatePaths (TemporaryBuffer, DirectoryOnBootDevice);
    SpConcatenatePaths (TemporaryBuffer, L"dataloss");

    INIT_OBJA (&obja, &UnicodeString, TemporaryBuffer);

    Status = ZwCreateFile(
                &Handle,
                FILE_GENERIC_WRITE|SYNCHRONIZE|FILE_READ_ATTRIBUTES,
                &obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,
                FILE_CREATE,
                FILE_SYNCHRONOUS_IO_NONALERT|FILE_NON_DIRECTORY_FILE,
                NULL,
                0
                );

    if (NT_SUCCESS(Status)) {
        ZwClose (Handle);
    }
}




INT_PTR
DIAMONDAPI
pCabNotification(
    IN      FDINOTIFICATIONTYPE FdiNotificationType,
    IN OUT  PFDINOTIFICATION FdiNotification
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    PSTR DestFileA = NULL;
    ANSI_STRING DestFileStringA = { 0 };
    UNICODE_STRING DestFileStringW = { 0 };
    HANDLE DestHandle = INVALID_HANDLE_VALUE;
    ULONG FileAttributes = 0;
    FILETIME LocalFileTime = { 0 };
    FILETIME FileTime = { 0 };
    PCAB_DATA CabData = NULL;
    INT_PTR Result = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    PCSTR psz1 = NULL;
    ANSI_STRING psz1String = { 0 };
    UNICODE_STRING NtPathString = { 0 };
    WCHAR ntPathTemp[ACTUAL_MAX_PATH];
    CHAR ntPath[ACTUAL_MAX_PATH];
    BOOLEAN b;
    
    switch (FdiNotificationType) {
    case fdintCABINET_INFO:     // General information about cabinet
        break;
    case fdintCOPY_FILE:        // File to be copied
        CabData = (PCAB_DATA)FdiNotification->pv;
        psz1 = FdiNotification->psz1;
        
        {
            RtlInitAnsiString(&psz1String, psz1);
            psz1String.Length = psz1String.MaximumLength; // include terminal nul
            Status = RtlAnsiStringToUnicodeString(&NtPathString, &psz1String, TRUE);
            if (!NT_SUCCESS(Status)) {
                KdPrintEx((
                    DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: Cannot convert ansi string %s to nt\n",
                    psz1String.Buffer
                    ));
                goto NtExit;
            }

            b = SpNtNameFromDosPath (
                    NtPathString.Buffer,
                    ntPathTemp,
                    sizeof(ntPathTemp),
                    PartitionOrdinalCurrent
                    );
            
            RtlFreeUnicodeString(&NtPathString);

            if (!b) {
                KdPrintEx((
                    DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: Cannot convert path %ws to an NT path\n",
                    NtPathString.Buffer
                    ));
                goto Exit;
            }
            
            RtlInitUnicodeString(&NtPathString, ntPathTemp);
            NtPathString.Length = NtPathString.MaximumLength; // include terminal nul
            
            psz1String.Buffer = (PSTR)ntPath;
            psz1String.Length = 0;
            psz1String.MaximumLength = sizeof(ntPath);
            Status = RtlUnicodeStringToAnsiString(&psz1String, &NtPathString, FALSE);
            if (!NT_SUCCESS(Status)) {
                KdPrintEx((
                    DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: Cannot convert nt string %ws to ansi\n",
                    NtPathString.Buffer
                    ));
                goto NtExit;
            }
            
            psz1 = psz1String.Buffer;
        }
        
        if (SpCabIsFullPath(&psz1String)) {
            //
            // This is always the case in Win9x uninstall.
            //
            DestFileA = SpDupString(psz1);
        }
        else {
            DestFileA = SpJoinPathsA(CabData->ExtractPathA.Buffer, psz1);
        }

        if (DestFileA == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        if (CabData->NotificationA != NULL) {
            if (CabData->NotificationA(DestFileA)) {
                Status = SpCreateDirectoryForFileA(DestFileA, CREATE_DIRECTORY_FLAG_SKIPPABLE);

                if (!NT_SUCCESS(Status)) {
                    pRecordDataLoss();

                    Result = 0;
                    goto Exit;
                }

                DestHandle = SpCreateFile1A(DestFileA);
                ASSERT (DestHandle);    // never NULL
            }
        } else if (CabData->NotificationW != NULL) {

            RtlInitAnsiString(&DestFileStringA, DestFileA);
            DestFileStringA.Length = DestFileStringA.MaximumLength; // include terminal nul
            Status = SpAnsiStringToUnicodeString(&DestFileStringW, &DestFileStringA, TRUE);

            if (!NT_SUCCESS(Status)) {
                goto NtExit;
            }

            if (CabData->NotificationW(DestFileStringW.Buffer)) {
                //
                // Ensure the directory exists. If we can't create the
                // dir, then record data loss and skip the file.
                //

                Status = SpCreateDirectoryForFileA(DestFileA, CREATE_DIRECTORY_FLAG_SKIPPABLE);
                if (!NT_SUCCESS(Status)) {
                    pRecordDataLoss();

                    Result = 0;
                    goto Exit;
                }

                DestHandle = SpCreateFile1A(DestFileA);
                ASSERT (DestHandle);    // never NULL
            }
        } else {
            DestHandle = SpCreateFile1A(DestFileA);
            ASSERT (DestHandle);    // never NULL
        }

        Result = (INT_PTR)DestHandle;

        //
        // If SpCreateFile1A fails, then enable preservation of
        // the backup cabs, but don't fail uninstall.
        //

        if (Result == -1) {
            pRecordDataLoss();

            Result = 0;
            goto Exit;
        }

        goto Exit;

    case fdintCLOSE_FILE_INFO:  // close the file, set relevant info
        CabData = (PCAB_DATA)FdiNotification->pv;
        if (SpDosDateTimeToFileTime(FdiNotification->date, FdiNotification->time, &LocalFileTime)) {
            if (SpLocalFileTimeToFileTime(&LocalFileTime, &FileTime)) {
                //
                // error here is probably ignorable..
                //
                SpSetFileTime((HANDLE)FdiNotification->hf, &FileTime, &FileTime, &FileTime);
            }
        }
        SpCabCloseHandle((HANDLE*)(&FdiNotification->hf));

        psz1 = FdiNotification->psz1;
        RtlInitAnsiString(&psz1String, psz1);

        if (SpCabIsFullPath(&psz1String)) {
            //
            // This is always the case in Win9x uninstall.
            //
            DestFileA = SpDupString(psz1);
        }
        else {
            DestFileA = SpJoinPathsA(CabData->ExtractPathA.Buffer, psz1);
        }

        FileAttributes = (FdiNotification->attribs & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));
        if (DestFileA != NULL) {
            //
            // error here is probably ignorable..
            //
            SpSetFileAttributesA(DestFileA, FileAttributes);
        }
        Result = TRUE;
        break;
    case fdintPARTIAL_FILE:     // First file in cabinet is continuation
        break;
    case fdintENUMERATE:        // Enumeration status
        break;
    case fdintNEXT_CABINET:     // File continued to next cabinet
        break;
    }
Exit:
    
    if (DestFileA != NULL){
        SpMemFree(DestFileA);
    }
    
    SpFreeStringW(&DestFileStringW);
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpNtStatusToDbgPrintLevel(Status),
        "SETUP:"__FUNCTION__" exiting Status:0x%08lx Error:%d\n",
        SpGetLastNtStatus(), SpGetLastWin32Error()));
    return Result;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

CCABHANDLE
SppCabCreateCabinet(
    PANSI_STRING    CabPathA,
    PANSI_STRING    CabFileFormatA,
    PANSI_STRING    CabDiskFormatA,
    PUNICODE_STRING CabPathW,
    PUNICODE_STRING CabFileFormatW,
    PUNICODE_STRING CabDiskFormatW,
    IN LONG         MaxFileSize
    )
/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabPathA - Specifies the path where the new cabinet file will be.

  CabFileFormat - Specifies (as for wsprintf) the format of the cabinet file name.

  CabDiskFormat - Specifies (as for wsprintf) the format of the cabinet disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/
{
    PFCI_CAB_HANDLE CabHandle = NULL;
    PFCI_CAB_HANDLE CabHandleRet = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    if (CabFileFormatA == NULL
        && CabFileFormatW == NULL
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto NtExit;
    }
    if (MaxFileSize < 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto NtExit;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x7FFFFFFF;
    }

    CabHandle = (PFCI_CAB_HANDLE)SpMemAlloc(sizeof (*CabHandle));
    if (CabHandle == NULL) {
        Status  = STATUS_NO_MEMORY;
        goto NtExit;
    }
    RtlZeroMemory(CabHandle, sizeof(*CabHandle));

#if DBG
    KeQuerySystemTime(&CabHandle->StartTime);
#endif

    SpMoveStringA(&CabHandle->PathA, CabPathA);
    SpMoveStringA(&CabHandle->FileFormatA, CabFileFormatA);
    SpMoveStringA(&CabHandle->DiskFormatA, CabDiskFormatA);
    SpMoveStringW(&CabHandle->PathW, CabPathW);
    SpMoveStringW(&CabHandle->FileFormatW, CabFileFormatW);
    SpMoveStringW(&CabHandle->DiskFormatW, CabDiskFormatW);

    // fill out the CCAB structure (other than the zeros)
    CabHandle->FciCabParams.cb = MaxFileSize;
    CabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    CabHandle->FciCabParams.iCab = 1;
    CabHandle->FciCabParams.iDisk = 1;

    if (CabHandle->PathA.Buffer != NULL && CabHandle->PathA.Buffer[0] != 0) {
        SpStringCopyNA(CabHandle->FciCabParams.szCabPath, CabHandle->PathA.Buffer, RTL_NUMBER_OF(CabHandle->FciCabParams.szCabPath) - 2);
        SpEnsureTrailingBackSlashA(CabHandle->FciCabParams.szCabPath);
    }
    if (CabHandle->DiskFormatA.Buffer != NULL && CabHandle->DiskFormatA.Buffer[0] != 0) {
        SpFormatStringA(CabHandle->FciCabParams.szDisk, RTL_NUMBER_OF(CabHandle->FciCabParams.szDisk), CabHandle->DiskFormatA.Buffer, CabHandle->FciCabParams.iDisk);
    }
    if (CabHandle->FileFormatA.Buffer != NULL && CabHandle->FileFormatA.Buffer[0] != 0) {
        SpFormatStringA(CabHandle->FciCabParams.szCab, RTL_NUMBER_OF(CabHandle->FciCabParams.szCab), CabHandle->FileFormatA.Buffer, CabHandle->FciCabParams.iCab);
    }

    CabHandle->FciHandle = FCICreate(
                                &CabHandle->FciErrorStruct,
                                pCabFilePlacedA,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenForWriteA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &CabHandle->FciCabParams,
                                CabHandle
                                );
    if (CabHandle->FciHandle == NULL)
        goto Exit;

    CabHandleRet = CabHandle;
    CabHandle = NULL;
Exit:
    if (CabHandle != NULL) {
        SpCabFlushAndCloseCabinet(CabHandle);
        CabHandle = NULL;
    }
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(CabHandleRet),
        "SETUP:"__FUNCTION__" exiting Handle:%p Status:0x%08lx Error:%d\n",
        CabHandleRet, SpGetLastNtStatus(), SpGetLastWin32Error()));
    return CabHandleRet;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

CCABHANDLE
SpCabCreateCabinetW(
    IN      PCWSTR CabPathW,
    IN      PCWSTR CabFileFormatW,
    IN      PCWSTR CabDiskFormatW,
    IN      LONG MaxFileSize
    )
/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabPathW - Specifies the path where the new cabinet file will be.

  CabFileFormat - Specifies (as for wsprintf) the format of the cabinet file name.

  CabDiskFormat - Specifies (as for wsprintf) the format of the cabinet disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/
{
    ANSI_STRING    CabPathStringA = { 0 };
    ANSI_STRING    CabFileFormatStringA = { 0 };
    ANSI_STRING    CabDiskFormatStringA = { 0 };
    UNICODE_STRING CabPathStringW = { 0 };
    UNICODE_STRING CabFileFormatStringW = { 0 };
    UNICODE_STRING CabDiskFormatStringW = { 0 };
    CCABHANDLE      CabHandle = NULL;
    NTSTATUS        Status = STATUS_SUCCESS;

    KdPrintEx((
        DPFLTR_SETUP_ID,
        DPFLTR_TRACE_LEVEL,
        __FUNCTION__"(%ls, %ls, %ls)\n", CabPathW, CabFileFormatW, CabDiskFormatW
        ));

    Status = SpConvertToNulTerminatedNtStringsW(CabPathW, &CabPathStringA, &CabPathStringW);
    if (!NT_SUCCESS(Status))
        goto NtExit;
    Status = SpConvertToNulTerminatedNtStringsW(CabFileFormatW, &CabFileFormatStringA, &CabFileFormatStringW);
    if (!NT_SUCCESS(Status))
        goto NtExit;
    Status = SpConvertToNulTerminatedNtStringsW(CabDiskFormatW, &CabDiskFormatStringA, &CabDiskFormatStringW);
    if (!NT_SUCCESS(Status))
        goto NtExit;

    CabHandle =
        SppCabCreateCabinet(
            &CabPathStringA,
            &CabFileFormatStringA,
            &CabDiskFormatStringA,
            &CabPathStringW,
            &CabFileFormatStringW,
            &CabDiskFormatStringW,
            MaxFileSize
            );

Exit:
    SpFreeStringA(&CabDiskFormatStringA);
    SpFreeStringA(&CabFileFormatStringA);
    SpFreeStringA(&CabPathStringA);
    SpFreeStringW(&CabDiskFormatStringW);
    SpFreeStringW(&CabFileFormatStringW);
    SpFreeStringW(&CabPathStringW);
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(CabHandle),
        "SETUP:"__FUNCTION__" exiting Handle:%p Status:0x%08lx Error:%d\n",
        CabHandle, SpGetLastNtStatus(), SpGetLastWin32Error()));
    return CabHandle;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

CCABHANDLE
SppCabCreateCabinetEx(
    IN      PCABGETCABINETNAMESA GetCabinetNamesA,
    IN      PCABGETCABINETNAMESW GetCabinetNamesW,
    IN      LONG MaxFileSize
    )
/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  GetCabinetNames - Specifies a callback used to decide cabinet path, cabinet name and disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/
{
    PFCI_CAB_HANDLE CabHandle = NULL;
    PFCI_CAB_HANDLE CabHandleRet = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    typedef struct FRAME {
        WCHAR szDisk[CB_MAX_DISK_NAME];
        WCHAR szCab[CB_MAX_CABINET_NAME];
        WCHAR szCabPath[CB_MAX_CAB_PATH];
    } FRAME, *PFRAME;
    PFRAME Frame = NULL;

    if (GetCabinetNamesA == NULL && GetCabinetNamesW == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto NtExit;
    }
    if (MaxFileSize < 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto NtExit;
    }
    if (MaxFileSize == 0) {
        MaxFileSize = 0x80000000;
    }

    CabHandle = (PFCI_CAB_HANDLE)SpMemAlloc(sizeof(*CabHandle));
    if (CabHandle == NULL) {
        Status  = STATUS_NO_MEMORY;
        goto NtExit;
    }
    RtlZeroMemory(CabHandle, sizeof(*CabHandle));
    CabHandle->GetCabinetNamesA = GetCabinetNamesA;
    CabHandle->GetCabinetNamesW = GetCabinetNamesW;

    // fill out the CCAB structure
    CabHandle->FciCabParams.cb = MaxFileSize;
    CabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    CabHandle->FciCabParams.iCab = 1;
    CabHandle->FciCabParams.iDisk = 1;
    if (GetCabinetNamesA != NULL) {
        if (!GetCabinetNamesA(
                CabHandle->FciCabParams.szCabPath,
                RTL_NUMBER_OF(CabHandle->FciCabParams.szCabPath),
                CabHandle->FciCabParams.szCab,
                RTL_NUMBER_OF(CabHandle->FciCabParams.szCab),
                CabHandle->FciCabParams.szDisk,
                RTL_NUMBER_OF(CabHandle->FciCabParams.szDisk),
                CabHandle->FciCabParams.iCab,
                &CabHandle->FciCabParams.iDisk
                )) {
            goto Exit;
        }
    }
    else if (GetCabinetNamesW != NULL) {
        Frame = (PFRAME)SpMemAlloc(sizeof(*Frame));
        if (Frame == NULL) {
            Status = STATUS_NO_MEMORY;
            goto NtExit;
        }
        if (!GetCabinetNamesW(
                Frame->szCabPath,
                RTL_NUMBER_OF(Frame->szCabPath),
                Frame->szCab,
                RTL_NUMBER_OF(Frame->szCab),
                Frame->szDisk,
                RTL_NUMBER_OF(Frame->szDisk),
                CabHandle->FciCabParams.iCab,
                &CabHandle->FciCabParams.iDisk
                )) {
            goto Exit;
        Status = SpKnownSizeUnicodeToDbcsN(CabHandle->FciCabParams.szCabPath, Frame->szCabPath, RTL_NUMBER_OF(CabHandle->FciCabParams.szCabPath));
        if (!NT_SUCCESS(Status))
            goto NtExit;
        Status = SpKnownSizeUnicodeToDbcsN(CabHandle->FciCabParams.szCab, Frame->szCab, RTL_NUMBER_OF(CabHandle->FciCabParams.szCab));
        if (!NT_SUCCESS(Status))
            goto NtExit;
        Status = SpKnownSizeUnicodeToDbcsN(CabHandle->FciCabParams.szDisk, Frame->szDisk, RTL_NUMBER_OF(CabHandle->FciCabParams.szDisk));
        if (!NT_SUCCESS(Status))
            goto NtExit;
        }
    }
    CabHandle->FciHandle = FCICreate(
                                &CabHandle->FciErrorStruct,
                                pCabFilePlacedA,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenForWriteA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &CabHandle->FciCabParams,
                                CabHandle
                                );
    if (CabHandle->FciHandle == NULL)
        goto Exit;
    CabHandleRet = CabHandle;
    CabHandle = NULL;
Exit:
    if (CabHandle != NULL) {
        SpCabFlushAndCloseCabinet(CabHandle);
        goto Exit;
    }
    if (Frame != NULL)
        SpMemFree(Frame);
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(CabHandleRet),
        "SETUP:"__FUNCTION__" exiting Handle:%p Status:0x%08lx Error:%d\n",
        CabHandleRet, SpGetLastNtStatus(), SpGetLastWin32Error()));
    return (CCABHANDLE)CabHandleRet;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

CCABHANDLE
SpCabCreateCabinetExW(
    IN      PCABGETCABINETNAMESW GetCabinetNamesW,
    IN      LONG MaxFileSize
    )
/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabGetCabinetNames - Specifies a callback used to decide cabinet path, cabinet name and disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/
{
    const PFCI_CAB_HANDLE CabHandle = SppCabCreateCabinetEx(NULL, GetCabinetNamesW, MaxFileSize);
    return CabHandle;
}

TCOMP
SpCabGetCompressionTypeForFile(
    PFCI_CAB_HANDLE CabHandle,
    IN PCWSTR FileName
    )
/*++
don't compress small files
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    TCOMP CompressionType = tcompTYPE_MSZIP;
    ULONG FileSize = 0;
    ULONG SmallFileSize = 4096;
    HANDLE FileHandle = NULL;
    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes = RTL_INIT_OBJECT_ATTRIBUTES(&UnicodeString, OBJ_CASE_INSENSITIVE);
    IO_STATUS_BLOCK IoStatusBlock;

    RtlInitUnicodeString(&UnicodeString, FileName);

    if (CabHandle != NULL) {
        if (CabHandle->SmallFileCompressionType == CabHandle->CompressionType)
            return CabHandle->CompressionType;
        if (CabHandle->SmallFileSize != 0)
            SmallFileSize = CabHandle->SmallFileSize;
        CompressionType = CabHandle->CompressionType;
    }

    Status =
        ZwOpenFile(
            &FileHandle,
            FILE_GENERIC_READ | FILE_GENERIC_WRITE,
            &ObjectAttributes,
            &IoStatusBlock,
            0,
            FILE_SYNCHRONOUS_IO_NONALERT);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Status = SpGetFileSize(FileHandle, &FileSize);
    if (!NT_SUCCESS(Status))
        goto Exit;

    if (FileSize < SmallFileSize)
        Status = tcompTYPE_NONE;
Exit:
    SpCabCloseHandle(&FileHandle);
    return CompressionType;
}

NTSTATUS
SpCabAddFileToCabinetW(
    IN      CCABHANDLE Handle,
    IN      PCWSTR FileNameW,
    IN      PCWSTR StoredNameW
    )
/*++

Routine Description:

  Compresses and adds a file to a cabinet context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileNameW - Specifies the file to be added.

  StoredNameW - Specifies the name to be stored in the cabinet file.

  FileCount - Specifies a count of files, receives the updated count
              when cabinet files are created

  FileSize - Specifies the number of bytes used by the file, receives
             the updated size

Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    ANSI_STRING FileNameA = { 0 };
    ANSI_STRING StoredNameA = { 0 };
    BOOL FreeStoredNameA = FALSE;
    PFCI_CAB_HANDLE CabHandle = (PFCI_CAB_HANDLE)Handle;
    NTSTATUS status = STATUS_SUCCESS;
    BOOL b;

    if (CabHandle == NULL) {
        status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (CabHandle->FciHandle == NULL) {
        status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (StoredNameW == NULL) {
        StoredNameW = FileNameW;
    }

    if (FileNameW == NULL) {
        FileNameW = StoredNameW;
    }

    status = SpConvertToNulTerminatedNtStringsW(FileNameW, &FileNameA, NULL);
    if (!NT_SUCCESS(status)) {
        goto NtExit;
    }

    if (FileNameW != StoredNameW) {
        FreeStoredNameA = FALSE;
        status = SpConvertToNulTerminatedNtStringsW(StoredNameW, &StoredNameA, NULL);
        if (!NT_SUCCESS(status)) {
            goto NtExit;
        }
    } else {
        StoredNameA = FileNameA;
    }

    b = FCIAddFile(
            CabHandle->FciHandle,
            FileNameA.Buffer,
            StoredNameA.Buffer,
            FALSE,
            pCabGetNextCabinet,
            pCabStatus,
            pCabGetOpenInfoA,
            CabHandle->CompressionType
            );

    if (!b) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpBoolToDbgPrintLevel(b),
            "SETUP:"__FUNCTION__" FCIAddFile failed.\n"
            ));
        status = SpGetLastNtStatus();
        goto Exit;
    }

    ASSERT (NT_SUCCESS (status));

Exit:
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpBoolToDbgPrintLevel(NT_SUCCESS (status)),
        "SETUP:"__FUNCTION__" exiting Success:%s Status:0x%08lx Error:%d\n",
        SpBoolToStringA(NT_SUCCESS (status)),
        SpGetLastNtStatus(),
        SpGetLastWin32Error()
        ));

    SpFreeStringA(&FileNameA);
    if (FreeStoredNameA) {
        SpFreeStringA(&StoredNameA);
    }

    return status;

NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(status);
    goto Exit;
}

BOOL
SpCabFlushAndCloseCabinetEx(
    IN      CCABHANDLE Handle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    )
/*++

Routine Description:

  Completes a cabinet file and closes its context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileCount - Receives the number of files added to the cab

  FileSize - Receives the size of all files before compression

  CabFileCount - Receives the number of cabinet files created

  CabFileSize - Receives the size of all cabinet files

Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    PFCI_CAB_HANDLE CabHandle = (PFCI_CAB_HANDLE) Handle;
    BOOL Result = FALSE;

    if (CabHandle == NULL) {
        goto Exit;
    }
    if (CabHandle->FciHandle != NULL) {
        if (!FCIFlushCabinet(
                CabHandle->FciHandle,
                FALSE,
                pCabGetNextCabinet,
                pCabStatus
                ))
            goto Exit;
    }


#if DBG
    {
        TIME_FIELDS TimeFields;
        LARGE_INTEGER EndTime = { 0 };
        LARGE_INTEGER Duration = { 0 };

        KeQuerySystemTime(&EndTime);
        Duration.QuadPart = EndTime.QuadPart - CabHandle->StartTime.QuadPart;
        RtlTimeToElapsedTimeFields(&Duration, &TimeFields);

        KdPrint((
            "SETUP: Cab %wZ\\%wZ %lu files compressed from %I64u to %I64u in %d minutes %d seconds\n",
            &CabHandle->PathW,
            &CabHandle->FileFormatW,
            (ULONG)CabHandle->FileCount,
            (ULONGLONG)CabHandle->FileSize,
            (ULONGLONG)CabHandle->CompressedSize,
            (int)TimeFields.Minute,
            (int)TimeFields.Second
            ));
    }
#endif

    SpFreeStringA(&CabHandle->PathA);
    SpFreeStringA(&CabHandle->FileFormatA);
    SpFreeStringA(&CabHandle->DiskFormatA);
    SpFreeStringW(&CabHandle->PathW);
    SpFreeStringW(&CabHandle->FileFormatW);
    SpFreeStringW(&CabHandle->DiskFormatW);

    if (CabHandle->FciHandle != NULL) {
        Result = FCIDestroy(CabHandle->FciHandle);
        CabHandle->FciHandle = NULL;
    }

    if (FileCount)
        *FileCount = CabHandle->FileCount;

    if (FileSize)
        *FileSize = CabHandle->FileSize;

    if (CabFileCount)
        *CabFileCount = CabHandle->CabCount;

    if (CabFileSize)
        *CabFileSize = CabHandle->CompressedSize;

    Result = TRUE;
Exit:
    return Result;
}

OCABHANDLE
SppCabOpenCabinet(
    IN       PCSTR FileNameA,
    IN      PCWSTR FileNameW
    )
/*++

Routine Description:

  Creates a cabinet context for an existent cabinet file.

Arguments:

  FileName - Specifies cabinet file name.

Return Value:

  a valid OCABHANDLE if successful, NULL otherwise.

--*/
{
    PFDI_CAB_HANDLE CabHandleRet = NULL;
    PFDI_CAB_HANDLE CabHandle = NULL;
    PSTR FilePtrA = NULL;
    PWSTR FilePtrW = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    ANSI_STRING LocalFileNameA = { 0 };
    UNICODE_STRING LocalFileNameW = { 0 };
    NTSTATUS Status = STATUS_SUCCESS;

    CabHandle = (PFDI_CAB_HANDLE) SpMemAlloc(sizeof(*CabHandle));
    if (CabHandle == NULL) {
        Status = STATUS_NO_MEMORY;
        goto NtExit;
    }
    RtlZeroMemory(CabHandle, sizeof(*CabHandle));

    CabHandle->FdiHandle = FDICreate(
                                pCabAlloc,
                                pCabFree,
                                pCabOpenForReadA,
                                pCabRead1,
                                pCabWrite1,
                                pCabClose1,
                                pCabSeek1,
                                cpuUNKNOWN, // ignored
                                &CabHandle->FdiErrorStruct
                                );
    if (CabHandle->FdiHandle == NULL) {
        goto Exit;
    }
    if (FileNameW != NULL) {
        Status = SpConvertToNulTerminatedNtStringsW(FileNameW, &LocalFileNameA, &LocalFileNameW);
        if (!NT_SUCCESS(Status))
            goto NtExit;
    }
    else if (FileNameA != NULL) {
        Status = SpConvertToNulTerminatedNtStringsA(FileNameA, &LocalFileNameA, &LocalFileNameW);
        if (!NT_SUCCESS(Status))
            goto NtExit;
    }
    else {
        Status = STATUS_INVALID_PARAMETER;
        goto NtExit;
    }
    FileHandle = SpOpenFile1W(LocalFileNameW.Buffer);

    ASSERT (FileHandle);    // never NULL

    if (FileHandle == INVALID_HANDLE_VALUE)
        goto Exit;
    if (!FDIIsCabinet(CabHandle->FdiHandle, (INT_PTR)FileHandle, &CabHandle->FdiCabinetInfo))
        goto Exit;
    SpCabCloseHandle(&FileHandle);
    FilePtrW = (PWSTR)SpGetFileNameFromPathW(LocalFileNameW.Buffer);
    if (FilePtrW == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto NtExit;
    }

    // ok if error, just empty string, no gauge
    RtlInitAnsiString(&g_CabFileFullPath, SpDupStringA(LocalFileNameA.Buffer));

    SpMoveStringA(&CabHandle->PathA, &LocalFileNameA);
    SpMoveStringW(&CabHandle->PathW, &LocalFileNameW);
    *FilePtrW = 0;
    Status = SpConvertToNulTerminatedNtStringsW(FilePtrW, &CabHandle->FileA, &CabHandle->FileW);
    if (!NT_SUCCESS(Status))
        goto NtExit;

    CabHandleRet = CabHandle;
    CabHandle = NULL;
Exit:
    ASSERT(g_SpCabFdiHandle == NULL);
    if (CabHandleRet != NULL) {
        g_SpCabFdiHandle = CabHandleRet;
    }

    SpCabCloseHandle(&FileHandle);
    SpFreeStringA(&LocalFileNameA);
    SpFreeStringW(&LocalFileNameW);
    if (CabHandle != NULL)
        SpCabCloseCabinet(CabHandle);
    return (OCABHANDLE)CabHandleRet;

NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

OCABHANDLE
SpCabOpenCabinetW(
    IN      PCWSTR FileName
    )
/*++

Routine Description:

  Creates a cabinet context for an existent cabinet file.

Arguments:

  FileName - Specifies cabinet file name.

Return Value:

  a valid OCABHANDLE if successful, NULL otherwise.

--*/
{
    OCABHANDLE Handle;

    KdPrint((__FUNCTION__":%ls\n", FileName));
    Handle = SppCabOpenCabinet(NULL, FileName);
    return Handle;
}

BOOL
SppCabExtractAllFilesEx(
    IN      OCABHANDLE Handle,
    PCSTR              ExtractPathA,
    PCWSTR             ExtractPathW,
    PCABNOTIFICATIONA  NotificationA   OPTIONAL,
    PCABNOTIFICATIONW  NotificationW   OPTIONAL
    )
/*++

Routine Description:

  Extracts all files from a cabinet file.

Arguments:

  CabHandle - Specifies cabinet context.

  ExtractPath - Specifies the path to extract the files to.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    PFDI_CAB_HANDLE CabHandle = (PFDI_CAB_HANDLE)Handle;
    CAB_DATA CabData = { 0 };
    BOOL Success = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    if (CabHandle == NULL)
        goto Exit;
    if (CabHandle->FdiHandle == NULL)
        goto Exit;

    if (ExtractPathW != NULL) {
        Status = SpConvertToNulTerminatedNtStringsW(ExtractPathW, &CabData.ExtractPathA, &CabData.ExtractPathW);
        if (!NT_SUCCESS(Status))
            goto NtExit;
    }
    else if (ExtractPathA != NULL) {
        Status = SpConvertToNulTerminatedNtStringsA(ExtractPathA, &CabData.ExtractPathA, &CabData.ExtractPathW);
        if (!NT_SUCCESS(Status))
            goto NtExit;
    }
    CabData.NotificationA = NotificationA;
    CabData.NotificationW = NotificationW;

    if (!FDICopy(
                CabHandle->FdiHandle,
                CabHandle->FileA.Buffer,
                CabHandle->PathA.Buffer,
                0,
                pCabNotification,
                NULL,
                &CabData
                ))
        goto Exit;
    Success = TRUE;
Exit:
    return Success;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

BOOL
SpCabExtractAllFilesExW(
    IN      OCABHANDLE        Handle,
    IN      PCWSTR            ExtractPathW,
    IN      PCABNOTIFICATIONW NotificationW   OPTIONAL
    )
/*++

Routine Description:

  Extracts all files from a cabinet file.

Arguments:

  CabHandle - Specifies cabinet context.

  ExtractPath - Specifies the path to extract the files to.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    const BOOL Success = SppCabExtractAllFilesEx(Handle, NULL, ExtractPathW, NULL, NotificationW);
    return Success;
}

BOOL
SpCabCloseCabinet(
    IN      OCABHANDLE Handle
    )
/*++

Routine Description:

  Closes a cabinet file context.

Arguments:

  CabHandle - Specifies cabinet context.

Return Value:

  TRUE if successful, FALSE otherwise.

Note this function is also used internally to tear down a partially constructed
cab handle, as happens if we fail building it up.
--*/
{
    PFDI_CAB_HANDLE CabHandle = (PFDI_CAB_HANDLE)Handle;
    BOOL Success = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    if (CabHandle == NULL) {
        Success = TRUE;
        goto Exit;
    }
    if (CabHandle->FdiHandle != NULL) {
        if (!FDIDestroy(CabHandle->FdiHandle))
            goto Exit;
    }
    SpFreeStringA(&CabHandle->PathA);
    SpFreeStringA(&CabHandle->FileA);
    SpFreeStringW(&CabHandle->PathW);
    SpFreeStringW(&CabHandle->FileW);

    if (CabHandle == g_SpCabFdiHandle) {
        SpCabCleanupCabGlobals();
    }

    SpMemFree(CabHandle);
    Success = TRUE;
Exit:
    return Success;
}

INT
DIAMONDAPI
pCabFilePlacedA(
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    PFCI_CAB_HANDLE CabHandle = NULL;

    CabHandle = (PFCI_CAB_HANDLE) Context;
    if (CabHandle == NULL) {
        return 0;
    }

    CabHandle->FileCount++;
    CabHandle->FileSize += FileSize;

    return 0;
}

BOOL
SpCabFlushAndCloseCabinet(
    IN      CCABHANDLE CabHandle
    )
{
    return SpCabFlushAndCloseCabinetEx(CabHandle,NULL,NULL,NULL,NULL);
}

VOID
SpFreeStringA(
    PANSI_STRING String
    )
{
    SpFreeStringW((PUNICODE_STRING)String);
}

VOID
SpFreeStringW(
    PUNICODE_STRING String
    )
{
    if (String != NULL) {
        if (String->Buffer != NULL) {
            SpMemFree(String->Buffer);
        }
        RtlZeroMemory(String, sizeof(*String));
    }
}

NTSTATUS
SpConvertToNulTerminatedNtStringsA(
    PCSTR           Ansi,
    PANSI_STRING    OutAnsiString     OPTIONAL,
    PUNICODE_STRING OutUnicodeString  OPTIONAL
    )
/*++
Unlike assorted Rtl functions, we are sure that every string is nul terminated.
We also consistently allocate our strings.
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Length = 0;

    if (Ansi != NULL)
        Length = strlen(Ansi);

    if (OutAnsiString != NULL)
        RtlZeroMemory(OutAnsiString, sizeof(*OutAnsiString));
    if (OutUnicodeString != NULL)
        RtlZeroMemory(OutUnicodeString, sizeof(*OutUnicodeString));

    if (OutAnsiString != NULL) {
        if (!(OutAnsiString->Buffer = SpMemAlloc((Length + 1) * sizeof(OutAnsiString->Buffer[0])))) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }
        RtlCopyMemory(OutAnsiString->Buffer, Ansi, Length * sizeof(OutAnsiString->Buffer[0]));
        OutAnsiString->Buffer[Length] = 0;
        OutAnsiString->Length = (USHORT)Length * sizeof(OutAnsiString->Buffer[0]);
        OutAnsiString->MaximumLength = OutAnsiString->Length + sizeof(OutAnsiString->Buffer[0]);
    }
    if (OutUnicodeString != NULL) {
        ANSI_STRING LocalAnsiString = { 0 };

        RtlInitAnsiString(&LocalAnsiString, Ansi);
        LocalAnsiString.Length = LocalAnsiString.MaximumLength; // include terminal nul
        Status = SpAnsiStringToUnicodeString(OutUnicodeString, &LocalAnsiString, TRUE);
        if (!NT_SUCCESS(Status)) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }
        OutUnicodeString->Length -= sizeof(OutUnicodeString->Buffer[0]);
    }
    Status = STATUS_SUCCESS;
Exit:
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpNtStatusToDbgPrintLevel(Status),
            "SETUP:"__FUNCTION__" 0x%08lx\n",
            Status
            ));
        SpFreeStringA(OutAnsiString);
        SpFreeStringW(OutUnicodeString);
    }
    return Status;
}

NTSTATUS
SpConvertToNulTerminatedNtStringsW(
    PCWSTR          Unicode,
    PANSI_STRING    OutAnsiString     OPTIONAL,
    PUNICODE_STRING OutUnicodeString  OPTIONAL
    )
/*++
Unlike assorted Rtl functions, we are sure that every string is nul terminated.
We also consistently allocate our strings.
--*/
{
    ULONG Length = 0;
    NTSTATUS Status = STATUS_SUCCESS;

    if (Unicode != NULL)
        Length = wcslen(Unicode);

    if (OutUnicodeString != NULL) {
        if (!(OutUnicodeString->Buffer = SpMemAlloc((Length + 1) * sizeof(OutUnicodeString->Buffer[0])))) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }
        RtlCopyMemory(OutUnicodeString->Buffer, Unicode, Length * sizeof(OutUnicodeString->Buffer[0]));
        OutUnicodeString->Buffer[Length] = 0;
        OutUnicodeString->Length = (USHORT)Length * sizeof(OutUnicodeString->Buffer[0]);
        OutUnicodeString->MaximumLength = OutUnicodeString->Length + sizeof(OutUnicodeString->Buffer[0]);
    }
    if (OutAnsiString != NULL) {
        UNICODE_STRING LocalUnicodeString = { 0 };

        RtlInitUnicodeString(&LocalUnicodeString, Unicode);
        LocalUnicodeString.Length = LocalUnicodeString.MaximumLength; // include terminal nul
        Status = SpUnicodeStringToAnsiString(OutAnsiString, &LocalUnicodeString, TRUE);
        if (!NT_SUCCESS(Status)) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }
        OutAnsiString->Length -= sizeof(OutAnsiString->Buffer[0]);
    }
    Status = STATUS_SUCCESS;
Exit:
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpNtStatusToDbgPrintLevel(Status),
            "SETUP:"__FUNCTION__" 0x%08lx\n",
            Status
            ));
        SpFreeStringA(OutAnsiString);
        SpFreeStringW(OutUnicodeString);
    }
    return Status;
}

VOID
SpStringCopyNA(
    PSTR Dest,
    PCSTR Source,
    SIZE_T Max
    )
/*++
Max is a number of chars, as in RTL_NUMBER_OF.
The result is always nul terminated.
--*/
{
    SIZE_T Length = strlen(Source);
    if (Length >= Max) {
        KdPrint(("SETUP:String truncated in "__FUNCTION__".\n"));
        Length = Max - 1;
    }
    RtlCopyMemory(Dest, Source, Length * sizeof(Dest[0]));
    Dest[Length] = 0;
}

VOID
SpStringCopyNW(
    PWSTR  Dest,
    PCWSTR Source,
    SIZE_T Max
    )
/*++
Max is a number of chars, as in RTL_NUMBER_OF.
The result is always nul terminated.
--*/
{
    SIZE_T Length = wcslen(Source);
    if (Length >= Max) {
        KdPrint(("SETUP:String truncated in "__FUNCTION__".\n"));
        Length = Max - 1;
    }
    RtlCopyMemory(Dest, Source, Length * sizeof(Dest[0]));
    Dest[Length] = 0;
}

VOID
SpMoveStringA(
    PANSI_STRING Dest,
    PANSI_STRING Source
    )
{
    SpMoveStringW((PUNICODE_STRING)Dest, (PUNICODE_STRING)Source);
}

VOID
SpMoveStringW(
    PUNICODE_STRING Dest,
    PUNICODE_STRING Source
    )
{
    if (Source != NULL) {
        *Dest = *Source;
        RtlZeroMemory(Source, sizeof(*Source));
    }
}


NTSTATUS
SpCreateDirectoryForFileA(
    IN PCSTR FilePathA,
    IN ULONG CreateFlags
    )
{
    UNICODE_STRING PathW = { 0 };
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR LastBackSlash = NULL;
    PWSTR BackSlash = NULL;

    if(!FilePathA || !FilePathA[0]){
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = SpConvertToNulTerminatedNtStringsA(FilePathA, NULL, &PathW);
    if (!NT_SUCCESS(Status)){
        goto Exit;
    }

    //
    // \device\harddiskn\partitionm\dirs..\file
    // or \device\harddiskn\partitionm\file
    // calculate \device\hardiskn\partitionm part
    //
    BackSlash = wcschr(PathW.Buffer + 1, '\\');
    if (BackSlash != NULL)
        BackSlash = wcschr(BackSlash + 1, '\\');
    if (BackSlash != NULL)
        BackSlash = wcschr(BackSlash + 1, '\\');
    if (BackSlash == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpNtStatusToDbgPrintLevel(Status),
            "SETUP:"__FUNCTION__"(%ls) less than expected number of slashes, expected \\device\\harddiskn\\partitionm\\...\n",
            FilePathA
            ));
        goto Exit;
    }
    *BackSlash = 0;

    LastBackSlash = wcsrchr(BackSlash + 1, '\\');
    if (LastBackSlash == NULL) {
        //
        // the file is at the root of a drive, no directory to create, just
        // return success
        //
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    *LastBackSlash = 0;

    if (!SpCreateDirectory (PathW.Buffer, NULL, BackSlash + 1, 0, CreateFlags)) {

        Status = STATUS_UNSUCCESSFUL;
        goto Exit;

    }

    Status = STATUS_SUCCESS;
Exit:
    SpFreeStringW(&PathW);
    return Status;
}

NTSTATUS
SpUnicodeStringToAnsiString(
    PANSI_STRING     DestinationStringA,
    PCUNICODE_STRING SourceStringW,
    BOOL             Allocate
    )
/*
This is like RtlUnicodeStringToAnsiString, but it is "setup heap correct".
The result is freed with SpMemFree instead of RtlFreeAnsiString.

I know this is inefficient.
*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ANSI_STRING RtlMemDestinationStringA = { 0 };
    if (!Allocate) {
        Status = RtlUnicodeStringToAnsiString(DestinationStringA, (PUNICODE_STRING)SourceStringW, FALSE);
        goto Exit;
    }
    Status = RtlUnicodeStringToAnsiString(&RtlMemDestinationStringA, (PUNICODE_STRING)SourceStringW, TRUE);
    if (!NT_SUCCESS(Status))
        goto Exit;
    //
    // Don't use SpDupString, we might not have a terminal nul (but usually does).
    //
    DestinationStringA->Buffer = SpMemAlloc(RtlMemDestinationStringA.MaximumLength);
    if (DestinationStringA->Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }
    DestinationStringA->MaximumLength = RtlMemDestinationStringA.MaximumLength;
    DestinationStringA->Length = RtlMemDestinationStringA.Length;
    RtlCopyMemory(DestinationStringA->Buffer, RtlMemDestinationStringA.Buffer, DestinationStringA->Length);
    if (DestinationStringA->MaximumLength >= (DestinationStringA->Length + sizeof(DestinationStringA->Buffer[0])))
        DestinationStringA->Buffer[DestinationStringA->Length / sizeof(DestinationStringA->Buffer[0])] = 0;
    Status = STATUS_SUCCESS;
Exit:
    RtlFreeAnsiString(&RtlMemDestinationStringA);
    return Status;
}

NTSTATUS
SpAnsiStringToUnicodeString(
    PUNICODE_STRING DestinationStringW,
    PCANSI_STRING   SourceStringA,
    BOOL            Allocate
    )
/*
This is like RtlAnsiStringToUnicodeString, but it is "setup heap correct".
The result is freed with SpMemFree instead of RtlFreeUnicodeString.

I know this is inefficient.
*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING RtlMemDestinationStringW = { 0 };
    if (!Allocate) {
        Status = RtlAnsiStringToUnicodeString(DestinationStringW, (PANSI_STRING)SourceStringA, FALSE);
        goto Exit;
    }
    Status = RtlAnsiStringToUnicodeString(&RtlMemDestinationStringW, (PANSI_STRING)SourceStringA, TRUE);
    if (!NT_SUCCESS(Status))
        goto Exit;
    //
    // Don't use SpDupString, we might not have a terminal nul (but usually does).
    //
    DestinationStringW->Buffer = SpMemAlloc(RtlMemDestinationStringW.MaximumLength);
    if (DestinationStringW->Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }
    DestinationStringW->MaximumLength = RtlMemDestinationStringW.MaximumLength;
    DestinationStringW->Length = RtlMemDestinationStringW.Length;
    RtlCopyMemory(DestinationStringW->Buffer, RtlMemDestinationStringW.Buffer, DestinationStringW->Length);
    if (DestinationStringW->MaximumLength >= (DestinationStringW->Length + sizeof(DestinationStringW->Buffer[0])))
        DestinationStringW->Buffer[DestinationStringW->Length / sizeof(DestinationStringW->Buffer[0])] = 0;
    Status = STATUS_SUCCESS;
Exit:
    RtlFreeUnicodeString(&RtlMemDestinationStringW);
    return Status;
}

NTSTATUS
SpKnownSizeUnicodeToDbcsN(
    OUT PSTR    Ansi,
    IN  PCWSTR  Unicode,
    IN  SIZE_T  AnsiSize
    )
/*++
based on windows\winstate\cobra\utils\...
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    AnsiString.Buffer = Ansi;
    AnsiString.Length = 0;
    AnsiString.MaximumLength = (USHORT)AnsiSize;

    RtlInitUnicodeString(&UnicodeString, Unicode);
    UnicodeString.Length = UnicodeString.MaximumLength; // include terminal nul

    Status = SpUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

VOID
SpEnsureTrailingBackSlashA(
    PSTR Path
    )
/*++
based on windows\winstate\cobra\utils\...
--*/
{
    if (*Path == 0 || *((Path += strlen(Path)) - 1) != '\\') {
        *Path = '\\';
        *(Path + 1) = 0;
    }
}

PCWSTR
SpGetFileNameFromPathW(
    IN PCWSTR PathSpec
    )
/*++
based on windows\winstate\cobra\utils\...
--*/
{
    PCWSTR p;

    p = wcsrchr(PathSpec, L'\\');
    if (p) {
        p++;
    } else {
        p = PathSpec;
    }

    return p;
}

HANDLE
SpCreateFile1A(
    IN PCSTR FileName
    )
/*++
based on windows\winstate\cobra\utils\...
--*/
{
    HANDLE Handle;
    DWORD orgAttributes;
    WIN32_FILE_ATTRIBUTE_DATA fileAttributeData = { 0 };

    //
    // Reset the file attributes, then do a CREATE_ALWAYS. FileName is an NT path.
    //
    // We do this because some of the files are replacing have had their
    // system|hidden attributes changed, and you can get access denied if you
    // try to replace these files with mismatching attributes.
    //

    if (!SpGetFileAttributesExA (FileName, GetFileExInfoStandard, &fileAttributeData)) {
        orgAttributes = FILE_ATTRIBUTE_NORMAL;
    } else {
        orgAttributes = fileAttributeData.dwFileAttributes;
    }

    SpSetFileAttributesA (FileName, FILE_ATTRIBUTE_NORMAL);

    Handle = SpWin32CreateFileA(
                    FileName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

    ASSERT (Handle);    // never NULL

    if (Handle == INVALID_HANDLE_VALUE) {
        SpSetFileAttributesA (FileName, orgAttributes);
    }

    return Handle;
}

PSTR
SpJoinPathsA(
    PCSTR a,
    PCSTR b
    )
/*++
based on windows\winstate\cobra\utils\...
--*/
{
// find code elsewhere in setup that does this already..
    PSTR Result = NULL;
    SIZE_T alen = 0;
    SIZE_T blen = 0;

    if (a == NULL)
        goto Exit;
    if (b == NULL)
        goto Exit;
    alen = strlen(a);
    blen = strlen(b);

    Result = SpMemAlloc((alen + blen + 2) * sizeof(*Result));
    if (Result == NULL) {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(STATUS_NO_MEMORY);
        goto Exit;
    }

    if (alen != 0) {
        strcpy(Result, a);
        if (a[alen - 1] != '\\')
            strcat(Result, "\\");
     }
     strcat(Result, b);
Exit:
    KdPrintEx((DPFLTR_SETUP_ID, SpPointerToDbgPrintLevel(Result), "SETUP:"__FUNCTION__" exiting\n"));
    return Result;
}

HANDLE
SpOpenFile1A(
    IN PCSTR Ansi
    )
/*++
based on windows\winstate\cobra\utils\main\basefile.c
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL     Success = FALSE;
    ANSI_STRING    AnsiString   = { 0 };
    UNICODE_STRING UnicodeString = { 0 };
    HANDLE Handle = INVALID_HANDLE_VALUE;

    RtlInitAnsiString(&AnsiString, Ansi);
    AnsiString.Length = AnsiString.MaximumLength; // include terminal nul

    if (!NT_SUCCESS(Status = SpAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE)))
        goto NtExit;
    Handle = SpOpenFile1W(UnicodeString.Buffer);
    ASSERT (Handle);    // never NULL
    if (Handle == INVALID_HANDLE_VALUE)
        goto Exit;

Exit:
    SpFreeStringW(&UnicodeString);
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(Handle),
        "SETUP:"__FUNCTION__"(%s) exiting %p\n", Ansi, Handle
        ));
    return Handle;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

HANDLE
SpOpenFile1W(
    IN PCWSTR FileName
    )
/*++
based on windows\winstate\cobra\utils\main\basefile.c
--*/
{
    HANDLE Handle;

    Handle = SpWin32CreateFileW(
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0, // no share
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
    ASSERT (Handle);    // never NULL

    return Handle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spcabp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    spcabp.h

Abstract:

    Cabinet stuff (file compression/decompression)

Author:

    Calin Negreanu (calinn) 27-Apr-2000

Revision History:

    Jay Krell (a-JayK) November 2000
        ported from windows\winstate\cobra\... to admin\ntsetup\textmode\kernel\spcab.h
--*/

#pragma once
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include <stdio.h>
#if defined(ULONG_MAX) && !defined(_INC_LIMITS)
#undef ULONG_MAX
#endif
#include <limits.h>
#if !defined(NUMBER_OF)
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#endif
#if !defined(MAXDWORD)
#define MAXDWORD (~(DWORD)0)
#endif
#define MAX_WCHAR_PATH 260

void SpDebugMessage(int level, const char* string);
#define DEBUGMSG(x) (SpDebugMessage(x))
#define DBG_ERROR /* nothing */

#include "spcab.h"
#include "fdi.h"
#include "fci.h"

//
// This work was not quite finished, and it turns out for now (November 26, 2000),
// we don't need it.
//
#define SETUP_CABP_SMALL_FILE_OPTIMIZATION 0

#if SETUP_CABP_SMALL_FILE_OPTIMIZATION

typedef struct _SETUP_CABP_FILE_VTABLE {
    /*
    read
    write
    seek
    close
    */
    int x;
} SETUP_CABP_FILE_VTABLE, *PSETUP_CABP_FILE_VTABLE;

typedef struct _SETUP_CABP_NT_FILE_DATA {
    HANDLE NtHandle;
} SETUP_CABP_NT_FILE_DATA;

typedef struct _SETUP_CABP_SMALL_FILE_CACHE_ENTRY_KEY {
    UNICODE_STRING Path;
} SETUP_CABP_SMALL_FILE_CACHE_ENTRY_KEY, *PSETUP_CABP_SMALL_FILE_CACHE_ENTRY_KEY;

typedef struct _SETUP_CABP_SMALL_FILE_CACHE_DATA {
    UCHAR          Buffer[100];
    LONG           OpenCount;
    ULONG          Access;
    ULONG          Share;
    LONG           Size;
} SETUP_CABP_SMALL_FILE_CACHE_ENTRY, *PSETUP_CABP_SMALL_FILE_CACHE_ENTRY;

typedef struct _SETUP_CABP_SMALL_FILE_CACHE_ENTRY {
    SETUP_CABP_SMALL_FILE_CACHE_KEY  Key; // This must be first.
    SETUP_CABP_SMALL_FILE_CACHE_DATA Data
} SETUP_CABP_SMALL_FILE_CACHE_ENTRY, *PSETUP_CABP_SMALL_FILE_CACHE_ENTRY;

typedef struct _SETUP_CABP_SMALL_FILE_OPENED_DATA {
    PSETUP_CABP_SMALL_FILE_CACHE_ENTRY CacheEntry;
    LONG                               SeekPointer;
    ULONG                              Access;
    ULONG                              Share;
} SETUP_CABP_SMALL_FILE_OPENED_DATA, *PSETUP_CABP_SMALL_FILE_OPENED_DATA;

//
// returns either STATUS_SUCCESS or STATUS_SHARING_VIOLATION
// or maybe STATUS_ACCESS_DENIED in the future
//
NTSTATUS
SpAccessCheck(
    PSETUP_CABP_SMALL_FILE_CACHE_ENTRY CacheEntry,
    ACCESS_MASK                        Access,
    ULONG                              Share
    );

typedef union _SETUP_CABP_FILE_DATA {
#if SETUP_CABP_SMALL_FILE_OPTIMIZATION
    SETUP_CABP_SMALL_FILE_OPENED_DATA Small;
#endif
    SETUP_CABP_NT_FILE_DATA           Nt;
} SETUP_CABP_FILE_DATA, *PSETUP_CABP_FILE_DATA;

typedef struct _SETUP_CABP_FILE_WITH_VTABLE {
    PSETUP_CABP_FILE_VTABLE VTable;
    SETUP_CABP_FILE_DATA    Data;
} SETUP_CABP_FILE_WITH_VTABLE, *PSETUP_CABP_FILE_WITH_VTABLE;

#ifndef KERNELMODE
typedef FAST_MUTEX SETUP_CABP_LOCK;
#define SpInitializeLock ExInitializeFastMutex
#define SpAcquireLock    ExAcquireFastMutex
#define SpReleaseLock    ExReleaseFastMutex
#define SpDeleteLock     /* nothing */
#else
typedef RTL_CRITICAL_SECTION SETUP_CABP_LOCK;
#define SpInitializeLock RtlInitializeCriticalSection
#define SpAcquireLock    RtlEnterCriticalSection
#define SpReleaseLock    RtlLeaveCriticalSection
#define SpDeleteLock     RtlDeleteCriticalSection
#endif

typedef struct _SETUP_CABP_SMALL_FILE_CACHE {
    RTL_AVL_TABLE  Table;
    SETUP_CABP_LOCK Lock;
} SETUP_CABP_SMALL_FILE_CACHE;

extern SETUP_CABP_SMALL_FILE_CACHE SpSmallFileCache;

extern const SETUP_CABP_FILE_VTABLE SpSmallFileVTable;
extern const SETUP_CABP_FILE_VTABLE SpNtFileVTable;

NTSTATUS
SpConvertSmallFileToNtFile(
    ...
    );

#endif

BOOL
SpIsStatusFileNotFoundEtc(
    NTSTATUS Status
    );

VOID
SpCloseHandle(
    HANDLE* HandlePointer
    );

VOID
SpFree(
    PVOID* PointerPointer
    );


#if SETUP_CABP_SMALL_FILE_OPTIMIZATION

VOID
SpFreeSmallFileCacheEntry(
    PSETUP_CABP_SMALL_FILE_CACHE_ENTRY* SmallFileCacheEntryPointerPointer
    );

NTSTATUS
SpOpenFile(
    UNICODE_STRING                Path,
    ULONG                         Access,
    ULONG                         Share,
    ULONG                         OpenOrCreate,
    PSETUP_CABP_FILE_WITH_VTABLE* FileOut
    );

#endif

// from windows\winstate\...\cablib.c
typedef struct _FCI_CAB_HANDLE {
    ANSI_STRING    PathA;
    ANSI_STRING    FileFormatA;
    ANSI_STRING    DiskFormatA;

    UNICODE_STRING PathW;
    UNICODE_STRING FileFormatW;
    UNICODE_STRING DiskFormatW;

    PCABGETCABINETNAMESA GetCabinetNamesA;
    PCABGETCABINETNAMESW GetCabinetNamesW;

    HFCI FciHandle;
    ERF FciErrorStruct;
    CCAB FciCabParams;
    UINT FileCount;
    UINT CabCount;
    LONGLONG FileSize;
    LONGLONG CompressedSize;

    LARGE_INTEGER StartTime;
    ULONG    SmallFileSize;
    TCOMP    CompressionType;
    TCOMP    SmallFileCompressionType;
}
FCI_CAB_HANDLE , *PFCI_CAB_HANDLE,
FCI_CAB_HANDLEA, *PFCI_CAB_HANDLEA,
FCI_CAB_HANDLEW, *PFCI_CAB_HANDLEW
;

// from windows\winstate\...\cablib.c
typedef struct {
    ANSI_STRING    PathA;
    ANSI_STRING    FileA;
    UNICODE_STRING PathW;
    UNICODE_STRING FileW;

    HFDI           FdiHandle;
    ERF            FdiErrorStruct;
    FDICABINETINFO FdiCabinetInfo;
    PVOID          Gauge;
}
FDI_CAB_HANDLE , *PFDI_CAB_HANDLE ,
FDI_CAB_HANDLEA, *PFDI_CAB_HANDLEA,
FDI_CAB_HANDLEW, *PFDI_CAB_HANDLEW
;

// from windows\winstate\...\cablib.c
typedef struct {
    ANSI_STRING       ExtractPathA;
    UNICODE_STRING    ExtractPathW;
    PCABNOTIFICATIONA NotificationA;
    PCABNOTIFICATIONW NotificationW;
}
CAB_DATA , *PCAB_DATA ,
CAB_DATAA, *PCAB_DATAA,
CAB_DATAW, *PCAB_DATAW
;

// from windows\winstate\...\cablib.c
INT
DIAMONDAPI
pCabFilePlacedW(
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
PVOID
DIAMONDAPI
pCabAlloc (
    IN      ULONG Size
    );

// from windows\winstate\...\cablib.c
VOID
DIAMONDAPI
pCabFree (
    IN      PVOID Memory
    );

// from windows\winstate\...\cablib.c
INT_PTR
DIAMONDAPI
pCabOpenA (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode,
    OUT     PINT Error,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
INT_PTR
DIAMONDAPI
pCabOpen1A (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode
    );

// from windows\winstate\...\cablib.c
UINT
DIAMONDAPI
pCabRead (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
UINT
DIAMONDAPI
pCabRead1 (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    );

// from windows\winstate\...\cablib.c
UINT
DIAMONDAPI
pCabWrite (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
UINT
DIAMONDAPI
pCabWrite1 (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    );

// from windows\winstate\...\cablib.c
INT
DIAMONDAPI
pCabClose (
    IN      INT_PTR FileHandle,
    OUT     PINT Error,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
INT
DIAMONDAPI
pCabClose1 (
    IN      INT_PTR FileHandle
    );

// from windows\winstate\...\cablib.c
LONG
DIAMONDAPI
pCabSeek (
    IN      INT_PTR FileHandle,
    IN      LONG Distance,
    IN      INT SeekType,
    OUT     PINT Error,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
LONG
DIAMONDAPI
pCabSeek1 (
    IN      INT_PTR FileHandle,
    IN      LONG Distance,
    IN      INT SeekType
    );

// from windows\winstate\...\cablib.c
INT
DIAMONDAPI
pCabDeleteA (
    IN      PSTR FileName,
    OUT     PINT Error,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
BOOL
DIAMONDAPI
pCabGetTempFileA (
    OUT     PSTR FileName,
    IN      INT FileNameLen,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
BOOL
DIAMONDAPI
pCabGetNextCabinetA (
     IN     PCCAB FciCabParams,
     IN     ULONG PrevCabinetSize,
     IN     PVOID Context
     );

// from windows\winstate\...\cablib.c
BOOL
DIAMONDAPI
pCabGetNextCabinetW (
     IN     PCCAB FciCabParams,
     IN     ULONG PrevCabinetSize,
     IN     PVOID Context
     );

// from windows\winstate\...\cablib.c
LONG
DIAMONDAPI
pCabStatusA (
    IN      UINT StatusType,
    IN      ULONG Size1,
    IN      ULONG Size2,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
LONG
DIAMONDAPI
pCabStatusW (
    IN      UINT StatusType,
    IN      ULONG Size1,
    IN      ULONG Size2,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
INT_PTR
DIAMONDAPI
pCabGetOpenInfoA (
    IN      PSTR FileName,
    OUT     USHORT *Date,
    OUT     USHORT *Time,
    OUT     USHORT *Attributes,
    OUT     PINT Error,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
INT_PTR
DIAMONDAPI
pCabNotification (
    IN      FDINOTIFICATIONTYPE FdiNotificationType,
    IN OUT  PFDINOTIFICATION FdiNotification
    );

typedef const unsigned char* PCBYTE;

INT
DIAMONDAPI
pCabFilePlacedA(
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spboot.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    spboot.c

Abstract:

    accessing and configuring boot variables.

Author:

    Sunil Pai (sunilp) 26-October-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

#include <hdlsblk.h>
#include <hdlsterm.h>

#if defined(EFI_NVRAM_ENABLED)
#include <efi.h>
#include <efiapi.h>
#endif             
               
#include "bootvar.h"

//
// Globals to this module
//

static ULONG Timeout;
static PWSTR Default;
ULONG DefaultSignature;
static PWSTR *BootVars[MAXBOOTVARS];
static BOOLEAN CleanSysPartOrphan = FALSE;

PWSTR *CurrentNtDirectoryList = NULL;

// do NOT change the order of the elements in this array.

PCHAR NvramVarNames[MAXBOOTVARS] = {
   LOADIDENTIFIERVAR,
   OSLOADERVAR,
   OSLOADPARTITIONVAR,
   OSLOADFILENAMEVAR,
   OSLOADOPTIONSVAR,
   SYSTEMPARTITIONVAR
   };

PCHAR OldBootVars[MAXBOOTVARS];
PWSTR NewBootVars[MAXBOOTVARS];

#if defined(_X86_)
BOOLEAN IsArcChecked = FALSE;
BOOLEAN IsArcMachine;
#endif

PSP_BOOT_ENTRY SpBootEntries = NULL;
PBOOT_OPTIONS SpBootOptions = NULL;

RedirectSwitchesModeEnum RedirectSwitchesMode = UseDefaultSwitches;
REDIRECT_SWITCHES RedirectSwitches;

#ifdef _X86_
extern BOOLEAN g_Win9xBackup;
#endif



//
// Local functions.
//

PWSTR
SpArcPathFromBootSet(
    IN BOOTVAR BootVariable,
    IN ULONG   Component
    );

BOOLEAN
SpConvertArcBootEntries (
    IN ULONG MaxComponents
    );

VOID
SpCreateBootEntry(
    IN ULONG_PTR Status,
    IN PDISK_REGION BootFileRegion,
    IN PWSTR BootFilePath,
    IN PDISK_REGION OsLoadRegion,
    IN PWSTR OsLoadPath,
    IN PWSTR OsLoadOptions,
    IN PWSTR FriendlyName
    );

PCHAR
SppGetArcEnvVar(
    IN BOOTVAR Variable
    );

VOID
SpFreeBootEntries (
    VOID
    );

BOOLEAN
SppSetArcEnvVar(
    IN BOOTVAR Variable,
    IN PWSTR *VarComponents,
    IN BOOLEAN bWriteVar
    );

#if defined(EFI_NVRAM_ENABLED)

typedef struct _HARDDISK_NAME_TRANSLATION {
    struct _HARDDISK_NAME_TRANSLATION *Next;
    PWSTR VolumeName;
    PWSTR PartitionName;
} HARDDISK_NAME_TRANSLATION, *PHARDDISK_NAME_TRANSLATION;

PHARDDISK_NAME_TRANSLATION SpHarddiskNameTranslations = NULL;

BOOLEAN
SpBuildHarddiskNameTranslations (
    VOID
    );

BOOLEAN
SpFlushEfiBootEntries (
    VOID
    );

BOOLEAN
SpReadAndConvertEfiBootEntries (
    VOID
    );

ULONG
SpSafeWcslen (
    IN PWSTR String,
    IN PWSTR Max
    );

VOID
SpTranslateFilePathToRegion (
    IN PFILE_PATH FilePath,
    OUT PDISK_REGION *DiskRegion,
    OUT PWSTR *PartitionNtName,
    OUT PWSTR *PartitionRelativePath
    );

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

#endif

//
// Function implementation
//


BOOLEAN
SpInitBootVars(
    )
/*++

Routine Description:

    Captures the state of the NVRAM Boot Variables.

Arguments:

    None.

Return Value:

--*/
{
    BOOLEAN Status = TRUE;
    BOOTVAR i;
    ULONG   Component, MaxComponents, SysPartComponents;
    PCHAR puArcString; // SGI

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_EXAMINING_FLEXBOOT,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Initialize the boot variables from the corresponding NVRAM variables
    //
#if defined(EFI_NVRAM_ENABLED)
    if (SpIsEfi()) {

        //
        // Build a list of all of the \Device\HarddiskN\PartitionM symbolic
        // links, along with their translations to \Device\HarddiskVolumeN
        // device names. This list is used to translate the
        // \Device\HarddiskVolumeN names returned by NtTranslateFilePath into
        // names that setupdd can translate to ARC names.
        //

        SpBuildHarddiskNameTranslations();
     
        //
        // Read the boot entries from NVRAM and convert them into our
        // internal format.
        //

        Status = SpReadAndConvertEfiBootEntries();

    } else
#endif
    {
        if (SpIsArc()) {
            ULONG   NumComponents;
    
            for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                OldBootVars[i] = SppGetArcEnvVar( i );
                SpGetEnvVarWComponents( OldBootVars[i], BootVars + i, &NumComponents );
            }
            Timeout = DEFAULT_TIMEOUT;
            Default = NULL;
#if defined(_AMD64_) || defined(_X86_)
        } else {
            Spx86InitBootVars( BootVars, &Default, &Timeout );
#endif // defined(_AMD64_) || defined(_X86_)
        }

        //
        // We now go back and replace all NULL OsLoadOptions with "", because we
        // validate a boot set by making sure that all components are non-NULL.
        //
        // First, find the maximum number of components in any of the other
        // boot variables, so that we can make OsLoadOptions have this many.
        // (We also disregard SYSTEMPARTITION since some machines have this component
        // sitting all by itself on a new machine.)
        //
        MaxComponents = 0;
        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
            if(i != OSLOADOPTIONS) {
                for(Component = 0; BootVars[i][Component]; Component++);
                if (i == SYSTEMPARTITION) {
                    SysPartComponents = Component;
                } else if(Component > MaxComponents) {
                    MaxComponents = Component;
                }
            }
        }
    
        if(SysPartComponents > MaxComponents) {
            CleanSysPartOrphan = TRUE;
        }
    
        for(Component = 0; BootVars[OSLOADOPTIONS][Component]; Component++);
        if(Component < MaxComponents) {
            //
            // Then we need to add empty strings to fill it out.
            //
            BootVars[OSLOADOPTIONS] = SpMemRealloc(BootVars[OSLOADOPTIONS],
                                                   (MaxComponents + 1) * sizeof(PWSTR *));
            ASSERT(BootVars[OSLOADOPTIONS]);
            BootVars[OSLOADOPTIONS][MaxComponents] = NULL;
    
            for(; Component < MaxComponents; Component++) {
                BootVars[OSLOADOPTIONS][Component] = SpDupStringW(L"");
            }
        }

        //
        // Now convert the ARC boot sets into our internal format.
        //

        Status = SpConvertArcBootEntries(MaxComponents);
    }

    CLEAR_CLIENT_SCREEN();
    return ( Status );
}



BOOLEAN
SpFlushBootVars(
    )
/*++

Routine Description:

    Updates the NVRAM variables / boot.ini
    from the current state of the boot variables.

Arguments:

Return Value:

--*/
{
    BOOLEAN Status, OldStatus;
    BOOTVAR i, iFailPoint;
    CHAR TimeoutValue[24];

#if defined(EFI_NVRAM_ENABLED)
    if (SpIsEfi()) {

        //
        // This is an EFI machine. Write changed boot entries back to NVRAM.
        //
        Status = SpFlushEfiBootEntries();

    } else
#endif
    {
        Status = FALSE;
        if (SpIsArc()) {
            //
            // Run through all the boot variables and set the corresponding
            // NVRAM variables
    
            for(OldStatus = TRUE, i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                Status = SppSetArcEnvVar( i, BootVars[i], OldStatus );
                if(Status != OldStatus) {
                    iFailPoint = i;
                    OldStatus = Status;
                }
            }
    
            // if we failed in writing any of the variables, then restore everything we
            // modified back to its original state.
            if(!Status) {
                for(i = FIRSTBOOTVAR; i < iFailPoint; i++) {
                    HalSetEnvironmentVariable(NvramVarNames[i], OldBootVars[i]);
                }
            }
    
            // Free all of the old boot variable strings
            for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                SpMemFree(OldBootVars[i]);
                OldBootVars[i] = NULL;
            }
    
            //
            // Now set the timeout.
            //
            if(Status) {
    
                Status = FALSE;
                sprintf(TimeoutValue,"%u",Timeout);
    
                if((HalSetEnvironmentVariable("COUNTDOWN",TimeoutValue) == ESUCCESS)
                && (HalSetEnvironmentVariable("AUTOLOAD" ,"YES"       ) == ESUCCESS))
                {
                    Status = TRUE;
                }
            }
#if defined(_AMD64_) || defined(_X86_)
        } else {
            Status = Spx86FlushBootVars( BootVars, Timeout, Default );
#endif // defined(_AMD64_) || defined(_X86_)
        }
    }
    return( Status );
}





VOID
SpFreeBootVars(
    )
/*++

Routine Description:

    To free any memory allocated and do other cleanup

Arguments:

    None

Return Value:

    None

--*/
{
    BOOTVAR i;

    //
    // Free internal-format boot entries.
    //
    SpFreeBootEntries();

#if defined(EFI_NVRAM_ENABLED)
    if (!SpIsEfi())
#endif
    {
        //
        // Go through the globals and free them
        //
    
        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
            if( BootVars[i] ) {
                SpFreeEnvVarComponents( BootVars[i] );
                BootVars[i] = NULL;
            }
        }
    
        if ( Default ) {
            SpMemFree( Default );
            Default = NULL;
        }
    }

    return;
}



VOID
SpAddBootSet(
    IN PWSTR *BootSet,
    IN BOOLEAN DefaultOS,
    IN ULONG Signature
    )
/*++

Routine Description:

    To add a new system to the installed system list.  The system is added
    as the first bootset.  If is found in the currently installed boot sets
    the boot set is extracted and shifted to position 0.

Arguments:

    BootSet - A list of the boot variables to use.
    Default - Whether this system is to be the default system to boot.

Return Value:

    Component list of the value of the boot variable.

--*/
{
    BOOTVAR i;
    ULONG   MatchComponent, j;
    LONG    k;
    BOOLEAN ValidBootSet, ComponentMatched;
    PWSTR   Temp;

    ASSERT( !SpIsEfi() );

    //
    // Validate the BootSet passed in
    //

    for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
        ASSERT( BootSet[i] );
    }

    //
    // Examine all the boot sets and make sure we don't have a boot set
    // already matching.  Note that we will compare all variables in
    // tandem.  We are not interested in matches which are generated by
    // the variables not being in tandem because they are difficult to
    // shift around.
    //

    ValidBootSet = TRUE;
    ComponentMatched = FALSE;
    for( MatchComponent = 0;
         BootVars[OSLOADPARTITION][MatchComponent];
         MatchComponent++
       ) {

        //
        // Validate the boot set at the current component
        //

        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
            ValidBootSet = ValidBootSet && BootVars[i][MatchComponent];
        }
        if( !ValidBootSet ) {
            break;
        }

        //
        // Valid Boot Set, compare the components against what we have in the
        // current BootSet
        //

        ComponentMatched = TRUE;
        for(i = FIRSTBOOTVAR; ComponentMatched && i <= LASTBOOTVAR; i++) {
            ComponentMatched = !_wcsicmp( BootSet[i], BootVars[i][MatchComponent] );
        }
        if( ComponentMatched ) {
            break;
        }
    }

    //
    // If component didn't match then prepend the BootSet to the boot sets
    // that currently exist.  It is important to prepend the BootSet, because
    // appending the BootSet doesn't guarantee a matched BootSet in the
    // environment variables.  If a match was found then we
    // have a cleanly matched set which can be exchanged with the first
    // one in the set.
    //

    if( ComponentMatched ) {

        // If the currently selected OS is to be the default:
        // Shift down all variables from position 0 to MatchComponent - 1
        // and store whatever was there at MatchComponent at position 0
        //

        if ( DefaultOS && MatchComponent != 0 ) {

            for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                Temp = BootVars[i][MatchComponent];
                for( k = MatchComponent - 1; k >= 0; k-- ) {
                    BootVars[i][k + 1] = BootVars[i][k];
                }
                BootVars[i][0] = Temp;
            }
        }

    }
    else {
        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {

            //
            // Find out the size of the current value
            //

            for(j = 0; BootVars[i][j]; j++) {
            }

            //
            // Realloc the current buffer to hold one more
            //

            BootVars[i] = SpMemRealloc( BootVars[i], (j + 1 + 1)*sizeof(PWSTR) );

            //
            // Shift all the variables down one and store the current value
            // at index 0;
            //

            for( k = j; k >= 0 ; k-- ) {
                BootVars[i][k+1] = BootVars[i][k];
            }
            BootVars[i][0] = SpDupStringW( BootSet[i] );
            ASSERT( BootVars[i][0] );

        }
    }

    //
    // If this has been indicated as the default then set this to be the
    // default OS after freeing the current default variable
    //

    if( DefaultOS ) {

        if( Default ) {
            SpMemFree( Default );
        }
        Default = SpMemAlloc( MAX_PATH * sizeof(WCHAR) );
        ASSERT( Default );
        wcscpy( Default, BootSet[OSLOADPARTITION] );
        wcscat( Default, BootSet[OSLOADFILENAME]  );

        DefaultSignature = Signature;
    }
    return;

}

VOID
SpDeleteBootSet(
    IN  PWSTR *BootSet,
    OUT PWSTR *OldOsLoadOptions  OPTIONAL
    )

/*++

Routine Description:

    To delete all boot sets in the list matching the boot set provided.
    Note that the information to use in comparing the bootset is provided
    by selectively providing fields in the boot set.  So in the boot set
    if the system partition is not provided it is not used in the comparison
    to see if the boot sets match.  By providing all NULL members we can
    delete all the boot sets currently present.

Arguments:

    BootSet - A list of the boot variables to use.

Return Value:

    None.

--*/
{
    ULONG   Component, j;
    BOOLEAN ValidBootSet, ComponentMatched;
    BOOTVAR i;
    PWSTR   OsPartPath;

    ASSERT( !SpIsEfi() );

    Component = 0;
    
    while(TRUE) {
        //
        // See if we have any boot sets left, if none left we are done
        //
        ValidBootSet = TRUE;
        
        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
            ValidBootSet = ValidBootSet && BootVars[i][Component];
        }

        if( !ValidBootSet ) {
            break;
        }

        //
        // Valid Boot Set, compare the components against what we have in the
        // current BootSet.  Use only members of the BootSet which are not NULL
        //
        ComponentMatched = TRUE;
        
        for(i = FIRSTBOOTVAR; ComponentMatched && i <= LASTBOOTVAR; i++) {
            if( BootSet[i] ) {
                if((i == OSLOADPARTITION) ||
                   (i == SYSTEMPARTITION)) {
                    //
                    // Then we may have a boot set existing in tertiary ARC path form, so
                    // we first translate this path to a primary or secondary ARC path.
                    //
                    OsPartPath = SpArcPathFromBootSet(i, Component);
                    ComponentMatched = !_wcsicmp( BootSet[i], OsPartPath );
                    SpMemFree(OsPartPath);
                } else {
                    ComponentMatched = !_wcsicmp( BootSet[i], BootVars[i][Component] );
                }
            }
        }
        if( (ComponentMatched)

#ifdef PRERELEASE
            //
            // If we're being asked to delete a boot entry, and this
            // isn't the *exact* entry (i.e. it's a duplicate) that
            // also has some private OSLOADOPTIONS, then keep it around.
            //
            && !( wcsstr(BootVars[OSLOADOPTIONS][Component], L"/kernel")   ||
                  wcsstr(BootVars[OSLOADOPTIONS][Component], L"/hal")      ||
                  wcsstr(BootVars[OSLOADOPTIONS][Component], L"/pae")      ||
                  wcsstr(BootVars[OSLOADOPTIONS][Component], L"/sos") )

#endif

           ) {

            //
            // Delete all the values in the current component and advance
            // all the other components one index up
            //
            for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                if((i == OSLOADOPTIONS) && OldOsLoadOptions && !(*OldOsLoadOptions)) {
                    //
                    // If we've been passed a pointer to OldOsLoadOptions,
                    // and haven't previously found a pertinent entry, then
                    // save this one
                    //
                    *OldOsLoadOptions = BootVars[i][Component];
                } else {
                    SpMemFree(BootVars[i][Component]);
                }

                j = Component;

                do {
                   BootVars[i][j] = BootVars[i][j+1];
                   j++;
                } while(BootVars[i][j] != NULL);
            }
        }
        else {
            Component++;
        }
    }
    
    return;
}


VOID
SpCleanSysPartOrphan(
    VOID
    )
{
    INT     Component, Orphan;
    BOOLEAN DupFound;
    PWSTR   NormalizedArcPath;

    if(!CleanSysPartOrphan) {
        return;
    }

    ASSERT( !SpIsEfi() );

    //
    // find the last SystemPartition entry
    //
    for(Orphan = 0; BootVars[SYSTEMPARTITION][Orphan]; Orphan++);

    //
    // it's position better be > 0, otherwise, just exit
    //
    if(Orphan < 2) {
        return;
    } else {
        NormalizedArcPath = SpNormalizeArcPath(BootVars[SYSTEMPARTITION][--Orphan]);
    }

    //
    // Make sure that this component is duplicated somewhere else in the
    // SystemPartition list.
    //
    for(Component = Orphan - 1, DupFound = FALSE;
        ((Component >= 0) && !DupFound);
        Component--)
    {
        DupFound = !_wcsicmp(NormalizedArcPath, BootVars[SYSTEMPARTITION][Component]);
    }

    if(DupFound) {
        SpMemFree(BootVars[SYSTEMPARTITION][Orphan]);
        BootVars[SYSTEMPARTITION][Orphan] = NULL;
    }

    SpMemFree(NormalizedArcPath);
}


PWSTR
SpArcPathFromBootSet(
    IN BOOTVAR BootVariable,
    IN ULONG   Component
    )
/*++

Routine Description:

    Given the index of a boot set, return the primary (multi) or
    secondary ("absolute" scsi) ARC path for the specified variable.
    This takes into account the NT 3.1 case where we had 'tertiary'
    ARC paths where a relative scsi ordinal was passed in via the
    /scsiordinal switch.

Arguments:

    BootVariable  - supplies the index of the variable we want to return.

    Component - supplies the index of the boot set to use.

Return Value:

    String representing the primary or secondary ARC path.  This string
    must be freed by the caller with SpMemFree.

--*/
{
    ASSERT( !SpIsEfi() );

    if(!SpIsArc()){
        PWSTR p = NULL, q = NULL, ReturnedPath = NULL, RestOfString;
        WCHAR ForceOrdinalSwitch[] = L"/scsiordinal:";
        WCHAR ScsiPrefix[] = L"scsi(";
        WCHAR OrdinalString[11];
        ULONG ScsiOrdinal, PrefixLength;
    
        //
        // Check to see if this boot set had the /scsiordinal option switch
        //
        if(BootVars[OSLOADOPTIONS][Component]) {
            wcscpy(TemporaryBuffer, BootVars[OSLOADOPTIONS][Component]);
            SpStringToLower(TemporaryBuffer);
            if(p = wcsstr(TemporaryBuffer, ForceOrdinalSwitch)) {
                p += sizeof(ForceOrdinalSwitch)/sizeof(WCHAR) - 1;
                if(!(*p)) {
                    p = NULL;
                }
            }
        }
    
        if(p) {
            //
            // We have found a scsiordinal, so use it
            //
            ScsiOrdinal = SpStringToLong(p, &RestOfString, 10);
            wcscpy(TemporaryBuffer, BootVars[BootVariable][Component]);
            SpStringToLower(TemporaryBuffer);
            if(p = wcsstr(TemporaryBuffer, ScsiPrefix)) {
                p += sizeof(ScsiPrefix)/sizeof(WCHAR) - 1;
                if(*p) {
                    q = wcschr(p, L')');
                } else {
                    p = NULL;
                }
            }
    
            if(q) {
                //
                // build the new secondary ARC path
                //
                swprintf(OrdinalString, L"%u", ScsiOrdinal);
                PrefixLength = (ULONG)(p - TemporaryBuffer);
                ReturnedPath = SpMemAlloc((PrefixLength + wcslen(OrdinalString) + wcslen(q) + 1)
                                            * sizeof(WCHAR)
                                         );
                wcsncpy(ReturnedPath, TemporaryBuffer, PrefixLength);
                ReturnedPath[PrefixLength] = L'\0';
                wcscat(ReturnedPath, OrdinalString);
                wcscat(ReturnedPath, q);
            }
        }
    
        if(!ReturnedPath) {
            //
            // We didn't find a scsiordinal, this is a multi-style path, or
            // there was some problem, so just use the boot variable as-is.
            //
            ReturnedPath = SpDupStringW(BootVars[BootVariable][Component]);
        }
    
        return ReturnedPath;
    } else {
        //
        // Nothing to do on ARC machines.
        //
        return SpDupStringW(BootVars[BootVariable][Component]);
    }
}


#if defined(REMOTE_BOOT)
BOOLEAN
SpFlushRemoteBootVars(
    IN PDISK_REGION TargetRegion
    )
{

#if defined(EFI_NVRAM_ENABLED)
    if (SpIsEfi()) {
        //
        // Insert EFI code here.
        //
        return FALSE;

    } else
#endif
    {
        if (SpIsArc()) {
            //
            // Insert ARC code here.
            //
            return FALSE;
    
#if defined(_AMD64_) || defined(_X86_)
        } else {
            return Spx86FlushRemoteBootVars( TargetRegion, BootVars, Default );
#endif // defined(_AMD64_) || defined(_X86_)
        }
    }
}
#endif // defined(REMOTE_BOOT)


BOOLEAN
SppSetArcEnvVar(
    IN BOOTVAR Variable,
    IN PWSTR *VarComponents,
    IN BOOLEAN bWriteVar
    )
/*++

Routine Description:

    Set the value of the arc environment variable

Arguments:

    VarName - supplies the name of the arc environment variable
        whose value is to be set.
    VarComponents - Set of components of the variable value to be set
    bWriteVar - if TRUE, then write the variable to nvram, otherwise
        just return FALSE (having put the first component in NewBootVars).

Return Value:

    TRUE if values were written to nvram / FALSE otherwise

--*/

{
    ULONG Length, NBVLen, i;
    PWSTR Temp;
    PUCHAR Value;
    ARC_STATUS ArcStatus;

    ASSERT( !SpIsEfi() );

    if( VarComponents == NULL ) {
        Temp = SpDupStringW( L"" );
        NewBootVars[Variable] = SpDupStringW( L"" );
    }
    else {
        for( i = 0, Length = 0; VarComponents[i]; i++ ) {
            Length = Length + (wcslen(VarComponents[i]) + 1) * sizeof(WCHAR);
            if(i == 0) {
                NBVLen = Length;    // we just want to store the first component
            }
        }
        Temp = SpMemAlloc( Length );
        ASSERT( Temp );
        wcscpy( Temp, L"" );
        NewBootVars[Variable] = SpMemAlloc( NBVLen );
        ASSERT( NewBootVars[Variable] );
        wcscpy( NewBootVars[Variable], L"" );
        for( i = 0; VarComponents[i]; i++ ) {
            wcscat( Temp, VarComponents[i] );
            if( VarComponents[i + 1] ) {
                wcscat( Temp, L";" );
            }

            if(i == 0) {
                wcscat( NewBootVars[Variable], VarComponents[i]);
            }
        }
    }

    if(bWriteVar) {
        Value = SpToOem( Temp );
        ArcStatus = HalSetEnvironmentVariable( NvramVarNames[ Variable ], Value );
        SpMemFree( Value );
    } else {
        ArcStatus = ENOMEM;
    }
    SpMemFree( Temp );

    return ( ArcStatus == ESUCCESS );
}


#ifdef _X86_
BOOLEAN
SpIsArc(
    VOID
    )

/*++

Routine Description:

    Run time check to determine if this is an Arc system. We attempt to read an
    Arc variable using the Hal. This will fail for Bios based systems.

Arguments:

    None

Return Value:

    True = This is an Arc system.

--*/

{
#define BUFFERLENGTH 512
    ARC_STATUS ArcStatus = EBADF;
    UCHAR   *buf;

    if (IsArcChecked) {
        return IsArcMachine;
    }

    IsArcChecked = TRUE;
    IsArcMachine = FALSE;

    //
    // Get the env var into the temp buffer.
    //
    buf = SpMemAlloc( BUFFERLENGTH );
    if( buf ) {
        ArcStatus = HalGetEnvironmentVariable(
                        NvramVarNames[ OSLOADER ],
                        BUFFERLENGTH,               //sizeof(TemporaryBuffer),
                        buf                         //(PUCHAR)TemporaryBuffer
                        );
        SpMemFree( buf );
    }
    if (ArcStatus == ESUCCESS) {
        IsArcMachine = TRUE;
    }

    return IsArcMachine;
}
#endif

VOID
SpFreeBootEntries (
    VOID
    )

/*++

Routine Description:

    Frees memory used to hold internal-format boot entries and options.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSP_BOOT_ENTRY bootEntry;

    //
    // Free boot options. These will only be allocated on EFI machines.
    //
    if (SpBootOptions != NULL) {
        ASSERT(SpIsEfi());
        SpMemFree(SpBootOptions);
        SpBootOptions = NULL;
    }

    //
    // Free internal-format boot entries. These will be allocated on all
    // machines.
    //
    while (SpBootEntries != NULL) {

        bootEntry = SpBootEntries;
        SpBootEntries = bootEntry->Next;

        //
        // Space for some fields is allocated with the base structure.
        // If a fields address indicates that it was allocated with the
        // base structure, don't try to free it.
        //

#define IS_SEPARATE_ALLOCATION(_p)                                      \
        ((bootEntry->_p != NULL) &&                                     \
         (((PUCHAR)bootEntry->_p < (PUCHAR)bootEntry) ||                \
          ((PUCHAR)bootEntry->_p > (PUCHAR)bootEntry->AllocationEnd)))

#define FREE_IF_SEPARATE_ALLOCATION(_p)                                 \
        if (IS_SEPARATE_ALLOCATION(_p)) {                               \
            SpMemFree(bootEntry->_p);                                   \
        }

        FREE_IF_SEPARATE_ALLOCATION(FriendlyName);
        FREE_IF_SEPARATE_ALLOCATION(OsLoadOptions);
        FREE_IF_SEPARATE_ALLOCATION(LoaderPath);
        FREE_IF_SEPARATE_ALLOCATION(LoaderPartitionNtName);
        FREE_IF_SEPARATE_ALLOCATION(LoaderFile);
        FREE_IF_SEPARATE_ALLOCATION(OsPath);
        FREE_IF_SEPARATE_ALLOCATION(OsPartitionNtName);
        FREE_IF_SEPARATE_ALLOCATION(OsDirectory);
        FREE_IF_SEPARATE_ALLOCATION(Pid20Array);

        SpMemFree(bootEntry);
    }

    ASSERT(SpBootEntries == NULL);

    return;

} // SpFreeBootEntries

PCHAR
SppGetArcEnvVar(
    IN BOOTVAR Variable
    )

/*++

Routine Description:

    Query the value of an ARC environment variable.
    A buffer will be returned in all cases -- if the variable does not exist,
    the buffer will be empty.

Arguments:

    VarName - supplies the name of the arc environment variable
        whose value is desired.

Return Value:

    Buffer containing value of the environemnt variable.
    The caller must free this buffer with SpMemFree.

--*/

{
    ARC_STATUS ArcStatus;

    ASSERT( !SpIsEfi() );

    //
    // Get the env var into the temp buffer.
    //
    ArcStatus = HalGetEnvironmentVariable(
                    NvramVarNames[ Variable ],
                    sizeof(TemporaryBuffer),
                    (PCHAR) TemporaryBuffer
                    );

    if(ArcStatus != ESUCCESS) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: arc status %u getting env var %s\n",ArcStatus,NvramVarNames[Variable]));
        //
        // return empty buffer.
        //
        TemporaryBuffer[0] = 0;
    }

    return(SpDupString((PCHAR)TemporaryBuffer));
}

#ifdef _X86_
//
// NEC98
//
BOOLEAN
SpReInitializeBootVars_Nec98(
    VOID
)
{
    return SppReInitializeBootVars_Nec98( BootVars, &Default, &Timeout );
}
#endif

PWSTR
SpGetDefaultBootEntry (
    OUT UINT *DefaultSignatureOut
    )
{
    *DefaultSignatureOut = DefaultSignature;

    return Default;
}



VOID
SpDetermineUniqueAndPresentBootEntries(
    VOID
    )

/*++

Routine Description:

    This routine goes through the list of NT boot entries and marks all
    such entries that are both unique and present.

Arguments:

    None. This routine modifies entries in the SpBootEntries list as
    appropriate.

Return Value:

    None.

--*/
{
    PSP_BOOT_ENTRY BootEntry;
    PSP_BOOT_ENTRY BootEntry2;

    //
    // Initialize
    //

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_LOOKING_FOR_WINNT,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Go through all the matched boot sets and find out which NTs are
    // upgradeable/repairable. The criteria here are:
    //
    // 1. The system partition should exist and be valid.
    // 2. The OS load partition should exist.
    // 3. An NT should exist in <OSLoadPartition><OsDirectory>.
    // 4. OsLoadPartition should be a non-FT partition, or it should be a
    //    member 0 of a mirror.
    //

    for (BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {

        //
        // Initialize to false.
        //

        BootEntry->Processable = FALSE;

        //
        // If this entry has been deleted or is not an NT boot entry, skip it.
        //

        if (!IS_BOOT_ENTRY_WINDOWS(BootEntry) || IS_BOOT_ENTRY_DELETED(BootEntry)) {
            continue;
        }

        //
        // Check if the system and OS partitions are present and valid.
        //

        if ((BootEntry->LoaderPartitionDiskRegion == NULL) ||
            (BootEntry->OsPartitionDiskRegion == NULL)) {
            continue;
        }

        if (!BootEntry->LoaderPartitionDiskRegion->PartitionedSpace) {
            continue;
        }

        //
        // Check whether this directory has been covered before in the
        // boot entry list. This happens when multiple boot entries point
        // at the same tree. The comparison is done based on the system
        // partition region, the OS partition region, and the OS directory.
        //

        for ( BootEntry2 = SpBootEntries; BootEntry2 != BootEntry; BootEntry2 = BootEntry2->Next ) {
            if ((BootEntry->LoaderPartitionDiskRegion == BootEntry2->LoaderPartitionDiskRegion) &&
                (BootEntry->OsPartitionDiskRegion == BootEntry2->OsPartitionDiskRegion) &&
                (_wcsicmp(BootEntry->OsDirectory, BootEntry2->OsDirectory) == 0)) {
                break;
            }
        }
        if (BootEntry != BootEntry2) {
            //
            // This entry duplicates a previous entry. Skip it.
            //
            continue;
        }

        //
        // This boot entry is the first one to point to this OS directory.
        // Check whether an NT installation is actually present there.
        //

        if (SpIsNtInDirectory(BootEntry->OsPartitionDiskRegion, BootEntry->OsDirectory)
            // && !BootEntry->OsPartitionDiskRegion->FtPartition
            ) {
        }

        BootEntry->Processable = TRUE;
    }

    CLEAR_CLIENT_SCREEN();
    return;
}

VOID
SpRemoveInstallationFromBootList(
    IN  PDISK_REGION     SysPartitionRegion,   OPTIONAL
    IN  PDISK_REGION     NtPartitionRegion,    OPTIONAL
    IN  PWSTR            SysRoot,              OPTIONAL
    IN  PWSTR            SystemLoadIdentifier, OPTIONAL
    IN  PWSTR            SystemLoadOptions,    OPTIONAL
    IN  ENUMARCPATHTYPE  ArcPathType,
#if defined(REMOTE_BOOT)
    IN  BOOLEAN          RemoteBootPath,
#endif // defined(REMOTE_BOOT)
    OUT PWSTR            *OldOsLoadOptions     OPTIONAL
    )
{
    PWSTR   BootSet[MAXBOOTVARS];
    PWSTR   TempSysRoot = NULL;
    PWSTR   FirstBackslash;
    BOOTVAR i;
    WCHAR   Drive[] = L"?:";
    PWSTR   tmp2;
    PSP_BOOT_ENTRY bootEntry;

    //
    // Tell the user what we are doing.
    //
    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_CLEANING_FLEXBOOT,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Find all boot entries that match the input specifications, and mark
    // them for deletion.
    //

    for (bootEntry = SpBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {

        ASSERT(bootEntry->FriendlyName != NULL);
        if (IS_BOOT_ENTRY_WINDOWS(bootEntry)) {
            ASSERT(bootEntry->OsLoadOptions != NULL);
        }

        if (IS_BOOT_ENTRY_WINDOWS(bootEntry) &&
            !IS_BOOT_ENTRY_DELETED(bootEntry) &&
            ((SysPartitionRegion == NULL) ||
             (bootEntry->LoaderPartitionDiskRegion == SysPartitionRegion)) &&
            ((NtPartitionRegion == NULL) ||
             (bootEntry->OsPartitionDiskRegion == NtPartitionRegion)) &&
            ((SysRoot == NULL) ||
             ((bootEntry->OsDirectory != NULL) &&
              (_wcsicmp(bootEntry->OsDirectory, SysRoot) == 0))) &&
            ((SystemLoadIdentifier == NULL) ||
             (_wcsicmp(bootEntry->FriendlyName, SystemLoadIdentifier) == 0)) &&
            ((SystemLoadOptions == NULL) ||
             (_wcsicmp(bootEntry->OsLoadOptions, SystemLoadOptions) == 0))) {

            bootEntry->Status |= BE_STATUS_DELETED;

            if ((OldOsLoadOptions != NULL) && (*OldOsLoadOptions == NULL)) {
                *OldOsLoadOptions = SpDupStringW(bootEntry->OsLoadOptions);
            }
        }
    }

    //
    // If not on an EFI machine, then also delete matching ARC boot sets.
    //

    if (!SpIsEfi()) {
    
        //
        // Set up the boot set
        //
        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
            BootSet[i] = NULL;
        }
    
        tmp2 = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);
    
        if( NtPartitionRegion ) {
            SpArcNameFromRegion(NtPartitionRegion,tmp2,sizeof(TemporaryBuffer)/2,PartitionOrdinalOnDisk,ArcPathType);
            BootSet[OSLOADPARTITION] = SpDupStringW(tmp2);
        }
    
        if( SysPartitionRegion ) {
            SpArcNameFromRegion(SysPartitionRegion,tmp2,sizeof(TemporaryBuffer)/2,PartitionOrdinalOnDisk,ArcPathType);
            BootSet[SYSTEMPARTITION] = SpDupStringW(tmp2);
        }
    
        BootSet[OSLOADFILENAME] = SysRoot;
        BootSet[LOADIDENTIFIER] = SystemLoadIdentifier;
        BootSet[OSLOADOPTIONS]  = SystemLoadOptions;
    
#if defined(REMOTE_BOOT)
        //
        // If this is a remote boot path, then move anything in OSLOADPARTITION
        // after (and including) the first backslash over to the OSLOADFILENAME --
        // this is the way that boot.ini is parsed when it is read, so it will
        // allow SpDeleteBootSet to match it properly.
        //
    
        if (RemoteBootPath && NtPartitionRegion &&
                (FirstBackslash = wcschr(BootSet[OSLOADPARTITION], L'\\'))) {
            wcscpy(tmp2, FirstBackslash);
            wcscat(tmp2, SysRoot);
            TempSysRoot = SpDupStringW(tmp2);
            BootSet[OSLOADFILENAME] = TempSysRoot;
            *FirstBackslash = L'\0';         // truncate BootSet[OSLOADPARTITION]
        }
#endif // defined(REMOTE_BOOT)
    
        //
        // Delete the boot set
        //
        SpDeleteBootSet(BootSet, OldOsLoadOptions);
    
        //
        // To take care of the case where the OSLOADPARTITION is a DOS drive letter
        // in the boot set, change the OSLOADPARTITION to a drive and retry
        // deletion
        //
        if( BootSet[OSLOADPARTITION] != NULL ) {
            SpMemFree(BootSet[OSLOADPARTITION]);
        }
        if( NtPartitionRegion && (ULONG)(Drive[0] = NtPartitionRegion->DriveLetter) != 0) {
            BootSet[OSLOADPARTITION] = Drive;
            SpDeleteBootSet(BootSet, OldOsLoadOptions);
        }
    
#if defined(_AMD64_) || defined(_X86_)
        //
        // If OldOsLoadOptions contains "/scsiordinal:", then remove it
        //
        if( ( OldOsLoadOptions != NULL ) &&
            ( *OldOsLoadOptions != NULL ) ) {
    
            PWSTR   p, q;
            WCHAR   SaveChar;
    
            SpStringToLower(*OldOsLoadOptions);
            p = wcsstr( *OldOsLoadOptions, L"/scsiordinal:" );
            if( p != NULL ) {
                SaveChar = *p;
                *p = (WCHAR)'\0';
                wcscpy(TemporaryBuffer, *OldOsLoadOptions);
                *p = SaveChar;
                q = wcschr( p, (WCHAR)' ' );
                if( q != NULL ) {
                    wcscat( TemporaryBuffer, q );
                }
                SpMemFree( *OldOsLoadOptions );
                *OldOsLoadOptions = SpDupStringW( ( PWSTR )TemporaryBuffer );
            }
        }
#endif // defined(_AMD64_) || defined(_X86_)
    
        //
        // Cleanup
        //
        if( BootSet[SYSTEMPARTITION] != NULL ) {
            SpMemFree(BootSet[SYSTEMPARTITION]);
        }
        if (TempSysRoot != NULL) {
            SpMemFree(TempSysRoot);
        }
    }
    return;
}


VOID
SpAddInstallationToBootList(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN BOOLEAN      BaseVideoOption,
    IN PWSTR        OldOsLoadOptions OPTIONAL
    )
/*++

Routine Description:

    Construct a boot set for the given installation
    parameters and add it to the current boot list.
    Perform modifications to the os load options if
    necessary.
          
Notes:  if this code changes, please ensure that 
    
            SpAddUserDefinedInstallationToBootList()
        
        stays in sync if appropriate.

--*/
{
    PWSTR   BootVars[MAXBOOTVARS];
    PWSTR   SystemPartitionArcName;
    PWSTR   TargetPartitionArcName;
    PWSTR   tmp;
    PWSTR   tmp2;
    PWSTR   SifKeyName;
    ULONG   Signature;
    BOOLEAN AddBaseVideo = FALSE;
    WCHAR   BaseVideoString[] = L"/basevideo";
    WCHAR   BaseVideoSosString[] = L"/sos";
    BOOLEAN AddSosToBaseVideoString;
    HEADLESS_RSP_QUERY_INFO Response;
    WCHAR   HeadlessRedirectString[] = L"/redirect";
#if defined(_AMD64_) || defined(_X86_)
    WCHAR   BootFastString[] = L"/fastdetect";
    BOOLEAN AddBootFastString = TRUE;
#endif // defined(_AMD64_) || defined(_X86_)
    ENUMARCPATHTYPE ArcPathType = PrimaryArcPath;
    WCHAR   HalString[] = L"/hal=";
    BOOLEAN OldOsLoadOptionsReplaced;
    NTSTATUS Status;
    SIZE_T Length;
    PWSTR LoadOptions;
    PWSTR LoadIdentifier;


    //
    // Tell the user what we are doing.
    //
    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_INITING_FLEXBOOT,DEFAULT_STATUS_ATTRIBUTE);

    OldOsLoadOptionsReplaced = FALSE;

    if( OldOsLoadOptions ) {
        PWSTR   p;

        tmp = SpDupStringW( OldOsLoadOptions );

        if (tmp) {
            SpStringToLower(tmp);

            if( p = wcsstr(tmp, HalString) ) {  // found /hal=
                WCHAR   SaveChar;
                PWSTR   q;

                SaveChar = *p;
                *p = L'\0';
                wcscpy( TemporaryBuffer, OldOsLoadOptions );
                q = TemporaryBuffer + wcslen( tmp );
                *q = L'\0';
                Length = wcslen( tmp );
                *p = SaveChar;
                for( ; *p && (*p != L' '); p++ ) {
                    Length++;
                }
                for( ; *p && (*p == L' '); p++ ) {
                    Length++;
                }
                if( *p ) {
                    wcscat( TemporaryBuffer, OldOsLoadOptions+Length );
                }
                OldOsLoadOptions = SpDupStringW( TemporaryBuffer );
                OldOsLoadOptionsReplaced = TRUE;
            }

            SpMemFree( tmp );
        }            
    }

    tmp2 = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);

    if (!SpIsEfi()) {
    
        //
        // Get an ARC name for the system partition.
        //
        if (SystemPartitionRegion != NULL) {
            SpArcNameFromRegion(
                SystemPartitionRegion,
                tmp2,
                sizeof(TemporaryBuffer)/2,
                PartitionOrdinalOnDisk,
                PrimaryArcPath
                );
            SystemPartitionArcName = SpDupStringW(tmp2);
        } else {
            SystemPartitionArcName = NULL;
        }
    
        //
        // Get an ARC name for the target partition.
        //
    
        //
        // If the partition is on a SCSI disk that has more than 1024 cylinders
        // and the partition has sectors located on cylinders beyond cylinder
        // 1024, the get the arc name in the secondary format. See also
        // spcopy.c!SpCreateNtbootddSys().
        //
        if(
            !SpIsArc() &&
#if defined(REMOTE_BOOT)
            !RemoteBootSetup &&
#endif // defined(REMOTE_BOOT)
    
#if defined(_AMD64_) || defined(_X86_)
            !SpUseBIOSToBoot(NtPartitionRegion, NULL, SifHandle) &&
#endif // defined(_AMD64_) || defined(_X86_)
            (HardDisks[NtPartitionRegion->DiskNumber].ScsiMiniportShortname[0]) ) {
    
            ArcPathType = SecondaryArcPath;
        } else {
            ArcPathType = PrimaryArcPath;
        }
    
        SpArcNameFromRegion(
            NtPartitionRegion,
            tmp2,
            sizeof(TemporaryBuffer)/2,
            PartitionOrdinalOnDisk,
            ArcPathType
            );
    
        TargetPartitionArcName = SpDupStringW(tmp2);
    }
    
    //
    // OSLOADOPTIONS is specified in the setup information file.
    //
    tmp = SpGetSectionKeyIndex(
                WinntSifHandle,
                SIF_SETUPDATA,
                SIF_OSLOADOPTIONSVAR,
                0
                );
    if (tmp == NULL) {
        tmp = SpGetSectionKeyIndex(
                SifHandle,
                SIF_SETUPDATA,
                SIF_OSLOADOPTIONSVAR,
                0
                );
    }

    //
    // If OsLoadOptionsVar wasn't specified, then we'll preserve any flags
    // the user had specified.
    //
    if(!tmp && OldOsLoadOptions) {
        tmp = OldOsLoadOptions;
    }

    AddSosToBaseVideoString = BaseVideoOption;
    AddBaseVideo = BaseVideoOption;

    if(tmp) {
        //
        // make sure we don't already have a /basevideo option, so we
        // won't add another
        //

        wcscpy(TemporaryBuffer, tmp);
        SpStringToLower(TemporaryBuffer);
        if(wcsstr(TemporaryBuffer, BaseVideoString)) {  // already have /basevideo
            BaseVideoOption = TRUE;
            AddBaseVideo = FALSE;
        }
        if(wcsstr(TemporaryBuffer, BaseVideoSosString)) {  // already have /sos
            AddSosToBaseVideoString = FALSE;
        }
#if defined(_AMD64_) || defined(_X86_)
        if(wcsstr(TemporaryBuffer, BootFastString)) {  // already have /bootfast
            AddBootFastString = FALSE;
        }
#endif // defined(_AMD64_) || defined(_X86_)
    }

    if(AddBaseVideo || AddSosToBaseVideoString
#if defined(_AMD64_) || defined(_X86_)
       || AddBootFastString
#endif // defined(_AMD64_) || defined(_X86_)
      ) {

        Length = ((tmp ? wcslen(tmp) + 1 : 0) * sizeof(WCHAR));
        if( AddBaseVideo ) {
            Length += sizeof(BaseVideoString);
        }
        if( AddSosToBaseVideoString ) {
            Length += sizeof( BaseVideoSosString );
        }
#if defined(_AMD64_) || defined(_X86_)
        if( AddBootFastString ) {
            Length += sizeof( BootFastString );
        }
#endif // defined(_AMD64_) || defined(_X86_)

        tmp2 = SpMemAlloc(Length);

        *tmp2 = ( WCHAR )'\0';
        if( AddBaseVideo ) {
            wcscat(tmp2, BaseVideoString);
        }
        if( AddSosToBaseVideoString ) {
            if( *tmp2 != (WCHAR)'\0' ) {
                wcscat(tmp2, L" ");
            }
            wcscat(tmp2, BaseVideoSosString);
        }
#if defined(_AMD64_) || defined(_X86_)
        if( AddBootFastString ) {
            if( *tmp2 != (WCHAR)'\0' ) {
                wcscat(tmp2, L" ");
            }
            wcscat(tmp2, BootFastString);
        }
#endif // defined(_AMD64_) || defined(_X86_)
        if(tmp) {
            if( *tmp2 != (WCHAR)'\0' ) {
                wcscat(tmp2, L" ");
            }
            wcscat(tmp2, tmp);
        }

        LoadOptions = SpDupStringW(tmp2);

        SpMemFree(tmp2);

    } else {
        LoadOptions = SpDupStringW(tmp ? tmp : L"");
    }

    //
    // Add on headless redirect parameter if we are redirecting right now.
    //

    Length = sizeof(HEADLESS_RSP_QUERY_INFO);
    Status = HeadlessDispatch(HeadlessCmdQueryInformation,
                              NULL,
                              0,
                              &Response,
                              &Length
                             );

    if (NT_SUCCESS(Status) && 
        (Response.PortType == HeadlessSerialPort) &&
        Response.Serial.TerminalAttached) {

        //
        // Before we go adding a /redirect string, we need to make
        // sure there's not already one.
        //
        if( !wcsstr(LoadOptions, HeadlessRedirectString) ) {

            Length = (wcslen(LoadOptions) + 1) * sizeof(WCHAR);
            Length += sizeof(HeadlessRedirectString);

            tmp2 = SpMemAlloc(Length);
            ASSERT(tmp2 != NULL);

            *tmp2 = UNICODE_NULL;

            wcscat(tmp2, LoadOptions);
            if (*tmp2 != UNICODE_NULL) {
                wcscat(tmp2, L" ");
            }
            wcscat(tmp2, HeadlessRedirectString);

            SpMemFree(LoadOptions);

            LoadOptions = tmp2;
        }
    }

    //
    // LOADIDENTIFIER is specified in the setup information file.
    // We need to surround it in double quotes.
    // Which value to use depends on the BaseVideo flag.
    //
    SifKeyName = BaseVideoOption ? SIF_BASEVIDEOLOADID : SIF_LOADIDENTIFIER;

    tmp = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SifKeyName,0);

    if(!tmp) {
        SpFatalSifError(SifHandle,SIF_SETUPDATA,SifKeyName,0,0);
    }

    if(!SpIsArc()) {
        //
        // Need quotation marks around the description on amd64/x86.
        //
        LoadIdentifier = SpMemAlloc((wcslen(tmp)+3)*sizeof(WCHAR));
        LoadIdentifier[0] = L'\"';
        wcscpy(LoadIdentifier+1,tmp);
        wcscat(LoadIdentifier,L"\"");
    } else {
        LoadIdentifier = SpDupStringW(tmp);
    }

    //
    // Create a new internal-format boot entry.
    //
    tmp = TemporaryBuffer;
    wcscpy(tmp,SystemPartitionDirectory);
    SpConcatenatePaths(
        tmp,
#if defined(_AMD64_) || defined(_X86_)
        SpIsArc() ? L"arcldr.exe" : L"ntldr"
#elif defined(_IA64_)
        L"ia64ldr.efi"
#else
        L"osloader.exe"
#endif // defined(_AMD64_) || defined(_X86_)
        );
    tmp = SpDupStringW(tmp);

    SpCreateBootEntry(
        BE_STATUS_NEW,
        SystemPartitionRegion,
        tmp,
        NtPartitionRegion,
        Sysroot,
        LoadOptions,
        LoadIdentifier
        );

    SpMemFree(tmp);

    //
    // If not on an EFI machine, add a new ARC-style boot set.
    //
    if (!SpIsEfi()) {
    
        BootVars[OSLOADOPTIONS] = LoadOptions;
        BootVars[LOADIDENTIFIER] = LoadIdentifier;
    
        //
        // OSLOADER is the system partition path + the system partition directory +
        //          osloader.exe. (ntldr on amd64/x86 machines).
        //
        if (SystemPartitionRegion != NULL) {
            tmp = TemporaryBuffer;
            wcscpy(tmp,SystemPartitionArcName);
            SpConcatenatePaths(tmp,SystemPartitionDirectory);
            SpConcatenatePaths(
                tmp,
#if defined(_AMD64_) || defined(_X86_)
                (SpIsArc() ? L"arcldr.exe" : L"ntldr")
#elif defined(_IA64_)
                L"ia64ldr.efi"
#else
                L"osloader.exe"
#endif // defined(_AMD64_) || defined(_X86_)
                );
    
            BootVars[OSLOADER] = SpDupStringW(tmp);
        } else {
            BootVars[OSLOADER] = SpDupStringW(L"");
        }
    
        //
        // OSLOADPARTITION is the ARC name of the windows nt partition.
        //
        BootVars[OSLOADPARTITION] = TargetPartitionArcName;
    
        //
        // OSLOADFILENAME is sysroot.
        //
        BootVars[OSLOADFILENAME] = Sysroot;
    
        //
        // SYSTEMPARTITION is the ARC name of the system partition.
        //
        if (SystemPartitionRegion != NULL) {
            BootVars[SYSTEMPARTITION] = SystemPartitionArcName;
        } else {
            BootVars[SYSTEMPARTITION] = L"";
        }
    
        //
        // get the disk signature
        //
        if ((NtPartitionRegion->DiskNumber != 0xffffffff) && HardDisks[NtPartitionRegion->DiskNumber].Signature) {
            Signature = HardDisks[NtPartitionRegion->DiskNumber].Signature;
        } else {
            Signature = 0;
        }
    
        //
        // Add the boot set and make it the default.
        //
        SpAddBootSet(BootVars, TRUE, Signature);

        SpMemFree(BootVars[OSLOADER]);
    }

    //
    // Free memory allocated.
    //
    SpMemFree(LoadOptions);
    SpMemFree(LoadIdentifier);

    if (!SpIsEfi()) {
        if (SystemPartitionArcName != NULL) {
            SpMemFree(SystemPartitionArcName);
        }
        SpMemFree(TargetPartitionArcName);
    }

    if( OldOsLoadOptionsReplaced ) {
        SpMemFree( OldOsLoadOptions );
    }
}


VOID
SpCompleteBootListConfig(
    WCHAR   DriveLetter
    )
{
    if(!RepairWinnt) {
        if (!SpIsArc()) {
            Timeout = 1;
        } else {
            Timeout = 5;
            //
            // If this is a winnt setup, there will be a boot set to start
            // text setup ("Install/Upgrade Windows NT").  Remove it here.
            //
            if(WinntSetup) {

                PSP_BOOT_ENTRY bootEntry;

                for (bootEntry = SpBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {
                    if (IS_BOOT_ENTRY_WINDOWS(bootEntry) &&
                        !IS_BOOT_ENTRY_DELETED(bootEntry) &&
                        (_wcsicmp(bootEntry->OsLoadOptions, L"WINNT32") == 0)) {
                        bootEntry->Status |= BE_STATUS_DELETED;
                    }
                }

                if (!SpIsEfi()) {
                
                    PWSTR BootVars[MAXBOOTVARS];

                    RtlZeroMemory(BootVars,sizeof(BootVars));

                    BootVars[OSLOADOPTIONS] = L"WINNT32";

                    SpDeleteBootSet(BootVars, NULL);
                }
            }
        }
    }

#ifdef _X86_
    if (g_Win9xBackup) {
        SpRemoveExtraBootIniEntry();
    }
#endif

    //
    // Flush boot vars.
    // On some machines, NVRAM update takes a few seconds,
    // so change the message to tell the user we are doing something different.
    //
    SpDisplayStatusText(SP_STAT_UPDATING_NVRAM,DEFAULT_STATUS_ATTRIBUTE);

    if(!SpFlushBootVars()) {
        if(SpIsEfi() || !SpIsArc()) {
            //
            // Fatal on x86 and EFI machines, nonfatal on arc machines.
            //
            if (SpIsEfi()) {
                SpStartScreen(SP_SCRN_CANT_INIT_FLEXBOOT_EFI,
                              3,
                              HEADER_HEIGHT+1,
                              FALSE,
                              FALSE,
                              DEFAULT_ATTRIBUTE
                              );
            } else {
                WCHAR   DriveLetterString[2];
    
                DriveLetterString[0] = DriveLetter;
                DriveLetterString[1] = L'\0';
                SpStringToUpper(DriveLetterString);
                SpStartScreen(SP_SCRN_CANT_INIT_FLEXBOOT,
                              3,
                              HEADER_HEIGHT+1,
                              FALSE,
                              FALSE,
                              DEFAULT_ATTRIBUTE,
                              DriveLetterString,
                              DriveLetterString
                              );
            }
            SpDisplayStatusText(SP_STAT_F3_EQUALS_EXIT,DEFAULT_STATUS_ATTRIBUTE);
            SpInputDrain();
            while(SpInputGetKeypress() != KEY_F3) ;
            SpDone(0,FALSE,TRUE);
        } else {
            BOOL b;

            b = TRUE;
            while(b) {
                ULONG ValidKeys[2] = { ASCI_CR, 0 };

                SpStartScreen(
                    SP_SCRN_CANT_UPDATE_BOOTVARS,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    NewBootVars[LOADIDENTIFIER],
                    NewBootVars[OSLOADER],
                    NewBootVars[OSLOADPARTITION],
                    NewBootVars[OSLOADFILENAME],
                    NewBootVars[OSLOADOPTIONS],
                    NewBootVars[SYSTEMPARTITION]
                    );

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    0
                    );

                switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {
                case ASCI_CR:
                    b = FALSE;
                }
            }
        }
    }

    if(SpIsArc() && !SpIsEfi()) {
        // Free all of the boot variable strings
        BOOTVAR i;

        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
            SpMemFree(NewBootVars[i]);
            NewBootVars[i] = NULL;
        }
    }
}

VOID
SpPtDeleteBootSetsForRegion(
    PDISK_REGION Region
    )
/*++

Routine Description:

    This routine goes through all the valid boot entries and
    deletes the ones which point to the specified region.

Arguments:

    Region : The region whose references from boot entries need
    to be removed

Return Value:

    None.

--*/
{
    PWSTR bootSet[MAXBOOTVARS];
    ENUMARCPATHTYPE arcPathType;
    ULONG i;
    PSP_BOOT_ENTRY bootEntry;

    if (Region->PartitionedSpace) {
        BOOLEAN IsSystemPartition = SPPT_IS_REGION_SYSTEMPARTITION(Region);
        
        //
        // Find all boot entries that have the specified region as the
        // OS load partition, and mark them for deletion.
        //
        for (bootEntry = SpBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {
            if (IS_BOOT_ENTRY_WINDOWS(bootEntry) &&
                !IS_BOOT_ENTRY_DELETED(bootEntry) &&
                (IsSystemPartition ? (bootEntry->LoaderPartitionDiskRegion == Region) :
                                     (bootEntry->OsPartitionDiskRegion == Region))) {
                bootEntry->Status |= BE_STATUS_DELETED;

                //
                // Make the regions also NULL since they might have actually
                // been deleted
                //
                bootEntry->LoaderPartitionDiskRegion = NULL;
                bootEntry->OsPartitionDiskRegion = NULL;
            }
        }

        //
        // If we're not on an EFI machine, we also have to munge the ARC
        // boot variables.
        //

        if (!SpIsEfi()) {
        
            //
            // Set up the boot set
            //
            for (i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                bootSet[i] = NULL;
            }
    
            //
            // We go through this loop twice, once for primary ARC path
            // and once for secondary. We delete any image which has
            // the OS load partition on the region we are deleting.
            //
    
            for (i = 0; i < 2; i++) {
    
                if (i == 0) {
                    arcPathType = PrimaryArcPath;
                } else {
                    arcPathType = SecondaryArcPath;
                }
    
                SpArcNameFromRegion(
                    Region,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    PartitionOrdinalOnDisk,
                    arcPathType);
    
                if ((TemporaryBuffer)[0] != L'\0') {
                    ULONG   Index = IsSystemPartition ? 
                                        SYSTEMPARTITION : OSLOADPARTITION;
                    
                    bootSet[Index] = SpDupStringW(TemporaryBuffer);
                    SpDeleteBootSet(bootSet, NULL);
                    SpMemFree(bootSet[Index]);
    
                }
            }
        }
    }
}

VOID
SpGetNtDirectoryList(
    OUT PWSTR  **DirectoryList,
    OUT PULONG   DirectoryCount
    )

/*++

Routine Description:

    Determine the list of directories into which NT may be installed.
    This is independent of the partitions onto which it may be installed.

    The determination of which directories nt might be in is based on
    boot.ini in the amd64/x86 cases, or on arc firmware (OSLOADFILENAME
    var) in the arc case.

Arguments:

    DirectoryList - receives a pointer to an array of strings,
        each of which contains a possible windows nt tree.

    DirectoryCount - receives the number of elements in DirectoryList.
        This may be 0.

Return Value:

    None.  The caller must free the array in DirectoryList if
    DirectoryCount is returned as non-0.

--*/

{
    ULONG count;
    PSP_BOOT_ENTRY BootEntry;
    PSP_BOOT_ENTRY BootEntry2;
    PWSTR *DirList;

    //
    // Free any previously allocated list.
    //
    if (CurrentNtDirectoryList != NULL) {
        SpMemFree(CurrentNtDirectoryList);
    }

    //
    // Walk the boot entry list to determine how many unique NT directory names
    // exist.
    //
    count = 0;
    for (BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
        if (!IS_BOOT_ENTRY_WINDOWS(BootEntry) || (BootEntry->OsDirectory == NULL)) {
            continue;
        }
        for (BootEntry2 = SpBootEntries; BootEntry2 != BootEntry; BootEntry2 = BootEntry2->Next) {
            if (!IS_BOOT_ENTRY_WINDOWS(BootEntry2) || (BootEntry2->OsDirectory == NULL)) {
                continue;
            }
            if (_wcsicmp(BootEntry2->OsDirectory, BootEntry->OsDirectory) == 0) {
                break;
            }
        }
        if (BootEntry2 == BootEntry) {
            count++;
        }
    }

    //
    // Allocate space for the list.
    //
    DirList = SpMemAlloc(count * sizeof(PWSTR));
    ASSERT(DirList != NULL);

    //
    // Populate the list.
    //
    count = 0;
    for (BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
        if (!IS_BOOT_ENTRY_WINDOWS(BootEntry) || (BootEntry->OsDirectory == NULL)) {
            continue;
        }
        for (BootEntry2 = SpBootEntries; BootEntry2 != BootEntry; BootEntry2 = BootEntry2->Next) {
            if (!IS_BOOT_ENTRY_WINDOWS(BootEntry2) || (BootEntry2->OsDirectory == NULL)) {
                continue;
            }
            if (_wcsicmp(BootEntry2->OsDirectory, BootEntry->OsDirectory) == 0) {
                break;
            }
        }
        if (BootEntry2 == BootEntry) {
            DirList[count++] = BootEntry->OsDirectory;
        }
    }

    //
    // Return a pointer to the list that we allocated.
    //
    CurrentNtDirectoryList = DirList;
    *DirectoryList = DirList;
    *DirectoryCount = count;

    return;
}

BOOLEAN
SpConvertArcBootEntries (
    IN ULONG MaxComponents
    )

/*++

Routine Description:

    Convert ARC boot entries (read from boot.ini or from ARC NVRAM) into
    our internal format.

Arguments:

    MaxComponents - maximum number of elements in any NVRAM variable.

Return Value:

    BOOLEAN - FALSE if any unexpected errors occurred.

--*/

{
    LONG i;
    PDISK_REGION systemPartitionRegion;
    PDISK_REGION ntPartitionRegion;
    PWSTR loaderName;

    for (i = (LONG)MaxComponents - 1; i >= 0; i--) {

        //
        // Skip this boot set if it is not complete.
        //
        
        if ((BootVars[SYSTEMPARTITION][i] != NULL) &&
            (BootVars[OSLOADPARTITION][i] != NULL) &&
            (BootVars[OSLOADER][i] != NULL) &&
            (BootVars[OSLOADFILENAME][i] != NULL) &&
            (BootVars[OSLOADOPTIONS][i] != NULL) &&
            (BootVars[LOADIDENTIFIER][i] != NULL)) {

            //
            // Translate the SYSTEMPARTITION and OSLOADPARTITION ARC names
            // into disk region pointers. Get the loader file name from
            // OSLOADER, which contains an ARC name (same as OSLOADPARTITION)
            // and a file name.
            //
            systemPartitionRegion = SpRegionFromArcName(
                                        BootVars[SYSTEMPARTITION][i],
                                        PartitionOrdinalCurrent,
                                        NULL
                                        );

            ntPartitionRegion = SpRegionFromArcName(
                                        BootVars[OSLOADPARTITION][i],
                                        PartitionOrdinalCurrent,
                                        NULL
                                        );

            //
            // Take care of duplicate arc names for the same disk by searching
            // and validating the NT directory is present on the partition
            //
            while (ntPartitionRegion &&
                    !SpIsNtInDirectory(ntPartitionRegion, BootVars[OSLOADFILENAME][i])) {
                //                                
                // Continue to look for same name region from the current 
                // searched region
                //
                ntPartitionRegion = SpRegionFromArcName(
                                            BootVars[OSLOADPARTITION][i],
                                            PartitionOrdinalCurrent,
                                            ntPartitionRegion
                                            );
            }
                                                    
            loaderName = wcschr(BootVars[OSLOADER][i], L'\\');

            //
            // If all of the above worked, then add an internal-format boot
            // entry for this ARC boot set.
            //
            if ((systemPartitionRegion != NULL) &&
                (ntPartitionRegion != NULL) &&
                (loaderName != NULL)) {

                SpCreateBootEntry(
                    BE_STATUS_FROM_BOOT_INI,
                    systemPartitionRegion,
                    loaderName,
                    ntPartitionRegion,
                    BootVars[OSLOADFILENAME][i],
                    BootVars[OSLOADOPTIONS][i],
                    BootVars[LOADIDENTIFIER][i]
                    );
            }
        }
    }

    return TRUE;
}

VOID
SpUpdateRegionForBootEntries(
    VOID
    )
/*++

Routine Description:

    Update the region pointers for all the given boot entries.

    NOTE : The region pointers change with every commit so we
    can't cache them across commits.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PSP_BOOT_ENTRY BootEntry;

    //
    // Walk through each boot entry and update its system partition region
    // pointer and NT partition region pointer.
    //
    for (BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {

        if (!IS_BOOT_ENTRY_DELETED(BootEntry)) {
            if (BootEntry->LoaderPartitionNtName != NULL) {
                BootEntry->LoaderPartitionDiskRegion = 
                    SpRegionFromNtName(BootEntry->LoaderPartitionNtName,
                                       PartitionOrdinalCurrent);
            } else {
                BootEntry->LoaderPartitionDiskRegion = NULL;
            }            

            if (BootEntry->OsPartitionNtName != NULL) {
                BootEntry->OsPartitionDiskRegion =
                    SpRegionFromNtName(BootEntry->OsPartitionNtName,
                                       PartitionOrdinalCurrent);
            } else {
                BootEntry->OsPartitionDiskRegion = NULL;
            }            
        }
    }

    return;

} // SpUpdateRegionForBootEntries

VOID
SpCreateBootEntry (
    IN ULONG_PTR Status,
    IN PDISK_REGION BootFileRegion,
    IN PWSTR BootFilePath,
    IN PDISK_REGION OsLoadRegion,
    IN PWSTR OsLoadPath,
    IN PWSTR OsLoadOptions,
    IN PWSTR FriendlyName
    )

/*++

Routine Description:

    Create an internal-format boot entry.

Arguments:

    Status - The status to be assigned to the boot entry. This should be either
        zero (for an entry already in NVRAM) or BE_STATUS_NEW for a new boot
        entry. Entries marked BE_STATUS_NEW are written to NVRAM at the end
        of textmode setup.

    BootFileRegion - The disk region on which the OS loader resides.

    BootFilePath - The volume-relative path to the OS loader. Must start with
        a backslash.

    OsLoadRegion - The disk region on which the OS resides.

    OsLoadPath - The volume-relative path to the OS root directory (\WINDOWS).
        Must start with a backslash.

    OsLoadOptions - Boot options for the OS. Can be an empty string.

    FriendlyName - The user-visible name for the boot entry. (This is ARC's
        LOADIDENTIFIER.)

Return Value:

    None. Only memory allocation failures are possible, and these are
        handled out-of-band.

--*/

{
    NTSTATUS status;
    ULONG requiredLength;
    ULONG osOptionsOffset;
    ULONG osLoadOptionsLength;
    ULONG osLoadPathOffset;
    ULONG osLoadPathLength;
    ULONG osOptionsLength;
    ULONG friendlyNameOffset;
    ULONG friendlyNameLength;
    ULONG bootPathOffset;
    ULONG bootPathLength;
    PSP_BOOT_ENTRY myBootEntry;
    PSP_BOOT_ENTRY previousBootEntry;
    PSP_BOOT_ENTRY nextBootEntry;
    PBOOT_ENTRY ntBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    PFILE_PATH osLoadPath;
    PWSTR friendlyName;
    PFILE_PATH bootPath;
    PWSTR p;

    PWSTR bootFileDevice;
    PWSTR osLoadDevice;

    //
    // Get NT names for the input disk regions.
    //
    bootFileDevice = SpMemAlloc(512);
    SpNtNameFromRegion(BootFileRegion, bootFileDevice, 512, PartitionOrdinalCurrent);

    osLoadDevice = SpMemAlloc(512);
    SpNtNameFromRegion(OsLoadRegion, osLoadDevice, 512, PartitionOrdinalCurrent);

    //
    // Calculate how long the internal boot entry needs to be. This includes
    // our internal structure, plus the BOOT_ENTRY structure that the NT APIs
    // use.
    //
    // Our structure:
    //
    requiredLength = FIELD_OFFSET(SP_BOOT_ENTRY, NtBootEntry);

    //
    // Base part of NT structure:
    //
    requiredLength += FIELD_OFFSET(BOOT_ENTRY, OsOptions);

    //
    // Save offset to BOOT_ENTRY.OsOptions. Add in base part of
    // WINDOWS_OS_OPTIONS. Calculate length in bytes of OsLoadOptions
    // and add that in.
    //
    osOptionsOffset = requiredLength;
    requiredLength += FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions);
    osLoadOptionsLength = (wcslen(OsLoadOptions) + 1) * sizeof(WCHAR);
    requiredLength += osLoadOptionsLength;

    //
    // Round up to a ULONG boundary for the OS FILE_PATH in the
    // WINDOWS_OS_OPTIONS. Save offset to OS FILE_PATH. Add in base part
    // of FILE_PATH. Add in length in bytes of OS device NT name and OS
    // directory. Calculate total length of OS FILE_PATH and of
    // WINDOWS_OS_OPTIONS.
    // 
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    osLoadPathOffset = requiredLength;
    requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);
    requiredLength += (wcslen(osLoadDevice) + 1 + wcslen(OsLoadPath) + 1) * sizeof(WCHAR);
    osLoadPathLength = requiredLength - osLoadPathOffset;
    osOptionsLength = requiredLength - osOptionsOffset;

    //
    // Round up to a ULONG boundary for the friendly name in the BOOT_ENTRY.
    // Save offset to friendly name. Calculate length in bytes of friendly name
    // and add that in.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    friendlyNameOffset = requiredLength;
    friendlyNameLength = (wcslen(FriendlyName) + 1) * sizeof(WCHAR);
    requiredLength += friendlyNameLength;

    //
    // Round up to a ULONG boundary for the boot FILE_PATH in the BOOT_ENTRY.
    // Save offset to boot FILE_PATH. Add in base part of FILE_PATH. Add in
    // length in bytes of boot device NT name and boot file. Calculate total
    // length of boot FILE_PATH.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    bootPathOffset = requiredLength;
    requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);
    requiredLength += (wcslen(bootFileDevice) + 1 + wcslen(BootFilePath) + 1) * sizeof(WCHAR);
    bootPathLength = requiredLength - bootPathOffset;

    //
    // Allocate memory for the boot entry.
    //
    myBootEntry = SpMemAlloc(requiredLength);
    ASSERT(myBootEntry != NULL);

    RtlZeroMemory(myBootEntry, requiredLength);

    //
    // Calculate addresses of various substructures using the saved offsets.
    //
    ntBootEntry = &myBootEntry->NtBootEntry;
    osOptions = (PWINDOWS_OS_OPTIONS)ntBootEntry->OsOptions;
    osLoadPath = (PFILE_PATH)((PUCHAR)myBootEntry + osLoadPathOffset);
    friendlyName = (PWSTR)((PUCHAR)myBootEntry + friendlyNameOffset);
    bootPath = (PFILE_PATH)((PUCHAR)myBootEntry + bootPathOffset);

    //
    // Fill in the internal-format structure.
    //
    myBootEntry->AllocationEnd = (PUCHAR)myBootEntry + requiredLength;
    myBootEntry->Status = Status | BE_STATUS_ORDERED;
    myBootEntry->FriendlyName = friendlyName;
    myBootEntry->FriendlyNameLength = friendlyNameLength;
    myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
    myBootEntry->OsLoadOptionsLength = osLoadOptionsLength;
    myBootEntry->LoaderPath = bootPath;
    myBootEntry->OsPath = osLoadPath;
    myBootEntry->LoaderPartitionDiskRegion = BootFileRegion;
    myBootEntry->OsPartitionDiskRegion = OsLoadRegion;

    //
    // Fill in the base part of the NT boot entry.
    //
    ntBootEntry->Version = BOOT_ENTRY_VERSION;
    ntBootEntry->Length = requiredLength - FIELD_OFFSET(SP_BOOT_ENTRY, NtBootEntry);
    ntBootEntry->Attributes = BOOT_ENTRY_ATTRIBUTE_ACTIVE | BOOT_ENTRY_ATTRIBUTE_WINDOWS;
    ntBootEntry->FriendlyNameOffset = (ULONG)((PUCHAR)friendlyName - (PUCHAR)ntBootEntry);
    ntBootEntry->BootFilePathOffset = (ULONG)((PUCHAR)bootPath - (PUCHAR)ntBootEntry);
    ntBootEntry->OsOptionsLength = osOptionsLength;

    //
    // Fill in the base part of the WINDOWS_OS_OPTIONS, including the
    // OsLoadOptions.
    //
    strcpy(osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE);
    osOptions->Version = WINDOWS_OS_OPTIONS_VERSION;
    osOptions->Length = osOptionsLength;
    osOptions->OsLoadPathOffset = (ULONG)((PUCHAR)osLoadPath - (PUCHAR)osOptions);
    wcscpy(osOptions->OsLoadOptions, OsLoadOptions);

    //
    // Fill in the OS FILE_PATH.
    //
    osLoadPath->Version = FILE_PATH_VERSION;
    osLoadPath->Length = osLoadPathLength;
    osLoadPath->Type = FILE_PATH_TYPE_NT;
    p = (PWSTR)osLoadPath->FilePath;
    myBootEntry->OsPartitionNtName = p;
    wcscpy(p, osLoadDevice);
    p += wcslen(p) + 1;
    myBootEntry->OsDirectory = p;
    wcscpy(p, OsLoadPath);

    //
    // Copy the friendly name.
    //
    wcscpy(friendlyName, FriendlyName);

    //
    // Fill in the boot FILE_PATH.
    //
    bootPath->Version = FILE_PATH_VERSION;
    bootPath->Length = bootPathLength;
    bootPath->Type = FILE_PATH_TYPE_NT;
    p = (PWSTR)bootPath->FilePath;
    myBootEntry->LoaderPartitionNtName = p;
    wcscpy(p, bootFileDevice);
    p += wcslen(p) + 1;
    myBootEntry->LoaderFile = p;
    wcscpy(p, BootFilePath);

    //
    // Link the new boot entry into the list, after any removable media
    // entries that are at the front of the list.
    //

    previousBootEntry = NULL;
    nextBootEntry = SpBootEntries;
    while ((nextBootEntry != NULL) &&
           IS_BOOT_ENTRY_REMOVABLE_MEDIA(nextBootEntry)) {
        previousBootEntry = nextBootEntry;
        nextBootEntry = nextBootEntry->Next;
    }
    myBootEntry->Next = nextBootEntry;
    if (previousBootEntry == NULL) {
        SpBootEntries = myBootEntry;
    } else {
        previousBootEntry->Next = myBootEntry;
    }

    //
    // Free local memory.
    //
    SpMemFree(bootFileDevice);
    SpMemFree(osLoadDevice);

    return;

} // SpCreateBootEntry

#if defined(EFI_NVRAM_ENABLED)

BOOLEAN
SpBuildHarddiskNameTranslations (
    VOID
    )

/*++

Routine Description:

    Build a list of the translations of all \Device\HarddiskN\PartitionM
    symbolic links to \Device\HarddiskVolumeN device names.

Arguments:

    None.

Return Value:

    BOOLEAN - FALSE if an unexpected error occurred.

--*/

{
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING unicodeString;
    HANDLE deviceHandle;
    HANDLE diskHandle;
    HANDLE linkHandle;
    PUCHAR buffer1;
    PUCHAR buffer2;
    BOOLEAN restartScan;
    ULONG context1;
    ULONG context2;
    POBJECT_DIRECTORY_INFORMATION dirInfo1;
    POBJECT_DIRECTORY_INFORMATION dirInfo2;
    PWSTR linkName;
    PWSTR p;
    PHARDDISK_NAME_TRANSLATION translation;

    //
    // Allocate buffers for directory queries.
    //

#define BUFFER_SIZE 2048

    buffer1 = SpMemAlloc(BUFFER_SIZE);
    buffer2 = SpMemAlloc(BUFFER_SIZE);

    //
    // Open the \Device directory.
    //
    INIT_OBJA(&obja, &unicodeString, L"\\device");

    status = ZwOpenDirectoryObject(&deviceHandle, DIRECTORY_ALL_ACCESS, &obja);

    if (!NT_SUCCESS(status)) {
        ASSERT(FALSE);
        goto cleanup;
    }

    restartScan = TRUE;
    context1 = 0;

    do {

        //
        // Search the \Device directory for HarddiskN subdirectories.
        //
        status = ZwQueryDirectoryObject(
                    deviceHandle,
                    buffer1,
                    BUFFER_SIZE,
                    TRUE,
                    restartScan,
                    &context1,
                    NULL
                    );

        restartScan = FALSE;

        if (!NT_SUCCESS(status)) {
            if (status != STATUS_NO_MORE_ENTRIES) {
                ASSERT(FALSE);
                goto cleanup;
            }
            status = STATUS_SUCCESS;
            break;
        }

        //
        // We only care about directories with HarddiskN names.
        //
        dirInfo1 = (POBJECT_DIRECTORY_INFORMATION)buffer1;

        if ((dirInfo1->Name.Length < sizeof(L"harddisk")) ||
           (dirInfo1->TypeName.Length < (sizeof(L"Directory") - sizeof(WCHAR))) ||
           (_wcsnicmp(dirInfo1->TypeName.Buffer,L"Directory",wcslen(L"Directory")) != 0)) {
            continue;
        }

        SpStringToLower(dirInfo1->Name.Buffer);

        if (wcsncmp(dirInfo1->Name.Buffer, L"harddisk", wcslen(L"harddisk")) != 0) {
            continue;
        }

        p = dirInfo1->Name.Buffer + wcslen(L"Harddisk");
        if (*p == 0) {
            continue;
        }
        do {
            if ((*p < L'0') || (*p > L'9')) {
                break;
            }
            p++;
        } while (*p != 0);
        if (*p != 0) {
            continue;
        }

        //
        // We have the name of a \Device\HarddiskN directory. Open it and look
        // for PartitionM names.
        //
        InitializeObjectAttributes(
            &obja,
            &dirInfo1->Name,
            OBJ_CASE_INSENSITIVE,
            deviceHandle,
            NULL
            );
    
        status = ZwOpenDirectoryObject(&diskHandle, DIRECTORY_ALL_ACCESS, &obja);
    
        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        restartScan = TRUE;
        context2 = 0;
    
        do {
    
            //
            // Search the \Device\HarddiskN directory for PartitionM symbolic
            // links.
            //
            status = ZwQueryDirectoryObject(
                        diskHandle,
                        buffer2,
                        BUFFER_SIZE,
                        TRUE,
                        restartScan,
                        &context2,
                        NULL
                        );
    
            restartScan = FALSE;
    
            if (!NT_SUCCESS(status)) {
                if (status != STATUS_NO_MORE_ENTRIES) {
                    ASSERT(FALSE);
                    goto cleanup;
                }
                status = STATUS_SUCCESS;
                break;
            }
    
            //
            // We only care about symbolic links with PartitionN names.
            //
            dirInfo2 = (POBJECT_DIRECTORY_INFORMATION)buffer2;
    
            if ((dirInfo2->Name.Length < sizeof(L"partition")) ||
               (dirInfo2->TypeName.Length < (sizeof(L"SymbolicLink") - sizeof(WCHAR))) ||
               (_wcsnicmp(dirInfo2->TypeName.Buffer,L"SymbolicLink",wcslen(L"SymbolicLink")) != 0)) {
                continue;
            }
    
            SpStringToLower(dirInfo2->Name.Buffer);
    
            if (wcsncmp(dirInfo2->Name.Buffer, L"partition", wcslen(L"partition")) != 0) {
                continue;
            }
            p = dirInfo2->Name.Buffer + wcslen(L"partition");
            if ((*p == 0) || (*p == L'0')) { // skip partition0
                continue;
            }
            do {
                if ((*p < L'0') || (*p > L'9')) {
                    break;
                }
                p++;
            } while (*p != 0);
            if (*p != 0) {
                continue;
            }

            //
            // Open the \Device\HarddiskN\PartitionM symbolic link.
            //
            linkName = SpMemAlloc(sizeof(L"\\device") +
                                  dirInfo1->Name.Length +
                                  dirInfo2->Name.Length +
                                  sizeof(WCHAR));

            wcscpy(linkName, L"\\device");
            SpConcatenatePaths(linkName, dirInfo1->Name.Buffer);
            SpConcatenatePaths(linkName, dirInfo2->Name.Buffer);

            //
            // Query the link to get the link target.
            //
            status = SpQueryCanonicalName(linkName,
                            -1,
                            TemporaryBuffer,
                            sizeof(TemporaryBuffer));
            
            if (!NT_SUCCESS(status)) {
                ASSERT(FALSE);
                SpMemFree(linkName);
                goto cleanup;
            }

            //
            // Create a translation entry.
            //
            translation = SpMemAlloc(sizeof(HARDDISK_NAME_TRANSLATION));
            translation->Next = SpHarddiskNameTranslations;
            SpHarddiskNameTranslations = translation;

            translation->PartitionName = linkName;
            translation->VolumeName = SpDupStringW(TemporaryBuffer);

        } while (TRUE);

        ZwClose(diskHandle);

    } while (TRUE);

    ASSERT(status == STATUS_SUCCESS);

cleanup:

    SpMemFree(buffer1);
    SpMemFree(buffer2);

    return (NT_SUCCESS(status) ? TRUE : FALSE);

} // SpBuildHarddiskNameTranslations

NTSTATUS
SpGetBootEntryFilePath(
    IN  ULONG       Id,
    IN  PWSTR       LoaderPartitionNtName,
    IN  PWSTR       LoaderFile,
    OUT PWSTR*      FilePath
    )
/*++

Routine Description:

    Construct a filepath including the loaderpartition name, the directory path to the
    OS loader and a filename for the boot entry specified.
     
Arguments:

    Id                      the boot entry id
    LoaderPartitionNtName   pointer to the string representing the disk partition
    LoaderFile              pointer to the string representing the path to the EFI OS loader
    FilePath                upon completion, this points to the completed filepath to the 
                            boot entry file
    
Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    WCHAR*              p;
    ULONG               FilePathSize;
    WCHAR               idString[9];
    
    //
    // use the EFI variable name as the filename
    //
        
    swprintf( idString, L"Boot%04x", Id);

    //
    // determine the size of the final filepath
    //
    // Note: FilePathSize should be a little bigger than actually needed
    // since we are including the full LoadFile string.  Also, the '\'
    // characters may be extra.
    //
    
    FilePathSize = (wcslen(LoaderPartitionNtName) * sizeof(WCHAR)) +    // partition
                   sizeof(WCHAR) +                                      // '\'
                   (wcslen(LoaderFile) * sizeof(WCHAR)) +               // path
                   sizeof(WCHAR) +                                      // '\'
                   (wcslen(idString) * sizeof(WCHAR)) +                 // new filename
                   sizeof(WCHAR);                                       // null term.

    ASSERT(FilePathSize > 0);
    if (FilePathSize <= 0) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: invalid loader partition name and/or loader path\n"));
        return STATUS_INVALID_PARAMETER;
    }

    *FilePath = SpMemAlloc(FilePathSize);
    if (!*FilePath) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to allocate memory for FilePath\n"));
        return STATUS_NO_MEMORY;
    }

    wcscpy(*FilePath, LoaderPartitionNtName);
    
    SpConcatenatePaths(*FilePath, LoaderFile);
    
    // remove the os loader filename from the path
    
    p = wcsrchr(*FilePath, L'\\');
    if (p != NULL) {
        p++;
    } else {
        // we could get here, but it would be wierd.
        p = *FilePath;
        wcscat(p, L"\\");
    }

    //
    // insert the filename
    //
    wcscpy(p, idString);

    ASSERT((wcslen(*FilePath) + 1) * sizeof(WCHAR) <= FilePathSize);

    return STATUS_SUCCESS;
}


NTSTATUS
SpGetAndWriteBootEntry(
    IN ULONG    Id,
    IN PWSTR    BootEntryPath
    )
/*++

Routine Description:

    Get the boot entry from NVRAM for the given boot entry Id.  Construct a filename
    of the form BootXXXX, where XXXX = id.  Put the file in the same directory as the
    EFI OS loader.  The directory is determined from the LoaderFile string. 
     
Arguments:

    bootEntry               pointer to a SP_BOOT_ENTRY structure of the entry to write
    BootEntryPath           pinter to the ARC/NT style reference to the boot entry filename
    
Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    WCHAR               idString[9];
    HANDLE              hfile;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     iostatus;
    UCHAR*              bootVar;
    ULONG               bootVarSize;
    UNICODE_STRING      uFilePath;
    UINT64              BootNumber;
    UINT64              BootSize;
    GUID                EfiBootVariablesGuid = EFI_GLOBAL_VARIABLE;

    hfile = NULL;

    //
    // Retrieve the NVRAM entry for the Id specified
    //
        
    swprintf( idString, L"Boot%04x", Id);
    
    bootVarSize = 0;

    status = HalGetEnvironmentVariableEx(idString,
                                        &EfiBootVariablesGuid,
                                        NULL,
                                        &bootVarSize,
                                        NULL);

    if (status != STATUS_BUFFER_TOO_SMALL) {
        
        ASSERT(FALSE);
        
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to get size for boot entry buffer.\n"));
    
        goto Done;

    } else {
        
        bootVar = SpMemAlloc(bootVarSize);
        if (!bootVar) {
            
            status = STATUS_NO_MEMORY;

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to allocate boot entry buffer.\n"));
            
            goto Done;
        }
         
        status = HalGetEnvironmentVariableEx(idString,
                                                &EfiBootVariablesGuid,
                                                bootVar,
                                                &bootVarSize,
                                                NULL);
        
        if (status != STATUS_SUCCESS) {

            ASSERT(FALSE);
            
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to get boot entry.\n"));
            
            goto Done;
        }
    }

    //
    // open the file 
    //

    INIT_OBJA(&oa, &uFilePath, BootEntryPath);

    status = ZwCreateFile(&hfile,
                            GENERIC_WRITE,
                            &oa,
                            &iostatus,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            0,
                            FILE_OVERWRITE_IF,
                            FILE_SYNCHRONOUS_IO_NONALERT,
                            NULL,
                            0
                            );
    if ( ! NT_SUCCESS(status) ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to create boot entry recovery file.\n"));
        
        goto Done;
    }

    //
    // Write the bits to disk using the format required
    // by base/efiutil/efinvram/savrstor.c
    //
    // [BootNumber][BootSize][BootEntry (of BootSize)]
    //

    //
    // build the header info for the boot entry block
    //

    // [header] include the boot id
    BootNumber = Id;
    status = ZwWriteFile( hfile,
                          NULL,
                          NULL,
                          NULL,
                          &iostatus,
                          &BootNumber,
                          sizeof(BootNumber),
                          NULL,
                          NULL
                          );
    if ( ! NT_SUCCESS(status) ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed writing boot number to boot entry recovery file.\n"));
        
        goto Done;
    }

    // [header] include the boot size
    BootSize = bootVarSize;
    status = ZwWriteFile( hfile,
                          NULL,
                          NULL,
                          NULL,
                          &iostatus,
                          &BootSize,
                          sizeof(BootSize),
                          NULL,
                          NULL
                          );
    if ( ! NT_SUCCESS(status) ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed writing boot entry size to boot entry recovery file.\n"));

        goto Done;
    }

    // boot entry bits
    status = ZwWriteFile( hfile,
                            NULL,
                            NULL,
                            NULL,
                            &iostatus,
                            bootVar,
                            bootVarSize,
                            NULL,
                            NULL
                            );
    if ( ! NT_SUCCESS(status) ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed writing boot entry to boot entry recovery file.\n"));
        
        goto Done;
    }

Done:

    //
    // We are done
    //

    if (bootVar) {
        SpMemFree(bootVar);
    }
    if (hfile) {
        ZwClose( hfile );
    }

    return status;

}


BOOLEAN
SpFlushEfiBootEntries (
    VOID
    )

/*++

Routine Description:

    Write boot entry changes back to NVRAM.

Arguments:

    None.

Return Value:

    BOOLEAN - FALSE if an unexpected error occurred.

--*/

{
    PSP_BOOT_ENTRY bootEntry;
    ULONG count;
    PULONG order;
    ULONG i;
    NTSTATUS status;
    PWSTR   BootEntryFilePath;

    ASSERT(SpIsEfi());

    //
    // Walk the list of boot entries, looking for entries that have been
    // deleted. Delete these entries from NVRAM. Do not delete entries that
    // are both new AND deleted; these are entries that have never been
    // written to NVRAM.
    //
    for (bootEntry = SpBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {

        if (IS_BOOT_ENTRY_DELETED(bootEntry) &&
            !IS_BOOT_ENTRY_NEW(bootEntry)) {

            ASSERT(IS_BOOT_ENTRY_WINDOWS(bootEntry));

            //
            // Delete this boot entry.
            //
            status = ZwDeleteBootEntry(bootEntry->NtBootEntry.Id);
            if (!NT_SUCCESS(status)) {
                return FALSE;
            }
        } 
    }

    //
    // Walk the list of boot entries, looking for entries that have are new.
    // Add these entries to NVRAM. Do not write entries that are both new AND
    // deleted.
    //
    for (bootEntry = SpBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {

        if (IS_BOOT_ENTRY_NEW(bootEntry) &&
            !IS_BOOT_ENTRY_DELETED(bootEntry)) {

            ASSERT(IS_BOOT_ENTRY_WINDOWS(bootEntry));

            //
            // Add this boot entry.
            //
            status = ZwAddBootEntry(&bootEntry->NtBootEntry, &bootEntry->NtBootEntry.Id);
            if (!NT_SUCCESS(status)) {
                return FALSE;
            }

            //
            // get the location we are going to store a copy of the NVRAM boot entry 
            //
            BootEntryFilePath = NULL;

            status = SpGetBootEntryFilePath(bootEntry->NtBootEntry.Id,
                                            bootEntry->LoaderPartitionNtName,
                                            bootEntry->LoaderFile,
                                            &BootEntryFilePath
                                            );
            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed getting boot entry filepath.\n"));
            } else {

                ASSERT(BootEntryFilePath);

                //
                // Fetch the bits from the newly created NVRAM entry and 
                // write them as a file in the the EFI load path 
                //
                status = SpGetAndWriteBootEntry(bootEntry->NtBootEntry.Id,
                                                BootEntryFilePath
                                                );
                if (!NT_SUCCESS(status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed boot entry recovery file.\n"));
                }

                //
                // We are done with the boot entry filepath
                //
                SpMemFree(BootEntryFilePath);
            }

            //
            // Remember the ID of the new boot entry as the entry to be booted
            // immediately on the next boot.
            //
            SpBootOptions->NextBootEntryId = bootEntry->NtBootEntry.Id;
        } 
    }

    //
    // Build the new boot order list. Insert all boot entries with
    // BE_STATUS_ORDERED into the list. (Don't insert deleted entries.)
    //
    count = 0;
    bootEntry = SpBootEntries;
    while (bootEntry != NULL) {
        if (IS_BOOT_ENTRY_ORDERED(bootEntry) && !IS_BOOT_ENTRY_DELETED(bootEntry)) {
            count++;
        }
        bootEntry = bootEntry->Next;
    }
    order = SpMemAlloc(count * sizeof(ULONG));
    count = 0;
    bootEntry = SpBootEntries;
    while (bootEntry != NULL) {
        if (IS_BOOT_ENTRY_ORDERED(bootEntry) && !IS_BOOT_ENTRY_DELETED(bootEntry)) {
            order[count++] = bootEntry->NtBootEntry.Id;
        }
        bootEntry = bootEntry->Next;
    }

    //
    // Write the new boot entry order list to NVRAM.
    //
    status = ZwSetBootEntryOrder(order, count);
    SpMemFree(order);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    //
    // Write the new timeout value to NVRAM.
    //
    // Set the boot entry we added to be booted automatically on
    // the next boot, without waiting for a timeout at the boot menu.
    //
    // NB: SpCreateBootEntry() sets SpBootOptions->NextBootEntryId.
    //
    SpBootOptions->Timeout = Timeout;
    status = ZwSetBootOptions(
                SpBootOptions,
                BOOT_OPTIONS_FIELD_TIMEOUT | BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID
                );
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    return TRUE;

} // SpFlushEfiBootEntries

BOOLEAN
SpReadAndConvertEfiBootEntries (
    VOID
    )

/*++

Routine Description:

    Read boot entries from EFI NVRAM and convert them into our internal format.

Arguments:

    None.

Return Value:

    BOOLEAN - FALSE if an unexpected error occurred.

--*/

{
    NTSTATUS status;
    ULONG length;
    PBOOT_ENTRY_LIST bootEntries;
    PBOOT_ENTRY_LIST bootEntryList;
    PBOOT_ENTRY bootEntry;
    PBOOT_ENTRY bootEntryCopy;
    PSP_BOOT_ENTRY myBootEntry;
    PSP_BOOT_ENTRY previousEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    LONG i;
    PULONG order;
    ULONG count;

    //
    // SpStartSetup() does not expect our caller, SpInitBootVars(), to fail.
    // So textmode is going to continue even if we have failures here.
    // Therefore we need to leave here in a consistent state. That means
    // that we MUST allocate a buffer for SpBootOptions, even if we can't
    // get the real information from the kernel.
    //

    //
    // Get the global system boot options.
    //
    length = 0;
    status = ZwQueryBootOptions(NULL, &length);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        ASSERT(FALSE);
        if (status == STATUS_SUCCESS) {
            status = STATUS_UNSUCCESSFUL;
        }
    } else {
        SpBootOptions = SpMemAlloc(length);
        status = ZwQueryBootOptions(SpBootOptions, &length);
        if (status != STATUS_SUCCESS) {
            ASSERT(FALSE);
        }
    }

    if (status != STATUS_SUCCESS) {

        //
        // An unexpected error occurred reading the boot options. Create
        // a fake boot options structure.
        //

        if (SpBootOptions != NULL) {
            SpMemFree(SpBootOptions);
        }
        length = FIELD_OFFSET(BOOT_OPTIONS,HeadlessRedirection) + sizeof(WCHAR);
        SpBootOptions = SpMemAlloc(length);
        RtlZeroMemory(SpBootOptions, length);
        SpBootOptions->Version = BOOT_OPTIONS_VERSION;
        SpBootOptions->Length = length;
    }

    //
    // Get the system boot order list.
    //
    count = 0;
    status = ZwQueryBootEntryOrder(NULL, &count);

    if (status != STATUS_BUFFER_TOO_SMALL) {

        if (status == STATUS_SUCCESS) {

            //
            // There are no entries in the boot order list. Strange but
            // possible.
            //
            count = 0;

        } else {

            //
            // An unexpected error occurred. Just pretend that the boot
            // entry order list is empty.
            //
            ASSERT(FALSE);
            count = 0;
        }
    }

    if (count != 0) {
        order = SpMemAlloc(count * sizeof(ULONG));
        status = ZwQueryBootEntryOrder(order, &count);
        if (status != STATUS_SUCCESS) {

            //
            // An unexpected error occurred. Just pretend that the boot
            // entry order list is empty.
            //
            ASSERT(FALSE);
            count = 0;
        }
    }

    //
    // Get all existing boot entries.
    //
    length = 0;
    status = ZwEnumerateBootEntries(NULL, &length);

    if (status != STATUS_BUFFER_TOO_SMALL) {

        if (status == STATUS_SUCCESS) {

            //
            // Somehow there are no boot entries in NVRAM. Handle this
            // by just creating an empty list.
            //

            length = 0;

        } else {

            //
            // An unexpected error occurred. Just pretend that no boot
            // entries exist.
            //
            ASSERT(FALSE);
            length = 0;
        }
    }

    if (length == 0) {

        ASSERT(SpBootEntries == NULL);

    } else {
    
        bootEntries = SpMemAlloc(length);
        status = ZwEnumerateBootEntries(bootEntries, &length);
        if (status != STATUS_SUCCESS) {
            ASSERT(FALSE);
            return FALSE;
        }
    
        //
        // Convert the boot entries into our internal representation.
        //
        bootEntryList = bootEntries;
        previousEntry = NULL;
    
        while (TRUE) {
    
            bootEntry = &bootEntryList->BootEntry;
    
            //
            // Calculate the length of our internal structure. This includes
            // the base part of SP_BOOT_ENTRY plus the NT BOOT_ENTRY.
            //
            length = FIELD_OFFSET(SP_BOOT_ENTRY, NtBootEntry) + bootEntry->Length;
            myBootEntry = SpMemAlloc(length);
            ASSERT(myBootEntry != NULL);
    
            RtlZeroMemory(myBootEntry, length);
    
            //
            // Copy the NT BOOT_ENTRY into the allocated buffer.
            //
            bootEntryCopy = &myBootEntry->NtBootEntry;
            memcpy(bootEntryCopy, bootEntry, bootEntry->Length);
    
            //
            // Fill in the base part of the structure.
            //
            myBootEntry->Next = NULL;
            myBootEntry->AllocationEnd = (PUCHAR)myBootEntry + length - 1;
            myBootEntry->FriendlyName = ADD_OFFSET(bootEntryCopy, FriendlyNameOffset);
            myBootEntry->FriendlyNameLength = (wcslen(myBootEntry->FriendlyName) + 1) * sizeof(WCHAR);
            myBootEntry->LoaderPath = ADD_OFFSET(bootEntryCopy, BootFilePathOffset);
    
            //
            // If this is an NT boot entry, translate the file paths.
            //
            osOptions = (PWINDOWS_OS_OPTIONS)bootEntryCopy->OsOptions;
    
            if (IS_BOOT_ENTRY_WINDOWS(myBootEntry)) {
    
                PSP_BOOT_ENTRY bootEntry2;
    
                myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
                myBootEntry->OsLoadOptionsLength = (wcslen(myBootEntry->OsLoadOptions) + 1) * sizeof(WCHAR);
                myBootEntry->OsPath = ADD_OFFSET(osOptions, OsLoadPathOffset);
    
                //
                // Translate the OS FILE_PATH and the boot FILE_PATH. Note that
                // the translation can fail when the target device is not present.
                //
                SpTranslateFilePathToRegion(
                    myBootEntry->OsPath,
                    &myBootEntry->OsPartitionDiskRegion,
                    &myBootEntry->OsPartitionNtName,
                    &myBootEntry->OsDirectory
                    );
                SpTranslateFilePathToRegion(
                    myBootEntry->LoaderPath,
                    &myBootEntry->LoaderPartitionDiskRegion,
                    &myBootEntry->LoaderPartitionNtName,
                    &myBootEntry->LoaderFile
                    );    
            }
    
            //
            // Link the new entry into the list.
            //
            if (previousEntry != NULL) {
                previousEntry->Next = myBootEntry;
            } else {
                SpBootEntries = myBootEntry;
            }
            previousEntry = myBootEntry;
    
            //
            // Move to the next entry in the enumeration list, if any.
            //
            if (bootEntryList->NextEntryOffset == 0) {
                break;
            }
            bootEntryList = ADD_OFFSET(bootEntryList, NextEntryOffset);
        }
    
        //
        // Free the enumeration buffer.
        //
        SpMemFree(bootEntries);
    }

    //
    // Boot entries are returned in an unspecified order. They are currently
    // in the SpBootEntries list in the order in which they were returned.
    // Sort the boot entry list based on the boot order. Do this by walking
    // the boot order array backwards, reinserting the entry corresponding to
    // each element of the array at the head of the list.
    //

    for (i = (LONG)count - 1; i >= 0; i--) {

        for (previousEntry = NULL, myBootEntry = SpBootEntries;
             myBootEntry != NULL;
             previousEntry = myBootEntry, myBootEntry = myBootEntry->Next) {

            if (myBootEntry->NtBootEntry.Id == order[i] ) {

                //
                // We found the boot entry with this ID. If it's not already
                // at the front of the list, move it there.
                //

                myBootEntry->Status |= BE_STATUS_ORDERED;

                if (previousEntry != NULL) {
                    previousEntry->Next = myBootEntry->Next;
                    myBootEntry->Next = SpBootEntries;
                    SpBootEntries = myBootEntry;
                } else {
                    ASSERT(SpBootEntries == myBootEntry);
                }

                break;
            }
        }
    }

    if (count != 0) {
        SpMemFree(order);
    }

    return TRUE;

} // SpReadAndConvertEfiBootEntries

ULONG
SpSafeWcslen (
    IN PWSTR String,
    IN PWSTR Max
    )

/*++

Routine Description:

    Calculate the length of a null-terminated string in a safe manner,
    avoiding walking off the end of the buffer if the string is not
    properly terminated.

Arguments:

    String - Address of string.

    Max - Address of first byte beyond the maximum legal address for the
    string. In other words, the address of the first byte past the end
    of the buffer in which the string is contained.

Return Value:

    ULONG - Length of the string, in characters, not including the null
        terminator. If the string is not terminated before the end of
        the buffer, 0xffffffff is returned.

--*/

{
    PWSTR p = String;

    //
    // Walk through the string, looking for either the end of the buffer
    // or a null terminator.
    //
    while ((p < Max) && (*p != 0)) {
        p++;
    }

    //
    // If we didn't reach the end of the buffer, then we found a null
    // terminator. Return the length of the string, in characters.
    //
    if (p < Max) {
        return (ULONG)(p - String);
    }

    //
    // The string is not properly terminated. Return an error indicator.
    //
    return 0xffffffff;

} // SpSafeWcslen

VOID
SpTranslateFilePathToRegion (
    IN PFILE_PATH FilePath,
    OUT PDISK_REGION *DiskRegion,
    OUT PWSTR *PartitionNtName,
    OUT PWSTR *PartitionRelativePath
    )

/*++

Routine Description:

    Translate a FILE_PATH to a pointer to a disk region and the path
    relative to the region.

Arguments:

    FilePath - Address of FILE_PATH.

    DiskRegion - Returns the address of the disk region described by
        FilePath. NULL is returned if the matching disk region cannot
        be found.

    PartitionNtName - Returns the NT name associated with the disk region.
        NULL is returned if the file path cannot be translated into NT
        format.

    PartitionRelativePath - Returns the volume-relative path of the file
        or directory described by the FilePath. NULL is returned if the
        file path cannot be translated into NT format.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    ULONG length;
    PFILE_PATH ntFilePath;
    PWSTR p;
    PWSTR q;
    PHARDDISK_NAME_TRANSLATION translation;

    //
    // Translate the file path into NT format. (It is probably in EFI format.)
    //
    length = 0;
    status = ZwTranslateFilePath(
                FilePath,
                FILE_PATH_TYPE_NT,
                NULL,
                &length
                );
    if (status != STATUS_BUFFER_TOO_SMALL) {
        *PartitionNtName = NULL;
        *DiskRegion = NULL;
        *PartitionRelativePath = NULL;
        return;
    }
    ntFilePath = SpMemAlloc(length);
    status = ZwTranslateFilePath(
                FilePath,
                FILE_PATH_TYPE_NT,
                ntFilePath,
                &length
                );
    if (status != STATUS_SUCCESS) {
        ASSERT(FALSE);
        *PartitionNtName = NULL;
        *DiskRegion = NULL;
        *PartitionRelativePath = NULL;
        SpMemFree(ntFilePath);
        return;
    }

    //
    // NtTranslateFilePath returns a name of the form \Device\HarddiskVolumeN.
    // We need to have a name of the form \Device\HardiskN\PartitionM. (This is
    // because all of the ARC<->NT translations use the latter form.) Use the
    // translation list built by SpBuildHarddiskNameTranslations to do the
    // translation.
    //
    // If the returned name doesn't include "HarddiskVolume", or if no
    // translation is found, use the returned name and hope for the best.
    //
    p = (PWSTR)ntFilePath->FilePath;
    q = p;

    if (wcsstr(q, L"Volume") != NULL){
    
        for ( translation = SpHarddiskNameTranslations;
              translation != NULL;
              translation = translation->Next ) {
            if (_wcsicmp(translation->VolumeName, q) == 0) {
                break;
            }
        }
        if (translation != NULL) {
            q = translation->PartitionName;
        }
    }

    //
    // We now have the file path in NT format. Get the disk region that
    // corresponds to the NT device name. Return the obtained information.
    //
    *PartitionNtName = SpDupStringW(q);
    *DiskRegion = SpRegionFromNtName(q, PartitionOrdinalCurrent);
    p += wcslen(p) + 1;
    *PartitionRelativePath = SpDupStringW(p);

    //
    // Free local memory.
    //
    SpMemFree(ntFilePath);

    return;
}

#endif // defined(EFI_NVRAM_ENABLED)

NTSTATUS
SpAddNTInstallToBootList(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PWSTR        OsLoadOptions,      OPTIONAL
    IN PWSTR        LoadIdentifier      OPTIONAL
    )
/*++

Routine Description:

    This routine takes the core components of a boot set and passes
    them on to SpAddUserDefinedInstallationToBootList, which does
    the real work of constructing a boot set.  After the new boot
    set is created, the boot vars are flushed - the exact implementation
    of the flush depends on the architecture.  On amd64/x86, we'll
    have a new boot.ini after this routine is done.               
     
Arguments:

    SifHandle       - pointer to the setup sif file

Return Value:

    STATUS_SUCCESS  if the NT install was successfully added to the
                    boot list
                        
    if there was an error, the status is returned

--*/
{
    NTSTATUS    status;

    //
    // create the new user defined boot set
    //
    status = SpAddUserDefinedInstallationToBootList(SifHandle,
                                                   SystemPartitionRegion,
                                                   SystemPartitionDirectory,
                                                   NtPartitionRegion,
                                                   Sysroot,
                                                   OsLoadOptions,
                                                   LoadIdentifier
                                                  );
    if (! NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SpExportBootEntries: failed while installing new boot set: Status = %lx\n",
                   status
                   ));
        return status;
    }

    //
    // write the new boot set out
    //
    if (SpFlushBootVars() == FALSE) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SpAddDiscoveredNTInstallToBootList: failed flushing boot vars\n"
                   ));
    
        status = STATUS_UNSUCCESSFUL;

    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
SpAddUserDefinedInstallationToBootList(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PWSTR        OsLoadOptions,      OPTIONAL
    IN PWSTR        LoadIdentifier      OPTIONAL
    )
/*++

Routine Description:

    This routine is based on SpAddInstallationToBootList, with the major
    differences being: 
    
        there is no processing of the load options
        the user can specifiy the loadIdentifier    
    
Return Value:

    STATUS_SUCCESS  if the NT install was successfully added to the
                    boot list
                        
    if there was an error, the status is returned

--*/
{
    PWSTR                   BootVars[MAXBOOTVARS];
    PWSTR                   SystemPartitionArcName;
    PWSTR                   TargetPartitionArcName;
    PWSTR                   tmp;
    PWSTR                   tmp2;
    PWSTR                   locOsLoadOptions;
    PWSTR                   locLoadIdentifier;
    ULONG                   Signature;
    ENUMARCPATHTYPE         ArcPathType;
    NTSTATUS                status;

    status = STATUS_SUCCESS;

    ArcPathType = PrimaryArcPath;

    tmp2 = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);

    if (!SpIsEfi()) {
    
        //
        // Get an ARC name for the system partition.
        //
        if (SystemPartitionRegion != NULL) {
            
            SpArcNameFromRegion(
                SystemPartitionRegion,
                tmp2,
                sizeof(TemporaryBuffer)/2,
                PartitionOrdinalOnDisk,
                PrimaryArcPath
                );

            SystemPartitionArcName = SpDupStringW(tmp2);
        } else {
            SystemPartitionArcName = NULL;
        }
    
        //
        // Get an ARC name for the target partition.
        //
    
        //
        // If the partition is on a SCSI disk that has more than 1024 cylinders
        // and the partition has sectors located on cylinders beyond cylinder
        // 1024, the get the arc name in the secondary format. See also
        // spcopy.c!SpCreateNtbootddSys().
        //
        if(
            !SpIsArc() &&
#if defined(REMOTE_BOOT)
            !RemoteBootSetup &&
#endif // defined(REMOTE_BOOT)
    
#if defined(_AMD64_) || defined(_X86_)
            !SpUseBIOSToBoot(NtPartitionRegion, NULL, SifHandle) &&
#endif // defined(_AMD64_) || defined(_X86_)
            (HardDisks[NtPartitionRegion->DiskNumber].ScsiMiniportShortname[0]) ) {
    
            ArcPathType = SecondaryArcPath;
        } else {
            ArcPathType = PrimaryArcPath;
        }
    
        SpArcNameFromRegion(
            NtPartitionRegion,
            tmp2,
            sizeof(TemporaryBuffer)/2,
            PartitionOrdinalOnDisk,
            ArcPathType
            );
    
        TargetPartitionArcName = SpDupStringW(tmp2);
    }
    
    //
    // Tweak the load identifier if necessary
    //
    if (LoadIdentifier) {
        
        if(!SpIsArc()) {
            //
            // Need quotation marks around the description on amd64/x86.
            //
            locLoadIdentifier = SpMemAlloc((wcslen(LoadIdentifier)+3)*sizeof(WCHAR));
            locLoadIdentifier[0] = L'\"';
            wcscpy(locLoadIdentifier+1,LoadIdentifier);
            wcscat(locLoadIdentifier,L"\"");
        } else {
            locLoadIdentifier = SpDupStringW(LoadIdentifier);
        }
    
    } else {
        locLoadIdentifier = SpDupStringW(L"");
    }
    ASSERT(locLoadIdentifier);
    
    //
    // Tweak the load options if necessary
    //
    if (OsLoadOptions) {
        locOsLoadOptions = SpDupStringW(OsLoadOptions);
    } else {
        locOsLoadOptions = SpDupStringW(L"");
    }
    ASSERT(locOsLoadOptions);

    //
    // Create a new internal-format boot entry.
    //
    tmp = TemporaryBuffer;
    wcscpy(tmp,SystemPartitionDirectory);
    SpConcatenatePaths(
        tmp,
#if defined(_AMD64_) || defined(_X86_)
        SpIsArc() ? L"arcldr.exe" : L"ntldr"
#elif defined(_IA64_)
        L"ia64ldr.efi"
#else
        L"osloader.exe"
#endif // defined(_AMD64_) || defined(_X86_)
        );
    tmp = SpDupStringW(tmp);

    SpCreateBootEntry(
        BE_STATUS_NEW,
        SystemPartitionRegion,
        tmp,
        NtPartitionRegion,
        Sysroot,
        locOsLoadOptions,
        locLoadIdentifier
        );

    SpMemFree(tmp);

    //
    // If not on an EFI machine, add a new ARC-style boot set.
    //
    if (!SpIsEfi()) {
    
        BootVars[OSLOADOPTIONS]     = locOsLoadOptions;
        BootVars[LOADIDENTIFIER]    = locLoadIdentifier;
    
        //
        // OSLOADER is the system partition path + the system partition directory +
        //          osloader.exe. (ntldr on amd64 or x86 machines).
        //
        if (SystemPartitionRegion != NULL) {
            tmp = TemporaryBuffer;
            wcscpy(tmp,SystemPartitionArcName);
            SpConcatenatePaths(tmp,SystemPartitionDirectory);
            SpConcatenatePaths(
                tmp,
#if defined(_AMD64_) || defined(_X86_)
                (SpIsArc() ? L"arcldr.exe" : L"ntldr")
#elif defined(_IA64_)
                L"ia64ldr.efi"
#else
                L"osloader.exe"
#endif // defined(_AMD64_) || defined(_X86_)
                );
    
            BootVars[OSLOADER] = SpDupStringW(tmp);
        } else {
            BootVars[OSLOADER] = SpDupStringW(L"");
        }
    
        //
        // OSLOADPARTITION is the ARC name of the windows nt partition.
        //
        BootVars[OSLOADPARTITION] = TargetPartitionArcName;
    
        //
        // OSLOADFILENAME is sysroot.
        //
        BootVars[OSLOADFILENAME] = Sysroot;
    
        //
        // SYSTEMPARTITION is the ARC name of the system partition.
        //
        if (SystemPartitionRegion != NULL) {
            BootVars[SYSTEMPARTITION] = SystemPartitionArcName;
        } else {
            BootVars[SYSTEMPARTITION] = L"";
        }
    
        //
        // get the disk signature
        //
        if ((NtPartitionRegion->DiskNumber != 0xffffffff) && HardDisks[NtPartitionRegion->DiskNumber].Signature) {
            Signature = HardDisks[NtPartitionRegion->DiskNumber].Signature;
        } else {
            Signature = 0;
        }
    
        //
        // Add the boot set and make it the default.
        //
        SpAddBootSet(BootVars, TRUE, Signature);

        SpMemFree(BootVars[OSLOADER]);
    }

    //
    // Free memory allocated.
    //
    if (locLoadIdentifier) {
        SpMemFree(locLoadIdentifier);
    }

    if (!SpIsEfi()) {
        if (SystemPartitionArcName) {
            SpMemFree(SystemPartitionArcName);
        }
        if (TargetPartitionArcName) {
            SpMemFree(TargetPartitionArcName);
        }
    }

    return status;
}

NTSTATUS
SpExportBootEntries(
    IN OUT PLIST_ENTRY      BootEntries,
       OUT PULONG           BootEntryCnt
    )
/*++

Routine Description:

    This routine compiles a safely exportable string represenation
    of the boot options.
    
Arguments:

    BootEntries     - returns pointing to the head of the linked list
                      containing the exported boot entries
    BootEntriesCnt  - returns with the # of boot entries exported                       
    
Return Value:

    STATUS_SUCCESS  if the boot entries were successfully exported
    
    if there was an error, the status is returned

--*/
{
    PSP_BOOT_ENTRY          bootEntry;
    PSP_EXPORTED_BOOT_ENTRY ebootEntry;

    *BootEntryCnt = 0;

    //
    // make sure we were given the list head
    //
    ASSERT(BootEntries);
    if (!BootEntries) {
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_ERROR_LEVEL, 
           "SpExportBootEntries: pointer to boot entry list is NULL\n"
           ));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // make sure the list is empty
    //
    ASSERT(IsListEmpty(BootEntries));
    if (! IsListEmpty(BootEntries)) {
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_ERROR_LEVEL, 
           "SpExportBootEntries: incoming boot entry list should be empty\n"
           ));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // for each boot entry, collect a subset of information and compile
    // it in an exportable (safe) string form
    //
    for (bootEntry = SpBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {

        //
        // allocate the node...
        //
        ebootEntry = SpMemAlloc(sizeof(SP_EXPORTED_BOOT_ENTRY));
        ASSERT(ebootEntry);
        if (ebootEntry == NULL) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                       DPFLTR_ERROR_LEVEL, 
                       "SpExportBootEntries: failed allocationg new exported boot entry\n"
                       ));
            return STATUS_NO_MEMORY;
        }
        RtlZeroMemory( ebootEntry, sizeof(SP_EXPORTED_BOOT_ENTRY) );

        //
        // map selected fields from SpBootEntries to our export
        //
        ebootEntry->LoadIdentifier  = SpDupStringW(bootEntry->FriendlyName);
        ebootEntry->OsLoadOptions   = SpDupStringW(bootEntry->OsLoadOptions);
        ebootEntry->DriverLetter    = bootEntry->OsPartitionDiskRegion->DriveLetter;
        ebootEntry->OsDirectory     = SpDupStringW(bootEntry->OsDirectory);

        InsertTailList( BootEntries, &ebootEntry->ListEntry );
        
        ++*BootEntryCnt;
    }

    if (*BootEntryCnt == 0) {
        ASSERT(IsListEmpty(BootEntries));
        if(! IsListEmpty(BootEntries)) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                       DPFLTR_ERROR_LEVEL, 
                       "SpExportBootEntries: exported boot entry list should be empty\n"
                       ));
            return STATUS_UNSUCCESSFUL;
        }
    } else {
        ASSERT(! IsListEmpty(BootEntries));
        if(IsListEmpty(BootEntries)) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                       DPFLTR_ERROR_LEVEL, 
                       "SpExportBootEntries: exported boot entry list should NOT be empty\n"
                       ));
            return STATUS_UNSUCCESSFUL;
        }
    }

    return STATUS_SUCCESS;

}

NTSTATUS
SpFreeExportedBootEntries(
    IN PLIST_ENTRY      BootEntries,
    IN ULONG            BootEntryCnt
    )
/*++

Routine Description:

    A convenience routine to free the exported boot entries
    
Arguments:

    BootEntries     - points to the head of the linked list
                      containing the exported boot entries
    BootEntriesCnt  - the # of boot entries exported                       
    
Return Value:

    STATUS_SUCCESS  if the exported boot entries were successfully freed
    
    if there was an error, the status is returned
                                                                        
--*/
{
    PSP_EXPORTED_BOOT_ENTRY bootEntry;
    PLIST_ENTRY             listEntry;
    ULONG                   cnt;
    NTSTATUS                status;

    cnt = 0;

    while ( !IsListEmpty(BootEntries) ) {

        listEntry  = RemoveHeadList(BootEntries);
        bootEntry = CONTAINING_RECORD(listEntry,
                                       SP_EXPORTED_BOOT_ENTRY,
                                       ListEntry
                                       );

        if (bootEntry->LoadIdentifier) {
            SpMemFree(bootEntry->LoadIdentifier);
        }
        if (bootEntry->OsLoadOptions) {
            SpMemFree(bootEntry->OsLoadOptions);
        }
        if (bootEntry->OsDirectory) {
            SpMemFree(bootEntry->OsDirectory);
        }
        
        SpMemFree(bootEntry);
        
        cnt++;
    }
    
    ASSERT(cnt == BootEntryCnt);

    if (cnt == BootEntryCnt) {
        status = STATUS_SUCCESS;
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SpFreeExportedBootEntries: incorrect # of boot entries freed\n"
                   ));
        status = STATUS_UNSUCCESSFUL;
    }

    return status;

}

NTSTATUS
SpSetRedirectSwitchMode(
    IN RedirectSwitchesModeEnum     mode,
    IN PCHAR                        redirectSwitch,
    IN PCHAR                        redirectBaudRateSwitch
    )
/*++

Routine Description:

    This routine is used to manage how the redirect switches
    are set in the boot configuration (amd64/x86 ==> boot.ini)
    
    Depending on the mode chosen, the user may specify
    which parameters they want to set or if they just 
    want the default (legacy) behavior.
    
    NOTE:
                              
    The user specified switches are copied into globals for
    use by the Flush routines.                       
    
    The global, RedirectSwitchesMode, is set and remains set
    after this routine returns.  All subsequent FlushBootVars
    will use this mode.
                           
Arguments:

    mode                    - how we affect the redirect switches
    redirectSwitch          - the user defined redirect parameter
    redirectBaudRateSwitch  - the user defined baudrate paramtere
    
Return Value:

    STATUS_SUCCESS  if the redirect values were successfully set
    
    if there was an error, the status is returned

--*/
{
    NTSTATUS    status;

    //
    // set the mode and user defined parameters
    //
    RedirectSwitchesMode = mode;

    //
    // null the redirect switches by default
    //
    RedirectSwitches.port[0] = '\0';  
    RedirectSwitches.baudrate[0] = '\0';  
    
    //
    // get copies of the user defined switches if specified
    //
    if (redirectSwitch) {
    
        strncpy(RedirectSwitches.port,
                redirectSwitch, 
                MAXSIZE_REDIRECT_SWITCH);
    
    }

    if (redirectBaudRateSwitch) {
    
        strncpy(RedirectSwitches.baudrate,
                redirectBaudRateSwitch, 
                MAXSIZE_REDIRECT_SWITCH);
    
    }
    
    //
    // update the boot options using the specified mode
    //
    if (SpFlushBootVars() == FALSE) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SpAddDiscoveredNTInstallToBootList: failed flushing boot vars\n"
                   ));
    
        status = STATUS_UNSUCCESSFUL;

    } else {

        status = STATUS_SUCCESS;
    
    }

    return status;

}

NTSTATUS
SpSetDefaultBootEntry(
    ULONG           BootEntryNumber
    )
/*++

Routine Description:

    Set the Default boot entry to the user specified boot entry.
    
Arguments:

    BootEntryNumber - the position of the boot entry in the list
                      which is intended to become the default.
                      This number should be >= 1.
    
Return Value:

    STATUS_SUCCESS      if the default was successfully set
    
    STATUS_NOT_FOUND    if the specified boot entry was not found
                        or is missing
    
    if there was an error, the status is returned

--*/
{
    PSP_BOOT_ENTRY          bootEntry;
    NTSTATUS                status;
    ULONG                   BootEntryCount;

    //
    // Find the user specified boot entry
    //

    BootEntryCount = 1;
    
    for (bootEntry = SpBootEntries; 
         (bootEntry != NULL) && (BootEntryCount != BootEntryNumber); 
         bootEntry = bootEntry->Next) {
    
        ++BootEntryCount;
    
    }
    ASSERT(BootEntryCount == BootEntryNumber);
    ASSERT(bootEntry);

    //
    // if we have found our match, then set the Default
    //
    if ((bootEntry != NULL) &&
        (BootEntryCount == BootEntryNumber)) {

        PDISK_REGION            Region;

        //
        // point to the disk region with the sig info
        //
        Region = bootEntry->OsPartitionDiskRegion;
        ASSERT(Region);
        if (! Region) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                       DPFLTR_ERROR_LEVEL, 
                       "SpSetDefaultBootEntry: new default partition region is NULL\n"
                       ));
            return STATUS_UNSUCCESSFUL;
        }
                
        //
        // Free the previous Default
        //
        if( Default ) {
            SpMemFree( Default );
        }
        Default = SpMemAlloc( MAX_PATH * sizeof(WCHAR) );
        ASSERT( Default );
        if (! Default) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                       DPFLTR_ERROR_LEVEL, 
                       "SpSetDefaultBootEntry: failed to allocate new Default\n"
                       ));
            return STATUS_UNSUCCESSFUL;
        }

        //
        // fetch the arc name for the region
        //
        SpArcNameFromRegion(
            Region,
            TemporaryBuffer,
            sizeof(TemporaryBuffer)/2,
            PartitionOrdinalOnDisk,
            PrimaryArcPath
            );
        
        //
        // store the new partition and directory info
        //
        wcscpy( Default, TemporaryBuffer);
        SpConcatenatePaths(Default, bootEntry->OsDirectory);
        
        //
        // get the disk signature of the new default disk
        //
        if ((Region->DiskNumber != 0xffffffff) && HardDisks[Region->DiskNumber].Signature) {
            DefaultSignature = HardDisks[Region->DiskNumber].Signature;
        } else {
            DefaultSignature = 0;
        }

        //
        // update the boot options using the specified mode
        //
        if(SpFlushBootVars() == FALSE) {

            KdPrintEx((DPFLTR_SETUP_ID, 
                       DPFLTR_ERROR_LEVEL, 
                       "SpSetDefaultBootEntry: failed flushing boot vars\n"
                       ));

            status = STATUS_UNSUCCESSFUL;
        } else {
            status = STATUS_SUCCESS;
        }

    } else {
        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SpSetDefaultBootEntry: failed to find specified boot entry to use as default\n"
                   ));
        status = STATUS_NOT_FOUND;
    }
    
    return status;

}

#if defined(EFI_NVRAM_ENABLED)

NTSTATUS
SpUpdateDriverEntry(
    IN PCWSTR DriverName,
    IN PCWSTR FriendlyName,
    IN PCWSTR SrcNtDevice,
    IN PCWSTR SrcDir,
    IN PCWSTR DestNtDevice OPTIONAL,
    IN PCWSTR DestDir OPTIONAL
    )
/*++

Routine Description:

	Updates the driver entry for the specified driver.
    If there's no driver entry for the driver, it creates a new one and copies the driver from the source location to the 
    destination location. If there is already a driver entry, the function will not change it; if necessary, the latest
    version of the driver will be copied from the source location to the location pointed to by the entry.

Arguments:

	DriverName -    the file name of the driver (no path)
	FriendlyName -  if the function needs to create a new driver entry, this will be its description
	SrcNtDevice -   NT device name of the location where the driver should be copied from
	SrcDir -        path (relative to SrcNtDevice) to the location where the driver should be copied from
	DestNtDevice -  NT device name of the location where the driver should be copied to. If NULL, SrcNTDevice will be used.
	DestDir -       path( relative to DestNtDevice) to the location where the driver should be copied to. If NULL, SrcDir
                    will be used. If the function needs to create a new driver entry, it will point to DestNTDevice\DestDir.

Return value:

	STATUS_SUCCESS if successful, otherwise an error status.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR SrcPath = NULL;                           // path to the source driver file
    PWSTR DestPath = NULL;                          // path to the destination file
    PWSTR SrcFullNtPath = NULL;                     // full nt path (device + path) for source
    PWSTR DestFullNtPath = NULL;                    // full nt path (device + path) for destination
    PEFI_DRIVER_ENTRY_LIST DriverList = NULL;       // list of driver entries
    PEFI_DRIVER_ENTRY DriverEntry = NULL;           // the new entry to be added
    PFILE_PATH DriverOptionPath = NULL;             // file path to the existing driver entry
    PWSTR OldDriverDevice = NULL;                   // nt device of the existing driver file
    PWSTR OldDriverPath = NULL;                     // path to the existing driver file
    PWSTR OldDriverFullPath = NULL;                 // full nt path to the existing driver file
    PULONG DriverEntryOrder = NULL;                 // holds the array of driver entries
    ULONG EntryId;                                  // ID of the existing or newly added driver entry
    BOOLEAN SameSrcDest;                            // true if the source and destination dirs are the same
    ULONG Length = 0;

    if(NULL == DriverName || NULL == FriendlyName || NULL == SrcNtDevice || NULL == SrcDir) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    if(NULL == DestNtDevice) {
        DestNtDevice = SrcNtDevice;
    }

    if(NULL == DestDir) {
        DestDir = SrcDir;
    }

    Status = ZwEnumerateDriverEntries(NULL, &Length);

    if(!NT_SUCCESS(Status)) {
        PEFI_DRIVER_ENTRY_LIST Entry;
        BOOLEAN bContinue;

        if(Status != STATUS_BUFFER_TOO_SMALL) {
            goto exit;
        }

        ASSERT(Length != 0);
        DriverList = (PEFI_DRIVER_ENTRY_LIST) SpMemAlloc(Length);
        Status = ZwEnumerateDriverEntries(DriverList, &Length);

        if(!NT_SUCCESS(Status)) {
            goto exit;
        }

        //
        // Search the list of entries for our driver
        //
        bContinue = TRUE;

        for(Entry = DriverList; bContinue; Entry = (PEFI_DRIVER_ENTRY_LIST) ((PCHAR) Entry + Entry->NextEntryOffset)) {
            PFILE_PATH FilePath = (PFILE_PATH) ((PCHAR) &Entry->DriverEntry + Entry->DriverEntry.DriverFilePathOffset);
            ULONG PathLength;
            PCWSTR FileName;

            bContinue = (Entry->NextEntryOffset != 0);
            EntryId = Entry->DriverEntry.Id;

            if(FilePath->Type != FILE_PATH_TYPE_NT) {
                PVOID Buffer;

                PathLength = 0;
                Status = ZwTranslateFilePath(FilePath, FILE_PATH_TYPE_NT, NULL, &PathLength);

                if(NT_SUCCESS(Status)) {
                    Status = STATUS_UNSUCCESSFUL;
                }

                if(STATUS_BUFFER_TOO_SMALL == Status) {
                    ASSERT(PathLength != 0);

                    if(DriverOptionPath != NULL) {
                        SpMemFree(DriverOptionPath);
                    }

                    DriverOptionPath = SpMemAlloc(PathLength);
                    Status = ZwTranslateFilePath(FilePath, FILE_PATH_TYPE_NT, DriverOptionPath, &PathLength);
                }

                if(!NT_SUCCESS(Status)) {
                    if(STATUS_OBJECT_PATH_NOT_FOUND == Status || STATUS_OBJECT_NAME_NOT_FOUND == Status) {
                        //
                        // This entry is stale; remove it
                        //
                        ZwDeleteDriverEntry(EntryId);
                    }

                    continue;
                }

                FilePath = DriverOptionPath;
            }

            PathLength = wcslen((PCWSTR) DriverOptionPath->FilePath) + 1;
            FileName = wcsrchr((PCWSTR) DriverOptionPath->FilePath + PathLength, L'\\');

            if(FileName != NULL && 0 == _wcsicmp(DriverName, FileName + 1)) {
                OldDriverDevice = SpDupStringW((PCWSTR) DriverOptionPath->FilePath);
                OldDriverPath = SpDupStringW((PCWSTR) DriverOptionPath->FilePath + PathLength);
                wcscpy(TemporaryBuffer, OldDriverDevice);
                SpConcatenatePaths(TemporaryBuffer, OldDriverPath);
                OldDriverFullPath = SpDupStringW(TemporaryBuffer);
                break;
            }
        }
    }

    //
    // Build the NT paths for source and dest
    //
    wcscpy(TemporaryBuffer, SrcDir);
    SpConcatenatePaths(TemporaryBuffer, DriverName);
    SrcPath = SpDupStringW(TemporaryBuffer);
    wcscpy(TemporaryBuffer, SrcNtDevice);
    SpConcatenatePaths(TemporaryBuffer, SrcPath);
    SrcFullNtPath = SpDupStringW(TemporaryBuffer);

    wcscpy(TemporaryBuffer, DestDir);
    SpConcatenatePaths(TemporaryBuffer, DriverName);
    DestPath = SpDupStringW(TemporaryBuffer);
    wcscpy(TemporaryBuffer, DestNtDevice);
    SpConcatenatePaths(TemporaryBuffer, DestPath);
    DestFullNtPath = SpDupStringW(TemporaryBuffer);

    //
    // Note that there can be different ways to specify the NT path so 
    // the caller should not use different forms for source and destination.
    //
    SameSrcDest = (0 == _wcsicmp(SrcFullNtPath, DestFullNtPath));

    if(OldDriverFullPath != NULL) {
        //
        // There is already an entry for our driver; compare the versions
        //
        ULONGLONG VersionOld;
        ULONGLONG VersionNew;
        Status = SpGetFileVersionFromPath(OldDriverFullPath, &VersionOld);

        if(STATUS_OBJECT_NAME_NOT_FOUND == Status || STATUS_OBJECT_PATH_NOT_FOUND == Status)
        {
            //
            // This entry is stale; remove it
            //
            ZwDeleteDriverEntry(EntryId);
            goto create_entry;
        }

        if(!NT_SUCCESS(Status)) {
            goto exit;
        }

        Status = SpGetFileVersionFromPath(SrcFullNtPath, &VersionNew);

        if(!NT_SUCCESS(Status)) {
            goto exit;
        }

        if(VersionOld < VersionNew) {
            //
            // Copy the new driver and leave the driver entry alone
            //
            Status = SpCopyFileUsingNames((PWSTR) SrcFullNtPath, OldDriverFullPath, 0, COPY_NODECOMP);
        }
    } else {
        ULONG FriendlyNameOffset;
        ULONG FriendlyNameLength;
        ULONG NtDeviceLength;
        ULONG DestPathLength;
        ULONG FilePathLength;
        ULONG EntryLength;
        PFILE_PATH FilePath;

create_entry:
        //
        // Copy the driver to its destination if not already there.
        //
        if(!SameSrcDest) {
            //
            // Make sure the dest dir is present; if this fails, the file copy will fail too
            //
            SpCreateDirectory(DestNtDevice, NULL, DestDir, 0, CREATE_DIRECTORY_FLAG_SKIPPABLE);
            Status = SpCopyFileUsingNames((PWSTR) SrcFullNtPath, (PWSTR) DestFullNtPath, 0, COPY_NODECOMP);

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
        }

        //
        // Add a new driver entry
        //
        FriendlyNameOffset = ALIGN_UP(sizeof(EFI_DRIVER_ENTRY), WCHAR);
        FriendlyNameLength = (wcslen(FriendlyName) + 1) * sizeof(WCHAR);
        NtDeviceLength = (wcslen(DestNtDevice) + 1) * sizeof(WCHAR);
        DestPathLength = (wcslen(DestPath) + 1) * sizeof(WCHAR);
        FilePathLength = FIELD_OFFSET(FILE_PATH, FilePath) + NtDeviceLength + DestPathLength;
        EntryLength = FriendlyNameOffset + ALIGN_UP(FriendlyNameLength, ULONG) + FilePathLength;
        DriverEntry = SpMemAlloc(EntryLength);

        DriverEntry->Version = EFI_DRIVER_ENTRY_VERSION;
        DriverEntry->Length = EntryLength;
        DriverEntry->FriendlyNameOffset = FriendlyNameOffset;
        DriverEntry->DriverFilePathOffset = FriendlyNameOffset + ALIGN_UP(FriendlyNameLength, ULONG);
        RtlCopyMemory((PCHAR) DriverEntry + DriverEntry->FriendlyNameOffset, FriendlyName, FriendlyNameLength);

        FilePath = (PFILE_PATH) ((PCHAR) DriverEntry + DriverEntry->DriverFilePathOffset);
        FilePath->Version = FILE_PATH_VERSION;
        FilePath->Length = FilePathLength;
        FilePath->Type = FILE_PATH_TYPE_NT;
        RtlCopyMemory(FilePath->FilePath, DestNtDevice, NtDeviceLength);
        RtlCopyMemory(FilePath->FilePath + NtDeviceLength, DestPath, DestPathLength);

        Status = ZwAddDriverEntry(DriverEntry, &EntryId);

        if(!NT_SUCCESS(Status)) {
            goto exit;
        }

        Length = 0;
        Status = ZwQueryDriverEntryOrder(NULL, &Length);

        if(!NT_SUCCESS(Status) && Status != STATUS_BUFFER_TOO_SMALL) {
            goto exit;
        }

        DriverEntryOrder = (PULONG) SpMemAlloc((Length + 1) * sizeof(ULONG));

        if(Length != 0) {
            Status = ZwQueryDriverEntryOrder(DriverEntryOrder, &Length);

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
        }

        DriverEntryOrder[Length] = EntryId;
        Status = ZwSetDriverEntryOrder(DriverEntryOrder, Length + 1);
    }

    //
    // Delete the source file
    //
    if(!SameSrcDest) {
        SpDeleteFile(SrcFullNtPath, NULL, NULL);
    }

exit:
    if(SrcPath != NULL) {
        SpMemFree(SrcPath);
    }

    if(DestPath != NULL) {
        SpMemFree(DestPath);
    }

    if(SrcFullNtPath != NULL) {
        SpMemFree(SrcFullNtPath);
    }

    if(DestFullNtPath != NULL) {
        SpMemFree(DestFullNtPath);
    }

    if(DriverList != NULL) {
        SpMemFree(DriverList);
    }

    if(OldDriverDevice != NULL) {
        SpMemFree(OldDriverDevice);
    }

    if(OldDriverPath != NULL) {
        SpMemFree(OldDriverPath);
    }

    if(OldDriverFullPath != NULL) {
        SpMemFree(OldDriverFullPath);
    }

    if(DriverEntry != NULL) {
        SpMemFree(DriverEntry);
    }

    if(DriverOptionPath != NULL) {
        SpMemFree(DriverOptionPath);
    }

    if(DriverEntryOrder != NULL) {
        SpMemFree(DriverEntryOrder);
    }

    return Status;
}

#endif  // EFI_NVRAM_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spcmdcon.h ===
//
// Parameter block passed to the spcmdcon.sys top-level routine.
//
typedef struct _CMDCON_BLOCK {
    PSP_VIDEO_VARS VideoVars;
    PVOID TemporaryBuffer;
    ULONG TemporaryBufferSize;
    PEPROCESS UsetupProcess;
    LPCWSTR BootDevicePath;
    LPCWSTR DirectoryOnBootDevice;
    PVOID SifHandle;
    PWSTR SetupSourceDevicePath;
    PWSTR DirectoryOnSetupSource;
} CMDCON_BLOCK, *PCMDCON_BLOCK;


//
// In its DriverEntry routine, spcmdcon.sys calls
// CommandConsoleInterface(), passing it the address of the top level
// command console routine.
//
typedef
ULONG
(*PCOMMAND_INTERPRETER_ROUTINE)(
    IN PCMDCON_BLOCK CmdConBlock
    );

VOID
CommandConsoleInterface(
    PCOMMAND_INTERPRETER_ROUTINE CmdRoutine
    );


//
// Autochk message processing callback.
//
typedef
NTSTATUS
(*PAUTOCHK_MSG_PROCESSING_ROUTINE) (
    PSETUP_FMIFS_MESSAGE SetupFmifsMessage
    );

VOID
SpSetAutochkCallback(
    IN PAUTOCHK_MSG_PROCESSING_ROUTINE AutochkCallbackRoutine
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spcab.h ===
/*++
Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    spcab.h

Abstract:

    Kernel mode support for cabbing files, esp. for Win9x uninstall.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    November 2000 Jay Krell (a-JayK)
        ported from windows\winstate\cobra\utils\inc\cablib.h

--*/
#pragma once

#include "spmemory.h"

// this is a bit of an interface boundary crossing hack, but only experimental at the moment
#define sptcompTYPE_MSZIP_BIG_FILES_NONE_SMALL_FILES 0x0004

//
// Types
//

typedef BOOL(NTAPI CABGETCABINETNAMESA)(
                        IN      PCSTR CabPath,
                        IN      UINT CabPathChars,
                        IN      PCSTR CabFileName,
                        IN      UINT CabFileNameChars,
                        IN      PCSTR CabDiskName,
                        IN      UINT CabDiskNameChars,
                        IN      INT CabFileNr,
                        IN OUT  PINT CabDiskNr
                        );
typedef CABGETCABINETNAMESA *PCABGETCABINETNAMESA;

typedef BOOL(NTAPI CABGETCABINETNAMESW)(
                        IN      PCWSTR CabPath,
                        IN      UINT CabPathChars,
                        IN      PCWSTR CabFileName,
                        IN      UINT CabFileNameChars,
                        IN      PCWSTR CabDiskName,
                        IN      UINT CabDiskNameChars,
                        IN      INT CabFileNr,
                        IN OUT  PINT CabDiskNr
                        );
typedef CABGETCABINETNAMESW *PCABGETCABINETNAMESW;

typedef BOOL(NTAPI CABNOTIFICATIONA)(
                        IN      PCSTR FileName
                        );
typedef CABNOTIFICATIONA *PCABNOTIFICATIONA;

typedef BOOL(NTAPI CABNOTIFICATIONW)(
                        IN      PCWSTR FileName
                        );
typedef CABNOTIFICATIONW *PCABNOTIFICATIONW;

typedef PVOID OCABHANDLE;

        struct _FCI_CAB_HANDLE;
typedef struct _FCI_CAB_HANDLE* PFCI_CAB_HANDLE;
typedef PFCI_CAB_HANDLE CCABHANDLE;

//
// API
//

CCABHANDLE
SpCabCreateCabinetA(
    IN      PCSTR CabPath,
    IN      PCSTR CabFileFormat,
    IN      PCSTR CabDiskFormat,
    IN      LONG MaxFileSize
    );

CCABHANDLE
SpCabCreateCabinetW(
    IN      PCWSTR CabPath,
    IN      PCWSTR CabFileFormat,
    IN      PCWSTR CabDiskFormat,
    IN      LONG   MaxFileSize
    );

CCABHANDLE
SpCabCreateCabinetExA(
    IN      PCABGETCABINETNAMESA CabGetCabinetNames,
    IN      LONG MaxFileSize
    );

CCABHANDLE
SpCabCreateCabinetExW(
    IN      PCABGETCABINETNAMESW CabGetCabinetNames,
    IN      LONG MaxFileSize
    );

NTSTATUS
SpCabAddFileToCabinetW(
    IN      CCABHANDLE CabHandle,
    IN      PCWSTR FileName,
    IN      PCWSTR StoredName
    );

BOOL
SpCabFlushAndCloseCabinetEx(
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    );

BOOL
SpCabFlushAndCloseCabinet(
    IN      CCABHANDLE CabHandle
    );

OCABHANDLE
SpCabOpenCabinetA(
    IN      PCSTR FileName
    );

OCABHANDLE
SpCabOpenCabinetW(
    IN      PCWSTR FileName
    );

BOOL
SpCabExtractAllFilesExA(
    IN      OCABHANDLE CabHandle,
    IN      PCSTR ExtractPath,
    IN      PCABNOTIFICATIONA CabNotification   OPTIONAL
    );

BOOL
SpCabExtractAllFilesA(
    IN      OCABHANDLE CabHandle,
    IN      PCSTR ExtractPath
    );

BOOL
SpCabExtractAllFilesExW(
    IN      OCABHANDLE CabHandle,
    IN      PCWSTR ExtractPath,
    IN      PCABNOTIFICATIONW CabNotification   OPTIONAL
    );

BOOL
SpCabExtractAllFilesW(
    IN      OCABHANDLE CabHandle,
    IN      PCWSTR ExtractPath
    );

BOOL
SpCabCloseCabinet(
    IN      OCABHANDLE CabHandle
    );

VOID
SpFreeStringW(
    PUNICODE_STRING String
    );

VOID
SpFreeStringA(
    PANSI_STRING String
    );

NTSTATUS
SpConvertToNulTerminatedNtStringsA(
    PCSTR           Ansi,
    PANSI_STRING    AnsiString     OPTIONAL,
    PUNICODE_STRING UnicodeString  OPTIONAL
    );

NTSTATUS
SpConvertToNulTerminatedNtStringsW(
    PCWSTR          Unicode,
    PANSI_STRING    AnsiString     OPTIONAL,
    PUNICODE_STRING UnicodeString  OPTIONAL
    );

VOID
SpStringCopyNA(
    PSTR Dest,
    PCSTR Source,
    SIZE_T Max
    );

VOID
SpStringCopyNW(
    PWSTR  Dest,
    PCWSTR Source,
    SIZE_T Max
    );

VOID
SpMoveStringA(
    PANSI_STRING Dest,
    PANSI_STRING Source
    );

VOID
SpMoveStringW(
    PUNICODE_STRING Dest,
    PUNICODE_STRING Source
    );

BOOL
SpCabFlushAndCloseCabinet(
    IN      CCABHANDLE CabHandle
    );

BOOL
SpCabCloseCabinet(
    IN      OCABHANDLE CabHandle
    );

NTSTATUS
SpCreateDirectoryForFileA(
    IN PCSTR FilePathA,
    IN ULONG CreateFlags
    );

#define SpBoolToDbgPrintLevel(f)    ((f) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)
#define SpBoolToStringA(f)          ((f) ? "true" : "false")
#define SpPointerToDbgPrintLevel(p) DPFLTR_TRACE_LEVEL/*(((p) != NULL && (p) != LongToPtr(-1)) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)*/
#define SpHandleToDbgPrintLevel(h)  DPFLTR_TRACE_LEVEL/*(((h) != NULL && (h) != LongToPtr(-1)) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)*/
#define SpNtStatusToDbgPrintLevel(s) \
    ((NT_SUCCESS(s) \
     || (s) == STATUS_NO_SUCH_FILE \
     || (s) == STATUS_OBJECT_PATH_NOT_FOUND \
     || (s) == STATUS_OBJECT_NAME_NOT_FOUND \
     || (s) == STATUS_NOT_FOUND \
    ) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)

#define SpBooleanToStringA(x) ((x) ? "True" : "False")
#define SpBooleanToStringW(x) ((x) ? L"True" : L"False")

NTSTATUS
SpAnsiStringToUnicodeString(
    PUNICODE_STRING DestinationStringW,
    PCANSI_STRING   SourceStringA,
    BOOL            Allocate
    );

NTSTATUS
SpUnicodeStringToAnsiString(
    PANSI_STRING     DestinationStringA,
    PCUNICODE_STRING SourceStringW,
    BOOL             Allocate
    );

NTSTATUS
SpKnownSizeUnicodeToDbcsN(
    OUT PSTR    Ansi,
    IN  PCWSTR  Unicode,
    IN  SIZE_T  AnsiSize
    );

VOID
SpEnsureTrailingBackSlashA(
    IN PSTR str
    );

PCWSTR
SpGetFileNameFromPathW(
    IN PCWSTR PathSpec
    );

PSTR
SpJoinPathsA(
    PCSTR a,
    PCSTR b
    );

HANDLE
SpOpenFile1W(
    IN      PCWSTR FileName
    );

HANDLE
SpCreateFile1A(
    IN PCSTR FileName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spconfig.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    spconfig.c

Abstract:

    Registry manipulation routines 
    
Author:

    Vijay Jayaseelan (vijayj@microsoft.com) 16 May 2001

Revision History:

    None.

--*/


#include "spprecmp.h"
#pragma hdrstop
#include <initguid.h>
#include <devguid.h>

//
// The following two are defined in winlogon\setup.h, but we
// cannot include setup.h so we are putting these two values here
//

#define SETUPTYPE_FULL    1
#define SETUPTYPE_UPGRADE 4

PWSTR   LOCAL_MACHINE_KEY_NAME    = L"\\registry\\machine";
PWSTR   SETUP_KEY_NAME            = L"setup";
PWSTR   ATDISK_NAME               = L"atdisk";
PWSTR   ABIOSDISK_NAME            = L"abiosdsk";
PWSTR   PRIMARY_DISK_GROUP        = L"Primary disk";
PWSTR   VIDEO_GROUP               = L"Video";
PWSTR   KEYBOARD_PORT_GROUP       = L"Keyboard Port";
PWSTR   POINTER_PORT_GROUP        = L"Pointer Port";
PWSTR   DEFAULT_EVENT_LOG         = L"%SystemRoot%\\System32\\IoLogMsg.dll";
PWSTR   CODEPAGE_NAME             = L"CodePage";
PWSTR   UPGRADE_IN_PROGRESS       = L"UpgradeInProgress";
PWSTR   VIDEO_DEVICE0             = L"Device0";
PWSTR   SESSION_MANAGER_KEY       = L"Control\\Session Manager";
PWSTR   BOOT_EXECUTE              = L"BootExecute";
PWSTR   RESTART_SETUP             = L"RestartSetup";
PWSTR   PRODUCT_OPTIONS_KEY_NAME  = L"ProductOptions";
PWSTR   PRODUCT_SUITE_VALUE_NAME  = L"ProductSuite";
PWSTR   SP_SERVICES_TO_DISABLE    = L"ServicesToDisable";
PWSTR   SP_UPPER_FILTERS          = L"UpperFilters";
PWSTR   SP_LOWER_FILTERS          = L"LowerFilters";
PWSTR   SP_MATCHING_DEVICE_ID     = L"MatchingDeviceId";
PWSTR   SP_CONTROL_CLASS_KEY      = L"Control\\Class";
PWSTR   SP_CLASS_GUID_VALUE_NAME  = L"ClassGUID";


PWSTR ProductSuiteNames[] =
{
    L"Small Business",
    L"Enterprise",
    L"BackOffice",
    L"CommunicationServer",
    L"Terminal Server",
    L"Small Business(Restricted)",
    L"EmbeddedNT",
    L"DataCenter",
    NULL, // This is a placeholder for Single User TS - not actually a suite but the bit position is defined in ntdef.h
    L"Personal",
    L"Blade"
};

#define CountProductSuiteNames (sizeof(ProductSuiteNames)/sizeof(PWSTR))

#define MAX_PRODUCT_SUITE_BYTES 1024

extern BOOLEAN DriveAssignFromA; //NEC98

NTSTATUS
SpSavePreinstallList(
    IN PVOID  SifHandle,
    IN PWSTR  SystemRoot,
    IN HANDLE hKeySystemHive
    );

NTSTATUS
SpDoRegistryInitialization(
    IN PVOID  SifHandle,
    IN PDISK_REGION TargetRegion,
    IN PWSTR  PartitionPath,
    IN PWSTR  SystemRoot,
    IN HANDLE *HiveRootKeys,
    IN PWSTR  SetupSourceDevicePath,
    IN PWSTR  DirectoryOnSourceDevice,
    IN PWSTR  SpecialDevicePath,   OPTIONAL
    IN HANDLE ControlSet
    );

NTSTATUS
SpFormSetupCommandLine(
    IN PVOID  SifHandle,
    IN HANDLE hKeySystemHive,
    IN PWSTR  SetupSourceDevicePath,
    IN PWSTR  DirectoryOnSourceDevice,
    IN PWSTR  FullTargetPath,
    IN PWSTR  SpecialDevicePath OPTIONAL
    );

NTSTATUS
SpDriverLoadList(
    IN PVOID  SifHandle,
    IN PWSTR  SystemRoot,
    IN HANDLE hKeySystemHive,
    IN HANDLE hKeyControlSet
    );

NTSTATUS
SpSaveSKUStuff(
    IN HANDLE hKeySystemHive
    );

NTSTATUS
SpWriteVideoParameters(
    IN PVOID  SifHandle,
    IN HANDLE hKeyControlSetServices
    );

NTSTATUS
SpConfigureNlsParameters(
    IN PVOID  SifHandle,
    IN HANDLE hKeyDefaultHive,
    IN HANDLE hKeyControlSetControl
    );

NTSTATUS
SpCreateCodepageEntry(
    IN PVOID  SifHandle,
    IN HANDLE hKeyNls,
    IN PWSTR  SubkeyName,
    IN PWSTR  SifNlsSectionKeyName,
    IN PWSTR  EntryName
    );

NTSTATUS
SpConfigureFonts(
    IN PVOID  SifHandle,
    IN HANDLE hKeySoftwareHive
    );

NTSTATUS
SpStoreHwInfoForSetup(
    IN HANDLE hKeyControlSetControl
    );

NTSTATUS
SpConfigureMouseKeyboardDrivers(
    IN PVOID  SifHandle,
    IN ULONG  HwComponent,
    IN PWSTR  ClassServiceName,
    IN HANDLE hKeyControlSetServices,
    IN PWSTR  ServiceGroup
    );

NTSTATUS
SpCreateServiceEntryIndirect(
    IN  HANDLE  hKeyControlSetServices,
    IN  PVOID   SifHandle,                  OPTIONAL
    IN  PWSTR   SifSectionName,             OPTIONAL
    IN  PWSTR   KeyName,
    IN  ULONG   ServiceType,
    IN  ULONG   ServiceStart,
    IN  PWSTR   ServiceGroup,               OPTIONAL
    IN  ULONG   ServiceError,
    IN  PWSTR   FileName,                   OPTIONAL
    OUT PHANDLE SubkeyHandle                OPTIONAL
    );

NTSTATUS
SpThirdPartyRegistry(
    IN PVOID hKeyControlSetServices
    );

NTSTATUS
SpGetCurrentControlSetNumber(
    IN  HANDLE SystemHiveRoot,
    OUT PULONG Number
    );

NTSTATUS
SpCreateControlSetSymbolicLink(
    IN  HANDLE  SystemHiveRoot,
    OUT HANDLE *CurrentControlSetRoot
    );

NTSTATUS
SpAppendStringToMultiSz(
    IN HANDLE hKey,
    IN PWSTR  Subkey,
    IN PWSTR  ValueName,
    IN PWSTR  StringToAdd
    );

NTSTATUS
SpGetValueKey(
    IN  HANDLE     hKeyRoot,
    IN  PWSTR      KeyName,
    IN  PWSTR      ValueName,
    IN  ULONG      BufferLength,
    OUT PUCHAR     Buffer,
    OUT PULONG     ResultLength
    );

NTSTATUS
SpPostprocessHives(
    IN PWSTR     PartitionPath,
    IN PWSTR     Sysroot,
    IN PCWSTR   *HiveNames,
    IN HANDLE   *HiveRootKeys,
    IN unsigned  HiveCount,
    IN HANDLE    hkeyCCS
    );

NTSTATUS
SpSaveSetupPidList(
    IN HANDLE hKeySystemHive
    );

NTSTATUS
SpSavePageFileInfo(
    IN HANDLE hKeyCCSetControl,
    IN HANDLE hKeySystemHive
    );

NTSTATUS
SpSetPageFileInfo(
    IN PVOID  SifHandle,
    IN HANDLE hKeyCCSetControl,
    IN HANDLE hKeySystemHive
    );

NTSTATUS
SpGetProductSuiteMask(
    IN HANDLE hKeyControlSetControl,
    OUT PULONG SuiteMask
    );

NTSTATUS
SpSetProductSuite(
    IN HANDLE hKeyControlSetControl,
    IN ULONG SuiteMask
    );

NTSTATUS
SppMigrateFtKeys(
    IN HANDLE hDestSystemHive
    );

NTSTATUS
SpMigrateSetupKeys(
    IN PWSTR  PartitionPath,
    IN PWSTR  SystemRoot,
    IN HANDLE hDestLocalMachine,
    IN PVOID  SifHandle
    );

NTSTATUS
SppDisableDynamicVolumes(
    IN HANDLE hCCSet
    );

NTSTATUS
SppCleanupKeysFromRemoteInstall(
    VOID
    );

NTSTATUS
SpDisableUnsupportedScsiDrivers(
    IN HANDLE hKeyControlSet
    );

NTSTATUS
SpAppendPathToDevicePath(
    IN HANDLE hKeySoftwareHive,
    IN PWSTR  OemPnpDriversDirPath
    );

NTSTATUS
SpAppendFullPathListToDevicePath (
    IN HANDLE hKeySoftwareHive,
    IN PWSTR  PnpDriverFullPathList
    );

NTSTATUS
SpUpdateDeviceInstanceData(
    IN HANDLE ControlSet
    );

NTSTATUS
SpCleanUpHive(
    VOID
    );

NTSTATUS
SpProcessServicesToDisable(
    IN PVOID WinntSifHandle,
    IN PWSTR SectionName,
    IN HANDLE SystemKey
    );

NTSTATUS
SpDeleteRequiredDeviceInstanceFilters(
    IN HANDLE CCSHandle
    );
    
    
#if defined(REMOTE_BOOT)
NTSTATUS
SpCopyRemoteBootKeyword(
    IN PVOID   SifHandle,
    IN PWSTR   KeywordName,
    IN HANDLE  hKeyCCSetControl
    );
#endif // defined(REMOTE_BOOT)


#define STRING_VALUE(s) REG_SZ,(s),(wcslen((s))+1)*sizeof(WCHAR)
#define ULONG_VALUE(u)  REG_DWORD,&(u),sizeof(ULONG)

//
//  List of oem inf files installed as part of the installation of third party drivers
//
extern POEM_INF_FILE   OemInfFileList;

//
//  Name of the directory where OEM files need to be copied, if a catalog file (.cat) is part of
//  the third party driver package that the user provide using the F6 or F5 key.
//
extern PWSTR OemDirName;


VOID
SpInitializeRegistry(
    IN PVOID        SifHandle,
    IN PDISK_REGION TargetRegion,
    IN PWSTR        SystemRoot,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    IN PWSTR        SpecialDevicePath   OPTIONAL,
    IN PDISK_REGION SystemPartitionRegion
    )

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    PWSTR pwstrTemp1,pwstrTemp2;
    int h;
    ULONG Disposition;
    LPCWSTR HiveNames[SetupHiveMax]    = { L"system",L"software",L"default",L"userdiff" };
    HANDLE  HiveRootKeys[SetupHiveMax] = { NULL     ,NULL       ,NULL      ,NULL        };
    PWSTR PartitionPath;
    HANDLE FileHandle;
    HANDLE KeyHandle;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Put up a screen telling the user what we are doing.
    //
    SpStartScreen(
        SP_SCRN_DOING_REG_CONFIG,
        0,
        8,
        TRUE,
        FALSE,
        DEFAULT_ATTRIBUTE
        );

    SpDisplayStatusText(SP_STAT_REG_LOADING_HIVES,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Get the name of the target patition.
    //
    SpNtNameFromRegion(
        TargetRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    PartitionPath = SpDupStringW(TemporaryBuffer);

    // pwstrTemp2 points half way through the buffer.

    pwstrTemp1 = TemporaryBuffer;
    pwstrTemp2 = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);

    //
    // In the fresh install case, there are no hive files in the target tree.
    // We create a key in a known place (\Registry\Machine\System\$$$PROTO.HIV,
    // which is 4 levels deep because \Registry\Machine\$$$PROTO.HIV would
    // imply a hive called $$$PROTO.HIV and we don't want to get tripped up
    // by those semantics). Then we save off that empty key 3 times into
    // system32\config to form 3 empty hives.
    //
    // In the upgrade case this there are actual hives in the target tree
    // which we do NOT want to overwrite!
    //
    // If this is the ASR quick test, we don't want to recreate any of the hives
    //
    // We also want to create an empty userdiff hive in both the fresh and
    // upgrade cases.
    //
    //
    INIT_OBJA(
        &ObjectAttributes,
        &UnicodeString,
        L"\\Registry\\Machine\\System\\$$$PROTO.HIV"
        );

    Status = ZwCreateKey(
                &KeyHandle,
                KEY_ALL_ACCESS,
                &ObjectAttributes,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                &Disposition
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to create root key for protohive (%lx)\n",Status));
    } else {

        ASSERT(SetupHiveUserdiff == SetupHiveMax-1);

        if (ASRMODE_QUICKTEST_FULL != SpAsrGetAsrMode()) {
            for(h = ((NTUpgrade == UpgradeFull) ? SetupHiveUserdiff : 0);
                NT_SUCCESS(Status) && (h < SetupHiveMax);
                h++) {

                //
                // Form full pathname to the hive we want to create.
                // Then create the file.
                //
                wcscpy(pwstrTemp1,PartitionPath);
                SpConcatenatePaths(pwstrTemp1,SystemRoot);
                SpConcatenatePaths(pwstrTemp1,L"SYSTEM32\\CONFIG");
                SpConcatenatePaths(pwstrTemp1,HiveNames[h]);


                SpDeleteFile(pwstrTemp1,NULL,NULL);  // Make sure that we get rid of the file if it has attributes.

                INIT_OBJA(&ObjectAttributes,&UnicodeString,pwstrTemp1);

                Status = ZwCreateFile(
                            &FileHandle,
                            FILE_GENERIC_WRITE,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            0,                      // no sharing
                            FILE_OVERWRITE_IF,
                            FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                            NULL,
                            0
                            );

                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to create file %ws for protohive (%lx)\n",pwstrTemp1,Status));
                } else {
                    //
                    // Save the empty key we created above into the file
                    // we just created. This creates an empty hive.
                    // Call the Ex version to make sure the hive is in the latest format
                    //
                    Status = ZwSaveKeyEx(KeyHandle,FileHandle,REG_LATEST_FORMAT);
                    if(!NT_SUCCESS(Status)) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to save empty key to protohive %ws (%lx)\n",pwstrTemp1,Status));
                    }

                    ZwClose(FileHandle);
                }
            }
        }

        ZwDeleteKey(KeyHandle);
        ZwClose(KeyHandle);
    }

    //
    // Now we have hives in both the upgrade and fresh install cases.
    // Load them up. We use the convention that a hive is loaded into
    // \Registry\Machine\x<hivename>.
    //
    for(h=0; NT_SUCCESS(Status) && (h<SetupHiveMax); h++) {

        swprintf(pwstrTemp1,L"%ws\\x%ws",LOCAL_MACHINE_KEY_NAME,HiveNames[h]);

        wcscpy(pwstrTemp2,PartitionPath);
        SpConcatenatePaths(pwstrTemp2,SystemRoot);
        SpConcatenatePaths(pwstrTemp2,L"SYSTEM32\\CONFIG");
        SpConcatenatePaths(pwstrTemp2,HiveNames[h]);

        Status = SpLoadUnloadKey(NULL,NULL,pwstrTemp1,pwstrTemp2);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: load hive %ws into %ws failed (%lx)\n",pwstrTemp2,pwstrTemp1,Status));
        } else {
            INIT_OBJA(&ObjectAttributes,&UnicodeString,pwstrTemp1);
            Status = ZwOpenKey(&HiveRootKeys[h],KEY_ALL_ACCESS,&ObjectAttributes);
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: open root key %ws failed (%lx)\n",pwstrTemp1,Status));
            }
        }
    }

    //
    // Make a symbolic link such that CurrentControlSet is valid.
    // This allows references in infs to work in either the fresh install case,
    // where we're always dealing with ControlSet001, or in the upgrade case,
    // where the control set we're dealing with is dictated by the state of
    // the existing registry.
    //
    if(NT_SUCCESS(Status)) {
        Status = SpCreateControlSetSymbolicLink(HiveRootKeys[SetupHiveSystem],&KeyHandle);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create ccs symbolic link (%lx)\n",Status));
        }
    }

    //
    // Go do registry initialization.
    //
    if(NT_SUCCESS(Status)) {

        SpDisplayStatusText(SP_STAT_REG_DOING_HIVES,DEFAULT_STATUS_ATTRIBUTE);

        Status = SpDoRegistryInitialization(
                    SifHandle,
                    TargetRegion,
                    PartitionPath,
                    SystemRoot,
                    HiveRootKeys,
                    SetupSourceDevicePath,
                    DirectoryOnSourceDevice,
                    SpecialDevicePath,
                    KeyHandle
                    );

        SpDisplayStatusText(SP_STAT_REG_SAVING_HIVES,DEFAULT_STATUS_ATTRIBUTE);

        if(NT_SUCCESS(Status)) {

#ifdef _X86_
            if (WinUpgradeType == UpgradeWin95) {
                //
                // NOTE: -- Clean this up.
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Migrating disk registry of win9x information.\n"));
                Status = SpMigrateDiskRegistry( HiveRootKeys[SetupHiveSystem]);

                if (!NT_SUCCESS(Status)) {

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate disk registry.\n"));
                }

            }

            //
            // We've set the \\Registry\\Machine\\System\\Setup\\SystemPartition
            // value when we did the partitioning code.  Now we need to migrate
            // that value into the proto hives so they'll be there for
            // the reboot.
            //
            {
#if 0
            HANDLE  Key;
            DWORD   ResultLength;
            PWSTR   SystemPartitionString = 0;


                INIT_OBJA(&ObjectAttributes,&UnicodeString,LOCAL_MACHINE_KEY_NAME);
                Status = ZwOpenKey(&Key,KEY_READ,&ObjectAttributes);
                if(NT_SUCCESS(Status)) {

                    Status = SpGetValueKey(
                                 Key,
                                 L"System\\Setup",
                                 L"SystemPartition",
                                 sizeof(TemporaryBuffer),
                                 (PCHAR)TemporaryBuffer,
                                 &ResultLength
                                 );

                    ZwClose(Key);

                    if(NT_SUCCESS(Status)) {
                        SystemPartitionString = SpDupStringW( TemporaryBuffer );

                        if( SystemPartitionString ) {
                            Status = SpOpenSetValueAndClose( HiveRootKeys[SetupHiveSystem],
                                                             SETUP_KEY_NAME,
                                                             L"SystemPartition",
                                                             STRING_VALUE(SystemPartitionString) );

                            if(!NT_SUCCESS(Status)) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to set SystemPartitionString. (%lx)\n", Status));
                            }

                            SpMemFree(SystemPartitionString);
                        } else {
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to duplicate SystemPartitionString.\n"));
                        }

                    } else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to query SystemPartition Value.\n"));
                    }
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to Open HKLM while trying to query the SytemPartition Value.\n"));
                }
#else

                PWSTR   SystemPartitionString = 0;

                SpNtNameFromRegion( SystemPartitionRegion,
                                    TemporaryBuffer,
                                    sizeof(TemporaryBuffer),
                                    PartitionOrdinalCurrent );

                SystemPartitionString = SpDupStringW( TemporaryBuffer );

                if( SystemPartitionString ) {
                    Status = SpOpenSetValueAndClose( HiveRootKeys[SetupHiveSystem],
                                                     SETUP_KEY_NAME,
                                                     L"SystemPartition",
                                                     STRING_VALUE(SystemPartitionString) );

                    if(!NT_SUCCESS(Status)) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to set SystemPartitionString. (%lx)\n", Status));
                    }

                    SpMemFree(SystemPartitionString);
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to duplicate SystemPartitionString.\n"));
                }

#endif
            }
#endif


            //
            // If we're headless, we'd like to supress any eventlog entries
            // that may occur if the machine has an i8042, but no one has
            // connected a physical keyboard to the machine.  We can do that
            // by adding a regkey here.
            //
            if( HeadlessTerminalConnected ) {
                ULONG One = 1;
                Status = SpOpenSetValueAndClose( KeyHandle,
                                                 L"Services\\i8042prt\\Parameters",
                                                 L"Headless",
                                                 ULONG_VALUE(One) );
                if( !NT_SUCCESS(Status) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to set Headless parameter for i8042. (%lx)\n", Status));
                }
            }


            //
            //  Note that SpPostprocessHives() will always close KeyHandle
            //
            Status = SpPostprocessHives(
                        PartitionPath,
                        SystemRoot,
                        HiveNames,
                        HiveRootKeys,
                        3,
                        KeyHandle
                        );
        } else {
            //
            //  If SpDoRegistryInitialization() fails, then we need to close KeyHandle here,
            //  before we start unloading the hives.
            //
            NtClose(KeyHandle);
        }
    }

    SpDisplayStatusText(SP_STAT_REG_SAVING_HIVES,DEFAULT_STATUS_ATTRIBUTE);

    //
    // From now on, do not disturb the value of Status.
    //
    // NOTE: DO NOT WRITE ANYTHING INTO HIVES BEYOND THIS POINT!!!
    //
    // In the upgrade case we have performed a little swictheroo in
    // SpPostprocessHives() such that anything written to the system hive
    // ends up in system.sav instead of system!
    //
    for(h=0; h<SetupHiveMax; h++) {

        if(HiveRootKeys[h]) {
            ZwClose(HiveRootKeys[h]);
        }

        swprintf(pwstrTemp1,L"%ws\\x%ws",LOCAL_MACHINE_KEY_NAME,HiveNames[h]);
        SpLoadUnloadKey(NULL,NULL,pwstrTemp1,NULL);
    }

    SpMemFree(PartitionPath);

    if(!NT_SUCCESS(Status)) {

        SpDisplayScreen(SP_SCRN_REGISTRY_CONFIG_FAILED,3,HEADER_HEIGHT+1);
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

        SpInputDrain();
        while(SpInputGetKeypress() != KEY_F3) ;

        SpDone(0,FALSE,TRUE);
    }
}


NTSTATUS
SpDoRegistryInitialization(
    IN PVOID  SifHandle,
    IN PDISK_REGION TargetRegion,
    IN PWSTR  PartitionPath,
    IN PWSTR  SystemRoot,
    IN HANDLE *HiveRootKeys,
    IN PWSTR  SetupSourceDevicePath,
    IN PWSTR  DirectoryOnSourceDevice,
    IN PWSTR  SpecialDevicePath,   OPTIONAL
    IN HANDLE ControlSet
    )

/*++

Routine Description:

    Initialize a registry based on user selection for hardware types,
    software options, and user preferences.

    - Create a command line for GUI setup, to be used by winlogon.
    - Create/munge service list entries for device drivers being installed.
    - Initialize the keyboard layout.
    - Initialize a core set of fonts for use with Windows.
    - Store information about selected ahrdware components for use by GUI setup.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    TargetRegion - supplies region descriptor for region to which the system
        is to be installed.

    PartitionPath - supplies the NT name for the drive of windows nt.

    SystemRoot - supplies nt path of the windows nt directory.

    HiveRootKeys - supplies the handles to the root key of the system, software
                   and default hives

    HiveRootPaths - supplies the paths to the root keys of the system, software
                    and default hives.

    SetupSourceDevicePath - supplies nt path to the device setup is using for
        source media (\device\floppy0, \device\cdrom0, etc).

    DirectoryOnSourceDevice - supplies the directory on the source device
        where setup files are kept.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE hKeyControlSetControl;
    PWSTR FullTargetPath;
    LPWSTR p;
    BOOLEAN b;
    ULONG SuiteMask = 0;
    PWSTR AdditionalGuiPnpDrivers;


    if(NTUpgrade != UpgradeFull) {

        b = SpHivesFromInfs(
                SifHandle,
                L"HiveInfs.Fresh",
                SetupSourceDevicePath,
                DirectoryOnSourceDevice,
                HiveRootKeys[SetupHiveSystem],
                HiveRootKeys[SetupHiveSoftware],
                HiveRootKeys[SetupHiveDefault],
                HiveRootKeys[SetupHiveUserdiff]
                );

#if defined(REMOTE_BOOT)
        //
        // If this is a remote boot setup, process the AddReg.RemoteBoot
        // section in hivesys.inf and the AddReg section in winnt.sif.
        //
        if (b && RemoteBootSetup) {
            (VOID)SpHivesFromInfs(
                      SifHandle,
                      L"HiveInfs.Fresh.RemoteBoot",
                      SetupSourceDevicePath,
                      DirectoryOnSourceDevice,
                      HiveRootKeys[SetupHiveSystem],
                      HiveRootKeys[SetupHiveSoftware],
                      HiveRootKeys[SetupHiveDefault],
                      NULL
                      );
            ASSERT(WinntSifHandle != NULL);
            (VOID)SpProcessAddRegSection(
                      WinntSifHandle,
                      L"AddReg",
                      HiveRootKeys[SetupHiveSystem],
                      HiveRootKeys[SetupHiveSoftware],
                      HiveRootKeys[SetupHiveDefault],
                      NULL
                      );
        }
#endif // defined(REMOTE_BOOT)

        if(!b) {
            Status = STATUS_UNSUCCESSFUL;
            goto sdoinitreg1;
        }
    }

    //
    // Open ControlSet\Control.
    //
    INIT_OBJA(&Obja,&UnicodeString,L"Control");
    Obja.RootDirectory = ControlSet;

    Status = ZwOpenKey(&hKeyControlSetControl,KEY_ALL_ACCESS,&Obja);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open CurrentControlSet\\Control (%lx)\n",Status));
        goto sdoinitreg1;
    }

    //
    //  Save the Pid list
    //
    SpSaveSetupPidList( HiveRootKeys[SetupHiveSystem] );

    //
    // Form the setup command line.
    //

    wcscpy(TemporaryBuffer, PartitionPath);
    SpConcatenatePaths(TemporaryBuffer, SystemRoot);
    FullTargetPath = SpDupStringW(TemporaryBuffer);

    Status = SpFormSetupCommandLine(
                SifHandle,
                HiveRootKeys[SetupHiveSystem],
                SetupSourceDevicePath,
                DirectoryOnSourceDevice,
                FullTargetPath,
                SpecialDevicePath
                );
    SpMemFree(FullTargetPath);

    if(!NT_SUCCESS(Status)) {
        goto sdoinitreg3;
    }

    //
    // Save evalution time
    //
    Status = SpSaveSKUStuff(HiveRootKeys[SetupHiveSystem]);
    if(!NT_SUCCESS(Status)) {
        goto sdoinitreg3;
    }

    //
    // Set the product suite
    //

    SpGetProductSuiteMask(hKeyControlSetControl,&SuiteMask);
    //
    // Account for multiple suite bits being set in SuiteType.
    //
//    SuiteMask |= (1 << (SuiteType-1));
    //
    // there's one more problem: PERSONAL sku is identified by VER_SUITE_PERSONAL flag set
    // we want to be able to upgrade from PER to PRO, but PRO doesn't have any flag set
    // we also want to be able to upgrade from PER to PER, but in this case this bit will be set
    // in SuiteType; therefore it's safe to always clear this bit before applying the new mask
    //
    SuiteMask &= ~VER_SUITE_PERSONAL;
    SuiteMask |= SuiteType;
    SpSetProductSuite(hKeyControlSetControl,SuiteMask);

    //
    // Language/locale-specific registry initialization.
    //
    Status = SplangSetRegistryData(
                SifHandle,
                ControlSet,
                (NTUpgrade == UpgradeFull) ? NULL : HardwareComponents,
                (BOOLEAN)(NTUpgrade == UpgradeFull)
                );

    if(!NT_SUCCESS(Status)) {
        goto sdoinitreg3;
    }



    //
    // If we need to convert to ntfs, set that up here.
    // We can't use the PartitionPath since that is based on
    // *current* disk ordinal -- we need a name based on the *on-disk*
    // ordinal, since the convert occurs after a reboot. Moved it here
    // so that this is done for upgrades too.
    //
    if(ConvertNtVolumeToNtfs) {
        WCHAR   GuidVolumeName[MAX_PATH] = {0};
        PWSTR   VolumeName;

        wcscpy(TemporaryBuffer,L"autoconv ");
        VolumeName = TemporaryBuffer + wcslen(TemporaryBuffer);

        SpNtNameFromRegion(
            TargetRegion,
            VolumeName,   // append to the "autoconv " we put there
            512,                        // just need any reasonable size
            PartitionOrdinalCurrent
            );

        //
        // NOTE: Don't use volume GUIDs for file system conversion 
        // for 9x upgrades.
        // 
        if (WinUpgradeType == NoWinUpgrade) {
            //
            // Try to get hold of the \\??\Volume{a-b-c-d} format
            // volume name for the partition
            //
            Status = SpPtnGetGuidNameForPartition(VolumeName,
                            GuidVolumeName);

            //
            // If GuidVolumeName is available then use that rather
            // than \device\harddiskX\partitionY since disk ids can
            // change across reboots
            //
            if (NT_SUCCESS(Status) && GuidVolumeName[0]) {
                wcscpy(VolumeName, GuidVolumeName);
            }
        }                        

        wcscat(TemporaryBuffer, L" /fs:NTFS");

        FullTargetPath = SpDupStringW(TemporaryBuffer);

        Status = SpAppendStringToMultiSz(
                    ControlSet,
                    SESSION_MANAGER_KEY,
                    BOOT_EXECUTE,
                    FullTargetPath
                    );

        SpMemFree(FullTargetPath);
    }

    if(NTUpgrade == UpgradeFull) {

        SpSavePageFileInfo( hKeyControlSetControl,
                            HiveRootKeys[SetupHiveSystem] );


        Status = SpUpgradeNTRegistry(
                    SifHandle,
                    HiveRootKeys,
                    SetupSourceDevicePath,
                    DirectoryOnSourceDevice,
                    ControlSet
                    );
        if(!NT_SUCCESS(Status)) {
            goto sdoinitreg3;
        }

        Status = SpProcessAddRegSection(
            WinntSifHandle,
            L"compatibility",
            HiveRootKeys[SetupHiveSystem],
            NULL,
            NULL,
            NULL
            );
            
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to process compatibility settings.\n"));
        }

        //
        // Disable all upper and lower level class filters for the services which were
        // disabled
        //
        Status = SpProcessServicesToDisable(WinntSifHandle,
                    SP_SERVICES_TO_DISABLE,
                    hKeyControlSetControl);
                        

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                DPFLTR_ERROR_LEVEL, 
                "SETUP: Unable to process ServicesToDisable section (%lx).\n",
                Status));
        }

        //
        // Remove all the upper and lower device instance filter drivers for keyboard and
        // mouse class drivers
        //
        Status = SpDeleteRequiredDeviceInstanceFilters(ControlSet);

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                DPFLTR_ERROR_LEVEL, 
                "SETUP: Unable to unable to delete keyboard & mouse device filter drivers (%lx).\n",
                Status));
        }

        
        //
        // Set up font entries.
        //
        Status = SpConfigureFonts(SifHandle,HiveRootKeys[SetupHiveSoftware]);
        if(!NT_SUCCESS(Status)) {
            goto sdoinitreg3;
        }

        //
        // Enable detected scsi miniports, atdisk and abios disk, if necessary
        //
        Status = SpDriverLoadList(SifHandle,SystemRoot,HiveRootKeys[SetupHiveSystem],ControlSet);
        if(!NT_SUCCESS(Status)) {
            goto sdoinitreg3;
        }

        //
        //  Disable the unsupported scsi drivers that need to be disabled
        //
        if( UnsupportedScsiHardwareToDisable != NULL ) {
            SpDisableUnsupportedScsiDrivers( ControlSet );
        }

    } else {

        if (IsNEC_98) { //NEC98
            //
            // NEC98 default drive assign for hard drive is start from A:,
            // so if it need to start from C: we should set "DriveLetter" KEY into hive.
            //
            if( !DriveAssignFromA ) {
                Status = SpOpenSetValueAndClose(HiveRootKeys[SetupHiveSystem],
                                                SETUP_KEY_NAME,
                                                L"DriveLetter",
                                                STRING_VALUE(L"C"));
            }

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set system\\setup\\drive letter (%lx)\n",Status));
                return(Status);
            }
        } //NEC98

        //
        // Create service entries for drivers being installed
        // (ie, munge the driver load list).
        //
        Status = SpDriverLoadList(SifHandle,SystemRoot,HiveRootKeys[SetupHiveSystem],ControlSet);
        if(!NT_SUCCESS(Status)) {
            goto sdoinitreg3;
        }

        if (SpDrEnabled()) {
            Status = SpDrSetEnvironmentVariables(HiveRootKeys);
            if(!NT_SUCCESS(Status)) {
                goto sdoinitreg3;
            }
        }


        //
        // Set up the keyboard layout and nls-related stuff.
        //
        Status = SpConfigureNlsParameters(SifHandle,HiveRootKeys[SetupHiveDefault],hKeyControlSetControl);
        if(!NT_SUCCESS(Status)) {
            goto sdoinitreg3;
        }

        //
        // Set up font entries.
        //
        Status = SpConfigureFonts(SifHandle,HiveRootKeys[SetupHiveSoftware]);
        if(!NT_SUCCESS(Status)) {
            goto sdoinitreg3;
        }

        //
        // Store information used by gui setup, describing the hardware
        // selections made by the user.
        //
        Status = SpStoreHwInfoForSetup(hKeyControlSetControl);
        if(!NT_SUCCESS(Status)) {
            goto sdoinitreg3;
        }
        if( PreInstall ) {
            ULONG  u;
            PWSTR  OemPnpDriversDirPath;

            u = 1;
            SpSavePreinstallList( SifHandle,
                                  SystemRoot,
                                  HiveRootKeys[SetupHiveSystem] );

            Status = SpOpenSetValueAndClose( hKeyControlSetControl,
                                             L"Windows",
                                             L"NoPopupsOnBoot",
                                             ULONG_VALUE(u) );
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set NoPopupOnBoot. Status = %lx \n",Status));
            }

            //
            // Add autolfn.exe to bootexecute list.
            //
            Status = SpAppendStringToMultiSz(
                        ControlSet,
                        SESSION_MANAGER_KEY,
                        BOOT_EXECUTE,
                        L"autolfn"
                        );

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to add autolfn to BootExecute. Status = %lx \n",Status));
                goto sdoinitreg3;
            }

            //
            //  If unattended file specifies path to OEM drivers directory, then append path
            //  to HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion, DevicePath
            //
            OemPnpDriversDirPath = SpGetSectionKeyIndex(UnattendedSifHandle,
                                                        SIF_UNATTENDED,
                                                        WINNT_OEM_PNP_DRIVERS_PATH_W,
                                                        0);
            if( OemPnpDriversDirPath != NULL ) {
                Status = SpAppendPathToDevicePath( HiveRootKeys[SetupHiveSoftware], OemPnpDriversDirPath );
                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to append %ls to DevicePath. Status = %lx \n",OemPnpDriversDirPath,Status));
                    goto sdoinitreg3;
                }
            }
        }
    }

    SpSetPageFileInfo( SifHandle, hKeyControlSetControl, HiveRootKeys[SetupHiveSystem] );

    //
    // Skip migration of FTKeys in the win95 upgrade case. This is important in order to ensure that
    // drive letters are preserved. At the beginning of GUI mode, the mounted devices key will
    // be rebuilt using the data stored by win9xupg in the HKLM\System\DISK.
    //

#ifdef _X86_
    if (WinUpgradeType != UpgradeWin95) {
#endif

    //
    // Do the migration of HKEY_LOCAL_MACHINE\SYSTEM\DISK and HKEY_LOCAL_MACHINE\SYSTEM\MountedDevices
    // from the setup hive to the target hive (if these keys exist).
    //
    Status = SppMigrateFtKeys(HiveRootKeys[SetupHiveSystem]);
    if(!NT_SUCCESS(Status)) {
        goto sdoinitreg3;
    }

#ifdef _X86_
    }
#endif

    //
    // On a remote install, we do some registry cleanup before migrating
    // keys.
    //
    if (RemoteInstallSetup) {
        SppCleanupKeysFromRemoteInstall();
    }

    //
    // Do any cleanup on the system hive before we migrate it to the target
    // system hive.
    //
    SpCleanUpHive();



    //
    //  Migrate some keys from the setup hive to the target system hive.
    //
    Status = SpMigrateSetupKeys( PartitionPath, SystemRoot, ControlSet, SifHandle );
    if( !NT_SUCCESS(Status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate registry keys from the setup hive to the target system hive. Status = %lx\n", Status));
        goto sdoinitreg3;
    }

    //
    //  Disable Dynamic Volumes on portables and
    //  Whistler Personal
    //
    if( DockableMachine || SpIsProductSuite(VER_SUITE_PERSONAL)) {
        NTSTATUS Status1;

        Status1 = SppDisableDynamicVolumes(ControlSet);

        if( !NT_SUCCESS( Status1 ) ) {
            KdPrintEx((DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Unable to disable dynamic volumes on laptop/personal builds. Status = %lx \n",
                Status1));
        }
    }

    //
    // A side-effect of loading setupdd.sys is that Plug&Play generates a device instance
    // key for it called "Root\LEGACY_SETUPDD\0000".  Clean that up now.  (No need to check
    // the return status--if this fails it's no big deal.)
    //
    SppDeleteKeyRecursive(ControlSet,
                          L"Enum\\Root\\LEGACY_SETUPDD",
                          TRUE
                         );

    //
    // Delete the virtual RAM devices and driver keys
    //
    if (VirtualOemSourceDevices) {
        //
        // delete the root devnodes
        //
        SpDeleteRootDevnodeKeys(SifHandle,
            ControlSet,
            L"RootDevicesToDelete.clean",
            NULL);

        //
        // Remove the service
        //
        SppDeleteKeyRecursive(ControlSet,
            L"Services\\" RAMDISK_DRIVER_NAME,
            TRUE);
    }

#if defined(REMOTE_BOOT)
    //
    // Copy information that remote boot needs from the .sif to the
    // registry.
    //
    if (RemoteBootSetup) {
        (VOID)SpCopyRemoteBootKeyword(WinntSifHandle,
                                      SIF_ENABLEIPSECURITY,
                                      hKeyControlSetControl);
        (VOID)SpCopyRemoteBootKeyword(WinntSifHandle,
                                      SIF_REPARTITION,
                                      hKeyControlSetControl);
    }
#endif // defined(REMOTE_BOOT)

    //
    //  Finally, if the answer file specifies a path list to additional GUI drivers,
    //  then append this path to the DevicePath value
    //
    AdditionalGuiPnpDrivers = SpGetSectionKeyIndex (
                                    WinntSifHandle,
                                    SIF_SETUPPARAMS,
                                    WINNT_SP_DYNUPDTADDITIONALGUIDRIVERS_W,
                                    0
                                    );
    if (AdditionalGuiPnpDrivers) {
        Status = SpAppendFullPathListToDevicePath (HiveRootKeys[SetupHiveSoftware], AdditionalGuiPnpDrivers);
        if (!NT_SUCCESS(Status)) {
            KdPrintEx ((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Unable to append %ls to DevicePath. Status = %lx \n",
                AdditionalGuiPnpDrivers,
                Status
                ));
            goto sdoinitreg3;
        }
    }

sdoinitreg3:

    ZwClose(hKeyControlSetControl);

sdoinitreg1:

    return(Status);
}


NTSTATUS
SpFormSetupCommandLine(
    IN PVOID  SifHandle,
    IN HANDLE hKeySystemHive,
    IN PWSTR  SetupSourceDevicePath,
    IN PWSTR  DirectoryOnSourceDevice,
    IN PWSTR  FullTargetPath,
    IN PWSTR  SpecialDevicePath   OPTIONAL
    )

/*++

Routine Description:

    Create the command line to invoke GUI setup and store it in
    HKEY_LOCAL_MACHINE\system\<ControlSet>\Setup:CmdLine.

    The command line for the command to be launched depends
    on whether NT Setup is executing within a disaster recovery
    context, or a normal context.  For the normal case, the
    command line is is as follows:

        setup -newsetup

    For Automated System Recovery (ASR), the command line is
        setup -newsetup -asr

    For the automated ASR quick test, the command line is
        setup - newsetup -asrquicktest

Arguments:

    SifHandle - handle to the master sif (txtsetup.sif)

    hKeySystemHive - supplies handle to root of the system hive
        (ie, HKEY_LOCAL_MACHINE\System).

    SetupSourceDevicePath - supplies the nt device path of the source media
        to be used during setup (\device\floppy0, \device\cdrom0, etc).

    DirectoryOnSourceDevice - supplies the directory on the source device
        where setup files are kept.

    FullTargetPath - supplies the NtPartitionName+SystemRoot path on the target device.

    SpecialDevicePath - if specified, will be passed to setup as the value for
        STF_SPECIAL_PATH.  If not specified, STF_SPECIAL_PATH will be "NO"

Return Value:

    Status value indicating outcome of operation.

--*/

{
    PWSTR OptionalDirSpec = NULL;
    PWSTR UserExecuteCmd = NULL;
    PWSTR szLanManNt = WINNT_A_LANMANNT_W;
    PWSTR szWinNt = WINNT_A_WINNT_W;
    PWSTR szYes = WINNT_A_YES_W;
    PWSTR szNo = WINNT_A_NO_W;
    PWSTR SourcePathBuffer;
    PWSTR CmdLine;
    DWORD SetupType,SetupInProgress;
    NTSTATUS Status;
    PWSTR TargetFile;
    PWSTR p;
    WCHAR *Data[1];

    //
    // Can't use TemporaryBuffer because we make subroutine calls
    // below that trash its contents.
    //
    CmdLine = SpMemAlloc(256);
    CmdLine[0] = 0;

    //
    // Construct the setup command line.  Start with the basic part.
    // We first look in winnt.sif for this data, and if it isn't there, then
    // we look in the sif handle which was input to us.
    //
    if(p = SpGetSectionKeyIndex(WinntSifHandle,SIF_SETUPDATA,SIF_SETUPCMDPREPEND,0)) {
        wcscpy(CmdLine,p);
    } else if(p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_SETUPCMDPREPEND,0)) {
        wcscpy(CmdLine,p);
    }

    // If we did get some parameter read in from unattend file, add separator.
    //
    if (*CmdLine)
        wcscat(CmdLine,L" ");

    //
    // If this is ASR, append the appropriate cmd line options to GUI-mode Setup
    //
    if (SpDrEnabled()) {

        if (ASRMODE_NORMAL == SpAsrGetAsrMode()) {
            //
            // This is normal ASR mode
            //
            wcscat(CmdLine, L"setup -newsetup -asr");
        }
        else {
            //
            // This is the Full Asr QuickTest
            //
            wcscat(CmdLine, L"setup -newsetup -asrquicktest");
        }

    } else {
        wcscat( CmdLine,L"setup -newsetup" );
    }

    //
    // Put the setup source in the command line.
    // Note that the source is an NT-style name. GUI Setup handles this properly.
    //
    SourcePathBuffer = SpMemAlloc( (wcslen(SetupSourceDevicePath) +
        wcslen(DirectoryOnSourceDevice) + 2) * sizeof(WCHAR) );
    wcscpy(SourcePathBuffer,SetupSourceDevicePath);

    if (!NoLs) {

        SpConcatenatePaths(SourcePathBuffer,DirectoryOnSourceDevice);

    }

    //
    // if we were given an administrator password via a remote install,
    // we need to put this in the unattend file if appropriate.
    //
    if (NetBootAdministratorPassword) {
        SpAddLineToSection(
                    WinntSifHandle,
                    SIF_GUI_UNATTENDED,
                    WINNT_US_ADMINPASS_W,
                    &NetBootAdministratorPassword,
                    1);
    }

    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_SOURCEPATH_W,
        &SourcePathBuffer,1);

    //
    // Put a flag indicating whether this is a win3.1 upgrade.
    //
    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_WIN31UPGRADE_W,
        ( (WinUpgradeType == UpgradeWin31) ? &szYes : &szNo),1);

    //
    // Put a flag indicating whether this is a win95 upgrade.
    //
    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_WIN95UPGRADE_W,
        ( (WinUpgradeType == UpgradeWin95) ? &szYes : &szNo),1);

    //
    // Put a flag indicating whether this is an NT upgrade.
    //
    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_NTUPGRADE_W,
        ((NTUpgrade == UpgradeFull) ? &szYes : &szNo), 1);

    //
    // Put a flag indicating whether to upgrade a standard server
    // (an existing standard server, or an existing workstation to
    // a standard server)
    //
    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_SERVERUPGRADE_W,
        (StandardServerUpgrade ? &szYes : &szNo),1);

    //
    // Tell gui mode whether this is server or workstation.
    //
    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_PRODUCT_W,
        (AdvancedServer ? &szLanManNt : &szWinNt),1);

    //
    // Special path spec.
    //
    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_BOOTPATH_W,
        (SpecialDevicePath ? &SpecialDevicePath : &szNo), 1);

    //
    // Go Fetch the Optional Dir Specs...
    //
    OptionalDirSpec = SpGetSectionKeyIndex(WinntSifHandle,SIF_SETUPPARAMS,
        L"OptionalDirs",0);

    //
    // Check for commad line to execute at end of gui setup
    //
    UserExecuteCmd = SpGetSectionKeyIndex(WinntSifHandle,SIF_SETUPPARAMS,
        L"UserExecute",0);

    //
    // Unattended mode flag | script filename
    //
    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_INSTALL_W,
        ((UnattendedOperation || UnattendedGuiOperation || SpDrEnabled()) ? &szYes : &szNo), 1);

    //
    // If this is ASR, write out the Networking sections to allow
    // GUI-mode to be unattended
    //
    if (SpDrEnabled()) {
        SpAddLineToSection(WinntSifHandle,L"Networking",L"InstallDefaultComponents",&szYes,1);
        Data[0]=L"WORKGROUP";
        SpAddLineToSection(WinntSifHandle,L"Identification",L"JoinWorkgroup",Data,1);
    }

    //
    // Write the name of OEM inf files, if any.
    //
    if( OemInfFileList != NULL ) {
        PWSTR   OemDriversKeyName = WINNT_OEMDRIVERS_W; // L"OemDrivers";
        PWSTR   OemDriverPathName = WINNT_OEMDRIVERS_PATHNAME_W; // L"OemDriverPathName";
        PWSTR   OemInfName = WINNT_OEMDRIVERS_INFNAME_W;         // L"OemInfName";
        PWSTR   OemDriverFlags = WINNT_OEMDRIVERS_FLAGS_W;
        PWSTR   OemInfSectionName = L"OemInfFiles";
        PWSTR   szOne = L"1";
        PWSTR   p;
        PWSTR   *r;
        ULONG   NumberOfInfFiles;
        POEM_INF_FILE q;
        ULONG   i;

        SpAddLineToSection(WinntSifHandle, SIF_DATA, OemDriversKeyName, &OemInfSectionName, 1);

        wcscpy( TemporaryBuffer, L"%SystemRoot%" );
        SpConcatenatePaths( TemporaryBuffer, OemDirName );
        p = SpDupStringW( TemporaryBuffer );
        SpAddLineToSection(WinntSifHandle, OemInfSectionName, OemDriverPathName, &p, 1);
        SpMemFree( p );
        SpAddLineToSection(WinntSifHandle, OemInfSectionName, OemDriverFlags, &szOne, 1);

        for( q = OemInfFileList, NumberOfInfFiles = 0;
             q != NULL;
             q = q->Next, NumberOfInfFiles++ );
        r = SpMemAlloc( NumberOfInfFiles * sizeof( PWSTR ) );
        for( q = OemInfFileList, i = 0;
             q != NULL;
             r[i] = q->InfName, q = q->Next, i++ );
        SpAddLineToSection(WinntSifHandle,OemInfSectionName, OemInfName, r, NumberOfInfFiles);
        SpMemFree( r );
    }

    //
    // Before we write the answer to this, we need to know if we successfully
    // have written Winnt.sif into system32\$winnt$.inf
    //
    wcscpy(TemporaryBuffer, FullTargetPath);
    SpConcatenatePaths(TemporaryBuffer, L"system32");
    SpConcatenatePaths(TemporaryBuffer, SIF_UNATTENDED_INF_FILE);
    TargetFile = SpDupStringW(TemporaryBuffer);
    Status = SpWriteSetupTextFile(WinntSifHandle,TargetFile,NULL,NULL);
    if(NT_SUCCESS(Status)) {

        Status = SpOpenSetValueAndClose(
                    hKeySystemHive,
                   SETUP_KEY_NAME,
                   L"CmdLine",
                   STRING_VALUE(CmdLine)
                   );
    }

    //
    // Free up whatever memory we have allocated
    //
    SpMemFree(TargetFile);
    SpMemFree(CmdLine);
    SpMemFree(SourcePathBuffer);

    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Set the SetupType value to the right value SETUPTYPE_FULL in the
    // case of initial install and SETUPTYPE_UPGRADE in the case of upgrade.
    //

    SetupType = (NTUpgrade == UpgradeFull) ? SETUPTYPE_UPGRADE : SETUPTYPE_FULL;
    Status = SpOpenSetValueAndClose(
                hKeySystemHive,
                SETUP_KEY_NAME,
                L"SetupType",
                ULONG_VALUE(SetupType)
                );
    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Set the SystemSetupInProgress value.  Don't rely on the default hives
    // having this set
    //

    SetupInProgress = 1;
    Status = SpOpenSetValueAndClose(
                hKeySystemHive,
                SETUP_KEY_NAME,
                L"SystemSetupInProgress",
                ULONG_VALUE(SetupInProgress)
                );

    return(Status);
}


NTSTATUS
SpDriverLoadList(
    IN PVOID  SifHandle,
    IN PWSTR  SystemRoot,
    IN HANDLE hKeySystemHive,
    IN HANDLE hKeyControlSet
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE hKeyControlSetServices;
    PHARDWARE_COMPONENT ScsiHwComponent;
    // PHARDWARE_COMPONENT TempExtender;
    ULONG u;
    ULONG i;
    PHARDWARE_COMPONENT TempHw;
    PHARDWARE_COMPONENT DeviceLists[] = {
                                        BootBusExtenders,
                                        BusExtenders,
                                        InputDevicesSupport
                                        };
    PWSTR   SectionNames[] = {
                             SIF_BOOTBUSEXTENDERS,
                             SIF_BUSEXTENDERS,
                             SIF_INPUTDEVICESSUPPORT
                             };

    PWSTR   ServiceGroupNames[] = {
                                  L"Boot Bus Extender",
                                  L"System Bus Extender",
                                  NULL
                                  };
    ULONG   StartValues[] = {
                            SERVICE_BOOT_START,
                            SERVICE_BOOT_START,
                            SERVICE_DEMAND_START
                            };

    //
    // Open controlset\services.
    //
    INIT_OBJA(&Obja,&UnicodeString,L"services");
    Obja.RootDirectory = hKeyControlSet;

    Status = ZwCreateKey(
                &hKeyControlSetServices,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open services key (%lx)\n",Status));
        return(Status);
    }

    //
    // For each non-third-party miniport driver that loaded,
    // go create a services entry for it.
    //
    if( !PreInstall ||
        ( PreinstallScsiHardware == NULL ) ) {
        ScsiHwComponent = ScsiHardware;
    } else {
        ScsiHwComponent = PreinstallScsiHardware;
    }
    for( ; ScsiHwComponent; ScsiHwComponent=ScsiHwComponent->Next) {

        if(!ScsiHwComponent->ThirdPartyOptionSelected) {

            //
            // For scsi, the shortname (idstring) is used as
            // the name of the service node key in the registry --
            // we don't look up the service entry in the [SCSI] section
            // of the setup info file.
            //
            Status = SpCreateServiceEntryIndirect(
                    hKeyControlSetServices,
                    NULL,
                    NULL,
                    ScsiHwComponent->IdString,
                    SERVICE_KERNEL_DRIVER,
                    SERVICE_BOOT_START,
                    L"SCSI miniport",
                    SERVICE_ERROR_NORMAL,
                    NULL,
                    NULL
                    );

            if(!NT_SUCCESS(Status)) {
                goto spdrvlist1;
            }

        }
    }

    //
    // If there are any atdisks out there, enable atdisk.
    // We have to enable AtDisk if Pcmcia was loaded, even
    // if atdisk doesn't exist. This will allow the user to
    // insert a pcmcia atdisk device, and have it work when
    // they boot.  In this case, however, we turn off error
    // logging, so that they won't get an annoying popup
    // when there is no atdisk device in the card slot.
    //
    // Note that atdisk.sys is always copied to the system.
    //

    Status = SpCreateServiceEntryIndirect(
                hKeyControlSetServices,
                NULL,
                NULL,
                ATDISK_NAME,
                SERVICE_KERNEL_DRIVER,
                ( AtDisksExist )? SERVICE_BOOT_START : SERVICE_DISABLED,
                PRIMARY_DISK_GROUP,
                ( AtDisksExist && !AtapiLoaded )? SERVICE_ERROR_NORMAL : SERVICE_ERROR_IGNORE,
                NULL,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        goto spdrvlist1;
    }

    //
    // If there are any abios disks out there, enable abiosdsk.
    //
    if(AbiosDisksExist) {

        Status = SpCreateServiceEntryIndirect(
                    hKeyControlSetServices,
                    NULL,
                    NULL,
                    ABIOSDISK_NAME,
                    SERVICE_KERNEL_DRIVER,
                    SERVICE_BOOT_START,
                    PRIMARY_DISK_GROUP,
                    SERVICE_ERROR_NORMAL,
                    NULL,
                    NULL
                    );

        if(!NT_SUCCESS(Status)) {
            goto spdrvlist1;
        }
    }

    //
    // For each bus enumerator driver that loaded,
    // go create a services entry for it.
    //
    for( i = 0; i < sizeof(DeviceLists) / sizeof(PDETECTED_DEVICE); i++ ) {
        for( TempHw = DeviceLists[i]; TempHw; TempHw=TempHw->Next) {

            //
            // For bus extenders and input devices, the shortname (idstring) is used as
            // the name of the service node key in the registry --
            // we don't look up the service entry in the [BusExtenders] or [InputDevicesSupport] section
            // of the setup info file.
            //
            Status = SpCreateServiceEntryIndirect(
                    hKeyControlSetServices,
                    SifHandle,
                    SectionNames[i],
                    TempHw->IdString,
                    SERVICE_KERNEL_DRIVER,
                    StartValues[i],
                    ServiceGroupNames[i],
                    SERVICE_ERROR_NORMAL,
                    NULL,
                    NULL
                    );

            if(!NT_SUCCESS(Status)) {
                goto spdrvlist1;
            }
        }
    }

    if( NTUpgrade != UpgradeFull ) {
        //
        // Set up video parameters.
        //
        Status = SpWriteVideoParameters(SifHandle,hKeyControlSetServices);

        if(!NT_SUCCESS(Status)) {
            goto spdrvlist1;
        }

        //
        // Enable the relevent keyboard and mouse drivers.  If the class drivers
        // are being replaced by third-party ones, then disable the built-in ones.
        //
        Status = SpConfigureMouseKeyboardDrivers(
                    SifHandle,
                    HwComponentKeyboard,
                    L"kbdclass",
                    hKeyControlSetServices,
                    KEYBOARD_PORT_GROUP
                    );

        if(!NT_SUCCESS(Status)) {
            goto spdrvlist1;
        }

        Status = SpConfigureMouseKeyboardDrivers(
                    SifHandle,
                    HwComponentMouse,
                    L"mouclass",
                    hKeyControlSetServices,
                    POINTER_PORT_GROUP
                    );

        if(!NT_SUCCESS(Status)) {
            goto spdrvlist1;
        }

    }
    Status = SpThirdPartyRegistry(hKeyControlSetServices);

spdrvlist1:

    ZwClose(hKeyControlSetServices);

    return(Status);
}


NTSTATUS
SpSaveSKUStuff(
    IN HANDLE hKeySystemHive
    )
{
    LARGE_INTEGER l;
    NTSTATUS Status;
    ULONG NumberOfProcessors;
    BOOLEAN OldStyleRegisteredProcessorMode;
    ULONG Index = 0;

    //
    // Do not change any of this algorithm without changing
    // SetUpEvaluationSKUStuff() in syssetup.dll (registry.c).
    //
    // Embed the evaluation time and a bool indicating whether
    // this is a server or workstation inside a random large integer.
    //
    // Evaluation time: bits 13-44
    // Product type   : bit     58
    //
    // Bit 10 == 1 : Setup works as it does before the 4.0 restriction logic
    //        == 0 : GUI Setup writes registered processors based on the
    //               contents of bits 5-9
    //
    // Bits 5 - 9  : The maximum number of processors that the system is licensed
    //               to use. The value stored is actually ~(MaxProcessors-1)
    //
    //
    // RestrictCpu is used to build protucts this place a very hard
    // limit on the number of processors
    //
    // - a value of 0 means for NTW, the hard limit is 2, and for NTS,
    //   the hard limit is 4
    //
    // - a value of 1-32 means that the hard limit is the number
    //   specified
    //
    // - a value > 32 means that the hard limit is 32 processors and GUI
    //     setup operates on registered processors as it does today
    //

    l.LowPart = SpComputeSerialNumber();
    l.HighPart = SpComputeSerialNumber();

    l.QuadPart &= 0xfbffe0000000181f;
    l.QuadPart |= ((ULONGLONG)EvaluationTime) << 13;

    if ( RestrictCpu == 0 ) {
        //
        // NTW and NTS will take this path using setupreg.hiv/setupret.hiv
        //
        OldStyleRegisteredProcessorMode = FALSE;
        //
        // new licensing model says that whistler is a 2 cpu system, not 4
        //
        NumberOfProcessors = 2;
        //NumberOfProcessors = (AdvancedServer ? 4 : 2);

    } else if ( RestrictCpu <= MAXIMUM_PROCESSORS ) {
        //
        // NTS/EE/DTC will take this path using a hive targetted at 8/16 CPU.
        //
        OldStyleRegisteredProcessorMode = FALSE;
        NumberOfProcessors = RestrictCpu;
    } else {
        OldStyleRegisteredProcessorMode = TRUE;
        NumberOfProcessors = MAXIMUM_PROCESSORS;
    }


    //
    // Logic of getting the log(NumberOfProcessor) and verification.
    //                         2
    // Here we encode the number of processors as the power of 2.
    // Where NumberOfProcessors is the maximum number of processors that 
    // the system is licensed to use.
    //
    
    //
    // If exact power of two only then it is a good value.
    //
    if (NumberOfProcessors & (NumberOfProcessors-1)){
       KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Invalid NumberOfProcessors (%u)\n",NumberOfProcessors));  
       return(STATUS_INVALID_PARAMETER);
    }

    //
    // Count the number of times we need to divide NumberOfProcessors 
    // by 2 to reduce it to 1.
    // 8 = 1000 in binary and (2^3 = 8) and we store 3 in the registry.
    // 
    Index = 0;
    while(NumberOfProcessors > 1){
        NumberOfProcessors = NumberOfProcessors >> 1;
        ++Index;
    }

    NumberOfProcessors = Index;
     
    
    
    //
    // Now NumberOfProcessors is correct. Convert it to the in registry format
    //

    NumberOfProcessors = NumberOfProcessors << 5;
    NumberOfProcessors &= 0x000003e0;

    //
    // Store NumberOfProcessors into the registry
    //

    l.LowPart |= NumberOfProcessors;

    //
    // Tell Gui Mode to do old style registered processors
    //

    if ( OldStyleRegisteredProcessorMode ) {
        l.LowPart |= 0x00000400;
    }

    if(AdvancedServer) {
        l.HighPart |= 0x04000000;
    }

    //
    // Save in registry.
    //
    Status = SpOpenSetValueAndClose(
                hKeySystemHive,
                SETUP_KEY_NAME,
                L"SystemPrefix",
                REG_BINARY,
                &l.QuadPart,
                sizeof(ULONGLONG)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set SystemPrefix (%lx)\n",Status));
    }

    return(Status);
}


NTSTATUS
SpSetUlongValueFromSif(
    IN PVOID  SifHandle,
    IN PWSTR  SifSection,
    IN PWSTR  SifKey,
    IN ULONG  SifIndex,
    IN HANDLE hKey,
    IN PWSTR  ValueName
    )
{
    UNICODE_STRING UnicodeString;
    PWSTR ValueString;
    LONG Value;
    NTSTATUS Status;

    //
    // Look up the value.
    //
    ValueString = SpGetSectionKeyIndex(SifHandle,SifSection,SifKey,SifIndex);
    if(!ValueString) {
        SpFatalSifError(SifHandle,SifSection,SifKey,0,SifIndex);
    }

    Value = SpStringToLong(ValueString,NULL,10);

    if(Value == -1) {

        Status = STATUS_SUCCESS;

    } else {

        RtlInitUnicodeString(&UnicodeString,ValueName);

        Status = ZwSetValueKey(hKey,&UnicodeString,0,ULONG_VALUE((ULONG)Value));

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set value %ws (%lx)\n",ValueName,Status));
        }
    }

    return(Status);
}


NTSTATUS
SpConfigureMouseKeyboardDrivers(
    IN PVOID  SifHandle,
    IN ULONG  HwComponent,
    IN PWSTR  ClassServiceName,
    IN HANDLE hKeyControlSetServices,
    IN PWSTR  ServiceGroup
    )
{
    PHARDWARE_COMPONENT hw;
    NTSTATUS Status;
    ULONG val = SERVICE_DISABLED;

    Status = STATUS_SUCCESS;
    if( !PreInstall ||
        ( PreinstallHardwareComponents[HwComponent] == NULL ) ) {
        hw = HardwareComponents[HwComponent];
    } else {
        hw = PreinstallHardwareComponents[HwComponent];
    }
    for(;hw && NT_SUCCESS( Status ); hw=hw->Next) {
        if(hw->ThirdPartyOptionSelected) {

            if(IS_FILETYPE_PRESENT(hw->FileTypeBits,HwFileClass)) {

                if( !PreInstall ) {
                    //
                    // Disable the built-in class driver.
                    //
                    Status = SpOpenSetValueAndClose(
                                hKeyControlSetServices,
                                ClassServiceName,
                                L"Start",
                                ULONG_VALUE(val)
                                );
                }
            }
        } else {

            Status = SpCreateServiceEntryIndirect(
                        hKeyControlSetServices,
                        SifHandle,
                        NonlocalizedComponentNames[HwComponent],
                        hw->IdString,
                        SERVICE_KERNEL_DRIVER,
                        SERVICE_SYSTEM_START,
                        ServiceGroup,
                        SERVICE_ERROR_IGNORE,
                        NULL,
                        NULL
                        );
        }
    }
    return(Status);
}

NTSTATUS
SpWriteVideoParameters(
    IN PVOID  SifHandle,
    IN HANDLE hKeyControlSetServices
    )
{
    NTSTATUS Status;
    PWSTR KeyName;
    HANDLE hKeyDisplayService;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    ULONG x,y,b,v,i;
    PHARDWARE_COMPONENT pHw;

    if( !PreInstall ||
        ( PreinstallHardwareComponents[HwComponentDisplay] == NULL ) ) {
        pHw = HardwareComponents[HwComponentDisplay];
    } else {
        pHw = PreinstallHardwareComponents[HwComponentDisplay];
    }
    Status = STATUS_SUCCESS;
    for(;pHw && NT_SUCCESS(Status);pHw=pHw->Next) {
        //
        // Third party drivers will have values written into the miniport
        // Device0 key at the discretion of the txtsetup.oem author.
        //
        if(pHw->ThirdPartyOptionSelected) {
            continue;
            // return(STATUS_SUCCESS);
        }

        KeyName = SpGetSectionKeyIndex(
                        SifHandle,
                        NonlocalizedComponentNames[HwComponentDisplay],
                        pHw->IdString,
                        INDEX_INFKEYNAME
                        );

        //
        // If no key name is specified for this display then there's nothing to do.
        // The setup display subsystem can tell us that the mode parameters are
        // not relevent.  If so there's nothing to do.
        //
        if(!KeyName || !SpvidGetModeParams(&x,&y,&b,&v,&i)) {
            continue;
            // return(STATUS_SUCCESS);
        }

        //
        // We want to write the parameters for the display mode setup
        // is using into the relevent key in the service list.  This will force
        // the right mode for, say, a fixed-frequency monitor attached to
        // a vxl (which might default to a mode not supported by the monitor).
        //

        INIT_OBJA(&Obja,&UnicodeString,KeyName);
        Obja.RootDirectory = hKeyControlSetServices;

        Status = ZwCreateKey(
                    &hKeyDisplayService,
                    KEY_ALL_ACCESS,
                    &Obja,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    NULL
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open/create key %ws (%lx)\n",KeyName,Status));
            return(Status);
        }

        //
        // Set the x resolution.
        //
        Status = SpOpenSetValueAndClose(
                    hKeyDisplayService,
                    VIDEO_DEVICE0,
                    L"DefaultSettings.XResolution",
                    ULONG_VALUE(x)
                    );

        if(NT_SUCCESS(Status)) {

            //
            // Set the y resolution.
            //
            Status = SpOpenSetValueAndClose(
                        hKeyDisplayService,
                        VIDEO_DEVICE0,
                        L"DefaultSettings.YResolution",
                        ULONG_VALUE(y)
                        );

            if(NT_SUCCESS(Status)) {

                //
                // Set the bits per pixel.
                //
                Status = SpOpenSetValueAndClose(
                             hKeyDisplayService,
                            VIDEO_DEVICE0,
                            L"DefaultSettings.BitsPerPel",
                            ULONG_VALUE(b)
                            );

                if(NT_SUCCESS(Status)) {

                    //
                    // Set the vertical refresh.
                    //
                    Status = SpOpenSetValueAndClose(
                                hKeyDisplayService,
                                VIDEO_DEVICE0,
                                L"DefaultSettings.VRefresh",
                                ULONG_VALUE(v)
                                );

                    if(NT_SUCCESS(Status)) {

                        //
                        // Set the interlaced flag.
                        //
                        Status = SpOpenSetValueAndClose(
                                    hKeyDisplayService,
                                    VIDEO_DEVICE0,
                                    L"DefaultSettings.Interlaced",
                                    ULONG_VALUE(i)
                                    );
                    }
                }
            }
        }

        ZwClose(hKeyDisplayService);
    }
    return(Status);
}


NTSTATUS
SpConfigureNlsParameters(
    IN PVOID  SifHandle,
    IN HANDLE hKeyDefaultHive,
    IN HANDLE hKeyControlSetControl
    )

/*++

Routine Description:

    This routine configures NLS-related stuff in the registry:

        - a keyboard layout
        - the primary ansi, oem, and mac codepages
        - the language casetable
        - the oem hal font

Arguments:

    SifHandle - supplies handle to open setup information file.

    hKeyDefaultHive - supplies handle to root of default user hive.

    hKeyControlSetControl - supplies handle to the Control subkey of
        the control set being operated on.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    PHARDWARE_COMPONENT_FILE HwFile;
    PWSTR LayoutId;
    NTSTATUS Status;
    HANDLE hKeyNls;
    PWSTR OemHalFont;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    PWSTR IntlLayoutId, LayoutText, LayoutFile, SubKey;

    //
    // We don't allow third-party keyboard layouts.
    //
    ASSERT(!HardwareComponents[HwComponentLayout]->ThirdPartyOptionSelected);

    //
    // Make an entry in the keyboard layout section in the default user hive.
    // This will match an entry in HKLM\CCS\Control\Nls\Keyboard Layouts,
    // which is 'preloaded' with all the possible layouts.
    //
    if( !PreInstall ||
        (PreinstallHardwareComponents[HwComponentLayout] == NULL) ) {
        LayoutId = HardwareComponents[HwComponentLayout]->IdString;
    } else {
        LayoutId = PreinstallHardwareComponents[HwComponentLayout]->IdString;
    }
    Status = SpOpenSetValueAndClose(
                hKeyDefaultHive,
                L"Keyboard Layout\\Preload",
                L"1",
                STRING_VALUE(LayoutId)
                );

    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Add 3 entries into the registry here.  our entries will be:
    // 1. HKLM\System\CurrentControlSet\Control\Keyboard Layouts\LayoutId\Layout File
    // 2. HKLM\System\CurrentControlSet\Control\Keyboard Layouts\LayoutId\Layout Id
    // 3. HKLM\System\CurrentControlSet\Control\Keyboard Layouts\LayoutId\Layout Text
    //

    wcscpy( TemporaryBuffer, L"Keyboard Layouts" );
    SpConcatenatePaths( TemporaryBuffer, LayoutId );
    SubKey = SpDupStringW(TemporaryBuffer);

    //
    // First, do the "Layout File" key.
    //
    LayoutFile = SpGetSectionKeyIndex(
                    SifHandle,              // txtsetup.sif
                    SIF_KEYBOARDLAYOUTFILES,// Files.KeyboardLayout
                    LayoutId,               // IdString
                    0                       // 0
                    );

    if(!LayoutFile) {
        SpFatalSifError(
            SifHandle,
            SIF_KEYBOARDLAYOUTFILES,
            LayoutId,
            0,
            INDEX_DESCRIPTION
            );

        //
        // Should not come here, but lets make prefix happy
        //
        return STATUS_NO_SUCH_FILE;
    }

    Status = SpOpenSetValueAndClose(
                hKeyControlSetControl,      // Handle to ControlSet\Control
                SubKey,                     // \Keyboard Layouts\LayoutId
                L"Layout File",             // ValueName
                REG_SZ,                     // ValueType
                LayoutFile,                 // Value
                (wcslen(LayoutFile)+1)*sizeof(WCHAR) // ValueSize
                );
    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Next, do the "\Keyboard layouts\Layout Text" key.
    //
    LayoutText = SpGetSectionKeyIndex(
                    SifHandle,              // txtsetup.sif
                    SIF_KEYBOARDLAYOUT,     // Keyboard Layout
                    LayoutId,               // IdString
                    0                       // 0
                    );

    if(!LayoutText) {
        SpFatalSifError(
            SifHandle,
            SIF_KEYBOARDLAYOUT,
            LayoutId,
            0,
            INDEX_DESCRIPTION
            );
    }

    Status = SpOpenSetValueAndClose(
                hKeyControlSetControl,      // Handle to ControlSet\Control
                SubKey,                     // \Keyboard Layouts\LayoutId
                L"Layout Text",             // ValueName
                REG_SZ,                     // ValueType
                LayoutText,                 // Value
                (wcslen(LayoutText)+1)*sizeof(WCHAR) // ValueSize
                );
    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Lastly, do the "\Keyboard layouts\Layout Id" key.
    //
    IntlLayoutId = SpGetSectionKeyIndex(
                   SifHandle,               // txtsetup.sif
                   L"KeyboardLayoutId",     // KeyboardLayoutId
                   LayoutId,                // IdString
                   0                        // 0
                   );

    //
    // There may legitimatley not be one...
    //
    if(IntlLayoutId) {
        Status = SpOpenSetValueAndClose(
                    hKeyControlSetControl,      // Handle to ControlSet\Control
                    SubKey,                     // \Keyboard Layouts\LayoutId
                    L"Layout Id",               // ValueName
                    REG_SZ,                     // ValueType
                    IntlLayoutId,               // Value
                    (wcslen(IntlLayoutId)+1)*sizeof(WCHAR) // ValueSize
                    );
        if(!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    SpMemFree(SubKey);

    //
    // Open controlset\Control\Nls.
    //
    INIT_OBJA(&Obja,&UnicodeString,L"Nls");
    Obja.RootDirectory = hKeyControlSetControl;

    Status = ZwCreateKey(
                &hKeyNls,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open controlset\\Control\\Nls key (%lx)\n",Status));
        return(Status);
    }

    //
    // Create an entry for the ansi codepage.
    //
    Status = SpCreateCodepageEntry(
                SifHandle,
                hKeyNls,
                CODEPAGE_NAME,
                SIF_ANSICODEPAGE,
                L"ACP"
                );

    if(NT_SUCCESS(Status)) {

        //
        // Create entries for the oem codepage(s).
        //
        Status = SpCreateCodepageEntry(
                    SifHandle,
                    hKeyNls,
                    CODEPAGE_NAME,
                    SIF_OEMCODEPAGE,
                    L"OEMCP"
                    );

        if(NT_SUCCESS(Status)) {

            //
            // Create an entry for the mac codepage.
            //
            Status = SpCreateCodepageEntry(
                        SifHandle,
                        hKeyNls,
                        CODEPAGE_NAME,
                        SIF_MACCODEPAGE,
                        L"MACCP"
                        );
        }
    }

    if(NT_SUCCESS(Status)) {

        //
        // Create an entry for the oem hal font.
        //

        OemHalFont = SpGetSectionKeyIndex(SifHandle,SIF_NLS,SIF_OEMHALFONT,0);
        if(!OemHalFont) {
            SpFatalSifError(SifHandle,SIF_NLS,SIF_OEMHALFONT,0,0);
        }

        Status = SpOpenSetValueAndClose(
                    hKeyNls,
                    CODEPAGE_NAME,
                    L"OEMHAL",
                    STRING_VALUE(OemHalFont)
                    );
    }

    //
    // Create an entry for the language case table.
    //
    if(NT_SUCCESS(Status)) {

        Status = SpCreateCodepageEntry(
                    SifHandle,
                    hKeyNls,
                    L"Language",
                    SIF_UNICODECASETABLE,
                    L"Default"
                    );
    }

#ifdef _X86_
    //
    // If necessary, let the win9x upgrade override the code page for GUI mode.
    //
    if (WinUpgradeType == UpgradeWin95) {
        SpWin9xOverrideGuiModeCodePage (hKeyNls);
    }
#endif

    ZwClose(hKeyNls);

    return(Status);
}


NTSTATUS
SpCreateCodepageEntry(
    IN PVOID  SifHandle,
    IN HANDLE hKeyNls,
    IN PWSTR  SubkeyName,
    IN PWSTR  SifNlsSectionKeyName,
    IN PWSTR  EntryName
    )
{
    PWSTR Filename,Identifier;
    NTSTATUS Status;
    ULONG value = 0;
    PWSTR DefaultIdentifier = NULL;

    while(Filename = SpGetSectionKeyIndex(SifHandle,SIF_NLS,SifNlsSectionKeyName,value)) {

        value++;

        Identifier = SpGetSectionKeyIndex(SifHandle,SIF_NLS,SifNlsSectionKeyName,value);
        if(!Identifier) {
            SpFatalSifError(SifHandle,SIF_NLS,SifNlsSectionKeyName,0,value);
        }

        //
        // Remember first identifier.
        //
        if(DefaultIdentifier == NULL) {
            DefaultIdentifier = Identifier;
        }

        value++;

        Status = SpOpenSetValueAndClose(
                    hKeyNls,
                    SubkeyName,
                    Identifier,
                    STRING_VALUE(Filename)
                    );

        if(!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    if(!value) {
        SpFatalSifError(SifHandle,SIF_NLS,SifNlsSectionKeyName,0,0);
    }

    Status = SpOpenSetValueAndClose(
                hKeyNls,
                SubkeyName,
                EntryName,
                STRING_VALUE(DefaultIdentifier)
                );

    return(Status);
}


NTSTATUS
SpConfigureFonts(
    IN PVOID  SifHandle,
    IN HANDLE hKeySoftwareHive
    )

/*++

Routine Description:

    Prepare a list of fonts for use with Windows.

    This routine runs down a list of fonts stored in the setup information
    file and adds each one to the registry, in the area that shadows the
    [Fonts] section of win.ini (HKEY_LOCAL_MACHINE\Software\Microsoft\
    Windows NT\CurrentVersion\Fonts).  If a particular font value entry
    already exists (e.g., if we're doing an upgrade), then it is left alone.

    Eventually it will add the correct resolution (96 or 120 dpi)
    fonts but for now it only deals with the 96 dpi fonts.

Arguments:

    SifHandle - supplies a handle to the open text setup information file.

    hKeySoftwareHive - supplies handle to root of software registry hive.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    HANDLE hKey;
    PWSTR FontList;
    PWSTR FontName;
    PWSTR FontDescription;
    ULONG FontCount,font;
    ULONG KeyValueLength;

    //
    // Open HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Fonts.
    //
    INIT_OBJA(
        &Obja,
        &UnicodeString,
        L"Microsoft\\Windows NT\\CurrentVersion\\Fonts"
        );

    Obja.RootDirectory = hKeySoftwareHive;

    Status = ZwCreateKey(
                &hKey,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open Fonts key (%lx)\n",Status));
        return(Status);
    }

    //
    // For now always use the 96 dpi fonts.
    //
    FontList = L"FontListE";

    //
    // Process each line in the text setup information file section
    // for the selected font list.
    //
    FontCount = SpCountLinesInSection(SifHandle,FontList);
    if(!FontCount) {
        SpFatalSifError(SifHandle,FontList,NULL,0,0);
    }

    for(font=0; font<FontCount; font++) {

        //
        // Fetch the font description.
        //
        FontDescription = SpGetKeyName(SifHandle,FontList,font);
        if(!FontDescription) {
            SpFatalSifError(SifHandle,FontList,NULL,font,(ULONG)(-1));
        }

        //
        // Check to see if a value entry for this font already exists.  If so,
        // we want to leave it alone.
        //
        RtlInitUnicodeString(&UnicodeString,FontDescription);

        Status = ZwQueryValueKey(hKey,
                                 &UnicodeString,
                                 KeyValueFullInformation,
                                 (PVOID)NULL,
                                 0,
                                 &KeyValueLength
                                );

        if((Status == STATUS_BUFFER_OVERFLOW) || (Status == STATUS_BUFFER_TOO_SMALL)) {
            Status = STATUS_SUCCESS;
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Font %ws already exists--entry will not be modified\n", FontDescription));
            continue;
        }

        //
        // Fetch the font filename.
        //
        FontName = SpGetSectionLineIndex(SifHandle,FontList,font,0);
        if(!FontName) {
            SpFatalSifError(SifHandle,FontList,NULL,font,0);
        }

        //
        // Set the entry.
        //
        Status = ZwSetValueKey(hKey,&UnicodeString,0,STRING_VALUE(FontName));

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set %ws to %ws (%lx)\n",FontDescription,FontName,Status));
            break;
        }
    }

    ZwClose(hKey);
    return(Status);
}


NTSTATUS
SpStoreHwInfoForSetup(
    IN HANDLE hKeyControlSetControl
    )

/*++

Routine Description:

    This routine stored information in the registry which will be used by
    GUI setup to determine which options for mouse, display, and keyboard
    are currently selected.

    The data is stored in HKEY_LOCAL_MACHINE\System\<control set>\Control\Setup
    in values pointer, video, and keyboard.

Arguments:

    hKeyControlSetControl - supplies handle to open key
        HKEY_LOCAL_MACHINE\System\<Control Set>\Control.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;

    ASSERT(HardwareComponents[HwComponentMouse]->IdString);
    ASSERT(HardwareComponents[HwComponentDisplay]->IdString);
    ASSERT(HardwareComponents[HwComponentKeyboard]->IdString);

    Status = SpOpenSetValueAndClose(
                hKeyControlSetControl,
                SETUP_KEY_NAME,
                L"pointer",
                STRING_VALUE(HardwareComponents[HwComponentMouse]->IdString)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set control\\setup\\pointer value (%lx)\n",Status));
        return(Status);
    }

    Status = SpOpenSetValueAndClose(
                hKeyControlSetControl,
                SETUP_KEY_NAME,
                L"video",
                STRING_VALUE(HardwareComponents[HwComponentDisplay]->IdString)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set control\\setup\\video value (%lx)\n",Status));
        return(Status);
    }

    Status = SpOpenSetValueAndClose(
                hKeyControlSetControl,
                SETUP_KEY_NAME,
                L"keyboard",
                STRING_VALUE(HardwareComponents[HwComponentKeyboard]->IdString)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set control\\setup\\keyboard value (%lx)\n",Status));
        return(Status);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
SpOpenSetValueAndClose(
    IN HANDLE hKeyRoot,
    IN PWSTR  SubKeyName,  OPTIONAL
    IN PWSTR  ValueName,
    IN ULONG  ValueType,
    IN PVOID  Value,
    IN ULONG  ValueSize
    )

/*++

Routine Description:

    Open a subkey, set a value in it, and close the subkey.
    The subkey will be created if it does not exist.

Arguments:

    hKeyRoot - supplies handle to an open registry key.

    SubKeyName - supplies path relative to hKeyRoot for key in which
        the value is to be set. If this is not specified, then the value
        is set in hKeyRoot.

    ValueName - supplies the name of the value to be set.

    ValueType - supplies the data type for the value to be set.

    Value - supplies a buffer containing the value data.

    ValueSize - supplies the size of the buffer pointed to by Value.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    OBJECT_ATTRIBUTES Obja;
    HANDLE hSubKey;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;

    //
    // Open or create the subkey in which we want to set the value.
    //
    hSubKey = hKeyRoot;
    if(SubKeyName) {
        //
        //  If SubKeyName is a path to the key, then we need to create
        //  the subkeys in the path, because they may not exist yet.
        //
        PWSTR   p;
        PWSTR   q;
        PWSTR   r;

        //
        //  Since this function may temporarily write to the key path (which may be a constant string,
        //  and the system will bug check if we write to it), we need to duplicate the string so that
        //  we can write to memory that we own.
        //
        p = SpDupStringW( SubKeyName );
        r = p;
        do {
            //
            //  p points to the next subkey to be created.
            //  q points to NUL character at the end of the
            //    name.
            //  r points to the beginning of the duplicated string. It will be used at the end of this
            //    routine, when we no longer need the string, so that we can free the alocated memory.
            //

            q = wcschr(p, (WCHAR)'\\');
            if( q != NULL ) {
                //
                //  Temporarily replace the '\' with the
                //  NUL character
                //
                *q = (WCHAR)'\0';
            }
            INIT_OBJA(&Obja,&UnicodeString,p);
            Obja.RootDirectory = hSubKey;

            Status = ZwCreateKey(
                        &hSubKey,
                        KEY_ALL_ACCESS,
                        &Obja,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        NULL
                        );

            if( q != NULL ) {
                //
                //  Restore the '\' in the subkey name, and make
                //  p and q point to the remainder of the path
                //  that was not processed yet.
                //
                *q = (WCHAR)'\\';
                q++;
                p = q;
            }
            //
            //  The parent of the key that we just attempted to open/create
            //  is no longer needed.
            //
            if( Obja.RootDirectory != hKeyRoot ) {
                ZwClose( Obja.RootDirectory );
            }

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open subkey %ws (%lx)\n",SubKeyName,Status));
                return(Status);
            }

        } while( q != NULL );
        SpMemFree( r );
    }

    //
    // Set the value.
    //
    RtlInitUnicodeString(&UnicodeString,ValueName);

    Status = ZwSetValueKey(
                hSubKey,
                &UnicodeString,
                0,
                ValueType,
                Value,
                ValueSize
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set value %ws:%ws (%lx)\n",SubKeyName,ValueName,Status));
    }

    if(SubKeyName) {
        ZwClose(hSubKey);
    }

    return(Status);
}


NTSTATUS
SpGetProductSuiteMask(
    IN HANDLE hKeyControlSetControl,
    OUT PULONG SuiteMask
    )
{
    OBJECT_ATTRIBUTES Obja;
    HANDLE hSubKey;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    UCHAR Buffer[MAX_PRODUCT_SUITE_BYTES];
    ULONG BufferLength;
    ULONG ResultLength = 0;
    PWSTR p;
    PUCHAR Data;
    ULONG DataLength;
    BOOLEAN SuiteFound = FALSE;
    ULONG i,j;


    *SuiteMask = 0;

    //
    // Open or create the subkey in which we want to set the value.
    //

    INIT_OBJA(&Obja,&UnicodeString,PRODUCT_OPTIONS_KEY_NAME);
    Obja.RootDirectory = hKeyControlSetControl;

    Status = ZwCreateKey(
                &hSubKey,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open subkey (%lx)\n",Status));
        return(Status);
    }

    //
    // query the current value
    //

    INIT_OBJA(&Obja,&UnicodeString,PRODUCT_SUITE_VALUE_NAME);

    BufferLength = sizeof(Buffer);
    RtlZeroMemory( Buffer, BufferLength );

    Status = ZwQueryValueKey(
                hSubKey,
                &UnicodeString,
                KeyValuePartialInformation,
                Buffer,
                BufferLength,
                &ResultLength
                );

    if((!NT_SUCCESS(Status)) && (Status != STATUS_OBJECT_NAME_NOT_FOUND)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to query subkey (%lx)\n",Status));
        return(Status);
    }

    if (ResultLength == BufferLength) {
        //
        // the buffer is too small, this should not happen
        // unless we have too many suites
        //
        ZwClose(hSubKey);
        return STATUS_BUFFER_OVERFLOW;
    }

    if (ResultLength) {

        Data = (PUCHAR)(((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data);

        if (((PWSTR)Data)[0] == 0) {
            ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->DataLength -= sizeof(WCHAR);
        }

        DataLength = ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->DataLength;

        p = (PWSTR)Data;
        i = 0;
        while (i<DataLength) {
            for (j=0; j<CountProductSuiteNames; j++) {
                if (ProductSuiteNames[j] != NULL && wcscmp(p,ProductSuiteNames[j]) == 0) {
                    *SuiteMask |= (1 << j);
                }
            }
            if (*p < L'A' || *p > L'z') {
                i += 1;
                p += 1;
            } else {
                i += (wcslen( p ) + 1);
                p += (wcslen( p ) + 1);
            }
        }
    }

    ZwClose(hSubKey);

    return(Status);
}


NTSTATUS
SpSetProductSuite(
    IN HANDLE hKeyControlSetControl,
    IN ULONG SuiteMask
    )
{
    OBJECT_ATTRIBUTES Obja;
    HANDLE hSubKey;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    UCHAR Buffer[MAX_PRODUCT_SUITE_BYTES];
    ULONG BufferLength;
    ULONG ResultLength = 0;
    PWSTR p;
    PUCHAR Data;
    ULONG DataLength;
    BOOLEAN SuiteFound = FALSE;
    ULONG i;
    ULONG tmp;


    //
    // Open or create the subkey in which we want to set the value.
    //

    INIT_OBJA(&Obja,&UnicodeString,PRODUCT_OPTIONS_KEY_NAME);
    Obja.RootDirectory = hKeyControlSetControl;

    Status = ZwCreateKey(
                &hSubKey,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open subkey (%lx)\n",Status));
        return(Status);
    }

    RtlZeroMemory( Buffer, sizeof(Buffer) );
    tmp = SuiteMask;
    p = (PWSTR)Buffer;
    i = 0;

    while (tmp && i<CountProductSuiteNames) {
        if ((tmp&1) && ProductSuiteNames[i] != NULL) {
            wcscpy(p,ProductSuiteNames[i]);
            p += (wcslen(p) + 1);
        }
        i += 1;
        tmp >>= 1;
    }

    BufferLength = (ULONG)((ULONG_PTR)p - (ULONG_PTR)Buffer) + sizeof(WCHAR);

    //
    // Set the value.
    //

    INIT_OBJA(&Obja,&UnicodeString,PRODUCT_SUITE_VALUE_NAME);

    Status = ZwSetValueKey(
                hSubKey,
                &UnicodeString,
                0,
                REG_MULTI_SZ,
                Buffer,
                BufferLength
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set value (%lx)\n",Status));
    }

    ZwClose(hSubKey);

    return Status;
}


NTSTATUS
SpCreateServiceEntryIndirect(
    IN  HANDLE  hKeyControlSetServices,
    IN  PVOID   SifHandle,                  OPTIONAL
    IN  PWSTR   SifSectionName,             OPTIONAL
    IN  PWSTR   KeyName,
    IN  ULONG   ServiceType,
    IN  ULONG   ServiceStart,
    IN  PWSTR   ServiceGroup,               OPTIONAL
    IN  ULONG   ServiceError,
    IN  PWSTR   FileName,                   OPTIONAL
    OUT PHANDLE SubkeyHandle                OPTIONAL
    )
{
    HANDLE hKeyService;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    PWSTR pwstr;

    //
    // Look in the sif file to get the subkey name within the
    // services list, unless the key name specified by the caller
    // is the actual key name.
    //
    if(SifHandle) {
        pwstr = SpGetSectionKeyIndex(SifHandle,SifSectionName,KeyName,INDEX_INFKEYNAME);
        if(!pwstr) {
            SpFatalSifError(SifHandle,SifSectionName,KeyName,0,INDEX_INFKEYNAME);
        }
        KeyName = pwstr;
    }

    //
    // Create the subkey in the services key.
    //
    INIT_OBJA(&Obja,&UnicodeString,KeyName);
    Obja.RootDirectory = hKeyControlSetServices;

    Status = ZwCreateKey(
                &hKeyService,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open/create key for %ws service (%lx)\n",KeyName,Status));
        return (Status) ;
    }

    //
    // Set the service type.
    //
    RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_TYPE);

    Status = ZwSetValueKey(
                hKeyService,
                &UnicodeString,
                0,
                ULONG_VALUE(ServiceType)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set service %ws Type (%lx)\n",KeyName,Status));
        goto spcsie1;
    }

    //
    // Set the service start type.
    //
    RtlInitUnicodeString(&UnicodeString,L"Start");

    Status = ZwSetValueKey(
                hKeyService,
                &UnicodeString,
                0,
                ULONG_VALUE(ServiceStart)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set service %ws Start (%lx)\n",KeyName,Status));
        goto spcsie1;
    }

    if( ServiceGroup != NULL ) {
        //
        // Set the service group name.
        //
        RtlInitUnicodeString(&UnicodeString,L"Group");

        Status = ZwSetValueKey(
                    hKeyService,
                    &UnicodeString,
                    0,
                    STRING_VALUE(ServiceGroup)
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set service %ws Group (%lx)\n",KeyName,Status));
            goto spcsie1;
        }
    }

    //
    // Set the service error type.
    //
    RtlInitUnicodeString(&UnicodeString,L"ErrorControl");

    Status = ZwSetValueKey(
                hKeyService,
                &UnicodeString,
                0,
                ULONG_VALUE(ServiceError)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set service %ws ErrorControl (%lx)\n",KeyName,Status));
        goto spcsie1;
    }

    //
    // If asked to do so, set the service image path.
    //
    if(FileName) {

        pwstr = TemporaryBuffer;
        wcscpy(pwstr,L"system32\\drivers");
        SpConcatenatePaths(pwstr,FileName);

        RtlInitUnicodeString(&UnicodeString,L"ImagePath");

        Status = ZwSetValueKey(hKeyService,&UnicodeString,0,STRING_VALUE(pwstr));

        if(!NT_SUCCESS(Status)) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set service %w image path (%lx)\n",KeyName,Status));
            goto spcsie1;
        }
    } else {
        if(NTUpgrade == UpgradeFull) {
            //
            // Delete imagepath on upgrade. This makes sure we are getting
            // our driver, and from the right place. Fixes Compaq's SSD stuff,
            // for example. Do something similar for PlugPlayServiceType, in case
            // we are renabling a device that the user disabled (in which case
            // the PlugPlayServiceType could cause us to fail to make up a
            // device instance for a legacy device, and cause the driver to fail
            // to load/initialize.
            //
            RtlInitUnicodeString(&UnicodeString,L"ImagePath");
            Status = ZwDeleteValueKey(hKeyService,&UnicodeString);
            if(!NT_SUCCESS(Status)) {
                if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to remove imagepath from service %ws (%lx)\n",KeyName,Status));
                }
                Status = STATUS_SUCCESS;
            }

            RtlInitUnicodeString(&UnicodeString,L"PlugPlayServiceType");
            Status = ZwDeleteValueKey(hKeyService,&UnicodeString);
            if(!NT_SUCCESS(Status)) {
                if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to remove plugplayservicetype from service %ws (%lx)\n",KeyName,Status));
                }
                Status = STATUS_SUCCESS;
            }
        }
    }

    //
    // If the caller doesn't want the handle to the service subkey
    // we just created, close the handle.  If we are returning an
    // error, always close it.
    //
spcsie1:
    if(NT_SUCCESS(Status) && SubkeyHandle) {
        *SubkeyHandle = hKeyService;
    } else {
        ZwClose(hKeyService);
    }

    //
    // Done.
    //
    return(Status);
}


NTSTATUS
SpThirdPartyRegistry(
    IN PVOID hKeyControlSetServices
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    HANDLE hKeyEventLogSystem;
    HwComponentType Component;
    PHARDWARE_COMPONENT Dev;
    PHARDWARE_COMPONENT_REGISTRY Reg;
    PHARDWARE_COMPONENT_FILE File;
    WCHAR NodeName[9];
    ULONG DriverType;
    ULONG DriverStart;
    ULONG DriverErrorControl;
    PWSTR DriverGroup;
    HANDLE hKeyService;

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\EventLog\System
    //
    INIT_OBJA(&Obja,&UnicodeString,L"EventLog\\System");
    Obja.RootDirectory = hKeyControlSetServices;

    Status = ZwCreateKey(
                &hKeyEventLogSystem,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpThirdPartyRegistry: couldn't open eventlog\\system (%lx)",Status));
        return(Status);
    }

    for(Component=0; Component<=HwComponentMax; Component++) {

        // no registry stuff applicable to keyboard layout
        if(Component == HwComponentLayout) {
            continue;
        }

        Dev = (Component == HwComponentMax)
            ? ((!PreInstall ||
                (PreinstallScsiHardware==NULL))? ScsiHardware :
                                                 PreinstallScsiHardware)
            : ((!PreInstall ||
                (PreinstallHardwareComponents[Component]==NULL))? HardwareComponents[Component] :
                                                                  PreinstallHardwareComponents[Component]);

        for( ; Dev; Dev = Dev->Next) {

            //
            // If there is no third-party option selected here, then skip
            // the component.
            //

            if(!Dev->ThirdPartyOptionSelected) {
                continue;
            }

            //
            // Iterate through the files for this device.  If a file has
            // a ServiceKeyName, create the key and add values in it
            // as appropriate.
            //

            for(File=Dev->Files; File; File=File->Next) {

                HwFileType filetype = File->FileType;
                PWSTR p;
                ULONG dw;

                //
                // If there is to be no node for this file, skip it.
                //
                if(!File->ConfigName) {
                    continue;
                }

                //
                // Calculate the node name.  This is the name of the driver
                // without the extension.
                //
                wcsncpy(NodeName,File->Filename,8);
                NodeName[8] = 0;
                if(p = wcschr(NodeName,L'.')) {
                    *p = 0;
                }

                //
                // The driver type and error control are always the same.
                //
                DriverType = SERVICE_KERNEL_DRIVER;
                DriverErrorControl = SERVICE_ERROR_NORMAL;

                //
                // The start type depends on the component.
                // For scsi, it's boot loader start.  For others, it's
                // system start.
                //
                DriverStart = (Component == HwComponentMax)
                            ? SERVICE_BOOT_START
                            : SERVICE_SYSTEM_START;

                //
                // The group depends on the component.
                //
                switch(Component) {

                case HwComponentDisplay:
                    DriverGroup = L"Video";
                    break;

                case HwComponentMouse:
                    if(filetype == HwFileClass) {
                        DriverGroup = L"Pointer Class";
                    } else {
                        DriverGroup = L"Pointer Port";
                    }
                    break;

                case HwComponentKeyboard:
                    if(filetype == HwFileClass) {
                        DriverGroup = L"Keyboard Class";
                    } else {
                        DriverGroup = L"Keyboard Port";
                    }
                    break;

                case HwComponentMax:
                    DriverGroup = L"SCSI miniport";
                    break;

                default:
                    DriverGroup = L"Base";
                    break;
                }

                //
                // Attempt to create the service entry.
                //
                Status = SpCreateServiceEntryIndirect(
                            hKeyControlSetServices,
                            NULL,
                            NULL,
                            NodeName,
                            DriverType,
                            DriverStart,
                            DriverGroup,
                            DriverErrorControl,
                            File->Filename,
                            &hKeyService
                            );

                if(!NT_SUCCESS(Status)) {
                    goto sp3reg1;
                }

                //
                // Create a default eventlog configuration.
                //
                Status = SpOpenSetValueAndClose(
                            hKeyEventLogSystem,
                            NodeName,
                            L"EventMessageFile",
                            REG_EXPAND_SZ,
                            DEFAULT_EVENT_LOG,
                            (wcslen(DEFAULT_EVENT_LOG)+1)*sizeof(WCHAR)
                            );

                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpThirdPartyRegistry: unable to set eventlog %ws EventMessageFile",NodeName));
                    ZwClose(hKeyService);
                    goto sp3reg1;
                }

                dw = 7;
                Status = SpOpenSetValueAndClose(
                                hKeyEventLogSystem,
                                NodeName,
                                L"TypesSupported",
                                ULONG_VALUE(dw)
                                );

                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpThirdPartyRegistry: unable to set eventlog %ws TypesSupported",NodeName));
                    ZwClose(hKeyService);
                    goto sp3reg1;
                }


                for(Reg=File->RegistryValueList; Reg; Reg=Reg->Next) {

                    //
                    // If the key name is null or empty, there is no key to create;
                    // use the load list node itself in this case.  Otherwise create
                    // the subkey in the load list node.
                    //

                    Status = SpOpenSetValueAndClose(
                                hKeyService,
                                (Reg->KeyName && *Reg->KeyName) ? Reg->KeyName : NULL,
                                Reg->ValueName,
                                Reg->ValueType,
                                Reg->Buffer,
                                Reg->BufferSize
                                );

                    if(!NT_SUCCESS(Status)) {

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                            "SETUP: SpThirdPartyRegistry: unable to set value %ws (%lx)\n",
                            Reg->ValueName,
                            Status
                            ));

                        ZwClose(hKeyService);
                        goto sp3reg1;
                    }
                }

                ZwClose(hKeyService);
            }
        }
    }

sp3reg1:

    ZwClose(hKeyEventLogSystem);
    return(Status);
}


NTSTATUS
SpDetermineProduct(
    IN  PDISK_REGION      TargetRegion,
    IN  PWSTR             SystemRoot,
    OUT PNT_PRODUCT_TYPE  ProductType,
    OUT ULONG             *MajorVersion,
    OUT ULONG             *MinorVersion,
    OUT ULONG             *BuildNumber,          OPTIONAL
    OUT ULONG             *ProductSuiteMask,
    OUT UPG_PROGRESS_TYPE *UpgradeProgressValue,
    OUT PWSTR             *UniqueIdFromReg,      OPTIONAL
    OUT PWSTR             *Pid,                  OPTIONAL
    OUT PBOOLEAN          pIsEvalVariation       OPTIONAL,
    OUT PLCID             LangId,
    OUT ULONG             *ServicePack            OPTIONAL
    )

{
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      UnicodeString;
    NTSTATUS            Status, TempStatus;
    PWSTR               Hive,HiveKey;
    PUCHAR              buffer;

    #define BUFFERSIZE (sizeof(KEY_VALUE_PARTIAL_INFORMATION)+256)

    BOOLEAN             HiveLoaded = FALSE;
    PWSTR               PartitionPath = NULL;
    PWSTR               p;
    HANDLE              hKeyRoot = NULL, hKeyCCSet = NULL;
    ULONG               ResultLength;
    ULONG               Number;
    ULONG               i;

    //
    // Allocate buffers.
    //
    Hive = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    HiveKey = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    buffer = SpMemAlloc(BUFFERSIZE);

    //
    // Get the name of the target partition.
    //
    SpNtNameFromRegion(
        TargetRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    PartitionPath = SpDupStringW(TemporaryBuffer);

    //
    // Load the system hive
    //

    wcscpy(Hive,PartitionPath);
    SpConcatenatePaths(Hive,SystemRoot);
    SpConcatenatePaths(Hive,L"system32\\config");
    SpConcatenatePaths(Hive,L"system");

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\x<hivename>.
    //

    wcscpy(HiveKey,LOCAL_MACHINE_KEY_NAME);
    SpConcatenatePaths(HiveKey,L"xSystem");

    //
    // Attempt to load the key.
    //
    Status = SpLoadUnloadKey(NULL,NULL,HiveKey,Hive);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load hive %ws to key %ws (%lx)\n",Hive,HiveKey,Status));
        goto spdp_1;
    }
    HiveLoaded = TRUE;


    //
    // Now get a key to the root of the hive we just loaded.
    //

    INIT_OBJA(&Obja,&UnicodeString,HiveKey);
    Status = ZwOpenKey(&hKeyRoot,KEY_ALL_ACCESS,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws (%lx)\n",HiveKey,Status));
        goto spdp_2;
    }

    //
    // Get the unique identifier if needed.
    // This value is not always present.
    //
    if(UniqueIdFromReg) {

        *UniqueIdFromReg = NULL;

        Status = SpGetValueKey(
                     hKeyRoot,
                     SETUP_KEY_NAME,
                     SIF_UNIQUEID,
                     BUFFERSIZE,
                     buffer,
                     &ResultLength
                     );

        if(NT_SUCCESS(Status)) {
            *UniqueIdFromReg = SpDupStringW((PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data));
        }
        // no error if not found.
    }

    //
    // See if this is a failed upgrade
    //
    *UpgradeProgressValue = UpgradeNotInProgress;
    Status = SpGetValueKey(
                 hKeyRoot,
                 SETUP_KEY_NAME,
                 UPGRADE_IN_PROGRESS,
                 BUFFERSIZE,
                 buffer,
                 &ResultLength
                 );

    if(NT_SUCCESS(Status)) {
        DWORD dw;
        if( (dw = *(DWORD *)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data)) < UpgradeMaxValue ) {
            *UpgradeProgressValue = (UPG_PROGRESS_TYPE)dw;
        }
    }

    //
    // Get the key to the current control set
    //
    Status = SpGetCurrentControlSetNumber(hKeyRoot,&Number);
    if(!NT_SUCCESS(Status)) {
        goto spdp_3;
    }

    swprintf((PVOID)buffer,L"ControlSet%03d",Number);
    INIT_OBJA(&Obja,&UnicodeString,(PVOID)buffer);
    Obja.RootDirectory = hKeyRoot;

    Status = ZwOpenKey(&hKeyCCSet,KEY_READ,&Obja);
    if(!NT_SUCCESS(Status)) {
        goto spdp_3;
    }

    //
    // Get the Product type field
    //

    Status = SpGetValueKey(
                 hKeyCCSet,
                 L"Control\\ProductOptions",
                 L"ProductType",
                 BUFFERSIZE,
                 buffer,
                 &ResultLength
                 );

    if(!NT_SUCCESS(Status)) {
        goto spdp_3;
    }

    if( _wcsicmp( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data), L"WinNT" ) == 0 ) {
        *ProductType = NtProductWinNt;
    } else if( _wcsicmp( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data), L"LanmanNt" ) == 0 ) {
        *ProductType = NtProductLanManNt;
    } else if( _wcsicmp( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data), L"ServerNt" ) == 0 ) {
        *ProductType = NtProductServer;
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: Error, unknown ProductType = %ls.  Assuming WinNt \n",
                  (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data) ));
        *ProductType = NtProductWinNt;
    }

    *ProductSuiteMask = 0;
    Status = SpGetValueKey(
                 hKeyCCSet,
                 L"Control\\ProductOptions",
                 L"ProductSuite",
                 BUFFERSIZE,
                 buffer,
                 &ResultLength
                 );

    if(NT_SUCCESS(Status)) {

        p = (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data);
        while (p && *p) {
            for (i = 0; i < CountProductSuiteNames; i++) {
                if (ProductSuiteNames[i] != NULL && _wcsicmp( p, ProductSuiteNames[i]) == 0) {
                    *ProductSuiteMask |= (1 << i);
                    break;
                }
            }

            p = p + wcslen(p) + 1;

        }
    } else {
        Status = SpGetValueKey(
                     hKeyCCSet,
                     L"Control\\Citrix",
                     L"OemId",
                     BUFFERSIZE,
                     buffer,
                     &ResultLength
                     );

        if (NT_SUCCESS(Status)) {
            PWSTR wbuff = (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data);
            if (*wbuff != L'\0') {
                *ProductSuiteMask |= VER_SUITE_TERMINAL;
            }
        }

    }

    if (LangId) {
      PWSTR EndChar;
      PWSTR Value = 0;

      //
      // Get the install language ID
      //
      Status = SpGetValueKey(
                   hKeyCCSet,
                   L"Control\\Nls\\Language",
                   L"InstallLanguage",
                   BUFFERSIZE,
                   buffer,
                   &ResultLength
                   );

      if (!NT_SUCCESS(Status) || !buffer || !ResultLength) {
        //
        // Try to get default Language ID if we can't get install
        // language ID
        //
        Status = SpGetValueKey(
                     hKeyCCSet,
                     L"Control\\Nls\\Language",
                     L"Default",
                     BUFFERSIZE,
                     buffer,
                     &ResultLength
                     );

        if (!NT_SUCCESS(Status) || !buffer || !ResultLength)
          goto spdp_3;
      }

      Value = (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data);
      *LangId = (LANGID)SpStringToLong(Value, &EndChar, 16); // hex base
    }

    //
    // Get the Eval variation flag
    //
    if (pIsEvalVariation) {
        *pIsEvalVariation = FALSE;

        Status = SpGetValueKey(
                    hKeyCCSet,
                    L"Control\\Session Manager\\Executive",
                    L"PriorityQuantumMatrix",
                    BUFFERSIZE,
                    buffer,
                    &ResultLength);

        if (NT_SUCCESS(Status)) {
            PKEY_VALUE_PARTIAL_INFORMATION  pValInfo =
                            (PKEY_VALUE_PARTIAL_INFORMATION)buffer;

            PBYTE   pData = (PBYTE)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data);

            //
            // Note : PriorityQantumMatix Value is made up of 3 ULONGS
            // Low Install Date&Time ULONG, Eval Duration (ULONG),
            // High Install Date&Time ULONG
            //
            if (pData && pValInfo && (pValInfo->Type == REG_BINARY) &&
                            (ResultLength >= 8) && *(((ULONG *)pData) + 1)) {
                *pIsEvalVariation = TRUE;
            }
        } else {
            // discard the error (NT 3.51 and below version does not have this key)
            Status = STATUS_SUCCESS;
        }
    }

    //
    // Get the ServicePack Number
    //
    if(ServicePack) {
        *ServicePack = 0;
        Status = SpGetValueKey(
                 hKeyCCSet,
                 L"Control\\Windows",
                 L"CSDVersion",
                 BUFFERSIZE,
                 buffer,
                 &ResultLength
                 );
        if (NT_SUCCESS(Status)) {
            PKEY_VALUE_PARTIAL_INFORMATION  pValInfo =
                            (PKEY_VALUE_PARTIAL_INFORMATION)buffer;

            if (pValInfo && pValInfo->Data && (pValInfo->Type == REG_DWORD)) {
                *ServicePack = ((*(PULONG)(pValInfo->Data)) >> 8 & (0xff)) * 100
                               + ((*(PULONG)(pValInfo->Data)) & 0xff);
            }
        } else {
            // discard the error
            Status = STATUS_SUCCESS;
        }
    }

    //
    // Close the hive key
    //

    ZwClose( hKeyCCSet );
    ZwClose( hKeyRoot );
    hKeyRoot = NULL;
    hKeyCCSet = NULL;

    //
    // Unload the system hive
    //

    TempStatus  = SpLoadUnloadKey(NULL,NULL,HiveKey,NULL);
    if(!NT_SUCCESS(TempStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: unable to unload key %ws (%lx)\n",HiveKey,TempStatus));
    }
    HiveLoaded = FALSE;

    //
    // Load the software hive
    //

    wcscpy(Hive,PartitionPath);
    SpConcatenatePaths(Hive,SystemRoot);
    SpConcatenatePaths(Hive,L"system32\\config");
    SpConcatenatePaths(Hive,L"software");

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\x<hivename>.
    //

    wcscpy(HiveKey,LOCAL_MACHINE_KEY_NAME);
    SpConcatenatePaths(HiveKey,L"x");
    wcscat(HiveKey,L"software");

    //
    // Attempt to load the key.
    //
    Status = SpLoadUnloadKey(NULL,NULL,HiveKey,Hive);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load hive %ws to key %ws (%lx)\n",Hive,HiveKey,Status));
        goto spdp_1;
    }
    HiveLoaded = TRUE;

    //
    // Now get a key to the root of the hive we just loaded.
    //

    INIT_OBJA(&Obja,&UnicodeString,HiveKey);
    Status = ZwOpenKey(&hKeyRoot,KEY_ALL_ACCESS,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws (%lx)\n",HiveKey,Status));
        goto spdp_2;
    }

    //
    // Query the version of the NT
    //

    Status = SpGetValueKey(
                 hKeyRoot,
                 L"Microsoft\\Windows NT\\CurrentVersion",
                 L"CurrentVersion",
                 BUFFERSIZE,
                 buffer,
                 &ResultLength
                 );

    //
    // Convert the version into a dword
    //

    {
        WCHAR wcsMajorVersion[] = L"0";
        WCHAR wcsMinorVersion[] = L"00";
        PWSTR Version = (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data);
        if( Version[0] && Version[1] && Version[2] ) {
            wcsMajorVersion[0] = Version[0];
            wcsMinorVersion[0] = Version[2];
            if( Version[3] ) {
                wcsMinorVersion[1] = Version[3];
            }
        }
        *MajorVersion = (ULONG)SpStringToLong( wcsMajorVersion, NULL, 10 );
        *MinorVersion = (ULONG)SpStringToLong( wcsMinorVersion, NULL, 10 );
    }

        //
        // EVAL variations on NT 5.0 are detected using MPC code
        // (This is to allow pre 5.0 RTM builds with timebomb to
        // upgrade properly
        //
    if (pIsEvalVariation && (*MajorVersion >= 5))
        *pIsEvalVariation = FALSE;

    //
    // Get build number
    //
    if(BuildNumber) {
        Status = SpGetValueKey(
                     hKeyRoot,
                     L"Microsoft\\Windows NT\\CurrentVersion",
                     L"CurrentBuildNumber",
                     BUFFERSIZE,
                     buffer,
                     &ResultLength
                     );

        *BuildNumber = NT_SUCCESS(Status)
                     ? (ULONG)SpStringToLong((PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data),NULL,10)
                     : 0;
    }



    //
    // Query the PID, if requested
    //

    if( Pid != NULL ) {
        TempStatus = SpGetValueKey(
                         hKeyRoot,
                         L"Microsoft\\Windows NT\\CurrentVersion",
                         L"ProductId",
                         BUFFERSIZE,
                         buffer,
                         &ResultLength
                         );

        if(!NT_SUCCESS(TempStatus)) {
            //
            //  If unable to read PID, assume empty string
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to query PID from hive %ws. Status = (%lx)\n",Hive,TempStatus));
            *Pid = SpDupStringW( L"" );
        } else {
            *Pid = SpDupStringW( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data) );
        }
    }

    //
    // Let the following do the cleaning up

spdp_3:

    if( hKeyCCSet ) {
        ZwClose( hKeyCCSet );
    }

    if( hKeyRoot ) {
        ZwClose(hKeyRoot);
    }


spdp_2:


    //
    // Unload the currently loaded hive.
    //

    if( HiveLoaded ) {
        TempStatus = SpLoadUnloadKey(NULL,NULL,HiveKey,NULL);
        if(!NT_SUCCESS(TempStatus)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: unable to unload key %ws (%lx)\n",HiveKey,TempStatus));
        }
    }

spdp_1:
    SpMemFree(PartitionPath);

    SpMemFree(Hive);
    SpMemFree(HiveKey);
    SpMemFree(buffer);

    return( Status );
#undef BUFFERSIZE
}

NTSTATUS
SpSetUpgradeStatus(
    IN  PDISK_REGION      TargetRegion,
    IN  PWSTR             SystemRoot,
    IN  UPG_PROGRESS_TYPE UpgradeProgressValue
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING    UnicodeString;
    NTSTATUS          Status, TempStatus;

    WCHAR   Hive[MAX_PATH], HiveKey[MAX_PATH];
    BOOLEAN HiveLoaded = FALSE;
    PWSTR   PartitionPath = NULL;
    HANDLE  hKeySystemHive;
    DWORD   dw;

    //
    // Get the name of the target patition.
    //
    SpNtNameFromRegion(
        TargetRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    PartitionPath = SpDupStringW(TemporaryBuffer);

    //
    // Load the system hive
    //

    wcscpy(Hive,PartitionPath);
    SpConcatenatePaths(Hive,SystemRoot);
    SpConcatenatePaths(Hive,L"system32\\config");
    SpConcatenatePaths(Hive,L"system");

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\x<hivename>.
    //

    wcscpy(HiveKey,LOCAL_MACHINE_KEY_NAME);
    SpConcatenatePaths(HiveKey,L"x");
    wcscat(HiveKey,L"system");

    //
    // Attempt to load the key.
    //
    Status = SpLoadUnloadKey(NULL,NULL,HiveKey,Hive);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load hive %ws to key %ws (%lx)\n",Hive,HiveKey,Status));
        goto spus_1;
    }
    HiveLoaded = TRUE;


    //
    // Now get a key to the root of the hive we just loaded.
    //

    INIT_OBJA(&Obja,&UnicodeString,HiveKey);
    Status = ZwOpenKey(&hKeySystemHive,KEY_ALL_ACCESS,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws (%lx)\n",HiveKey,Status));
        goto spus_2;
    }

    //
    // Set the upgrade status under the setup key.
    //

    dw = UpgradeProgressValue;
    Status = SpOpenSetValueAndClose(
                hKeySystemHive,
                SETUP_KEY_NAME,
                UPGRADE_IN_PROGRESS,
                ULONG_VALUE(dw)
                );

    //
    // Flush the key. Ignore the error
    //
    TempStatus = ZwFlushKey(hKeySystemHive);
    if(!NT_SUCCESS(TempStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwFlushKey %ws failed (%lx)\n",HiveKey,Status));
    }


    //
    // Close the hive key
    //
    ZwClose( hKeySystemHive );
    hKeySystemHive = NULL;

    //
    // Unload the system hive
    //

    TempStatus  = SpLoadUnloadKey(NULL,NULL,HiveKey,NULL);
    if(!NT_SUCCESS(TempStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: unable to unload key %ws (%lx)\n",HiveKey,TempStatus));
    }
    HiveLoaded = FALSE;

spus_2:

    //
    // Unload the currently loaded hive.
    //

    if( HiveLoaded ) {
        TempStatus = SpLoadUnloadKey(NULL,NULL,HiveKey,NULL);
        if(!NT_SUCCESS(TempStatus)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: unable to unload key %ws (%lx)\n",HiveKey,TempStatus));
        }
    }

spus_1:
    SpMemFree(PartitionPath);
    return( Status );

}


NTSTATUS
SpGetCurrentControlSetNumber(
    IN  HANDLE SystemHiveRoot,
    OUT PULONG Number
    )

/*++

Routine Description:

    This routine determines the ordinal number of the "current" control set
    as indicated by the values in a SELECT key at the root of a system hive.

Arguments:

    SystemHiveRoot - supplies an open key to the a key which is to be
        considered the root of a system hive.

    Number - If the routine is successful, recieves the ordinal number of
        the "current" control set in that system hive.

Return Value:

    NT Status value indicating outcome.

--*/

{
    NTSTATUS Status;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+256];
    ULONG ResultLength;

    Status = SpGetValueKey(
                 SystemHiveRoot,
                 L"Select",
                 L"Current",
                 sizeof(buffer),
                 buffer,
                 &ResultLength
                 );

    if(NT_SUCCESS(Status)) {
        *Number = *(DWORD *)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data);
    }

    return(Status);
}


NTSTATUS
SpCreateControlSetSymbolicLink(
    IN  HANDLE  SystemHiveRoot,
    OUT HANDLE *CurrentControlSetRoot
    )

/*++

Routine Description:

    This routine creates a CurrentControlSet symbolic link, whose target
    is the appropriate ControlSetxxx key within a given system hive.

    The symbolic link is created volatile.

Arguments:

    SystemHiveRoot - supplies a handle to a key that is to be considered
        the root key of a system hive.

    CurrentControlSetRoot - if this routine is successful then this receives
        a handle to the open root key of the current control set, with
        KEY_ALL_ACCESS.

Return Value:

    NT status code indicating outcome.

--*/

{
    NTSTATUS Status;
    ULONG Number;
    HANDLE KeyHandle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    WCHAR name[50];

    //
    // First we need to figure out which control set is the "current" one.
    // In the upgrade case we need to get it from looking at the existing
    // hive; in the fresh install case it's always 1.
    //
    if(NTUpgrade == UpgradeFull) {
        Status = SpGetCurrentControlSetNumber(SystemHiveRoot,&Number);
        if(!NT_SUCCESS(Status)) {
            return(Status);
        }
    } else {
        Number = 1;

        //
        // HACK: In the fresh install case we need to make sure that there is
        // a ControlSet001 value to link to! There won't be one when we get here
        // because we didn't run any infs yet.
        //
        RtlInitUnicodeString(&UnicodeString,L"ControlSet001");

        InitializeObjectAttributes(
            &Obja,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            SystemHiveRoot,
            NULL
            );

        Status = ZwCreateKey(
                    &KeyHandle,
                    KEY_QUERY_VALUE,
                    &Obja,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    NULL
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: can't create ControlSet001 key (%lx)\n",Status));
            return(Status);
        }

        ZwClose(KeyHandle);
    }

    //
    // Create CurrentControlSet for create-link access.
    //
    RtlInitUnicodeString(&UnicodeString,L"CurrentControlSet");

    InitializeObjectAttributes(
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        SystemHiveRoot,
        NULL
        );

    Status = ZwCreateKey(
                &KeyHandle,
                KEY_CREATE_LINK,
                &Obja,
                0,
                NULL,
                REG_OPTION_VOLATILE | REG_OPTION_CREATE_LINK,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: can't create CurrentControlSet symbolic key (%lx)\n",Status));
        return(Status);
    }

    //
    // Now set the value value in there. If the swprintf changes, make sure
    // the name buffer is large enough!
    //
    swprintf(name,L"\\Registry\\Machine\\xSystem\\ControlSet%03d",Number);
    RtlInitUnicodeString(&UnicodeString,L"SymbolicLinkValue");

    Status = ZwSetValueKey(KeyHandle,&UnicodeString,0,REG_LINK,name,wcslen(name)*sizeof(WCHAR));
    ZwClose(KeyHandle);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set SymbolicLinkValue for CurrentControlSet to %ws (%lx)\n",name,Status));
    } else {
        //
        // Finally, open a handle to the key.
        //
        INIT_OBJA(&Obja,&UnicodeString,name);
        Status = ZwOpenKey(CurrentControlSetRoot,KEY_ALL_ACCESS,&Obja);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open control set root %ws (%lx)\n",name,Status));
        }
    }

    return(Status);
}


NTSTATUS
SpAppendStringToMultiSz(
    IN HANDLE hKey,
    IN PWSTR  Subkey,
    IN PWSTR  ValueName,
    IN PWSTR  StringToAdd
    )
{
    NTSTATUS Status;
    ULONG Length;
    PUCHAR Data;

    Status = SpGetValueKey(
                hKey,
                Subkey,
                ValueName,
                sizeof(TemporaryBuffer),
                (PCHAR)TemporaryBuffer,
                &Length
                );

    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    Data   = ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data;
    Length = ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength;

    //
    // Stick on end. For a multi_sz there has to be at least
    // the terminating nul, but just to be safe we'll be robust.
    //
    ASSERT(Length);
    if(!Length) {
        *(PWCHAR)Data = 0;
        Length = sizeof(WCHAR);
    }

    //
    // Append new string to end and add new terminating 0.
    //
    wcscpy((PWSTR)(Data+Length-sizeof(WCHAR)),StringToAdd);
    Length += (wcslen(StringToAdd)+1)*sizeof(WCHAR);
    *(PWCHAR)(Data+Length-sizeof(WCHAR)) = 0;

    //
    // Write back out to registry.
    //
    Status = SpOpenSetValueAndClose(
                hKey,
                Subkey,
                ValueName,
                REG_MULTI_SZ,
                Data,
                Length
                );

    return(Status);
}

NTSTATUS
SpRemoveStringFromMultiSz(
    IN HANDLE KeyHandle,
    IN PWSTR  SubKey OPTIONAL,
    IN PWSTR  ValueName,
    IN PWSTR  StringToRemove
    )
/*++

Routine Description:

    Removes the specified string from the given multi_sz value.

Arguments:

    KeyHandle - The handle to the key which contains the value or
        the SubKey.

    SubKey - The subkey name which contains the value.

    ValueName - The value name which is under the SubKey or the 
        Key reachable by KeyHandle.

    StringToRemove - The string that needs to be removed from
        from the multi_sz strings.
        
Return Value:

    Appropriate NT status error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    //
    // Validate parameters
    //
    if (KeyHandle && ValueName && StringToRemove) {
        HANDLE NewKeyHandle = KeyHandle;
        HANDLE SubKeyHandle = NULL;

        Status = STATUS_SUCCESS;

        //
        // Open the subkey if needed
        //
        if (SubKey) {            
            UNICODE_STRING SubKeyName;
            OBJECT_ATTRIBUTES ObjAttrs;
            
            INIT_OBJA(&ObjAttrs, &SubKeyName, SubKey);
            ObjAttrs.RootDirectory = KeyHandle;

            Status = ZwOpenKey(&SubKeyHandle,
                        KEY_ALL_ACCESS,
                        &ObjAttrs);

            if (NT_SUCCESS(Status)) {
                NewKeyHandle = SubKeyHandle;
            }
        }

        if (NT_SUCCESS(Status)) {                
            ULONG ResultLength = 0;
            PWSTR Buffer = NULL;
            ULONG BufferLength = 0;
            UNICODE_STRING ValueNameStr;

            RtlInitUnicodeString(&ValueNameStr, ValueName);
            
            Status = ZwQueryValueKey(NewKeyHandle,
                        &ValueNameStr,
                        KeyValueFullInformation,
                        NULL,
                        0,
                        &ResultLength);

            //
            // Is there something to process ?
            //
            if (ResultLength && 
                (Status == STATUS_BUFFER_OVERFLOW) || (Status == STATUS_BUFFER_TOO_SMALL)) {
                //
                // Allocate adequate buffer 
                //
                BufferLength = ResultLength + (2 * sizeof(WCHAR));
                Buffer = (PWSTR)SpMemAlloc(BufferLength);                

                if (Buffer) {
                    PKEY_VALUE_FULL_INFORMATION ValueInfo;
                    
                    //
                    // Get the current value
                    //
                    ValueInfo = (PKEY_VALUE_FULL_INFORMATION)Buffer;

                    Status = ZwQueryValueKey(NewKeyHandle,
                                &ValueNameStr,
                                KeyValueFullInformation,
                                ValueInfo,
                                BufferLength,
                                &ResultLength);

                    if (NT_SUCCESS(Status)) {
                        //
                        // Verify that its REG_MULTI_SZ or REG_SZ type
                        // NOTE : We allow REG_SZ also since in some W2K installations
                        // the string type is REG_SZ for class upperfilters & lowerfilters
                        //
                        if ((ValueInfo->Type == REG_MULTI_SZ) ||
                             (ValueInfo->Type == REG_SZ)){
                            PWSTR CurrString = (PWSTR)(((PUCHAR)ValueInfo + ValueInfo->DataOffset));
                            BOOLEAN Found = FALSE;
                            ULONG BytesToProcess = ValueInfo->DataLength;
                            ULONG BytesProcessed;
                            ULONG Length;

                            //
                            // null terminate the string (we allocated enough buffer space above)
                            //
                            CurrString[ValueInfo->DataLength/sizeof(WCHAR)] = UNICODE_NULL;
                            CurrString[(ValueInfo->DataLength/sizeof(WCHAR))+1] = UNICODE_NULL;

                            //
                            // Search for an occurrence of the string to replace
                            //
                            for (BytesProcessed = 0; 
                                (!Found && (BytesProcessed < BytesToProcess));
                                CurrString += (Length + 1), BytesProcessed += ((Length + 1) * sizeof(WCHAR))) 
                            {

                                Length = wcslen(CurrString);
                                
                                if (Length && !_wcsicmp(CurrString, StringToRemove)) {
                                    Found = TRUE;
                                }
                            } 

                            if (Found) {
                                //
                                // We found an occurrence -- allocate new buffer to selectively
                                // copy the required information from the old string
                                //
                                PWSTR   NewString = (PWSTR)(SpMemAlloc(ValueInfo->DataLength));

                                if (NewString) {
                                    PWSTR CurrDestString = NewString;
                                    
                                    RtlZeroMemory(NewString, ValueInfo->DataLength);
                                    CurrString = (PWSTR)(((PUCHAR)ValueInfo + ValueInfo->DataOffset));
                                    CurrString[ValueInfo->DataLength/sizeof(WCHAR)] = UNICODE_NULL;
                                    CurrString[(ValueInfo->DataLength/sizeof(WCHAR))+1] = UNICODE_NULL;
                                    
                                    //
                                    // Copy all the strings except the one's to skip
                                    //
                                    for (BytesProcessed = 0; 
                                        (BytesProcessed < BytesToProcess);
                                        CurrString += (Length + 1), BytesProcessed += ((Length + 1) * sizeof(WCHAR)))
                                    {                                            
                                        Length = wcslen(CurrString);                                    
                                        
                                        //                                            
                                        // copy the unmatched non-empty source string to destination
                                        //
                                        if (Length && (_wcsicmp(CurrString, StringToRemove))) {
                                            wcscpy(CurrDestString, CurrString);
                                            CurrDestString += (Length + 1);
                                        }                                        
                                    } 

                                    //
                                    // Set the string back if its not empty
                                    //
                                    if (CurrDestString != NewString) {
                                        *CurrDestString++ = UNICODE_NULL;

                                        //
                                        // Set the new value back
                                        //
                                        Status = ZwSetValueKey(NewKeyHandle,
                                                    &ValueNameStr,
                                                    0,
                                                    REG_MULTI_SZ,
                                                    NewString,
                                                    ((CurrDestString - NewString) * sizeof(WCHAR)));
                                    } else {
                                        //
                                        // Remove the empty value
                                        //
                                        Status = ZwDeleteValueKey(NewKeyHandle,
                                                    &ValueNameStr);
                                    }                                        

                                    //
                                    // done with the buffer
                                    //
                                    SpMemFree(NewString);
                                } else {
                                    Status = STATUS_NO_MEMORY;
                                }                            
                            } else {
                                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                            }                        
                        } else {
                            Status = STATUS_INVALID_PARAMETER;
                        }                        
                    }                

                    SpMemFree(Buffer);
                } else {
                    Status = STATUS_NO_MEMORY;
                }                    
            }                
        }

        if (SubKeyHandle) {
            ZwClose(SubKeyHandle);
        }
    }

    return Status;
}

NTSTATUS
SpGetValueKey(
    IN  HANDLE     hKeyRoot,
    IN  PWSTR      KeyName,
    IN  PWSTR      ValueName,
    IN  ULONG      BufferLength,
    OUT PUCHAR     Buffer,
    OUT PULONG     ResultLength
    )
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    HANDLE hKey = NULL;

    //
    // Open the key for read access
    //

    INIT_OBJA(&Obja,&UnicodeString,KeyName);
    Obja.RootDirectory = hKeyRoot;
#if 0
KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "+ [spconfig.c:%lu] KeyName %ws\n", __LINE__, KeyName ));
KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "+ [spconfig.c:%lu] ValueName %ws\n", __LINE__, UnicodeString ));

KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "+ [spconfig.c:%lu] UnicodeString %ws\n", __LINE__, UnicodeString ));
KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "+ [spconfig.c:%lu] UnicodeString %S\n", __LINE__, UnicodeString ));
#endif

    Status = ZwOpenKey(&hKey,KEY_READ,&Obja);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpGetValueKey: couldn't open key %ws for read access (%lx)\n",KeyName, Status));
    }
    else {
        //
        // Find out the value of the Current value
        //

        RtlInitUnicodeString(&UnicodeString,ValueName);
        Status = ZwQueryValueKey(
                    hKey,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    Buffer,
                    BufferLength,
                    ResultLength
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpGetValueKey: couldn't query value %ws in key %ws (%lx)\n",ValueName,KeyName,Status));
        }
    }

    if( hKey ) {
        ZwClose( hKey );
    }
    return( Status );

}

NTSTATUS
SpDeleteValueKey(
    IN  HANDLE     hKeyRoot,
    IN  PWSTR      KeyName,
    IN  PWSTR      ValueName
    )
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    HANDLE hKey = NULL;

    //
    // Open the key for read access
    //

    INIT_OBJA(&Obja,&UnicodeString,KeyName);
    Obja.RootDirectory = hKeyRoot;
    Status = ZwOpenKey(&hKey,KEY_SET_VALUE,&Obja);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpDeleteValueKey: couldn't open key %ws for write access (%lx)\n",KeyName, Status));
    }
    else {
        //
        // Find out the value of the Current value
        //

        RtlInitUnicodeString(&UnicodeString,ValueName);
        Status = ZwDeleteValueKey(
                    hKey,
                    &UnicodeString
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpDeleteValueKey: couldn't delete value %ws in key %ws (%lx)\n",ValueName,KeyName,Status));
        }
    }

    if( hKey ) {
        ZwClose( hKey );
    }
    return( Status );

}



BOOLEAN
SpReadSKUStuff(
    VOID
    )

/*++

Routine Description:

    Read SKU differentiation data from the setup hive we are currently
    running on.

    In the unnamed key of our driver node, there is a REG_BINARY that
    tells us whether this is stepup mode, and/or whether this is an
    evaluation unit (gives us the time in minutes).

Arguments:

    None.

Return Value:

    Boolean value indicating outcome.
    If TRUE, StepUpMode and EvaluationTime globals are filled in.
    If FALSE, product may have been tampered with.

--*/

{
    NTSTATUS Status;
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo;
    PULONG Values;
    ULONG ResultLength;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HKEY Key;



    INIT_OBJA(&Obja,&UnicodeString,LOCAL_MACHINE_KEY_NAME);
    Status = ZwOpenKey(&Key,KEY_READ,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to open %ws (Status = %lx)\n",LOCAL_MACHINE_KEY_NAME,Status));
        return(FALSE);
    }

    Status = SpGetValueKey(
                 Key,
                 L"System\\ControlSet001\\Services\\setupdd",
                 L"",
                 sizeof(TemporaryBuffer),
                 (PCHAR)TemporaryBuffer,
                 &ResultLength
                 );

    ZwClose(Key);

    ValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer;

    //
    // This line of code depends on the setup hive setupreg.hiv
    // (see oak\bin\setupreg.ini).
    //
    if(NT_SUCCESS(Status) && (ValueInfo->Type == REG_BINARY) && (ValueInfo->DataLength == 16)) {

        Values = (PULONG)ValueInfo->Data;

        //
        // First DWORD is eval time, second is stepup boolean, third is restric cpu val, fourth is suite
        //
        EvaluationTime = Values[0];
        StepUpMode = (BOOLEAN)Values[1];
        RestrictCpu = Values[2];
        SuiteType = Values[3];

        return(TRUE);
    }

    return(FALSE);
}

VOID
SpSetDirtyShutdownFlag(
    IN  PDISK_REGION    TargetRegion,
    IN  PWSTR           SystemRoot
    )
{
    NTSTATUS            Status;
    PWSTR               HiveRootPath;
    PWSTR               HiveFilePath;
    BOOLEAN             HiveLoaded;
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      UnicodeString;
    HANDLE              HiveRootKey;
    UCHAR               buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(DISK_CONFIG_HEADER)];
    ULONG               ResultLength;
    PDISK_CONFIG_HEADER DiskHeader;

    //
    // Get the name of the target patition.
    //
    SpNtNameFromRegion(
        TargetRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    //
    // Form the name of the hive file.
    // This is partitionpath + sysroot + system32\config + the hive name.
    //
    SpConcatenatePaths(TemporaryBuffer, SystemRoot);
    SpConcatenatePaths(TemporaryBuffer,L"system32\\config\\system");
    HiveFilePath = SpDupStringW(TemporaryBuffer);

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\x<hivename>.
    //
    wcscpy(TemporaryBuffer,LOCAL_MACHINE_KEY_NAME);
    SpConcatenatePaths(TemporaryBuffer,L"x");
    wcscat(TemporaryBuffer,L"system");
    HiveRootPath = SpDupStringW(TemporaryBuffer);
    ASSERT(HiveRootPath);

    //
    // Attempt to load the key.
    //
    HiveLoaded = FALSE;
    Status = SpLoadUnloadKey(NULL,NULL,HiveRootPath,HiveFilePath);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load hive %ws to key %ws (%lx)\n",HiveFilePath,HiveRootPath,Status));
        goto setdirty1;
    }

    HiveLoaded = TRUE;

    //
    // Now get a key to the root of the hive we just loaded.
    //
    INIT_OBJA(&Obja,&UnicodeString,HiveRootPath);
    Status = ZwOpenKey(&HiveRootKey,KEY_ALL_ACCESS,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws (%lx)\n",HiveRootPath,Status));
        goto setdirty1;
    }

    //
    //  Make the appropriate change
    //

    Status = SpGetValueKey(
                 HiveRootKey,
                 L"DISK",
                 L"Information",
                 sizeof(TemporaryBuffer),
                 (PCHAR)TemporaryBuffer,
                 &ResultLength
                 );

    //
    //  TemporaryBuffer is 32kb long, and it should be big enough
    //  for the data.
    //
    ASSERT( Status != STATUS_BUFFER_OVERFLOW );
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to read value from registry. KeyName = Disk, ValueName = Information, Status = (%lx)\n",Status));
        goto setdirty1;
    }

    DiskHeader = ( PDISK_CONFIG_HEADER )(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data);
    DiskHeader->DirtyShutdown = TRUE;

    Status = SpOpenSetValueAndClose( HiveRootKey,
                                     L"DISK",
                                     L"Information",
                                     REG_BINARY,
                                     DiskHeader,
                                     ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength
                                   );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write value to registry. KeyName = Disk, ValueName = Information, Status = (%lx)\n",Status));
        goto setdirty1;
    }

setdirty1:

    //
    // Flush the hive.
    //

    if(HiveLoaded && HiveRootKey) {
        NTSTATUS stat;

        stat = ZwFlushKey(HiveRootKey);
        if(!NT_SUCCESS(stat)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwFlushKey x%ws failed (%lx)\n", HiveRootPath, Status));
        }
    }

    if(HiveLoaded) {

        //
        // We don't want to disturb the value of Status
        // so use a we'll different variable below.
        //
        NTSTATUS stat;

        if(HiveRootKey!=NULL) {
            ZwClose(HiveRootKey);
            HiveRootKey = NULL;
        }

        //
        // Unload the hive.
        //
        stat = SpLoadUnloadKey(NULL,NULL,HiveRootPath,NULL);

        if(!NT_SUCCESS(stat)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: unable to unload key %ws (%lx)\n",HiveRootPath,stat));
        }

        HiveLoaded = FALSE;
    }

    SpMemFree(HiveRootPath);
    SpMemFree(HiveFilePath);

    //
    //  If we fail to set the DirtyShutdown flag, then we silently fail
    //  because there is nothing that the user can do about, and the system
    //  is unlikely to boot anyway.
    //  This will occur if setup fails to:
    //
    //      - Load the system hive
    //      - Open System\Disk key
    //      - Read the value entry
    //      - Write the value entry
    //      - Unload the system hive
    //
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: setup was unable to set DirtyShutdown flag. Status =   (%lx)\n", Status));
    }
}


NTSTATUS
SpPostprocessHives(
    IN PWSTR     PartitionPath,
    IN PWSTR     Sysroot,
    IN PCWSTR   *HiveNames,
    IN HANDLE   *HiveRootKeys,
    IN unsigned  HiveCount,
    IN HANDLE    hKeyCCS
    )
{
    NTSTATUS Status;
    ULONG u;
    unsigned h;
    PWSTR SaveHiveName;
    PWSTR HiveName;
    HANDLE SaveHiveHandle;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_ATTRIBUTES ObjectAttributes2;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING UnicodeString2;
    DWORD MangledVersion;
    PWSTR Value;
    PWSTR   SecurityHives[] = {
                              L"sam",
                              L"security"
                              };
    //
    // Flush all hives.
    //
    for(h=0; h<HiveCount; h++) {
        Status = ZwFlushKey(HiveRootKeys[h]);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Warning: ZwFlushKey %ws failed (%lx)\n",HiveNames[h],Status));
        }

        SendSetupProgressEvent(SavingSettingsEvent, SaveHiveEvent, NULL);
    }

    //
    // If GUI setup is supposed to be restartable, we need to add an entry
    // to the BootExecute list, to cause sprestrt.exe to run.
    // Also, we want system.sav to have a RestartSetup=TRUE value in it,
    // but we want the actual system hive to have RestartSetup=FALSE.
    //
    if(RestartableGuiSetup) {

        Status = SpAppendStringToMultiSz(
                    hKeyCCS,
                    SESSION_MANAGER_KEY,
                    BOOT_EXECUTE,
                    L"sprestrt"
                    );



        if(NT_SUCCESS(Status)) {
            //
            // Add a RestartSetup value, set to TRUE.
            // To understand why we use a different value here in upgrade
            // and non-upgrade case, see discussion below.
            //
            u = (NTUpgrade == UpgradeFull) ? 0 : 1;
            Status = SpOpenSetValueAndClose(
                        HiveRootKeys[SetupHiveSystem],
                        SETUP_KEY_NAME,
                        RESTART_SETUP,
                        ULONG_VALUE(u)
                        );
        }
    } else {
        Status = STATUS_SUCCESS;
    }

    //
    // Do the final update of device instance data.
    //
    if((NTUpgrade == UpgradeFull)) {
        //
        // SANTOSHJ: This whole code needs to go away for BLACKCOMB.
        //
        Value = SpGetSectionKeyIndex(WinntSifHandle,
                                    SIF_DATA, WINNT_D_WIN32_VER_W, 0);
        if(Value) {
            //
            // version is bbbbllhh - build/low/high
            //
            MangledVersion = (DWORD)SpStringToLong( Value, NULL, 16 );
            if (LOWORD(MangledVersion) == 0x0105) {

                Status = SpUpdateDeviceInstanceData(hKeyCCS);
                if (!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not update device instance data. Status = (%lx)\n",Status));
                    return(Status);
                }
            }
        }
    }

    //
    //  At this point, we no longer need hKeyCCS, so we close the key.
    //  Note that key needs to be closed before we call ZwReplaceKey, otherwise
    //  this API will fail.
    //
    //  Note also, that the caller of this function expects this function to close this handle
    //  before it returns.
    //
    NtClose(hKeyCCS);

    if(NT_SUCCESS(Status)) {
        //
        // Save out the hives to *.sav in the initial install case,
        // or *.tmp in the upgrade case.
        //
        for(h=0; NT_SUCCESS(Status) && (h<HiveCount); h++) {
            //
            // Form full pathname of hive file.
            //
            wcscpy(TemporaryBuffer,PartitionPath);
            SpConcatenatePaths(TemporaryBuffer,Sysroot);
            SpConcatenatePaths(TemporaryBuffer,L"system32\\config");
            SpConcatenatePaths(TemporaryBuffer,HiveNames[h]);
            wcscat(TemporaryBuffer,(NTUpgrade == UpgradeFull) ? L".tmp" : L".sav");

            SaveHiveName = SpDupStringW(TemporaryBuffer);

            SpDeleteFile( SaveHiveName, NULL, NULL ); // Make sure that we get rid of the file if it has attributes.

            INIT_OBJA(&ObjectAttributes,&UnicodeString,SaveHiveName);

            Status = ZwCreateFile(
                        &SaveHiveHandle,
                        FILE_GENERIC_WRITE,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        0,                      // no sharing
                        FILE_OVERWRITE_IF,
                        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL,
                        0
                        );

            if(NT_SUCCESS(Status)) {

                //
                // call the Ex version to make sure the hive is saved in the lates format
                //
                Status = ZwSaveKeyEx(HiveRootKeys[h],SaveHiveHandle,REG_LATEST_FORMAT);
                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: save key into %ws failed (%lx)\n",SaveHiveName,Status));
                }

                ZwClose(SaveHiveHandle);

            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to create file %ws to save hive (%lx)\n",SaveHiveName,Status));
            }

            //
            // In the upgrade case, there is significant benefit to ensuring that
            // the hives are in the latest format. A hive that has been created
            // via NtSaveKeyEx(...,...,REG_LATEST_FORMAT) is guaranteed to be in the latest format.
            // Since we just did a SaveKey, xxx.tmp is in the latest format,
            // and we should use that as the xxx hive from now on. The existing
            // (old-format) hive can be retained as xxx.sav.
            //
            // NtReplaceKey does exactly what we want, but we have to make sure
            // that there is no .sav file already there, because that causes
            // NtReplaceKey to fail with STATUS_OBJECT_NAME_COLLISION.
            //
            // After NtReplaceKey is done, the hive root keys refer to the .sav
            // on-disk file but the extensionless on-disk file will be used at next
            // boot. Thus we need to be careful about how we write the restart values
            // into the hives.
            //
            if(NT_SUCCESS(Status) && (NTUpgrade == UpgradeFull)) {

                HiveName = SpDupStringW(SaveHiveName);
                wcscpy(HiveName+wcslen(HiveName)-3,L"sav");

                SpDeleteFile(HiveName,NULL,NULL);

                INIT_OBJA(&ObjectAttributes,&UnicodeString,SaveHiveName);
                INIT_OBJA(&ObjectAttributes2,&UnicodeString2,HiveName);

                Status = ZwReplaceKey(&ObjectAttributes,HiveRootKeys[h],&ObjectAttributes2);
            }

            SpMemFree(SaveHiveName);
        }
    }

    if(NT_SUCCESS(Status) && (NTUpgrade == UpgradeFull)) {
        //
        // In the upgarde case, make a backup of the security
        // hives. They need to be restored if the system is restartable.
        //

        //
        // Initialize the diamond decompression engine.
        // This needs to be done, because SpCopyFileUsingNames() uses
        // the decompression engine.
        //
        SpdInitialize();

        for( h = 0; h < sizeof(SecurityHives)/sizeof(PWSTR); h++ ) {
            PWSTR   p, q;

            wcscpy(TemporaryBuffer,PartitionPath);
            SpConcatenatePaths(TemporaryBuffer,Sysroot);
            SpConcatenatePaths(TemporaryBuffer,L"system32\\config");
            SpConcatenatePaths(TemporaryBuffer,SecurityHives[h]);
            p = SpDupStringW(TemporaryBuffer);
            wcscat(TemporaryBuffer, L".sav");
            q = SpDupStringW(TemporaryBuffer);
            Status = SpCopyFileUsingNames( p, q, 0, 0 );
            if( !NT_SUCCESS(Status) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to create backup file %ws. Status = %lx\n", q, Status));
            }
            SpMemFree(p);
            SpMemFree(q);
            if( !NT_SUCCESS(Status) ) {
                break;
            }
        }
        //
        // Terminate diamond.
        //
        SpdTerminate();
    }


    if(NT_SUCCESS(Status) && RestartableGuiSetup) {
        //
        // Set RestartSetup to FALSE in mainline hive.
        // To understand why we use a different value here in upgrade
        // and non-upgrade case, see discussion above.
        //
        u = (NTUpgrade == UpgradeFull) ? 1 : 0;
        Status = SpOpenSetValueAndClose(
                    HiveRootKeys[SetupHiveSystem],
                    SETUP_KEY_NAME,
                    RESTART_SETUP,
                    ULONG_VALUE(u)
                    );
    }

    return(Status);
}


NTSTATUS
SpSaveSetupPidList(
    IN HANDLE hKeySystemHive
    )

/*++

Routine Description:

    Save the Product Id read from setup.ini on HKEY_LOCAL_MACHINE\SYSTEM\Setup\\Pid.
    Also create the key HKEY_LOCAL_MACHINE\SYSTEM\Setup\PidList, and create
    value entries under this key that contain various Pid20 found in the other
    systems installed on this machine (the contents Pid20Array).

Arguments:

    hKeySystemHive - supplies handle to root of the system hive
        (ie, HKEY_LOCAL_MACHINE\System).


Return Value:

    Status value indicating outcome of operation.

--*/

{
    PWSTR    ValueName;
    NTSTATUS Status;
    ULONG    i;

    //
    //  First save the Pid read from setup.ini
    //
    if( PidString != NULL ) {
        Status = SpOpenSetValueAndClose( hKeySystemHive,
                                         L"Setup\\Pid",
                                         L"Pid",
                                         STRING_VALUE(PidString)
                                       );
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to save Pid on SYSTEM\\Setup\\Pid. Status = %lx\n", Status ));
        }
    }

    //
    //  If Pid20Array is empty, then don't bother to create the Pid key
    //
    if( Pid20Array == NULL || Pid20Array[0] == NULL ) {
        return( STATUS_SUCCESS );
    }

    //
    // Can't use TemporaryBuffer because we make subroutine calls
    // below that trash its contents.
    // Note that a buffer of size MAX_PATH for a value name is more than enough.
    //
    ValueName = SpMemAlloc((MAX_PATH+1)*sizeof(WCHAR));

    for( i = 0; Pid20Array[i] != NULL; i++ ) {

        swprintf( ValueName, L"Pid_%d", i );
        Status = SpOpenSetValueAndClose( hKeySystemHive,
                                         L"Setup\\PidList",
                                         ValueName,
                                         STRING_VALUE(Pid20Array[i])
                                       );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open or create SYSTEM\\Setup\\PidList. ValueName = %ws, ValueData = %ws, Status = %lx\n",
                     ValueName, Pid20Array[i] ));
        }
    }
    SpMemFree(ValueName);
    return( STATUS_SUCCESS );
}


NTSTATUS
SpSavePreinstallHwInfo(
    IN PVOID  SifHandle,
    IN PWSTR  SystemRoot,
    IN HANDLE hKeyPreinstall,
    IN ULONG  ComponentIndex,
    IN PHARDWARE_COMPONENT  pHwList
    )
{
    NTSTATUS Status;
    NTSTATUS SaveStatus;
    PHARDWARE_COMPONENT TmpHw;
    PHARDWARE_COMPONENT_FILE File;
    PWSTR   OemTag = L"OemComponent";
    PWSTR   RetailClass = L"RetailClassToDisable";
    PWSTR   ClassName;
    ULONG u;
    WCHAR NodeName[9];
    PWSTR   ServiceName;

    SaveStatus = STATUS_SUCCESS;
    for( TmpHw = pHwList; TmpHw != NULL; TmpHw = TmpHw->Next ) {
        if( !TmpHw->ThirdPartyOptionSelected ) {
            u = 0;
            if( ( ComponentIndex == HwComponentKeyboard ) ||
                ( ComponentIndex == HwComponentMouse ) ) {
                ServiceName = SpGetSectionKeyIndex(SifHandle,
                                                   NonlocalizedComponentNames[ComponentIndex],
                                                   TmpHw->IdString,
                                                   INDEX_INFKEYNAME);
            } else {
                ServiceName = TmpHw->IdString;
            }

            Status = SpOpenSetValueAndClose( hKeyPreinstall,
                                             ServiceName,
                                             OemTag,
                                             ULONG_VALUE(u)
                                           );
            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to save information for preinstalled retail driver %ls. Status = %lx \n", TmpHw->IdString, Status ));
                if( SaveStatus == STATUS_SUCCESS ) {
                    SaveStatus = Status;
                }
            }

        } else {
            //
            //  Find the name of the service, save it, and indicate if there is
            //  a retail class driver that needs to be disabled if the service
            //  initializes successfully.
            //
            if( IS_FILETYPE_PRESENT(TmpHw->FileTypeBits, HwFileClass) ) {
                if( ComponentIndex == HwComponentKeyboard ) {
                    ClassName = L"kbdclass";
                } else if( ComponentIndex == HwComponentMouse ) {
                    ClassName = L"mouclass";
                } else {
                    ClassName = NULL;
                }
            } else {
                ClassName = NULL;
            }
            for(File=TmpHw->Files; File; File=File->Next) {
                PWSTR p;

                //
                // If there is to be no node for this file, skip it.
                //
                if(!File->ConfigName) {
                    continue;
                }
                //
                // Calculate the node name.  This is the name of the driver
                // without the extension.
                //
                wcsncpy(NodeName,File->Filename,8);
                NodeName[8] = L'\0';
                if(p = wcschr(NodeName,L'.')) {
                    *p = L'\0';
                }
                u = 1;
                Status = SpOpenSetValueAndClose( hKeyPreinstall,
                                                 NodeName,
                                                 OemTag,
                                                 ULONG_VALUE(u)
                                               );
                if( !NT_SUCCESS( Status ) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to save information for preinstalled OEM driver %ls. Status = %lx \n", NodeName, Status ));
                    if( SaveStatus == STATUS_SUCCESS ) {
                        SaveStatus = Status;
                    }
                }
                if( ClassName != NULL ) {
                    Status = SpOpenSetValueAndClose( hKeyPreinstall,
                                                     NodeName,
                                                     RetailClass,
                                                     STRING_VALUE(ClassName)
                                                   );
                    if( !NT_SUCCESS( Status ) ) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to save information for preinstalled OEM driver %ls. Status = %lx \n", NodeName, Status ));
                        if( SaveStatus == STATUS_SUCCESS ) {
                            SaveStatus = Status;
                        }
                    }
                }
            }
        }
    }
    return( SaveStatus );
}

NTSTATUS
SpSavePreinstallList(
    IN PVOID  SifHandle,
    IN PWSTR  SystemRoot,
    IN HANDLE hKeySystemHive
    )
{
    NTSTATUS Status;
    NTSTATUS SaveStatus;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE hKeyPreinstall;
    ULONG   i;

    //
    // Create setup\preinstall
    //
    INIT_OBJA(&Obja,&UnicodeString,L"Setup\\Preinstall");
    Obja.RootDirectory = hKeySystemHive;

    Status = ZwCreateKey(
                &hKeyPreinstall,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to create Preinstall key. Status = %lx\n",Status));
        return( Status );
    }

    SaveStatus = STATUS_SUCCESS;
    for( i = 0; i < HwComponentMax; i++ ) {
        if( ( i == HwComponentComputer ) ||
            ( i == HwComponentDisplay )  ||
            ( i == HwComponentLayout ) ||
            ( PreinstallHardwareComponents[i] == NULL ) ) {
            continue;
        }

        Status = SpSavePreinstallHwInfo( SifHandle,
                                         SystemRoot,
                                         hKeyPreinstall,
                                         i,
                                         PreinstallHardwareComponents[i] );
        if( !NT_SUCCESS( Status ) ) {
            if( SaveStatus == STATUS_SUCCESS ) {
                SaveStatus = Status;
            }
        }
    }

    if( PreinstallScsiHardware != NULL ) {
        Status = SpSavePreinstallHwInfo( SifHandle,
                                         SystemRoot,
                                         hKeyPreinstall,
                                         HwComponentMax,
                                         PreinstallScsiHardware );
        if( !NT_SUCCESS( Status ) ) {
            if( SaveStatus == STATUS_SUCCESS ) {
                SaveStatus = Status;
            }
        }
    }
    ZwClose(hKeyPreinstall);
    return( SaveStatus );
}

NTSTATUS
SpSetPageFileInfo(
    IN PVOID   SifHandle,
    IN HANDLE hKeyCCSetControl,
    IN HANDLE hKeySystemHive
    )

/*++

Routine Description:

    This function replaces the original data of 'PagingFile' 
    CurrentControlSet\Session Manager\Memory Management with values from txtsetup.sif if the values don't measure up.
    The original value will have already been saved on HKEY_LOCAL_MACHINE\SYSTEM\Setup\\PageFile,
    and it will be restored at the end of GUI setup.

Arguments:

    SifHandle - handle to txtsetup.sif

    hKeyCCSetControl - supplies handle to SYSTEM\CurrentControlSet\Control

    hKeySystemHive - supplies handle to root of the system hive
        (ie, HKEY_LOCAL_MACHINE\System).


Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    PUCHAR   Data;
    ULONG    Length;
    PWSTR    SrcKeyPath = L"Session Manager\\Memory Management";
    PWSTR    ValueName  = L"PagingFiles";

    PWSTR    Buffer;
    PWSTR    NextDstSubstring;
    ULONG    AuxLength;
    ULONG    StartPagefile,MaxPagefile;
    ULONG    OldStartPagefile,OldMaxPagefile;
    PWSTR    p;


    //
    // Read recommended pagefile size for gui-mode.
    //

    if(p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_PAGEFILE,0)) {
        StartPagefile = SpStringToLong( p, NULL, 10 );
    }
    else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to retrieve initial pagefile size from txtsetup.sif\n"));
        return( STATUS_UNSUCCESSFUL );
    }
    if(p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_PAGEFILE,1)) {
        MaxPagefile = SpStringToLong( p, NULL, 10 );
    }
    else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to retrieve max pagefile size from txtsetup.sif\n"));
        return( STATUS_UNSUCCESSFUL );
    }
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Read pagefile from txtsetup %lx %lx\n", StartPagefile, MaxPagefile ));
    //
    //  Retrieve the original value of 'PagingFiles'
    //

    Status = SpGetValueKey( hKeyCCSetControl,
                            SrcKeyPath,
                            ValueName,
                            sizeof(TemporaryBuffer),
                            (PCHAR)TemporaryBuffer,
                            &Length );

    OldStartPagefile = 0;
    OldMaxPagefile = 0;
    NextDstSubstring = TemporaryBuffer;

    if(NT_SUCCESS(Status) && ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Type == REG_MULTI_SZ) {
        PWSTR   r;
        WCHAR   SaveChar;
        PWSTR   s=NULL;

        Data   = ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data;
        Length = ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength;

        Buffer = SpMemAlloc( Length );
    
        RtlMoveMemory( Buffer, Data, Length );

        AuxLength = wcslen( Buffer);
        // If it's not one string, then we won't change the pagefile
        if( AuxLength == 0 || *(Buffer+AuxLength+1) != (WCHAR)'\0') {
            SpMemFree( Buffer );
            return( STATUS_SUCCESS );
        }

        //
        //  Form a new value entry that contains the information regarding the
        //  paging files to be created. The paths to the paging files will be the
        //  same ones used in the system before the upgrade. 
    
        //
        //  Make a copy of the original value entry, and form the data for the new
        //  value entry in the TemporaryBuffer.
        //
    
        SpStringToLower( Buffer );
        r = wcsstr( Buffer, L"\\pagefile.sys" );
        if( r != NULL ) {
            r += wcslen( L"\\pagefile.sys" );
            SaveChar = *r;
            *r = (WCHAR)'\0';
            wcscpy( NextDstSubstring, Buffer );
            *r = SaveChar;
            OldStartPagefile = SpStringToLong( r, &s, 10 );
            if( (s != NULL) && (*s != (WCHAR)'\0') ) {
                OldMaxPagefile = max( OldStartPagefile, (ULONG)SpStringToLong( s, NULL, 10 ));
            } else {
                OldMaxPagefile = OldStartPagefile;
            }

        } else {
            wcscpy( NextDstSubstring, L"?:\\pagefile.sys" );
        }
        SpMemFree( Buffer );
        // NextDstSubstring should now point just after pagefile.sys at the null
    } else {
        wcscpy( NextDstSubstring, L"?:\\pagefile.sys" );
    }
    NextDstSubstring += wcslen( NextDstSubstring );

    //
    //  Overwrite the original value of PagingFiles
    //
    swprintf( NextDstSubstring, L" %d %d", max( OldStartPagefile, StartPagefile), max( OldMaxPagefile, MaxPagefile));
    Length = wcslen( TemporaryBuffer );
    Length++;
    (TemporaryBuffer)[ Length++ ] = UNICODE_NULL;

    Status = SpOpenSetValueAndClose( hKeyCCSetControl,
                                     SrcKeyPath,
                                     ValueName,
                                     REG_MULTI_SZ,
                                     TemporaryBuffer,
                                     Length*sizeof(WCHAR) );


    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to save pagefile.  Status = %lx\n", Status ));
    }
    return( Status );
}

NTSTATUS
SpSavePageFileInfo(
    IN HANDLE hKeyCCSetControl,
    IN HANDLE hKeySystemHive
    )

/*++

Routine Description:

    This function is only called on the upgrade case.
    The original value will be saved on HKEY_LOCAL_MACHINE\SYSTEM\Setup\\PageFile,
    and it will be restored at the end of GUI setup.

Arguments:

    hKeyCCSetControl - supplies handle to SYSTEM\CurrentControlSet\Control

    hKeySystemHive - supplies handle to root of the system hive
        (ie, HKEY_LOCAL_MACHINE\System).


Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    PUCHAR   Data;
    ULONG    Length;
    PWSTR    SrcKeyPath = L"Session Manager\\Memory Management";
    PWSTR    ValueName  = L"PagingFiles";

    //
    //  Retrieve the original value of 'PagingFiles'
    //

    Status = SpGetValueKey( hKeyCCSetControl,
                            SrcKeyPath,
                            ValueName,
                            sizeof(TemporaryBuffer),
                            (PCHAR)TemporaryBuffer,
                            &Length );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to retrieve %ls on %ls. Status = %lx \n", ValueName, SrcKeyPath, Status ));
        return( Status );
    }

    Data   = ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data;
    Length = ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength;


    //
    //  Save the data in SYSTEM\Setup\PageFile
    //

    Status = SpOpenSetValueAndClose(
                hKeySystemHive,
                L"Setup\\PageFile",
                ValueName,
                REG_MULTI_SZ,
                Data,
                Length
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to save %ls on SYSTEM\\Setup\\PageFile. ValueName, Status = %lx\n", Status ));
    }
    return( Status );
}

NTSTATUS
SppMigrateSetupRegNonVolatileKeys(
    IN PWSTR   PartitionPath,
    IN PWSTR   SystemRoot,
    IN HANDLE  hDestControlSet,
    IN PWSTR   KeyPath,
    IN BOOLEAN OverwriteValues,
    IN BOOLEAN OverwriteACLs
    )

/*++

Routine Description:

    This routine migrates keys of the setup hive to the target hive.
    These keys are subkeys of \Registry\Machine\System\CurrentControlSet,
    and are listed on the section [SetupKeysToMigrate] on txtsetup.sif.

Arguments:

    PartitionPath - supplies the NT name for the drive of windows nt.

    SystemRoot - supplies nt path of the windows nt directory.

    hDestLocalMachine - Handle to HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet on the target hive.

    KeyPath - Path to the key to be migrated, relative to \Registry\Machine\System\CurrentControlSet.

    SifHandle - Handle to txtsetup.sif

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;

    HANDLE hSrcKey;
    HANDLE hTempSrcKey;
    HANDLE SaveHiveHandle;
    HANDLE hDestKey;

    PWSTR TempKeyPath = L"\\registry\\machine\\TempKey";
    PWSTR SaveHiveName;
    IO_STATUS_BLOCK   IoStatusBlock;
    PSECURITY_DESCRIPTOR Security = NULL;
    ULONG                ResultLength;


    //
    //  Open the key the key that needs to be saved
    //
    wcscpy(TemporaryBuffer,L"\\registry\\machine\\system\\currentcontrolset");
    SpConcatenatePaths(TemporaryBuffer,KeyPath);
    INIT_OBJA(&Obja,&UnicodeString,TemporaryBuffer);
    Obja.RootDirectory = NULL;
    Status = ZwOpenKey(&hSrcKey,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive (%lx)\n", TemporaryBuffer, Status));
        return( Status ) ;
    }

    //
    //  Create the hive file
    //
    wcscpy(TemporaryBuffer,PartitionPath);
    SpConcatenatePaths(TemporaryBuffer,SystemRoot);
    SpConcatenatePaths(TemporaryBuffer,L"system32\\config");
    SpConcatenatePaths(TemporaryBuffer,L"TempKey");

    SaveHiveName = SpDupStringW(TemporaryBuffer);

    SpDeleteFile( SaveHiveName, NULL, NULL );

    INIT_OBJA(&Obja,&UnicodeString,SaveHiveName);

    Status = ZwCreateFile(
                    &SaveHiveHandle,
                    FILE_GENERIC_WRITE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    0,                      // no sharing
                    FILE_OVERWRITE_IF,
                    FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                    );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create the hive file %ls. Status = %lx\n", SaveHiveName, Status));
        goto TempMigr_2;
    }

    Status = ZwSaveKey( hSrcKey, SaveHiveHandle );
    ZwClose( SaveHiveHandle );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to save %ls key to the hive file %ls. Status = %lx\n", KeyPath, SaveHiveName, Status));
        goto TempMigr_3;
    }

    Status = SpLoadUnloadKey( NULL,
                              NULL,
                              TempKeyPath,
                              SaveHiveName );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load %ls key to the setup hive. Status = %lx\n", SaveHiveName, Status));
        goto TempMigr_3;
    }

    //
    //  Open TempKey
    //
    INIT_OBJA(&Obja,&UnicodeString,TempKeyPath);
    Obja.RootDirectory = NULL;
    Status = ZwOpenKey(&hTempSrcKey,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open TempSrc key on the setup hive. Status = %lx\n", Status));
        goto TempMigr_4;
    }

    //
    // First, get the security descriptor from the source key so we can create
    // the destination key with the correct ACL.
    //
    Status = ZwQuerySecurityObject(hTempSrcKey,
                                   DACL_SECURITY_INFORMATION,
                                   NULL,
                                   0,
                                   &ResultLength
                                  );
    if(Status==STATUS_BUFFER_TOO_SMALL) {
        Security=SpMemAlloc(ResultLength);
        Status = ZwQuerySecurityObject(hTempSrcKey,
                                       DACL_SECURITY_INFORMATION,
                                       Security,
                                       ResultLength,
                                       &ResultLength);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to query security for key %ws in the source hive (%lx)\n",
                     TempKeyPath,
                     Status)
                   );
            SpMemFree(Security);
            Security=NULL;
        }
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to query security size for key %ws in the source hive (%lx)\n",
                 TempKeyPath,
                 Status)
               );
        Security=NULL;
    }
    //
    // Open the key on the target hive
    //
    INIT_OBJA(&Obja,&UnicodeString,KeyPath);
    Obja.RootDirectory = hDestControlSet;

    Status = ZwOpenKey(&hDestKey,KEY_ALL_ACCESS,&Obja);

    if(!NT_SUCCESS(Status)) {
        //
        // Assume that failure was because the key didn't exist.  Now try creating
        // the key.

        Obja.SecurityDescriptor = Security;

        Status = ZwCreateKey(
                    &hDestKey,
                    KEY_ALL_ACCESS,
                    &Obja,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    NULL
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open or create key %ws(%lx)\n",KeyPath, Status));

            if(Security) {
                SpMemFree(Security);
            }
            goto TempMigr_5;
        }
    } else if (OverwriteACLs) {

        Status = ZwSetSecurityObject(
                    hDestKey,
                    DACL_SECURITY_INFORMATION,
                    Security );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to copy ACL to existing key %ws(%lx)\n",KeyPath, Status));
        }
    }

    if(Security) {
        SpMemFree(Security);
    }

    Status = SppCopyKeyRecursive(
                 hTempSrcKey,
                 hDestKey,
                 NULL,
                 NULL,
                 OverwriteValues,
                 OverwriteACLs
                 );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls to the target hive. KeyPath, Status = %lx\n", Status));
    }

    ZwClose( hDestKey );

TempMigr_5:
    ZwClose( hTempSrcKey );

TempMigr_4:
    //
    //  Unload hive
    //
    SpLoadUnloadKey( NULL,
                     NULL,
                     TempKeyPath,
                     NULL );

TempMigr_3:
    SpDeleteFile( SaveHiveName, NULL, NULL );

TempMigr_2:
    SpMemFree( SaveHiveName );

    return( Status );
}



BOOLEAN
SpHivesFromInfs(
    IN PVOID   SifHandle,
    IN LPCWSTR SectionName,
    IN LPCWSTR SourcePath1,
    IN LPCWSTR SourcePath2,     OPTIONAL
    IN HANDLE  SystemHiveRoot,
    IN HANDLE  SoftwareHiveRoot,
    IN HANDLE  DefaultUserHiveRoot,
    IN HANDLE  HKR
    )

/*++

Routine Description:

    This routine runs addreg and delreg sections as listed in txtsetup.sif,
    in order to create or perform the basic upgrade on the registry hives.

    Each line in the given section is expected to be in the following form:

        addreg = <filename>,<section>

    or

        delreg = <filename>,<section>

    Multiple addreg and delreg lines can be supplied, and the sections are
    processed in order listed.

    The filename specs are filename only; the files are expected to be
    in the source directory.

Arguments:

    SifHandle - supplies the handle to txtsetup.sif.

    SectionName - supplies the name of the section in txtsetuyp.sif that
        lists infs/sections to be processed.

    SourcePath - supplies NT-style path to the source files for installation.

    SystemHiveRoot - supplies handle to root key of system hive under
        construction.

    SoftwareHiveRoot - supplies handle to root key of software hive under
        construction.

    DefaultUserHiveRoot - supplies handle to root key of default hive under
        construction.

    HKR - supplies key to be used for HKR.

Return Value:

    Boolean value indicating outcome.

--*/

{

    LPCWSTR PreviousInf;
    LPCWSTR CurrentInf;
    ULONG LineNumber;
    LPCWSTR TypeSpec;
    LPCWSTR SectionSpec;
    PVOID InfHandle;
    ULONG ErrorLine;
    NTSTATUS Status;
    LPWSTR name;
    LPWSTR MediaShortname;
    LPWSTR MediaDirectory;

    //
    // Allocate a buffer for names.
    //
    name = SpMemAlloc(1000);

    LineNumber = 0;
    PreviousInf = L"";
    InfHandle = NULL;

    while((TypeSpec = SpGetKeyName(SifHandle,SectionName,LineNumber))
       && (CurrentInf = SpGetSectionLineIndex(SifHandle,SectionName,LineNumber,0))
       && (SectionSpec = SpGetSectionLineIndex(SifHandle,SectionName,LineNumber,1))) {

        //
        // Only load the inf if it's different than the previous one,
        // as a time optimization.
        //
        if(_wcsicmp(CurrentInf,PreviousInf)) {
            if(InfHandle) {
                SpFreeTextFile(InfHandle);
                InfHandle = NULL;
            }

            MediaShortname = SpLookUpValueForFile(SifHandle,(LPWSTR)CurrentInf,INDEX_WHICHMEDIA,TRUE);
            SpGetSourceMediaInfo(SifHandle,MediaShortname,NULL,NULL,&MediaDirectory);

            wcscpy(name,SourcePath1);
            if(SourcePath2) {
                SpConcatenatePaths(name,SourcePath2);
            }
            SpConcatenatePaths(name,MediaDirectory);
            SpConcatenatePaths(name,CurrentInf);
            Status = SpLoadSetupTextFile(name,NULL,0,&InfHandle,&ErrorLine,FALSE,FALSE);
            if(!NT_SUCCESS(Status)) {

                SpStartScreen(
                    SP_SCRN_INF_LINE_CORRUPT,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    ErrorLine,
                    CurrentInf
                    );

                SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

                SpInputDrain();
                while(SpInputGetKeypress() != KEY_F3) ;

                SpDone(0,FALSE,TRUE);
            }

            PreviousInf = CurrentInf;
        }

        if(!_wcsicmp(TypeSpec,L"addreg")) {

            Status = SpProcessAddRegSection(
                        InfHandle,
                        SectionSpec,
                        SystemHiveRoot,
                        SoftwareHiveRoot,
                        DefaultUserHiveRoot,
                        HKR
                        );

            SendSetupProgressEvent(SavingSettingsEvent, InitializeHiveEvent, NULL);
        } else {
            if(!_wcsicmp(TypeSpec,L"delreg")) {

                Status = SpProcessDelRegSection(
                            InfHandle,
                            SectionSpec,
                            SystemHiveRoot,
                            SoftwareHiveRoot,
                            DefaultUserHiveRoot,
                            HKR
                            );

                SendSetupProgressEvent(SavingSettingsEvent, InitializeHiveEvent, NULL);
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unknown hive section type spec %ws\n",TypeSpec));
                SpFreeTextFile(InfHandle);
                SpMemFree(name);
                return(FALSE);
            }
        }

        if(!NT_SUCCESS(Status)) {
            SpFreeTextFile(InfHandle);
            SpMemFree(name);
            return(FALSE);
        }

        LineNumber++;
    }

    if(InfHandle) {
        SpFreeTextFile(InfHandle);
    }

    SpMemFree(name);
    return(TRUE);
}




NTSTATUS
SpMigrateSetupKeys(
    IN PWSTR  PartitionPath,
    IN PWSTR  SystemRoot,
    IN HANDLE hDestControlSet,
    IN PVOID  SifHandle
    )

/*++

Routine Description:

    This routine migrates keys of the setup hive to the target hive.
    These keys are subkeys of \Registry\Machine\System\CurrentControlSet,
    and are listed on the section [SetupKeysToMigrate] on txtsetup.sif.

Arguments:

    PartitionPath - supplies the NT name for the drive of windows nt.

    SystemRoot - supplies nt path of the windows nt directory.

    hDestLocalMachine - Handle to HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet
                        on the target hive.

    SifHandle - Handle to txtsetup.sif

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    NTSTATUS SavedStatus;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;

    HANDLE hSrcKey;

    ULONG   LineIndex;
    PWSTR   KeyName;
    PWSTR   SectionName = L"SetupKeysToMigrate";
    BOOLEAN MigrateVolatileKeys;
    BOOLEAN OverwriteValues;
    BOOLEAN OverwriteACLs;
    BOOLEAN MigrateOnCleanInstall;
    BOOLEAN MigrateOnUpgrade;
    ULONG   InstType;
    PWSTR   p;

    SavedStatus = STATUS_SUCCESS;
    for( LineIndex = 0;
         ( KeyName = SpGetKeyName( SifHandle,
                                   SectionName,
                                   LineIndex ) ) != NULL;
         LineIndex++ ) {

        p = SpGetSectionKeyIndex ( SifHandle,
                                   SectionName,
                                   KeyName,
                                   0 );
        MigrateVolatileKeys = ( ( p != NULL ) && ( SpStringToLong( p, NULL, 10 ) == 0 ) )? FALSE : TRUE;

        p = SpGetSectionKeyIndex ( SifHandle,
                                   SectionName,
                                   KeyName,
                                   1 );
        if( p != NULL ) {
            InstType = SpStringToLong( p, NULL, 10 );
            if( InstType > 2 ) {
                InstType = 2;
            }
        } else {
            InstType = 2;
        }
        MigrateOnCleanInstall = ( InstType != 1 );
        MigrateOnUpgrade = ( InstType != 0 );


        p = SpGetSectionKeyIndex ( SifHandle,
                                   SectionName,
                                   KeyName,
                                   2 );
        OverwriteValues = ( ( p != NULL ) && ( SpStringToLong( p, NULL, 10 ) == 0 ) )? FALSE : TRUE;


        p = SpGetSectionKeyIndex ( SifHandle,
                                   SectionName,
                                   KeyName,
                                   3 );
        OverwriteACLs = ( ( p != NULL ) && ( SpStringToLong( p, NULL, 10 ) != 0 ) );


        if( ( ( NTUpgrade == DontUpgrade ) && MigrateOnCleanInstall ) ||
            ( ( NTUpgrade != DontUpgrade ) && MigrateOnUpgrade ) ) {

            if( MigrateVolatileKeys ) {
                wcscpy( TemporaryBuffer, L"\\registry\\machine\\system\\currentcontrolset\\" );
                SpConcatenatePaths(TemporaryBuffer, KeyName);

                //
                //  Open the source key
                //
                INIT_OBJA(&Obja,&UnicodeString,TemporaryBuffer);
                Obja.RootDirectory = NULL;

                Status = ZwOpenKey(&hSrcKey,KEY_ALL_ACCESS,&Obja);
                if( !NT_SUCCESS( Status ) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive (%lx)\n", TemporaryBuffer, Status));
                    if( SavedStatus != STATUS_SUCCESS ) {
                        SavedStatus = Status;
                    }
                    continue;
                }

                Status = SppCopyKeyRecursive(
                                 hSrcKey,
                                 hDestControlSet,
                                 NULL,
                                 KeyName,
                                 OverwriteValues,
                                 OverwriteACLs
                                 );

                if( !NT_SUCCESS( Status ) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls. Status = %lx\n", KeyName, Status));
                    if( SavedStatus != STATUS_SUCCESS ) {
                        SavedStatus = Status;
                    }
                }

            } else {
                Status = SppMigrateSetupRegNonVolatileKeys( PartitionPath,
                                                            SystemRoot,
                                                            hDestControlSet,
                                                            KeyName,
                                                            OverwriteValues,
                                                            OverwriteACLs );
                if( !NT_SUCCESS( Status ) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls. Status = %lx\n", KeyName, Status));
                    if( SavedStatus != STATUS_SUCCESS ) {
                        SavedStatus = Status;
                    }
                }

            }
        }
    }
    return( SavedStatus );
}

NTSTATUS
SppMigrateFtKeys(
    IN HANDLE hDestSystemHive
    )

/*++

Routine Description:

    This routine migrates the ftdisk related keys on the setup hive to the
    target hive.

Arguments:

    hDestSystemHive - Handle to the root of the system hive on the system
                      being upgraded.


Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    NTSTATUS SavedStatus;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;


    PWSTR   FtDiskKeys[] = {
                           L"Disk",
                           L"MountedDevices"
                           };
    WCHAR   KeyPath[MAX_PATH];
    HANDLE  SrcKey;
    ULONG   i;

    SavedStatus = STATUS_SUCCESS;
    for( i = 0; i < sizeof(FtDiskKeys)/sizeof(PWSTR); i++ ) {
        //
        //  Open the source key
        //
        swprintf( KeyPath, L"\\registry\\machine\\system\\%ls", FtDiskKeys[i] );
        INIT_OBJA(&Obja,&UnicodeString,KeyPath);
        Obja.RootDirectory = NULL;

        Status = ZwOpenKey(&SrcKey,KEY_ALL_ACCESS,&Obja);
        if( !NT_SUCCESS( Status ) ) {
            //
            //  If the key doesn't exist, just assume success
            //
            if( Status != STATUS_OBJECT_NAME_NOT_FOUND ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive. Status =  %lx \n", KeyPath, Status));
                if( SavedStatus == STATUS_SUCCESS ) {
                    SavedStatus = Status;
                }
            }
            continue;
        }
        Status = SppCopyKeyRecursive( SrcKey,
                                      hDestSystemHive,
                                      NULL,
                                      FtDiskKeys[i],
                                      (((NTUpgrade == UpgradeFull) && !_wcsicmp( FtDiskKeys[i], L"MountedDevices"))? FALSE : TRUE),
                                      FALSE
                                    );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls to SYSTEM\\%ls. Status = %lx\n", KeyPath, FtDiskKeys[i], Status));
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
            }
        }
        ZwClose( SrcKey );
    }
    return( SavedStatus );
}

NTSTATUS
SppCleanupKeysFromRemoteInstall(
    VOID
    )

/*++

Routine Description:

    This routine cleans up some keys that remote install modified to get
    the network card working. This is so that PnP setup during GUI-mode is
    not confused by the card already being setup.

Arguments:

    None.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG ResultLength;
    HANDLE hKey;
    PWSTR DeviceInstance;

    //
    //  Open the remote boot key.
    //

    wcscpy( TemporaryBuffer, L"\\registry\\machine\\system\\currentcontrolset\\control\\remoteboot" );
    INIT_OBJA(&Obja,&UnicodeString,TemporaryBuffer);
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&hKey,KEY_READ,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppCleanupKeysFromRemoteInstall unable to open %ls on the setup hive (%lx)\n", TemporaryBuffer, Status));
        return Status;
    }

    //
    // Read the netboot card's device instance out.
    //

    RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_DEVICE_INSTANCE);
    Status = ZwQueryValueKey(
                hKey,
                &UnicodeString,
                KeyValuePartialInformation,
                TemporaryBuffer,
                sizeof(TemporaryBuffer),
                &ResultLength
                );

    ZwClose(hKey);

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppCleanupKeysFromRemoteInstall unable to read RemoteBoot\\DeviceInstance value (%lx)\n", Status));
        return Status;
    }

    DeviceInstance = SpDupStringW((PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data));

    //
    // Now open the device instance key under control\enum.
    //

    wcscpy( TemporaryBuffer, L"\\registry\\machine\\system\\currentcontrolset\\enum\\" );
    SpConcatenatePaths(TemporaryBuffer, DeviceInstance);

    SpMemFree(DeviceInstance);

    INIT_OBJA(&Obja,&UnicodeString,TemporaryBuffer);
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&hKey,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppCleanupKeysFromRemoteInstall unable to open %ls on the setup hive (%lx)\n", TemporaryBuffer, Status));
        return Status;
    }

    //
    // Now delete the keys we added to get the card up -- Service,
    // ClassGUID, and Driver.
    //

    RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_SERVICE);
    Status = ZwDeleteValueKey(hKey,&UnicodeString);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppCleanupKeysFromRemoteInstall unable to delete Service (%lx)\n", Status));
        ZwClose(hKey);
        return Status;
    }

    RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_CLASSGUID);
    Status = ZwDeleteValueKey(hKey,&UnicodeString);
    if( !NT_SUCCESS( Status ) ) {

        RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_GUID);
        Status = ZwDeleteValueKey(hKey,&UnicodeString);
        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppCleanupKeysFromRemoteInstall unable to delete ClassGUID (%lx)\n", Status));
            ZwClose(hKey);
            return Status;
        }
    }

    RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_DRIVER);
    Status = ZwDeleteValueKey(hKey,&UnicodeString);
    if( !NT_SUCCESS( Status ) ) {

        RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_DRVINST);
        Status = ZwDeleteValueKey(hKey,&UnicodeString);
        ZwClose(hKey);
        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppCleanupKeysFromRemoteInstall unable to delete Driver (%lx)\n", Status));
            return Status;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SpDisableUnsupportedScsiDrivers(
    IN HANDLE hKeyControlSet
    )
{
    NTSTATUS Status;
    NTSTATUS SavedStatus;
    PHARDWARE_COMPONENT TmpHw;
    ULONG u;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE hKeyControlSetServices;
    ULONG val = SERVICE_DISABLED;

    //
    // Open controlset\services.
    //
    INIT_OBJA(&Obja,&UnicodeString,L"services");
    Obja.RootDirectory = hKeyControlSet;

    Status = ZwCreateKey(
                &hKeyControlSetServices,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open services key (%lx)\n",Status));
        return(Status);
    }

    SavedStatus = STATUS_SUCCESS;

    for( TmpHw = UnsupportedScsiHardwareToDisable;
         TmpHw != NULL;
         TmpHw = TmpHw->Next ) {

        Status = SpOpenSetValueAndClose(
                    hKeyControlSetServices,
                    TmpHw->IdString,
                    L"Start",
                    ULONG_VALUE(val)
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to disable unsupported driver %ls. Status = %lx \n", TmpHw->IdString, Status));
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unsupported driver %ls successfully disabled. \n", TmpHw->IdString));
        }
    }
    ZwClose( hKeyControlSetServices );
    return( SavedStatus );
}

NTSTATUS
SpAppendPathToDevicePath(
    IN HANDLE hKeySoftwareHive,
    IN PWSTR  OemPnpDriversDirPath
    )

/*++

Routine Description:

    This routine should be called only on OEM preinstall.
    It appends the path to the directory that cntains the OEM drivers to be installed during GUI
    setup to HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion!DevicePath.

Arguments:

    hKeySoftwareKey - Handle to the root of the software hive.

    OemPnpDriversDirPath - Path to the directory that contains the OEM pnp drivers (eg. \Dell).

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS    Status;
    ULONG       Length;
    PWSTR       szCurrentVersionKey = L"Microsoft\\Windows\\CurrentVersion";
    PWSTR       szDevicePath = L"DevicePath";

    Status = SpGetValueKey( hKeySoftwareHive,
                            szCurrentVersionKey,
                            szDevicePath,
                            sizeof(TemporaryBuffer),
                            (PCHAR)TemporaryBuffer,
                            &Length );

    if( NT_SUCCESS(Status) ) {
        if( wcslen( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data) ) != 0 ) {
        PWSTR   BeginStrPtr;
        PWSTR   EndStrPtr;
        BOOL    Done = FALSE;
            //
            // OemPnpDriversDirPath can have several entries, separated by
            // a semicolon.  For each entry, we need to:
            // 1. append a semicolon.
            // 2. append %SystemDrive%
            // 3. concatenate the entry.
            //

            BeginStrPtr = OemPnpDriversDirPath;
            do {
                //
                // Mark the end of this entry.
                //
                EndStrPtr = BeginStrPtr;
                while( (*EndStrPtr) && (*EndStrPtr != L';') ) {
                    EndStrPtr++;
                }

                //
                // Is this the last entry?
                //
                if( *EndStrPtr == 0 ) {
                    Done = TRUE;
                }
                *EndStrPtr = 0;

                wcscat( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data), L";" );
                wcscat( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data), L"%SystemDrive%" );
                SpConcatenatePaths((PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data), BeginStrPtr);

                BeginStrPtr = EndStrPtr + 1;

                //
                // Take care of the case where the user ended the
                // OemPnpDriversPath entry with a semicolon.
                //
                if( *BeginStrPtr == 0 ) {
                    Done = TRUE;
                }

            } while( !Done );

            //
            // Now put the entry back into the registry.
            //
            Status = SpOpenSetValueAndClose( hKeySoftwareHive,
                                             szCurrentVersionKey,
                                             szDevicePath,
                                             ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Type,
                                             ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data,
                                             (wcslen( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data) ) +1 ) * sizeof(WCHAR) );
        }
    }
    return( Status );
}

NTSTATUS
SpAppendFullPathListToDevicePath (
    IN HANDLE hKeySoftwareHive,
    IN PWSTR  PnpDriverFullPathList
    )

/*++

Routine Description:

    This routine appends the given full path list to the directory that cntains the OEM drivers to be installed during GUI
    setup to HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion!DevicePath.

Arguments:

    hKeySoftwareKey - Handle to the root of the software hive.

    PnpDriverFullPathList - List of full paths to the directories that contain additional pnp drivers

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS    Status;
    ULONG       Length;
    PWSTR       szCurrentVersionKey = L"Microsoft\\Windows\\CurrentVersion";
    PWSTR       szDevicePath = L"DevicePath";

    Status = SpGetValueKey (
                hKeySoftwareHive,
                szCurrentVersionKey,
                szDevicePath,
                sizeof(TemporaryBuffer),
                (PCHAR)TemporaryBuffer,
                &Length
                );

    if (NT_SUCCESS (Status)) {
        if (*(WCHAR*)((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data) {
            wcscat ((PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data), L";");
        }
        wcscat ((PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data), PnpDriverFullPathList);
        //
        // Now put the entry back into the registry.
        //
        Status = SpOpenSetValueAndClose (
                        hKeySoftwareHive,
                        szCurrentVersionKey,
                        szDevicePath,
                        ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Type,
                        ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data,
                        (wcslen ((PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data) + 1) * sizeof(WCHAR)
                        );
    }

    return( Status );
}

#if defined(REMOTE_BOOT)
NTSTATUS
SpCopyRemoteBootKeyword(
    IN PVOID   SifHandle,
    IN PWSTR   KeywordName,
    IN HANDLE  hKeyCCSetControl
    )

/*++

Routine Description:

    This routine looks in a .sif file for the specified keyword
    in the [RemoteBoot] section. If it finds it, it creates a registry
    DWORD value with same name under System\CurrentControlSet\Control\
    RemoteBoot. The value will be set to 1 if the sif keyword was
    "Yes" and 0 if it was "No" (or anything else).

Arguments:

    SifHandle - The handle to the open SIF file.

    KeywordName - The name of the keyword.

    hKeyCCSetControl - The handle to CurrentControlSet\Control.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    PWSTR KeywordSifValue;
    DWORD KeywordRegistryValue;
    NTSTATUS Status;

    //
    // First see if the value exists in the SIF.
    //

    KeywordSifValue = SpGetSectionKeyIndex(SifHandle,
                                           SIF_REMOTEBOOT,
                                           KeywordName,
                                           0);

    if (KeywordSifValue == NULL) {
        return STATUS_SUCCESS;
    }

    //
    // This is the value we write to the registry.
    //

    if ((KeywordSifValue[0] == 'Y') || (KeywordSifValue[0] == 'y')) {
        KeywordRegistryValue = 1;
    } else {
        KeywordRegistryValue = 0;
    }

    //
    // Set the value.
    //

    Status = SpOpenSetValueAndClose(
                 hKeyCCSetControl,
                 SIF_REMOTEBOOT,
                 KeywordName,
                 ULONG_VALUE(KeywordRegistryValue)
                 );

    return Status;

}
#endif // defined(REMOTE_BOOT)


NTSTATUS
SppDisableDynamicVolumes(
    IN HANDLE hCCSet
    )

/*++

Routine Description:

    This routine disable dynamic volumes by disabling the appropriate services in the
    target hive.
    In addition, DmServer is reset to MANUAL start, so that it will only run when
    the LDM UI is open.

Arguments:

    hCCSet - Handle to CurrentControlSet of the target system hive.



Return Value:

    Status value indicating outcome of operation.

--*/

{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING    UnicodeString;
    NTSTATUS Status;
    NTSTATUS SavedStatus;
    DWORD    u;
    ULONG    i;
    HANDLE   hServices;
    WCHAR    KeyPath[MAX_PATH];

    PWSTR    LDMServices[] = {
                             L"dmboot",
                             L"dmio",
                             L"dmload"
                             };
    PWSTR   LDMDmServer    = L"dmserver";

    //
    // Open ControlSet\Services.
    //
    INIT_OBJA(&Obja,&UnicodeString,L"Services");
    Obja.RootDirectory = hCCSet;

    Status = ZwOpenKey(&hServices,KEY_ALL_ACCESS,&Obja);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open CurrentControlSet\\Services. Status = %lx \n",Status));
        return(Status);
    }

    SavedStatus = STATUS_SUCCESS;
    u = 0x4;
    for( i = 0; i < sizeof(LDMServices)/sizeof(PWSTR); i++ ) {

        Status = SpOpenSetValueAndClose( hServices,
                                         LDMServices[i],
                                         L"Start",
                                         ULONG_VALUE(u)
                                       );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to disable HKLM\\SYSTEM\\CurrentControlSet\\Services\\%ls. Status = %lx\n", LDMServices[i], Status));
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
            }
        }
    }
    u = 0x3;
    Status = SpOpenSetValueAndClose( hServices,
                                     LDMDmServer,
                                     L"Start",
                                     ULONG_VALUE(u)
                                   );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set HKLM\\SYSTEM\\CurrentControlSet\\Services\\%ls to MANUAL start. Status = %lx\n", LDMDmServer, Status));
        if( SavedStatus == STATUS_SUCCESS ) {
            SavedStatus = Status;
        }
    }

    ZwClose( hServices );
    return( SavedStatus );
}

NTSTATUS
SpGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_FULL_INFORMATION *Information
    )

/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    PAGED_CODE();

    RtlInitUnicodeString( &unicodeString, ValueName );
    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //
    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {

        ASSERT(!NT_SUCCESS(status));
        return status;
    }
    //
    // Allocate a buffer large enough to contain the entire key data value.
    //
    infoBuffer = SpMemAlloc(keyValueLength);
    if (!infoBuffer) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Query the data for the key value.
    //
    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (!NT_SUCCESS( status )) {

        SpMemFree(infoBuffer);
        return status;
    }
    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}

VOID
SpUpdateDeviceInstanceKeyData(
    IN  HANDLE          InstanceKey,
    IN  HANDLE          ClassBranchKey,
    IN  PUNICODE_STRING EnumName,
    IN  PUNICODE_STRING DeviceName,
    IN  PUNICODE_STRING InstanceName
    )

/*++

Routine Description:

    This routine updates (removes\changes type\names) the various values under
    the device instance key on an upgrade.

Arguments:

    InstanceKey - Handle to the device instance key.

    ClassBranchKey - Handle to the classes branch.

    EnumName - Enumerator name.

    DeviceName - Device name.

    InstanceName - Instance name.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    UNICODE_STRING valueName, guidString, drvInstString;
    DWORD length;
    GUID guid;
    PKEY_VALUE_FULL_INFORMATION info, guidInfo;
    PWCHAR  ids, className;
    ULONG   drvInst;
    WCHAR   driver[GUID_STRING_LEN + 5];
    OBJECT_ATTRIBUTES obja;
    HANDLE hClassKey;
    BOOLEAN guidAllocatedViaRtl = FALSE;

    //
    // Preinit
    //
    RtlInitUnicodeString(&guidString, NULL);
    info = NULL;
    guidInfo = NULL;

    //
    // Look at the instance key to see if we are dealing with a WinXP Beta2
    // machine. If so, we need to convert it's compressed PnP data format back
    // to the original Win2K format (app compat):
    //
    // <Normal, Win2K/WinXP>                    <Compressed, XP Beta2>
    // "ClassGUID" (REG_SZ)                     "GUID" (REG_BINARY)
    // "Driver" (REG_SZ, ClassGUID\DrvInst)     "DrvInst" (REG_DWORD, DrvInst)
    // "HardwareID" (UNICODE, MultiSz)          "HwIDs" (ANSI-REG_BINARY, MultiSz)
    // "CompatibleIDs" (UNICODE, MultiSz)       "CIDs" (ANSI-REG_BINARY, MultiSz)
    // "Class" (UNICODE)                        none, retrieved using ClassGUID
    //

    //
    // Do we have the XP-Beta2 style "GUID" key?
    //
    status = SpGetRegistryValue(InstanceKey, REGSTR_VALUE_GUID, &info);
    if (NT_SUCCESS(status) && !info) {

        status = STATUS_UNSUCCESSFUL;
    }

    if (NT_SUCCESS(status)) {

        //
        // Change "GUID" (REG_BINARY) to "ClassGUID" (REG_SZ).
        //
        status = RtlStringFromGUID((GUID *)((PUCHAR)info + info->DataOffset), &guidString);
        SpMemFree(info);
        if (NT_SUCCESS(status)) {

            guidAllocatedViaRtl = TRUE;

            RtlInitUnicodeString(&valueName, REGSTR_VAL_CLASSGUID);
            ZwSetValueKey(
                InstanceKey,
                &valueName,
                0,
                REG_SZ,
                guidString.Buffer,
                guidString.Length + sizeof(UNICODE_NULL));

            //
            // Delete old "GUID" value
            //
            RtlInitUnicodeString(&valueName, REGSTR_VALUE_GUID);
            ZwDeleteValueKey(InstanceKey, &valueName);
        }

    } else {

        //
        // This might be a rare Lab1 build where we've already done the
        // conversion but we forgot to restore the class name.
        //
        status = SpGetRegistryValue(InstanceKey, REGSTR_VAL_CLASS, &info);

        if (NT_SUCCESS(status) && info) {

            //
            // We successfully retrieved the class name from the device
            // instance key--no need to attempt further migration.
            //
            SpMemFree(info);

            status = STATUS_UNSUCCESSFUL;

        } else {

            status = SpGetRegistryValue(InstanceKey, REGSTR_VAL_CLASSGUID, &guidInfo);

            if (NT_SUCCESS(status) && !guidInfo) {

                status = STATUS_UNSUCCESSFUL;
            }

            if (NT_SUCCESS(status)) {

                //
                // The ClassGUID value exists.  Initialize our string with this
                // GUID so we can go to the corresponding key under the Class
                // Branch to lookup the Class name.
                //
                guidAllocatedViaRtl = FALSE;

                RtlInitUnicodeString(&guidString, 
                                     (PWCHAR)((PUCHAR)guidInfo + guidInfo->DataOffset)
                                    );
            }
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // While we are here we need to restore the class name as well.
        // Start by getting the class name from the class's branch itself.
        //
        InitializeObjectAttributes(
            &obja,
            &guidString,
            OBJ_CASE_INSENSITIVE,
            ClassBranchKey,
            NULL
            );

        status = ZwOpenKey(&hClassKey, KEY_ALL_ACCESS, &obja);

        ASSERT(NT_SUCCESS(status));

        if (NT_SUCCESS(status)) {

            status = SpGetRegistryValue(hClassKey, REGSTR_VAL_CLASS, &info);
            if (NT_SUCCESS(status) && !info) {

                status = STATUS_UNSUCCESSFUL;
            }

            if (NT_SUCCESS(status)) {

                //
                // Copy the class name stored in the class branch to the
                // instance key.
                //
                className = (PWCHAR)((PUCHAR)info + info->DataOffset);

                RtlInitUnicodeString(&valueName, REGSTR_VAL_CLASS);
                ZwSetValueKey(
                    InstanceKey,
                    &valueName,
                    0,
                    REG_SZ,
                    className,
                    (wcslen(className)+1)*sizeof(WCHAR)
                    );

                SpMemFree(info);
            }

            ZwClose(hClassKey);
        }
    }

    //
    // At this point, if status is successful, that means we migrated Class/
    // ClassGUID values, so there may be more to do...
    //
    if (NT_SUCCESS(status)) {
        //
        // Do we have the XP-Beta2 style "DrvInst" key?
        //
        status = SpGetRegistryValue(InstanceKey, REGSTR_VALUE_DRVINST, &info);
        if (NT_SUCCESS(status) && !info) {

            status = STATUS_UNSUCCESSFUL;
        }

        if (NT_SUCCESS(status)) {

            //
            // Change DrvInst (REG_DWORD) to Driver (REG_SZ) from "ClassGuid\DrvInst"
            //
            ASSERT(guidString.Length != 0);

            drvInst = *(PULONG)((PUCHAR)info + info->DataOffset);
            swprintf(driver,
                     TEXT("%wZ\\%04u"),
                     &guidString,
                     drvInst);

            SpMemFree(info);

            RtlInitUnicodeString(&valueName, REGSTR_VAL_DRIVER);
            ZwSetValueKey(
                InstanceKey,
                &valueName,
                0,
                REG_SZ,
                driver,
                sizeof(driver)
                );

            //
            // Delete DrvInst value
            //
            RtlInitUnicodeString(&valueName, REGSTR_VALUE_DRVINST);
            ZwDeleteValueKey(InstanceKey, &valueName);
        }
    }

    //
    // We don't need the class guid anymore.
    //
    if (guidString.Buffer) {

        if (guidAllocatedViaRtl) {

            RtlFreeUnicodeString(&guidString);
        } else {

            SpMemFree(guidInfo);
        }
    }

    //
    // Do we have the XP-Beta2 "HwIDs" key?
    //
    status = SpGetRegistryValue(InstanceKey, REGSTR_VALUE_HWIDS, &info);
    if (NT_SUCCESS(status) && !info) {

        status = STATUS_UNSUCCESSFUL;
    }

    if (NT_SUCCESS(status)) {

        //
        // Change HW IDs from ANSI to UNICODE.
        //
        ids = SpConvertMultiSzStrToWstr(((PUCHAR)info + info->DataOffset), info->DataLength);
        if (ids) {

            RtlInitUnicodeString(&valueName, REGSTR_VAL_HARDWAREID);
            ZwSetValueKey(
                InstanceKey,
                &valueName,
                0,
                REG_MULTI_SZ,
                ids,
                info->DataLength * sizeof(WCHAR)
                );

            //
            // Delete HwIDs value
            //
            RtlInitUnicodeString(&valueName, REGSTR_VALUE_HWIDS);
            ZwDeleteValueKey(InstanceKey, &valueName);
            SpMemFree(ids);
        }
        SpMemFree(info);
    }

    //
    // Do we have the XP-Beta2 "CIDs" key?
    //
    status = SpGetRegistryValue(InstanceKey, REGSTR_VALUE_CIDS, &info);
    if (NT_SUCCESS(status) && !info) {

        status = STATUS_UNSUCCESSFUL;
    }

    if (NT_SUCCESS(status)) {

        //
        // Change Compatible IDs from ANSI to UNICODE.
        //
        ids = SpConvertMultiSzStrToWstr(((PUCHAR)info + info->DataOffset), info->DataLength);
        if (ids) {

            RtlInitUnicodeString(&valueName, REGSTR_VAL_COMPATIBLEIDS);
            ZwSetValueKey(
                InstanceKey,
                &valueName,
                0,
                REG_MULTI_SZ,
                ids,
                info->DataLength * sizeof(WCHAR)
                );

            //
            // Delete CIDs value
            //
            RtlInitUnicodeString(&valueName, REGSTR_VALUE_CIDS);
            ZwDeleteValueKey(InstanceKey, &valueName);
            SpMemFree(ids);
        }
        SpMemFree(info);
    }
}

NTSTATUS
SpUpdateDeviceInstanceData(
    IN HANDLE ControlSet
    )
/*++

Routine Description:

    This routine enumerates all the keys under HKLM\System\CCS\Enum and call
    SpUpdateDeviceInstanceKeyData for each device instance key.

Arguments:

    ControlSet - Handle to the control set to update.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;
    HANDLE hEnumBranchKey, hClassBranchKey;
    UNICODE_STRING enumBranch, classBranch;
    HANDLE hEnumeratorKey, hDeviceKey, hInstanceKey;
    UNICODE_STRING enumeratorName, deviceName, instanceName;
    PKEY_BASIC_INFORMATION  enumBasicInfo, deviceBasicInfo, instBasicInfo;
    ULONG ulEnumerator, ulDevice, ulInstance, ulLength, ulBasicInfoSize;

    //
    // Preinit for error
    //
    hEnumBranchKey = NULL;
    hClassBranchKey = NULL;
    enumBasicInfo = NULL;

    //
    // First open the enum branch for this control set
    //
    RtlInitUnicodeString(&enumBranch, REGSTR_KEY_ENUM);
    InitializeObjectAttributes(
        &obja,
        &enumBranch,
        OBJ_CASE_INSENSITIVE,
        ControlSet,
        NULL
        );

    status = ZwOpenKey(&hEnumBranchKey, KEY_ALL_ACCESS, &obja);

    if (!NT_SUCCESS(status)) {

        ASSERT(NT_SUCCESS(status));
        goto Exit;
    }

    //
    // Now open the class key for this control set.
    //
    RtlInitUnicodeString(&classBranch, REGSTR_KEY_CONTROL L"\\" REGSTR_KEY_CLASS);
    InitializeObjectAttributes(
        &obja,
        &classBranch,
        OBJ_CASE_INSENSITIVE,
        ControlSet,
        NULL
        );

    status = ZwOpenKey(&hClassBranchKey, KEY_ALL_ACCESS, &obja);

    if (!NT_SUCCESS(status)) {

        ASSERT(NT_SUCCESS(status));
        goto Exit;
    }

    //
    // Allocate memory for enumeration
    //
    ulBasicInfoSize = sizeof(KEY_BASIC_INFORMATION) + REG_MAX_KEY_NAME_LENGTH;
    enumBasicInfo = SpMemAlloc(ulBasicInfoSize * 3);
    if (enumBasicInfo == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    //
    // Cast two pointers for future buffer usage.
    //
    deviceBasicInfo = (PKEY_BASIC_INFORMATION)((PUCHAR)enumBasicInfo + ulBasicInfoSize);
    instBasicInfo = (PKEY_BASIC_INFORMATION)((PUCHAR)deviceBasicInfo + ulBasicInfoSize);

    //
    // Walk each enumerator and then each device instance
    //
    status = STATUS_SUCCESS;
    for (ulEnumerator = 0; ; ulEnumerator++) {

        status = ZwEnumerateKey(
            hEnumBranchKey,
            ulEnumerator,
            KeyBasicInformation,
            enumBasicInfo,
            ulBasicInfoSize,
            &ulLength
            );

        if (!NT_SUCCESS(status)) {

            break;
        }

        //
        // Open the enumerator
        //
        enumeratorName.Length = enumeratorName.MaximumLength = (USHORT)enumBasicInfo->NameLength;
        enumeratorName.Buffer = &enumBasicInfo->Name[0];
        InitializeObjectAttributes(
            &obja,
            &enumeratorName,
            OBJ_CASE_INSENSITIVE,
            hEnumBranchKey,
            NULL
            );

        status = ZwOpenKey(&hEnumeratorKey, KEY_ALL_ACCESS, &obja);

        if (!NT_SUCCESS(status)) {

            break;
        }

        //
        // Walk each device
        //
        for (ulDevice = 0; ; ulDevice++) {

            status = ZwEnumerateKey(
                hEnumeratorKey,
                ulDevice,
                KeyBasicInformation,
                deviceBasicInfo,
                ulBasicInfoSize,
                &ulLength
                );

            if (!NT_SUCCESS(status)) {

                break;
            }

            deviceName.Length = deviceName.MaximumLength = (USHORT)deviceBasicInfo->NameLength;
            deviceName.Buffer = &deviceBasicInfo->Name[0];
            InitializeObjectAttributes(
                &obja,
                &deviceName,
                OBJ_CASE_INSENSITIVE,
                hEnumeratorKey,
                NULL
                );

            status = ZwOpenKey(&hDeviceKey, KEY_ALL_ACCESS, &obja);

            if (!NT_SUCCESS(status)) {

                break;
            }

            //
            // Now walk each instance
            //
            for (ulInstance = 0; ; ulInstance++) {

                status = ZwEnumerateKey(
                    hDeviceKey,
                    ulInstance,
                    KeyBasicInformation,
                    instBasicInfo,
                    ulBasicInfoSize,
                    &ulLength
                    );

                if (!NT_SUCCESS(status)) {

                    break;
                }

                instanceName.Length = instanceName.MaximumLength = (USHORT)instBasicInfo->NameLength;
                instanceName.Buffer = &instBasicInfo->Name[0];
                InitializeObjectAttributes(
                    &obja,
                    &instanceName,
                    OBJ_CASE_INSENSITIVE,
                    hDeviceKey,
                    NULL
                    );

                status = ZwOpenKey(&hInstanceKey, KEY_ALL_ACCESS, &obja);

                if (!NT_SUCCESS(status)) {

                    break;
                }

                SpUpdateDeviceInstanceKeyData(
                    hInstanceKey,
                    hClassBranchKey,
                    &enumeratorName,
                    &deviceName,
                    &instanceName
                    );

                ZwClose(hInstanceKey);
            }

            ZwClose(hDeviceKey);

            if (status != STATUS_NO_MORE_ENTRIES) {

                break;
            }
        }

        ZwClose(hEnumeratorKey);

        if (status != STATUS_NO_MORE_ENTRIES) {

            break;
        }
    }

    //
    // STATUS_NO_MORE_ENTRIES isn't a failure, it just means we've exhausted
    // the number of enumerators.
    //
    if (status == STATUS_NO_MORE_ENTRIES) {

        status = STATUS_SUCCESS;
    }

Exit:

    if (enumBasicInfo) {

        SpMemFree(enumBasicInfo);
    }

    if (hEnumBranchKey) {

        ZwClose(hEnumBranchKey);
    }

    if (hClassBranchKey) {

        ZwClose(hClassBranchKey);
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}

NTSTATUS
SppDeleteRegistryValueRecursive(
    HANDLE  hKeyRoot,
    PWSTR   KeyPath,    OPTIONAL
    PWSTR   ValueToDelete
    )
/*++

Routine Description:

    This routine will recursively enumerate the specified hKeyRoot and KeyPath
    and delete any ValueToDelete registry values in those keys.

Arguments:

    hKeyRoot: Handle to root key

    KeyPath:  root key relative path to the subkey which needs to be
              recursively copied. if this is null hKeyRoot is the key
              from which the recursive copy is to be done.

    ValueToDelete  name of the value that needs to be deleted.

Return Value:

    Status is returned.

--*/

{
    NTSTATUS             Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES    ObjaSrc;
    UNICODE_STRING       UnicodeStringSrc, UnicodeStringValue;
    HANDLE               hKey=NULL;
    ULONG                ResultLength, Index;
    PWSTR                SubkeyName;

    PKEY_BASIC_INFORMATION      KeyInfo;

    //
    // Get a handle to the source key
    //
    if(KeyPath == NULL) {
        hKey = hKeyRoot;
    }
    else {
        //
        // Open the Src key
        //
        INIT_OBJA(&ObjaSrc,&UnicodeStringSrc,KeyPath);
        ObjaSrc.RootDirectory = hKeyRoot;
        Status = ZwOpenKey(&hKey,KEY_READ,&ObjaSrc);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open key %ws in the source hive (%lx)\n",KeyPath,Status));
            return(Status);
        }
    }

    //
    // Enumerate all keys in the source key and recursively create
    // all the subkeys
    //
    KeyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;
    for( Index=0;;Index++ ) {

        Status = ZwEnumerateKey(
                    hKey,
                    Index,
                    KeyBasicInformation,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    &ResultLength
                    );

        if(!NT_SUCCESS(Status)) {
            if(Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            else {
                if(KeyPath!=NULL) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to enumerate subkeys in key %ws(%lx)\n",KeyPath, Status));
                }
                else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to enumerate subkeys in root key(%lx)\n", Status));
                }
            }
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        KeyInfo->Name[KeyInfo->NameLength/sizeof(WCHAR)] = 0;

        //
        // Make a duplicate of the subkey name because the name is
        // in TemporaryBuffer, which might get clobbered by recursive
        // calls to this routine.
        //
        SubkeyName = SpDupStringW(KeyInfo->Name);
        if (SubkeyName) {
            Status = SppDeleteRegistryValueRecursive(
                         hKey,
                         SubkeyName,
                         ValueToDelete
                         );

            SpMemFree(SubkeyName);
        }
    }

    //
    // Process any errors if found
    //
    if(!NT_SUCCESS(Status)) {

        if(KeyPath != NULL) {
            ZwClose(hKey);
        }

        return(Status);
    }

    //
    // Delete the ValueToDelete value in this key.  We won't check the status
    // since it doesn't matter if this succeeds or not.
    //
    RtlInitUnicodeString(&UnicodeStringValue, ValueToDelete);
    ZwDeleteValueKey(hKey,&UnicodeStringValue);

    //
    // cleanup
    //
    if(KeyPath != NULL) {
        ZwClose(hKey);
    }

    return(Status);
}

NTSTATUS
SpCleanUpHive(
    VOID
    )

/*++

Routine Description:

    This routine will cleanup the system hive before it is migrated to the
    target system hive.

Arguments:

    none

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE hKey;

    INIT_OBJA(&Obja,&UnicodeString,L"\\registry\\machine\\system\\currentcontrolset");
    Obja.RootDirectory = NULL;
    Status = ZwOpenKey(&hKey,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive (%lx)\n", L"\\registry\\machine\\system\\currentcontrolset", Status));
        return( Status ) ;
    }

    //
    // Delete the DeviceDesc values from under the enum key.
    // The reason for this is that if we replace the DeviceDesc values on an
    // upgrade then GUI mode setup won't be able to backup any 3rd party drivers
    // that we are replaceing with our in-box drivers. This is because the
    // DeviceDesc is one of three values that setupapi uses to create a
    // unique driver node.
    //
    if (NTUpgrade == UpgradeFull) {
        Status = SppDeleteRegistryValueRecursive(
                        hKey,
                        REGSTR_KEY_ENUM,
                        REGSTR_VAL_DEVDESC
                        );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls to the target hive. KeyPath, Status = %lx\n", Status));
        }
    }

    ZwClose( hKey );

    return( Status );
}

NTSTATUS
SpIterateRegistryKeyForKeys(
    IN HANDLE RootKeyHandle,
    IN PWSTR  KeyToIterate,
    IN SP_REGISTRYKEY_ITERATION_CALLBACK Callback,
    IN PVOID  Context
    )
/*++

Routine Description:

    Iterates the registry key looking for registry keys which are
    immediately below the current key.

    NOTE : To stop the iteration the callback function should return
        FALSE.

Arguments:

    RootKeyHandle - The root key which contains the key to iterate

    KeyToIterate - The relative path for the key to iterate w.r.t to 
        root key.

    Callback - The call function which will be called for each subkey
        found under the requested key.

    Context - Opaque context data that the caller needs and will be
        passed on by the iteration routine for each invocation of
        the callback function.
        
Return Value:

    Appropriate NT status error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    //
    // Validate the arguments
    //
    if (RootKeyHandle && KeyToIterate && Callback) {
        HANDLE  KeyHandle = NULL; 
        UNICODE_STRING KeyName;
        OBJECT_ATTRIBUTES ObjAttrs;

        //
        // Open the key which needs to be iterated
        //
        INIT_OBJA(&ObjAttrs, &KeyName, KeyToIterate);
        ObjAttrs.RootDirectory = RootKeyHandle;

        Status = ZwOpenKey(&KeyHandle,
                    KEY_ALL_ACCESS,
                    &ObjAttrs);

        if (NT_SUCCESS(Status)) {
            ULONG BufferLength = 4096;
            PKEY_FULL_INFORMATION FullInfo = (PKEY_FULL_INFORMATION)SpMemAlloc(BufferLength);
            ULONG ResultLength = 0;

            if (FullInfo) {                
                //
                // Find out how many subkeys the current key has
                //
                Status = ZwQueryKey(KeyHandle,
                            KeyFullInformation,
                            FullInfo,
                            BufferLength,
                            &ResultLength);

                if (NT_SUCCESS(Status)) {
                    ULONG NumSubKeys = FullInfo->SubKeys;
                    ULONG Index;
                    BOOLEAN Done;
                    NTSTATUS LastError = STATUS_SUCCESS;

                    //
                    // Iterate each subkey of the current key and callback
                    // the subscriber function
                    //
                    for (Index = 0, Done = FALSE; 
                        NT_SUCCESS(Status) && !Done && (Index < NumSubKeys); 
                        Index++) {
                        
                        PKEY_BASIC_INFORMATION BasicInfo = (PKEY_BASIC_INFORMATION)FullInfo;

                        Status = ZwEnumerateKey(KeyHandle,
                                    Index,
                                    KeyBasicInformation,
                                    BasicInfo,
                                    BufferLength,
                                    &ResultLength);

                        if (NT_SUCCESS(Status)) {
                            NTSTATUS CallbackStatus = STATUS_SUCCESS;
                            SP_REGISTRYKEY_ITERATION_CALLBACK_DATA CallbackData;

                            CallbackData.InformationType = KeyBasicInformation;
                            CallbackData.Information = (PVOID)BasicInfo;
                            CallbackData.ParentKeyHandle = KeyHandle;

                            //
                            // Callback
                            //
                            Done = (Callback(Context, &CallbackData, &CallbackStatus) == FALSE);

                            //
                            // register any error and continue on
                            //
                            if (!NT_SUCCESS(CallbackStatus)) {
                                LastError = CallbackStatus;
                            }
                        } else if (Status == STATUS_NO_MORE_ENTRIES) {
                            //
                            // Done with iteration
                            //
                            Done = TRUE;
                            Status = STATUS_SUCCESS;
                        } 
                    }                    

                    if (!NT_SUCCESS(LastError)) {
                        Status = LastError;
                    }                        
                }

                SpMemFree(FullInfo);
            } else {
                Status = STATUS_NO_MEMORY;
            }                
        }                                            
    }

    return Status;
}


//
// Context data structure for class filter deletion
//
typedef struct _SP_CLASS_FILTER_DELETE_CONTEXT {
    PVOID   Buffer;
    ULONG   BufferLength;
    PWSTR   DriverName;
} SP_CLASS_FILTER_DELETE_CONTEXT, *PSP_CLASS_FILTER_DELETE_CONTEXT;    

static
BOOLEAN 
SppFixUpperAndLowerFilterEntries(
    IN PVOID Context,
    IN PSP_REGISTRYKEY_ITERATION_CALLBACK_DATA Data,
    OUT NTSTATUS *Status
    )
/*++

Routine Description:


Arguments:

    Context - The SP_CLASS_FILTER_DELETE_CONTEXT disguised as
        a void pointer.

    Data - The data the iterator passed to us, containing information
        about the current subkey.

    Status - Place holder for receiving the error status code which
        this function returns.

Return Value:

    TRUE if the iteration needs to be continued otherwise FALSE.

--*/
{
    BOOLEAN Result = FALSE;    

    *Status = STATUS_INVALID_PARAMETER;

    if (Context && Data && (Data->InformationType == KeyBasicInformation)) {
        NTSTATUS UpperStatus, LowerStatus;
        PKEY_BASIC_INFORMATION  BasicInfo = (PKEY_BASIC_INFORMATION)(Data->Information);
        PSP_CLASS_FILTER_DELETE_CONTEXT DelContext = (PSP_CLASS_FILTER_DELETE_CONTEXT)Context;
        PWSTR KeyName = (PWSTR)(DelContext->Buffer);

        if (KeyName && (BasicInfo->NameLength < DelContext->BufferLength)) {
            wcsncpy(KeyName, BasicInfo->Name, BasicInfo->NameLength/sizeof(WCHAR));
            KeyName[BasicInfo->NameLength/sizeof(WCHAR)] = UNICODE_NULL;

            //
            // Delete the string from upperfilters
            //
            UpperStatus = SpRemoveStringFromMultiSz(Data->ParentKeyHandle,
                                KeyName,
                                SP_UPPER_FILTERS,
                                DelContext->DriverName);

            //
            // Delete the string from lowerfilters
            //
            LowerStatus = SpRemoveStringFromMultiSz(Data->ParentKeyHandle,
                                KeyName,
                                SP_LOWER_FILTERS,
                                DelContext->DriverName);

            if (NT_SUCCESS(UpperStatus) || NT_SUCCESS(LowerStatus)) {
                *Status = STATUS_SUCCESS;
            } else if (((UpperStatus == STATUS_OBJECT_NAME_NOT_FOUND) ||
                        (UpperStatus == STATUS_OBJECT_NAME_INVALID)) && 
                       ((LowerStatus == STATUS_OBJECT_NAME_NOT_FOUND) ||
                        (LowerStatus == STATUS_OBJECT_NAME_INVALID))) {
                //
                // If the value was not found then continue on
                //
                *Status = STATUS_SUCCESS;
            }            

            // 
            // we want to continue iterating irrespective of the results
            //
            Result = TRUE;
        }            
    }

    return Result;
}



NTSTATUS
SpProcessServicesToDisable(
    IN PVOID WinntSifHandle,
    IN PWSTR SectionName,
    IN HANDLE CurrentControlSetKey
    )
/*++

Routine Description:

    Processess the winnt.sif's [ServiceToDisable] section to 
    remove the service entries from upper and lower filters.    

Arguments:

    WinntSifHandle - Handle to winnt.sif file.

    SectionName - The name of section in winnt.sif which contains
        a list of service name which need to be removed from
        the filter list.

    CurrentControlKey - The handle to CurrentControlSet root key.        

Return Value:

    Appropriate NTSTATUS error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    //
    // Validate arguments
    //
    if (WinntSifHandle && SectionName && CurrentControlSetKey) {        
        ULONG EntriesToProcess = SpCountLinesInSection(WinntSifHandle,
                                    SP_SERVICES_TO_DISABLE);                                        

        //
        // If there are any entries to process -- then process them
        //
        if (EntriesToProcess) {                                        
            ULONG BufferLength = 16 * 1024;
            PVOID Buffer = SpMemAlloc(BufferLength);

            if (Buffer) {
                ULONG Index;
                PWSTR CurrentEntry;
                SP_CLASS_FILTER_DELETE_CONTEXT DeleteContext = {0};                
                NTSTATUS LastErrorStatus = STATUS_SUCCESS;

                //
                // Process each entry
                //
                DeleteContext.Buffer = Buffer;
                DeleteContext.BufferLength = BufferLength;

                for(Index = 0; Index < EntriesToProcess; Index++) {                            
                    CurrentEntry = SpGetSectionLineIndex(WinntSifHandle,
                                        SP_SERVICES_TO_DISABLE,
                                        Index,
                                        0);

                    if (CurrentEntry) {
                        DeleteContext.DriverName = CurrentEntry;
                        
                        Status = SpIterateRegistryKeyForKeys(CurrentControlSetKey,
                                        L"Class",
                                        SppFixUpperAndLowerFilterEntries,
                                        &DeleteContext);

                        //
                        // save away the error code and continue on
                        //
                        if (!NT_SUCCESS(Status)) {
                            LastErrorStatus = Status;
                        }
                    }                                        
                }

                //
                // Even one of the entries failed to delete correctly
                // then flag it as a failure
                //
                if (!NT_SUCCESS(LastErrorStatus)) {
                    Status = LastErrorStatus;
                }                    

                SpMemFree(Buffer);
            }                                
        } else {
            Status = STATUS_SUCCESS;    // nothing to process
        }                
    }

    return Status;
}


//
// Context data structure for device instance filter deletion
//
typedef struct _SP_DEVINSTANCE_FILTER_DELETE_CONTEXT {
    PVOID   Buffer;
    ULONG   BufferLength;
    PUNICODE_STRING *ClassGuids;
} SP_DEVINSTANCE_FILTER_DELETE_CONTEXT, *PSP_DEVINSTANCE_FILTER_DELETE_CONTEXT;    


static
VOID
SppRemoveFilterDriversForClassDeviceInstances(
    IN HANDLE  SetupInstanceKeyHandle,
    IN HANDLE  UpgradeInstanceKeyHandle,
    IN BOOLEAN RootEnumerated,
    IN PVOID   Context
    )
/*++

Routine Description:

    Callback which removes the filter drivers for the 
    specified device instance

Arguments:

    SetupInstanceKeyHandle - Handle to device instance key in setupreg.hiv.

    UpgradeInstanceKeyHandle - Handle to device instance key in the
        system hive of the installation being upgraded.

    RootEnumerated - Whether this is root enumerated key or not.

    Context - SP_DEVINSTANCE_FILTER_DELETE_CONTEXT instance disguised 
        as PVOID context.

Return Value:

    None.

--*/
{
    //
    // Validate arguments
    //
    if (Context && SetupInstanceKeyHandle) {        
        PSP_DEVINSTANCE_FILTER_DELETE_CONTEXT DelContext;

        //
        // get device instance filter deletion context
        //
        DelContext = (PSP_DEVINSTANCE_FILTER_DELETE_CONTEXT)Context;

        //
        // Validate the context
        //
        if (DelContext->Buffer && DelContext->BufferLength && 
            DelContext->ClassGuids && DelContext->ClassGuids[0]) {

            PKEY_VALUE_FULL_INFORMATION  ValueInfo;
            UNICODE_STRING GuidValueName;
            ULONG BufferLength;
            NTSTATUS Status;
            BOOLEAN DeleteFilterValueKeys = FALSE;

            //
            // reuse the buffer allocated by the iterator caller
            //
            ValueInfo = (PKEY_VALUE_FULL_INFORMATION)(DelContext->Buffer);

            RtlInitUnicodeString(&GuidValueName, SP_CLASS_GUID_VALUE_NAME);

            //
            // Get the class GUID for the current device instance
            //
            Status = ZwQueryValueKey(SetupInstanceKeyHandle,
                        &GuidValueName,
                        KeyValueFullInformation,
                        ValueInfo,
                        DelContext->BufferLength - sizeof(WCHAR),
                        &BufferLength);

            if (NT_SUCCESS(Status)) {
                PWSTR CurrentGuid = (PWSTR)(((PUCHAR)ValueInfo + ValueInfo->DataOffset));
                ULONG Index;

                //
                // null terminate the string (NOTE:we assume buffer has space)
                //
                CurrentGuid[ValueInfo->DataLength/sizeof(WCHAR)] = UNICODE_NULL;

                //
                // Is this the one of the class device instance we are looking for?
                //
                for (Index = 0; DelContext->ClassGuids[Index]; Index++) {
                    if (!_wcsicmp(CurrentGuid, DelContext->ClassGuids[Index]->Buffer)) {
                        DeleteFilterValueKeys = TRUE;

                        break;
                    }
                }                
            }

            //
            // Delete the upper and lower filter value keys
            //
            if (DeleteFilterValueKeys) {
                UNICODE_STRING  UpperValueName, LowerValueName;
                
                RtlInitUnicodeString(&UpperValueName, SP_UPPER_FILTERS);
                RtlInitUnicodeString(&LowerValueName, SP_LOWER_FILTERS);

                if (SetupInstanceKeyHandle) {
                    ZwDeleteValueKey(SetupInstanceKeyHandle, &UpperValueName);
                    ZwDeleteValueKey(SetupInstanceKeyHandle, &LowerValueName);
                }                    

                if (UpgradeInstanceKeyHandle) {
                    ZwDeleteValueKey(UpgradeInstanceKeyHandle, &UpperValueName);
                    ZwDeleteValueKey(UpgradeInstanceKeyHandle, &LowerValueName);
                }                    
            }        
        }            
    }            
}


NTSTATUS
SpDeleteRequiredDeviceInstanceFilters(
    IN HANDLE CCSKeyHandle
    )
/*++

Routine Description:

    Deletes filter entries from keyboard and mouse class device
    instances in registry.

Arguments:

    CCSHandle - Handle to CCS key.

Return Value:

    Appropriate NT status code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (CCSKeyHandle) {
        UNICODE_STRING  MouseGuidStr = {0};
        UNICODE_STRING  KeyboardGuidStr = {0};
        PUNICODE_STRING ClassGuids[16] = {0};
        ULONG CurrentIndex = 0;
        NTSTATUS LastErrorCode = STATUS_SUCCESS;

        //
        // Get hold of keyboard class GUID string
        //
        Status = RtlStringFromGUID(&GUID_DEVCLASS_KEYBOARD, &KeyboardGuidStr);

        if (NT_SUCCESS(Status)) {
            ClassGuids[CurrentIndex++] = &KeyboardGuidStr;
        } else {
            LastErrorCode = Status;
        } 

        //
        // Get hold of mouse class GUID string
        //
        Status = RtlStringFromGUID(&GUID_DEVCLASS_MOUSE, &MouseGuidStr);

        if (NT_SUCCESS(Status)) {
            ClassGuids[CurrentIndex++] = &MouseGuidStr;
        } else {
            LastErrorCode = Status;
        }            

        //
        // If we could form atleast one class guid string
        //
        if (CurrentIndex) {
            SP_DEVINSTANCE_FILTER_DELETE_CONTEXT  DelContext = {0};
            ULONG BufferLength = 4096;
            PVOID Buffer = SpMemAlloc(BufferLength);

            if (Buffer) {            
                // 
                // null terminate the class GUID unicode string array
                //
                ClassGuids[CurrentIndex] = NULL;

                DelContext.Buffer = Buffer;
                DelContext.BufferLength = BufferLength;
                DelContext.ClassGuids = ClassGuids;

                //
                // Iterate through all the device instances
                //
                SpApplyFunctionToDeviceInstanceKeys(CCSKeyHandle,
                    SppRemoveFilterDriversForClassDeviceInstances,
                    &DelContext);  

                SpMemFree(Buffer);                    
            } else {
                LastErrorCode = STATUS_NO_MEMORY;
            }                

            //
            // free the allocated strings
            //
            if (MouseGuidStr.Buffer) {
                RtlFreeUnicodeString(&MouseGuidStr);
            }

            if (KeyboardGuidStr.Buffer) {
                RtlFreeUnicodeString(&KeyboardGuidStr);
            }            
        }            

        Status = LastErrorCode;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spdblspc.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdblspc.c

Abstract:

    Code that detects compressed drives on a system that contains
    dblspace.ini in the root of c:.

Author:

    Jaime Sasson (jaimes) 01-October-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

//
//  This variable is needed since it contains a buffer that can
//  be used in kernel mode. The buffer is used by NtFsControlFile,
//  since the Zw API is not exported
//
extern PSETUP_COMMUNICATION  CommunicationParams;


#define KWD_ACT             L"ActivateDrive"
#define KWD_FIRST           L"FirstDrive"
#define KWD_LAST            L"LastDrive"
#define KWD_MAXREM          L"MaxRemovableDrives"
#define KWD_MAXFILE         L"MaxFileFragments"
#define KWD_AUTOMOUNT       L"Automount"
#define KWD_DOUBLEGUARD     L"Doubleguard"
#define KWD_ROMSERVER       L"Romserver"
#define KWD_SWITCHES        L"Switches"
#define CVF_SEQ_MAX         255
#define MINFILEFRAGMENTS    50
#define MAXFILEFRAGMENTS    10000
#define DBLSPACE_INI_FILE   L"\\dblspace.ini"
#define CVF_NAME_PATTERN    L"DBLSPACE.%03d"

typedef struct _ACTIVATE_DRIVE {
    struct _ACTIVATE_DRIVE* Next;
    struct _ACTIVATE_DRIVE* Previous;
    WCHAR    MountDrive;
    WCHAR    HostDrive;
    USHORT    SeqNumber;
    } ACTIVATE_DRIVE, *PACTIVATE_DRIVE;

typedef struct _DBLSPACE_INI_INFO {
    USHORT          MaxRemovableDrives;
    WCHAR           FirstDrive;
    WCHAR           LastDrive;
    USHORT          MaxFileFragments;
    WCHAR           DoubleGuard[2];
    WCHAR           RomServer[2];
    PACTIVATE_DRIVE CompressedDriveList;
    WCHAR           AutoMount[30];
    WCHAR           Switches[4];
    } DBLSPACE_INI_INFO, *PDBLSPACE_INI_INFO;

BOOLEAN             DblspaceModified = FALSE;
DBLSPACE_INI_INFO   DblspaceInfo = { 0,                // MaxRemovableDrives
                                     0,                // FirstDrive
                                     0,                // LastDrive
                                     0,                // MaxFileFragments
                                     { (WCHAR)'\0' },  // DoubleGuard
                                     { (WCHAR)'\0' },  // RomServer
                                     NULL,             // CompressedDriveList
                                     { (WCHAR)'\0' },  // AutoMount[0]
                                     { (WCHAR)'\0' }   // Switches[0]
                                   };


LONG
CompareDrive(
    IN  PACTIVATE_DRIVE Drive1,
    IN  PACTIVATE_DRIVE Drive2
    )

/*++

Routine Description:

    Compares two structures of type ACTIVATE_DRIVE.
    This routine is used to sort the list of compressed drives
    in the global variable DblspaceInfo.

    Drive1 < Drive2 if
        Drive1->HostDrive < Drive2->HostDrive or
        Drive1->HostDrive ==  Drive2->HostDrive and
        Drive1->SeqNumber < Drive2->SeqNumber

    Drive1 == Drive2 if
        Drive1->HostDrive == Drive2->HostDrive and
        Drive1->SeqNumber == Drive2->SeqNumber

    Drive1 > Drive2 if
        Drive1->HostDrive > Drive2->HostDrive or
        Drive1->HostDrive ==  Drive2->HostDrive and
        Drive1->SeqNumber > Drive2->SeqNumber


Arguments:

    Drive1, Drive2 - Pointer to  ACTIVATE_STRUCTUREs to be compared.

Return Value:

    LONG - Returns: -1 if Drive1 < Drive2
                     0 if Drive1 == Drive2
                     1 if Drive1 > Drive2


--*/
{
    if( ( Drive1->HostDrive < Drive2->HostDrive ) ||
        ( ( Drive1->HostDrive == Drive2->HostDrive ) &&
          ( Drive1->SeqNumber < Drive2->SeqNumber ) )
      ) {
        return( -1 );
    } else if ( ( Drive1->HostDrive > Drive2->HostDrive ) ||
                ( ( Drive1->HostDrive == Drive2->HostDrive ) &&
                ( Drive1->SeqNumber > Drive2->SeqNumber ) )
      ) {
        return( 1 );
    }
    return( 0 );
}




BOOLEAN
AddCompressedDrive(
    IN  WCHAR   MountDrive,
    IN  WCHAR   HostDrive,
    IN  USHORT  SeqNumber
    )
/*++

Routine Description:

    Add an ACTIVATE_DRIVE structure to the list of compressed drives
    kept in DblspaceInfo.

Arguments:

    MountDrive - Indicates the drive letter of the compressed drive.

    HostDrive - Indicates the drive letter of the host drive (drive that
                contains the file dblspace.nnn) for the compressed drive.

    SeqNumber - Sequence number for the CVF file associated to the compressed
                drive.

Return Value:

    BOOLEAN - Returns TRUE if the information was successfully added
              to the list of compressed drives.


--*/

{
    PACTIVATE_DRIVE     NewElement;
    PACTIVATE_DRIVE     Pointer;

    NewElement = SpMemAlloc( sizeof( ACTIVATE_DRIVE ) );
    if( NewElement == NULL ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to allocate memory!\n" ) );
        return( FALSE );
    }
    NewElement->MountDrive = MountDrive;
    NewElement->HostDrive = HostDrive;
    NewElement->SeqNumber = SeqNumber;
    NewElement->Next = NULL;
    NewElement->Previous = NULL;

    if( ( Pointer = DblspaceInfo.CompressedDriveList ) == NULL ) {
        DblspaceInfo.CompressedDriveList = NewElement;
    } else {
        for( ; Pointer; Pointer = Pointer->Next ) {
            if( CompareDrive( NewElement, Pointer ) <= 0 ) {
                //
                //  Insert element
                //
                NewElement->Previous = Pointer->Previous;
                if( NewElement->Previous != NULL ) {
                    NewElement->Previous->Next = NewElement;
                } else {
                    DblspaceInfo.CompressedDriveList = NewElement;
                }
                NewElement->Next = Pointer;
                Pointer->Previous = NewElement;
                break;
            } else {
                if( Pointer->Next == NULL ) {
                    //
                    //  Insert element if element is greater than the last
                    //  element in the list
                    //
                    Pointer->Next = NewElement;
                    NewElement->Previous = Pointer;
                    break;
                }
            }
        }
    }
    DblspaceModified = TRUE;
    return( TRUE );
}



BOOLEAN
RemoveCompressedDrive(
    IN  WCHAR   Drive
    )

/*++

Routine Description:

    Remove a the entry from the list of compressed drives that describes
    a particular compressed drive.

Arguments:

    Drive - Drive letter that describes a compressed drive.

Return Value:


    BOOLEAN - Returns TRUE if the compressed drive was successfuly removed
              from the list of compressed drives. Returns FALSE
              if the drive was not found in the data base.

--*/
{
    PACTIVATE_DRIVE     Pointer;
    BOOLEAN             Status;

    Status = FALSE;

    Pointer = DblspaceInfo.CompressedDriveList;
    for( ; Pointer; Pointer = Pointer->Next ) {
        if( Pointer->MountDrive == Drive ) {
            if( Pointer->Previous != NULL ) {
                Pointer->Previous->Next = Pointer->Next;
            }
            if( Pointer->Next != NULL ) {
                Pointer->Next->Previous = Pointer->Previous;
            }
            if( Pointer == DblspaceInfo.CompressedDriveList ) {
                DblspaceInfo.CompressedDriveList = Pointer->Next;
            }
            SpMemFree( Pointer );
            Status = TRUE;
            DblspaceModified = TRUE;
            break;
        }
    }
    return( Status );
}


VOID
DumpDblspaceInfo()

/*++

Routine Description:

    Dump the information stored in the global variable DblspaceInfo
    into the debugger.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PACTIVATE_DRIVE Pointer;

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "MaxRemovableDrives=%d\n",
              DblspaceInfo.MaxRemovableDrives ));

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "FirstDrive=%c\n",
              ( CHAR )DblspaceInfo.FirstDrive ));

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "LastDrive=%c\n",
              ( CHAR )DblspaceInfo.LastDrive ));

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "MaxFileFragments=%d\n",
              DblspaceInfo.MaxFileFragments ));

    for( Pointer = DblspaceInfo.CompressedDriveList;
         Pointer;
         Pointer = Pointer->Next ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "ActivateDrive=%c,%c%d\n",
                  ( CHAR )Pointer->MountDrive,
                  ( CHAR )Pointer->HostDrive,
                  Pointer->SeqNumber ));
    }
}


VOID
DumpCompressedDrives(
    IN  PDISK_REGION    HostRegion
    )

/*++

Routine Description:

    Dump the compressed drive list associated to a particular host drive,
    into the debugger

Arguments:

    None.

Return Value:


    None.

--*/

{
    PDISK_REGION    CurrentDrive;

    if( ( HostRegion->Filesystem == FilesystemFat ) &&
        ( HostRegion->NextCompressed != NULL ) ) {


        for( CurrentDrive = HostRegion;
             CurrentDrive;
             CurrentDrive = CurrentDrive->NextCompressed ) {
            if( CurrentDrive->Filesystem == FilesystemFat ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "HostDrive = %wc\n", CurrentDrive->HostDrive) );
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "CompressedDrive = %wc, HostDrive = %wc, CVF = %wc:DBLSPACE.%03d\n", CurrentDrive->MountDrive, CurrentDrive->HostRegion->HostDrive, CurrentDrive->HostDrive, CurrentDrive->SeqNumber ) );
            }
        }
    }
}



VOID
DumpAllCompressedDrives()
/*++

Routine Description:

    Traverse all the structures that represent partitions and dump
    all compressed drives into the debugger.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG             DiskNumber;
    PPARTITIONED_DISK pDisk;
    PDISK_REGION      pRegion;
    unsigned          pass;

    for( DiskNumber = 0; DiskNumber < HardDiskCount; DiskNumber++ ) {

        pDisk = &PartitionedDisks[DiskNumber];

        for(pass=0; pass<2; pass++) {

            pRegion = pass ? pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions;
            for( ; pRegion; pRegion=pRegion->Next) {
                DumpCompressedDrives( pRegion );
            }
        }
    }
}



BOOLEAN
SpLoadDblspaceIni()
/*++

Routine Description:

    Read and parse dblspace.ini, if one is found.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if dblspace.ini was read successfully.
              Returns FALSE otherwise.

--*/

{
    PDISK_REGION CColonRegion;
    WCHAR        NtPath[ 512 ];
    NTSTATUS     Status;
    PVOID        Handle;
    ULONG        ErrorLine;

    ULONG   LineNumber;
    PWCHAR  Key;
    PWCHAR  Value1;
    PWCHAR  Value2;
    PWCHAR  Value3;
    UINT    ValueSize;
    ULONG   CvfNumber;
    ULONG   MaxNumber;
    PWCHAR  AuxPointer;


// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Entering SpLoadDblspaceIni\n"));
    //
    // See if there is a valid C: already.  If not, then silently fail.
    //
#ifndef _X86_

    return( FALSE );

#else

    CColonRegion = SpPtValidSystemPartition();
    if(!CColonRegion) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no C:, no dblspace.ini!\n"));
        return(FALSE);
    }

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Called SpPtValidSystemPartition\n"));

#endif
    //
    // Check the filesystem.  If not FAT, then silently fail.
    //
    if(CColonRegion->Filesystem != FilesystemFat) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: C: is not FAT, dblspace.ini!\n"));
        return(FALSE);
    }

    SpNtNameFromRegion(
        CColonRegion,
        NtPath,
        sizeof(NtPath),
        PartitionOrdinalCurrent
        );

    wcscat( NtPath, DBLSPACE_INI_FILE );

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Called SpNtNameFromRegion\n"));

    Status = SpLoadSetupTextFile( NtPath,
                                  NULL,
                                  0,
                                  &Handle,
                                  &ErrorLine,
                                  TRUE,
                                  FALSE
                                  );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: unable to read dblspace.ini!\n"));
        return( FALSE );
    }

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Called SpLoadSetupTextFile\n"));

    //
    //  Read and interpret each line in dblspace.ini
    //
//    DblspaceInfo.ActivateDriveCount = 0;
    LineNumber = 0;
    while( ( Key = SpGetKeyName( Handle,
                                 DBLSPACE_SECTION,
                                 LineNumber ) ) != NULL ) {
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Called SpGetKeyName\n"));
        if( _wcsicmp( Key, KWD_ACT ) == 0 ) {
            //
            //  Found an ActivateDrive= key
            //

            //
            //  Read mount drive letter
            //
            Value1 = SpGetSectionLineIndex( Handle,
                                            DBLSPACE_SECTION,
                                            LineNumber,
                                            0 );
            if( Value1 == NULL ) {
                //
                //  Unable to read mount drive letter
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: unable to read Mount Drive letter from dblspace.ini!\n"));
                continue;
            }
            //
            //  Validate Mount Drive letter
            //
            if( ( wcslen( Value1 ) != 1 ) ||
                ( !SpIsAlpha( *Value1 ) ) ) {
                //
                //  Mount Drive letter is not valid
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Mount Drive letter in dblspace.ini is not legal!\n"));
                continue;
            }
            //
            //  Read host drive letter
            //
            Value2 = SpGetSectionLineIndex( Handle,
                                            DBLSPACE_SECTION,
                                            LineNumber,
                                            1 );
            if( Value2 == NULL ) {
                //
                //  Unable to read host drive letter
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: unable to read Host Drive letter from dblspace.ini!\n"));
                continue;
            }
            //
            //  Validate Host Drive letter
            //
            ValueSize = wcslen( Value2 );
            if( ( ( ValueSize < 2 ) || ( ValueSize > 4 ) ) ||
                ( !SpIsAlpha( *Value2 ) ) ) {
                //
                //  Mount Drive letter is not valid
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Mount Drive letter in dblspace.ini is not legal!\n"));
                continue;
            }
            //
            //  Validate CVF string
            //
            Value3 = Value2 + 1;
            ValueSize--;
            while( ValueSize != 0 ) {
                if( !SpIsDigit( *Value3 ) ) {
                    //
                    //  CVF number is not valid
                    //
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: unable to read CVF number from dblspace.ini!\n"));
                    continue;
                }
                ValueSize--;
                Value3++;
            }
            //
            //  Validate CVF number
            //
            CvfNumber = (ULONG)SpStringToLong( Value2 + 1, &AuxPointer, 10 );
            if( CvfNumber > CVF_SEQ_MAX ) {
                //
                //  CVF number is out of range
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: found an invalid CVF number in dblspace.ini!\n"));
                continue;
            }
            //
            //  Save the values read in DblspaceInfo
            //
            if( !AddCompressedDrive( SpToUpper( *Value1 ),
                                     SpToUpper( *Value2 ),
                                     ( USHORT )CvfNumber ) ) {
                //
                //  CVF number is out of range
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to initialize DblspaceInfo: out of memory!\n"));
                continue;
            }

        } else if( ( _wcsicmp( Key, KWD_FIRST ) == 0 ) ||
                   ( _wcsicmp( Key, KWD_LAST ) == 0 ) ) {
            //
            //  Read first drive
            //
            Value1 = SpGetSectionLineIndex( Handle,
                                            DBLSPACE_SECTION,
                                            LineNumber,
                                            0 );
            if( Value1 == NULL ) {
                //
                //  Unable to read drive letter
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: unable to read FirstDrive or LastDrive from dblspace.ini!\n"));
                continue;
            }
            //
            //  Validate the drive letter
            //
            if( ( wcslen( Value1 ) != 1 ) ||
                ( !SpIsAlpha( *Value1 ) ) ) {
                //
                //  Drive letter is not valid
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: FirstDrive or LastDrive in dblspace.ini is not legal!\n"));
                continue;
            }
            if( _wcsicmp( Key, KWD_FIRST ) == 0 ) {
                DblspaceInfo.FirstDrive = SpToUpper( *Value1 );
            } else {
                DblspaceInfo.LastDrive = SpToUpper( *Value1 );
            }
        } else if( ( _wcsicmp( Key, KWD_MAXFILE ) == 0 ) ||
                   ( _wcsicmp( Key, KWD_MAXREM ) == 0 ) ) {
            //
            //  Read MaxFileFragment or MaxRemovableDrives
            //
            Value1 = SpGetSectionLineIndex( Handle,
                                            DBLSPACE_SECTION,
                                            LineNumber,
                                            0 );
            if( Value1 == NULL ) {
                //
                //  Unable to read MaxFileFragments or MaxRemovableDrives
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: unable to read MaxFileFragments or MaxRemovableDrives from dblspace.ini!\n"));
                continue;
            }
            //
            //  Validate MaxFileFragments or MaxRemovableDrives
            //
            Value2 = Value1;
            ValueSize = wcslen( Value2 );
            while( ValueSize != 0 ) {
                ValueSize--;
                if( !SpIsDigit( *Value2 ) ) {
                    //
                    //  Number is not valid
                    //
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: value of MaxFileFragments or MaxRemovableDrives in dblspace.ini is not valid!\n"));
                    ValueSize = 0;
                }
                Value2++;
            }
            //
            //  Validate number
            //
            MaxNumber = (ULONG)SpStringToLong( Value1, &AuxPointer, 10 );
            //
            //  Validate and initialize MaxFileFragments or MaxRemovableDrives
            //
            if( _wcsicmp( Key, KWD_MAXFILE ) == 0 ) {
                if( MaxNumber < MINFILEFRAGMENTS ) {
                    MaxNumber = MINFILEFRAGMENTS;
                } else if( MaxNumber > MAXFILEFRAGMENTS ) {
                    MaxNumber = MAXFILEFRAGMENTS;
                }
                DblspaceInfo.MaxFileFragments = ( USHORT )MaxNumber;
            } else {
                DblspaceInfo.MaxRemovableDrives = ( MaxNumber == 0 )?
                                                  1 : ( USHORT )MaxNumber;
            }
        } else if( ( _wcsicmp( Key, KWD_DOUBLEGUARD ) == 0 ) ||
                   ( _wcsicmp( Key, KWD_ROMSERVER ) == 0 ) ||
                   ( _wcsicmp( Key, KWD_SWITCHES ) == 0 ) ||
                   ( _wcsicmp( Key, KWD_AUTOMOUNT ) == 0 ) ) {
            //
            //  Read Doubleguard, Romerver, Switches, or Automount
            //
            Value1 = SpGetSectionLineIndex( Handle,
                                            DBLSPACE_SECTION,
                                            LineNumber,
                                            0 );
            if( Value1 == NULL ) {
                //
                //  Unable to read Doubleguard, Romerver, Switches, or Automount
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: unable to read Doubleguard, Romerver, Switches, or Automount from dblspace.ini!\n"));
                continue;
            }
            if( _wcsicmp( Key, KWD_DOUBLEGUARD ) == 0 ) {
                wcsncpy( DblspaceInfo.DoubleGuard,
                         Value1,
                         sizeof( DblspaceInfo.DoubleGuard ) / sizeof( WCHAR ) );

            } else if( _wcsicmp( Key, KWD_ROMSERVER ) == 0 ) {
                wcsncpy( DblspaceInfo.RomServer,
                         Value1,
                         sizeof( DblspaceInfo.RomServer ) / sizeof( WCHAR ) );

            } else if( _wcsicmp( Key, KWD_SWITCHES ) == 0 ) {
                wcsncpy( DblspaceInfo.Switches,
                         Value1,
                         sizeof( DblspaceInfo.Switches ) / sizeof( WCHAR ) );

            } else {
                wcsncpy( DblspaceInfo.AutoMount,
                         Value1,
                         sizeof( DblspaceInfo.AutoMount ) / sizeof( WCHAR ) );

            }

        } else {
                //
                //  Invalid key in dblspace.ini
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: dblspace.ini contains invalid key!\n"));
                continue;
        }
        LineNumber++;
    }

    SpFreeTextFile( Handle );

    //
    // Clear DblspaceModified flag, so that dblspace.ini won't get updated when
    // SpUpdateDoubleSpaceIni() is called, and no compressed drive was added or
    // deleted.
    //
    DblspaceModified = FALSE;

// DumpDblspaceInfo();
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Exiting SpLoadDblspaceIni\n"));

    return( TRUE );
}


BOOLEAN
IsHostDrive(
    IN  WCHAR            Drive,
    OUT PACTIVATE_DRIVE* Pointer
    )
/*++

Routine Description:

    Find out whether a particular drive is the host for a compressed drive.

Arguments:

    Drive -

    Pointer - Variable that will contain the pointer for an entry in the
              list of compressed drives, that describes the compressed
              drive with the lowest sequence number, whose host drive
              is the drive received as parameter.

Return Value:


    BOOLEAN - Returns TRUE if the drive passed as argument is a host drive.
              Returns FALSE otherwise.


--*/

{
    PACTIVATE_DRIVE  p;
    BOOLEAN Status;

    Status = FALSE;
    for( p = DblspaceInfo.CompressedDriveList;
         ( p && ( p->HostDrive != Drive ) );
         p = p->Next );
    if( p ) {
        *Pointer = p;
        Status = TRUE;
    }
    return( Status );
}


NTSTATUS
MountDoubleSpaceDrive(
    IN  PDISK_REGION    HostRegion,
    IN  PACTIVATE_DRIVE CompressedDriveInfo
    )
/*++

Routine Description:

    Mount a double space drive.

Arguments:

    HostRegion - Pointer to the structure that describes a FAT partition, that
                 will be the host for the compressed drive.

    CompressedDriveInfo - Pointer to a structure that contains the information
                          about the compressed drive to be mounted.


Return Value:

    NTSTATUS - Returns an NT status code indicating whether or not the drive
               was mounted.

--*/

{
#ifdef FULL_DOUBLE_SPACE_SUPPORT
    NTSTATUS                Status;
    WCHAR                   HostName[512];
    UNICODE_STRING          UnicodeDasdName;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    IO_STATUS_BLOCK         IoStatusBlock;
    PIO_STATUS_BLOCK        KernelModeIoStatusBlock;
    HANDLE                  Handle;
    PFILE_MOUNT_DBLS_BUFFER KernelModeMountFsctlBuffer;


    SpNtNameFromRegion(
        HostRegion,
        HostName,
        sizeof(HostName),
        PartitionOrdinalCurrent
        );

    RtlInitUnicodeString( &UnicodeDasdName, HostName );

    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeDasdName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );


    Status = ZwCreateFile( &Handle,
                           GENERIC_READ,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           0,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           OPEN_EXISTING,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ("SETUP: NtCreateFile failed, Status = %x\n", Status ) );
        return( Status );
    }
    //
    // Note that since we use the NtFsControlFile API instead of the
    // Zw API (this one is not exported), we need a buffer for IoStatusBlock
    // and for MountBuffer, that can be used in kernel mode.
    // We use the the region of memory pointed by CommunicationParams for this
    // purpose.
    //
    KernelModeIoStatusBlock = ( PIO_STATUS_BLOCK )( &(CommunicationParams->Buffer[0]) );
    *KernelModeIoStatusBlock = IoStatusBlock;
    KernelModeMountFsctlBuffer = ( PFILE_MOUNT_DBLS_BUFFER )( &(CommunicationParams->Buffer[128]) );

    KernelModeMountFsctlBuffer->CvfNameLength =
                                 sizeof(WCHAR) * swprintf( KernelModeMountFsctlBuffer->CvfName,
                                                           CVF_NAME_PATTERN,
                                                           CompressedDriveInfo->SeqNumber );

    Status = NtFsControlFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              KernelModeIoStatusBlock,
                              FSCTL_MOUNT_DBLS_VOLUME,
                              KernelModeMountFsctlBuffer,
                              sizeof( FILE_MOUNT_DBLS_BUFFER ) + 12*sizeof( WCHAR ),
                              NULL,
                              0 );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to mount %ls. NtFsControlFile returned Status = %x\n",
                  KernelModeMountFsctlBuffer->CvfName, Status ) );
    }
    ZwClose( Handle );
    return( Status );
#else //FULL_DOUBLE_SPACE_SUPPORT
    return( STATUS_SUCCESS );
#endif
}


VOID
MountCompressedDrives(
    IN  PDISK_REGION    HostRegion
    )
/*++

Routine Description:

    Mount all compressed drives detected on a partition.

Arguments:

    HostRegion - Pointer to the structure that describes a FAT partition.

Return Value:

    None.

--*/

{
    PDISK_REGION    CompressedList;
    PDISK_REGION    CurrentDrive;
    PDISK_REGION    TmpPointer;
    WCHAR           HostDrive;
    PACTIVATE_DRIVE Pointer;

    CompressedList = NULL;
    CurrentDrive = NULL;
    if( ( HostRegion != NULL ) &&
        ( HostRegion->Filesystem == FilesystemFat ) &&
        IsHostDrive( HostRegion->DriveLetter, &Pointer )
      ) {
        HostDrive = HostRegion->DriveLetter;
        for( ;
             ( Pointer && ( HostDrive == Pointer->HostDrive ));
             Pointer = Pointer->Next ) {
            //
            //  Mount the drive
            //
            if( NT_SUCCESS( MountDoubleSpaceDrive( HostRegion, Pointer) ) ) {
                //
                //  Drive was mounted successfully
                //
                TmpPointer =
                    SpPtAllocateDiskRegionStructure( HostRegion->DiskNumber,
                                                     HostRegion->StartSector,
                                                     HostRegion->SectorCount,
                                                     HostRegion->PartitionedSpace,
                                                     HostRegion->MbrInfo,
                                                     HostRegion->TablePosition );
                ASSERT( TmpPointer );
                if( TmpPointer == NULL ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to allocate memory\n" ) );
                    //
                    //  Unmount drive
                    //
                    continue;
                }
                TmpPointer->NextCompressed = NULL;
                TmpPointer->HostRegion = HostRegion;
                TmpPointer->Filesystem = FilesystemDoubleSpace;
                TmpPointer->SeqNumber = Pointer->SeqNumber;
                if( TmpPointer->SeqNumber == 0 ) {
                    TmpPointer->MountDrive = Pointer->HostDrive;
                    TmpPointer->HostDrive = Pointer->MountDrive;
                    HostRegion->HostDrive = TmpPointer->HostDrive;
                } else {
                    TmpPointer->MountDrive = Pointer->MountDrive;
                    if( HostRegion->HostDrive == 0 ) {
                        HostRegion->HostDrive = Pointer->HostDrive;
                    }
                    TmpPointer->HostDrive = HostRegion->HostDrive;
                }
                swprintf( TmpPointer->TypeName,
                          CVF_NAME_PATTERN,
                          TmpPointer->SeqNumber );
                if( CompressedList == NULL ) {
                    TmpPointer->PreviousCompressed = NULL;
                    CompressedList = TmpPointer;
                } else {
                    TmpPointer->PreviousCompressed = CurrentDrive;
                    CurrentDrive->NextCompressed = TmpPointer;
                }
                CurrentDrive = TmpPointer;
            }
        }

    }
    HostRegion->NextCompressed = CompressedList;
}



VOID
SpInitializeCompressedDrives()
/*++

Routine Description:

    Traverse the structure that describes all the disks in the system,
    and mount all compressed drives previously identified.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG             DiskNumber;
    PPARTITIONED_DISK pDisk;
    PDISK_REGION      pRegion;
    unsigned          pass;

    for( DiskNumber = 0; DiskNumber < HardDiskCount; DiskNumber++ ) {

        pDisk = &PartitionedDisks[DiskNumber];

        for(pass=0; pass<2; pass++) {

            pRegion = pass ? pDisk->ExtendedDiskRegions : pDisk->PrimaryDiskRegions;
            for( ; pRegion; pRegion=pRegion->Next) {
                MountCompressedDrives( pRegion );
            }
        }
    }
//    DumpAllCompressedDrives();
}


VOID
SpDisposeCompressedDrives(
    PDISK_REGION    CompressedDrive
    )
/*++

Routine Description:

    Delete the list of compressed drives found in a structure
    associated with a partition in the disk.
    This function is called when the user deletes a host partition
    that contains compressed drives.
    The list of compressed drives kept in the global variable DblspaceInfo
    is updated so that it reflects the changes made by the user.


Arguments:

    CompressedDrive - Pointer to the first element of a compressed drive list.

Return Value:

    None.

--*/

{
    ASSERT( CompressedDrive->Filesystem == FilesystemDoubleSpace );

    if( CompressedDrive->NextCompressed != NULL ) {
        SpDisposeCompressedDrives( CompressedDrive->NextCompressed );
    }

    if( CompressedDrive->SeqNumber != 0 ) {
        RemoveCompressedDrive( CompressedDrive->MountDrive );
    } else {
        RemoveCompressedDrive( CompressedDrive->HostDrive );
    }
    SpMemFree( CompressedDrive );
}


BOOLEAN
SpUpdateDoubleSpaceIni()

/*++

Routine Description:

    Update dblspace.ini to reflect all changes made by the user, with respect
    to compressed drives deleted or created.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if dblspace.ini was successfully updated.
              Returns FALSE otherwise.

--*/

{
    PDISK_REGION            CColonRegion;
    WCHAR                   NtPath[ 512 ];
    UNICODE_STRING          FileName;
    NTSTATUS                Status;
    HANDLE                  Handle;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    IO_STATUS_BLOCK         IoStatusBlock;
    CHAR                    Buffer[ 512 ];
    PACTIVATE_DRIVE         Pointer;


// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Entering SpUpdateDblspaceIni\n"));

    //
    // If no compressed drive was created or deleted, then do not
    // touch dblspace.ini
    //

    if( !DblspaceModified ) {
        return( TRUE );
    }
    //
    // See if there is a valid C: already.  If not, then silently fail.
    //
#ifndef _X86_

    return( FALSE );

#else

    CColonRegion = SpPtValidSystemPartition();
    if(!CColonRegion) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no C:, no dblspace.ini!\n"));
        return(FALSE);
    }

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Called SpPtValidSystemPartition\n"));

#endif

    //
    // Check the filesystem.  If not FAT, then silently fail.
    //
    if(CColonRegion->Filesystem != FilesystemFat) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: C: is not FAT, no dblspace.ini!\n"));
        return(FALSE);
    }

    SpNtNameFromRegion(
        CColonRegion,
        NtPath,
        sizeof(NtPath),
        PartitionOrdinalCurrent
        );

    wcscat( NtPath, DBLSPACE_INI_FILE );

    Status = SpDeleteFile( NtPath, NULL, NULL );
    if( !NT_SUCCESS( Status ) &&
        ( Status != STATUS_OBJECT_NAME_NOT_FOUND ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Unable to delete dblspace.ini, Status = %x\n",Status ) );
        return( FALSE );
    }

    //
    //  If the user deleted all compressed drives, then don't create a new
    //  dblspace.ini
    //
    // if( DblspaceInfo.CompressedDriveList == NULL ) {
    //     return( TRUE );
    // }
    //
    //  Create and write a new dblspace.ini
    //

    RtlInitUnicodeString( &FileName, NtPath );

    InitializeObjectAttributes( &ObjectAttributes,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = ZwCreateFile( &Handle,
                           FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                           0,
                           FILE_OVERWRITE_IF,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create dblspace.ini, Status = %x\n", Status ) );
        return( FALSE );
    }

    sprintf( Buffer,
             "%ls=%d\r\n",
             KWD_MAXREM,
             DblspaceInfo.MaxRemovableDrives
            );


    Status = ZwWriteFile( Handle,
                          NULL,
                          NULL,
                          NULL,
                          &IoStatusBlock,
                          Buffer,
                          strlen( Buffer ),
                          NULL,
                          NULL );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write MaxRemovableDrives to dblspace.ini, Status = %x\n", Status ));
        ZwClose( Handle );
        return( FALSE );
    }

    if( DblspaceInfo.FirstDrive != ( WCHAR )'\0' ) {
        sprintf( Buffer,
                 "%ls=%c\r\n",
                 KWD_FIRST,
                 DblspaceInfo.FirstDrive
                );


        Status = ZwWriteFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              Buffer,
                              strlen( Buffer ),
                              NULL,
                              NULL );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write FirstDrive to dblspace.ini, Status = %x\n", Status ));
            ZwClose( Handle );
            return( FALSE );
        }
    }

    if( DblspaceInfo.LastDrive != ( WCHAR )'\0' ) {
        sprintf( Buffer,
                 "%ls=%c\r\n",
                 KWD_LAST,
                 DblspaceInfo.LastDrive
                );


        Status = ZwWriteFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              Buffer,
                              strlen( Buffer ),
                              NULL,
                              NULL );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write LastDrive to dblspace.ini, Status = %x\n", Status ));
            ZwClose( Handle );
            return( FALSE );
        }
    }

    sprintf( Buffer,
             "%ls=%d\r\n",
             KWD_MAXFILE,
             DblspaceInfo.MaxFileFragments
            );


    Status = ZwWriteFile( Handle,
                          NULL,
                          NULL,
                          NULL,
                          &IoStatusBlock,
                          Buffer,
                          strlen( Buffer ),
                          NULL,
                          NULL );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write LastDrive to dblspace.ini, Status = %x\n", Status ));
        ZwClose( Handle );
        return( FALSE );
    }

    if( wcslen( DblspaceInfo.DoubleGuard ) != 0 ) {
        sprintf( Buffer,
                 "%ls=%ls\r\n",
                 KWD_AUTOMOUNT,
                 DblspaceInfo.AutoMount
                );


        Status = ZwWriteFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              Buffer,
                              strlen( Buffer ),
                              NULL,
                              NULL );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write Automount to dblspace.ini, Status = %x\n", Status ));
            ZwClose( Handle );
            return( FALSE );
        }
    }


    if( wcslen( DblspaceInfo.RomServer ) != 0 ) {
        sprintf( Buffer,
                 "%ls=%ls\r\n",
                 KWD_ROMSERVER,
                 DblspaceInfo.RomServer
                );


        Status = ZwWriteFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              Buffer,
                              strlen( Buffer ),
                              NULL,
                              NULL );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write Romserver to dblspace.ini, Status = %x\n", Status ));
            ZwClose( Handle );
            return( FALSE );
        }
    }

    if( wcslen( DblspaceInfo.Switches ) != 0 ) {
        sprintf( Buffer,
                 "%ls=%ls\r\n",
                 KWD_SWITCHES,
                 DblspaceInfo.Switches
                );


        Status = ZwWriteFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              Buffer,
                              strlen( Buffer ),
                              NULL,
                              NULL );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write Switches to dblspace.ini, Status = %x\n", Status ));
            ZwClose( Handle );
            return( FALSE );
        }
    }

    if( wcslen( DblspaceInfo.DoubleGuard ) != 0 ) {
        sprintf( Buffer,
                 "%ls=%ls\r\n",
                 KWD_DOUBLEGUARD,
                 DblspaceInfo.DoubleGuard
                );


        Status = ZwWriteFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              Buffer,
                              strlen( Buffer ),
                              NULL,
                              NULL );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write Doubleguard to dblspace.ini, Status = %x\n", Status ));
            ZwClose( Handle );
            return( FALSE );
        }
    }

    for( Pointer = DblspaceInfo.CompressedDriveList;
         Pointer;
         Pointer = Pointer->Next ) {

        sprintf( Buffer,
                 "%ls=%c,%c%d\r\n",
                  KWD_ACT,
                  Pointer->MountDrive,
                  Pointer->HostDrive,
                  Pointer->SeqNumber
                );

        Status = ZwWriteFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              Buffer,
                              strlen( Buffer ),
                              NULL,
                              NULL );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write to dblspace.ini, Status = %x\n", Status ));
            ZwClose( Handle );
            return( FALSE );
        }
    }

    ZwClose( Handle );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Exiting SpUpdateDblspaceIni\n"));
    return( TRUE );
}



ULONG
SpGetNumberOfCompressedDrives(
    IN  PDISK_REGION    Partition
)

/*++

Routine Description:

    Determine the number of compressed volumes on a particular partition.

Arguments:

    Partition - Pointer to the structure that describes a partition.

Return Value:

    ULONG - Returns the number of compressed drives found on the partition.

--*/

{
    ULONG           Count;
    PDISK_REGION    Pointer;

    Count = 0;

    if( ( Partition != NULL ) &&
        ( Partition->Filesystem == FilesystemFat )
      ) {
        for( Pointer = Partition->NextCompressed;
             Pointer;
             Pointer = Pointer->NextCompressed ) {
                Count++;
        }
    }
    return( Count );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spcopy.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    spcopy.c

Abstract:

    File copy/decompression routines for text setup.

Author:

    Ted Miller (tedm) 2-Aug-1993

Revision History:

    02-Oct-1996  jimschm  Added SpMoveWin9xFiles
    12-Dec-1996  jimschm  SpMoveWin9xFiles now moves paths
                          based on WINNT.SIF instructions
    24-Feb-1997  jimschm  Added SpDeleteWin9xFiles

--*/


#include "spprecmp.h"
#pragma hdrstop
#include "spcmdcon.h"
#include "spasmcabs.h"

//
// This structure is used during an OEM preinstall.
// It is used to form the list of files that were installed in the system, that
// have a short target name, instead of the corresponding long target name.
//
typedef struct _FILE_TO_RENAME {

    struct _FILE_TO_RENAME *Next;

    //
    // Name of the file to be copied, as it exists on the source media
    // (short file name part only -- no paths).
    //
    PWSTR SourceFilename;

    //
    // Directory to which this file is to be copied.
    //
    PWSTR TargetDirectory;

    //
    // Name of file as it should exist on the target (long name).
    //
    PWSTR TargetFilename;

} FILE_TO_RENAME, *PFILE_TO_RENAME;

//
// Structures used to hold lists of files and directories for SpCopyDirRecursive.
//

typedef struct _COPYDIR_FILE_NODE {
    LIST_ENTRY SiblingListEntry;
    WCHAR Name[1];
} COPYDIR_FILE_NODE, *PCOPYDIR_FILE_NODE;

typedef struct _COPYDIR_DIRECTORY_NODE {
    LIST_ENTRY SiblingListEntry;
    LIST_ENTRY SubdirectoryList;
    LIST_ENTRY FileList;
    struct _COPYDIR_DIRECTORY_NODE *Parent;
    WCHAR Name[1];
} COPYDIR_DIRECTORY_NODE, *PCOPYDIR_DIRECTORY_NODE;

//
//  List used on an OEM preinstall.
//  It contains the name of the files that need to be added to $$RENAME.TXT
//
PFILE_TO_RENAME RenameList = NULL;


//
// Remember whether or not we write out an ntbootdd.sys
//
BOOLEAN ForceBIOSBoot = FALSE;
HARDWAREIDLIST *HardwareIDList = NULL;

//
// global variables for delayed driver CAB opening during
// repair
//
extern PWSTR    gszDrvInfDeviceName;
extern PWSTR    gszDrvInfDirName;
extern HANDLE   ghSif;

#define FILE_ATTRIBUTES_RHS       (FILE_ATTRIBUTE_READONLY | \
                                   FILE_ATTRIBUTE_HIDDEN   | \
                                   FILE_ATTRIBUTE_SYSTEM   | \
                                   FILE_ATTRIBUTE_ARCHIVE)
                                   
#define FILE_ATTRIBUTES_NONE       0

PVOID FileCopyGauge;
PVOID FileDeleteGauge;

PVOID   _SetupLogFile = NULL;
PVOID   _LoggedOemFiles = NULL;

extern PCMDCON_BLOCK  gpCmdConsBlock;

//
//  List of oem inf files installed as part of the installation of third party drivers
//
POEM_INF_FILE   OemInfFileList = NULL;
//
//  Name of the directory where OEM files need to be copied, if a catalog file (.cat) is part of
//  the third party driver package that the user provide using the F6 or F5 key.
//
PWSTR OemDirName = L"OemDir";

#if defined(REMOTE_BOOT)
HANDLE SisRootHandle = NULL;
#endif // defined(REMOTE_BOOT)


VOID
SpLogOneFile(
    IN PFILE_TO_COPY    FileToCopy,
    IN PWSTR            Sysroot,
    IN PWSTR            DirectoryOnSourceDevice,
    IN PWSTR            DiskDescription,
    IN PWSTR            DiskTag,
    IN ULONG            CheckSum
    );

BOOLEAN
SpRemoveEntryFromCopyList(
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           TargetDirectory,
    IN PWSTR           TargetFilename,
    IN PWSTR           TargetDevicePath,
    IN BOOLEAN         AbsoluteTargetDirectory
    );


PVOID
SppRetrieveLoggedOemFiles(
    PVOID   OldLogFile
    );

VOID
SppMergeLoggedOemFiles(
    IN PVOID DestLogHandle,
    IN PVOID OemLogHandle,
    IN PWSTR SystemPartition,
    IN PWSTR SystemPartitionDirectory,
    IN PWSTR NtPartition
    );

BOOLEAN
SppIsFileLoggedAsOemFile(
    IN PWSTR FilePath
    );

BOOLEAN
SpDelEnumFile(
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    );

VOID
SppMergeRenameFiles(
    IN PWSTR    SourceDevicePath,
    IN PWSTR    NtPartition,
    IN PWSTR    Sysroot
    );

VOID
SppCopyOemDirectories(
    IN PWSTR    SourceDevicePath,
    IN PWSTR    NtPartition,
    IN PWSTR    Sysroot
    );

NTSTATUS
SpOpenFileInDriverCab(
    IN PCWSTR SourceFileName,
    IN PVOID SifHandle,
    OUT HANDLE *SourceHandle
    );

BOOLEAN
pSpTimeFromDosTime(
    IN USHORT Date,
    IN USHORT Time,
    OUT PLARGE_INTEGER UtcTime
    );

VOID
SpInitializeDriverInf(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    );


BOOLEAN
SpCreateDirectory(
    IN PCWSTR DevicePath,       OPTIONAL
    IN PCWSTR RootDirectory,    OPTIONAL
    IN PCWSTR Directory,
    IN ULONG DirAttrs           OPTIONAL,
    IN ULONG CreateFlags        OPTIONAL
    )
{
    UNICODE_STRING DevicePathString;
    UNICODE_STRING RootDirectoryString;
    UNICODE_STRING DirectoryString;
    BOOLEAN Result;

    RtlInitUnicodeString(&DevicePathString, DevicePath);
    RtlInitUnicodeString(&RootDirectoryString, RootDirectory);
    RtlInitUnicodeString(&DirectoryString, Directory);

    Result = SpCreateDirectory_Ustr(&DevicePathString, &RootDirectoryString, &DirectoryString, DirAttrs, CreateFlags);

    return Result;
}

BOOLEAN
SpCreateDirectory_Ustr(
    IN PCUNICODE_STRING DevicePath,       OPTIONAL
    IN PCUNICODE_STRING RootDirectory,    OPTIONAL
    IN PCUNICODE_STRING Directory,
    IN ULONG DirAttrs           OPTIONAL,
    IN ULONG CreateFlags        OPTIONAL
    )

/*++

Routine Description:

    Create a directory.  All containing directories are created to ensure
    that the directory can be created.  For example, if the directory to be
    created is \a\b\c, then this routine will create \a, \a\b, and \a\b\c
    in that order.

Arguments:

    DevicePath - supplies pathname to the device on which the directory
        is to be created.

    RootDirectory - if specified, supplies a fixed portion of the directory name,
        which may or may not have been already created. The directory being created will be
        concatenated to this value.

    Directory - supplies directory to be created on the device. You may use
        this to specify a full NT path (pass in NULL for DevicePath and
        RootDirectory).

Return Value:

    None.  Does not return if directry could not successfully be created.

--*/

{
    UNICODE_STRING p_ustr;
    PWSTR p,q,r,EntirePath, z, NewName;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };
    ULONG DevicePartLen;
    BOOL TriedOnce;
    BOOLEAN SkippedFile = FALSE;
    static ULONG u = 0;
    const static UNICODE_STRING EmptyString = RTL_CONSTANT_STRING(L"");
    const static UNICODE_STRING JustBackslashString = RTL_CONSTANT_STRING(L"\\");

    ASSERT (Directory);

    NewName = NULL;

    //
    // Do not bother attempting to create the root directory.
    //
    if (RtlEqualUnicodeString(Directory, &EmptyString, TRUE)
        || RtlEqualUnicodeString(Directory, &JustBackslashString, TRUE)) {
        return TRUE;
    }

    //
    // Fill up TemporaryBuffer with the full pathname of the directory being
    // created. If DevicePath is NULL, TemporaryBuffer will be filled with one
    // backslash. Because Directory is required, this ensures the path starts
    // with a backslash.
    //
    p = TemporaryBuffer;
    *p = 0;
    p_ustr = TemporaryBufferUnicodeString;
    ASSERT(p_ustr.Length == 0);
    SpConcatenatePaths_Ustr(&p_ustr,DevicePath);
    DevicePartLen = RTL_STRING_GET_LENGTH_CHARS(&p_ustr);

    if(RootDirectory) {
        SpConcatenatePaths_Ustr(&p_ustr,RootDirectory);
    }

    SpConcatenatePaths_Ustr(&p_ustr,Directory);

    //
    // Make a duplicate of the path being created.
    //
    RTL_STRING_NUL_TERMINATE(&p_ustr);
    EntirePath = SpDupStringW(p_ustr.Buffer);

    if (!EntirePath) {
        return FALSE; // ran out of memory
    }

    //
    // Make q point to the first character in the directory
    // part of the pathname (ie, 1 char past the end of the device name).
    //
    q = EntirePath + DevicePartLen;

    //
    // Note: It is possible for the device path to end in a '\', so we may need
    // to backup one character
    //
    if (*q != L'\\') {
        q--;
    }
    ASSERT(*q == L'\\');

    //
    // Make r point to the first character in the directory
    // part of the pathname.  This will be used to keep the status
    // line updated with the directory being created.
    //
    r = q;

    //
    // Make p point to the first character following the first
    // \ in the directory part of the full path.
    //
    p = q+1;

    do {

        //
        // find the next \ or the terminating 0.
        //
        q = wcschr(p,L'\\');

        //
        // If we found \, terminate the string at that point.
        //
        if(q) {
            *q = 0;
        }

        do {
            if( !HeadlessTerminalConnected ) {
                if ((CreateFlags & CREATE_DIRECTORY_FLAG_NO_STATUS_TEXT_UI) == 0) {
                    SpDisplayStatusText(SP_STAT_CREATING_DIRS,DEFAULT_STATUS_ATTRIBUTE,r);
                }
            } else {

                PWCHAR TempPtr = NULL;
                //
                // If we're headless, we need to be careful about displaying very long
                // file/directory names.  For that reason, just display a little spinner.
                //
                switch( u % 4) {
                case 0:
                    TempPtr = L"-";
                    break;
                case 1:
                    TempPtr = L"\\";
                    break;
                case 2:
                    TempPtr = L"|";
                    break;
                default:
                    TempPtr = L"/";
                    break;

                }

                SpDisplayStatusText( SP_STAT_CREATING_DIRS,DEFAULT_STATUS_ATTRIBUTE, TempPtr );

                u++;

            }

            //
            // Create or open the directory whose name is in EntirePath.
            //
            INIT_OBJA(&Obja,&UnicodeString,EntirePath);
            Handle = NULL;
            TriedOnce = FALSE;

tryagain:
            Status = ZwCreateFile(
                        &Handle,
                        FILE_LIST_DIRECTORY | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL | DirAttrs,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_OPEN_IF,
                        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_ALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                        NULL,
                        0
                        );


            //
            // If it's an obdirectory, obsymlink, device, or directory, then they just didn't pass
            // a long enough DevicePath. Let this by.
            //
            if (Status == STATUS_NOT_A_DIRECTORY) {
                //
                //Could be that a file exists by that name. Rename it out of the way
                //

                if( SpFileExists( EntirePath, FALSE ) && !TriedOnce){

                    z = TemporaryBuffer;
                    wcscpy( z, EntirePath );
                    wcscat( z, L".SetupRenamedFile" );

                    NewName = SpDupStringW( z );
                    if( !NewName )
                        return FALSE; //out of memory - bugcheck (never gets here) - but this keeps PREFIX happy


                    Status = SpRenameFile( EntirePath, NewName, FALSE );

                    if( NT_SUCCESS(Status)){

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Renamed file %ws to %ws\n", r, NewName));

                        TriedOnce = TRUE;
                        goto tryagain;


                    }else{

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to rename file %ws (%lx)\n", r, Status));

                    }

                }
            }

            if(!NT_SUCCESS(Status)) {

                BOOLEAN b = TRUE;

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create dir %ws (%lx)\n", r, Status));

                if (CreateFlags & CREATE_DIRECTORY_FLAG_SKIPPABLE) {
                    SkippedFile = TRUE;
                    goto SkippedFileQuit;
                }

                //
                // Tell user we couldn't do it.  Options are to retry or exit.
                //
                while(b) {

                    SpStartScreen(
                        SP_SCRN_DIR_CREATE_ERR,
                        3,
                        HEADER_HEIGHT+1,
                        FALSE,
                        FALSE,
                        DEFAULT_ATTRIBUTE,
                        r
                        );

                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_RETRY,
                        SP_STAT_F3_EQUALS_EXIT,
                        0
                        );

                    switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {
                    case ASCI_CR:
                        b = FALSE;
                        break;
                    case KEY_F3:
                        SpConfirmExit();
                        break;
                    }
                }
            }

        } while(!NT_SUCCESS(Status));

        if (Handle != NULL)
            ZwClose(Handle);

        //
        // Unterminate the current string if necessary.
        //
        if(q) {
            *q = L'\\';
            p = q+1;
        }

    } while(*p && q);       // *p catches string ending in '\'

SkippedFileQuit:
    SpMemFree(EntirePath);
    if( NewName )
        SpMemFree(NewName);

    return !SkippedFile;
}

VOID
SpCreateDirStructWorker(
    IN PVOID SifHandle,
    IN PWSTR SifSection,
    IN PWSTR DevicePath,
    IN PWSTR RootDirectory,
    IN BOOLEAN Fatal
    )

/*++

Routine Description:

    Create a set of directories that are listed in a setup information file
    section.  The expected format is as follows:

    [SectionName]
    shortname = directory
    shortname = directory
            .
            .
            .

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SifSection - supplies name of section in the setup information file
        containing directories to be created.

    DevicePath - supplies pathname to the device on which the directory
        structure is to be created.

    RootDirectory - supplies a root directory, relative to which the
        directory structure will be created.

Return Value:

    None.  Does not return if directory structure could not be created.

--*/

{
    ULONG Count;
    ULONG d;
    PWSTR Directory;


    //
    // Count the number of directories to be created.
    //
    Count = SpCountLinesInSection(SifHandle,SifSection);
    if(!Count) {
        if(Fatal) {
            SpFatalSifError(SifHandle,SifSection,NULL,0,0);
        } else {
            return;
        }
    }

    for(d=0; d<Count; d++) {

        Directory = SpGetSectionLineIndex(SifHandle,SifSection,d,0);
        if(!Directory) {
            SpFatalSifError(SifHandle,SifSection,NULL,d,0);
        }

        SpCreateDirectory(DevicePath,RootDirectory,Directory,0,0);
    }
}


VOID
SpCreateDirectoryStructureFromSif(
    IN PVOID SifHandle,
    IN PWSTR SifSection,
    IN PWSTR DevicePath,
    IN PWSTR RootDirectory
    )

/*++

Routine Description:

    Create a set of directories that are listed in a setup information file
    section. The expected format is as follows:

    [SectionName]
    shortname = directory
    shortname = directory
            .
            .
            .

    [SectionName.<platform>]
    shortname = directory
    shortname = directory
            .
            .
            .

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SifSection - supplies name of section in the setup information file
        containing directories to be created.

    DevicePath - supplies pathname to the device on which the directory
        structure is to be created.

    RootDirectory - supplies a root directory, relative to which the
        directory structure will be created.

Return Value:

    None.  Does not return if directory structure could not be created.

--*/

{
    PWSTR p;

    //
    // Create the root directory.
    //
    SpCreateDirectory(DevicePath,NULL,RootDirectory,HideWinDir?FILE_ATTRIBUTE_HIDDEN:0,0);

    //
    // Create platform-indepdenent directories
    //
    SpCreateDirStructWorker(SifHandle,SifSection,DevicePath,RootDirectory,TRUE);

    //
    // Create platform-dependent directories
    //
    p = SpMakePlatformSpecificSectionName(SifSection);

    if (p) {
        SpCreateDirStructWorker(SifHandle,p,DevicePath,RootDirectory,FALSE);
        SpMemFree(p);
    }
}


VOID
SpGetFileVersion(
    IN  PVOID      ImageBase,
    OUT PULONGLONG Version
    )

/*++

Routine Description:

    Get the version stamp out of the VS_FIXEDFILEINFO resource in a PE
    image.

Arguments:

    ImageBase - supplies the address in memory where the file is mapped in.

    Version - receives 64bit version number, or 0 if the file is not
        a PE image or has no version data.

Return Value:

    None.
--*/

{
    PIMAGE_RESOURCE_DATA_ENTRY DataEntry;
    NTSTATUS Status;
    ULONG_PTR IdPath[3];
    ULONG ResourceSize;
    struct {
        USHORT TotalSize;
        USHORT DataSize;
        USHORT Type;
        WCHAR Name[16];                     // L"VS_VERSION_INFO" + unicode nul
        VS_FIXEDFILEINFO FixedFileInfo;
    } *Resource;

    *Version = 0;

    //
    // Do this to prevent the Ldr routines from faulting.
    //
    ImageBase = (PVOID)((ULONG_PTR)ImageBase | 1);

    IdPath[0] = (ULONG_PTR)RT_VERSION;
    IdPath[1] = (ULONG_PTR)MAKEINTRESOURCE(VS_VERSION_INFO);
    IdPath[2] = 0;

    try {
        Status = LdrFindResource_U(ImageBase,IdPath,3,&DataEntry);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_UNSUCCESSFUL;
    }
    if(!NT_SUCCESS(Status)) {
        return;
    }

    try {
        Status = LdrAccessResource(ImageBase,DataEntry,&Resource,&ResourceSize);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_UNSUCCESSFUL;
    }
    if(!NT_SUCCESS(Status)) {
        return;
    }

    try {
        if((ResourceSize >= sizeof(*Resource)) && !_wcsicmp(Resource->Name,L"VS_VERSION_INFO")) {

            *Version = ((ULONGLONG)Resource->FixedFileInfo.dwFileVersionMS << 32)
                     | (ULONGLONG)Resource->FixedFileInfo.dwFileVersionLS;

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Warning: invalid version resource\n"));
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Exception encountered processing bogus version resource\n"));
    }
}

#if defined(REMOTE_BOOT)
NTSTATUS
SpCopyFileForRemoteBoot(
    IN PWSTR SourceFilename,
    IN PWSTR TargetFilename,
    IN ULONG TargetAttributes,
    IN ULONG Flags,
    OUT PULONG Checksum
    )

/*++

Routine Description:

    Check to see if the target file already exists in the master tree on
    the remote boot server, and if it does, create a single-instance store
    link to the existing file instead of doing the copy.

Arguments:

    SourceFilename - supplies fully qualified name of file
        in the NT namespace.

    TargetFilename - supplies fully qualified name of file
        in the NT namespace.

    TargetAttributes - if supplied (ie, non-0) supplies the attributes
        to be placed on the target on successful copy (ie, readonly, etc).

    Flags - bit mask specifying any special treatment necessary
        for the file.

    CheckSum - checksum of the file

Return Value:

    NT Status value indicating outcome of NtWriteFile of the data.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    PSI_COPYFILE copyFile;
    ULONG copyFileSize;
    ULONG sourceLength;
    ULONG targetLength;
    HANDLE targetHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;

    //
    // If the target file is not remote, then it must be on the local system
    // partition, and there's no use in trying an SIS copy.
    //
    // If there is no SIS root handle, there's no handle on which to issue the
    // SIS FSCTL.
    //

    if ( (_wcsnicmp(TargetFilename, L"\\Device\\LanmanRedirector", 24) != 0 ) ||
         (SisRootHandle == NULL) ) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Build the FSCTL command buffer.
    //

    sourceLength = (wcslen(SourceFilename) + 1) * sizeof(WCHAR);
    targetLength = (wcslen(TargetFilename) + 1) * sizeof(WCHAR);

    copyFileSize = FIELD_OFFSET(SI_COPYFILE, FileNameBuffer) + sourceLength + targetLength;

    copyFile = SpMemAlloc( copyFileSize );
    copyFile->SourceFileNameLength = sourceLength;
    copyFile->DestinationFileNameLength = targetLength;
    copyFile->Flags = COPYFILE_SIS_REPLACE;

    RtlCopyMemory(
        copyFile->FileNameBuffer,
        SourceFilename,
        sourceLength
        );

    RtlCopyMemory(
        copyFile->FileNameBuffer + (sourceLength / sizeof(WCHAR)),
        TargetFilename,
        targetLength
        );

    //
    // Invoke the SIS CopyFile FsCtrl.
    //

    status = ZwFsControlFile(
                SisRootHandle,
                NULL,
                NULL,
                NULL,
                &ioStatusBlock,
                FSCTL_SIS_COPYFILE,
                copyFile,               // Input buffer
                copyFileSize,           // Input buffer length
                NULL,                   // Output buffer
                0 );                    // Output buffer length

    if ( NT_SUCCESS(status) ) {

        //KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SpCopyFileForRemoteBoot: SIS copy %ws->%ws succeeded\n", SourceFilename, TargetFilename ));

        //
        // Open the target file so that CSC knows about it and pins it.
        //

        INIT_OBJA(&objectAttributes, &unicodeString, TargetFilename);

        status = ZwOpenFile(
                    &targetHandle,
                    FILE_GENERIC_READ,
                    &objectAttributes,
                    &ioStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    0
                    );

        if ( NT_SUCCESS(status) ) {
            ZwClose(targetHandle);
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SpCopyFileForRemoteBoot: SIS copy %ws->%ws succeeded, but open failed: %x\n", SourceFilename, TargetFilename, status ));
        }

    } else {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SpCopyFileForRemoteBoot: SIS copy %ws->%ws failed: %x\n", SourceFilename, TargetFilename, status ));

        //
        // If it looks like SIS isn't active on the remote file system, close
        // the SIS root handle so that we can avoid repeatedly getting this
        // error.
        //
        // Note: NTFS returns STATUS_INVALID_PARAMETER. FAT returns
        // STATUS_INVALID_DEVICE_REQUEST.
        //

        if ( (status == STATUS_INVALID_PARAMETER) ||
             (status == STATUS_INVALID_DEVICE_REQUEST) ) {
            ZwClose( SisRootHandle );
            SisRootHandle = NULL;
        }
    }

    *Checksum = 0;

    SpMemFree( copyFile );

    return status;
}
#endif // defined(REMOTE_BOOT)

NTSTATUS
SpCopyFileUsingNames(
    IN PWSTR SourceFilename,
    IN PWSTR TargetFilename,
    IN ULONG TargetAttributes,
    IN ULONG Flags
    )

/*++

Routine Description:

    Attempt to copy or decompress a file based on filenames.

Arguments:

    SourceFilename - supplies fully qualified name of file
        in the NT namespace.

    TargetFilename - supplies fully qualified name of file
        in the NT namespace.

    TargetAttributes - if supplied (ie, non-0) supplies the attributes
        to be placed on the target on successful copy (ie, readonly, etc).

    Flags - bit mask specifying any special treatment necessary
        for the file.

Return Value:

    NT Status value indicating outcome of NtWriteFile of the data.

--*/

{
    NTSTATUS Status;
    HANDLE SourceHandle;
    HANDLE TargetHandle;
    BOOLEAN b;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicFileInfo;
    FILE_BASIC_INFORMATION BasicFileInfo2;
    BOOLEAN GotBasicInfo;
    ULONG FileSize;
    PVOID ImageBase;
    HANDLE SectionHandle;
    BOOLEAN IsCompressed;
    BOOLEAN InDriverCab;
    PWSTR TempFilename,TempSourcename;
    PFILE_RENAME_INFORMATION RenameFileInfo;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    LARGE_INTEGER FileOffset;
    ULONGLONG SourceVersion;
    ULONGLONG TargetVersion;
    USHORT CompressionState;
    BOOLEAN Moved;
    BOOLEAN TargetExists;
    WCHAR   SmashedSourceFilename[ACTUAL_MAX_PATH];
    ULONG pathSize;

#if 0
#ifdef _X86_

    BOOL bUniprocFile = FALSE;

    //
    // If this file is on the list of files whose locks need to be smashed,
    // copy a file who's been smashed.  We do this by prepending our up
    // directory name infront of the filename in SourceFilename.
    //
    if((Flags & COPY_SMASHLOCKS) && !SpInstallingMp() && !RemoteSysPrepSetup) {
    WCHAR   *char_ptr;
        //
        // Find the last '\\' in the name.
        //
        char_ptr = SourceFilename + (wcslen(SourceFilename)) - 1;

        while( (char_ptr > SourceFilename) &&
               (*char_ptr != L'\\') ) {
            char_ptr--;
        }

        //
        // Now insert our special directory name inside
        // the specified source file name.
        //
        if( *char_ptr == L'\\' ) {
            *char_ptr = 0;
            wcscpy( SmashedSourceFilename, SourceFilename );
            *char_ptr = L'\\';
            char_ptr++;
            wcscat( SmashedSourceFilename, L"\\UniProc\\" );
            wcscat( SmashedSourceFilename, char_ptr );

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Copying:\n\t%ws\n\tinstead of:\n\t%ws\n", SmashedSourceFilename, SourceFilename));

            SourceFilename = SmashedSourceFilename;
            bUniprocFile = TRUE;
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Unable to generate smashed source path for %ws\n", SourceFilename));
        }
    }
#endif // defined _x86_
#endif // 0

    //
    // Open the source file if it's not open already.
    // Note that the name may not be the actual name on disk.
    // We also try to open the name with the _ appended.
    //

    InDriverCab = FALSE;

    if (RemoteSysPrepSetup && ((Flags & COPY_DECOMPRESS_SYSPREP) == 0)) {

        INIT_OBJA(&Obja,&UnicodeString,SourceFilename);

        Status = ZwCreateFile(  &SourceHandle,
                                FILE_GENERIC_READ,
                                &Obja,
                                &IoStatusBlock,
                                NULL,
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ,
                                FILE_OPEN,
                                0,
                                NULL,
                                0
                                );
    } else {

        if (!PrivateInfHandle && g_UpdatesSifHandle) {

            TempSourcename = wcsrchr(SourceFilename,L'\\');
            if (TempSourcename) {
                TempSourcename++;
            } else {
                TempSourcename = SourceFilename;
            }

#if 0
#ifdef _X86_
            //
            // If this file is on the list of files whose locks need to be smashed,
            // look in uniproc.cab first
            //
            if(bUniprocFile && g_UniprocSifHandle) {
                Status = SpOpenFileInDriverCab (
                            TempSourcename,
                            g_UniprocSifHandle,
                            &SourceHandle
                            );

                if (NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: using %ws from uniproc cab\n", TempSourcename));
                    InDriverCab = TRUE;
                    Flags &= ~COPY_DELETESOURCE;
                }
            }
#endif // defined _X86_
#endif // 0

            if (!InDriverCab) {
                //
                // look in updates cab first
                //
                Status = SpOpenFileInDriverCab (
                            TempSourcename,
                            g_UpdatesSifHandle,
                            &SourceHandle
                            );

                if (NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: using %ws from updates cab\n", TempSourcename));
                    InDriverCab = TRUE;
                    Flags &= ~COPY_DELETESOURCE;
                }
            }
        }

        if (!InDriverCab) {
            Status = SpOpenNameMayBeCompressed(
                        SourceFilename,
                        FILE_GENERIC_READ,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ,
                        FILE_OPEN,
                        0,
                        &SourceHandle,
                        &b
                        );

            if (!NT_SUCCESS(Status)) {
                //
                // if it's not the actual name and it's not compressed, it may be in the driver cab-file
                //
                TempSourcename = wcsrchr(SourceFilename,L'\\');
                if (TempSourcename) {
                    TempSourcename++;
                } else {
                    TempSourcename = SourceFilename;
                }

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: temp source name:  %ws\n", TempSourcename));



                Status = SpOpenFileInDriverCab(
                        TempSourcename,
                        NULL,
                        &SourceHandle
                        );

                InDriverCab = TRUE;
            }
        }
    }
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: Unable to open source file %ws (%x)\n",SourceFilename,Status));
        return(Status);
    }

    //
    // Gather basic file info about the file. We only use the timestamp info.
    // If this fails this isn't fatal (we assume that if this fails, then
    // the copy will also fail; it not, the worst case is that the timestamps
    // might be wrong).
    //
    Status = ZwQueryInformationFile(
                SourceHandle,
                &IoStatusBlock,
                &BasicFileInfo,
                sizeof(BasicFileInfo),
                FileBasicInformation
                );

    if(NT_SUCCESS(Status)) {
        GotBasicInfo = TRUE;
    } else {
        GotBasicInfo = FALSE;
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: Warning: unable to get basic file info for %ws (%x)\n",SourceFilename,Status));
    }


    //
    // Get the source file size, map in the file, and determine whether it's compressed.
    //
    Status = SpGetFileSize(SourceHandle,&FileSize);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to get size of %ws (%x)\n",SourceFilename,Status));
        if (!InDriverCab) {
            ZwClose(SourceHandle);
        }
        return(Status);
    }

    if( FileSize == 0 ) {

        //
        // We'll soon indirectly call ZwCreateSection with a zero length.
        // This will fail, so let's deal with zero-length files up here so
        // they actually get copied.
        //
        // We know a couple of things that make our job much easier.
        // 1. We don't need to actually copy any data, just create an empty
        //    file.
        // 2. The source file isn't compressed, so don't worry about
        //    decompressing/renaming (by defintion, the smallest compressed
        //    file is non-zero).
        //

        INIT_OBJA(&Obja,&UnicodeString,TargetFilename);
        Status = ZwCreateFile( &TargetHandle,
                               FILE_GENERIC_WRITE,
                               &Obja,
                               &IoStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               0,                        // no sharing
                               FILE_OVERWRITE_IF,
                               FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                               NULL,
                               0
                               );

        if( NT_SUCCESS(Status) ) {

            //
            //  if the source is off of a sysprep image, then we need to copy
            //  EAs and alternate data streams too.  we do this before setting
            //  attributes so that read only bit isn't set.
            //  Only do this if we're not grabbing additional drivers from the
            //  flat image.
            //

            if (RemoteSysPrepSetup && ((Flags & COPY_DECOMPRESS_SYSPREP) == 0)) {

                Status = SpCopyEAsAndStreams( SourceFilename,
                                              SourceHandle,
                                              TargetFilename,
                                              TargetHandle,
                                              FALSE );
            }

            if ( NT_SUCCESS(Status) ) {
                //
                // Try and set attributes on target.
                //
                BasicFileInfo.FileAttributes = TargetAttributes;
                ZwSetInformationFile(
                    TargetHandle,
                    &IoStatusBlock,
                    &BasicFileInfo,
                    sizeof(BasicFileInfo),
                    FileBasicInformation
                    );

            }

            //
            // Close target file
            //
            ZwClose( TargetHandle );

            //
            // Do we need to delete Source?
            //
            if( (Flags & COPY_DELETESOURCE) && !RemoteSysPrepSetup && !InDriverCab) {
                ZwClose(SourceHandle);
                SourceHandle = NULL;
                SpDeleteFile(SourceFilename,NULL,NULL);
            }
        }
        else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: Failed to create zero-length file %ws\n",TargetFilename));
        }

        //
        // Clean up this guy since we won't be needing him anymore.
        //
        if (SourceHandle != NULL) {
            if( !InDriverCab ) {
                ZwClose(SourceHandle);
            }
        }

        if (RemoteSysPrepSetup &&
            NT_SUCCESS(Status) &&
            ((Flags & COPY_DECOMPRESS_SYSPREP) == 0)) {

            Status = SpSysPrepSetExtendedInfo( SourceFilename,
                                               TargetFilename,
                                               FALSE,
                                               FALSE );
        }
        return(Status);
    }

    Status = SpMapEntireFile(SourceHandle,&SectionHandle,&ImageBase,FALSE);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to map file %ws (%x)\n",SourceFilename,Status));
        if (!InDriverCab) {
            ZwClose(SourceHandle);
        }
        return(Status);
    }

    //
    // If we were told not to decompress, then treat any file like it is
    // uncompressed.
    //

    if (Flags & COPY_NODECOMP) {
        IsCompressed = FALSE;
    } else {
        if (InDriverCab) {
            IsCompressed = TRUE;
        } else {
            IsCompressed = SpdIsCompressed(ImageBase,FileSize);
            if (IsCompressed){
                PWSTR ExtensionName;
                
                //
                // If cabinet file has one file only, IsCompressed is TRUE.
                // So we check extension whether this file is cabinet file or
                // compressed file.
                //
                ExtensionName = wcsrchr(SourceFilename, L'.');
                if (ExtensionName && !_wcsicmp(ExtensionName, L".cab")) {
                    IsCompressed = FALSE;
                }
                
            }
            
        }

    }

    //
    // Create a temporary filename to be used for the target.
    //

    pathSize = (wcslen(TargetFilename)+12) * sizeof(WCHAR);

    TempFilename = SpMemAlloc(pathSize);
    wcscpy(TempFilename,TargetFilename);
    wcscpy(wcsrchr(TempFilename,L'\\')+1,L"$$TEMP$$.~~~");

    //
    // Allocate some space for the rename buffer.
    //
    RenameFileInfo = SpMemAlloc(sizeof(FILE_RENAME_INFORMATION) + pathSize );

    //
    // Create the temporary file. We first try to do this via a move
    // if the source isn't compressed and we're going to delete the source file.
    //
    if (!IsCompressed && (Flags & COPY_DELETESOURCE) && !RemoteSysPrepSetup) {

        RenameFileInfo->ReplaceIfExists = TRUE;
        RenameFileInfo->RootDirectory = NULL;
        RenameFileInfo->FileNameLength = wcslen(TempFilename)*sizeof(WCHAR);
        wcscpy(RenameFileInfo->FileName,TempFilename);

        Status = ZwSetInformationFile(
                    SourceHandle,
                    &IoStatusBlock,
                    RenameFileInfo,
                    sizeof(FILE_RENAME_INFORMATION) + RenameFileInfo->FileNameLength,
                    FileRenameInformation
                    );


        Moved = TRUE;
    } else {
        //
        // Force us to fall into the copy case below.
        //
        Status = STATUS_UNSUCCESSFUL;
    }

    INIT_OBJA(&Obja,&UnicodeString,TempFilename);

    if(!NT_SUCCESS(Status)) {
        Moved = FALSE;

        //
        // OK, move failed, try decompress/copy instead.
        // Start by creating the temporary file.
        //
        Status = ZwCreateFile(
                    &TargetHandle,
                    FILE_GENERIC_WRITE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    0,                      // no sharing
                    FILE_OVERWRITE_IF,
                    FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                    NULL,
                    0
                    );

        if(NT_SUCCESS(Status)) {

            if(IsCompressed &&
                ( (!RemoteSysPrepSetup) ||
                  ((Flags & COPY_DECOMPRESS_SYSPREP) != 0))) {

                if (InDriverCab) {
                    USHORT RealFileTime,RealFileDate;
                    LARGE_INTEGER RealTime;
                    ASSERT (TempSourcename != NULL );

                    //
                    // remove the file from the driver cab...
                    //
                    Status = SpdDecompressFileFromDriverCab(
                                                 TempSourcename,
                                                 ImageBase,
                                                 FileSize,
                                                 TargetHandle,
                                                 &RealFileDate,
                                                 &RealFileTime );

                    //
                    // ...now update the basic file information filetime...
                    //
                    if (GotBasicInfo) {
                        SpTimeFromDosTime(RealFileDate,RealFileTime,&RealTime);
                        BasicFileInfo.CreationTime = RealTime;
                    }
                } else{
                    Status = SpdDecompressFile(ImageBase,FileSize,TargetHandle);
                }

            } else {

                ULONG remainingLength;
                ULONG writeLength;
                PUCHAR base;

                //
                // Guard the write with a try/except because if there is an i/o error,
                // memory management will raise an in-page exception.
                //
                FileOffset.QuadPart = 0;
                base = ImageBase;
                remainingLength = FileSize;

                try {
                    while (remainingLength != 0) {
                        writeLength = 60 * 1024;
                        if (writeLength > remainingLength) {
                            writeLength = remainingLength;
                        }
                        Status = ZwWriteFile(
                                    TargetHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    base,
                                    writeLength,
                                    &FileOffset,
                                    NULL
                                    );
                        base += writeLength;
                        FileOffset.LowPart += writeLength;
                        remainingLength -= writeLength;
                        if (!NT_SUCCESS(Status)) {
                            break;
                        }
                    }

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    Status = STATUS_IN_PAGE_ERROR;
                }
            }

            //
            //  if the source is off of a sysprep image, then we need to copy
            //  EAs and alternate data streams too.
            //

            if ( NT_SUCCESS(Status) &&
                 RemoteSysPrepSetup &&
                 ((Flags & COPY_DECOMPRESS_SYSPREP) == 0)) {

                Status = SpCopyEAsAndStreams( SourceFilename,
                                              SourceHandle,
                                              TargetFilename,
                                              TargetHandle,
                                              FALSE );
            }

            ZwClose(TargetHandle);
        }
    }

    SpUnmapFile(SectionHandle,ImageBase);
    if (!InDriverCab) {
        ZwClose(SourceHandle);
    }

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to create temporary file %ws (%x)\n",TempFilename,Status));
        SpMemFree(TempFilename);
        SpMemFree(RenameFileInfo);
        return(Status);
    }

    //
    // At this point we have a temporary target file that is now the source.
    // Open the file, map it in, and get its version.
    //
    Status = ZwCreateFile(
                &SourceHandle,
                FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,                      // don't bother with attributes
                0,                      // no sharing
                FILE_OPEN,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if((Status == STATUS_ACCESS_DENIED) && Moved) {
        //
        // The only way this could have happened is if the source file
        // is uncompressed and the delete-source flag is set, since in
        // that case we could have moved the source file to the temp file.
        // In any other case we would have created the temp file by copying,
        // and there's no problem reopening the file since we just created
        // and closed it ourselves, above.
        //
        // Reset attributes and try again. The file might have been read-only.
        // This can happen when doing a winnt32 directly from a CD since the
        // RO attribute of files from the CD are preserved.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpCopyFileUsingNames: for file %ws, can't reopen temp file (access deined), trying again\n",SourceFilename));

        Status = ZwCreateFile(
                    &SourceHandle,
                    FILE_WRITE_ATTRIBUTES,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    0,                      // don't bother with attributes
                    FILE_SHARE_WRITE,
                    FILE_OPEN,
                    FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                    );

        if(NT_SUCCESS(Status)) {

            RtlZeroMemory(&BasicFileInfo2,sizeof(BasicFileInfo2));
            BasicFileInfo2.FileAttributes = FILE_ATTRIBUTE_NORMAL;

            Status = ZwSetInformationFile(
                        SourceHandle,
                        &IoStatusBlock,
                        &BasicFileInfo2,
                        sizeof(BasicFileInfo2),
                        FileBasicInformation
                        );

            ZwClose(SourceHandle);

            if(NT_SUCCESS(Status)) {

                Status = ZwCreateFile(
                            &SourceHandle,
                            FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                            &Obja,
                            &IoStatusBlock,
                            NULL,
                            0,                      // don't bother with attributes
                            0,                      // no sharing
                            FILE_OPEN,
                            FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                            NULL,
                            0
                            );

            }
        }
    }

    //
    // Read-only failured win out over sharing violations -- ie, we'll get back
    // ACCESS_DEINED first for files that are both RO and in-use. So break out
    // this block so it gets executed even if we tried again above because the
    // file might be read-only.
    //
    if((Status == STATUS_SHARING_VIOLATION) && Moved) {
        //
        // The only way this can happen is if the source file is uncompressed
        // and the delete-source flag is set. In this case we renamed the file
        // to the temp filename and now we can't open it for write.
        // In any other case we would have created the temp file by copying,
        // and so there's no problem opening the file since we just closed it.
        //
        // Rename the temp file back to the source file and try again without
        // the delete source flag set. This forces a copy instead of a move.
        // The rename better work or else we're completely hosed -- because
        // there's a file we can't overwrite with the name we want to use for
        // the temp file for all our copy operations!
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpCopyFileUsingNames: temporary file %ws is in use -- trying recursive call\n",TempFilename));

        Status = SpRenameFile(TempFilename,SourceFilename,FALSE);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpCopyFileUsingNames: unable to restore temp file to %ws (%x)\n",SourceFilename,Status));
        }

        SpMemFree(TempFilename);
        SpMemFree(RenameFileInfo);

        if(NT_SUCCESS(Status)) {
            Status = SpCopyFileUsingNames(
                        SourceFilename,
                        TargetFilename,
                        TargetAttributes,
                        Flags & ~COPY_DELETESOURCE
                        );
        }

        return(Status);
    }


    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to reopen temporary file %ws (%x)\n",TempFilename,Status));
        if(Moved) {
            SpRenameFile(TempFilename,SourceFilename,FALSE);
        }
        SpMemFree(TempFilename);
        SpMemFree(RenameFileInfo);
        return(Status);
    }

    Status = SpGetFileSize(SourceHandle,&FileSize);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to get size of %ws (%x)\n",TempFilename,Status));
        ZwClose(SourceHandle);
        if(Moved) {
            SpRenameFile(TempFilename,SourceFilename,FALSE);
        }
        SpMemFree(TempFilename);
        SpMemFree(RenameFileInfo);
        return(Status);
    }

    Status = SpMapEntireFile(SourceHandle,&SectionHandle,&ImageBase,FALSE);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to map file %ws (%x)\n",TempFilename,Status));
        ZwClose(SourceHandle);
        if(Moved) {
            SpRenameFile(TempFilename,SourceFilename,FALSE);
        }
        SpMemFree(TempFilename);
        SpMemFree(RenameFileInfo);
        return(Status);
    }

    SpGetFileVersion(ImageBase,&SourceVersion);

    SpUnmapFile(SectionHandle,ImageBase);

    //
    // See if the target file is there by attempting to open it.
    // If the file is there, get its version.
    //
    INIT_OBJA(&Obja,&UnicodeString,TargetFilename);

    Status = ZwCreateFile(
                &TargetHandle,
                FILE_GENERIC_READ,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,                                  // don't bother with attributes
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,                          // open if exists, fail if not
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    TargetVersion = 0;
    if(NT_SUCCESS(Status)) {

        TargetExists = TRUE;

        //
        // If we're supposed to ignore versions, then keep the
        // target version at 0. This will guarantee that we'll overwrite
        // the target. We use the source filename here because it
        // allows more flexibility (such as with HALs, which all have
        // different source names but the same target name).
        //
        if(!(Flags & COPY_NOVERSIONCHECK)) {

            Status = SpGetFileSize(TargetHandle,&FileSize);
            if(NT_SUCCESS(Status)) {

                Status = SpMapEntireFile(TargetHandle,&SectionHandle,&ImageBase,FALSE);
                if(NT_SUCCESS(Status)) {

                    SpGetFileVersion(ImageBase,&TargetVersion);

                    SpUnmapFile(SectionHandle,ImageBase);

                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: warning: unable to map file %ws (%x)\n",TargetFilename,Status));
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: warning: unable to get size of file %ws (%x)\n",TargetFilename,Status));
            }
        }

        ZwClose(TargetHandle);
    } else {
        TargetExists = FALSE;
    }

    //
    // OK, now we have a temporary source file and maybe an existing
    // target file, and version numbers for both. We will replace or create
    // the target file if:
    //
    // - The target file doesn't have version data (this also catches the case
    //   where the target file didn't exist)
    //
    // - The source version is newer than or equal to the target version.
    //
    // So that means we *won't* replace the target file only if both source and
    // target have version info and the source is older than the target.
    //
    // If the target version is 0 then the source version is always >= the target
    // so one simple test does everything we want.
    //
#if 0
    if(SourceVersion >= TargetVersion) {
#else
    //
    // Quit version-checking.  We need to install a stable OS.  If we
    // version check, then we never know what we're going to end up with.
    //
    if(1) {
#endif // if 0

        //
        // Delete the existing target in preparation.
        //
        if(TargetExists) {
             SpDeleteFile(TargetFilename,NULL,NULL);
        }

        //
        // Rename temp file to actual target file.
        //
        RenameFileInfo->ReplaceIfExists = TRUE;
        RenameFileInfo->RootDirectory = NULL;
        RenameFileInfo->FileNameLength = wcslen(TargetFilename)*sizeof(WCHAR);

        ASSERT( RenameFileInfo->FileNameLength < pathSize );

        wcscpy(RenameFileInfo->FileName,TargetFilename);

        Status = ZwSetInformationFile(
                    SourceHandle,
                    &IoStatusBlock,
                    RenameFileInfo,
                    sizeof(FILE_RENAME_INFORMATION) + RenameFileInfo->FileNameLength,
                    FileRenameInformation
                    );

        SpMemFree(RenameFileInfo);

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to rename temp file to target %ws (%x)\n",TargetFilename,Status));
            ZwClose(SourceHandle);
            if(Moved) {
                SpRenameFile(TempFilename,SourceFilename,FALSE);
            }
            SpMemFree(TempFilename);
            return(Status);
        }

        //
        // If necessary, check if destination file is using NTFS compression, and
        // if so, uncompress it.
        //
        if(NT_SUCCESS(Status) && (Flags & COPY_FORCENOCOMP)) {

            Status = ZwQueryInformationFile(
                        SourceHandle,
                        &IoStatusBlock,
                        &BasicFileInfo2,
                        sizeof(BasicFileInfo2),
                        FileBasicInformation
                        );

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to get basic file info on %ws (%x)\n",TargetFilename,Status));
                ZwClose(SourceHandle);
                if(Moved) {
                    SpRenameFile(TempFilename,SourceFilename,FALSE);
                }
                SpMemFree(TempFilename);
                return(Status);
            }

            if(BasicFileInfo2.FileAttributes & FILE_ATTRIBUTE_COMPRESSED) {

                CompressionState = 0;

                Status = ZwFsControlFile(
                             SourceHandle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             FSCTL_SET_COMPRESSION,
                             &CompressionState,
                             sizeof(CompressionState),
                             NULL,
                             0
                             );

                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFileUsingNames: unable to make %ws uncompressed (%lx)\n",TargetFilename,Status));
                    ZwClose(SourceHandle);
                    if(Moved) {
                        SpRenameFile(TempFilename,SourceFilename,FALSE);
                    }
                    SpMemFree(TempFilename);
                    return(Status);
                }
            }
        }

        SpMemFree(TempFilename);

        //
        // Delete the source if necessary. If the source is not
        // compressed and the deletesource flag is set, then we moved
        // the source file and so the source file is already gone.
        //
        if(IsCompressed && (Flags & COPY_DELETESOURCE) && !RemoteSysPrepSetup  && !InDriverCab) {
            PWSTR   compname;

            //
            // Assume that the source name is on its compressed form, and attempt to
            // delete this file.
            //
            compname = SpGenerateCompressedName(SourceFilename);
            Status = SpDeleteFile(compname,NULL,NULL);
            SpMemFree(compname);
            if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
                //
                // If we couldn't delete the file with the compressed name, then the file name
                // was probably on its uncompressed format.
                //
                SpDeleteFile(SourceFilename,NULL,NULL);
            }
        }

        //
        // Apply attributes and timestamp.
        // Ignore errors.
        //
        if(!GotBasicInfo) {
            RtlZeroMemory(&BasicFileInfo,sizeof(BasicFileInfo));
        }

        //
        // Set the file attributes. Note that if the caller didn't specify any,
        // then 0 value will tell the I/O system to leave the attributes alone.
        //
        BasicFileInfo.FileAttributes = TargetAttributes;
        ZwSetInformationFile(
            SourceHandle,
            &IoStatusBlock,
            &BasicFileInfo,
            sizeof(BasicFileInfo),
            FileBasicInformation
            );

        ZwClose(SourceHandle);
        Status = STATUS_SUCCESS;

    } else {
        //
        // Delete the temporary source.
        //
        ZwClose(SourceHandle);
        SpDeleteFile(TempFilename,NULL,NULL);
        SpMemFree(TempFilename);
        SpMemFree(RenameFileInfo);
        Status = STATUS_SUCCESS;
    }

    if (RemoteSysPrepSetup &&
        NT_SUCCESS(Status) &&
        ((Flags & COPY_DECOMPRESS_SYSPREP) == 0)) {

        Status = SpSysPrepSetExtendedInfo( SourceFilename,
                                           TargetFilename,
                                           FALSE,
                                           FALSE );
    }

    return(Status);
}


VOID
SpValidateAndChecksumFile(
    IN  HANDLE   FileHandle, OPTIONAL
    IN  PWSTR    Filename,   OPTIONAL
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    )

/*++

Routine Description:

    Calculate a checksum value for a file using the standard
    nt image checksum method.  If the file is an nt image, validate
    the image using the partial checksum in the image header.  If the
    file is not an nt image, it is simply defined as valid.

    If we encounter an i/o error while checksumming, then the file
    is declared invalid.

Arguments:

    FileHandle - supplies handle of file to check (if not present, then
        Filename specifies the file to be opened and checked)

    Filename - supplies full NT path of file to check (if not present, then
        FileHandle must be specified)

    IsNtImage = Receives flag indicating whether the file is an
        NT image file.

    Checksum - receives 32-bit checksum value.

    Valid - receives flag indicating whether the file is a valid
        image (for nt images) and that we can read the image.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PVOID BaseAddress;
    ULONG FileSize;
    HANDLE hFile = FileHandle, hSection;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG HeaderSum;

    //
    // Assume not an image and failure.
    //
    *IsNtImage = FALSE;
    *Checksum = 0;
    *Valid = FALSE;

    //
    // Open and map the file for read access.
    //
    Status = SpOpenAndMapFile(
                Filename,
                &hFile,
                &hSection,
                &BaseAddress,
                &FileSize,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        return;
    }

    NtHeaders = SpChecksumMappedFile(BaseAddress,FileSize,&HeaderSum,Checksum);

    //
    // If the file is not an image and we got this far (as opposed to encountering
    // an i/o error) then the checksum is declared valid.  If the file is an image,
    // then its checksum may or may not be valid.
    //

    if(NtHeaders) {
        *IsNtImage = TRUE;
        *Valid = HeaderSum ? (*Checksum == HeaderSum) : TRUE;
    } else {
        *Valid = TRUE;
    }

    SpUnmapFile(hSection,BaseAddress);

    if(!FileHandle) {
        ZwClose(hFile);
    }
}


VOID
SpCopyFileWithRetry(
    IN PFILE_TO_COPY      FileToCopy,
    IN PWSTR              SourceDevicePath,
    IN PWSTR              DirectoryOnSourceDevice,
    IN PWSTR              SourceDirectory,         OPTIONAL
    IN PWSTR              TargetRoot,              OPTIONAL
    IN ULONG              TargetFileAttributes,    OPTIONAL
    IN PCOPY_DRAW_ROUTINE DrawScreen,
    IN PULONG             FileCheckSum,            OPTIONAL
    IN PBOOLEAN           FileSkipped,             OPTIONAL
    IN ULONG              Flags
    )

/*++

Routine Description:

    This routine copies a single file, allowing retry is an error occurs
    during the copy.  If the source file is LZ compressed, then it will
    be decompressed as it is copied to the target.

    If the file is not successfully copied, the user has the option
    to retry to copy or to skip copying that file after a profuse warning
    about how dangerous that is.

Arguments:

    FileToCopy - supplies structure giving information about the file
        being copied.

    SourceDevicePath - supplies path to device on which the source media
        is mounted (ie, \device\floppy0, \device\cdrom0, etc).

    DirectoryOnSourceDevice - Supplies the directory on the source where
        the file is to be found.

    TargetRoot - if specified, supplies the directory on the target
        to which the file is to be copied.

    TargetFileAttributes - if supplied (ie, non-0) supplies the attributes
        to be placed on the target on successful copy (ie, readonly, etc).
        If not specified, the attributes will be set to FILE_ATTRIBUTE_NORMAL.

    DrawScreen - supplies address of a routine to be called to refresh
        the screen.

    FileCheckSum - if specified, will contain the check sum of the file copied.

    FileSkipped - if specified, will inform the caller if there was no attempt
                  to copy the file.

    Flags - supplies flags to control special processing for this file, such as
        deleting the source file on successful copy or skip; smashing locks;
        specifying that the source file is oem; or to indicate that en oem file
        with the same name should be overwritten on upgrade. This value is ORed
        in with the Flags field of FileToCopy.

Return Value:

    None.

--*/

{
    PWSTR p = TemporaryBuffer;
    PWSTR FullSourceName,FullTargetName;
    NTSTATUS Status;
    ULONG ValidKeys[4] = { ASCI_CR, ASCI_ESC, KEY_F3, 0 };
    BOOLEAN IsNtImage,IsValid;
    ULONG Checksum;
    BOOLEAN Failure;
    ULONG MsgId;
    BOOLEAN DoCopy;
    ULONG CopyFlags;
    BOOLEAN PreinstallRememberFile;

    //
    // Form the full NT path of the source file.
    //
    wcscpy(p,SourceDevicePath);
    SpConcatenatePaths(p,DirectoryOnSourceDevice);
    if(SourceDirectory) {
        SpConcatenatePaths(p,SourceDirectory);
    }
    SpConcatenatePaths(p,FileToCopy->SourceFilename);

    FullSourceName = SpDupStringW(p);

    //
    // Form the full NT path of the target file.
    //
    wcscpy(p,FileToCopy->TargetDevicePath);
    if(TargetRoot) {
        SpConcatenatePaths(p,TargetRoot);
    }
    SpConcatenatePaths(p,FileToCopy->TargetDirectory);

    //
    //  On an OEM preinstall, if the target name is a long name, then use
    //  the short name as a target name, and later on, if the copy succeeds,
    //  add the file to RenameList, so that it can be added to $$rename.txt
    //
    if( !PreInstall ||
        ( wcslen( FileToCopy->TargetFilename ) <= 8 + 1 + 3 ) ) {
        SpConcatenatePaths(p,FileToCopy->TargetFilename);
        PreinstallRememberFile = FALSE;
    } else {
        SpConcatenatePaths(p,FileToCopy->SourceFilename);
        PreinstallRememberFile = TRUE;
    }
    FullTargetName = SpDupStringW(p);

    //
    // Call out to the draw screen routine to indicate that
    // a new file is being copied.
    //
    DrawScreen(FullSourceName,FullTargetName,FALSE);

    //
    // Build up the copy flags value.
    //
    CopyFlags = Flags | FileToCopy->Flags;

    //
    // Set the file attributes if specified in inf file else
    // set the attributes as specified by the caller.
    //
    if (FileToCopy->FileAttributes != FILE_ATTRIBUTES_NONE){
        TargetFileAttributes = FileToCopy->FileAttributes;
    } 
        
    do {
        DoCopy = TRUE;

        //
        // Check the copy options field.  The valid values here are
        //
        //    - COPY_ALWAYS
        //    - COPY_ONLY_IF_PRESENT
        //    - COPY_ONLY_IF_NOT_PRESENT
        //    - COPY_NEVER

        switch(CopyFlags & COPY_DISPOSITION_MASK) {

        case COPY_ONLY_IF_PRESENT:

            DoCopy = SpFileExists(FullTargetName, FALSE);
            break;

        case COPY_ONLY_IF_NOT_PRESENT:

            DoCopy = !SpFileExists(FullTargetName, FALSE);
            break;

        case COPY_NEVER:

            DoCopy = FALSE;

        case COPY_ALWAYS:
        default:
           break;
        }

        if(!DoCopy) {
            break;
        }

        //
        //  In the upgrade case, check if the file being copied
        //  replaces a third party file.
        //  If it does, then ask what the user wants to do about it
        //
        if( !RepairWinnt &&
            ( NTUpgrade == UpgradeFull ) &&
            SpFileExists(FullTargetName, FALSE) ) {
            //
            //  If necessary ask the user if he wants to overwrite the file.
            //  Otherwise go ahead and copy the file.
            //
            if(!(CopyFlags & COPY_OVERWRITEOEMFILE)) {
                PWSTR   TmpFilePath;
                BOOLEAN OverwriteFile;


                if(( TargetRoot == NULL ) ||
                   ( wcslen( FileToCopy->TargetDirectory ) == 0 ) ) {
                    wcscpy( p, FileToCopy->TargetFilename );
                } else {
                    wcscpy( p, TargetRoot );
                    SpConcatenatePaths( p, FileToCopy->TargetDirectory );
                    SpConcatenatePaths(p,FileToCopy->TargetFilename);
                }
                TmpFilePath = SpDupStringW(p);
                OverwriteFile = TRUE;

                if( ( (CopyFlags & COPY_SOURCEISOEM) == 0 ) &&
                    SppIsFileLoggedAsOemFile( TmpFilePath ) ) {

                    if( !UnattendedOperation ) {
                        ULONG ValidKeys[3] = { ASCI_CR, ASCI_ESC, 0 };
                        BOOLEAN ActionSelected = FALSE;
//                        ULONG Mnemonics[] = { MnemonicOverwrite, 0 };

                        //
                        //  Warn user that existing file is a third party file,
                        //  and ask if user wants to over write the file
                        //

                        while( !ActionSelected ) {
                            SpStartScreen(
                                SP_SCRN_OVERWRITE_OEM_FILE,
                                3,
                                HEADER_HEIGHT+1,
                                FALSE,
                                FALSE,
                                DEFAULT_ATTRIBUTE,
                                FileToCopy->TargetFilename
                                );

                            SpDisplayStatusOptions(
                                DEFAULT_STATUS_ATTRIBUTE,
                                SP_STAT_ENTER_EQUALS_REPLACE_FILE,
                                SP_STAT_ESC_EQUALS_SKIP_FILE,
                                0
                                );

                            switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

                                case ASCI_CR:       // don't overwrite

                                OverwriteFile = TRUE;
                                ActionSelected = TRUE;
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: OEM file %ls, will be overwritten.\n", FullTargetName ));
                                break;

                                case ASCI_ESC:      // skip file

                                OverwriteFile = FALSE;
                                ActionSelected = TRUE;
                                break;


                            }
                        }

                        //
                        // Need to completely repaint gauge, etc.
                        //
                        DrawScreen(FullSourceName,FullTargetName,TRUE);

                    } else {
                        //
                        //  On unattended upgrade, do what is in the script file
                        //
                        OverwriteFile = UnattendedOverwriteOem;
                    }
                }
                SpMemFree( TmpFilePath );

                if( !OverwriteFile ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: OEM file %ls, will not be overwritten.\n", FullTargetName ));
                    if( ARGUMENT_PRESENT( FileSkipped ) ) {
                         *FileSkipped = TRUE;
                    }
                    //
                    // Free the source and target filenames.
                    //
                    SpMemFree(FullSourceName);
                    SpMemFree(FullTargetName);
                    return;
                }
            }
        }
        
        //
        // Copy the file.  If there is a target root specified, assume
        // the file is being copied to the system partition and make
        // the file readonly, system, hidden.
        //
#if defined(REMOTE_BOOT)
        // If this is a remote boot install, check to see if a copy of the
        // file already exists on the server, and if so, just make a link
        // to the file instead of copying it.
        //
        if (RemoteBootSetup) {
            Status = SpCopyFileForRemoteBoot(
                        FullSourceName,
                        FullTargetName,
                        TargetFileAttributes,
                        CopyFlags,
                        &Checksum);
            IsValid = TRUE;         // Checksum is known
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }

        if (!NT_SUCCESS(Status))
#endif // defined(REMOTE_BOOT)
        {
            Status = SpCopyFileUsingNames(
                        FullSourceName,
                        FullTargetName,
                        TargetFileAttributes,
                        CopyFlags
                        );
            IsValid = FALSE;        // Checksum is not known
        }

        //
        // If the file copied OK, verify the copy.
        //
        if(NT_SUCCESS(Status)) {

            if (!IsValid) {
                SpValidateAndChecksumFile(NULL,FullTargetName,&IsNtImage,&Checksum,&IsValid);
            }
            if( ARGUMENT_PRESENT( FileCheckSum ) ) {
                *FileCheckSum = Checksum;
            }

            //
            // If the image is valid, then the file really did copy OK.
            //
            if(IsValid) {
                Failure = FALSE;
            } else {

                //
                // If it's an nt image, then the verify failed.
                // If it's not an nt image, then the only way the verify
                // can fail is if we get an i/o error reading the file back,
                // which means it didn't really copy correctly.
                //
                MsgId = IsNtImage ? SP_SCRN_IMAGE_VERIFY_FAILED : SP_SCRN_COPY_FAILED;
                Failure = TRUE;
                PreinstallRememberFile = FALSE;
            }

        } else {
            if((Status == STATUS_OBJECT_NAME_NOT_FOUND) && (Flags & COPY_SKIPIFMISSING)) {
                Failure = FALSE;
            } else {
                Failure = TRUE;
                MsgId = SP_SCRN_COPY_FAILED;
            }
           PreinstallRememberFile = FALSE;
        }

        if(Failure) {

            //
            // The copy or verify failed.  Give the user a message and allow retry.
            //
            repaint:
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                FileToCopy->SourceFilename
                );

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_RETRY,
                SP_STAT_ESC_EQUALS_SKIP_FILE,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

            switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

            case ASCI_CR:       // retry

                break;

            case ASCI_ESC:      // skip file

                Failure = FALSE;
                break;

            case KEY_F3:        // exit setup

                SpConfirmExit();
                goto repaint;
            }

            //
            // Need to completely repaint gauge, etc.
            //
            DrawScreen(FullSourceName,FullTargetName,TRUE);
        }

    } while(Failure);

    if( ARGUMENT_PRESENT( FileSkipped ) ) {
        *FileSkipped = !DoCopy;
    }

    //
    // Free the source and target filenames.
    //
    SpMemFree(FullSourceName);
    SpMemFree(FullTargetName);

    //
    //  In the preinstall mode, add the file to RenameList
    //
    if( PreInstall && PreinstallRememberFile ) {
        PFILE_TO_RENAME  File;

        File = SpMemAlloc(sizeof(FILE_TO_RENAME));
        File->SourceFilename = SpDupStringW(FileToCopy->SourceFilename);
        wcscpy(TemporaryBuffer,L"\\");
        if(TargetRoot) {
            SpConcatenatePaths(TemporaryBuffer,TargetRoot);
        }
        SpConcatenatePaths(TemporaryBuffer,FileToCopy->TargetDirectory);
        File->TargetDirectory = SpDupStringW(TemporaryBuffer);
        File->TargetFilename = SpDupStringW((PWSTR)FileToCopy->TargetFilename);
        File->Next = RenameList;
        RenameList = File;
    }
}


VOID
SpCopyFilesScreenRepaint(
    IN PWSTR   FullSourcename,      OPTIONAL
    IN PWSTR   FullTargetname,      OPTIONAL
    IN BOOLEAN RepaintEntireScreen
    )
{
    static ULONG u = 0;
    PWSTR p;
    UNREFERENCED_PARAMETER(FullTargetname);

    //
    // Repaint the entire screen if necessary.
    //
    if(RepaintEntireScreen) {

        SpStartScreen(SP_SCRN_SETUP_IS_COPYING,0,6,TRUE,FALSE,DEFAULT_ATTRIBUTE);
        if(FileCopyGauge) {
            SpDrawGauge(FileCopyGauge);
        }
    }

    //
    // Place the name of the file being copied on the rightmost
    // area of the status line.
    //
    if(FullSourcename) {

        if(RepaintEntireScreen) {

            SpvidClearScreenRegion(
                0,
                VideoVars.ScreenHeight-STATUS_HEIGHT,
                VideoVars.ScreenWidth,
                STATUS_HEIGHT,
                DEFAULT_STATUS_BACKGROUND
                );

            SpDisplayStatusActionLabel(SP_STAT_COPYING,12);
        }

        //
        // Isolate the filename part of the sourcename.
        //
        if(p = wcsrchr(FullSourcename,L'\\')) {
            p++;
        } else {
            p = FullSourcename;
        }

        if( !HeadlessTerminalConnected ) {
            SpDisplayStatusActionObject(p);
        } else {


            PWCHAR TempPtr = NULL;
            //
            // If we're headless, we need to be careful about displaying very long
            // file/directory names.  For that reason, just display a little spinner.
            //
            switch( u % 4) {
            case 0:
                TempPtr = L"-";
                break;
            case 1:
                TempPtr = L"\\";
                break;
            case 2:
                TempPtr = L"|";
                break;
            default:
                TempPtr = L"/";
                break;

            }

            SpDisplayStatusActionObject( TempPtr );

            u++;

        }
    }
}

VOID
SpCopyFilesInCopyList(
    IN PVOID                    SifHandle,
    IN PDISK_FILE_LIST          DiskFileLists,
    IN ULONG                    DiskCount,
    IN PWSTR                    SourceDevicePath,
    IN PWSTR                    DirectoryOnSourceDevice,
    IN PWSTR                    TargetRoot,
    IN PINCOMPATIBLE_FILE_LIST  CompatibilityExceptionList OPTIONAL
    )

/*++

Routine Description:

    Iterate the copy list for each setup source disk and prompt for
    the disk and copy/decompress all the files on it.

Arguments:

    SifHandle - supplies handle to setup information file.

    DiskFileLists - supplies the copy list, in the form of an array
        of structures, one per disk.

    DiskCount - supplies number of elements in the DiskFileLists array,
        ie, the number of setup disks.

    SourceDevicePath - supplies the path of the device from which files
        are to be copied (ie, \device\floppy0, etc).

    DirectoryOnSourceDevice - supplies the directory on the source device
        where files are to be found.

    TargetRoot - supplies root directory of target.  All target directory
        specifications are relative to this directory on the target.

    CompatibilityExceptionList - Singly-linked list of
        PINCOMPATIBLE_FILE_ENTRY objects that should be skipped during
        copying.  Optional, pass NULL if no exceptions are present.

Return Value:

    None.

--*/

{
    ULONG DiskNo;
    PDISK_FILE_LIST pDisk;
    PFILE_TO_COPY pFile;
    ULONG TotalFileCount;
    ULONG   CheckSum;
    BOOLEAN FileSkipped;
    ULONG CopyFlags;
    NTSTATUS status;
    //
    // Compute the total number of files.
    //
    for(TotalFileCount=DiskNo=0; DiskNo<DiskCount; DiskNo++) {
        TotalFileCount += DiskFileLists[DiskNo].FileCount;
    }

    //
    // If there are no files to copy, then we're done.
    //
    if( TotalFileCount == 0 ) {
        return;
    }

    SendSetupProgressEvent(FileCopyEvent, FileCopyStartEvent, &TotalFileCount);

    //
    // Create a gas gauge.
    //
    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_SETUP_IS_COPYING);
    FileCopyGauge = SpCreateAndDisplayGauge(TotalFileCount,0,15,TemporaryBuffer,NULL,GF_PERCENTAGE,0);
    ASSERT(FileCopyGauge);

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Copy files on each disk.
    //
    for(DiskNo=0; DiskNo<DiskCount; DiskNo++) {

        pDisk = &DiskFileLists[DiskNo];

        //
        // Don't bother with this disk if there are no files
        // to be copied from it.
        //
        if(pDisk->FileCount == 0) {
            continue;
        }

        //
        // Prompt the user to insert the disk.
        //
        SpPromptForDisk(
            pDisk->Description,
            SourceDevicePath,
            pDisk->TagFile,
            FALSE,              // no ignore disk in drive
            FALSE,              // no allow escape
            TRUE,               // warn multiple prompts
            NULL                // don't care about redraw flag
            );

        //
        // Passing the empty string as the first arg forces
        // the action area of the status line to be set up.
        // Not doing so results in the "Copying: xxxxx" to be
        // flush left on the status line instead of where
        // it belongs (flush right).
        //
        SpCopyFilesScreenRepaint(L"",NULL,TRUE);

        //
        // Copy each file on the source disk.
        //
        ASSERT(pDisk->FileList);
        for(pFile=pDisk->FileList; pFile; pFile=pFile->Next) {
            
            //
            // Copy the file.
            //
            // If the file is listed for lock smashing then we need to smash it
            // if installing UP on x86 (we don't bother with the latter
            // qualifications here).
            //
            // If there is an absolute target root specified, assume the
            // file is being copied to the system partition and make it
            // readonly/hidden/system.
            //
            // On upgrade, we need to know if the file is listed for oem overwrite.
            //

            //
            // "Copy" or "Move"??
            //
            if( (WinntSetup || RemoteInstallSetup)  &&
                (!WinntFromCd)                      &&
                (!NoLs)                             &&
                (NTUpgrade != UpgradeFull)          &&
                (!IsFileFlagSet(SifHandle,pFile->TargetFilename,FILEFLG_DONTDELETESOURCE)) ) {

                //
                // We can delete the source (i.e. do a 'move')
                //
                CopyFlags = COPY_DELETESOURCE;
            } else {

                //
                // Do a 'copy'
                //
                CopyFlags = 0;
            }

#if 0
#ifdef _X86_
            //
            // Copy out of \uniproc (which contains lock-smashed binaries)?
            //
            if( IsFileFlagSet(SifHandle,pFile->TargetFilename,FILEFLG_SMASHLOCKS) ) {
                CopyFlags |= COPY_SMASHLOCKS;
            }
#endif // defined _X86_
#endif // if 0

            //
            // What do we do if we can't find a file??
            //
            if( SkipMissingFiles ) {
                CopyFlags |= COPY_SKIPIFMISSING;
            }


            //
            // Do we overwrite files installed by the OEM?
            //
            if( (NTUpgrade == UpgradeFull) &&
                (IsFileFlagSet(SifHandle,pFile->TargetFilename,FILEFLG_UPGRADEOVERWRITEOEM)) ) {

                CopyFlags |= COPY_OVERWRITEOEMFILE;
            }

            //
            // If the file is incompatible, and it's got the overwrite flag set,
            // the blow it away with our own one instead.
            //
            if ( SpIsFileIncompatible(
                    CompatibilityExceptionList,
                    pFile,
                    pFile->AbsoluteTargetDirectory ? NULL : TargetRoot
                    ) )
            {
                if (IsFileFlagSet(SifHandle,pFile->SourceFilename,FILEFLG_UPGRADEOVERWRITEOEM) ||
                    ( pFile->Flags & FILEFLG_UPGRADEOVERWRITEOEM ) ) {

                    CopyFlags = (CopyFlags & ~(COPY_DISPOSITION_MASK|COPY_OVERWRITEOEMFILE));
                    CopyFlags |= COPY_ALWAYS | COPY_NOVERSIONCHECK;

                    KdPrintEx((
                        DPFLTR_SETUP_ID,
                        DPFLTR_INFO_LEVEL,
                        "SETUP: OEM (or preexsting) file %ws is incompatible with gui-mode, set flag %08lx, forcing copy\n",
                        pFile->TargetFilename,
                        CopyFlags
                        ));

                }
            }

            //
            // What about any privates?  We don't want to ever 'move'
            // privates because they might be in the driver cab, in which
            // case, we want them in the ~LS directory when
            // we go into gui-mode setup.
            //
            if( (pSpIsFileInPrivateInf(pFile->TargetFilename)) ) {
                CopyFlags &= ~COPY_DELETESOURCE;
            }


            if(!WIN9X_OR_NT_UPGRADE || IsFileFlagSet(SifHandle,pFile->SourceFilename,FILEFLG_NOVERSIONCHECK)) {
                CopyFlags |= COPY_NOVERSIONCHECK;
            }
            
            SpCopyFileWithRetry(
                pFile,
                SourceDevicePath,
                DirectoryOnSourceDevice,
                pDisk->Directory,
                pFile->AbsoluteTargetDirectory ? NULL : TargetRoot,
                pFile->AbsoluteTargetDirectory ? FILE_ATTRIBUTES_RHS : 0,
                SpCopyFilesScreenRepaint,
                &CheckSum,
                &FileSkipped,
                CopyFlags
                );

            //
            // Log the file
            //
            if( !FileSkipped ) {
                SpLogOneFile( pFile,
                              pFile->AbsoluteTargetDirectory ? NULL : TargetRoot,
                              NULL, // DirectoryOnSourceDevice,
                              NULL,
                              NULL,
                              CheckSum );
            }


            //
            // Advance the gauge.
            //
            SpTickGauge(FileCopyGauge);

            SendSetupProgressEvent(FileCopyEvent,
                                   OneFileCopyEvent,
                                   &((PGAS_GAUGE)FileCopyGauge)->CurrentPercentage);
        }
    }

    SendSetupProgressEvent(FileCopyEvent, FileCopyEndEvent, NULL);

    SpDestroyGauge(FileCopyGauge);
    FileCopyGauge = NULL;
}


NTSTATUS
SpCreateIncompatibleFileEntry(
    OUT PINCOMPATIBLE_FILE_ENTRY *TargetEntry,
    IN PWSTR FileName,
    IN PWSTR VersionString,             OPTIONAL
    IN PWSTR TargetAbsolutePath,        OPTIONAL
    IN ULONG Flags                      OPTIONAL
    )
/*++

Routine Description:

    Allocates enough space to store the incompatible file entry data in
    a contiguous blob, copies the values into it, and returns the blob
    created. Layout (using null-terminated strings) is as follows:

    [ Allocation                                    ]
    [ Header ][Filename][Version][TargetAbsolutePath]

Arguments:

    TargetEntry - Pointer to a PINCOMPATIBLE_FILE_ENTRY that will be
        returned to the caller.

    FileName - Name of the file, no path

    VersionString - Full version string of the file

    TargetAbsolutePath - Absolute path on the target media that this
        file will live in

    Flags - Any flags to be stored

Returns:

    STATUS_SUCCESS if TargetEntry contains a pointer to the allocated space

    STATUS_NO_MEMORY if the allocation failed

    STATUS_INVALID_PARAMETER_1 if TargetEntry was NULL

    STATUS_INVALID_PARAMETER_2 if FileName was NULL

--*/
{
    ULONG WCharsNeeded = 0;
    ULONG ActualBytes = 0;
    PINCOMPATIBLE_FILE_ENTRY LocalEntry;
    PWSTR Cursor;

    if ( TargetEntry )
        *TargetEntry = NULL;
    else
        return STATUS_INVALID_PARAMETER_1;

    //
    // Gather required sizes
    //
    if ( FileName != NULL )
        WCharsNeeded += wcslen(FileName) + 1;
    else
        return STATUS_INVALID_PARAMETER_2;

    if ( VersionString != NULL )
        WCharsNeeded += wcslen(VersionString) + 1;

    if ( TargetAbsolutePath != NULL )
        WCharsNeeded += wcslen(TargetAbsolutePath) + 1;

    //
    // Allocate the space, point the cursor at where we'll be copying
    // the strings.
    //
    ActualBytes = ( sizeof(WCHAR) * WCharsNeeded ) + sizeof(INCOMPATIBLE_FILE_ENTRY);
    LocalEntry = SpMemAlloc( ActualBytes );

    if ( LocalEntry == NULL ) {
        return STATUS_NO_MEMORY;
    }

    //
    // Blank it out, point the write cursor at the end
    //
    ZeroMemory(LocalEntry, ActualBytes);
    Cursor = (PWSTR)(LocalEntry + 1);

    //
    // Copy strings and set pointers
    //
    wcscpy(Cursor, FileName);
    LocalEntry->IncompatibleFileName = Cursor;
    Cursor += wcslen(FileName) + 1;

    if ( VersionString != NULL ) {

        wcscpy(Cursor, VersionString);
        LocalEntry->VersionString = Cursor;
        Cursor += wcslen(VersionString) + 1;

    }

    if ( TargetAbsolutePath != NULL ) {

        wcscpy(Cursor, TargetAbsolutePath);
        LocalEntry->FullPathOnTarget = Cursor;

    }

    *TargetEntry = LocalEntry;

    return STATUS_SUCCESS;

}


NTSTATUS
SpFreeIncompatibleFileList(
    IN PINCOMPATIBLE_FILE_LIST FileListHead
    )
/*++

Routine Description:

    Cleans out the list of incompatible entries by freeing all the space
    that was allocated for the list.

Arguments:

    FileListHead - Pointer to the list containing INCOMPATIBLE_FILE_ENTRY
        items

Return values:

    STATUS_SUCCESS if the operation succeeds.

    STATUS_INVALID_PARAMETER if FileListHead is NULL

--*/
{
    PINCOMPATIBLE_FILE_ENTRY    IncListEntry;

    if ( !FileListHead )
        return STATUS_INVALID_PARAMETER;

    while ( FileListHead->Head != NULL ) {

        //
        // Simple list removal, some bookkeeping
        //
        IncListEntry = FileListHead->Head;

        FileListHead->Head = IncListEntry->Next;

        FileListHead->EntryCount--;

        SpMemFree( IncListEntry );
    }

    //
    // Toast the list structure as well.
    //
    FileListHead->Head = NULL;
    FileListHead->EntryCount = 0;

    return STATUS_SUCCESS;

}


BOOLEAN
SpIsFileIncompatible(
    IN  PINCOMPATIBLE_FILE_LIST FileList,
    IN  PFILE_TO_COPY           pFile,
    IN  PWSTR                   TargetRoot OPTIONAL
    )
/*++

Routine Description:

    Find out whether the given target media path and file name are listed
    as "incompatible."  Looks down FileList for an INCOMPATIBLE_FILE_ENTRY
    that contains FileName and TargetMediaPath.  If TargetMediaPath is not
    specified, indicates TRUE if a member with the name FileName is listed
    instead.  (Dangerous.)

Arguments:

    FileList - Header node of a list created with
        SpInitializeCompatibilityOverwriteLists.

    pFile - File to copy structure, containing all the relevant information
        about this file to scan for.

    TargetRoot - Copy target root directory, optional

Return Values:

    TRUE if the file "FileName" (with the optional path TargetMediaPath)
        is in the list of incompatible files.

    FALSE otherwise, or if FileList or FileName is NULL.

Remarks:

    This routine could be made more robust in the face of bad parameters,
    but this was deemed superfluous, since there's exactly one caller of
    this API whose values are already checked.  This function will then
    behave "properly" in all cases.

--*/
{
    INCOMPATIBLE_FILE_ENTRY *Entry;
    BOOLEAN                  Found = FALSE;
    PWSTR                    TargetFileName;

    if ( ( FileList == NULL ) || ( FileList->EntryCount == 0 ) )
        goto Exit;

    if ( pFile == NULL )
        goto Exit;

    Entry = FileList->Head;

    //
    // Cache locally
    //
    TargetFileName = pFile->TargetFilename;

    //
    // Generate the target media path from the file object
    //
#if 0
VOID
SpCopyFileWithRetry(    SpCopyFileWithRetry(
    IN PFILE_TO_COPY      FileToCopy,        pFile,
    IN PWSTR              SourceDevicePath,        SourceDevicePath,
    IN PWSTR              DirectoryOnSourceDevice,        DirectoryOnSourceDevice,
    IN PWSTR              SourceDirectory,         OPTIONAL        pDisk->Directory,
    IN PWSTR              TargetRoot,              OPTIONAL        pFile->AbsoluteTargetDirectory ? NULL : TargetRoot,
    IN ULONG              TargetFileAttributes,    OPTIONAL        pFile->AbsoluteTargetDirectory ? ATTR_RHS : 0,
    IN PCOPY_DRAW_ROUTINE DrawScreen,        SpCopyFilesScreenRepaint,
    IN PULONG             FileCheckSum,            OPTIONAL        &CheckSum,
    IN PBOOLEAN           FileSkipped,             OPTIONAL        &FileSkipped,
    IN ULONG              Flags        CopyFlags
        );

    VOID
    SpCopyFileWithRetry(
        IN PFILE_TO_COPY      FileToCopy,
        IN PWSTR              SourceDevicePath,
        IN PWSTR              DirectoryOnSourceDevice,
        IN PWSTR              SourceDirectory,         OPTIONAL
        IN PWSTR              TargetRoot,              OPTIONAL
        IN ULONG              TargetFileAttributes,    OPTIONAL
        IN PCOPY_DRAW_ROUTINE DrawScreen,
        IN PULONG             FileCheckSum,            OPTIONAL
        IN PBOOLEAN           FileSkipped,             OPTIONAL
        IN ULONG              Flags
        )

    //
    // Form the full NT path of the target file.
    //
    wcscpy(p,FileToCopy->TargetDevicePath);
    if(TargetRoot) {
        SpConcatenatePaths(p,TargetRoot);
    }
    SpConcatenatePaths(p,FileToCopy->TargetDirectory);

    //
    //  On an OEM preinstall, if the target name is a long name, then use
    //  the short name as a target name, and later on, if the copy succeeds,
    //  add the file to RenameList, so that it can be added to $$rename.txt
    //
    if( !PreInstall ||
        ( wcslen( FileToCopy->TargetFilename ) <= 8 + 1 + 3 ) ) {
        SpConcatenatePaths(p,FileToCopy->TargetFilename);
        PreinstallRememberFile = FALSE;
    } else {
        SpConcatenatePaths(p,FileToCopy->SourceFilename);
        PreinstallRememberFile = TRUE;
    }
    FullTargetName = SpDupStringW(p);
#endif // if 0

    //
    // Cycle through the list of incompatible file names, looking
    // for the one requested
    //
    while ( Entry != NULL ) {

        //
        // If the file names match, then check the media paths if
        // specified
        //
        if (_wcsicmp(TargetFileName, Entry->IncompatibleFileName) == 0) {


            //
            // CUT&PASTE CUT&PASTE CUT&PASTE CUT&PASTE CUT&PASTE CUT&PASTE
            //
            // This was clipped from SpCopyFileWithRetry's code that generates the
            // actual target path.  I think the logic is supposed to look something
            // like the following:
            //
            // Target =
            //      File.TargetDevicePath +
            //      (File.AbsoluteTargetDirectory ? "" : TargetRoot) +
            //      File.TargetDirectory +
            //      ( (PreInstall || File.TargetFileName.Length > 12 ) ? File.SourceFilename : File.TargetFilename )
            //

            PWSTR TargetMediaPath = (PWSTR)TemporaryBuffer;

            wcscpy( TargetMediaPath, pFile->TargetDevicePath );

            if ( !pFile->AbsoluteTargetDirectory && ( TargetRoot != NULL ) ) {
                SpConcatenatePaths(TargetMediaPath, TargetRoot);
            }

            SpConcatenatePaths(TargetMediaPath,pFile->TargetDirectory);

            if ( !PreInstall || ( wcslen( pFile->TargetFilename ) <= 8 + 1 + 3 ) ) {
                SpConcatenatePaths(TargetMediaPath, pFile->TargetFilename);
            } else {
                SpConcatenatePaths(TargetMediaPath, pFile->SourceFilename);
            }


            //
            // When requesting an exact match, check it
            //
            if (Entry->FullPathOnTarget != NULL) {

                if (_wcsicmp(TargetMediaPath, Entry->FullPathOnTarget) == 0) {

                    Found = TRUE;
                    goto Exit;

                }

            //
            // Otherwise, the target media path was NULL, so just care if
            // the short names matched
            //
            } else {

                Found = TRUE;
                goto Exit;

            }

        }

        Entry = Entry->Next;
    }

Exit:
    return Found;

}



NTSTATUS
SpInitializeCompatibilityOverwriteLists(
    IN  PVOID                   SifHandle,
    OUT PINCOMPATIBLE_FILE_LIST IncompatibleFileList
    )
/*++

Routine Description:

    Reads the list of files that were marked as "incompatible" or "wrong
    version" in Winnt32, and stored in the IncompatibleFilesToOverWrite
    section of the sif file.  The data should be in the format

    [IncompatibleFilesToOverWrite]
    <shortname> = <version>,<full file path>

Arguments:

    SifHandle - Handle to the INF that this list will be loaded from.

    IncompatibleFileLists - Filled out to

Returns:

    STATUS_SUCCESS on good completion.

    STATUS_INVALID_PARAMETER_1 if SifHandle is NULL.

    STATUS_INVALID_PARAMETER_2 if IncompatibleFileList is NULL.

--*/
{
    NTSTATUS                    status = STATUS_SUCCESS;
    INCOMPATIBLE_FILE_LIST      fileListHead;
    PINCOMPATIBLE_FILE_ENTRY    fileListSingle = NULL;
    PWSTR                       SectionName = WINNT_OVERWRITE_EXISTING_W;
    PWSTR                       VersionString;
    PWSTR                       TargetMediaName;
    PWSTR                       FileName;
    PWSTR                       FullNtPathOfTargetName;
    ULONG                       SectionItemCount;
    ULONG                       i;

    if ( !SifHandle )
        return STATUS_INVALID_PARAMETER_1;

    if ( !IncompatibleFileList )
        return STATUS_INVALID_PARAMETER_2;

    //
    // Construct our local copy
    //
    IncompatibleFileList->Head = NULL;
    IncompatibleFileList->EntryCount = 0;
    fileListHead.Head = NULL;
    fileListHead.EntryCount = 0;

    SectionItemCount = SpCountLinesInSection(SifHandle, SectionName);

    for ( i = 0; i < SectionItemCount; i++ ) {

        FileName = SpGetKeyName( SifHandle, SectionName, i );

        if (!FileName){
            SpFatalSifError(SifHandle,SectionName,NULL,i,(ULONG)(-1));
        }

        //
        // Get the version string
        //
        VersionString = SpGetSectionKeyIndex(
            SifHandle,
            SectionName,
            FileName,
            0 );

        //
        // And name on the target media, if specified.
        //
        TargetMediaName = SpGetSectionKeyIndex(
            SifHandle,
            SectionName,
            FileName,
            1 );

        //
        // We can't, unfortunately, just use the path we got from the sif
        // file, as it's a Win32 path (c:\foo\bar\zot.foom).  We need a full
        // NT path (\Device\Harddisk0\Partition1\foo\bar\zot.foom) instead.
        // So, we convert with SpNtPathFromDosPath, which has the side-
        // effect of allocating space, which we don't necessarily care
        // about.
        //
        FullNtPathOfTargetName = SpNtPathFromDosPath( TargetMediaName );

        //
        // Create the file list entry, and store it for
        // later use.
        //
        status = SpCreateIncompatibleFileEntry(
            &fileListSingle,
            FileName,
            VersionString,
            FullNtPathOfTargetName,
            0 );

        //
        // If that failed and we have a full path, it should get freed
        // before we fail this code path to avoid a leak.
        //
        if ( FullNtPathOfTargetName != NULL ) {

            SpMemFree(FullNtPathOfTargetName);
            FullNtPathOfTargetName = NULL;

        }


        if (!NT_SUCCESS(status))
            goto Exit;

        //
        // Head insertion, indicate it was added
        //
        fileListSingle->Next = fileListHead.Head;
        fileListHead.Head = fileListSingle;
        fileListHead.EntryCount++;

        fileListSingle = NULL;

    }

    //
    // And store the list from here to there.
    //
    *IncompatibleFileList = fileListHead;

Exit:
    //
    // Did we accidentally create one but fail to insert it?  Hmm...
    //
    if( fileListSingle != NULL ) {
        SpMemFree(fileListSingle);
        fileListSingle = NULL;
    }

    //
    // If there was a failure and the list is nonempty, free its
    // entries.  It will not have been copied over to IncompatibleFileLists
    // (the only point of failure is SpCreateIncompatibleFileEntry, which
    // if it fails leaps out to Exit: without assigning IFL.)
    //
    if ( fileListHead.EntryCount != 0 && !NT_SUCCESS(status)) {
        SpFreeIncompatibleFileList( &fileListHead );
    }

    return status;
}



VOID
SpInitializeFileLists(
    IN  PVOID            SifHandle,
    OUT PDISK_FILE_LIST *DiskFileLists,
    OUT PULONG           DiskCount
    )

/*++

Routine Description:

    Initialize disk file lists.  This involves looking in a given section
    in the sectup information file and fetching information for each
    disk specified there.  The data is expected to be in the format

    [<SifSection>]
    <MediaShortname> = <Description>,<TagFile>[,,<Directory>]
    ...


    (Note that <Directory> is the third field -- the 2 commas
    are not a typo -- field 2 is unused.)

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    DiskFileLists - receives pointer to an array of disk file list
        structures, one per line in SifSection.  The caller must free
        this buffer when finished with it.

    DiskCount - receives number of elements in DiskFileLists array.

Return Value:

    None.

--*/

{
    unsigned pass;
    PWSTR mediaShortname,description,tagFile,directory;
    PDISK_FILE_LIST diskFileLists;
    PWSTR SectionName;
    ULONG TotalCount;
    ULONG SectionCount;
    ULONG i,u;
    BOOLEAN Found;

    diskFileLists = SpMemAlloc(0);
    TotalCount = 0;

    for(pass=0; pass<2; pass++) {

        //
        // On first pass do the platform-specific section.
        //
        SectionName = pass
                    ? SIF_SETUPMEDIA
                    : SpMakePlatformSpecificSectionName(SIF_SETUPMEDIA);

        //
        // Determine the number of media specifications
        // in the given section.
        //
        if (SectionName) {
            SectionCount = SpCountLinesInSection(SifHandle,SectionName);

            diskFileLists = SpMemRealloc(
                                diskFileLists,
                                (TotalCount+SectionCount) * sizeof(DISK_FILE_LIST)
                                );

            //
            // Zero out the new part of the buffer we just reallocated.
            //
            RtlZeroMemory(
                diskFileLists + TotalCount,
                SectionCount * sizeof(DISK_FILE_LIST)
                );

            for(i=0; i<SectionCount; i++) {

                //
                // Fetch parameters for this disk.
                //
                mediaShortname = SpGetKeyName(SifHandle,SectionName,i);
                if(!mediaShortname) {
                    SpFatalSifError(SifHandle,SectionName,NULL,i,(ULONG)(-1));
                }

                //
                // Ignore if we've already processed a media with this
                // shortname. This lets the platform-specific one override
                // the platform-independent one.
                //
                Found = FALSE;
                for(u=0; u<TotalCount; u++) {
                    if(!_wcsicmp(mediaShortname,diskFileLists[u].MediaShortname)) {
                        Found = TRUE;
                        break;
                    }
                }

                if(!Found) {
                    SpGetSourceMediaInfo(SifHandle,mediaShortname,&description,&tagFile,&directory);

                    //
                    // Initialize the disk file list structure.
                    //
                    diskFileLists[TotalCount].MediaShortname = mediaShortname;
                    diskFileLists[TotalCount].Description = description;
                    diskFileLists[TotalCount].TagFile = tagFile;
                    diskFileLists[TotalCount].Directory = directory;
                    TotalCount++;
                }
            }

            if(!pass) {
                SpMemFree(SectionName);
            }
        }
    }

    *DiskFileLists = diskFileLists;
    *DiskCount = TotalCount;
}

ULONG
SpInterpretFileAttributes(  
    IN PVOID    SifHandle,
    IN PWSTR    SifSection,    
    IN PWSTR    SifKey,    OPTIONAL
    IN ULONG    SifLine,
    IN ULONG    Index
    )
/*++
Routine Description:

    Interpret the file attributes mentioned in the sif file for the file.
    They can be specified like "ASHR" for Archive, System, Hidden and Readonly.

Arguments:

    SifHandle   - supplies handle to loaded setup information file.

    SifSection  - Section in the txtsetup.sif file that this file entry resides.

    SifKey      - Source File name.
    
    SifLine     - Line number in the section for the entry.

    Index       - Index of the attributes value in the file entry.    
Return Value:

    File Attributes.

--*/
{
    PWSTR AttributesString  = NULL;
    ULONG FileAttributes    = FILE_ATTRIBUTES_NONE; // this is the default file attribute.

    if(SifKey) {
        AttributesString = SpGetSectionKeyIndex(SifHandle,SifSection,SifKey,Index);
    } else {

        AttributesString = SpGetSectionLineIndex(SifHandle,SifSection,SifLine,Index);
    }

    //
    // Find out the attributes that need to be set for the file.
    // A (Archive) S (System) H (Hidden) R (ReadOnly) N (Normal), it has to be one of these.
    //
    if (AttributesString){        

        //
        // All other attributes override FILE_ATTRIBUTE_NORMAL hence no harm in even setting it
        // if specified for the file.
        //
        while(*AttributesString){
            switch (SpToUpper(*AttributesString)){
                case L'A'   :
                    FileAttributes |= FILE_ATTRIBUTE_ARCHIVE;
                    break;
                
                case L'S'   :
                    FileAttributes |= FILE_ATTRIBUTE_SYSTEM;
                    break;
                
                case L'H'   :
                    FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
                    break;
                
                case L'R'   :
                    FileAttributes |= FILE_ATTRIBUTE_READONLY;
                    break;
                
                case L'N'   :                    
                    FileAttributes |= FILE_ATTRIBUTE_NORMAL;
                    break;

                default     :   
                    KdPrintEx(( DPFLTR_SETUP_ID, 
                                DPFLTR_INFO_LEVEL, 
                                "SETUP: SpInterpretFileAttributes() :File Attribute other than (ASHRN) specified\n"));
            }
            AttributesString++;
        }
        
    }
    
    return(FileAttributes);
}

VOID
SpFreeCopyLists(
    IN OUT PDISK_FILE_LIST *DiskFileLists,
    IN     ULONG            DiskCount
    )
{
    ULONG u;
    PFILE_TO_COPY Entry,Next;

    //
    // Free the copy list on each disk.
    //
    for(u=0; u<DiskCount; u++) {

        for(Entry=(*DiskFileLists)[u].FileList; Entry; ) {

            Next = Entry->Next;

            SpMemFree(Entry);

            Entry = Next;
        }
    }

    SpMemFree(*DiskFileLists);
    *DiskFileLists = NULL;
}


BOOLEAN
SpCreateEntryInCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN ULONG           DiskNumber,
    IN PWSTR           SourceFilename,
    IN PWSTR           TargetDirectory,
    IN PWSTR           TargetFilename,
    IN PWSTR           TargetDevicePath,
    IN BOOLEAN         AbsoluteTargetDirectory,
    IN ULONG           CopyFlags,
    IN ULONG           FileAttributes
    )

/*++

Routine Description:

    Adds an entry to a disk's file copy list after first verifying that
    the file is not already on the disk copy list.

Arguments:

    SifHandle - supplies handle to loaded text setup information file
        (txtsetup.sif).

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    SourceFilename - supplies the name of the file as it exists on the
        distribution media.

    TargetDirectory - supplies the directory on the target media
        into which the file will be copied.

    TargetFilename - supplies the name of the file as it will exist
        in the target tree.

    TargetDevicePath - supplies the NT name of the device onto which the file
        is to be copied (ie, \device\harddisk1\partition2, etc).

    AbsoluteTargetDirectory - indicates whether TargetDirectory is a path from the
        root, or relative to a root to specified later.

    CopyFlags -
         COPY_ALWAYS              : always copied
         COPY_ONLY_IF_PRESENT     : copied only if present on the targetReturn Value:
         COPY_ONLY_IF_NOT_PRESENT : not copied if present on the target
         COPY_NEVER               : never copied

    FileAttributes - File attributes to be set for the file.
    
Return Value:

    TRUE if a new copy list entry was created; FALSE if not (ie, the file was
        already on the copy list).

--*/

{
    PDISK_FILE_LIST pDiskList;
    PFILE_TO_COPY pListEntry;
    PFILE_TO_COPY pLastEntry = NULL;

    UNREFERENCED_PARAMETER(DiskCount);

#if defined(REMOTE_BOOT)
    //
    // If TargetDevicePath is NULL, this file is destined for the system
    // partition on a diskless remote boot machine. In this case, we just
    // skip this file.
    //
    if (TargetDevicePath == NULL) {
        return FALSE;
    }
#endif // defined(REMOTE_BOOT)

    pDiskList = &DiskFileLists[DiskNumber];

    for(pListEntry=pDiskList->FileList; pListEntry; pListEntry=pListEntry->Next) {

        //
        // Remember the last entry in the list.
        //
        pLastEntry = pListEntry;

        if(!_wcsicmp(pListEntry->TargetFilename,TargetFilename)
        && !_wcsicmp(pListEntry->SourceFilename,SourceFilename)
        && !_wcsicmp(pListEntry->TargetDirectory,TargetDirectory)
        && !_wcsicmp(pListEntry->TargetDevicePath,TargetDevicePath)
        && (pListEntry->AbsoluteTargetDirectory == AbsoluteTargetDirectory)
//      && (   (pListEntry->CopyOptions == COPY_ALWAYS)
//          || (CopyOptions == COPY_ALWAYS)
//          || (CopyOptions == pListEntry->CopyOptions)
//         )
          )
        {
            //
            // Return code indicates that we did not add a new entry.
            //
            return(FALSE);
        }
    }

    //
    // File not already found; create new entry
    // and link into relevent disk's file list.
    //
    pListEntry = SpMemAlloc(sizeof(FILE_TO_COPY));

    pListEntry->SourceFilename          = SourceFilename;
    pListEntry->TargetDirectory         = TargetDirectory;
    pListEntry->TargetFilename          = TargetFilename;
    pListEntry->TargetDevicePath        = TargetDevicePath;
    pListEntry->AbsoluteTargetDirectory = AbsoluteTargetDirectory;
    pListEntry->Flags                   = CopyFlags;
    pListEntry->FileAttributes          = FileAttributes;

#if 0
    pListEntry->Next = pDiskList->FileList;
    pDiskList->FileList = pListEntry;
#else
    if( pLastEntry ) {
        pListEntry->Next = NULL;
        pLastEntry->Next = pListEntry;
    } else {
        pListEntry->Next = pDiskList->FileList;
        pDiskList->FileList = pListEntry;
    }
#endif // if 0

    pDiskList->FileCount++;

    //
    // Return code indicates that we added a new entry.
    //
    return(TRUE);
}


VOID
SpAddMasterFileSectionToCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           TargetDevicePath,
    IN PWSTR           AbsoluteTargetDirectory,
    IN ULONG           CopyOptionsIndex
    )

/*++

Routine Description:

    Adds files listed in a setup information master file section to the
    copy list.

    Each line in the section is expected to be in a standard format:

    [Section]
    <source_filename> = <disk_ordinal>,
                        <target_directory_shortname>,
                        <copy_options_for_upgrade>,
                        <copy_options_for_textmode>,
                        <rename_name>

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    TargetDevicePath - supplies the NT name of the device onto which the files
        are to be copied (ie, \device\harddisk1\partition2, etc).

    AbsoluteTargetDirectory - If specified, supplies the directory into which the files
        are to be copied on the target; overrides values specified on the lines
        in [<SectionName>].  This allows the caller to specify an absolute directory
        for the files instead of using indirection via a target directory shortname.

    CopyOptionsIndex -
        This specifies which index to look up to get the copy options field. If
        the field is not present it is assumed that this this file is not to
        be copied. Use:
           INDEX_UPGRADE   for upgrade copy options
           INDEX_WINNTFILE for fresh installation copy options

--*/

{
    ULONG Count,u,u1,CopyOptions;
    PWSTR CopyOptionsString, sourceFilename,targetFilename,targetDirSpec,mediaShortname,TargetDirectory;
    BOOLEAN  fAbsoluteTargetDirectory;
    PWSTR section;
    unsigned i;

    for(i=0; i<2; i++) {

        section = i
                ? SpMakePlatformSpecificSectionName(SIF_FILESONSETUPMEDIA)
                : SIF_FILESONSETUPMEDIA;

        //
        // Determine the number of files listed in the section.
        // This value may be zero.
        //
        Count = SpCountLinesInSection(SifHandle,section);
        if (fAbsoluteTargetDirectory = (AbsoluteTargetDirectory != NULL)) {
            TargetDirectory = AbsoluteTargetDirectory;
        }

        for(u=0; u<Count; u++) {

            //
            // Get the copy options using the index provided.  If the field
            // is not present, we don't need to add this to the copy list
            //
            CopyOptionsString = SpGetSectionLineIndex(SifHandle,section,u,CopyOptionsIndex);
            if((CopyOptionsString == NULL) || (*CopyOptionsString == 0)) {
                continue;
            }
            CopyOptions = (ULONG)SpStringToLong(CopyOptionsString,NULL,10);
            if(CopyOptions == COPY_NEVER) {
                continue;
            }

            //
            // get the source file name
            //
            sourceFilename = SpGetKeyName(SifHandle,section, u);

            if(!sourceFilename) {
                SpFatalSifError(SifHandle,section,NULL,u,0);
            }

            //
            // get the destination target dir spec
            //
            targetDirSpec  = SpGetSectionLineIndex(SifHandle,section,u,INDEX_DESTINATION);
            if(!targetDirSpec) {
                SpFatalSifError(SifHandle,section,NULL,u,INDEX_DESTINATION);
            }
            targetFilename = SpGetSectionLineIndex(SifHandle,section,u,INDEX_TARGETNAME);
            if(!targetFilename || !(*targetFilename)) {
                targetFilename = sourceFilename;
            }

            //
            // Look up the actual target directory if necessary.
            //
            if(!fAbsoluteTargetDirectory) {
                TargetDirectory = SpLookUpTargetDirectory(SifHandle,targetDirSpec);
            }

            //
            // get the media shortname
            //
            mediaShortname = SpGetSectionLineIndex(SifHandle,section,u,INDEX_WHICHMEDIA);
            if(!mediaShortname) {
                SpFatalSifError(SifHandle,section,NULL,u,INDEX_WHICHMEDIA);
            }

            //
            // Look up the disk in the disk file lists array.
            //
            for(u1=0; u1<DiskCount; u1++) {
                if(!_wcsicmp(mediaShortname,DiskFileLists[u1].MediaShortname)) {
                    break;
                }
            }

            //
            // If we didn't find the media descriptor, then it's invalid.
            //
            if(u1 == DiskCount) {
                SpFatalSifError(SifHandle,section,sourceFilename,0,INDEX_WHICHMEDIA);
            }

            //
            // Create a new file list entry if the file is not already being copied.
            //
            SpCreateEntryInCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                u1,
                sourceFilename,
                TargetDirectory,
                targetFilename,
                TargetDevicePath,
                fAbsoluteTargetDirectory,
                CopyOptions,
                FILE_ATTRIBUTES_NONE
                );
        }

        if(i) {
            SpMemFree(section);
        }
    }
}


VOID
SpAddSingleFileToCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           SifSection,
    IN PWSTR           SifKey,             OPTIONAL
    IN ULONG           SifLine,
    IN PWSTR           TargetDevicePath,
    IN PWSTR           TargetDirectory,    OPTIONAL
    IN ULONG           CopyOptions,
    IN BOOLEAN         CheckForNoComp,
    IN BOOLEAN         FileAttributesAvailable
    )

/*++

Routine Description:

    Adds a single file to the list of files to be copied.

    The file, along with the directory into which it is to be copied
    n the target and the name it is to receive on the target, is listed
    in a section in the setup information file.

    The filename is used to index the master file list to determine the
    source media where it resides.

    All this information is recorded in a structure associated with
    the disk on which the file resides.

    [SpecialFiles]
    mpkernel = ntkrnlmp.exe,4,ntoskrnl.exe
    upkernel = ntoskrnl.exe,4,ntoskrnl.exe
    etc.

    [MasterFileList]
    ntkrnlmp.exe = d2
    ntoskrnl.exe = d3
    etc.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    SifSection - supplies the name of the section that lists the file
        being added to the copy list.

    SifKey - if specified, supplies the keyname for the line in SifSection
        that lists the file to be added to the copy list.

    SifLine - if SifKey is not specified, this parameter supplies the 0-based
        line number of the line in SifSection that lists the file to be added
        to the copy list.

    TargetDevicePath - supplies the NT name of the device onto which the file
        is to be copied (ie, \device\harddisk1\partition2, etc).

    TargetDirectory - If specified, supplies the directory into which the file
        is to be copied on the target; overrides the value specified on the line
        in SifSection.  This allows the caller to specify an absolute directory
        for the file instead of using indirection.

    CopyOptions -
         COPY_ALWAYS              : always copied
         COPY_ONLY_IF_PRESENT     : copied only if present on the targetReturn Value:
         COPY_ONLY_IF_NOT_PRESENT : not copied if present on the target
         COPY_NEVER               : never copied                            None.

    CheckForNoComp - if true, check this file to see if it must remain uncompressed
        on an NTFS system partition supporting compression.
        If so, then OR the CopyOptions value with COPY_FORCENOCOMP.

    FileAttributesAvailable - Are the file attributes available in the sif file?
Return Value:

    None.

--*/

{
    PWSTR sourceFilename,targetDirSpec,targetFilename;
    ULONG u;
    PWSTR mediaShortname;
    BOOLEAN absoluteTargetDirectory;
    ULONG   FileAttributes = FILE_ATTRIBUTES_NONE;

    //
    // Get the source filename, target directory spec, and target filename.
    //
    if(SifKey) {

        sourceFilename = SpGetSectionKeyIndex(SifHandle,SifSection,SifKey,0);
        targetDirSpec  = SpGetSectionKeyIndex(SifHandle,SifSection,SifKey,1);
        targetFilename = SpGetSectionKeyIndex(SifHandle,SifSection,SifKey,2);

    } else {

        sourceFilename = SpGetSectionLineIndex(SifHandle,SifSection,SifLine,0);
        targetDirSpec  = SpGetSectionLineIndex(SifHandle,SifSection,SifLine,1);
        targetFilename = SpGetSectionLineIndex(SifHandle,SifSection,SifLine,2);
    }


    //
    // Validate source filename, target directory spec, and target filename.
    //
    if(!sourceFilename) {
        SpFatalSifError(SifHandle,SifSection,SifKey,SifLine,0);

        return;
    }

    if(!targetDirSpec) {
        SpFatalSifError(SifHandle,SifSection,SifKey,SifLine,1);

        return;
    }

    if(!targetFilename || 
        (UNICODE_NULL == targetFilename[0]) ||
        (!_wcsicmp(SifSection, L"SCSI.Load") &&
         !_wcsicmp(targetFilename,L"noload"))) {
        targetFilename = sourceFilename;
    }

    //
    // Look up the actual target directory if necessary.
    //
    if(TargetDirectory) {

        absoluteTargetDirectory = TRUE;

    } else {

        absoluteTargetDirectory = FALSE;
        TargetDirectory = SpLookUpTargetDirectory(SifHandle,targetDirSpec);
    }

    //
    // Look up FileAttributes from the inf files if we need to set some file attributes.
    //
    if (FileAttributesAvailable){
        FileAttributes =  SpInterpretFileAttributes(SifHandle,
                                                    SifSection,            
                                                    SifKey,
                                                    SifLine,
                                                    INDEX_FILE_ATTRIB);
    }
    
    //
    // Look up the file in the master file list to get
    // the media shortname of the disk where the file is located.
    //
    mediaShortname = SpLookUpValueForFile(SifHandle,sourceFilename,INDEX_WHICHMEDIA,TRUE);

    //
    // Look up the disk in the disk file lists array.
    //
    for(u=0; u<DiskCount; u++) {
        if(!_wcsicmp(mediaShortname,DiskFileLists[u].MediaShortname)) {
            break;
        }
    }

    //
    // If we didn't find the media descriptor, then it's invalid.
    //
    if(u == DiskCount) {
        SpFatalSifError(SifHandle,SIF_FILESONSETUPMEDIA,sourceFilename,0,INDEX_WHICHMEDIA);
    }

    //
    // If necessary, check to see whether this file cannot use NTFS compression. If it cannot,
    // then OR the CopyOptions with COPY_FORCENOCOMP.
    //
    if(CheckForNoComp && IsFileFlagSet(SifHandle,targetFilename,FILEFLG_FORCENOCOMP)) {

        CopyOptions |= COPY_FORCENOCOMP;
    }

    //
    // Create a new file list entry if the file is not already being copied.
    //
    SpCreateEntryInCopyList(
        SifHandle,
        DiskFileLists,
        DiskCount,
        u,
        sourceFilename,
        TargetDirectory,
        targetFilename,
        TargetDevicePath,
        absoluteTargetDirectory,
        CopyOptions,
        FileAttributes
        );
}


VOID
SpAddSectionFilesToCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           SectionName,
    IN PWSTR           TargetDevicePath,
    IN PWSTR           TargetDirectory,
    IN ULONG           CopyOptions,
    IN BOOLEAN         CheckForNoComp,
    IN BOOLEAN         FileAttributesAvailable
    )

/*++

Routine Description:

    Adds files listed in a setup information file section to the copy list.

    Each line in the section is expected to be in a standard format:

    [Section]
    <source_filename>,<target_directory_shortname>[,<target_filename>]

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    SectionName - supplies the name of the section that lists the files
        being added to the copy list.

    TargetDevicePath - supplies the NT name of the device onto which the files
        are to be copied (ie, \device\harddisk1\partition2, etc).

    TargetDirectory - If specified, supplies the directory into which the files
        are to be copied on the target; overrides values specified on the lines
        in [<SectionName>].  This allows the caller to specify an absolute directory
        for the files instead of using indirection via a target directory shortname.

    CopyOptions -
         COPY_ALWAYS              : always copied
         COPY_ONLY_IF_PRESENT     : copied only if present on the targetReturn Value:
         COPY_ONLY_IF_NOT_PRESENT : not copied if present on the target
         COPY_NEVER               : never copied

    CheckForNoComp - if true, then check each file to see if it must exist uncompressed
        on an NTFS partition supporting compression (ie, NTLDR on amd64/x86).

    FileAttributesAvailable - Are the file attributes available in the sif file?
--*/

{
    ULONG Count,u;

    //
    // Determine the number of files listed in the section.
    // This value may be zero.
    //
    Count = SpCountLinesInSection(SifHandle,SectionName);

    for(u=0; u<Count; u++) {

        //
        // Add this line to the copy list.
        //

        SpAddSingleFileToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SectionName,
            NULL,
            u,
            TargetDevicePath,
            TargetDirectory,
            CopyOptions,
            CheckForNoComp,
            FileAttributesAvailable
            );
    }
}

VOID
SpAddHalKrnlDetToCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           TargetDevicePath,
    IN PWSTR           SystemPartition,
    IN PWSTR           SystemPartitionDirectory,
    IN BOOLEAN         Uniprocessor
    )
/*++

Routine Description:

    Add the following files based on configuration:

    - the up or mp kernel.
    - the HAL
    - the detect module [amd64/x86 only]

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    TargetDevicePath - supplies the NT name of the device that will hold the
        nt tree.

    SystemPartition - supplies the NT name of the device that will hold the
        system partition.

    SystemPartitionDirectory - supplies the directory on the system partition
        into which files that go on the system partition will be copied.

    Uniprocessor - if true, then we are installing/upgrading a UP system.
        Note that this a different question than the number of processors
        in the system.

Return Value:

    None.

--*/

{
    PHARDWARE_COMPONENT pHw;

    //
    // Add the right kernel to the copy list.
    //
    SpAddSingleFileToCopyList(
        SifHandle,
        DiskFileLists,
        DiskCount,
        SIF_SPECIALFILES,
        Uniprocessor ? SIF_UPKERNEL : SIF_MPKERNEL,
        0,
        TargetDevicePath,
        NULL,
        COPY_ALWAYS,
        FALSE,
        FALSE
        );

#ifdef _X86_

    // Check to see if we should add the PAE kernel to the copy list.
    // Since some skus like pro/per don't have these kernels, they should not list them in the txtsetup.sif.

    if ( SpGetSectionKeyIndex(SifHandle,SIF_SPECIALFILES,Uniprocessor ? L"UPKrnlPa" : L"MPKrnlPa",0)) {
        //
        // Add the right PAE kernel to the copy list.
        //
        SpAddSingleFileToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SPECIALFILES,
            Uniprocessor ? L"UPKrnlPa" : L"MPKrnlPa",
            0,
            TargetDevicePath,
            NULL,
            COPY_ALWAYS,
            FALSE,
            FALSE
            );
    }
#endif // defined _X86_


    //
    // Add the hal to the file copy list.
    //
    if( !PreInstall ||
        (PreinstallHardwareComponents[HwComponentComputer] == NULL) ) {
        pHw = HardwareComponents[HwComponentComputer];
    } else {
        pHw = PreinstallHardwareComponents[HwComponentComputer];
    }
    if(!pHw->ThirdPartyOptionSelected) {
        SpAddSingleFileToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SIF_HAL,
                pHw->IdString,
                0,
                TargetDevicePath,
                NULL,
                COPY_ALWAYS,
                FALSE,
                FALSE
                );
    }

#if defined(_AMD64_) || defined(_X86_)

    if (SpIsArc()) {
        SpAddSingleFileToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_BOOTVID,
            pHw->IdString,
            0,
            TargetDevicePath,
            NULL,
            COPY_ALWAYS,
            FALSE,
            FALSE
            );
    }


    //
    // If a third party computer was not specified, then there will be a
    // detect module specified in the [ntdetect] section of the inf file
    // for the computer.
    // If a third-party computer was specified, then there may or may not
    // be a detect module.  If there is no detect module specified, then
    // copy the 'standard' one.
    //
    {
        PWSTR NtDetectId = NULL;

        if(!pHw->ThirdPartyOptionSelected) {
            NtDetectId = pHw->IdString;
        } else {
            if(!IS_FILETYPE_PRESENT(pHw->FileTypeBits,HwFileDetect)) {
                NtDetectId = SIF_STANDARD;
            }
        }

        if(NtDetectId) {
            SpAddSingleFileToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SIF_NTDETECT,
                NtDetectId,
                0,
                SystemPartition,
                SystemPartitionDirectory,
                COPY_ALWAYS,
                FALSE,
                FALSE
                );
        }
    }
#endif // defined(_AMD64_) || defined(_X86_)

}

VOID
SpAddBusExtendersToCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           TargetDevicePath
    )

/*++

Routine Description:

    Add to the copy list the bus extender related files and the mouse and keyboard related files,
    that are copied based on the configuration of the machine.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    TargetDevicePath - supplies the NT name of the device that will hold the
        nt tree.


Return Value:

    None.

--*/

{
    ULONG i;
    PHARDWARE_COMPONENT pHw;
    PWSTR SectionName;
    PHARDWARE_COMPONENT DeviceLists[] = {
                                        BootBusExtenders,
                                        BusExtenders,
                                        InputDevicesSupport
                                        };
    PWSTR   SectionNames[] = {
                             SIF_BOOTBUSEXTENDERS,
                             SIF_BUSEXTENDERS,
                             SIF_INPUTDEVICESSUPPORT
                             };


    //
    //  Add the bus extender and input device drivers to the copy list
    //
    for( i = 0; i < sizeof(DeviceLists) / sizeof(PDETECTED_DEVICE); i++ ) {
        for( pHw = DeviceLists[i]; pHw; pHw=pHw->Next) {

            //
            // Get the name of the section containing files for this device.
            //
            SectionName = SpGetSectionKeyIndex(
                                    SifHandle,
                                    SectionNames[i],
                                    pHw->IdString,
                                    INDEX_FILESECTION
                                    );

            if(!SectionName) {
                SpFatalSifError(
                    SifHandle,
                    SectionNames[i],
                    pHw->IdString,
                    0,
                    INDEX_FILESECTION
                    );

                return;  // for prefix
            }

            //
            // Add that section's files to the copy list.
            //
            SpAddSectionFilesToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SectionName,
                TargetDevicePath,
                NULL,
                COPY_ALWAYS,
                FALSE,
                FALSE
                );
        }
    }
}


VOID
SpAddConditionalFilesToCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           TargetDevicePath,
    IN PWSTR           SystemPartition,
    IN PWSTR           SystemPartitionDirectory,
    IN BOOLEAN         Uniprocessor
    )

/*++

Routine Description:

    Add files to the copy list that are copied based on the configuration
    of the machine and user selections.

    This may include:

    - the up or mp kernel.
    - abiosdsk
    - vga files [amd64/x86 only]
    - files for computer, keyboard, mouse, display, and layout
    - scsi miniport drivers
    - mouse and keyboard class drivers
    - the HAL
    - the detect module [amd64/x86 only]
    - bus extender drivers

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    TargetDevicePath - supplies the NT name of the device that will hold the
        nt tree.

    SystemPartition - supplies the NT name of the device that will hold the
        system partition.

    SystemPartitionDirectory - supplies the directory on the system partition
        into which files that go on the system partition will be copied.

    Uniprocessor - if true, then we are installing/upgrading a UP system.
        Note that this a different question than the number of processors
        in the system.

Return Value:

    None.

--*/

{
    ULONG i;
    PHARDWARE_COMPONENT pHw;
    PWSTR SectionName;

    //
    // Add the hal, kernel and ntdetect to the copy list
    //

    SpAddHalKrnlDetToCopyList(
        SifHandle,
        DiskFileLists,
        DiskCount,
        TargetDevicePath,
        SystemPartition,
        SystemPartitionDirectory,
        Uniprocessor
        );

    //
    // If there are any abios disks, copy the abios disk driver.
    //
    if(AbiosDisksExist) {

        SpAddSingleFileToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SPECIALFILES,
            SIF_ABIOSDISK,
            0,
            TargetDevicePath,
            NULL,
            COPY_ALWAYS,
            FALSE,
            FALSE
            );
    }

    //
    // Always copy vga files.
    //
    SpAddSectionFilesToCopyList(
        SifHandle,
        DiskFileLists,
        DiskCount,
        SIF_VGAFILES,
        TargetDevicePath,
        NULL,
        COPY_ALWAYS,
        FALSE,
        FALSE
        );

    //
    // Add the correct device driver files to the copy list.
    //
    for(i=0; i<HwComponentMax; i++) {

        //
        // Layout is handled elsewhere.
        //
        if(i == HwComponentLayout) {
            continue;
        }

        if( !PreInstall ||
            ( PreinstallHardwareComponents[i] == NULL ) ) {
            pHw = HardwareComponents[i];
        } else {
            pHw = PreinstallHardwareComponents[i];
        }

        for( ; pHw != NULL; pHw = pHw->Next ) {
            //
            // No files to copy here for third-party options.
            // This is handled elsewhere.
            //
            if(pHw->ThirdPartyOptionSelected) {
                continue;
            }

            //
            // Get the name of the section containing files for this device.
            //
            SectionName = SpGetSectionKeyIndex(
                                SifHandle,
                                NonlocalizedComponentNames[i],
                                pHw->IdString,
                                INDEX_FILESECTION
                                );

            if(!SectionName) {
                SpFatalSifError(
                    SifHandle,
                    NonlocalizedComponentNames[i],
                    pHw->IdString,
                    0,
                    INDEX_FILESECTION
                    );

                return; // for prefix
            }

            //
            // Add that section's files to the copy list.
            //
            SpAddSectionFilesToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SectionName,
                TargetDevicePath,
                NULL,
                COPY_ALWAYS,
                FALSE,
                FALSE
                );
        }
    }

    //
    // Add the keyboard layout dll to the copy list.
    //
    if( !PreInstall ||
        (PreinstallHardwareComponents[HwComponentLayout] == NULL) ) {
        pHw = HardwareComponents[HwComponentLayout];
    } else {
        pHw = PreinstallHardwareComponents[HwComponentLayout];
    }
    //
    if(!pHw->ThirdPartyOptionSelected) {

        SpAddSingleFileToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_KEYBOARDLAYOUTFILES,
            pHw->IdString,
            0,
            TargetDevicePath,
            NULL,
            COPY_ALWAYS,
            FALSE,
            FALSE
            );
    }

    //
    // Add scsi miniport drivers to the copy list.
    // Because miniport drivers are only a single file,
    // we just use the filename specified in [SCSI.Load] --
    // no need for separate [files.xxxx] sections.
    //
    if( !PreInstall ||
        ( PreinstallScsiHardware == NULL ) ) {
        pHw = ScsiHardware;
    } else {
        pHw = PreinstallScsiHardware;
    }
    for( ; pHw; pHw=pHw->Next) {
        if(!pHw->ThirdPartyOptionSelected) {

            SpAddSingleFileToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                L"SCSI.Load",
                pHw->IdString,
                0,
                TargetDevicePath,
                NULL,
                COPY_ALWAYS,
                FALSE,
                FALSE
                );
        }
    }

    SpAddBusExtendersToCopyList( SifHandle,
                                 DiskFileLists,
                                 DiskCount,
                                 TargetDevicePath );


#if 0
    //
    // If not being replaced by third-party ones, add keyboard and mouse
    // class drivers.
    // Note that in the pre-install case, keyboard and class drivers will
    // be added if at least one retail mouse or keyborad driver are
    // to be pre-installed.
    //
    if( !PreInstall ||
        ( PreinstallHardwareComponents[HwComponentMouse] == NULL ) ) {
        pHw=HardwareComponents[HwComponentMouse];
    } else {
        pHw=PreinstallHardwareComponents[HwComponentMouse];
    }
    for( ;pHw;pHw=pHw->Next ) {
        if(!pHw->ThirdPartyOptionSelected
        || !IS_FILETYPE_PRESENT(pHw->FileTypeBits,HwFileClass))
        {
            SpAddSingleFileToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SIF_SPECIALFILES,
                SIF_MOUSECLASS,
                0,
                TargetDevicePath,
                NULL,
                COPY_ALWAYS,
                FALSE
                );
            //
            //  We don't need to continue to look at the other mouse drivers
            //  since we have already added the class driver
            //
            break;
        }
    }

    if( !PreInstall ||
        ( PreinstallHardwareComponents[HwComponentKeyboard] == NULL ) ) {
        pHw=HardwareComponents[HwComponentKeyboard];
    } else {
        pHw=PreinstallHardwareComponents[HwComponentKeyboard];
    }
    for( ;pHw;pHw=pHw->Next ) {
        if(!pHw->ThirdPartyOptionSelected
        || !IS_FILETYPE_PRESENT(pHw->FileTypeBits,HwFileClass))
        {
            SpAddSingleFileToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SIF_SPECIALFILES,
                SIF_KEYBOARDCLASS,
                0,
                TargetDevicePath,
                NULL,
                COPY_ALWAYS,
                FALSE
                );
            //
            //  We don't need to continue to look at the other keyboard drivers
            //  since we have already added the class driver
            //
            break;
        }
    }
#endif // if 0

    if( ( HardwareComponents[HwComponentMouse] != NULL ) &&
        ( _wcsicmp( (HardwareComponents[HwComponentMouse])->IdString, L"none" ) != 0)
      ) {
        SpAddSingleFileToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SPECIALFILES,
            SIF_MOUSECLASS,
            0,
            TargetDevicePath,
            NULL,
            COPY_ALWAYS,
            FALSE,
            FALSE
            );
    }

    if( ( HardwareComponents[HwComponentKeyboard] != NULL) &&
        ( _wcsicmp( (HardwareComponents[HwComponentKeyboard])->IdString, L"none" ) != 0)
      ) {
            SpAddSingleFileToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SIF_SPECIALFILES,
                SIF_KEYBOARDCLASS,
                0,
                TargetDevicePath,
                NULL,
                COPY_ALWAYS,
                FALSE,
                FALSE
                );
    }

}


VOID
SpDontOverwriteMigratedDrivers (
    IN PWSTR           SysrootDevice,
    IN PWSTR           Sysroot,
    IN PWSTR           SyspartDevice,
    IN PWSTR           SyspartDirectory,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount
    )
{
    PLIST_ENTRY ListEntry;
    PSP_MIG_DRIVER_ENTRY MigEntry;

    while (!IsListEmpty(&MigratedDriversList)) {

        ListEntry = RemoveHeadList(&MigratedDriversList);
        MigEntry = CONTAINING_RECORD(ListEntry, SP_MIG_DRIVER_ENTRY, ListEntry);

        SpRemoveEntryFromCopyList (
            DiskFileLists,
            DiskCount,
            L"system32\\drivers",
            MigEntry->BaseDllName,
            SysrootDevice,
            FALSE
            );

        SpMemFree(MigEntry->BaseDllName);
        SpMemFree(MigEntry);
    }
}


VOID
SpCopyThirdPartyDrivers(
    IN PWSTR           SourceDevicePath,
    IN PWSTR           SysrootDevice,
    IN PWSTR           Sysroot,
    IN PWSTR           SyspartDevice,
    IN PWSTR           SyspartDirectory,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount
    )
{
    ULONG component;
    PHARDWARE_COMPONENT pHw;
    PHARDWARE_COMPONENT_FILE pHwFile;
    FILE_TO_COPY FileDescriptor;
    PWSTR TargetRoot;
    PWSTR InfNameBases[HwComponentMax+1] = { L"cpt", L"vio", L"kbd", L"lay", L"ptr", L"scs" };
    ULONG InfCounts[HwComponentMax+1] = { 0,0,0,0,0,0 };
    WCHAR InfFilename[20];
    ULONG CheckSum;
    BOOLEAN FileSkipped;
    ULONG TargetFileAttribs;
    ULONG CopyFlags;
    PWSTR OemDirPath;
    BOOLEAN OemDirExists;
    PWSTR NtOemSourceDevicePath;

    //
    //  Find out if the %SystemRoot%\OemDir exists. This directory will be needed if the third party drivers
    //  istalled contain a catalog.
    //
    OemDirPath = SpMemAlloc(ACTUAL_MAX_PATH * sizeof(WCHAR));
    wcscpy( OemDirPath, SysrootDevice );
    SpConcatenatePaths( OemDirPath, Sysroot );
    SpConcatenatePaths( OemDirPath, OemDirName );
    OemDirExists = SpFileExists( OemDirPath, TRUE );
    SpMemFree( OemDirPath );
    OemDirPath = NULL;

    for(component=0; component<=HwComponentMax; component++) {

        //
        // If we're upgrading, then we only want to copy third-party HALs or SCSI
        // drivers (if supplied)
        //
        if((NTUpgrade == UpgradeFull) &&
           !((component == HwComponentComputer) || (component == HwComponentMax))) {
            continue;
        }

        //
        // Handle scsi specially.
        //
        pHw = (component==HwComponentMax) ? ( ( !PreInstall ||
                                                ( PreinstallScsiHardware == NULL )
                                              )?
                                              ScsiHardware :
                                              PreinstallScsiHardware
                                            )
                                            :
                                            ( ( !PreInstall ||
                                                ( PreinstallHardwareComponents[component] == NULL )
                                              )?
                                              HardwareComponents[component] :
                                              PreinstallHardwareComponents[component]
                                            );

        //
        // Look at each instance of this component.
        //
        for( ; pHw; pHw=pHw->Next) {
            BOOLEAN CatalogIsPresent;
            BOOLEAN DynamicUpdateComponent = (IS_FILETYPE_PRESENT(pHw->FileTypeBits, HwFileDynUpdt) != 0);

            //
            // Skip this device if not a third-party selection.
            //
            if(!pHw->ThirdPartyOptionSelected) {
                continue;
            }

            //
            //  Create the OemDir if necessary
            //
            if( !OemDirExists ) {
                SpCreateDirectory( SysrootDevice,
                                   Sysroot,
                                   OemDirName,
                                   0,
                                   0 );
                OemDirExists = TRUE;
            }

            //
            //  Find out if a catalog was provided with this third party driver
            //
            for(CatalogIsPresent=FALSE, pHwFile=pHw->Files; pHwFile; pHwFile=pHwFile->Next) {
                if(pHwFile->FileType == HwFileCatalog) {
                    CatalogIsPresent = TRUE;
                    break;
                }
            }

            //
            // Loop through the list of files associated with this selection.
            //
            for(pHwFile=pHw->Files; pHwFile; pHwFile=pHwFile->Next) {
                //
                // Assume the file goes on the nt drive (as opposed to
                // the system partition drive) and that the target name
                // is the same as the source name.  Also, assume no special
                // attributes (ie, FILE_ATTRIBUTE_NORMAL)
                //
                FileDescriptor.Next             = NULL;
                FileDescriptor.SourceFilename   = pHwFile->Filename;
                FileDescriptor.TargetDevicePath = SysrootDevice;
                FileDescriptor.TargetFilename   = FileDescriptor.SourceFilename;
                FileDescriptor.Flags            = COPY_ALWAYS;
                FileDescriptor.AbsoluteTargetDirectory = FALSE;
                TargetFileAttribs = 0;
                NtOemSourceDevicePath = NULL;

                if (pHwFile->ArcDeviceName) {
                    NtOemSourceDevicePath = SpArcToNt(pHwFile->ArcDeviceName);
                }

                if (!NtOemSourceDevicePath) {
                    NtOemSourceDevicePath = SourceDevicePath;
                }


                switch(pHwFile->FileType) {


                //
                // Driver, port, and class type files are all device drivers
                // and are treated the same -- they get copied to the
                // system32\drivers directory.
                //
                case HwFileDriver:
                case HwFilePort:
                case HwFileClass:

                    TargetRoot = Sysroot;
                    FileDescriptor.TargetDirectory = L"system32\\drivers";
                    break;

                //
                // Dlls get copied to the system32 directory.
                //
                case HwFileDll:

                    TargetRoot = Sysroot;
                    FileDescriptor.TargetDirectory = L"system32";
                    break;

                //
                // Catalogs get copied to the OemDir directory.
                //
                case HwFileCatalog:

                    TargetRoot = Sysroot;
                    FileDescriptor.TargetDirectory = OemDirName;
                    break;

                //
                // Inf files get copied to the system32 directory and are
                // renamed based on the component.
                //
                case HwFileInf:

                    if(InfCounts[component] < 99) {

                        InfCounts[component]++;         // names start at 1

                        swprintf(
                            InfFilename,
                            L"oem%s%02d.inf",
                            InfNameBases[component],
                            InfCounts[component]
                            );

                        FileDescriptor.TargetFilename = InfFilename;
                    }

                    TargetRoot = Sysroot;
                    FileDescriptor.TargetDirectory = OemDirName;
                    break;

                //
                // Hal files are renamed to hal.dll and copied to the system32
                // directory
                //
                case HwFileHal:

                    TargetRoot = Sysroot;
                    FileDescriptor.TargetDirectory = L"system32";
                    FileDescriptor.TargetFilename = L"hal.dll";
                    break;

                //
                // Detect modules are renamed to ntdetect.com and copied to
                // the root of the system partition (C:).
                //
                case HwFileDetect:

                    TargetRoot = NULL;
                    FileDescriptor.TargetDevicePath = SyspartDevice;
                    FileDescriptor.TargetDirectory = SyspartDirectory;
                    FileDescriptor.TargetFilename = L"ntdetect.com";
                    TargetFileAttribs = FILE_ATTRIBUTES_RHS;
                    break;
                }

                if( !PreInstall && !DynamicUpdateComponent) {
                    //
                    // Prompt for the disk.
                    //
                    SpPromptForDisk(
                        pHwFile->DiskDescription,
                        NtOemSourceDevicePath,
                        pHwFile->DiskTagFile,
                        FALSE,                  // don't ignore disk in drive
                        FALSE,                  // don't allow escape
                        FALSE,                  // don't warn about multiple prompts
                        NULL                    // don't care about redraw flag
                        );
                }

                //
                // Passing the empty string as the first arg forces
                // the action area of the status line to be set up.
                // Not doing so results in the "Copying: xxxxx" to be
                // flush left on the status line instead of where
                // it belongs (flush right).
                //
                SpCopyFilesScreenRepaint(L"",NULL,TRUE);

                //
                // Copy the file.
                //
                SpCopyFileWithRetry(
                    &FileDescriptor,
                    NtOemSourceDevicePath,
                    (PreInstall) ? PreinstallOemSourcePath : pHwFile->Directory,
                    NULL,
                    TargetRoot,
                    TargetFileAttribs,
                    SpCopyFilesScreenRepaint,
                    &CheckSum,
                    &FileSkipped,
                    COPY_SOURCEISOEM
                    );

                //
                // Log the file
                //
                if( !FileSkipped ) {
                    //
                    //  Catalog files don't need to be logged, since they don't need to be repaired.
                    //
                    if ( pHwFile->FileType != HwFileCatalog ) {
                        SpLogOneFile( &FileDescriptor,
                                      TargetRoot,
                                      pHwFile->Directory,
                                      pHwFile->DiskDescription,
                                      pHwFile->DiskTagFile,
                                      CheckSum );
                    }

                    //
                    //  If a catalog is part of the third party driver being installed, then we need to copy
                    //  the file to OemDir also. Note that we don't copy the catalog to the OemDir directory,
                    //  since it was already copied.
                    //
                    if(pHwFile->FileType != HwFileCatalog){
                        //
                        // Save off original target directory.
                        //
                        PWSTR   SpOriginalTargetDir = FileDescriptor.TargetDirectory;                        
                        
                        FileDescriptor.TargetDirectory = OemDirName;

                        SpCopyFileWithRetry(
                            &FileDescriptor,
                            NtOemSourceDevicePath,
                            (PreInstall)? PreinstallOemSourcePath : pHwFile->Directory,
                            NULL,
                            TargetRoot,
                            TargetFileAttribs,
                            SpCopyFilesScreenRepaint,
                            &CheckSum,
                            &FileSkipped,
                            COPY_SOURCEISOEM
                        );

                        //
                        //  If this was an inf file then we need to remember its name
                        //
                        if( pHwFile->FileType == HwFileInf ) {
                            POEM_INF_FILE   p;

                            p = SpMemAlloc( sizeof(OEM_INF_FILE) );
                            p->InfName = SpDupStringW( FileDescriptor.TargetFilename );
                            p->Next = OemInfFileList;
                            OemInfFileList = p;
                        }
                        //
                        // Restore original target directory so as to remove the correct 
                        // entry from the file list to copy.
                        //
                        if (SpOriginalTargetDir){
                            FileDescriptor.TargetDirectory = SpOriginalTargetDir;
                            SpOriginalTargetDir = NULL;
                        }
                    }

                }
                //
                // Remove the file from the copy list so that it won't be overwritten
                //
                SpRemoveEntryFromCopyList( DiskFileLists,
                                           DiskCount,
                                           FileDescriptor.TargetDirectory,
                                           FileDescriptor.TargetFilename,
                                           FileDescriptor.TargetDevicePath,
                                           FileDescriptor.AbsoluteTargetDirectory );

            }
        }
    }
}


#if defined(_AMD64_) || defined(_X86_)
VOID
SpCopyNtbootddScreenRepaint(
    IN PWSTR   FullSourcename,      OPTIONAL
    IN PWSTR   FullTargetname,      OPTIONAL
    IN BOOLEAN RepaintEntireScreen
    )
{
    UNREFERENCED_PARAMETER(FullSourcename);
    UNREFERENCED_PARAMETER(FullTargetname);
    UNREFERENCED_PARAMETER(RepaintEntireScreen);

    //
    // Just put up a message indicating that we are setting up
    // boot params.
    //
    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_DOING_NTBOOTDD,DEFAULT_STATUS_ATTRIBUTE);
}
#endif // defined(_AMD64_) || defined(_X86_)

#if defined(_X86_) || defined(_AMD64_)
BOOLEAN
FindFalsexInt13Support(
    IN PVOID        SifHandle
    )

/*++

Routine Description:

    Go look through the devices installed and see if any match our
    list of known devices that may lie to us about their support for
    xInt13.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

Return Value:

    TRUE - We found a match.

    FALSE otherwise

--*/

{
    HARDWAREIDLIST     *MyHardwareIDList = HardwareIDList;

    while( MyHardwareIDList ) {
        if( MyHardwareIDList->HardwareID ) {
            if( SpGetSectionKeyExists(SifHandle, L"BadXInt13Devices", MyHardwareIDList->HardwareID) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: FindFalsexInt13Support: Found it.\n" ));
                return TRUE;
            }
        }

        MyHardwareIDList = MyHardwareIDList->Next;
    }
    return FALSE;
}


BOOL
SpUseBIOSToBoot(
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        NtPartitionDevicePath,
    IN PVOID        SifHandle
    )
/*++

Routine Description:

    Determine if we need a mini port driver to boot or if we can rely
    on the BIOS.


Arguments:

    NtPartitionRegion - supplies the region descriptor for the disk region
        onto which the user chose to install Windows NT.

    NtPartitionDevicePath - supplies the nt namespace pathname for the
        partition onto which the user chose to install Windows NT.

    SifHandle - supplies handle to loaded setup information file.

Return Value:

    TRUE - we can safely rely on the BIOS to boot.

    FALSE - we will need a mini port driver to boot.

--*/
{
    PDISK_SIGNATURE_INFORMATION DiskSignature;
    PWSTR p;

    if( ForceBIOSBoot ) {
        //
        // Either the user has asked us to force the use of the BIOS
        // to boot, or we've already manually checked and determined
        // that it's okay to use the BIOS.
        //
        return TRUE;
    }


    //
    // This may be the first time we've been called.  see if the user
    // wants us to force a BIOS boot.
    //
    p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,L"UseBIOSToBoot",0);
    if( p != NULL ) {
        //
        // The user wants us to use the BIOS.  Set our global and
        // get out of here.
        //
        ForceBIOSBoot = TRUE;
        return TRUE;
    }



    //
    // The NtPartitionDevicePath may or may not be available to the
    // caller.  If it isn't, then attempt to derive it from the
    // NtPartitionRegion.
    //
    if( NtPartitionDevicePath ) {
        p = SpNtToArc( NtPartitionDevicePath, PrimaryArcPath );
    } else {
        p = SpMemAlloc( (MAX_PATH*2) );
        if( p ) {
            SpArcNameFromRegion( NtPartitionRegion,
                                 p,
                                 (MAX_PATH*2),
                                 PartitionOrdinalOnDisk,
                                 PrimaryArcPath );
        }
    }

    if(p) {
        if( _wcsnicmp(p,L"multi(",6) == 0 ) {

            if( !SpIsRegionBeyondCylinder1024(NtPartitionRegion) ) {
                //
                // This region is very small, so we won't be needing
                // a miniport to boot.
                //
                ForceBIOSBoot = TRUE;
            } else {
                //
                // Hang on.  This disk is big, but it may support xint13.  In
                // that case we won't need a miniport.  Luckily, we have that
                // information stored away.
                //
                DiskSignature = DiskSignatureInformation;

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: About to search through the DiskSignatureInformation database for a device called %ws\n", p ));

                while( DiskSignature != NULL ) {

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: this DiskSignatureInformation entry is called %ws\n", DiskSignature->ArcPath ));

                    if( !_wcsnicmp( p, DiskSignature->ArcPath, wcslen(DiskSignature->ArcPath) ) ) {

                        //
                        // We found our disk.  Now just check his support for xint13.
                        //

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: I think they matched.\n" ));

                        if( DiskSignature->xInt13 ) {
                            //
                            // Yep, he's going to support xint13, so there's
                            // nothing for us to do here.
                            //

                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: I think he's got xInt13 support.\n" ));

                            //
                            // But it's possible that the BIOS has lied to us about his xInt13
                            // support.  We want to go check txtsetup.sif and see if this is a
                            // known controller that we don't support.
                            //
                            if( HardDisks[NtPartitionRegion->DiskNumber].Description[0] ) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: His description is: %ws\n", HardDisks[NtPartitionRegion->DiskNumber].Description ));
                            } else {
                                //
                                // Odd...  This guy doesn't have a description.
                                //
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: This device has no description!\n" ));
                            }


                            //
                            // Now go look in txtsetup.sif and see if this is listed as a device
                            // that I don't believe.
                            //

                            if( FindFalsexInt13Support(SifHandle) ) {
                                //
                                // We think this guy might be lying to us when he tells
                                // us that he supports xint13.  Assume that he really
                                // doesn't, which means we'll be using a miniport to
                                // boot.
                                //
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: This machine has a device that may erroneously indicate its xint13 support.\n" ));
                                break;
                            } else {

                                //
                                // This device isn't lised in the list that
                                // we don't believe, so assume that he
                                // really does have xint13 support.
                                //
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpCreateNtbootddSys: I trust this device when he tells me he has xint13 support.\n" ));

                                //
                                // Remember that we're going to use the BIOS to boot rather than
                                // a miniport.
                                //
                                ForceBIOSBoot = TRUE;
                                break;
                            }

                        } else {

                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: I don't think he has xInt13 support.\n" ));
                        }
                    } else {
                        //
                        // This isn't the right region.  Fall through and look at
                        // the next one.
                        //
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpUseBIOSToBoot: They didn't match.\n" ));
                    }

                    DiskSignature = DiskSignature->Next;
                }

            }

        }

        SpMemFree(p);

    }

    return ForceBIOSBoot;
}
#endif // defined(_X86_)

#if defined(_AMD64_) || defined(_X86_)
VOID
SpCreateNtbootddSys(
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        NtPartitionDevicePath,
    IN PWSTR        Sysroot,
    IN PWSTR        SystemPartitionDevicePath,
    IN PVOID        SifHandle,
    IN PWSTR        SourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Create c:\ntbootdd.sys if necessary.

    The scsi miniport driver file will be copied from the drivers directory
    (where it was copied during the earlier file copy phase) to c:\ntbootdd.sys.

    In the atapi case, the file ataboot.sys will be copied from the media to
    c:\ntbootdd.sys.

    NOTE: We're not going to support this on atapi devices anymore.  However,
    I'm leaving the code here in case we want to do it again later.  This code
    should execute early because I've modifed SpGetDiskInfo, so that
    ScsiMiniportShortname won't ever get set for atapi devices. -matth

Arguments:

    NtPartitionRegion - supplies the region descriptor for the disk region
        onto which the user chose to install Windows NT.

    NtPartitionDevicePath - supplies the nt namespace pathname for the
        partition onto which the user chose to install Windows NT.

    Sysroot - supplies the directory on the target partition.

    SystemPartitionDevicePath - supplies the nt device path of the partition
        onto which to copy ntbootdd.sys (ie, C:\).

    SifHandle - supplies handle to loaded setup information file.

    SourceDevicePath- Path to the device that contains the source.

    DirectoryOnSourceDevice - Supplies the directory on the source where
        the file is to be found.


Return Value:

    None.

--*/

{
    PWSTR MiniportDriverBasename;
    PWSTR MiniportDriverFilename;
    FILE_TO_COPY Descriptor;
    PWSTR DriversDirectory,p;
    ULONG CheckSum;
    BOOLEAN FileSkipped;
    ULONG CopyFlags;
    BOOLEAN IsAtapi = FALSE;

    //
    // no PC98 need NTBOOTDD.SYS.
    //
    if (IsNEC_98) {
        return;
    }

#if defined(REMOTE_BOOT)
    //
    // If the NT partition is on DiskNumber -1, this is a remote boot setup,
    // so there's nothing to do.
    //
    if (NtPartitionRegion->DiskNumber == 0xffffffff) {
        return;
    }
#endif // defined(REMOTE_BOOT)

    //
    // If the Nt Partition is not on a scsi disk, there's nothing to do.
    //
    MiniportDriverBasename = HardDisks[NtPartitionRegion->DiskNumber].ScsiMiniportShortname;
    if(*MiniportDriverBasename == 0) {
        return;
    }

    if( SpUseBIOSToBoot(NtPartitionRegion, NtPartitionDevicePath, SifHandle) ) {
        //
        // We can use the BIOS, so there's no reason to continue.
        //
        return;
    }

    IsAtapi = (_wcsicmp(MiniportDriverBasename,L"atapi") == 0);

    if( !IsAtapi ) {
        //
        // Form the name of the scsi miniport driver.
        //
        wcscpy(TemporaryBuffer,MiniportDriverBasename);
        wcscat(TemporaryBuffer,L".sys");
    } else {
        wcscpy(TemporaryBuffer,L"ataboot.sys");
    }
    MiniportDriverFilename = SpDupStringW(TemporaryBuffer);

    if( !IsAtapi ) {
        //
        // Form the full path to the drivers directory.
        //
        wcscpy(TemporaryBuffer,Sysroot);
        SpConcatenatePaths(TemporaryBuffer,L"system32\\drivers");
    } else {
        //
        // If it is atapi then make DriversDirectory point to the source media
        //

        PWSTR   MediaShortName;
        PWSTR   MediaDirectory;

        MediaShortName = SpLookUpValueForFile( SifHandle,
                                               MiniportDriverFilename,  // L"ataboot.sys",
                                               INDEX_WHICHMEDIA,
                                               TRUE );

        SpGetSourceMediaInfo(SifHandle,MediaShortName,NULL,NULL,&MediaDirectory);

        wcscpy(TemporaryBuffer,DirectoryOnSourceDevice);
        SpConcatenatePaths(TemporaryBuffer,MediaDirectory);
    }
    DriversDirectory = SpDupStringW(TemporaryBuffer);

    //
    //
    // Fill in the fields of the file descriptor.
    //
    Descriptor.SourceFilename   = MiniportDriverFilename;
    Descriptor.TargetDevicePath = SystemPartitionDevicePath;
    Descriptor.TargetDirectory  = L"";
    Descriptor.TargetFilename   = L"NTBOOTDD.SYS";
    Descriptor.Flags            = COPY_ALWAYS;

    CopyFlags = 0;
    if(!WIN9X_OR_NT_UPGRADE || IsFileFlagSet(SifHandle,Descriptor.TargetFilename,FILEFLG_NOVERSIONCHECK)) {
        CopyFlags |= COPY_NOVERSIONCHECK;
    }

    //
    // Copy the file.
    //
    SpCopyFileWithRetry(
        &Descriptor,
        (IsAtapi) ? SourceDevicePath : NtPartitionDevicePath,
        DriversDirectory,
        NULL,
        NULL,
        FILE_ATTRIBUTES_RHS,
        SpCopyNtbootddScreenRepaint,
        &CheckSum,
        &FileSkipped,
        CopyFlags
        );

    //
    // Log the file
    //
    if( !FileSkipped ) {
        SpLogOneFile( &Descriptor,
                      Sysroot,
                      NULL,
                      NULL,
                      NULL,
                      CheckSum );
    }

    //
    // Clean up.
    //
    SpMemFree(MiniportDriverFilename);
    SpMemFree(DriversDirectory);
}
#endif // defined(_AMD64_) || defined(_X86_)

VOID
SpCopyFiles(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PWSTR        SystemPartitionDirectory,
    IN PWSTR        SourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    IN PWSTR        ThirdPartySourceDevicePath
    )
{
    PDISK_FILE_LIST DiskFileLists;
    ULONG   DiskCount;
    PWSTR   NtPartition,SystemPartition;
    PWSTR   p;
    BOOLEAN Uniprocessor;
    ULONG n;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NtPartitionString;
    IO_STATUS_BLOCK IoStatusBlock;
    INCOMPATIBLE_FILE_LIST IncompatibleFileListHead;

    CLEAR_CLIENT_SCREEN();

    Uniprocessor = !SpInstallingMp();

    //
    // open a handle to the driver inf file
    //
    SpInitializeDriverInf(SifHandle,
                          SourceDevicePath,
                          DirectoryOnSourceDevice);

    //
    // initialize alternate sources (if any)
    //
    SpInitAlternateSource ();

    //
    // Skip copying if directed to do so in the setup information file.
    //
    if((p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_DONTCOPY,0))
    && SpStringToLong(p,NULL,10))
    {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: DontCopy flag is set in .sif; skipping file copying\n"));
        return;
    }

    //
    // Initialize the diamond decompression engine. In the remote boot
    // case this will already have been initialized.
    //
    if (!RemoteInstallSetup) {
        SpdInitialize();
    }

    //
    // Get the device path of the nt partition.
    //
    SpNtNameFromRegion(
        NtPartitionRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    NtPartition = SpDupStringW(TemporaryBuffer);

    //
    // Get the device path of the system partition.
    //
    if (SystemPartitionRegion != NULL) {
        SpNtNameFromRegion(
            SystemPartitionRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );

        SystemPartition = SpDupStringW(TemporaryBuffer);
    } else {
        SystemPartition = NULL;
    }

    //
    // Create the system partition directory.
    //
    if (SystemPartition != NULL) {
        SpCreateDirectory(SystemPartition,NULL,SystemPartitionDirectory,0,0);
#ifdef _IA64_
        {
        PWSTR SubDirPath = SpGetSectionKeyIndex(
                                SifHandle,
                                L"SetupData",
                                L"EfiUtilPath",
                                0
                                );

        SpCreateDirectory(SystemPartition,NULL,SubDirPath,0,0);

        }

#endif // defined _IA64_
    }

    //
    // Create the nt tree.
    //
    SpCreateDirectoryStructureFromSif(SifHandle,SIF_NTDIRECTORIES,NtPartition,Sysroot);

    //
    // We may be installing into an old tree, so delete all files
    // in the system32\config subdirectory (unless we're upgrading).
    //
    if(NTUpgrade != UpgradeFull) {

        wcscpy(TemporaryBuffer, NtPartition);
        SpConcatenatePaths(TemporaryBuffer, Sysroot);
        SpConcatenatePaths(TemporaryBuffer, L"system32\\config");
        p = SpDupStringW(TemporaryBuffer);

        //
        // Enumerate and delete all files in system32\config subdirectory.
        //
        SpEnumFiles(p, SpDelEnumFile, &n, NULL);

        SpMemFree(p);
    } else {
        //
        // We go off and try to load the setup.log file for the
        // installation we're about to upgrade.  We do this because we
        // need to transfer any loggged OEM files to our new setup.log.
        // Otherwise, these entries would be lost in our new log file,
        // and we would have an unrepairable installation if the OEM files
        // lost were vital for booting.
        //

        ULONG    RootDirLength;
        NTSTATUS Status;
        PVOID    Inf;

        //
        //  We first find out if the repair directory exists.  If it does exist
        //  load setup.log from the repair directory. Otherwise, load setup.log
        //  from the WinNt directory
        //
        wcscpy(TemporaryBuffer, NtPartition);
        SpConcatenatePaths(TemporaryBuffer, Sysroot);
        RootDirLength = wcslen(TemporaryBuffer);

        SpConcatenatePaths(TemporaryBuffer, SETUP_REPAIR_DIRECTORY);
        SpConcatenatePaths(TemporaryBuffer, SETUP_LOG_FILENAME);

        if(!SpFileExists(TemporaryBuffer, FALSE)) {
            (TemporaryBuffer)[RootDirLength] = UNICODE_NULL;
            SpConcatenatePaths(TemporaryBuffer, SETUP_LOG_FILENAME);
        }

        p = SpDupStringW(TemporaryBuffer);

        //
        // Attempt to load old setup.log.  If we can't, it's no big deal,  We just
        // won't have any old logged OEM files to merge in.
        //
        Status = SpLoadSetupTextFile(p, NULL, 0, &Inf, &n, TRUE, FALSE);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpCopyFiles: can't load old setup.log (%lx)\n", Status));
        } else {
            //
            // We found setup.log, so go and pull out anything pertinent.
            //
            _LoggedOemFiles = SppRetrieveLoggedOemFiles(Inf);
            SpFreeTextFile(Inf);
        }
        SpMemFree(p);

        //
        // Prepare fonts for upgrade.
        //
        wcscpy(TemporaryBuffer,NtPartition);
        SpConcatenatePaths(TemporaryBuffer,Sysroot);
        SpConcatenatePaths(TemporaryBuffer,L"SYSTEM");

        p = SpDupStringW(TemporaryBuffer);
        SpPrepareFontsForUpgrade(p);
        SpMemFree(p);
    }

    SpDisplayStatusText(SP_STAT_BUILDING_COPYLIST,DEFAULT_STATUS_ATTRIBUTE);

    //
    //  Create the buffer for the log file.
    //
    _SetupLogFile = SpNewSetupTextFile();
    if( _SetupLogFile == NULL ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create buffer for setup.log \n"));
    }

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot setup, open the root of the NT partition
    // so that single-instance store links may be created instead of
    // copying files.
    //

    SisRootHandle = NULL;

    if (RemoteBootSetup) {

        RtlInitUnicodeString( &NtPartitionString, NtPartition );
        InitializeObjectAttributes(
            &ObjectAttributes,
            &NtPartitionString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);
        Status = ZwCreateFile(
                    &SisRootHandle,
                    GENERIC_READ,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,
                    0,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    OPEN_EXISTING,
                    0,
                    NULL,
                    0);

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SpCopyFiles: Unable to open SIS volume %ws: %x\n", NtPartition, Status ));
            SisRootHandle = NULL;
        }
    }
#endif // defined(REMOTE_BOOT)

    //
    // Generate media descriptors for the source media.
    //
    SpInitializeFileLists(
        SifHandle,
        &DiskFileLists,
        &DiskCount
        );

    //
    // And gather the list of files deemed 'incompatible' during
    // winnt32, if any
    //
    if ( WinntSifHandle != NULL ) {

        //
        // We'll do this for fun because we have to.
        //
        SpInitializeCompatibilityOverwriteLists(
            WinntSifHandle,
            &IncompatibleFileListHead
            );

    }

    if(NTUpgrade != UpgradeFull) {

        SpAddMasterFileSectionToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            NtPartition,
            NULL,
            INDEX_WINNTFILE
            );

        //
        // Add the section of system partition files that are always copied.
        //
        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SYSPARTCOPYALWAYS,
            SystemPartition,
            SystemPartitionDirectory,
            COPY_ALWAYS,
            (BOOLEAN)(SystemPartitionRegion->Filesystem == FilesystemNtfs),
            FALSE
            );

#ifdef _IA64_
        {
        PWSTR SubDirPath;
        //
        // Add the section of system partition root files that are always copied.
        //
        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SYSPARTROOT,
            SystemPartition,
            L"\\",
            COPY_ALWAYS,
            (BOOLEAN)(SystemPartitionRegion->Filesystem == FilesystemNtfs),
            FALSE
            );

        //
        // Add the section of system partition utility files that are always copied.
        //
        SubDirPath = SpGetSectionKeyIndex(
                            SifHandle,
                            L"SetupData",
                            L"EfiUtilPath",
                            0
                            );

        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SYSPARTUTIL,
            SystemPartition,
            SubDirPath,
            COPY_ALWAYS,
            (BOOLEAN)(SystemPartitionRegion->Filesystem == FilesystemNtfs),
            TRUE
            );
        }
#endif // defined _IA64_

        //
        // Add conditional files to the copy list.
        //
        SpAddConditionalFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            NtPartition,
            SystemPartition,
            SystemPartitionDirectory,
            Uniprocessor
            );

    }
    else {

        PHARDWARE_COMPONENT pHw;

        //
        // Add the section of system partition files that are always copied.
        //
        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SYSPARTCOPYALWAYS,
            SystemPartition,
            SystemPartitionDirectory,
            COPY_ALWAYS,
            (BOOLEAN)(SystemPartitionRegion->Filesystem == FilesystemNtfs),
            FALSE
            );

#ifdef _IA64_
        {
        PWSTR SubDirPath;
        //
        // Add the section of system partition root files that are always copied.
        //
        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SYSPARTROOT,
            SystemPartition,
            L"\\",
            COPY_ALWAYS,
            (BOOLEAN)(SystemPartitionRegion->Filesystem == FilesystemNtfs),
            FALSE
            );

        //
        // Add the section of system partition utility files that are always copied.
        //
        SubDirPath = SpGetSectionKeyIndex(
                            SifHandle,
                            L"SetupData",
                            L"EfiUtilPath",
                            0
                            );

        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_SYSPARTUTIL,
            SystemPartition,
            SubDirPath,
            COPY_ALWAYS,
            (BOOLEAN)(SystemPartitionRegion->Filesystem == FilesystemNtfs),
            TRUE
            );
        }
#endif // defined _IA64_


        //
        // Add the detected scsi miniport drivers to the copy list.
        // Note that they are always copied to the target.
        // These files have to be added to the copy list, before the ones marked
        // as COPY_ONLY_IF_PRESENT. This is because in most cases, these files
        // will be listed in [Files] with COPY_ONLY_IF_PRESENT set, and the
        // function that creates entries in the copy list, will not create more
        // than one entry for the same file. So if we add the file to the copy
        // list, with COPY_ONLY_IF_PRESENT, there will be no way to replace
        // or overwrite this entry in the list, and the file will end up not
        // being copied.
        //
        // we just use the filename specified in [SCSI.Load] --
        // no need for separate [files.xxxx] sections.
        //
        if( !PreInstall ||
            ( PreinstallScsiHardware == NULL ) ) {
            pHw = ScsiHardware;
        } else {
            pHw = PreinstallScsiHardware;
        }
        for( ; pHw; pHw=pHw->Next) {
            if(!pHw->ThirdPartyOptionSelected) {

                SpAddSingleFileToCopyList(
                    SifHandle,
                    DiskFileLists,
                    DiskCount,
                    L"SCSI.Load",
                    pHw->IdString,
                    0,
                    NtPartition,
                    NULL,
                    COPY_ALWAYS,
                    FALSE,
                    FALSE
                    );
            }
        }

        //
        //  Add the bus extender drivers to the copy list
        //
        SpAddBusExtendersToCopyList( SifHandle,
                                     DiskFileLists,
                                     DiskCount,
                                     NtPartition );



        //
        // Add the files in the master file list with the copy options
        // specified in each line on the INDEX_UPGRADE index. The options
        // specify whether the file is to be copied at all or copied always
        // or copied only if there on the target or not copied if there on
        // the target.
        //

        SpAddMasterFileSectionToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            NtPartition,
            NULL,
            INDEX_UPGRADE
            );

        //
        // Add the section of files that are upgraded only if it is not
        // a Win31 upgrade
        //

        if(WinUpgradeType != UpgradeWin31) {
            SpAddSectionFilesToCopyList(
                SifHandle,
                DiskFileLists,
                DiskCount,
                SIF_FILESUPGRADEWIN31,
                NtPartition,
                NULL,
                COPY_ALWAYS,
                FALSE,
                FALSE
                );
        }

        //
        // Add the files for kernel, hal and detect module, these are
        // handled specially because they involve renamed files (it is
        // not possible to find out just by looking at the target file
        // how to upgrade it).
        // NOTE: This does not handle third-party HAL's (they get copied
        // by SpCopyThirdPartyDrivers() below).
        //

        SpAddHalKrnlDetToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            NtPartition,
            SystemPartition,
            SystemPartitionDirectory,
            Uniprocessor
            );

        //
        // Add the new hive files so that our config stuff can get at them
        // to extract new configuration information.  These new hive files
        // are renamed on the target so that they don't overwrite the
        // existing hives.

        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_FILESNEWHIVES,
            NtPartition,
            NULL,
            COPY_ALWAYS,
            FALSE,
            FALSE
            );

        //
        // Copy third-party migrated drivers.
        // The driver files are actually already in place (since it's an upgrade)
        // but the function makes sure they are not overwriten with inbox drivers
        // if there's a filename collision
        //
        SpDontOverwriteMigratedDrivers (
            NtPartition,
            Sysroot,
            SystemPartition,
            SystemPartitionDirectory,
            DiskFileLists,
            DiskCount
            );

    }

#if defined(REMOTE_BOOT)
    //
    // If remote booting, add the [Files.RemoteBoot] section.
    //

    if (RemoteBootSetup) {
        SpAddSectionFilesToCopyList(
            SifHandle,
            DiskFileLists,
            DiskCount,
            SIF_REMOTEBOOTFILES,
            NtPartition,
            NULL,
            COPY_ALWAYS,
            FALSE,
            FALSE
            );
    }
#endif // defined(REMOTE_BOOT)

    //
    // Copy third-party files.
    // We do this here just in case there is some error in the setup information
    // file -- we'd have caught it by now, before we start copying files to the
    // user's hard drive.
    // NOTE: SpCopyThirdPartyDrivers has a check to make sure it only copies the
    // HAL and PAL if we're in an upgrade (in which case, we want to leave the other
    // drivers alone).
    //
    SpCopyThirdPartyDrivers(
        ThirdPartySourceDevicePath,
        NtPartition,
        Sysroot,
        SystemPartition,
        SystemPartitionDirectory,
        DiskFileLists,
        DiskCount
        );

#if 0
    KdPrintEx( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ("SETUP: Sysroot = %ls \n", Sysroot ) );
    KdPrintEx( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ("SETUP: SystemPartitionDirectory = %ls \n", SystemPartitionDirectory ));
    KdPrintEx( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ("SETUP: SourceDevicePath = %ls \n", SourceDevicePath ));
    KdPrintEx( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ("SETUP: DirectoryOnSourceDevice = %ls \n", DirectoryOnSourceDevice ));
    KdPrintEx( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ("SETUP: ThirdPartySourceDevicePath = %ls \n", ThirdPartySourceDevicePath ));
//    SpCreateSetupLogFile( DiskFileLists, DiskCount, NtPartitionRegion, Sysroot, DirectoryOnSourceDevice );
#endif // if 0

    //
    // Copy files in the copy list.
    //
    SpCopyFilesInCopyList(
        SifHandle,
        DiskFileLists,
        DiskCount,
        SourceDevicePath,
        DirectoryOnSourceDevice,
        Sysroot,
        &IncompatibleFileListHead
        );

    //
    // extract asms*.cab
    //
    SpExtractAssemblyCabinets(
        SifHandle,
        SourceDevicePath,
        DirectoryOnSourceDevice,
        NtPartition,
        Sysroot
        );

#if defined(_AMD64_) || defined(_X86_)
    if(!SpIsArc()) {
        //
        // Take care of ntbootdd.sys.
        //
        SpCreateNtbootddSys(
            NtPartitionRegion,
            NtPartition,
            Sysroot,
            SystemPartition,
            SifHandle,
            SourceDevicePath,
            DirectoryOnSourceDevice
            );


        //
        // Now get rid of x86-ARC turd files that
        // we won't need (because we're not on an
        // arc machine.
        //

#if defined(_X86_)
        wcscpy( TemporaryBuffer, NtBootDevicePath );
        SpDeleteFile( TemporaryBuffer, L"arcsetup.exe", NULL );
        wcscpy( TemporaryBuffer, NtBootDevicePath );
        SpDeleteFile( TemporaryBuffer, L"arcldr.exe", NULL );
#endif // defined(_X86_)

    }
#endif // defined(_AMD64_) || defined(_X86_)

    if( PreInstall ) {
        SppCopyOemDirectories( SourceDevicePath,
                               NtPartition,
                               Sysroot );
    }

    //
    //  Create the log file in disk
    //
    if( _SetupLogFile != NULL ) {

        PWSTR   p;
        PWSTR   TempName;
        PWSTR   Values[] = {
                           SIF_NEW_REPAIR_NT_VERSION
                           };

        //
        // Merge in the OEM files retrived from the previous setup.log
        //
        if(_LoggedOemFiles) {
            SppMergeLoggedOemFiles(_SetupLogFile,
                                   _LoggedOemFiles,
                                   SystemPartition,
                                   ( *SystemPartitionDirectory != (WCHAR)'\0' )? SystemPartitionDirectory :
                                                                  ( PWSTR )L"\\",
                                   NtPartition );
            SpFreeTextFile(_LoggedOemFiles);
        }

        //
        //  Add signature
        //
        SpAddLineToSection( _SetupLogFile,
                            SIF_NEW_REPAIR_SIGNATURE,
                            SIF_NEW_REPAIR_VERSION_KEY,
                            Values,
                            1 );

        //
        // Add section that contains the paths
        //

        Values[0] = SystemPartition;
        SpAddLineToSection( _SetupLogFile,
                            SIF_NEW_REPAIR_PATHS,
                            SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DEVICE,
                            Values,
                            1 );

        Values[0] = ( *SystemPartitionDirectory != (WCHAR)'\0' )? SystemPartitionDirectory :
                                                                  ( PWSTR )L"\\";
        SpAddLineToSection( _SetupLogFile,
                            SIF_NEW_REPAIR_PATHS,
                            SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DIRECTORY,
                            Values,
                            1 );

        Values[0] = NtPartition;
        SpAddLineToSection( _SetupLogFile,
                            SIF_NEW_REPAIR_PATHS,
                            SIF_NEW_REPAIR_PATHS_TARGET_DEVICE,
                            Values,
                            1 );

        Values[0] = Sysroot;
        SpAddLineToSection( _SetupLogFile,
                            SIF_NEW_REPAIR_PATHS,
                            SIF_NEW_REPAIR_PATHS_TARGET_DIRECTORY,
                            Values,
                            1 );

        //
        // Flush to disk
        //
        TempName = SpMemAlloc( ( wcslen( SETUP_REPAIR_DIRECTORY ) + 1 +
                                 wcslen( SETUP_LOG_FILENAME ) + 1 ) * sizeof( WCHAR ) );
        wcscpy( TempName, SETUP_REPAIR_DIRECTORY );
        SpConcatenatePaths(TempName, SETUP_LOG_FILENAME );
        SpWriteSetupTextFile(_SetupLogFile,NtPartition,Sysroot,TempName);
        SpMemFree( TempName );
        SpFreeTextFile( _SetupLogFile );
        _SetupLogFile = NULL;
    }

    //
    // Free the media descriptors.
    //
    SpFreeCopyLists(&DiskFileLists,DiskCount);

    //
    // Free incompatible file lists
    //
    if ( IncompatibleFileListHead.EntryCount ) {

        SpFreeIncompatibleFileList(&IncompatibleFileListHead);

    }

    SpMemFree(NtPartition);
    if (SystemPartition != NULL) {
        SpMemFree(SystemPartition);
    }

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot setup, close the root of the NT partition.
    //

    if (SisRootHandle != NULL) {
        ZwClose(SisRootHandle);
        SisRootHandle = NULL;
    }
#endif // defined(REMOTE_BOOT)

    //
    // Terminate diamond.
    //
    SpdTerminate();
    SpUninitAlternateSource ();
}




VOID
SppDeleteDirectoriesInSection(
    IN PVOID SifHandle,
    IN PWSTR SifSection,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR Sysroot
    )

/*++

Routine Description:

    This routine enumerates files listed in the given section and deletes
    them from the system tree.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SifSection  - section containing files to delete

    NtPartitionRegion - region descriptor for volume on which nt resides.

    Sysroot - root directory for nt.



Return Value:

    None.

--*/

{
    ULONG Count,u;
    PWSTR RelativePath, DirOrdinal, TargetDir, NtDir, DirPath;
    NTSTATUS Status;


    CLEAR_CLIENT_SCREEN();


    //
    // Determine the number of files listed in the section.
    // This value may be zero.
    //
    Count = SpCountLinesInSection(SifHandle,SifSection);

    for(u=0; u<Count; u++) {
        DirOrdinal = SpGetSectionLineIndex(SifHandle, SifSection, u, 0);
        RelativePath = SpGetSectionLineIndex(SifHandle, SifSection, u, 1);

        //
        // Validate the filename and dirordinal
        //
        if(!DirOrdinal) {
            SpFatalSifError(SifHandle,SifSection,NULL,u,0);
        }
        if(!RelativePath) {
            SpFatalSifError(SifHandle,SifSection,NULL,u,1);
        }

        //
        // use the dirordinal key to get the path relative to sysroot of the
        // directory the file is in
        //

        DirPath = SpLookUpTargetDirectory(SifHandle,DirOrdinal);

        wcscpy( TemporaryBuffer, Sysroot );
        SpConcatenatePaths( TemporaryBuffer, DirPath );
        SpConcatenatePaths( TemporaryBuffer, RelativePath );

        TargetDir = SpDupStringW( TemporaryBuffer );

        //
        // display status bar
        //
        if( !HeadlessTerminalConnected ) {
            SpDisplayStatusText(SP_STAT_DELETING_FILE,DEFAULT_STATUS_ATTRIBUTE, TargetDir);
        } else {

            PWCHAR TempPtr = NULL;
            //
            // If we're headless, we need to be careful about displaying very long
            // file/directory names.  For that reason, just display a little spinner.
            //
            switch( u % 4) {
            case 0:
                TempPtr = L"-";
                break;
            case 1:
                TempPtr = L"\\";
                break;
            case 2:
                TempPtr = L"|";
                break;
            default:
                TempPtr = L"/";
                break;

            }

            SpDisplayStatusText(SP_STAT_DELETING_FILE,DEFAULT_STATUS_ATTRIBUTE, TempPtr);

        }

        //
        // delete the directory
        //
        SpDeleteExistingTargetDir(NtPartitionRegion, TargetDir, FALSE, 0);
        SpMemFree(TargetDir);

    }

}



VOID
SppDeleteFilesInSection(
    IN PVOID SifHandle,
    IN PWSTR SifSection,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR Sysroot
    )

/*++

Routine Description:

    This routine enumerates files listed in the given section and deletes
    them from the system tree.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SifSection  - section containing files to delete

    NtPartitionRegion - region descriptor for volume on which nt resides.

    Sysroot - root directory for nt.



Return Value:

    None.

--*/

{
    ULONG Count,u;
    PWSTR filename, dirordinal, targetdir, ntdir;
    NTSTATUS Status;


    CLEAR_CLIENT_SCREEN();

    //
    // Get the device path of the nt partition.
    //
    SpNtNameFromRegion(
        NtPartitionRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    SpConcatenatePaths(TemporaryBuffer,Sysroot);
    ntdir = SpDupStringW(TemporaryBuffer);

    //
    // Determine the number of files listed in the section.
    // This value may be zero.
    //
    Count = SpCountLinesInSection(SifHandle,SifSection);

    for(u=0; u<Count; u++) {
        filename   = SpGetSectionLineIndex(SifHandle, SifSection, u, 0);
        dirordinal = SpGetSectionLineIndex(SifHandle, SifSection, u, 1);

        //
        // Validate the filename and dirordinal
        //
        if(!filename) {
            SpFatalSifError(SifHandle,SifSection,NULL,u,0);
        }
        if(!dirordinal) {
            SpFatalSifError(SifHandle,SifSection,NULL,u,1);
        }

        //
        // use the dirordinal key to get the path relative to sysroot of the
        // directory the file is in
        //
        targetdir = SpLookUpTargetDirectory(SifHandle,dirordinal);

        //
        // display status bar
        //
        if( !HeadlessTerminalConnected ) {
            SpDisplayStatusText(SP_STAT_DELETING_FILE,DEFAULT_STATUS_ATTRIBUTE, filename);
        } else {

            PWCHAR TempPtr = NULL;
            //
            // If we're headless, we need to be careful about displaying very long
            // file/directory names.  For that reason, just display a little spinner.
            //
            switch( u % 4) {
            case 0:
                TempPtr = L"-";
                break;
            case 1:
                TempPtr = L"\\";
                break;
            case 2:
                TempPtr = L"|";
                break;
            default:
                TempPtr = L"/";
                break;

            }

            SpDisplayStatusText(SP_STAT_DELETING_FILE,DEFAULT_STATUS_ATTRIBUTE, TempPtr);

        }

        //
        // delete the file
        //
        while(TRUE) {
            Status = SpDeleteFile(ntdir, targetdir, filename);
            if(!NT_SUCCESS(Status)
                && Status != STATUS_OBJECT_NAME_NOT_FOUND
                && Status != STATUS_OBJECT_PATH_NOT_FOUND
                ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to delete file %ws (%lx)\n",filename, Status));
                //
                // We can ignore this error since this just means that we have
                // less free space on the hard disk.  It is not critical for
                // install.
                //
                if(!SpNonCriticalError(SifHandle, SP_SCRN_DELETE_FAILED, filename, NULL)) {
                    break;
                }
            }
            else {
                break;
            }
        }
    }
    SpMemFree(ntdir);
}















VOID
SppBackupFilesInSection(
    IN PVOID SifHandle,
    IN PWSTR SifSection,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR Sysroot
    )

/*++

Routine Description:

    This routine enumerates files listed in the given section and deletes
    backs them up in the given NT tree if found by renaming.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    SifSection  - section containing files to backup

    NtPartitionRegion - region descriptor for volume on which nt resides.

    Sysroot - root directory for nt.



Return Value:

    None.

--*/

{
    ULONG Count,u;
    PWSTR filename, dirordinal, backupfile, targetdir, ntdir;
    WCHAR OldFile[ACTUAL_MAX_PATH];
    WCHAR NewFile[ACTUAL_MAX_PATH];
    NTSTATUS Status;


    CLEAR_CLIENT_SCREEN();

    //
    // Get the device path of the nt partition.
    //
    SpNtNameFromRegion(
        NtPartitionRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    SpConcatenatePaths(TemporaryBuffer,Sysroot);
    ntdir = SpDupStringW(TemporaryBuffer);

    //
    // Determine the number of files listed in the section.
    // This value may be zero.
    //
    Count = SpCountLinesInSection(SifHandle,SifSection);

    for(u=0; u<Count; u++) {
        filename   = SpGetSectionLineIndex(SifHandle, SifSection, u, 0);
        dirordinal = SpGetSectionLineIndex(SifHandle, SifSection, u, 1);
        backupfile = SpGetSectionLineIndex(SifHandle, SifSection, u, 2);

        //
        // Validate the filename and dirordinal
        //
        if(!filename) {
            SpFatalSifError(SifHandle,SifSection,NULL,u,0);
        }
        if(!dirordinal) {
            SpFatalSifError(SifHandle,SifSection,NULL,u,1);
        }
        if(!backupfile) {
            SpFatalSifError(SifHandle,SifSection,NULL,u,2);
        }

        //
        // use the dirordinal key to get the path relative to sysroot of the
        // directory the file is in
        //
        targetdir = SpLookUpTargetDirectory(SifHandle,dirordinal);

        //
        // display status bar
        //
        SpDisplayStatusText(SP_STAT_BACKING_UP_FILE,DEFAULT_STATUS_ATTRIBUTE, filename, backupfile);

        //
        // Form the complete pathnames of the old file name and the new file
        // name
        //
        wcscpy(OldFile, ntdir);
        SpConcatenatePaths(OldFile, targetdir);
        wcscpy(NewFile, OldFile);
        SpConcatenatePaths(OldFile, filename);
        SpConcatenatePaths(NewFile, backupfile);

        while(TRUE) {
            if(!SpFileExists(OldFile, FALSE)) {
                break;
            }

            if(SpFileExists(NewFile, FALSE)) {
                SpDeleteFile(NewFile, NULL, NULL);
            }

            Status = SpRenameFile(OldFile, NewFile, FALSE);
            if(!NT_SUCCESS(Status) && Status != STATUS_OBJECT_NAME_NOT_FOUND && Status != STATUS_OBJECT_PATH_NOT_FOUND) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to rename file %ws to %ws(%lx)\n",OldFile, NewFile, Status));
                //
                // We can ignore this error, since it is not critical
                //
                if(!SpNonCriticalError(SifHandle, SP_SCRN_BACKUP_FAILED, filename, backupfile)) {
                    break;
                }
            }
            else {
                break;
            }

        }
    }
    SpMemFree(ntdir);
}

VOID
SpDeleteAndBackupFiles(
    IN PVOID        SifHandle,
    IN PDISK_REGION TargetRegion,
    IN PWSTR        TargetPath
    )
{
    //
    // If we are not upgrading or installing into the same tree, then
    // we have nothing to do
    //
    if(NTUpgrade == DontUpgrade) {
        return;
    }

    //
    // Below is code for NT-to-NT upgrade only
    //

    //
    //  The order in which the tasks below are performed is important.
    //  So do not change it!!!
    //  This is necessary in order to upgrade 3rd party video drivers
    //  (eg. rename sni543x.sys to cirrus.sys, so that we only upgrade
    //  the driver if it was present).
    //

    //
    // Backup files
    //
    SppBackupFilesInSection(
        SifHandle,
        (NTUpgrade == UpgradeFull) ? SIF_FILESBACKUPONUPGRADE : SIF_FILESBACKUPONOVERWRITE,
        TargetRegion,
        TargetPath
        );

    //
    // Delete files
    //
    SppDeleteFilesInSection(
        SifHandle,
        SIF_FILESDELETEONUPGRADE,
        TargetRegion,
        TargetPath
        );

    //
    // Delete directories
    //
    SppDeleteDirectoriesInSection(
        SifHandle,
        SIF_DIRSDELETEONUPGRADE,
        TargetRegion,
        TargetPath
        );

}


BOOLEAN
SpDelEnumFile(
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    )
{
    PWSTR FileName;
    static ULONG u = 0;

    //
    // Ignore subdirectories
    //
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        return TRUE;    // continue processing
    }

    //
    // We have to make a copy of the filename, because the info struct
    // we get isn't NULL-terminated.
    //
    wcsncpy(
        TemporaryBuffer,
        FileInfo->FileName,
        FileInfo->FileNameLength
        );
    (TemporaryBuffer)[FileInfo->FileNameLength / sizeof(WCHAR)] = UNICODE_NULL;
    FileName = SpDupStringW(TemporaryBuffer);

    //
    // display status bar
    //
    if( !HeadlessTerminalConnected ) {
        SpDisplayStatusText( SP_STAT_DELETING_FILE, DEFAULT_STATUS_ATTRIBUTE, FileName );
    } else {

        PWCHAR TempPtr = NULL;
        //
        // If we're headless, we need to be careful about displaying very long
        // file/directory names.  For that reason, just display a little spinner.
        //
        switch( u % 4) {
        case 0:
            TempPtr = L"-";
            break;
        case 1:
            TempPtr = L"\\";
            break;
        case 2:
            TempPtr = L"|";
            break;
        default:
            TempPtr = L"/";
            break;

        }

        SpDisplayStatusText( SP_STAT_DELETING_FILE, DEFAULT_STATUS_ATTRIBUTE, TempPtr );

        u++;
    }

    //
    // Ignore return status of delete
    //

    SpDeleteFile(DirName, FileName, NULL);

    SpMemFree(FileName);
    return TRUE;    // continue processing
}


BOOLEAN
SpDelEnumFileAndDirectory(
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    )
{
    PWSTR FileName = NULL;
    NTSTATUS Del_Status;
    DWORD FileOrDir;
    static ULONG u = 0;


    if(*(PULONG)Pointer == SP_DELETE_FILESTODELETE ){

        //
        // We have to make a copy of the filename, because the info struct
        // we get isn't NULL-terminated.
        //
        wcsncpy(
            TemporaryBuffer,
            FileInfo->FileName,
            FileInfo->FileNameLength
            );
        (TemporaryBuffer)[FileInfo->FileNameLength / sizeof(WCHAR)] = UNICODE_NULL;


        FileName = SpDupStringW(TemporaryBuffer);


        //
        // display status bar
        //
        if( !HeadlessTerminalConnected ) {
            SpDisplayStatusText( SP_STAT_DELETING_FILE, DEFAULT_STATUS_ATTRIBUTE, FileName );
        } else {

            PWCHAR TempPtr = NULL;
            //
            // If we're headless, we need to be careful about displaying very long
            // file/directory names.  For that reason, just display a little spinner.
            //
            switch( u % 4) {
            case 0:
                TempPtr = L"-";
                break;
            case 1:
                TempPtr = L"\\";
                break;
            case 2:
                TempPtr = L"|";
                break;
            default:
                TempPtr = L"/";
                break;

            }

            SpDisplayStatusText( SP_STAT_DELETING_FILE, DEFAULT_STATUS_ATTRIBUTE, TempPtr );

            u++;

        }

        //
        // Ignore return status of delete
        //



        if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY){
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: DELETING DirName-%ws : FileName-%ws\n", DirName, FileName ));
        }

        Del_Status = SpDeleteFileEx( DirName,
                        FileName,
                        NULL,
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT );

        if(!NT_SUCCESS(Del_Status))
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: File Not Deleted - Status - %ws (%lx)\n", TemporaryBuffer, Del_Status));

        if( FileDeleteGauge )
            SpTickGauge(FileDeleteGauge);
        SpMemFree(FileName);
    }
    else
        *(PULONG)Pointer = *(PULONG)Pointer + 1;


    return TRUE;    // continue processing
}


VOID
SpLogOneFile(
    IN PFILE_TO_COPY    FileToCopy,
    IN PWSTR            Sysroot,
    IN PWSTR            DirectoryOnSourceDevice,
    IN PWSTR            DiskDescription,
    IN PWSTR            DiskTag,
    IN ULONG            CheckSum
    )

{

    PWSTR   Values[ 5 ];
    LPWSTR  NtPath;
    ULONG   ValueCount;
    PFILE_TO_COPY   p;
    WCHAR   CheckSumString[ 9 ];

    if( _SetupLogFile == NULL ) {
        return;
    }

    Values[ 1 ] = CheckSumString;
    Values[ 2 ] = DirectoryOnSourceDevice;
    Values[ 3 ] = DiskDescription;
    Values[ 4 ] = DiskTag;

    swprintf( CheckSumString, ( LPWSTR )L"%lx", CheckSum );
    p = FileToCopy;

#if 0
    KdPrintEx( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ("SETUP: Source Name = %ls, \t\tTargetDirectory = %ls \t\tTargetName = %ls\t\tTargetDevice = %ls, \tAbsoluteDirectory = %d \n",
             p->SourceFilename,
             p->TargetDirectory,
             p->TargetFilename,
             p->TargetDevicePath,
             p->AbsoluteTargetDirectory ));
#endif // if 0

    Values[0] = p->SourceFilename;
    ValueCount = ( DirectoryOnSourceDevice == NULL )? 2 : 5;

    if( ( Sysroot == NULL ) ||
        ( wcslen( p->TargetDirectory ) == 0 )
      ) {

        SpAddLineToSection( _SetupLogFile,
                            SIF_NEW_REPAIR_SYSPARTFILES,
                            p->TargetFilename,
                            Values,
                            ValueCount );

    } else {

        NtPath = SpDupStringW( Sysroot );

        if (NtPath) {
            NtPath = SpMemRealloc( NtPath,
                           sizeof( WCHAR ) * ( wcslen( Sysroot ) +
                               wcslen( p->TargetDirectory ) +
                               wcslen( p->TargetFilename ) +
                               2 +    // for possible two extra back slashes
                               1      // for the terminating NULL
                          ) );


            if (NtPath) {
                SpConcatenatePaths( NtPath, p->TargetDirectory );
                SpConcatenatePaths( NtPath, p->TargetFilename );

                SpAddLineToSection( _SetupLogFile,
                                    SIF_NEW_REPAIR_WINNTFILES,
                                    NtPath,
                                    Values,
                                    ValueCount );

                SpMemFree( NtPath );
            }
        }
   }
}


PVOID
SppRetrieveLoggedOemFiles(
    PVOID   OldLogFile
    )
{
    PVOID   NewLogFile;
    BOOLEAN OldFormatSetupLogFile, FilesRetrieved = FALSE;
    PWSTR   SectionName[2];
    ULONG   FileCount, SectionIndex, i;
    PWSTR   TargetFileName;
    PWSTR   OemDiskDescription, OemDiskTag, OemSourceDirectory;
    PWSTR   Values[5];

    //
    // Create a new setup.log file to merge the OEM files into
    //
    NewLogFile = SpNewSetupTextFile();
    if(!NewLogFile) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create new setup.log buffer for OEM merging.\n"));
        return NULL;
    }

    //
    //  Determine whether setup.log has the new or old style
    //
    if(OldFormatSetupLogFile = !IsSetupLogFormatNew(OldLogFile)) {
        SectionName[0] = SIF_REPAIRSYSPARTFILES;
        SectionName[1] = SIF_REPAIRWINNTFILES;
    } else {
        SectionName[0] = SIF_NEW_REPAIR_SYSPARTFILES;
        SectionName[1] = SIF_NEW_REPAIR_WINNTFILES;
    }

    if(OldFormatSetupLogFile) {
        //
        // I don't know if we even want to mess with this.
        // The format of setup.log in NT 3.1 makes it impossible
        // to identify any OEM files except for SCSI files, and
        // even then the tagfile name is lost. I would have to use
        // the driver filename itself as a substitute for the tagfile
        // name (which is what NT 3.1 repair did--UGGHH!!)
        //
    } else {
        //
        // Retrieve logged OEM files first from system partition, then
        // from winnt directory.
        //
        for(SectionIndex = 0; SectionIndex < 2; SectionIndex++) {
            FileCount = SpCountLinesInSection(OldLogFile, SectionName[SectionIndex]);

            for(i=0; i<FileCount; i++) {
                OemSourceDirectory = SpGetSectionLineIndex(OldLogFile, SectionName[SectionIndex], i, 2);
                OemDiskTag = NULL;
                if(OemSourceDirectory) {
                    OemDiskDescription = SpGetSectionLineIndex(OldLogFile, SectionName[SectionIndex], i, 3);
                    if(OemDiskDescription) {
                        OemDiskTag = SpGetSectionLineIndex(OldLogFile, SectionName[SectionIndex], i, 4);
                    }
                }

                if(OemDiskTag) {    // then we have an OEM file

                    TargetFileName = SpGetKeyName(OldLogFile, SectionName[SectionIndex], i);
                    Values[0] = SpGetSectionLineIndex(OldLogFile, SectionName[SectionIndex], i, 0);
                    Values[1] = SpGetSectionLineIndex(OldLogFile, SectionName[SectionIndex], i, 1);
                    Values[2] = OemSourceDirectory;
                    Values[3] = OemDiskDescription;
                    Values[4] = OemDiskTag;

                    SpAddLineToSection(NewLogFile,
                                       SectionName[SectionIndex],
                                       TargetFileName,
                                       Values,
                                       5
                                       );

                    FilesRetrieved = TRUE;
                }
            }
        }
    }

    if(FilesRetrieved) {
        return NewLogFile;
    } else {
        SpFreeTextFile(NewLogFile);
        return NULL;
    }
}


VOID
SppMergeLoggedOemFiles(
    IN PVOID DestLogHandle,
    IN PVOID OemLogHandle,
    IN PWSTR SystemPartition,
    IN PWSTR SystemPartitionDirectory,
    IN PWSTR NtPartition
    )
{
    PWSTR SectionName[2] = {SIF_NEW_REPAIR_SYSPARTFILES, SIF_NEW_REPAIR_WINNTFILES};
    PWSTR FullPathNames[2] = {NULL, NULL};
    ULONG FileCount, SectionIndex, i, j;
    PWSTR TargetFileName;
    PWSTR Values[5];

    //
    //  First build the target path. It will be used to check if
    //  an existing OEM file still exists on the new installation
    //  (An OEM file could listed in the FilesToDelete section of txtsetup.sif)
    //

    wcscpy( TemporaryBuffer, SystemPartition );
    SpConcatenatePaths(TemporaryBuffer, SystemPartitionDirectory );
    FullPathNames[0] = SpDupStringW(TemporaryBuffer);
    FullPathNames[1] = SpDupStringW(NtPartition);

    //
    // Merge logged OEM files first from system partition, then
    // from winnt directory.
    //
    for(SectionIndex = 0; SectionIndex < 2; SectionIndex++) {
        FileCount = SpCountLinesInSection(OemLogHandle, SectionName[SectionIndex]);

        for(i=0; i<FileCount; i++) {
            TargetFileName = SpGetKeyName(OemLogHandle, SectionName[SectionIndex], i);
            //
            // Find out if there's already an entry for this file. If so, then don't
            // merge in the OEM file.
            //
            if(!SpGetSectionKeyExists(DestLogHandle, SectionName[SectionIndex], TargetFileName)) {
                PWSTR   p;

                //
                //  Find out if the OEM file still exists on the target system.
                //  If it doesn't exist, don't merge in the OEM file.
                //
                wcscpy( TemporaryBuffer, FullPathNames[SectionIndex] );
                SpConcatenatePaths(TemporaryBuffer, TargetFileName );
                p = SpDupStringW(TemporaryBuffer);

                if(SpFileExists(p, FALSE)) {
                    for(j = 0; j < 5; j++) {
                        Values[j] = SpGetSectionLineIndex(OemLogHandle, SectionName[SectionIndex], i, j);
                    }

                    SpAddLineToSection(DestLogHandle,
                                       SectionName[SectionIndex],
                                       TargetFileName,
                                       Values,
                                       5
                                       );
                }
                SpMemFree(p);
            }
        }
    }
    SpMemFree( FullPathNames[0] );
    SpMemFree( FullPathNames[1] );
}

BOOLEAN
SppIsFileLoggedAsOemFile(
    IN PWSTR TargetFileName
    )
{
    PWSTR SectionName[2] = {SIF_NEW_REPAIR_SYSPARTFILES, SIF_NEW_REPAIR_WINNTFILES};
    ULONG FileCount, SectionIndex;
    BOOLEAN FileIsOem;

//    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SppIsFileLoggedAsOemFile() is checking %ls \n", TargetFileName ));
    FileIsOem = FALSE;
    if( _LoggedOemFiles ) {
        //
        // Look first in the from system partition section, then
        // in the winnt section.
        //
        for(SectionIndex = 0; SectionIndex < 2; SectionIndex++) {
            if( SpGetSectionKeyExists( _LoggedOemFiles, SectionName[SectionIndex], TargetFileName)) {
                FileIsOem = TRUE;
                break;
            }
        }
    }
    return( FileIsOem );
}

BOOLEAN
SpRemoveEntryFromCopyList(
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           TargetDirectory,
    IN PWSTR           TargetFilename,
    IN PWSTR           TargetDevicePath,
    IN BOOLEAN         AbsoluteTargetDirectory
    )

/*++

Routine Description:

    Removes an entry from a disk's file copy list.

Arguments:

    DiskFileLists - supplies an array of file lists, one for each distribution
        disk in the product.

    DiskCount - supplies number of elements in the DiskFileLists array.

    TargetDirectory - supplies the directory on the target media
        into which the file will be copied.

    TargetFilename - supplies the name of the file as it will exist
        in the target tree.

    TargetDevicePath - supplies the NT name of the device onto which the file
        is to be copied (ie, \device\harddisk1\partition2, etc).

    AbsoluteTargetDirectory - indicates whether TargetDirectory is a path from the
        root, or relative to a root to specified later.

Return Value:

    TRUE if a new copy list entry was created; FALSE if not (ie, the file was
        already on the copy list).

--*/

{
    PDISK_FILE_LIST pDiskList;
    PFILE_TO_COPY   pListEntry;
    ULONG           DiskNumber;

    for(DiskNumber=0; DiskNumber<DiskCount; DiskNumber++) {
        pDiskList = &DiskFileLists[DiskNumber];
        for(pListEntry=pDiskList->FileList; pListEntry; pListEntry=pListEntry->Next) {
            if(!_wcsicmp(pListEntry->TargetFilename,TargetFilename)
            && !_wcsicmp(pListEntry->TargetDirectory,TargetDirectory)
            && !_wcsicmp(pListEntry->TargetDevicePath,TargetDevicePath)
            && (pListEntry->AbsoluteTargetDirectory == AbsoluteTargetDirectory)) {
                pListEntry->Flags &= ~COPY_DISPOSITION_MASK;
                pListEntry->Flags |= COPY_NEVER;
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SpRemoveEntryFromCopyList() removed %ls from copy list \n", TargetFilename ));
                return( TRUE );
            }
        }
    }
//    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: SpRemoveEntryFromCopyList() failed to remove %ls from copy list \n", TargetFilename ));
    return( FALSE );
}

NTSTATUS
SpMoveFileOrDirectory(
    IN PWSTR   SrcPath,
    IN PWSTR   DestPath
    )
/*++

Routine Description:

    This routine attempts to move a source file or  directory, to a target
    file or directory.

    Note: This function will fail if the source and destination paths do not
    point to the same volume.

Arguments:

    SrcPath:  Absolute path to the source file or directory.
              This path should include the path to the source device.

    DestPath: Absolute path to the destination file or directory.
              This path should include the path to the source device.

Return Value:

    NTSTATUS

--*/

{
    OBJECT_ATTRIBUTES        Obja;
    IO_STATUS_BLOCK          IoStatusBlock;
    UNICODE_STRING           SrcName;
    HANDLE                   hSrc;
    NTSTATUS                 Status;
    BYTE                     RenameFileInfoBuffer[ACTUAL_MAX_PATH * sizeof(WCHAR) + sizeof(FILE_RENAME_INFORMATION)];
    PFILE_RENAME_INFORMATION RenameFileInfo;

    if(wcslen(DestPath) >= ACTUAL_MAX_PATH){
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, 
                   "SETUP:SpMoveFileOrDirectory, Actual length of Dest path is %d more that %d - skipping %ws move", 
                   wcslen(DestPath), ACTUAL_MAX_PATH, DestPath));
        return STATUS_NAME_TOO_LONG;
    }
    //
    // Initialize names and attributes.
    //
    INIT_OBJA(&Obja,&SrcName,SrcPath);

    Status = ZwCreateFile( &hSrc,
                           FILE_GENERIC_READ,
                           &Obja,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ,
                           FILE_OPEN,
                           0,
                           NULL,
                           0 );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open source file %ws. Status = %lx\n",SrcPath, Status));
        return( Status );
    }

    memset(RenameFileInfoBuffer, 0, sizeof(RenameFileInfoBuffer));
    RenameFileInfo = (PFILE_RENAME_INFORMATION)RenameFileInfoBuffer;
    RenameFileInfo->ReplaceIfExists = TRUE;
    RenameFileInfo->RootDirectory = NULL;
    RenameFileInfo->FileNameLength = wcslen(DestPath) * sizeof(WCHAR);
    RtlMoveMemory(RenameFileInfo->FileName, DestPath, (wcslen(DestPath) + 1) * sizeof(WCHAR));
    Status = ZwSetInformationFile( hSrc,
                                   &IoStatusBlock,
                                   RenameFileInfo,
                                   sizeof(RenameFileInfoBuffer),
                                   FileRenameInformation );
    if(!NT_SUCCESS(Status)) {
        KdPrintEx(( DPFLTR_SETUP_ID, 
                    DPFLTR_ERROR_LEVEL, 
                    "SETUP: unable to set attribute on  %ws. Status = %lx\n",
                    SrcPath, 
                    Status));
    }
    
    ZwClose(hSrc);
    
    return( Status );
}


BOOLEAN
SppCopyDirRecursiveCallback(
    IN  PCWSTR                      SrcPath,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT PULONG                      ReturnData,
    IN  PVOID                       Params
    )

/*++

Routine Description:

    This routine is called by the file enumerator as a callback for each
    file or subdirectory found in the parent directory. It creates a node
    for the file or subdirectory and appends it to the appropriate list.

Arguments:

    SrcPath - Absolute path to the parent directory. Unused.
              the path to the source device.

    FileInfo - supplies find data for a file or directory in the parent directory.

    ReturnData - receives an error code if an error occurs.
                 We ignore errors in this routine and thus we always
                 just fill this in with NO_ERROR.

    Params - Contains a pointer to the COPYDIR_DIRECTORY_NODE for the parent directory.

Return Value:

    TRUE if successful otherwise FALSE (if ran out of memory).

--*/

{
    PCOPYDIR_FILE_NODE fileEntry;
    PCOPYDIR_DIRECTORY_NODE directoryEntry;
    PCOPYDIR_DIRECTORY_NODE parentDirectory = Params;
    ULONG nameLength;
    BOOLEAN Result = TRUE;

    *ReturnData = NO_ERROR;

    nameLength = FileInfo->FileNameLength / sizeof(WCHAR);

    if( (FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {

        //
        // This is a file. Create a node for it, linked to the parent directory.
        //
        fileEntry = SpMemAlloc(sizeof(COPYDIR_FILE_NODE) + FileInfo->FileNameLength);

        if (fileEntry) {
            wcsncpy(fileEntry->Name, FileInfo->FileName, nameLength);
            fileEntry->Name[nameLength] = 0;
            InsertTailList(&parentDirectory->FileList, &fileEntry->SiblingListEntry);
        } else {
            Result = FALSE; // ran out of memory
        }
    } else {

        //
        // This is a directory. Skip it if it's "." or "..". Otherwise,
        // create a node for it, linked to the parent directory.
        //
        ASSERT(nameLength != 0);
        if ( (FileInfo->FileName[0] == L'.') &&
             ( (nameLength == 1) ||
               ( (nameLength == 2) && (FileInfo->FileName[1] == L'.') ) ) ) {
            //
            // Skip . and ..
            //
        } else {
            directoryEntry = SpMemAlloc(sizeof(COPYDIR_DIRECTORY_NODE) + FileInfo->FileNameLength);

            if (directoryEntry) {
                InitializeListHead(&directoryEntry->FileList);
                InitializeListHead(&directoryEntry->SubdirectoryList);
                directoryEntry->Parent = parentDirectory;
                wcsncpy( directoryEntry->Name,
                         FileInfo->FileName,
                         FileInfo->FileNameLength/sizeof(WCHAR) );
                directoryEntry->Name[FileInfo->FileNameLength/sizeof(WCHAR)] = 0;
                InsertTailList( &parentDirectory->SubdirectoryList,
                                &directoryEntry->SiblingListEntry );
            } else {
                Result = FALSE; // ran out of memory
            }
        }
    }

    return Result;
}

VOID
SpCopyDirRecursive(
    IN PWSTR   SrcPath,
    IN PWSTR   DestDevPath,
    IN PWSTR   DestDirPath,
    IN ULONG   CopyFlags
    )
/*++

Routine Description:

    This routine recursively copies a src directory to a destination directory.

Arguments:

    SrcPath:  Absolute path to the source directory. This path should include
              the path to the source device.

    DestDevPath:  Path to the destination device.

    DestDirPath:  Path to the destination directory.

    CopyFlags: Flags to pass to SpCopyFilesUsingNames()

Return Value:

    None.

--*/

{
    ULONG n;
    NTSTATUS Status;
    PWSTR currentSrcPath;
    PWSTR currentDestPath;
    LIST_ENTRY directoryList;
    LIST_ENTRY fileList;
    COPYDIR_DIRECTORY_NODE rootDirectory;
    PCOPYDIR_DIRECTORY_NODE currentDirectory;
    PCOPYDIR_DIRECTORY_NODE oldDirectory;
    PCOPYDIR_FILE_NODE fileEntry;
    PLIST_ENTRY listEntry;

    //
    // Allocate a buffer to hold the working source and destination paths.
    //

#define COPYDIR_MAX_PATH 16384 // characters

    currentSrcPath = SpMemAlloc(2 * COPYDIR_MAX_PATH * sizeof(WCHAR));
    currentDestPath = currentSrcPath + COPYDIR_MAX_PATH;

    wcscpy(currentSrcPath, SrcPath);
    wcscpy(currentDestPath, DestDevPath);
    SpConcatenatePaths(currentDestPath, DestDirPath);

    //
    //  Create the target directory
    //

    if( !SpFileExists( currentDestPath, TRUE ) ) {

        //
        //  If the directory doesn't exist, then try to move (rename) the
        //  source directory.
        //
        if (!RemoteSysPrepSetup) {

            Status = SpMoveFileOrDirectory( SrcPath, currentDestPath );
            if( NT_SUCCESS( Status ) ) {
                SpMemFree(currentSrcPath);
                return;
            }
        }

        //
        //  If unable to rename the source directory, then create the
        //  target directory
        //
        SpCreateDirectory( DestDevPath,
                           NULL,
                           DestDirPath,
                           0,
                           0 );

        if (RemoteSysPrepSetup) {

            Status = SpCopyEAsAndStreams( currentSrcPath,
                                          NULL,
                                          currentDestPath,
                                          NULL,
                                          TRUE );


            if ( NT_SUCCESS( Status )) {

                Status = SpSysPrepSetExtendedInfo( currentSrcPath,
                                                   currentDestPath,
                                                   TRUE,
                                                   FALSE );
            }

            if (! NT_SUCCESS( Status )) {

                SpMemFree(currentSrcPath);
                return;
            }
        }
    }

    //
    // Initialize the screen.
    //

    SpCopyFilesScreenRepaint(L"", NULL, TRUE);

    //
    // Create directory node for the starting directory.
    //

    InitializeListHead( &rootDirectory.SubdirectoryList );
    InitializeListHead( &rootDirectory.FileList );
    rootDirectory.Parent = NULL;

    currentDirectory = &rootDirectory;

    do {

        //
        // Enumerate the files and directories in the current source directory.
        //

        SpEnumFiles(currentSrcPath, SppCopyDirRecursiveCallback, &n, currentDirectory);

        //
        // Copy all files in the current source directory to the destination directory.
        //

        while ( !IsListEmpty(&currentDirectory->FileList) ) {

            listEntry = RemoveHeadList(&currentDirectory->FileList);
            fileEntry = CONTAINING_RECORD( listEntry,
                                           COPYDIR_FILE_NODE,
                                           SiblingListEntry );

            SpConcatenatePaths(currentSrcPath, fileEntry->Name);
            SpConcatenatePaths(currentDestPath, fileEntry->Name);

            SpMemFree(fileEntry);

            SpCopyFilesScreenRepaint(currentSrcPath, NULL, FALSE);

            Status = SpCopyFileUsingNames( currentSrcPath,
                                           currentDestPath,
                                           0,
                                           CopyFlags );

            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to copy %ws. Status = %lx\n", currentSrcPath, Status));
                SpCopyFilesScreenRepaint(L"", NULL, TRUE);
            }

            *wcsrchr(currentSrcPath, L'\\') = 0;
            *wcsrchr(currentDestPath, L'\\') = 0;
        }

        //
        // If the current directory has no subdirectories, walk back up the
        // tree looking for an unprocessed directory.
        //

        while ( IsListEmpty(&currentDirectory->SubdirectoryList) ) {

            //
            // If the current directory is the root directory, we're done. Otherwise,
            // move up to the parent directory entry and delete the current one.
            //

            oldDirectory = currentDirectory;
            currentDirectory = currentDirectory->Parent;

            if ( currentDirectory == NULL ) {
                break;
            }

            ASSERT(IsListEmpty(&oldDirectory->FileList));
            ASSERT(IsListEmpty(&oldDirectory->SiblingListEntry));
            SpMemFree(oldDirectory);

            //
            // Strip the name of the current directory off of the path.
            //

            *wcsrchr(currentSrcPath, L'\\') = 0;
            *wcsrchr(currentDestPath, L'\\') = 0;
        }

        if ( currentDirectory != NULL ) {

            //
            // We found another directory to work on.
            //

            listEntry = RemoveHeadList(&currentDirectory->SubdirectoryList);
            currentDirectory = CONTAINING_RECORD( listEntry,
                                                  COPYDIR_DIRECTORY_NODE,
                                                  SiblingListEntry );
#if DBG
            InitializeListHead(&currentDirectory->SiblingListEntry);
#endif

            //
            // Create the target directory.
            //
            SpCreateDirectory( currentDestPath,
                               NULL,
                               currentDirectory->Name,
                               0,
                               0 );
            SpCopyFilesScreenRepaint(L"",NULL,TRUE);

            SpConcatenatePaths(currentSrcPath, currentDirectory->Name);
            SpConcatenatePaths(currentDestPath, currentDirectory->Name);

            if (RemoteSysPrepSetup) {

                Status = SpCopyEAsAndStreams( currentSrcPath,
                                              NULL,
                                              currentDestPath,
                                              NULL,
                                              TRUE );


                if ( NT_SUCCESS( Status )) {

                    Status = SpSysPrepSetExtendedInfo( currentSrcPath,
                                                       currentDestPath,
                                                       TRUE,
                                                       FALSE );
                }

                if (! NT_SUCCESS( Status )) {

                    goto cleanup;
                }
            }
        }

    } while ( currentDirectory != NULL );

    ASSERT(IsListEmpty(&rootDirectory.FileList));
    ASSERT(IsListEmpty(&rootDirectory.SubdirectoryList));

cleanup:

    //
    // Normally everything will already be cleaned up by the time we get here.
    // But if the above loop is aborted, there may be some cleanup to do.
    // Walk the lists in the same manner as the above loop, freeing memory
    // along the way.
    //

    currentDirectory = &rootDirectory;

    do {

        while ( !IsListEmpty(&currentDirectory->FileList) ) {
            listEntry = RemoveHeadList(&currentDirectory->FileList);
            fileEntry = CONTAINING_RECORD( listEntry,
                                           COPYDIR_FILE_NODE,
                                           SiblingListEntry );
            SpMemFree(fileEntry);
        }

        while ( IsListEmpty(&currentDirectory->SubdirectoryList) ) {

            oldDirectory = currentDirectory;
            currentDirectory = currentDirectory->Parent;

            if ( currentDirectory == NULL ) {
                break;
            }

            ASSERT(IsListEmpty(&oldDirectory->FileList));
            ASSERT(IsListEmpty(&oldDirectory->SiblingListEntry));
            SpMemFree(oldDirectory);
        }

        if ( currentDirectory != NULL ) {

            listEntry = RemoveHeadList(&currentDirectory->SubdirectoryList);
            currentDirectory = CONTAINING_RECORD( listEntry,
                                                  COPYDIR_DIRECTORY_NODE,
                                                  SiblingListEntry );
#if DBG
            InitializeListHead(&currentDirectory->SiblingListEntry);
#endif
        }

    } while ( currentDirectory != NULL );

    //
    // Free the buffer allocated at the beginning.
    //

    SpMemFree(currentSrcPath);

    return;

} // SpCopyDirRecursive


VOID
SppCopyOemDirectories(
    IN PWSTR    SourceDevicePath,
    IN PWSTR    NtPartition,
    IN PWSTR    Sysroot
    )
/*++

Routine Description:

    This routine recursively copies a src directory to a destination directory.

Arguments:

    SourceDevicePath: Path to the device that contains the source.

    NtPartition:  Path to the drive that contains the system.

    Systroot:     Directory where the system is installed.

Return Value:

    None.

--*/

{
    PWSTR   r, s, t;
    WCHAR   Drive[3];
    PDISK_REGION TargetRegion;

    //
    //  Check if the subdirectory $OEM$\\$$ exists on the source directory.
    //  If it exists, then tree copy the directory on top of %SystemRoot%
    //
    wcscpy(TemporaryBuffer, SourceDevicePath);
    SpConcatenatePaths( TemporaryBuffer, PreinstallOemSourcePath );
    r = wcsrchr( TemporaryBuffer, (WCHAR)'\\' );
    if( r != NULL ) {
        *r = (WCHAR)'\0';
    }
    //
    //  Make a copy of the path that we have so far. It will be used to build the
    //  path to $OEM$\$1
    //
    s = SpDupStringW(TemporaryBuffer);

    SpConcatenatePaths( TemporaryBuffer, WINNT_OEM_FILES_SYSROOT_W );
    r = SpDupStringW(TemporaryBuffer);

    if (r) {
        if( SpFileExists( r, TRUE ) ) {
            SpCopyFilesScreenRepaint(L"", NULL, TRUE);
            SpCopyDirRecursive( r,
                                NtPartition,
                                Sysroot,
                                COPY_DELETESOURCE
                              );
        }

        SpMemFree( r );
    }

    //
    //  Check if the subdirectory $OEM$\\$1 exists on the source directory.
    //  If it exists, then tree copy the directory to the root of %SystemDrive%
    //
    wcscpy(TemporaryBuffer, s);
    SpMemFree( s );
    SpConcatenatePaths( TemporaryBuffer, WINNT_OEM_FILES_SYSDRVROOT_W );
    r = SpDupStringW(TemporaryBuffer);

    if (r) {
        if( SpFileExists( r, TRUE ) ) {
            SpCopyFilesScreenRepaint(L"", NULL, TRUE);
            SpCopyDirRecursive( r,
                                NtPartition,
                                L"\\",
                                COPY_DELETESOURCE
                              );
        }
        SpMemFree( r );
    }


    //
    //  Copy the subdirectories $OEM$\<drive letter> to the root of each
    //  corresponding drive.
    //  These directories are:
    //
    //      $OEM$\C
    //      $OEM$\D
    //      $OEM$\E
    //          .
    //          .
    //          .
    //      $OEM$\Z
    //
    //
    wcscpy(TemporaryBuffer, SourceDevicePath);
    SpConcatenatePaths( TemporaryBuffer, PreinstallOemSourcePath );
    r = wcsrchr( TemporaryBuffer, (WCHAR)'\\' );

    if( r != NULL ) {
        *r = (WCHAR)'\0';
    }

    SpConcatenatePaths( TemporaryBuffer, L"\\C" );
    r = SpDupStringW(TemporaryBuffer);

    if (r) {
        s = wcsrchr( r, (WCHAR)'\\' );
        s++;

        Drive[1] = (WCHAR)':';
        Drive[2] = (WCHAR)'\0';

        for( Drive[0] = (WCHAR)'C'; Drive[0] <= (WCHAR)'Z'; Drive[0] = Drive[0] + 1) {
            //
            //  If the subdirectory $OEM$\<drive letter> exists on the source,
            //  and if there is a FAT or NTFS partition in the target machine that
            //  has the same drive letter specification, then tree copy
            //  $OEM$\<drive letter> to the corresponding partition in the target
            //  machine.
            //
            *s = Drive[0];
            if( SpFileExists( r, TRUE ) ) {
                if( ( ( TargetRegion = SpRegionFromDosName( Drive ) ) != NULL ) &&
                    TargetRegion->PartitionedSpace &&
                    ( ( TargetRegion->Filesystem  == FilesystemFat   ) ||
                      ( TargetRegion->Filesystem  == FilesystemFat32 ) ||
                      ( TargetRegion->Filesystem  == FilesystemNtfs  ) )
                  ) {
                    SpNtNameFromRegion( TargetRegion,
                                        TemporaryBuffer,
                                        sizeof(TemporaryBuffer),
                                        PartitionOrdinalCurrent );
                    t = SpDupStringW(TemporaryBuffer);
                    SpCopyDirRecursive( r,
                                        t,
                                        L"",
                                        COPY_DELETESOURCE
                                      );
                    SpMemFree( t );
                }
            }
        }
        SpMemFree( r );
    }

    //
    //  Merge %SystemRoot%\$$rename.txt with $$rename.txt in the root of the
    //  NT partition.
    //
    SppMergeRenameFiles( SourceDevicePath, NtPartition, Sysroot );
}



VOID
SppMergeRenameFiles(
    IN PWSTR    SourceDevicePath,
    IN PWSTR    NtPartition,
    IN PWSTR    Sysroot
    )
/*++

Routine Description:

    This routine recursively copies a src directory to a destination directory.

Arguments:

    SourceDevicePath: Path to the device that contains the source.

    NtPartition:  Path to the drive that contains the system.

    Systroot:     Directory where the system is installed.

Return Value:

    None.

--*/

{
    PWSTR        r, s;
    PDISK_REGION TargetRegion;
    NTSTATUS     Status;
    PVOID        RootRenameFile;
    PVOID        SysrootRenameFile;
    ULONG        ErrorLine;
    ULONG        SectionCount;
    ULONG        LineCount;
    ULONG        i,j;
    PWSTR        SectionName;
    PWSTR        NewSectionName;
    PWSTR        KeyName;
    PWSTR        Values[1];
    PFILE_TO_RENAME File;

    //
    //  Build the ful path to %sysroot%\$$rename.txt
    //
    wcscpy(TemporaryBuffer, NtPartition);
    SpConcatenatePaths( TemporaryBuffer, Sysroot );
    SpConcatenatePaths( TemporaryBuffer, WINNT_OEM_LFNLIST_W );
    s = SpDupStringW(TemporaryBuffer);

    //
    //  Load %sysroot%\$$rename.txt, if one exists
    //
    if( SpFileExists( s, FALSE ) ) {
        //
        //  Load Sysroot\$$rename.txt
        //
        Status = SpLoadSetupTextFile( s,
                                      NULL,
                                      0,
                                      &SysrootRenameFile,
                                      &ErrorLine,
                                      TRUE,
                                      FALSE
                                      );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load file %ws. Status = %lx \n", s, Status ));
            goto merge_rename_exit;
        }
    } else {
        SysrootRenameFile = NULL;
    }

    //
    //  If there is a $$rename.txt on sysroot, then it needs to be merged
    //  (or appended) to the one in the NtPartition.
    //  If RenameList is not empty, then the files in this list need to be
    //  added to $$rename.txt on the NtPartition.
    //  Otherwise, don't do any merge.
    //
    if( ( SysrootRenameFile != NULL )
        || ( RenameList != NULL )
      ) {

        //
        //  Find out if the NtPartition contains a $$rename.txt
        //
        wcscpy(TemporaryBuffer, NtPartition);
        SpConcatenatePaths( TemporaryBuffer, WINNT_OEM_LFNLIST_W );
        r = SpDupStringW(TemporaryBuffer);
        if( !SpFileExists( r, FALSE ) ) {
            //
            //  If the NT partition doesn't contain $$rename.txt, then
            //  create a new $$rename.txt in memory
            //
            RootRenameFile = SpNewSetupTextFile();
            if( RootRenameFile == NULL ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpNewSetupTextFile() failed \n"));
                if( SysrootRenameFile != NULL ) {
                    SpFreeTextFile( SysrootRenameFile );
                }
                SpMemFree( r );
                goto merge_rename_exit;
            }

        } else {
            //
            //  Load $$rename on the NTPartition
            //
            Status = SpLoadSetupTextFile( r,
                                          NULL,
                                          0,
                                          &RootRenameFile,
                                          &ErrorLine,
                                          TRUE,
                                          FALSE
                                          );
            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load file %ws. Status = %lx \n", r, Status ));
                if( SysrootRenameFile != NULL ) {
                    SpFreeTextFile( SysrootRenameFile );
                }
                SpMemFree( r );
                goto merge_rename_exit;
            }
        }

        if( SysrootRenameFile != NULL ) {
            //
            //  Add the section of Sysroot\$$rename.txt to $$rename.txt in memory
            //  Note that we need to prepend Sysroot to the section name
            //
            SectionCount = SpCountSectionsInFile( SysrootRenameFile );
            for( i = 0; i < SectionCount; i++ ) {
                SectionName = SpGetSectionName( SysrootRenameFile, i );
                if( SectionName != NULL ) {
                    wcscpy(TemporaryBuffer, L"\\");
                    SpConcatenatePaths( TemporaryBuffer, Sysroot);
                    SpConcatenatePaths( TemporaryBuffer, SectionName );
                    NewSectionName = SpDupStringW(TemporaryBuffer);
                    LineCount = SpCountLinesInSection( SysrootRenameFile, SectionName );
                    for( j = 0; j < LineCount; j++ ) {
                        KeyName = SpGetKeyName( SysrootRenameFile, SectionName, j );
                        Values[0] = SpGetSectionKeyIndex( SysrootRenameFile, SectionName, KeyName, 0 );
                        SpAddLineToSection( RootRenameFile,
                                            NewSectionName,
                                            KeyName,
                                            Values,
                                            1 );
                    }
                    SpMemFree( NewSectionName );
                }
            }
            //
            //  $$rename.txt on Sysroot is no longer needed
            //
            SpFreeTextFile( SysrootRenameFile );
            SpDeleteFile( s, NULL, NULL );
        }

        //
        //  Add the files in RenameList to \$$rename.txt
        //
        if( RenameList != NULL ) {
            do {
                File = RenameList;
                RenameList = File->Next;
                Values[0] = File->TargetFilename;
                SpAddLineToSection( RootRenameFile,
                                    File->TargetDirectory,
                                    File->SourceFilename,
                                    Values,
                                    1 );
                SpMemFree( File->SourceFilename );
                SpMemFree( File->TargetFilename );
                SpMemFree( File->TargetDirectory );
                SpMemFree( File );
            } while( RenameList != NULL );
        }

        //
        //  Create a new \$$rename.txt
        //
        SpWriteSetupTextFile( RootRenameFile, r, NULL, NULL );
        //
        //  $$rename.txt on memory is no longer needed
        //
        SpFreeTextFile( RootRenameFile );
    }

merge_rename_exit:

    SpMemFree( s );
}


BOOLEAN
SpTimeFromDosTime(
    IN USHORT Date,
    IN USHORT Time,
    OUT PLARGE_INTEGER UtcTime
    )
{
    //
    // steal time from windows\base\client\datetime.c, DosDateTimeToFileTime()
    // and LocalFileTimeToFileTime()
    //

    TIME_FIELDS TimeFields;
    LARGE_INTEGER FileTime;
    LARGE_INTEGER Bias;

    TimeFields.Year         = (CSHORT)((Date & 0xFE00) >> 9)+(CSHORT)1980;
    TimeFields.Month        = (CSHORT)((Date & 0x01E0) >> 5);
    TimeFields.Day          = (CSHORT)((Date & 0x001F) >> 0);
    TimeFields.Hour         = (CSHORT)((Time & 0xF800) >> 11);
    TimeFields.Minute       = (CSHORT)((Time & 0x07E0) >>  5);
    TimeFields.Second       = (CSHORT)((Time & 0x001F) << 1);
    TimeFields.Milliseconds = 0;

    if (RtlTimeFieldsToTime(&TimeFields,&FileTime)) {

        //
        // now convert to utc time
        //
        do {
            Bias.HighPart = USER_SHARED_DATA->TimeZoneBias.High1Time;
            Bias.LowPart = USER_SHARED_DATA->TimeZoneBias.LowPart;
        } while (Bias.HighPart != USER_SHARED_DATA->TimeZoneBias.High2Time);
        UtcTime->QuadPart = Bias.QuadPart + FileTime.QuadPart;

        return(TRUE);
    }

    RtlSecondsSince1980ToTime( 0, UtcTime );  // default = 1-1-1980

    return(FALSE);

}



BOOLEAN
pSpIsFileInDriverInf(
    IN PCWSTR FileName,
    IN PVOID SifHandle,
    HANDLE *CabHandle
    )
{
    PWSTR  InfFileName, CabFileName;
    UINT   FileCount,i,j;
    PWSTR  szSetupSourceDevicePath = 0;
    PWSTR  szDirectoryOnSetupSource = 0;
    HANDLE hSif = (HANDLE)0;
    CABDATA *MyCabData;


    if (!DriverInfHandle) {
        if (gpCmdConsBlock) {
            szSetupSourceDevicePath = gpCmdConsBlock->SetupSourceDevicePath;
            szDirectoryOnSetupSource = gpCmdConsBlock->DirectoryOnSetupSource;
            hSif = (HANDLE)(gpCmdConsBlock->SifHandle);

        } else {
            if (ghSif && gszDrvInfDeviceName && gszDrvInfDirName) {
                hSif = ghSif;
                szSetupSourceDevicePath = gszDrvInfDeviceName;
                szDirectoryOnSetupSource = gszDrvInfDirName;
            }
        }

        if (szSetupSourceDevicePath && szDirectoryOnSetupSource &&
                hSif) {
            //
            // try to open handle to drvindex.inf and to driver.cab,
            // prompting for media if required
            //
            SpInitializeDriverInf( hSif,
                                   szSetupSourceDevicePath,
                                   szDirectoryOnSetupSource );

            if (!DriverInfHandle)
                return(FALSE);
        } else {
            return FALSE;
        }
    }

    //
    // look for the file in all loaded cabs, in order
    //
    MyCabData = CabData;
    while (MyCabData) {
        if (MyCabData->CabHandle && MyCabData->CabSectionName && MyCabData->CabInfHandle) {
            if (!SifHandle || SifHandle == MyCabData->CabInfHandle) {
                //
                // look for entries in this inf
                //
                FileCount = SpCountLinesInSection(MyCabData->CabInfHandle, MyCabData->CabSectionName);
                for (i=0; i< FileCount; i++) {
                    InfFileName = SpGetSectionLineIndex( MyCabData->CabInfHandle, MyCabData->CabSectionName, i, 0);
                    if (InfFileName && _wcsicmp (InfFileName, FileName) == 0) {
                        //
                        // Got him. Return the handle.
                        //
                        *CabHandle = MyCabData->CabHandle;
                        return TRUE;
                    }
                }
            }
        }

        MyCabData = MyCabData->Next;
    }

    return(FALSE);

}

NTSTATUS
SpOpenFileInDriverCab(
    PCWSTR SourceFileName,
    IN PVOID SifHandle,
    HANDLE *SourceHandle
    )
{
    if (!pSpIsFileInDriverInf( SourceFileName, SifHandle, SourceHandle )) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    return STATUS_SUCCESS;

}


#if defined(_X86_)
//
// Structure used by next few routines below.  The SpMigMoveFileOrDir
// moves the file/dir with ntos rtl, but the rtl resets the attributes!!
// We have no choice but to traverse the file/dir and save the attributes
// in a list, then do the move, then restore the attributes from the list.
//

typedef struct {
    ULONG BaseDirChars;
    PWSTR BaseDir;
    ULONG FileCount;
    ULONG BytesNeeded;
    PBYTE OriginalPos;
    PBYTE CurrentPos;       // NULL if callback should determine size and count
} ATTRIBS_LIST, *PATTRIBS_LIST;


VOID
SppAddAttributeToList (
    IN      ULONG Attributes,
    IN      PWSTR FileOrDir,
    OUT     PATTRIBS_LIST List
    )

/*++

Routine Description:

    This private function updates the attribute list.  It has two modes:
    (A) the size is being calculated or (B) the list is being created.

Arguments:

    Attributes:   The attributes of the file (needed for (B) only)

    FileOrDir:    Partial path to file or dir (it is relative to the
                  base path)

    List:         List structure that is updated

Return Value:

    None.

--*/

{
    ULONG BytesNeeded;

    BytesNeeded = sizeof (ULONG) + (wcslen (FileOrDir) + 1) * sizeof (WCHAR);

    if (List->CurrentPos) {
        *((PULONG) List->CurrentPos) = Attributes;
        wcscpy ((PWSTR) (List->CurrentPos + sizeof (ULONG)), FileOrDir);
        List->CurrentPos += BytesNeeded;
    } else {
        List->BytesNeeded += BytesNeeded;
        List->FileCount += 1;
    }
}


BOOLEAN
SpAttribsEnumFile(
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    )

/*++

Routine Description:

    SpAttribsEnumFile is an EnumFilesRecursive callback.  It
    recieves every file, dir, subfile and subdir for a file/dir
    being moved.  (It does not recieve the . and .. dirs.)

    For each file, the attributes and file name are added to
    the attribute list.

Arguments:

    DirName:        Path to the current directory

    FileInfo:       Structure containing information about the file or
                    subdir being enumerated.

    ret:            Return code used for failuers

    Pointer:        A pointer to an ATTRIBS_LIST structure.

Return Value:

    TRUE unless an error occurs (errors stop enumeration).

--*/

{
    PATTRIBS_LIST BufferInfo;
    PWSTR p;
    ULONG Attributes;
    NTSTATUS Status;
    PWSTR temp;
    ULONG Len;
    PWSTR FullPath;

    BufferInfo = (PATTRIBS_LIST) Pointer;

    //
    // Check state of BufferInfo
    //

    ASSERT (wcslen(DirName) >= BufferInfo->BaseDirChars);

    //
    // Build the full file or dir path
    //

    temp = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);
    Len = FileInfo->FileNameLength/sizeof(WCHAR);

    wcsncpy(temp,FileInfo->FileName,Len);
    temp[Len] = 0;

    wcscpy(TemporaryBuffer,DirName);
    SpConcatenatePaths(TemporaryBuffer,temp);
    FullPath = SpDupStringW(TemporaryBuffer);

    //
    // Get attributes and add file to the list
    //

    Status = SpGetAttributes (FullPath, &Attributes);
    if (NT_SUCCESS (Status)) {
        SppAddAttributeToList (
            Attributes,
            FullPath + BufferInfo->BaseDirChars,
            BufferInfo
            );
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not get attributes for %ws, Status=%lx\n", FullPath, Status));
    }

    SpMemFree (FullPath);

    return TRUE;
}


NTSTATUS
SpSaveFileOrDirAttribs (
    IN      PWSTR SourceFileOrDir,
    OUT     PATTRIBS_LIST BufferInfo
    )

/*++

Routine Description:

    This routine determines if SourceFileOrDir is a file or dir.
    For a file, it obtains the attributes and puts it in the
    supplied attribs list.  For a dir, it obtains the attributes
    of the dir, plus all attributes of subdirs and subfiles and
    puts them in the supplied attribs list.  This function uses
    EnumFilesRecursive to enumerate everything in a directory.

Arguments:

    SourceFileOrDir: Full path to a file or directory to build
                     an attribute list from.

    BufferInfo:      A caller-allocated ATTRIBS_LIST struct that
                     recieves a list of attributes and relative
                     paths.

Return Value:

    Standard NT Status code.

--*/

{
    LONG                BaseAttribute;
    NTSTATUS            Status;

    //
    // Get attributes of base file or directory provided
    //

    Status = SpGetAttributes (SourceFileOrDir, &BaseAttribute);
    if (!NT_SUCCESS (Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID, 
            DPFLTR_ERROR_LEVEL, 
            "SETUP:SpSaveFileOrDirAttribs, Failed to get attributes %ws - status 0x%08X.\n", 
            SourceFileOrDir, 
            Status));
        return Status;
    }

    //
    // Set the size required and file count for base file or dir
    //
    RtlZeroMemory (BufferInfo, sizeof (ATTRIBS_LIST));
    BufferInfo->BaseDirChars = wcslen (SourceFileOrDir);
    SppAddAttributeToList (BaseAttribute, L"", BufferInfo);

    //
    // If the supplied path is to a directory, find the number of bytes
    // needed to hold a list of all subfiles and subdirectories.
    //

    if (BaseAttribute & FILE_ATTRIBUTE_DIRECTORY) {
        // Determine space needed to hold all file names
        SpEnumFilesRecursive (
            SourceFileOrDir,
            SpAttribsEnumFile,
            &Status,
            BufferInfo
            );
    }

    //
    // Allocate the file list
    //

    BufferInfo->OriginalPos = SpMemAlloc (BufferInfo->BytesNeeded);
    BufferInfo->CurrentPos = BufferInfo->OriginalPos;

    //
    // Add the base attributes for real this time
    //

    SppAddAttributeToList (BaseAttribute, L"", BufferInfo);

    //
    // For directories, add all subfiles and subdirectories
    //

    if (BaseAttribute & FILE_ATTRIBUTE_DIRECTORY) {
        // Add all files, dirs, subfiles and subdirs to the list
        SpEnumFilesRecursive (
             SourceFileOrDir,
             SpAttribsEnumFile,
             &Status,
             BufferInfo
             );
    }

    return Status;
}

VOID
SppRestoreAttributesFromList (
    IN OUT  PATTRIBS_LIST BufferInfo
    )

/*++

Routine Description:

    This routine restores the attributes associated with a file
    in the supplied attribs list.  After the attributes are set,
    the list size is decremented.  A few sanity checks are also
    done.

Arguments:

    BufferInfo:   The attribs structure that has at least one
                  file/dir and attribute pair in it.  The
                  list pointer is advanced and the file count
                  is decremented.

Return Value:

    None.

--*/

{
    ULONG Attributes;
    PWSTR Path;
    ULONG BytesNeeded;
    PWSTR FullPath;
    NTSTATUS Status;

    Attributes = *((PULONG) BufferInfo->CurrentPos);
    Path       = (PWSTR) (BufferInfo->CurrentPos + sizeof (ULONG));

    BytesNeeded = sizeof (ULONG) + (wcslen (Path) + 1) * sizeof (WCHAR);

    // guard against abnormal failure
    if (BytesNeeded > BufferInfo->BytesNeeded ||
        !BufferInfo->BaseDir) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppRestoreAttributesFromList failed abnormally\n"));
        BufferInfo->FileCount = 0;
        return;
    }

    //
    // Prepare full path
    //

    wcscpy (TemporaryBuffer, BufferInfo->BaseDir);
    if (*Path) {
        SpConcatenatePaths(TemporaryBuffer, Path);
    }

    FullPath = SpDupStringW(TemporaryBuffer);

    //
    // Set attributes
    //

    Status = SpSetAttributes (FullPath, Attributes);
    if (!NT_SUCCESS (Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not set attributes for %ws, Status=%lx\n", FullPath, Status));
    }

    //
    // Adjust position state
    //

    BufferInfo->CurrentPos += BytesNeeded;
    BufferInfo->BytesNeeded -= BytesNeeded;
    BufferInfo->FileCount -= 1;

    //
    // Cleanup
    //

    SpMemFree (FullPath);
}


VOID
SpCleanUpAttribsList (
    IN      PATTRIBS_LIST BufferInfo
    )

/*++

Routine Description:

    This is the cleanup routine needed by SpRestoreFileOrDirAttribs,
    or by the ATTRIBS_LIST allocating function if the attributes
    don't get restored.

    This routine cannot be called twice on the same structure.

Arguments:

    BufferInfo:   The attribs structure to clean up.

Return Value:

    None.

--*/

{
    if (BufferInfo->OriginalPos) {
        SpMemFree (BufferInfo->OriginalPos);
    }
}


VOID
SpRestoreFileOrDirAttribs (
    IN      PWSTR DestFileOrDir,
    IN      PATTRIBS_LIST BufferInfo
    )

/*++

Routine Description:

    This routine calls SppRestoreAttributesFromList for every
    file/dir and attribute pair in the supplied attribute list.
    The attributes are applied to a new base dir.  This function
    is used to restore attributes after a file or directory has
    been moved.

Arguments:

    DestFileOrDir:  The new full path of the file or dir

    BufferInfo:     The caller-allocated ATTRIBS_LIST that was
                    prepared by SpSaveFileOrDirAttribs.

Return Value:

    None.  (Errors are ignored.)

--*/

{
    ULONG BaseAttributes;
    NTSTATUS Status;

    BufferInfo->CurrentPos = BufferInfo->OriginalPos;
    BufferInfo->BaseDir = DestFileOrDir;

    while (BufferInfo->FileCount > 0) {
        SppRestoreAttributesFromList (BufferInfo);
    }

    SpCleanUpAttribsList (BufferInfo);
}


VOID
SpMigMoveFileOrDir (
    IN      PWSTR SourceFileOrDir,
    IN      PWSTR DestFileOrDir
    )

/*++

Routine Description:

  SpMigMoveFileOrDir sets the attribute of the source file to be
  normal, moves the file into the destination, and resets the
  attribute.  If an error occurs, it is ignored.  There's nothing
  the user can do about the error, and it will be detected in GUI
  mode.  In an error condition, the user's settings will not be
  completely migrated, but NT will install OK.  (Any error would
  be really bad news for the user anyhow, like a hardware failure.)

Arguments:

    SourceFileOrDir:       The source path (with DOS drive)

    DestFileOrDir:         The destination path (with DOS drive)

Return Value:

    None.  Errors ignored.

--*/


{
    NTSTATUS Status;
    PDISK_REGION SourceRegion;              // source region (converted from DOS path)
    PDISK_REGION DestRegion;                // destination region (also converted)
    PWSTR SrcNTPath;                        // buffer for full source path
    PWSTR DestPartition;                    // buffer for destination partition in NT namespace
    PWSTR DestNTPath;                       // buffer for full source dest
    PWSTR DestDir;                          // DestFileOrDir with last subdir or file chopped off
    PWSTR DestDirWack;                      // Used to find last subdir or file in DestDir path
    ATTRIBS_LIST AttribsList;               // used to save attribute list


    // We are guaranteed to have drive letters because of WINNT32's behavior.
    // However, let's verify and ignore messed up data.

    if (!(SourceFileOrDir && SourceFileOrDir[0] && SourceFileOrDir[1] == L':')) {
        return;
    }

    if (!(DestFileOrDir && DestFileOrDir[0] && DestFileOrDir[1] == L':')) {
        return;
    }

    // Get regions for DOS paths
    SourceRegion = SpRegionFromDosName (SourceFileOrDir);

    if (!SourceRegion) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "SETUP: SpRegionFromDosName failed for %ws\n", SourceFileOrDir));

        return;
    }

    DestRegion = SpRegionFromDosName (DestFileOrDir);

    if (!DestRegion) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "SETUP: SpRegionFromDosName failed for %ws\n", DestFileOrDir));

        return;
    }

    // Make full paths
    SpNtNameFromRegion(
                    SourceRegion,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    // no repartioning is possible, so this is the same ordinal
                    // as the original
                    PartitionOrdinalCurrent
                    );

    SpConcatenatePaths( TemporaryBuffer, &SourceFileOrDir[2]);
    SrcNTPath = SpDupStringW(TemporaryBuffer);

    SpNtNameFromRegion(
                    DestRegion,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    PartitionOrdinalCurrent
                    );

    DestPartition = SpDupStringW(TemporaryBuffer);
    SpConcatenatePaths( TemporaryBuffer, &DestFileOrDir[2]);
    DestNTPath = SpDupStringW(TemporaryBuffer);

    // Save file attribs
    Status = SpSaveFileOrDirAttribs (SrcNTPath, &AttribsList);

    if (NT_SUCCESS (Status)) {
        // Reset file attribs
        Status = SpSetAttributes (SrcNTPath, FILE_ATTRIBUTE_NORMAL);

        if (NT_SUCCESS (Status)) {
            // Ensure destination exists
            DestDir = SpDupStringW (&DestFileOrDir[2]);

            if (DestDir) {
                DestDirWack = wcsrchr (DestDir, L'\\');

                if (DestDirWack) {
                    *DestDirWack = 0;
                }

                SpCreateDirectory (DestPartition,
                                   NULL,
                                   DestDir,
                                   0,
                                   0);

                SpMemFree (DestDir);
            }

            // Move the file or directory tree
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                "SETUP: Moving %ws to %ws\n", SrcNTPath, DestNTPath));

            Status = SpMoveFileOrDirectory (SrcNTPath, DestNTPath);

            // Restore attributes
            if (NT_SUCCESS (Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                    "SETUP: Restoring attributes on %ws\n", DestNTPath));

                SpRestoreFileOrDirAttribs (DestNTPath, &AttribsList);
            } else {
                SpCleanUpAttribsList (&AttribsList);
            }
        }
        else {
            KdPrintEx((
                DPFLTR_SETUP_ID, 
                DPFLTR_ERROR_LEVEL, 
                "SETUP:SpMigMoveFileOrDir, Could not set attributes for %ws, Status=%lx\n", 
                SrcNTPath, 
                Status));
        }
    }
    else{
        KdPrintEx((
            DPFLTR_SETUP_ID, 
            DPFLTR_ERROR_LEVEL, 
            "SETUP:SpMigMoveFileOrDir, Function \"SpSaveFileOrDirAttribs\" failed with %ws, Status=%lx\n", 
            SrcNTPath, 
            Status));
    }

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "SETUP: Unable to move file %ws to %ws. Status = %lx \n",
            SrcNTPath, DestNTPath, Status ));
    }

    // Clean up
    SpMemFree( SrcNTPath );
    SpMemFree( DestNTPath );
    SpMemFree( DestPartition );
}


VOID
SpMigDeleteFile (
    PWSTR DosFileToDelete
    )

/*++

Routine Description:

  SpMigDeleteFile sets the attribute of the source file to be
  normal, and then deletes the file.  If an error occurs, it
  is ignored.  There's nothing the user can do about the error,
  and it will be detected in file copy.  In an error condition,
  there is a potential for two copies of the same file--an NT
  version and a Win9x version.  Any error would be really
  bad news for the user anyhow, like a hardware failure, and
  textmode's file copy won't succeed.

Arguments:

    DosFileToDelete:       The source path (with DOS drive)

Return Value:

    None.  Errors ignored.

--*/

{
    NTSTATUS Status;
    PDISK_REGION SourceRegion;              // source region (converted from DOS path)
    PWSTR SrcNTPath;                        // buffer for full source path

    // We are guaranteed to have drive letters because of WINNT32's behavior.
    // However, let's verify and ignore messed up data.

    if (!(DosFileToDelete && DosFileToDelete[0] && DosFileToDelete[1] == L':'))
        return;

    // Get region for DOS path
    SourceRegion = SpRegionFromDosName (DosFileToDelete);
    if (!SourceRegion) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRegionFromDosName failed for %ws\n", DosFileToDelete));
        return;
    }

    SpNtNameFromRegion(
        SourceRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        // no repartioning is possible, so this is the same ordinal
        // as the original
        PartitionOrdinalCurrent
        );

    SpConcatenatePaths (TemporaryBuffer, &DosFileToDelete[2]);
    SrcNTPath = SpDupStringW (TemporaryBuffer);

    SpSetAttributes (SrcNTPath, FILE_ATTRIBUTE_NORMAL);

    if (SpFileExists (SrcNTPath, FALSE)) {

        //
        // Delete the file
        //

        Status = SpDeleteFile (SrcNTPath, NULL, NULL);

    } else if (SpFileExists (SrcNTPath, TRUE)) {

        //
        // Delete the empty directory
        //

        Status = SpDeleteFileEx (
                    SrcNTPath,
                    NULL,
                    NULL,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_FOR_BACKUP_INTENT
                    );
    } else {
        //
        // Doesn't exist -- ignore delete request
        //

        Status = STATUS_SUCCESS;
    }

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Unable to delete %ws. Status = %lx \n",
            SrcNTPath,
            Status
            ));
    }

    // Clean up
    SpMemFree( SrcNTPath );
}

#endif // defined _X86_


NTSTATUS
SpExpandFile(
    IN PWSTR            SourceFilename,
    IN PWSTR            TargetPathname,
    IN PEXPAND_CALLBACK Callback,
    IN PVOID            CallbackContext
    )

/*++

Routine Description:

    Attempt to decompress contents of a file, reporting progress via callback.

Arguments:

    SourceFilename - supplies fully qualified name of compressed file
        in the NT namespace.

    TargetPathname - supplies fully qualified path for target file(s)
        in the NT namespace.

Return Value:

    NT Status value indicating outcome.

--*/

{
    NTSTATUS Status;
    HANDLE SourceHandle = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG FileSize;
    PVOID ImageBase;
    HANDLE SectionHandle = INVALID_HANDLE_VALUE;
    BOOLEAN IsCabinet = FALSE;
    BOOLEAN IsMultiFileCabinet;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;

    //
    // Open the source file.
    //

    INIT_OBJA(&Obja,&UnicodeString,SourceFilename);

    Status = ZwCreateFile( &SourceHandle,
                           FILE_GENERIC_READ,
                           &Obja,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ,
                           FILE_OPEN,
                           0,
                           NULL,
                           0 );

    if( !NT_SUCCESS(Status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpExpandFile: Unable to open source file %ws (%x)\n",SourceFilename,Status));
        goto exit;
    }

    Status = SpGetFileSize( SourceHandle, &FileSize );
    if( !NT_SUCCESS(Status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpExpandFile: unable to get size of %ws (%x)\n",SourceFilename,Status));
        goto exit;
    }

    Status = SpMapEntireFile( SourceHandle, &SectionHandle, &ImageBase, FALSE );
    if( !NT_SUCCESS(Status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpExpandFile: Unable to map source file %ws (%x)\n",SourceFilename,Status));
        goto exit;
    }

    IsCabinet = SpdIsCabinet( ImageBase, FileSize, &IsMultiFileCabinet );

    if ( !IsCabinet ) {

        LARGE_INTEGER Zero;

        Zero.QuadPart = 0;

        Callback( EXPAND_NOTIFY_CANNOT_EXPAND,
                  SourceFilename,
                  &Zero,
                  &Zero,
                  0,
                  CallbackContext );

        Status = STATUS_UNSUCCESSFUL;
        goto exit;
    }

    //
    // Advise client if the source contains multiple files
    //

    if ( IsMultiFileCabinet ) {

        EXPAND_CALLBACK_RESULT rc;
        LARGE_INTEGER Zero;

        Zero.QuadPart = 0;

        rc = Callback( EXPAND_NOTIFY_MULTIPLE,
                       SourceFilename,
                       &Zero,
                       &Zero,
                       0,
                       CallbackContext );

        if ( rc == EXPAND_ABORT ) {
            Status = STATUS_UNSUCCESSFUL;
            goto exit;
        }
    }

    Status = SpdDecompressCabinet( ImageBase,
                                   FileSize,
                                   TargetPathname,
                                   Callback,
                                   CallbackContext );

exit:

    if (SectionHandle != INVALID_HANDLE_VALUE) {
        SpUnmapFile( SectionHandle, ImageBase );
    }

    if ( SourceHandle != INVALID_HANDLE_VALUE ) {
        ZwClose( SourceHandle );
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spcopy.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spcopy.h

Abstract:

    Header file for file copying functions in text setup.

Author:

    Ted Miller (tedm) 29-October-1993

Revision History:

    02-Oct-1996  jimschm  Added SpMoveWin9xFiles
    24-Feb-1997  jimschm  Added SpDeleteWin9xFiles
    28-Feb-1997  marcw    Moved *Win9x* functions to i386\win9xupg.c.
                          Added declarations for SpMigDeleteFile and SpMigMoveFileOrDir

--*/


#ifndef _SPCOPY_DEFN_
#define _SPCOPY_DEFN_

//
// Define structure used to describe a file to be copied
// to the target installation.
//
typedef struct _FILE_TO_COPY {

    struct _FILE_TO_COPY *Next;

    //
    // Name of the file to be copied, as it exists on the source media
    // (file name part only -- no paths).
    //
    PWSTR SourceFilename;

    //
    // Directory to which this file is to be copied.
    //
    PWSTR TargetDirectory;

    //
    // Name of file as it should exist on the target.
    //
    PWSTR TargetFilename;

    //
    // Path to target partition.  This is useful because
    // be will have to copy files to the nt drive and system partition,
    // and we don't want to serialize these lists (ie, we don't want to
    // worry about where the target is).
    //
    PWSTR TargetDevicePath;

    //
    // Flag indicating whether TargetDirectory is absolute.  If not, then it
    // is relative to a directory determined at run time (ie, sysroot).
    // This is useful for files that get copied to the system partition.
    //
    BOOLEAN AbsoluteTargetDirectory;

    //
    // Disposition flag to indicate the conditions under which the file
    // is to be copied. Can be one of the following, which may be ORed with
    // any of the COPY_xxx flags below.
    //
    //   COPY_ALWAYS                : always copied
    //   COPY_ONLY_IF_PRESENT       : copied only if present on the target
    //   COPY_ONLY_IF_NOT_PRESENT   : not copied if present on the target
    //   COPY_NEVER                 : never copied
    //
    ULONG Flags;

    //
    // File attributes to be set on the file. If specified sets these attributes.
    // If FILE_ATTRIBUTES_NONE then takes the default logic of attribute setting.
    //
    ULONG FileAttributes;

} FILE_TO_COPY, *PFILE_TO_COPY;

typedef struct _DISK_FILE_LIST {

    PWSTR MediaShortname;

    PWSTR Description;

    PWSTR TagFile;

    PWSTR Directory;

    ULONG FileCount;

    PFILE_TO_COPY FileList;

} DISK_FILE_LIST, *PDISK_FILE_LIST;


typedef struct _INCOMPATIBLE_FILE_ENTRY {

    //
    // Next in line
    //
    struct _INCOMPATIBLE_FILE_ENTRY *Next;

    //
    // Future - currently always zero
    //
    ULONG Flags;

    //
    // Short name (no path) of the file that is incompatible
    //
    PWSTR IncompatibleFileName;

    //
    // Version string (future use) of this file
    //
    PWSTR VersionString;

    //
    // Where it lives on the target media
    //
    PWSTR FullPathOnTarget;

} INCOMPATIBLE_FILE_ENTRY, *PINCOMPATIBLE_FILE_ENTRY;

typedef struct _INCOMPATIBLE_FILE_LIST {

    //
    // First entry in the list
    //
    PINCOMPATIBLE_FILE_ENTRY Head;

    //
    // Count, to speed things up
    //
    ULONG EntryCount;

} INCOMPATIBLE_FILE_LIST, *PINCOMPATIBLE_FILE_LIST;


#define COPY_ALWAYS                 0x00000000
#define COPY_ONLY_IF_PRESENT        0x00000001
#define COPY_ONLY_IF_NOT_PRESENT    0x00000002
#define COPY_NEVER                  0x00000003
#define COPY_DISPOSITION_MASK       0x0000000f

#define COPY_DELETESOURCE           0x00000010
#define COPY_SMASHLOCKS             0x00000020
#define COPY_SOURCEISOEM            0x00000040
#define COPY_OVERWRITEOEMFILE       0x00000080
#define COPY_FORCENOCOMP            0x00000100
#define COPY_SKIPIFMISSING          0x00000200
#define COPY_NOVERSIONCHECK         0x00000400
#define COPY_NODECOMP               0x00000800
#define COPY_DECOMPRESS_SYSPREP     0x00001000 // decompress even if it's a sysprep image

//
// Flags in [FileFlags] section of txtsetup.sif
//
#define FILEFLG_SMASHLOCKS          0x00000001
#define FILEFLG_FORCENOCOMP         0x00000002
#define FILEFLG_UPGRADEOVERWRITEOEM 0x00000004
#define FILEFLG_NOVERSIONCHECK      0x00000008
#define FILEFLG_DONTDELETESOURCE    0x00000010

#define SP_DELETE_FILESTODELETE 0
#define SP_COUNT_FILESTODELETE 1

//
//  Structure used to build a list of OEM inf files copied during the installation of OEM drivers
//
typedef struct _OEM_INF_FILE {

    struct _OEM_INF_FILE *Next;

    PWSTR InfName;

} OEM_INF_FILE, *POEM_INF_FILE;

//
// Type of routine to be called from SpCopyFileWithRetry
// when the screen needs repainting.
//
typedef
VOID
(*PCOPY_DRAW_ROUTINE) (
    IN PWSTR   FullSourcePath,     OPTIONAL
    IN PWSTR   FullTargetPath,     OPTIONAL
    IN BOOLEAN RepaintEntireScreen
    );

//
// Type of routine to be called from SpExpandFile
// for each file found in cabinet.
//

typedef enum {
    EXPAND_COPY_FILE,
    EXPAND_COPIED_FILE,
    EXPAND_QUERY_OVERWRITE,
    EXPAND_NOTIFY_CANNOT_EXPAND,
    EXPAND_NOTIFY_MULTIPLE,
    EXPAND_NOTIFY_CREATE_FAILED
} EXPAND_CALLBACK_MESSAGE;

typedef enum {
    EXPAND_NO_ERROR = 0,
    EXPAND_SKIP_THIS_FILE,
    EXPAND_COPY_THIS_FILE,
    EXPAND_CONTINUE,
    EXPAND_ABORT
} EXPAND_CALLBACK_RESULT;

typedef
EXPAND_CALLBACK_RESULT
(*PEXPAND_CALLBACK) (
    IN EXPAND_CALLBACK_MESSAGE  Message,
    IN PWSTR                    FileName,
    IN PLARGE_INTEGER           FileSize,
    IN PLARGE_INTEGER           FileTime,
    IN ULONG                    FileAttributes,
    IN PVOID                    CallbackContext
    );

VOID
SpCopyThirdPartyDrivers(
    IN PWSTR           SourceDevicePath,
    IN PWSTR           SysrootDevice,
    IN PWSTR           Sysroot,
    IN PWSTR           SyspartDevice,
    IN PWSTR           SyspartDirectory,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount
    );

NTSTATUS
SpCopyFileUsingNames(
    IN PWSTR   SourceFilename,
    IN PWSTR   TargetFilename,
    IN ULONG   TargetAttributes,
    IN ULONG   Flags
    );

VOID
SpValidateAndChecksumFile(
    IN  HANDLE   FileHandle, OPTIONAL
    IN  PWSTR    Filename,   OPTIONAL
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    );

VOID
SpCopyFileWithRetry(
    IN PFILE_TO_COPY      FileToCopy,
    IN PWSTR              SourceDevicePath,
    IN PWSTR              DirectoryOnSourceDevice,
    IN PWSTR              SourceDirectory,          OPTIONAL
    IN PWSTR              TargetRoot,               OPTIONAL
    IN ULONG              TargetFileAttributes,
    IN PCOPY_DRAW_ROUTINE DrawScreen,
    IN PULONG             CheckSum,
    IN PBOOLEAN           FileSkipped,
    IN ULONG              Flags
    );

VOID
SpCopyFiles(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PWSTR        SystemPartitionDirectory,
    IN PWSTR        SourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    IN PWSTR        ThirdPartySourceDevicePath
    );

VOID
SpDeleteAndBackupFiles(
    IN PVOID        SifHandle,
    IN PDISK_REGION TargetRegion,
    IN PWSTR        TargetPath
    );

//
// The user may skip this operation, in which case SpCreateDirectory
// returns FALSE.
//
#define CREATE_DIRECTORY_FLAG_SKIPPABLE         (0x00000001)
//
// The headless spinner and error ui are not affected by this flag.
//
#define CREATE_DIRECTORY_FLAG_NO_STATUS_TEXT_UI (0x00000002)

BOOLEAN
SpCreateDirectory_Ustr(
    IN PCUNICODE_STRING DevicePath,
    IN PCUNICODE_STRING RootDirectory, OPTIONAL
    IN PCUNICODE_STRING Directory,
    IN ULONG DirAttrs,
    IN ULONG CreateFlags
    );

BOOLEAN
SpCreateDirectory(
    IN PCWSTR DevicePath,
    IN PCWSTR RootDirectory, OPTIONAL
    IN PCWSTR Directory,
    IN ULONG DirAttrs,
    IN ULONG CreateFlags
    );

VOID
SpCreateDirectoryStructureFromSif(
    IN PVOID SifHandle,
    IN PWSTR SifSection,
    IN PWSTR DevicePath,
    IN PWSTR RootDirectory
    );


NTSTATUS
SpMoveFileOrDirectory(
    IN PWSTR   SrcPath,
    IN PWSTR   DestPath
    );

VOID
SpCopyDirRecursive(
    IN PWSTR   SrcPath,
    IN PWSTR   DestDevPath,
    IN PWSTR   DestDirPath,
    IN ULONG   CopyFlags
    );

//
// Diamond/decompression routines.
//
VOID
SpdInitialize(
    VOID
    );

VOID
SpdTerminate(
    VOID
    );

BOOLEAN
SpdIsCabinet(
    IN PVOID SourceBaseAddress,
    IN ULONG SourceFileSize,
    OUT PBOOLEAN ContainsMultipleFiles
    );

BOOLEAN
SpdIsCompressed(
    IN PVOID SourceBaseAddress,
    IN ULONG SourceFileSize
    );

NTSTATUS
SpdDecompressFile(
    IN PVOID  SourceBaseAddress,
    IN ULONG  SourceFileSize,
    IN HANDLE DestinationHandle
    );

NTSTATUS
SpdDecompressCabinet(
    IN PVOID            SourceBaseAddress,
    IN ULONG            SourceFileSize,
    IN PWSTR            DestinationPath,
    IN PEXPAND_CALLBACK Callback,
    IN PVOID            CallbackContext
    );

NTSTATUS
SpdDecompressFileFromDriverCab(
    IN  PWSTR SourceFileName,
    IN  PVOID  SourceBaseAddress,
    IN  ULONG  SourceFileSize,
    IN  HANDLE DestinationHandle,
    OUT PUSHORT pDate,
    OUT PUSHORT pTime
    );

BOOLEAN
SpTimeFromDosTime(
    IN USHORT Date,
    IN USHORT Time,
    OUT PLARGE_INTEGER UtcTime
    );

VOID
SpMigDeleteFile (
    PWSTR DosFileToDelete
    );

VOID
SpMigMoveFileOrDir (
    IN PWSTR         SourceFileOrDir,
    IN PWSTR         DestFileOrDir
    );

VOID
SpInitializeFileLists(
    IN  PVOID            SifHandle,
    OUT PDISK_FILE_LIST *DiskFileLists,
    OUT PULONG           DiskCount
    );

VOID
SpAddSectionFilesToCopyList(
    IN PVOID           SifHandle,
    IN PDISK_FILE_LIST DiskFileLists,
    IN ULONG           DiskCount,
    IN PWSTR           SectionName,
    IN PWSTR           TargetDevicePath,
    IN PWSTR           TargetDirectory,
    IN ULONG           CopyOptions,
    IN BOOLEAN         CheckForNoComp,
    IN BOOLEAN         FileAttributesAvailable
    );

VOID
SpCopyFilesInCopyList(
    IN PVOID                    SifHandle,
    IN PDISK_FILE_LIST          DiskFileLists,
    IN ULONG                    DiskCount,
    IN PWSTR                    SourceDevicePath,
    IN PWSTR                    DirectoryOnSourceDevice,
    IN PWSTR                    TargetRoot,
    IN PINCOMPATIBLE_FILE_LIST  CompatibilityExceptionList OPTIONAL
    );

VOID
SpFreeCopyLists(
    IN OUT PDISK_FILE_LIST *DiskFileLists,
    IN     ULONG            DiskCount
    );

NTSTATUS
SpExpandFile(
    IN PWSTR            SourceFilename,
    IN PWSTR            TargetPathname,
    IN PEXPAND_CALLBACK Callback,
    IN PVOID            CallbackContext
    );

NTSTATUS
SpCreateIncompatibleFileEntry(
    OUT PINCOMPATIBLE_FILE_ENTRY *TargetEntry,
    IN PWSTR FileName,
    IN PWSTR VersionString          OPTIONAL,
    IN PWSTR TargetAbsolutePath     OPTIONAL,
    IN ULONG Flags                  OPTIONAL
    );


NTSTATUS
SpFreeIncompatibleFileList(
    IN PINCOMPATIBLE_FILE_LIST FileListHead
    );

BOOLEAN
SpIsFileIncompatible(
    IN  PINCOMPATIBLE_FILE_LIST FileList,
    IN  PFILE_TO_COPY           pFile,
    IN  PWSTR                   TargetRoot OPTIONAL
    );


NTSTATUS
SpInitializeCompatibilityOverwriteLists(
    IN  PVOID                   SifHandle,
    OUT PINCOMPATIBLE_FILE_LIST IncompatibleFileList
    );

#endif // ndef _SPCOPY_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spdblspc.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdblspc.h

Abstract:

    Header file for double space module in text setup.

Author:

    Jaime Sasson (jaimes) 01-October-1993

Revision History:

--*/

#ifndef _SPDBLSPACE_
#define _SPDBLSPACE_

#define CVF_NAME        L"DBLSPACE"
#define CVF_NAME_LENGTH 8+1+3

BOOLEAN
SpLoadDblspaceIni(
    );

VOID
SpInitializeCompressedDrives(
    );

VOID
SpDisposeCompressedDrives(
    PDISK_REGION    CompressedDrive
    );

BOOLEAN
SpUpdateDoubleSpaceIni(
    );

ULONG
SpGetNumberOfCompressedDrives(
    IN  PDISK_REGION    DiskRegion
);


#endif // _SPDBLSPACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spdisk.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdisk.h

Abstract:

    Hard disk manipulation support for text setup.

Author:

    Ted Miller (tedm) 27-Aug-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop
#include <ntddscsi.h>

//
// The following will be TRUE if hard disks have been determined
// successfully (ie, if SpDetermineHardDisks was successfully called).
//
BOOLEAN HardDisksDetermined = FALSE;

//
// These two globals track the hard disks attached to the computer.
//
PHARD_DISK HardDisks;
ULONG      HardDiskCount;

//
// These flags get set to TRUE if we find any disks owned
// by ATDISK or ABIOSDSK.
//
BOOLEAN AtDisksExist = FALSE;
BOOLEAN AbiosDisksExist = FALSE;

//
// Structure to track scsi ports in the system and routine to initialize
// a list of them.
//
typedef struct _MY_SCSI_PORT_INFO {

    //
    // Port number, redundant if these are stored in an array.
    //
    ULONG PortNumber;

    //
    // Port number relative to the the first port owned by the
    // adapter that owns this port.
    //
    // For example, if there are 2 Future Domain controllers and an Adaptec
    // controller, the RelativePortNumbers would be 0, 1, and 0.
    //
    ULONG RelativePortNumber;

    //
    // Name of owning miniport driver (ie, aha154x or fd8xx).
    // NULL if unknown.
    //
    PWSTR MiniportName;

} MY_SCSI_PORT_INFO, *PMY_SCSI_PORT_INFO;


//
// Disk format type strings
//
// TBD : Use the localized strings
//
WCHAR   *DiskTags[] = { DISK_TAG_TYPE_UNKNOWN,
                        DISK_TAG_TYPE_PCAT,
                        DISK_TAG_TYPE_NEC98,
                        DISK_TAG_TYPE_GPT,
                        DISK_TAG_TYPE_RAW };

VOID
SpInitializeScsiPortList(
    VOID
    );

//
// Count of scsi ports in the system.
//
ULONG ScsiPortCount;
PMY_SCSI_PORT_INFO ScsiPortInfo;

//
// Key in registry of device map
//
PCWSTR szRegDeviceMap = L"\\Registry\\Machine\\Hardware\\DeviceMap";


PWSTR
SpDetermineOwningDriver(
    IN HANDLE Handle
    );

VOID
SpGetDiskInfo(
    IN  ULONG      DiskNumber,
    IN  PVOID      SifHandle,
    IN  PWSTR      OwningDriverName,
    IN  HANDLE     Handle,
    OUT PHARD_DISK Descriptor
    );

BOOLEAN
SpGetScsiAddress(
    IN  HANDLE         Handle,
    OUT PSCSI_ADDRESS  ScsiAddress,
    OUT PWSTR         *ScsiAdapterName
    );

NTSTATUS
SpDetermineInt13Hookers(
    IN HANDLE DiskHandle,
    IN OUT PHARD_DISK Disk
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    
    if (DiskHandle && Disk) {
        PVOID   UnalignedBuffer = SpMemAlloc(Disk->Geometry.BytesPerSector * 2);

        if (UnalignedBuffer) {
            PON_DISK_MBR    Mbr = ALIGN(UnalignedBuffer, Disk->Geometry.BytesPerSector);

            Disk->Int13Hooker = NoHooker;

            Status = SpReadWriteDiskSectors(DiskHandle,
                        0,
                        1,
                        Disk->Geometry.BytesPerSector,
                        (PVOID)Mbr,
                        FALSE);


            if (NT_SUCCESS(Status)) {
                switch (Mbr->PartitionTable[0].SystemId) {
                    case 0x54:
                        Disk->Int13Hooker = HookerOnTrackDiskManager;
                        break;
                        
                    case 0x55:
                        Disk->Int13Hooker = HookerEZDrive;
                        break;
                        
                    default:
                        break;
                }
            }                    

            SpMemFree(UnalignedBuffer);
        } else {
            Status = STATUS_NO_MEMORY;
        }            
    }

    return Status;
}

   
NTSTATUS
SpDetermineHardDisks(
    IN PVOID SifHandle
    )

/*++

Routine Description:

    Determine the hard disks attached to the computer and
    the state they are in (ie, on-line, off-line, removed, etc).

Arguments:

    SifHandle - handle to main setup information file.

Return Value:

    STATUS_SUCCESS   - operation successful.

    The global variables HardDisks and
    HardDiskCount are filled in if STATUS_SUCCESS.

--*/

{
    PCONFIGURATION_INFORMATION ConfigInfo;
    ULONG disk;
    PWSTR OwningDriverName;
    ULONG remainder;
    LARGE_INTEGER temp;
    PARTITION_INFORMATION PartitionInfo;

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_EXAMINING_DISK_CONFIG,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Determine the number of hard disks attached to the system
    // and allocate space for an array of Disk Descriptors.
    //
    ConfigInfo = IoGetConfigurationInformation();
    HardDiskCount = ConfigInfo->DiskCount;

    if ( HardDiskCount != 0 ) {
        HardDisks = SpMemAlloc(HardDiskCount * sizeof(HARD_DISK));
        RtlZeroMemory(HardDisks,HardDiskCount * sizeof(HARD_DISK));
    }

    SpInitializeScsiPortList();

    //
    // For each disk, fill in its device path in the nt namespace
    // and get information about the device.
    //

    for(disk=0; disk<HardDiskCount; disk++) {

        NTSTATUS Status;
        IO_STATUS_BLOCK IoStatusBlock;
        HANDLE Handle;
        PHARD_DISK Descriptor;
        FILE_FS_DEVICE_INFORMATION DeviceInfo;

        Descriptor = &HardDisks[disk];

        swprintf(Descriptor->DevicePath,L"\\Device\\Harddisk%u",disk);

        //
        // Assume off-line.
        //
        Descriptor->Status = DiskOffLine;

        SpFormatMessage(
            Descriptor->Description,
            sizeof(Descriptor->Description),
            SP_TEXT_UNKNOWN_DISK_0
            );

        //
        // Open partition0 of the disk.  This should succeed even if
        // there is no media in the drive.
        //
        Status = SpOpenPartition0(Descriptor->DevicePath,&Handle,FALSE);
        if(!NT_SUCCESS(Status)) {
            continue;
        }
        
        //
        // Determine device characteristics (fixed/removable).
        // If this fails, assume that the disk is fixed and off-line.
        //
        Status = ZwQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &DeviceInfo,
                    sizeof(DeviceInfo),
                    FileFsDeviceInformation
                    );

        if(NT_SUCCESS(Status)) {

            //
            // Save device characteristic information.
            //
            ASSERT(DeviceInfo.DeviceType == FILE_DEVICE_DISK);
            ASSERT((DeviceInfo.Characteristics & (FILE_FLOPPY_DISKETTE | FILE_REMOTE_DEVICE)) == 0);
            Descriptor->Characteristics = DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA;

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: unable to determine device characteristics for %ws (%lx)\n",Descriptor->DevicePath,Status));
            ZwClose(Handle);
            continue;
        }

        //
        // Attempt to get geometry.
        // If this fails, then assume the disk is off-line.
        //
        Status = ZwDeviceIoControlFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
                    NULL,
                    0,
                    &Descriptor->Geometry,
                    sizeof(DISK_GEOMETRY)
                    );

        if(NT_SUCCESS(Status)) {

            Descriptor->CylinderCount = Descriptor->Geometry.Cylinders.QuadPart;

            //
            // Calculate some additional geometry information.
            //
            Descriptor->SectorsPerCylinder = Descriptor->Geometry.SectorsPerTrack
                                           * Descriptor->Geometry.TracksPerCylinder;

#if defined(_IA64_)            
            Status = ZwDeviceIoControlFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_DISK_GET_PARTITION_INFO,
                NULL,
                0,
                &PartitionInfo,
                sizeof(PARTITION_INFORMATION)
                );
            if (NT_SUCCESS(Status)) {
                Descriptor->DiskSizeSectors = (PartitionInfo.PartitionLength.QuadPart) / 
                    (Descriptor->Geometry.BytesPerSector);
            }
            else {
#endif
                Descriptor->DiskSizeSectors = RtlExtendedIntegerMultiply(
                                                    Descriptor->Geometry.Cylinders,
                                                    Descriptor->SectorsPerCylinder
                                                    ).LowPart;
#if defined(_IA64_)            
            }
#endif
            if (IsNEC_98) { //NEC98
                //
                // Used last cylinder by T&D
                //
                Descriptor->DiskSizeSectors -= Descriptor->SectorsPerCylinder;
            } //NEC98

            Descriptor->Status = DiskOnLine;

            //
            // Calculate the size of the disk in MB.
            //
            temp.QuadPart = UInt32x32To64(
                                Descriptor->DiskSizeSectors,
                                Descriptor->Geometry.BytesPerSector
                                );

            Descriptor->DiskSizeMB = RtlExtendedLargeIntegerDivide(temp,1024*1024,&remainder).LowPart;
            if(remainder >= 512) {
                Descriptor->DiskSizeMB++;
            }

            //
            // Now that we know how big the disk is, change the default disk name.
            //
            SpFormatMessage(
                Descriptor->Description,
                sizeof(Descriptor->Description),
                SP_TEXT_UNKNOWN_DISK_1,
                Descriptor->DiskSizeMB
                );

            //
            // Attempt to get the disk signature.
            //
            Status = ZwDeviceIoControlFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                        NULL,
                        0,
                        TemporaryBuffer,
                        sizeof(TemporaryBuffer)
                        );

            if(NT_SUCCESS(Status)) {
                PDRIVE_LAYOUT_INFORMATION_EX    DriveLayoutEx = 
                                (PDRIVE_LAYOUT_INFORMATION_EX)TemporaryBuffer;

                if (DriveLayoutEx->PartitionStyle == PARTITION_STYLE_MBR)                               
                    Descriptor->Signature = (( PDRIVE_LAYOUT_INFORMATION )TemporaryBuffer)->Signature;

                Descriptor->DriveLayout = *DriveLayoutEx;

                switch (DriveLayoutEx->PartitionStyle) {
                    case PARTITION_STYLE_MBR:
                        Descriptor->FormatType = DISK_FORMAT_TYPE_PCAT;

                        //
                        // Determine if any INT13 hookers are present
                        //
                        SpDetermineInt13Hookers(Handle, Descriptor);

#if defined(_IA64_)            
                        //
                        // Make sure that this is not a raw disk
                        // which is being faked as MBR disk
                        //
                        if (SpPtnIsRawDiskDriveLayout(DriveLayoutEx)) {
                            Descriptor->FormatType = DISK_FORMAT_TYPE_RAW;
                            SPPT_SET_DISK_BLANK(disk, TRUE);
                        }                                                    
#endif                    
                        
                        break;
                        
                    case PARTITION_STYLE_GPT:
                        Descriptor->FormatType = DISK_FORMAT_TYPE_GPT;
                        break;
                        
                    case PARTITION_STYLE_RAW:                    
                        Descriptor->FormatType = DISK_FORMAT_TYPE_RAW;
                        SPPT_SET_DISK_BLANK(disk, TRUE);
                        
                        break;

                    default:
                        Descriptor->FormatType = DISK_FORMAT_TYPE_UNKNOWN;
                        break;
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: failed to get signature for %ws (%lx)\n",Descriptor->DevicePath,Status));
                Descriptor->Signature = 0;
            }

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: failed to get geometry for %ws (%lx)\n",Descriptor->DevicePath,Status));
            ZwClose(Handle);
            continue;
        }

        //
        // NEC98: force removable media to OFFLINE.
        // Because NEC98 doesnot support FLEX boot, so NT cannot boot up
        // from removable media.
        //
        if (IsNEC_98 && (Descriptor->Characteristics & FILE_REMOVABLE_MEDIA)) {
            Descriptor->Status = DiskOffLine;
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: found removable disk. force offline %ws\n", Descriptor->DevicePath));
        }

        //
        // Now go through the device object to determine the device driver
        // that owns this disk.
        //
        if(OwningDriverName = SpDetermineOwningDriver(Handle)) {

            SpGetDiskInfo(disk,SifHandle,OwningDriverName,Handle,Descriptor);
            SpMemFree(OwningDriverName);
        }

        ZwClose(Handle);
    }

    HardDisksDetermined = TRUE;
    return(STATUS_SUCCESS);
}


VOID
SpGetDiskInfo(
    IN  ULONG      DiskNumber,
    IN  PVOID      SifHandle,
    IN  PWSTR      OwningDriverName,
    IN  HANDLE     Handle,
    OUT PHARD_DISK Descriptor
    )
{
    PWSTR FormatString;
    PWSTR ScsiAdapterName;
    PWSTR PcCardInfoKey;
    SCSI_ADDRESS ScsiAddress;
    NTSTATUS Status;
    ULONG ValLength;
    PKEY_VALUE_PARTIAL_INFORMATION p;
    IO_STATUS_BLOCK IoStatusBlock;
    DISK_CONTROLLER_NUMBER ControllerInfo;

    PcCardInfoKey = NULL;

    //
    // Look up the driver in the map in txtsetup.sif.
    // Note that the driver could be one we don't recognize.
    //
    FormatString = SpGetSectionKeyIndex(SifHandle,SIF_DISKDRIVERMAP,OwningDriverName,0);

#if defined(_AMD64_) || defined(_X86_)
    //
    // Assume not SCSI and thus no scsi-style ARC name.
    //
    Descriptor->ArcPath[0] = 0;
    Descriptor->ScsiMiniportShortname[0] = 0;
#endif // defined(_AMD64_) || defined(_X86_)

    if(FormatString) {

        if(_wcsicmp(OwningDriverName,L"disk")) {

            //
            // Non-scsi.
            //
            SpFormatMessageText(
                Descriptor->Description,
                sizeof(Descriptor->Description),
                FormatString,
                Descriptor->DiskSizeMB
                );

            if(!_wcsicmp(OwningDriverName,L"atdisk")) {

                AtDisksExist = TRUE;

                //
                // Get controller number for atdisks.
                //
                Status = ZwDeviceIoControlFile(
                            Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_DISK_CONTROLLER_NUMBER,
                            NULL,
                            0,
                            &ControllerInfo,
                            sizeof(DISK_CONTROLLER_NUMBER)
                            );

                if(NT_SUCCESS(Status)) {

                    swprintf(
                        TemporaryBuffer,
                        L"%ws\\AtDisk\\Controller %u",
                        szRegDeviceMap,
                        ControllerInfo.ControllerNumber
                        );

                    PcCardInfoKey = SpDupStringW(TemporaryBuffer);

                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to get controller number (%lx)\n",Status));
                }
            } else if(!IsNEC_98) {
                //
                // Not AT disk, might be abios disk. (NEC98 does not have ABIOS disk.)
                //
                if(!_wcsicmp(OwningDriverName,L"abiosdsk")) {
                    AbiosDisksExist = TRUE;
                }
            }

        } else {
            //
            // Scsi. Get disk address info.
            //
            if(SpGetScsiAddress(Handle,&ScsiAddress,&ScsiAdapterName)) {

                swprintf(
                    TemporaryBuffer,
                    L"%ws\\Scsi\\Scsi Port %u",
                    szRegDeviceMap,
                    ScsiAddress.PortNumber
                    );

                PcCardInfoKey = SpDupStringW(TemporaryBuffer);

                SpFormatMessageText(
                    Descriptor->Description,
                    sizeof(Descriptor->Description),
                    FormatString,
                    Descriptor->DiskSizeMB,
                    ScsiAddress.Lun,
                    ScsiAddress.TargetId,
                    ScsiAddress.PathId,
                    ScsiAdapterName
                    );

#if defined(_AMD64_) || defined(_X86_)
                //
                // Generate "secondary" arc path.
                //

                _snwprintf(
                    Descriptor->ArcPath,
                    sizeof(Descriptor->ArcPath)/sizeof(WCHAR),
                    L"scsi(%u)disk(%u)rdisk(%u)",
                    ScsiPortInfo[ScsiAddress.PortNumber].RelativePortNumber,
                    SCSI_COMBINE_BUS_TARGET(ScsiAddress.PathId, ScsiAddress.TargetId),
                    ScsiAddress.Lun
                    );

                wcsncpy(
                    Descriptor->ScsiMiniportShortname,
                    ScsiAdapterName,
                    (sizeof(Descriptor->ScsiMiniportShortname)/sizeof(WCHAR))-1
                    );
#endif // defined(_AMD64_) || defined(_X86_)

                SpMemFree(ScsiAdapterName);

            } else {

                //
                // Some drivers, like SBP2PORT (1394), don't support
                // IOCTL_SCSI_GET_ADDRESS, so just display driver name.
                //

                SpFormatMessage(
                    Descriptor->Description,
                    sizeof (Descriptor->Description),
                    SP_TEXT_UNKNOWN_DISK_2,
                    Descriptor->DiskSizeMB,
                    OwningDriverName
                    );
            }
        }
    }

    //
    // Determine whether the disk is pcmcia.
    //
    if(PcCardInfoKey) {

        Status = SpGetValueKey(
                    NULL,
                    PcCardInfoKey,
                    L"PCCARD",
                    sizeof(TemporaryBuffer),
                    (PCHAR)TemporaryBuffer,
                    &ValLength
                    );

        if(NT_SUCCESS(Status)) {

            p = (PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer;

            if((p->Type == REG_DWORD) && (p->DataLength == sizeof(ULONG)) && *(PULONG)p->Data) {

                Descriptor->PCCard = TRUE;
            }
        }

        SpMemFree(PcCardInfoKey);
    }
}


BOOLEAN
SpGetScsiAddress(
    IN  HANDLE         Handle,
    OUT PSCSI_ADDRESS  ScsiAddress,
    OUT PWSTR         *ScsiAdapterName
    )

/*++

Routine Description:

    Get scsi address information about a device.  This includes
    the port, bus, id, and lun, as well as the shortname of the miniport
    driver that owns the device.

Arguments:

    Handle - handle to open device.

    ScsiAddress - receives port, bus, id, and lun for the device described by Handle.

    ScsiAdapterName - receives pointer to buffer containing shortname
        for miniport driver that owns the device (ie, aha154x).
        The caller must free this buffer via SpMemFree().

Return Value:

    TRUE - scsi address information was determined successfully.
    FALSE - error determining scsi address information.

--*/

{
    NTSTATUS Status;
    PWSTR MiniportName = NULL;
    IO_STATUS_BLOCK IoStatusBlock;

    Status = ZwDeviceIoControlFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_SCSI_GET_ADDRESS,
                NULL,
                0,
                ScsiAddress,
                sizeof(SCSI_ADDRESS)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to get scsi address info (%lx)\n",Status));
        return(FALSE);
    }

    //
    // We can get the miniport name from the scsi port information list
    // we built earlier.
    //
    if(ScsiAddress->PortNumber < ScsiPortCount) {

        MiniportName = ScsiPortInfo[ScsiAddress->PortNumber].MiniportName;

    } else {

        //
        // This should not happen.
        //
        ASSERT(ScsiAddress->PortNumber < ScsiPortCount);

        MiniportName = TemporaryBuffer;
        SpFormatMessage(MiniportName,sizeof(TemporaryBuffer),SP_TEXT_UNKNOWN);
    }

    *ScsiAdapterName = SpDupStringW(MiniportName);

    return(TRUE);
}


PWSTR
SpDetermineOwningDriver(
    IN HANDLE Handle
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_INFORMATION HandleInfo;
    PFILE_OBJECT FileObject;
    ULONG ObjectNameLength;
    POBJECT_NAME_INFORMATION ObjectNameInfo;
    PWSTR OwningDriverName;

    //
    // Get the file object for the disk device.
    //
    Status = ObReferenceObjectByHandle(
                Handle,
                0L,
                *IoFileObjectType,
                ExGetPreviousMode(),
                &FileObject,
                &HandleInfo
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpDetermineOwningDriver: unable to reference object (%lx)\n",Status));
        return(NULL);
    }

    //
    // Follow the links to the driver object and query the name.
    //
    ObjectNameInfo = (POBJECT_NAME_INFORMATION)TemporaryBuffer;

    Status = ObQueryNameString(
                FileObject->DeviceObject->DriverObject,
                ObjectNameInfo,
                sizeof(TemporaryBuffer),
                &ObjectNameLength
                );

    //
    // Dereference the file object now that we've got the name.
    //
    ObDereferenceObject(FileObject);

    //
    // Check the status of the name query.
    //
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpDetermineOwningDriver: unable to query name string (%lx)\n",Status));
        return(NULL);
    }

    //
    // Pull out the name of the owning driver.
    //
    if(OwningDriverName = wcsrchr(ObjectNameInfo->Name.Buffer,L'\\')) {
        OwningDriverName++;
    } else {
        OwningDriverName = ObjectNameInfo->Name.Buffer;
    }

    return(SpDupStringW(OwningDriverName));
}


VOID
SpInitializeScsiPortList(
    VOID
    )
{
    ULONG port;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    HANDLE PortHandle;
    ULONG RelativeNumber;

    //
    // Get the number of scsi ports in the system.
    //
    ScsiPortCount = IoGetConfigurationInformation()->ScsiPortCount;

    //
    // Allocate an array to hold information about each port.
    //
    ScsiPortInfo = SpMemAlloc(ScsiPortCount * sizeof(MY_SCSI_PORT_INFO));
    RtlZeroMemory(ScsiPortInfo,ScsiPortCount * sizeof(MY_SCSI_PORT_INFO));

    //
    // Iterate through the ports.
    //
    for(port=0; port<ScsiPortCount; port++) {

        ScsiPortInfo[port].PortNumber = port;

        //
        // Open \device\scsiport<n> so we can determine the owning miniport.
        //
        swprintf(TemporaryBuffer,L"\\Device\\ScsiPort%u",port);

        INIT_OBJA(&ObjectAttributes,&UnicodeString,TemporaryBuffer);

        Status = ZwCreateFile(
                    &PortHandle,
                    FILE_GENERIC_READ,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                    );

        if(NT_SUCCESS(Status)) {

            ScsiPortInfo[port].MiniportName = SpDetermineOwningDriver(PortHandle);

            ZwClose(PortHandle);

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open \\device\\scsiport%u (%lx)\n",port,Status));
        }

        //
        // Determine relative port number.  If this is port 0 or the current port owner
        // doesn't match the previous port owner, then the relative port number is 0.
        // Otherwise the relative port number is one greater than the previous relative
        // port number.
        //

        if(port && ScsiPortInfo[port-1].MiniportName && ScsiPortInfo[port].MiniportName
        && !_wcsicmp(ScsiPortInfo[port-1].MiniportName,ScsiPortInfo[port].MiniportName)) {
            RelativeNumber++;
        } else {
            RelativeNumber = 0;
        }

        ScsiPortInfo[port].RelativePortNumber = RelativeNumber;
    }
}



NTSTATUS
SpOpenPartition(
    IN  PWSTR   DiskDevicePath,
    IN  ULONG   PartitionNumber,
    OUT HANDLE *Handle,
    IN  BOOLEAN NeedWriteAccess
    )
{
    PWSTR             PartitionPath;
    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS          Status;
    IO_STATUS_BLOCK   IoStatusBlock;

    //
    // Form the pathname of partition.
    //
    PartitionPath = SpMemAlloc((wcslen(DiskDevicePath) * sizeof(WCHAR)) + sizeof(L"\\partition000"));
    if(PartitionPath == NULL) {
        return(STATUS_NO_MEMORY);
    }

    swprintf(PartitionPath,L"%ws\\partition%u",DiskDevicePath,PartitionNumber);

    //
    // Attempt to open partition0.
    //
    INIT_OBJA(&Obja,&UnicodeString,PartitionPath);

    Status = ZwCreateFile(
                Handle,
                FILE_GENERIC_READ | (NeedWriteAccess ? FILE_GENERIC_WRITE : 0),
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws (%lx)\n",PartitionPath,Status));
    }

    SpMemFree(PartitionPath);

    return(Status);
}


NTSTATUS
SpReadWriteDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONGLONG SectorNumber,
    IN     ULONG  SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer,
    IN     BOOLEAN Write
    )

/*++

Routine Description:

    Reads or writes one or more disk sectors.

Arguments:

    Handle - supplies handle to open partition object from which
        sectors are to be read or written.  The handle must be
        opened for synchronous I/O.

Return Value:

    NTSTATUS value indicating outcome of I/O operation.

--*/

{
    LARGE_INTEGER IoOffset;
    ULONG IoSize;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    //
    // Calculate the large integer byte offset of the first sector
    // and the size of the I/O.
    //
    IoOffset.QuadPart = UInt32x32To64(SectorNumber,BytesPerSector);
    IoSize = SectorCount * BytesPerSector;

    //
    // Perform the I/O.
    //
    Status = (NTSTATUS)(

                Write

             ?
                ZwWriteFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    AlignedBuffer,
                    IoSize,
                    &IoOffset,
                    NULL
                    )
             :
                ZwReadFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    AlignedBuffer,
                    IoSize,
                    &IoOffset,
                    NULL
                    )
             );


    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to %s %u sectors starting at sector %u\n",Write ? "write" : "read" ,SectorCount,SectorNumber));
    }

    return(Status);
}


ULONG
SpArcDevicePathToDiskNumber(
    IN PWSTR ArcPath
    )

/*++

Routine Description:

    Given an arc device path, determine which NT disk it represents.

Arguments:

    ArcPath - supplies arc path.

Return Value:

    NT disk ordinal suitable for use in generating nt device paths
    of the form \device\harddiskx.

    -1 if cannot be determined.

--*/

{
    PWSTR NtPath;
    ULONG DiskNumber;
    ULONG PrefixLength;

    //
    // Assume failure.
    //
    DiskNumber = (ULONG)(-1);
    PrefixLength = wcslen(DISK_DEVICE_NAME_BASE);

    //
    // Convert the path to an nt path.
    //
    if((NtPath = SpArcToNt(ArcPath))
    && !_wcsnicmp(NtPath,DISK_DEVICE_NAME_BASE,PrefixLength))
    {
        DiskNumber = (ULONG)SpStringToLong(NtPath+PrefixLength,NULL,10);
        SpMemFree(NtPath);
    }

    return(DiskNumber);
}


BOOLEAN
SpIsRegionBeyondCylinder1024(
    IN PDISK_REGION Region
    )

/*++

Routine Description:

    This routine figures out whether a disk region contains sectors
    that are on cylinders beyond cylinder 1024.

Arguments:

    Region - supplies the disk region for the partition to be checked.

Return Value:

    BOOLEAN - Returns TRUE if the region contains a sector located in cylinder
              1024 or greater. Otherwise returns FALSE.

--*/

{
    ULONGLONG LastSector;
    ULONGLONG LastCylinder;

    if (IsNEC_98) { //NEC98
        //
        // NEC98 has no "1024th cylinder limit".
        //
        return((BOOLEAN)FALSE);
    } //NEC98

    if (Region->DiskNumber == 0xffffffff) {
        return FALSE; //  Partition is a redirected drive
    }

    LastSector = Region->StartSector + Region->SectorCount - 1;
    LastCylinder = LastSector / HardDisks[Region->DiskNumber].SectorsPerCylinder;

    return  ((BOOLEAN)(LastCylinder > 1023));

}

VOID
SpAppendDiskTag(
    IN PHARD_DISK   Disk
    )
{
    if (Disk) {
        PWSTR   TagStart = wcsrchr(Disk->Description, DISK_TAG_START_CHAR);

        if (TagStart) {
            if (wcscmp(TagStart, DiskTags[0]) && wcscmp(TagStart, DiskTags[1]) &&
                wcscmp(TagStart, DiskTags[2]) && wcscmp(TagStart, DiskTags[3]) &&
                wcscmp(TagStart, DiskTags[4])) {

                //
                // not the tag we were looking for
                //
                TagStart = Disk->Description + wcslen(Disk->Description);
            }         
        } else {
            TagStart = Disk->Description + wcslen(Disk->Description);
            *TagStart = L' ';
            TagStart++;            
        }            

        wcscpy(TagStart, DiskTags[Disk->FormatType]);
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spdisk.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdisk.h

Abstract:

    Public header file for disk support module in text setup.

Author:

    Ted Miller (tedm) 27-Aug-1993

Revision History:

--*/


#ifndef _SPDISK_
#define _SPDISK_


//
// The following will be TRUE if hard disks have been determined
// successfully (ie, if SpDetermineHardDisks was successfully called).
//
extern BOOLEAN HardDisksDetermined;



NTSTATUS
SpDetermineHardDisks(
    IN PVOID SifHandle
    );

NTSTATUS
SpOpenPartition(
    IN  PWSTR   DiskDevicePath,
    IN  ULONG   PartitionNumber,
    OUT HANDLE *Handle,
    IN  BOOLEAN NeedWriteAccess
    );

#define SpOpenPartition0(path,handle,write)  SpOpenPartition((path),0,(handle),(write))

NTSTATUS
SpReadWriteDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONGLONG SectorNumber,
    IN     ULONG   SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer,
    IN     BOOLEAN Write
    );

ULONG
SpArcDevicePathToDiskNumber(
    IN PWSTR ArcPath
    );

#define DISK_DEVICE_NAME_BASE   L"\\device\\harddisk"

//
// Define enumerated type for possible states a hard disk can be in.
//
typedef enum {
    DiskOnLine,
    DiskOffLine
} DiskStatus;

//
// Int13 hooker types.
//
typedef enum {
    NoHooker = 0,
    HookerEZDrive,
    HookerOnTrackDiskManager,
    HookerMax
} Int13HookerType;




//
// Define per-disk structure used internally to track hard disks.
//
typedef struct _HARD_DISK {

    //
    // Cylinder count we got back from the i/o system.
    //
    ULONGLONG     CylinderCount;

    //
    // Path in the NT namespace of the device.
    //
    WCHAR DevicePath[(sizeof(DISK_DEVICE_NAME_BASE)+sizeof(L"000"))/sizeof(WCHAR)];

    //
    // Geometry information.
    //
    DISK_GEOMETRY Geometry;
    ULONG         SectorsPerCylinder;
    ULONGLONG     DiskSizeSectors;
    ULONG         DiskSizeMB;

    //
    // Characteristics of the device (remoavable, etc).
    //
    ULONG Characteristics;

    //
    // Status of the device.
    //
    DiskStatus Status;

    //
    // Human-readable description of the disk device.
    //
    WCHAR Description[256];

    //
    // If the disk is a scsi disk, then the shortname of the
    // scsi miniport driver is stored here. If this string
    // is empty, then the disk is not a scsi disk.
    //
    WCHAR ScsiMiniportShortname[24];

    //
    // scsi-style ARC path of the disk device if possible for the disk.
    // Empty string if not. This is used to translate between scsi-style ARC
    // NT names because the 'firmware' cannot see scsi devices without BIOSes
    // and so they do not appear in the arc disk info passed by the osloader.
    // (IE, there are no arc names in the system for such disks).
    //
    WCHAR ArcPath[128];

    //
    // Int13 hooker support (ie, EZDrive).
    //
    Int13HookerType Int13Hooker;

    //
    // This tells us whether the disk is PCMCIA or not.
    //
    BOOLEAN PCCard;

    //
    // Contains the signature of the disk. This is used during the
    // identification of FT partitions, on the upgrade case.
    //
    ULONG Signature;

    //
    // MBR type: formatted for PC/AT or NEC98.
    //
    UCHAR FormatType;

    //
    // Wether the disk completely free
    //
    BOOLEAN NewDisk;    

    //
    // The drive information we read
    // 
    DRIVE_LAYOUT_INFORMATION_EX     DriveLayout;
    
#if 0
    //
    // Number of partition tables (are different between PC/AT and NEC98).
    //
    USHORT MaxPartitionTables;
#endif //0

} HARD_DISK, *PHARD_DISK;

#define DISK_FORMAT_TYPE_UNKNOWN 0x00
#define DISK_FORMAT_TYPE_PCAT    0x01
#define DISK_FORMAT_TYPE_NEC98   0x02
#define DISK_FORMAT_TYPE_GPT     0x03
#define DISK_FORMAT_TYPE_RAW     0x04

#define DISK_TAG_TYPE_UNKNOWN   L"[Unknown]"
#define DISK_TAG_TYPE_PCAT      L"[MBR]"
#define DISK_TAG_TYPE_NEC98     L"[NEC98]"
#define DISK_TAG_TYPE_GPT       L"[GPT]"
#define DISK_TAG_TYPE_RAW       L"[Raw]"
#define DISK_TAG_START_CHAR     L'['

extern WCHAR   *DiskTags[];

VOID
SpAppendDiskTag(
    IN PHARD_DISK Disk
    );

//
// These two globals track the hard disks attached to the computer.
//
extern PHARD_DISK HardDisks;
extern ULONG      HardDiskCount;

//
// These flags get set to TRUE if we find any disks owned
// by ATDISK or ABIOSDSK.
//
extern BOOLEAN AtDisksExist,AbiosDisksExist;

#endif // ndef _SPDISK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spddlang.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    spddlang.h

Abstract:

    Header file for language/locale support interface
    for Far East localizations.

Author:

    Ted Miller (tedm) 4-July-1995

Revision History:

--*/

#ifndef _SPDDLANG_H_
#define _SPDDLANG_H_

NTSTATUS
SplangInitializeFontSupport(
    IN PCWSTR BootDevicePath,
    IN PCWSTR DirectoryOnBootDevice,
    IN PVOID BootFontImage,
    IN ULONG BootFontImageLength
    );

NTSTATUS
SplangTerminateFontSupport(
    VOID
    );

typedef enum {
    SpVideoVga = 0,
    SpVideoFrameBuffer,
    SpVideoMax
} SpVideoType;

PVIDEO_FUNCTION_VECTOR
SplangGetVideoFunctionVector(
    IN SpVideoType VideoType,
    IN PSP_VIDEO_VARS VideoVariableBlock
    );

ULONG
SplangGetColumnCount(
    IN PCWSTR String
    );

PWSTR
SplangPadString(
    IN int    Size,
    IN PCWSTR String
    );

VOID
SplangSelectKeyboard(
    IN BOOLEAN UnattendedMode,
    IN PVOID UnattendedSifHandle,
    IN ENUMUPGRADETYPE NTUpgrade,
    IN PVOID SifHandle,
    IN PHARDWARE_COMPONENT *HwComponents
    );

VOID
SplangReinitializeKeyboard(
    IN BOOLEAN UnattendedMode,
    IN PVOID   SifHandle,
    IN PWSTR   Directory,
    OUT PVOID *KeyboardVector,
    IN PHARDWARE_COMPONENT *HwComponents
    );

WCHAR
SplangGetLineDrawChar(
    IN LineCharIndex WhichChar
    );

WCHAR
SplangGetCursorChar(
    VOID
    );

NTSTATUS
SplangSetRegistryData(
    IN PVOID  SifHandle,
    IN HANDLE ControlSetKeyHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN BOOLEAN Upgrade
    );

BOOLEAN
SplangQueryMinimizeExtraSpacing(
    VOID
    );

#endif // _SPDDLANG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spdbsfmt.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdblfmt.c

Abstract:

    This file contains the functions that format an existing compressed
    drive.
    To format a compressed drive we have to unmount the drive, map its
    cvf file in memory, initialize its varios regions, unmap the file
    from memory, and mount the drive.

Author:

    Jaime Sasson (jaimes) 15-October-1993

Revision History:

--*/

#include "spprecmp.h"
#pragma hdrstop

#include "cvf.h"

#define MIN_CLUS_BIG    4085        // Minimum clustre for a big fat.

//
//  This variable is needed since it contains a buffer that can
//  be used in kernel mode. The buffer is used by NtSetInformationFile,
//  since the Zw API is not exported
//
extern PSETUP_COMMUNICATION  CommunicationParams;

//
//  Global variables
//

HANDLE  _FileHandle = NULL;
HANDLE  _SectionHandle = NULL;
PVOID   _FileBaseAddress = NULL;
ULONG   _ViewSize = 0;
ULONG   _Maximumcapacity = 0;

NTSTATUS
SpChangeFileAttribute(
    IN  PWSTR   FileName,
    IN  ULONG   FileAttributes
    )

/*++

Routine Description:

    Change the attributes of a file.

Arguments:

    FileName - Contains the file's full path (NT name).

    FileAttributes - New desired file attributes.


Return Value:

    NTSTATUS - Returns a NT status code indicating whether or not
               the operation succeeded.

--*/

{
    NTSTATUS                Status;
    UNICODE_STRING          UnicodeFileName;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    IO_STATUS_BLOCK         IoStatusBlock;
    PIO_STATUS_BLOCK        KernelModeIoStatusBlock;
    HANDLE                  Handle;
    PFILE_BASIC_INFORMATION KernelModeBasicInfo;

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: Entering SpChangeFileAttribute() \n" ) );

    RtlInitUnicodeString( &UnicodeFileName,
                          FileName );

    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = ZwOpenFile( &Handle,
                         FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwOpenFile() failed. Status = %x\n",Status ) );
        return( Status );
    }

    //
    // Set attributes.
    // Note that since we use the NtSetInformationFile API instead of the
    // Zw API (this one is not exported), we need a buffer for IoStatusBlock
    // and for FileBasicInformation, that can be used in kernel mode.
    // We use the the region of memory pointed by CommunicationParams for this
    // purpose.
    //
    KernelModeIoStatusBlock = ( PIO_STATUS_BLOCK )( &(CommunicationParams->Buffer[0]) );
    *KernelModeIoStatusBlock = IoStatusBlock;
    KernelModeBasicInfo = ( PFILE_BASIC_INFORMATION )( &(CommunicationParams->Buffer[128]) );
    RtlZeroMemory( KernelModeBasicInfo, sizeof( FILE_BASIC_INFORMATION ) );
    KernelModeBasicInfo->FileAttributes = ( FileAttributes & FILE_ATTRIBUTE_VALID_FLAGS ) | FILE_ATTRIBUTE_NORMAL;

    Status = NtSetInformationFile( Handle,
                                   KernelModeIoStatusBlock,
                                   KernelModeBasicInfo,
                                   sizeof( FILE_BASIC_INFORMATION ),
                                   FileBasicInformation );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: NtSetInformationFile failed, Status = %x\n", Status) );
    }
    ZwClose( Handle );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: Exiting SpChangeFileAttribute() \n" ) );
    return( Status );
}

NTSTATUS
SpMapCvfFileInMemory(
    IN  PWSTR    FileName
    )

/*++

Routine Description:

    Map a CVF file in memory.

Arguments:

    FileName - Contains the file's full path (NT name).


Return Value:

    NTSTATUS - Returns a NT status code indicating whether or not
               the operation succeeded.
               If the file is mapped successfully, this function will
               initialize the global variables _FileHandle, _SectionHandle,
               and _FileBaseAddress.

--*/

{
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeFileName;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    LARGE_INTEGER       SectionOffset;

    //
    //  Open the CVF file for READ and WRITE access
    //
    RtlInitUnicodeString( &UnicodeFileName,
                          FileName );

    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = ZwOpenFile( &_FileHandle,
                         FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         0,
                         FILE_SYNCHRONOUS_IO_NONALERT );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwOpenFile() failed. Status = %x\n",Status ) );
        return( Status );
    }

    //
    //  Map the CVF file in memory
    //
    Status =
        ZwCreateSection( &_SectionHandle,
                         STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
                         NULL,
                         NULL,       // entire file.
                         PAGE_READWRITE,
                         SEC_COMMIT,
                         _FileHandle
                       );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwCreateSection failed, Status = %x\n",Status));
        ZwClose( _FileHandle );
        _FileHandle = NULL;
        return(Status);
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    _ViewSize = 0;
    Status = ZwMapViewOfSection( _SectionHandle,
                                 NtCurrentProcess(),
                                 &_FileBaseAddress,
                                 0,
                                 0,
                                 &SectionOffset,
                                 &_ViewSize,
                                 ViewShare,
                                 0,
                                 PAGE_READWRITE
                               );

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "File size = %x\n", _ViewSize ) );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwMapViewOfSection failed, Status = %x\n", Status));
        ZwClose( _SectionHandle );
        ZwClose( _FileHandle );
        _FileBaseAddress = NULL;
        _SectionHandle = NULL;
        _FileHandle = NULL;
        return(Status);
    }
    return( Status );
}


NTSTATUS
SpUnmapCvfFileFromMemory(
    IN  BOOLEAN SaveChanges
    )

/*++

Routine Description:

    Unmap the CFV file previously mapped in memory.

Arguments:

    SaveChanges - Indicates whether or not the caller wants the changes made
                  to the file flushed to disk.


Return Value:

    NTSTATUS - Returns a NT status code indicating whether or not
               the operation succeeded.
               This function clears the global variables _FileHandle, _SectionHandle,
               and _FileBaseAddress.

--*/

{
    NTSTATUS        Status;
    NTSTATUS        PreviousStatus;


//    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: Entering SpUnmapCvfFileFromMemory \n" ) );
    PreviousStatus = STATUS_SUCCESS;
    if( SaveChanges ) {
        Status = SpFlushVirtualMemory( _FileBaseAddress,
                                       _ViewSize );
//
//        Status = NtFlushVirtualMemory( NtCurrentProcess(),
//                                       &_FileBaseAddress,
//                                       &_ViewSize,
//                                       &IoStatus );
//
        if( !NT_SUCCESS( Status ) ) {
            PreviousStatus = Status;
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpFlushVirtualMemory() failed, Status = %x\n", Status ) );
        }
    }
    Status = ZwUnmapViewOfSection( NtCurrentProcess(), _FileBaseAddress );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwUnmapViewOfSection() failed, Status = %x \n", Status ) );
    }
    ZwClose( _SectionHandle );
    ZwClose( _FileHandle );
    _FileHandle = NULL;
    _SectionHandle = NULL;
    _FileBaseAddress = NULL;
    if( !NT_SUCCESS( PreviousStatus ) ) {
        return( PreviousStatus );
    }
//    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: Exiting SpUnmapCvfFileFromMemory \n" ) );
    return( Status );
}

ULONG
ComputeMaximumCapacity(
    IN ULONG HostDriveSize
    )
/*++

Routine Description:

    This function computes the maximum capacity for a compressed
    volume file on a host volume of a given size.

Arguments:

    HostDriveSize   --  Supplies the size in bytes of the host drive.

Return Value:

    The appropriate Maximum Capacity.

--*/
{
    ULONG MaxCap;

    if( HostDriveSize < 20 * 1024L * 1024L ) {

        MaxCap = 16 * HostDriveSize;

    } else if ( HostDriveSize < 64 * 1024L * 1024L ) {

        MaxCap = 8 * HostDriveSize;

    } else {

        MaxCap = 4 * HostDriveSize;
    }

    if( MaxCap < 4 * 1024L * 1024L ) {

        MaxCap = 4 * 1024L * 1024L;

    } else if( MaxCap > 512 * 1024L * 1024L ) {

        MaxCap = 512 * 1024L * 1024L;
    }

    return MaxCap;
}


BOOLEAN
CreateCvfHeader(
    OUT    PCVF_HEADER  CvfHeader,
    IN     ULONG        MaximumCapacity
    )
/*++

Routine Description:

    This function creates a Compressed Volume File and fills in
    the first sector with a valid CVF Header.  The number of sectors
    in the DOS BPB is set to zero, to indicate that this volume
    file is not initialized.

Arguments:

    CvfHeader       --  Receives the created CVF header.
    MaximumCapacity --  Supplies the maximum capacity for the
                        double-space volume, in bytes.

Return Value:

    TRUE upon successful completion.

--*/
{
    ULONG Sectors, Clusters, Offset, SectorsInBitmap, SectorsInCvfFatExtension;

    if( MaximumCapacity % (8L * 1024L * 1024L) ) {

        // The volume maximum capacity must be a multiple of
        // eight megabytes.
        //
        return FALSE;
    }

    // Most of the fields in the DOS BPB have fixed values:
    //
    CvfHeader->Jump = 0xEB;
    CvfHeader->JmpOffset = 0x903c;

    memcpy( CvfHeader->Oem, "MSDSP6.0", 8 );

    CvfHeader->Bpb.BytesPerSector = DoubleSpaceBytesPerSector;
    CvfHeader->Bpb.SectorsPerCluster = DoubleSpaceSectorsPerCluster;
    // ReservedSectors computed below.
    CvfHeader->Bpb.Fats = DoubleSpaceFats;
    CvfHeader->Bpb.RootEntries = DoubleSpaceRootEntries;
    CvfHeader->Bpb.Sectors = 0;
    CvfHeader->Bpb.Media = DoubleSpaceMediaByte;
    // SectorsPerFat computed below.
    CvfHeader->Bpb.SectorsPerTrack = DoubleSpaceSectorsPerTrack;
    CvfHeader->Bpb.Heads = DoubleSpaceHeads;
    CvfHeader->Bpb.HiddenSectors = DoubleSpaceHiddenSectors;
    CvfHeader->Bpb.LargeSectors = 0;

    // Compute the number of sectors and clusters for the given
    // maximum capacity:
    //
    Sectors = MaximumCapacity / CvfHeader->Bpb.BytesPerSector;
    Clusters = Sectors / CvfHeader->Bpb.SectorsPerCluster;

    // Reserve space for a 16-bit FAT that's big enough for the
    // maximum number of clusters.
    //
    CvfHeader->Bpb.SectorsPerFat =
        ( USHORT )( (2 * Clusters + CvfHeader->Bpb.BytesPerSector - 1)/
                    CvfHeader->Bpb.BytesPerSector );

    // DOS 6.2 requires that the first sector of the Sector Heap
    // be cluster aligned; since the Root Directory is one cluster,
    // this means that ReservedSectors plus SectorsPerFat must be
    // a multiple of SectorsPerCluster.
    //
    CvfHeader->Bpb.ReservedSectors = DoubleSpaceReservedSectors;

    Offset = (CvfHeader->Bpb.ReservedSectors + CvfHeader->Bpb.SectorsPerFat) %
             CvfHeader->Bpb.SectorsPerCluster;

    if( Offset != 0 ) {

        CvfHeader->Bpb.ReservedSectors +=
            ( USHORT )( CvfHeader->Bpb.SectorsPerCluster - Offset );
    }

    // So much for the DOS BPB.  Now for the Double Space
    // BPB extensions.  The location of the CVFFatExtension
    // table is preceded by sector zero, the bitmap, and
    // one reserved sector.  Note that MaximumCapacity must
    // be a multiple of 8 Meg (8 * 1024 * 1024), which simplifies
    // calculation of SectorsInBitmap, SectorsInCvfFatExtension,
    // and CvfBitmap2KSize.
    //
    SectorsInBitmap = (Sectors / 8) / CvfHeader->Bpb.BytesPerSector;
    SectorsInCvfFatExtension = (Clusters * 4) / CvfHeader->Bpb.BytesPerSector;

    CvfHeader->CvfFatExtensionsLbnMinus1 = ( UCHAR )( SectorsInBitmap + 1 );
    CvfHeader->LogOfBytesPerSector = DoubleSpaceLog2BytesPerSector;
    CvfHeader->DosBootSectorLbn = ( USHORT )( DoubleSpaceReservedSectors2 +
                                              CvfHeader->CvfFatExtensionsLbnMinus1 + 1 +
                                              SectorsInCvfFatExtension );
    CvfHeader->DosRootDirectoryOffset =
        CvfHeader->Bpb.ReservedSectors + CvfHeader->Bpb.SectorsPerFat;
    CvfHeader->CvfHeapOffset =
        CvfHeader->DosRootDirectoryOffset + DoubleSpaceSectorsInRootDir;
    CvfHeader->CvfFatFirstDataEntry =
        CvfHeader->CvfHeapOffset / CvfHeader->Bpb.SectorsPerCluster - 2;
    CvfHeader->CvfBitmap2KSize = ( UCHAR )( SectorsInBitmap / DSSectorsPerBitmapPage );
    CvfHeader->LogOfSectorsPerCluster = DoubleSpaceLog2SectorsPerCluster;
    CvfHeader->Is12BitFat = 1;

    CvfHeader->MinFile = 32L * DoubleSpaceRootEntries +
                           ( CvfHeader->DosBootSectorLbn    +
                             CvfHeader->Bpb.ReservedSectors +
                             CvfHeader->Bpb.SectorsPerFat   +
                             CVF_MIN_HEAP_SECTORS ) *
                           CvfHeader->Bpb.BytesPerSector;

    CvfHeader->CvfMaximumCapacity = (USHORT)(MaximumCapacity/(1024L * 1024L));

    return TRUE;
}

ULONG
ComputeVirtualSectors(
    IN  PCVF_HEADER CvfHeader,
    IN  ULONG       HostFileSize
    )
/*++

Routine Description:

    This function computes the appropriate number of virtual
    sectors for the given Compressed Volume File.  Note that
    it always uses a ratio of 2.

Arguments:

    CvfHeader       --  Supplies the Compressed Volume File Header.
    HostFileSize    --  Supplies the size of the host file in bytes.

Return Value:

    The number of virtual sectors appropriate to this Compressed
    Volume File.

--*/
{
    CONST DefaultRatio = 2;
    ULONG SystemOverheadSectors, SectorsInFile,
          VirtualSectors, MaximumSectors, VirtualClusters;

    if( CvfHeader == NULL                    ||
        CvfHeader->Bpb.BytesPerSector == 0   ||
        CvfHeader->Bpb.SectorsPerCluster == 0 ) {

        return 0;
    }

    SystemOverheadSectors = CvfHeader->DosBootSectorLbn +
                            CvfHeader->CvfHeapOffset +
                            2;

    SectorsInFile = HostFileSize / CvfHeader->Bpb.BytesPerSector;

    if( SectorsInFile < SystemOverheadSectors ) {

        return 0;
    }

    VirtualSectors = (SectorsInFile - SystemOverheadSectors) * DefaultRatio +
                     CvfHeader->CvfHeapOffset;

    // VirtualSectors cannot result in more that 0xfff8 clusters on
    // the volume, nor can it be greater than the volume's maximum
    // capacity.
    //
    VirtualSectors = min( VirtualSectors,
                          ( ULONG )( 0xfff8L * CvfHeader->Bpb.SectorsPerCluster ) );

    MaximumSectors = (CvfHeader->CvfMaximumCapacity * 1024L * 1024L) /
                     CvfHeader->Bpb.BytesPerSector;

    VirtualSectors = min( VirtualSectors, MaximumSectors );

    // To avoid problems with DOS, do not create a volume with
    // a number-of-clusters value in the range [0xFEF, 0xFF7].
    //
    VirtualClusters = VirtualSectors / CvfHeader->Bpb.SectorsPerCluster;

    if( VirtualClusters >= 0xFEF && VirtualClusters <= 0xFF7 ) {

        VirtualSectors = 0xFEEL * CvfHeader->Bpb.SectorsPerCluster;
    }

    return VirtualSectors;
}


NTSTATUS
SpDoubleSpaceFormat(
    IN PDISK_REGION Region
    )
/*++

Routine Description:

    This routine does a DoubleSpace format on the given partition.

    The caller should have cleared the screen and displayed
    any message in the upper portion; this routine will
    maintain the gas gauge in the lower portion of the screen.

Arguments:

    Region - supplies the disk region descriptor for the
        partition to be formatted.

Return Value:


--*/
{
    WCHAR       CvfFileName[ 512 ];
    NTSTATUS    Status;
    PUCHAR      BaseAddress;
    ULONG       BytesPerSector;
    PHARD_DISK  pHardDisk;
    ULONG       MaximumCapacity;
    CVF_HEADER  CvfHeader;
    ULONG       BitFatSize;
    ULONG       MdFatSize;
    ULONG       Reserved2Size;
    ULONG       SuperAreaSize;
    UCHAR       SystemId;
    ULONG       max_sec_per_sa;
    ULONG       FatSize;
    ULONG       RootDirectorySize;

    ASSERT(Region->Filesystem == FilesystemDoubleSpace);
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Entering SpFormatDoubleSpace() \n") );

    SpNtNameFromRegion(
        Region,
        CvfFileName,
        sizeof(CvfFileName),
        PartitionOrdinalCurrent
        );

    CvfFileName[ wcslen( CvfFileName ) - (3+1+8+1) ] = ( WCHAR )'\\';
    //
    // Change the CVF file attribute to NORMAL
    //
    Status = SpChangeFileAttribute( CvfFileName, FILE_ATTRIBUTE_NORMAL );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: Unable to change attribute of %ls \n", CvfFileName ) );
        return( Status );
    }

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: CvfFileName = %ls \n", CvfFileName ) );
    Status = SpMapCvfFileInMemory( CvfFileName );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: Unable to map CVF file in memory \n" ) );
        SpChangeFileAttribute( CvfFileName,
                               FILE_ATTRIBUTE_READONLY |
                               FILE_ATTRIBUTE_HIDDEN |
                               FILE_ATTRIBUTE_SYSTEM );
        return( Status );
    }
//    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: CVF file is mapped in memory \n" ) );

    //
    // Compute the maximum capacity of the compressed drive.
    // The capacity of the compressed drive is based on the
    // size of the host size.
    //
    // Note that MaximumCapacity is rounded up to the next
    // highest multiple of 8 Meg.
    //

    pHardDisk = &HardDisks[Region->HostRegion->DiskNumber];
    BytesPerSector = pHardDisk->Geometry.BytesPerSector;
    MaximumCapacity = ComputeMaximumCapacity( Region->HostRegion->SectorCount * BytesPerSector );
    MaximumCapacity = ( ( MaximumCapacity + EIGHT_MEG - 1 ) / EIGHT_MEG ) * EIGHT_MEG;
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: MaximumCapacity = %x\n", MaximumCapacity ));
    //
    // Create the Compressed Volume File Header:
    //
    CreateCvfHeader( &CvfHeader, MaximumCapacity );

    //
    // Now fill in the value of Virtual Sectors.
    //
    CvfHeader.Bpb.LargeSectors = ComputeVirtualSectors( &CvfHeader, _ViewSize );
    if( CvfHeader.Bpb.LargeSectors >= ( ULONG )( MIN_CLUS_BIG*DoubleSpaceSectorsPerCluster ) ) {
        CvfHeader.Is12BitFat = ( UCHAR )0;
    }

    BaseAddress = ( PUCHAR )_FileBaseAddress;
    memset( BaseAddress, 0, BytesPerSector );

    //
    //  Write the CVF Header
    //
    CvfPackCvfHeader( ( PPACKED_CVF_HEADER )_FileBaseAddress, &CvfHeader );

#if 0
KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: CalculatedMaximumCapacity = %x, MaximumCapacity = %x \n",
             (USHORT)CvfHeader.CvfMaximumCapacity,
            *((PUSHORT)((ULONG)_FileBaseAddress + 62))
            ) );
#endif

    //
    // Initialize the BitFAT area
    //
    BaseAddress += BytesPerSector;
    BitFatSize = MaximumCapacity / ( BytesPerSector*8 );
    memset( BaseAddress, 0, BitFatSize );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: BitFAT address = %x, BitFAT size = %x\n", BaseAddress, BitFatSize ));

    //
    // Initialize the 1st reserved area (Reserved1)
    //
    BaseAddress += BitFatSize;
    memset( BaseAddress, 0, BytesPerSector );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: Reserved1 address = %x, Reserved1 size = %x\n", BaseAddress, BytesPerSector ));

    //
    // Initialize MDFAT
    //

    BaseAddress += BytesPerSector;
    MdFatSize = 4*( MaximumCapacity/( BytesPerSector*CvfHeader.Bpb.SectorsPerCluster ) );
    memset( BaseAddress, 0, MdFatSize );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: MDFAT address = %x, MDFAT size = %x\n", BaseAddress, MdFatSize ));

    //
    // Initialize the 2nd reserved area (Reserved2)
    //

    BaseAddress += MdFatSize;
    Reserved2Size = DoubleSpaceReservedSectors2*BytesPerSector;
    memset( BaseAddress, 0, Reserved2Size );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: Reserved2 address = %x, Reserved2 size = %x\n", BaseAddress, Reserved2Size ));

    //
    // Initialize Boot Sector
    //

    max_sec_per_sa = 1 +
                     2*((2*65536 - 1)/BytesPerSector + 1) +
                     ((512*32 - 1)/BytesPerSector + 1);
    BaseAddress += Reserved2Size;
    FmtFillFormatBuffer( ( ULONG )CvfHeader.Bpb.LargeSectors,
                         ( ULONG )( ( USHORT )CvfHeader.Bpb.BytesPerSector ),
                         ( ULONG )( ( USHORT )CvfHeader.Bpb.SectorsPerTrack ),
                         ( ULONG )( ( USHORT )CvfHeader.Bpb.Heads ),
                         ( ULONG )CvfHeader.Bpb.HiddenSectors,
                         BaseAddress,
                         max_sec_per_sa,
                         &SuperAreaSize,
                         NULL,
                         0,
                         &SystemId );


    //
    // Initialize the 3rd reserved area (Reserved3)
    //

    BaseAddress += BytesPerSector;
    memcpy( BaseAddress, FirstDbSignature, DbSignatureLength );

    //
    // Initialize the FAT area
    //
    BaseAddress += ( ( ULONG )CvfHeader.Bpb.ReservedSectors - 1 )*BytesPerSector;;
    FatSize = ( ULONG )CvfHeader.Bpb.SectorsPerFat * BytesPerSector;
    memset( BaseAddress, 0, FatSize );
    *BaseAddress = 0xF8;
    *( BaseAddress + 1 ) = 0xFF;
    *( BaseAddress + 2 ) = 0xFF;
    if( CvfHeader.Is12BitFat == 0 ) {
        *( BaseAddress + 3 ) = 0xFF;
    }
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: FAT address = %x, Fat size = %x\n", BaseAddress, FatSize ));

    //
    // Initialize the Root Directory area
    //

    BaseAddress += FatSize;
    RootDirectorySize = DoubleSpaceSectorsInRootDir*BytesPerSector;
    memset( BaseAddress, 0, RootDirectorySize );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: RootDirectory address = %x, RootDirectory size = %x\n", BaseAddress, RootDirectorySize ));

    //
    // Initialization of the 4th reserved area (Reserved4) is not necessary
    //

    //
    // Initialization of the sector heap is not necessary
    //

    //
    // Initialize the 2nd stamp
    //

    BaseAddress = ( PUCHAR )(( ULONG )_FileBaseAddress + _ViewSize - BytesPerSector);
    memset( BaseAddress, 0, BytesPerSector );
    memcpy( BaseAddress, SecondDbSignature, DbSignatureLength );
// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SecondStamp address = %x, SecondStamp size = %x\n", BaseAddress, BytesPerSector ));

// KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: _FileBaseAddress = %lx, _ViewSize = %lx\n", _FileBaseAddress, _ViewSize ) );


    SpUnmapCvfFileFromMemory( TRUE );

    SpChangeFileAttribute( CvfFileName,
                           FILE_ATTRIBUTE_READONLY |
                           FILE_ATTRIBUTE_HIDDEN |
                           FILE_ATTRIBUTE_SYSTEM );
    return( Status );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spdrmmgr.c ===
/*++
Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdrmmgr.c

Abstract:

Revision History:
    Initial Code                Michael Peterson (v-michpe)     13.Dec.1997
    Code cleanup and changes    Guhan Suriyanarayanan (guhans)  21.Aug.1999

--*/
#include "spprecmp.h"
#pragma hdrstop

#define THIS_MODULE L"spdrmmgr.c"
#define THIS_MODULE_CODE  L"M"

#define DOS_DEVICES             L"\\DosDevices\\?:"
#define DOS_DEVICES_DRV_LTR_POS 12

typedef struct _NAMETABLE {
    ULONG Elements;
    PWSTR SymbolicName[1];
} NAMETABLE, *PNAMETABLE;


// Imported from sppartit.c
extern WCHAR
SpDeleteDriveLetter(IN PWSTR DeviceName);


NTSTATUS
SpAsrOpenMountManager(
    OUT HANDLE *Handle
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;

    INIT_OBJA(&objectAttributes, &unicodeString, MOUNTMGR_DEVICE_NAME);
    status = ZwOpenFile(Handle,
                (ACCESS_MASK)(FILE_GENERIC_READ),
                &objectAttributes,
                &ioStatusBlock,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE ,
                FILE_NON_DIRECTORY_FILE
                );

    if (!NT_SUCCESS(status)) {
        DbgErrorMesg((_asrerr, "Could not open the mount manager (0x%x). \n", status));
        ASSERT(0 && L"Could not open mount manager");
    }
    return status;
}


VOID
SpAsrAllocateMountPointForCreate(
    IN PWSTR PartitionDeviceName,
    IN PWSTR MountPointNameString,
    OUT PMOUNTMGR_CREATE_POINT_INPUT *pMpt,
    OUT ULONG *MountPointSize
    )
{
    PMOUNTMGR_CREATE_POINT_INPUT pMountPoint = NULL;

    *pMpt = NULL;
    *MountPointSize = sizeof(MOUNTMGR_CREATE_POINT_INPUT) +
        (wcslen(PartitionDeviceName) + wcslen(MountPointNameString)) * sizeof(WCHAR);

    pMountPoint = (PMOUNTMGR_CREATE_POINT_INPUT) SpAsrMemAlloc(*MountPointSize, TRUE); // does not return on failure

    pMountPoint->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    pMountPoint->SymbolicLinkNameLength = wcslen(MountPointNameString) * sizeof(WCHAR);
    RtlCopyMemory(((PCHAR) pMountPoint + pMountPoint->SymbolicLinkNameOffset),
        MountPointNameString,
        pMountPoint->SymbolicLinkNameLength
        );

    pMountPoint->DeviceNameLength = (USHORT) (wcslen(PartitionDeviceName) * sizeof(WCHAR));
    pMountPoint->DeviceNameOffset = (USHORT) pMountPoint->SymbolicLinkNameOffset +
        pMountPoint->SymbolicLinkNameLength;
    RtlCopyMemory(((PCHAR)pMountPoint + pMountPoint->DeviceNameOffset),
        PartitionDeviceName, 
        pMountPoint->DeviceNameLength
        );

    *pMpt = pMountPoint;
}



NTSTATUS
SpAsrCreateMountPoint(
    IN PWSTR PartitionDeviceName,
    IN PWSTR MountPointNameString
    )
/*++
Description:

    Creates the specified mount point for the specified partition region.
    These strings will usually be in the form of a symbolic names, such as:

                "\DosDevices\?:"

    Where ? can be any supported drive letter,
    or,
    a GUID string in the form of, for example:
    
                "\??\Volume{1234abcd-1234-5678-abcd-000000000000}"


Arguments:

    PartitionDeviceName    Specifies the partitioned region portion of the 
                           mount point.

    MountPointNameString   Specifies the symbolic name to be associated with
                           the specified partition.

Returns:

    NTSTATUS

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE handle = NULL;
    ULONG mountPointSize = 0;
    PMOUNTMGR_CREATE_POINT_INPUT pMountPoint = NULL;

    //
    // Create the input structure.
    //
    SpAsrAllocateMountPointForCreate(PartitionDeviceName,
        MountPointNameString,
        &pMountPoint,
        &mountPointSize
        );

    status = SpAsrOpenMountManager(&handle);
    if (!NT_SUCCESS(status)) {
        
        DbgFatalMesg((_asrerr, "SpAsrCreateMountPoint([%ws],[%ws]). SpAsrOpenMountManager failed (0x%x). mountPointSize:%lu handle:0x%x.\n",
            PartitionDeviceName, 
            MountPointNameString, 
            status, 
            mountPointSize, 
            handle
            ));

        SpMemFree(pMountPoint);
        //
        // There's nothing the user can do in this case. 
        //
        INTERNAL_ERROR(L"SpAsrOpenMountManager() Failed");            // ok
        // does not return
    }

    //
    // IOCTL_CREATE_POINT
    //
    status = ZwDeviceIoControlFile(handle,
        NULL,
        NULL,
        NULL,
        &ioStatusBlock,
        IOCTL_MOUNTMGR_CREATE_POINT,
        pMountPoint,
        mountPointSize,
        NULL,
        0
        );

    if (!NT_SUCCESS(status)) {
        //
        // We couldn't restore the volume guid for this volume.  This is expected if the
        // volume is on a non-critical disk--we only recreate critical disks in textmode
        // Setup.
        //
        DbgErrorMesg((_asrwarn, "SpAsrCreateMountPoint([%ws], [%ws]). ZwDeviceIoControlFile(IOCTL_MOUNTMGR_CREATE_POINT) failed (0x%x). handle:0x%x, pMountPoint:0x%x, mountPointSize:0x%x\n",
            PartitionDeviceName,
            MountPointNameString,
            status,
            handle,
            pMountPoint,
            mountPointSize
            ));
    }

    SpMemFree(pMountPoint);
    ZwClose(handle);

    return status;
}

//////////////////////////////////////////////////////////////////////////////
//                      EXPORTED FUNCTIONS                                  //
//////////////////////////////////////////////////////////////////////////////


NTSTATUS
SpAsrSetPartitionDriveLetter(
    IN PDISK_REGION pRegion,
    IN WCHAR NewDriveLetter
    )
/*++
Description:

    Checks whether a drive letter exists for the specified partitioned region.
    If one does, then if the existing drive letter is the same as the 
    specified drive letter, return STATUS_SUCCESS.  If the existing drive 
    letter is different from that specified by the caller, delete and recreate
    the region's mount point using the symbolic name built from the drive letter
    parameter.

Arguments:

    pRegion         A pointer to a partitioned region descriptor.

    NewDriveLetter     Specifies the drive letter to be assigned to the region.

Returns:

    NTSTATUS
--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    WCHAR existingDriveLetter = 0;
    PWSTR partitionDeviceName = NULL;
    PWSTR symbolicName = NULL;

    //
    // Check input parameters:  these better be valid
    //
    if (!pRegion || !SPPT_IS_REGION_PARTITIONED(pRegion)) {
        DbgErrorMesg((_asrwarn,
            "SpAsrSetPartitionDriveLetter. Invalid Parameter, pRegion %p is NULL or not partitioned.\n",
            pRegion
            )); 
        ASSERT(0 && L"Invalid Parameter, pRegion is NULL or not partitioned."); // debug
        return STATUS_INVALID_PARAMETER;
    }

    if (NewDriveLetter < ((!IsNEC_98) ? L'C' : L'A') || NewDriveLetter > L'Z') {
        DbgErrorMesg((_asrwarn, "SpAsrSetPartitionDriveLetter. Invalid Parameter, NewDriveLetter [%wc].\n", NewDriveLetter)); 
        ASSERT(0 && L"Invalid Parameter, NewDriveLetter"); // debug
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check if the drive letter already exists
    //
    partitionDeviceName = SpAsrGetRegionName(pRegion);
    existingDriveLetter = SpGetDriveLetter(partitionDeviceName, NULL);

    if (NewDriveLetter == existingDriveLetter) {
        
        DbgStatusMesg((_asrinfo, 
            "SpAsrSetPartitionDriveLetter. Ptn [%ws] already has drv letter %wc.\n",
            partitionDeviceName, 
            NewDriveLetter
            ));

        SpMemFree(partitionDeviceName);
        return STATUS_SUCCESS;
    }

    //
    // The existing drive letter does not match.  Delete it.
    //
    if (existingDriveLetter) {
        
        DbgStatusMesg((_asrinfo,
            "SpAsrSetPartitionDriveLetter. [%ws] has driveLetter %wc, deleting.\n",
            partitionDeviceName,
            existingDriveLetter
            ));
        
        SpDeleteDriveLetter(partitionDeviceName);    
    }

    symbolicName = SpDupStringW(DOS_DEVICES);
    pRegion->DriveLetter = symbolicName[DOS_DEVICES_DRV_LTR_POS] = NewDriveLetter;
 
    //
    // Create the mount point with the correct drive letter
    //
    status = SpAsrCreateMountPoint(partitionDeviceName, symbolicName);

    if (NT_SUCCESS(status)) {
        
        DbgStatusMesg((_asrinfo,
            "SpAsrSetPartitionDriveLetter. [%ws] is drive %wc.\n",
            partitionDeviceName,
            NewDriveLetter
            ));

    }
    else  {

        DbgErrorMesg((_asrwarn, 
            "SpAsrSetPartitionDriveLetter. SpAsrCreateMountPoint([%ws],[%ws]) failed (0x%x). Drive letter %wc not assigned to [%ws].\n",
            partitionDeviceName, 
            symbolicName,
            status,
            NewDriveLetter,
            partitionDeviceName
            ));
    }

    SpMemFree(partitionDeviceName);
    SpMemFree(symbolicName);

    return status;
}


NTSTATUS
SpAsrDeleteMountPoint(IN PWSTR PartitionDevicePath)
{
    //
    // Check the DevicePath:  it better not be NULL.
    //
    if (!PartitionDevicePath) {

        DbgErrorMesg((_asrwarn,
            "SpAsrDeleteMountPoint. Invalid Parameter, ParititionDevicePath is NULL.\n"
            ));
        
        ASSERT(0 && L"Invalid Parameter, ParititionDevicePath is NULL."); // debug
        return STATUS_INVALID_PARAMETER;

    }

    DbgStatusMesg((_asrinfo, 
        "SpAsrDeleteMountPoint.  Deleting drive letter for [%ws]\n", 
        PartitionDevicePath
        ));

    SpDeleteDriveLetter(PartitionDevicePath);
    return STATUS_SUCCESS;
}


NTSTATUS
SpAsrSetVolumeGuid(
    IN PDISK_REGION pRegion,
    IN PWSTR VolumeGuid
    )
/*++

Description:
    Delete and recreate the region's mount point using the passed-in symbolic 
    name GUID parameter.

Arguments:
    pRegion         A pointer to a partitioned region descriptor.
    VolumeGuid      Specifies the GUID string to be assigned to the region.
    DeleteDriveLetter Specifies if the existing drive letter for the volume
                    should be deleted.  This should be TRUE for all volumes 
                    except the boot volume.

Returns:
    NTSTATUS

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PWSTR partitionDeviceName = NULL;

    //
    // Check input parameters
    // 
    if (!pRegion || !SPPT_IS_REGION_PARTITIONED(pRegion)) {

        DbgErrorMesg((_asrwarn,
            "SpAsrSetVolumeGuid. Invalid Param: pRegion (%p) NULL/not partitioned\n",
            pRegion
            )); 

        return STATUS_INVALID_PARAMETER;
    }

    if (!VolumeGuid || !wcslen(VolumeGuid)) {
        
        DbgErrorMesg((_asrwarn, 
            "SpAsrSetVolumeGuid. Invalid Param: VolumeGuid (%p) NULL/blank.\n",
            VolumeGuid
            )); 

        return STATUS_INVALID_PARAMETER;
    }

    partitionDeviceName = SpAsrGetRegionName(pRegion);

    //
    // Create the mount point with the correct Guid string.  
    //
    status = SpAsrCreateMountPoint(partitionDeviceName, VolumeGuid);

    SpMemFree(partitionDeviceName);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spdr.c ===
/*++
Copyright (c) 1993 Microsoft Corporation

Module Name:
    spdr.c

Abstract:
    Source file for Automated System Recovery (ASR) functions for text-mode
    setup.  The services defined in this module recreate the boot and system
    partitions based on information obtained by reading records from a 
    configuration file, the asr.sif file (aka SIF).


Terminology
    The following terms are used:

    1.  The "system" partition is the partition that contains the OS loader
    programs (i.e., On amd64/x86 platforms these are the boot.ini. ntldr,
    and ntdetect.com files, among others).

    2.  The "boot" (aka NT) partition is the partition that contains the %SystemRoot%
    directory, i.e., the directory containing the NT system files.  In the
    text-mode setup sources, this directory is also called the
    "TargetDirectory" since, when running normal textmode setup, this is the
    directory into which NT gets installed.

    3.  Extended partition and Logical Disk Terminology

    In the SIF file two kinds of extended partition records can be found.  The
    first kind, of which there may be zero, one, or more, are called Logical
    Disk Descriptor records, or LDDs.  LDDs describe a partition within an
    extended partition. The second kind are called Container Partition
    Descriptor records, or CPDs, because they describe extended partitions.
    For any disk, at most one extended partition may exist and, therefore, only
    one CPD per disk record may exist in the SIF file.


    Extended partitions and logical disk support in Windows NT 5.0:
    1) Windows NT 5.0 supports 0 or 1 extended partition per disk.
    2) Logical disks only exist within extended partitions.
    3) An extended partition may contain zero (0) or more logical disk
    partitions.


    Algorithm for Recovering the System and NT Partitions (see
    SpDrPtPrepareDisks()):
    For each disk
    {
        Check whether its capacity is sufficient to contain all the partitions
        specified in the asr.sif file for that disk (ie the partition set).

        if (Existing Physical Disk Partitions != asr.sif configuration)
        {
            - Remove disk's existing partitions;
            - Recreate disk's partitions according to the asr.sif
              specifications.
        }
        else
        {
            - Replace all corrupt boot and NT system files, excluding
              registry files.
            - Set Repaired Flag.
        }

    }

    - Reinstall NT from CDROM into NT directory specified by asr.sif.
    - If specified, copy 3rd-party files per asr.sif file.
    - Reboot and execute gui-mode disaster recover.

ASR Restrictions:
    For the boot and system volumes ASR requires that the restored (new) 
    system have:
        Same number of drives as the old system.
        Capacity of each new drive >= capacity of corresponding old drive.

Revision History:
    Initial Code                Michael Peterson (v-michpe)     13.May.1997
    Code cleanup and changes    Guhan Suriyanarayanan (guhans)  21.Aug.1999

--*/
#include "spprecmp.h"
#pragma hdrstop
#include <oemtypes.h>

//
// Defaults used for textmode ASR.  The static ones aren't accessed from outside
// this file, and are grouped here so that it's easy to change them if need be.
//
static PWSTR ASR_CONTEXT_KEY   = L"\\CurrentControlSet\\Control\\Session Manager\\Environment";
static PWSTR ASR_CONTEXT_VALUE = L"ASR_C_CONTEXT";
static PWSTR ASR_CONTEXT_DATA  = L"AsrInProgress";

static PWSTR ASR_BOOT_PARTITION_VALUE     = L"ASR_C_WINNT_PARTITION_DEVICE";
static PWSTR ASR_SYSTEM_PARTITION_VALUE   = L"ASR_C_SYSTEM_PARTITION_DEVICE";

static PWSTR ASR_SIF_NAME                 = L"asr.sif";
static PWSTR ASR_SIF_PATH                 = L"\\Device\\Floppy0\\asr.sif";
static PWSTR ASR_SIF_TARGET_PATH          = L"\\repair\\asr.sif";

static PWSTR ASR_SETUP_LOG_NAME           = L"setup.log";
static PWSTR ASR_DEFAULT_SETUP_LOG_PATH   = L"\\Device\\Floppy0\\Setup.log";

extern const PWSTR SIF_ASR_PARTITIONS_SECTION;
extern const PWSTR SIF_ASR_SYSTEMS_SECTION;

PWSTR ASR_FLOPPY0_DEVICE_PATH = L"\\Device\\Floppy0";
PWSTR ASR_CDROM0_DEVICE_PATH  = L"\\Device\\CdRom0";
PWSTR ASR_TEMP_DIRECTORY_PATH = L"\\TEMP";


PWSTR ASR_SIF_SYSTEM_KEY      = L"1";     // we only handle one system per sif

static PWSTR Gbl_SourceSetupLogFileName = NULL;

PWSTR Gbl_SystemPartitionName       = NULL;
PWSTR Gbl_SystemPartitionDirectory  = NULL;
PWSTR Gbl_BootPartitionName         = NULL;
PWSTR Gbl_BootPartitionDirectory    = NULL;

ULONG Gbl_FixedDiskCount = 0;

WCHAR Gbl_BootPartitionDriveLetter;

PVOID Gbl_HandleToSetupLog = NULL;
PVOID Gbl_SifHandle = NULL;

BOOLEAN Gbl_RepairWinntFast = FALSE; // Put in spdrfix.c
BOOLEAN Gbl_NtPartitionIntact = TRUE;
BOOLEAN Gbl_RepairFromErDisk = FALSE;
BOOLEAN Gbl_AsrSifOnInstallationMedia = FALSE;

ASRMODE Gbl_AsrMode = ASRMODE_NONE;

PDISK_REGION Gbl_BootPartitionRegion   = NULL;
PDISK_REGION Gbl_SystemPartitionRegion = NULL;

PSIF_PARTITION_RECORD Gbl_SystemPartitionRecord = NULL;
DWORD                 Gbl_SystemDiskIndex       = 0;

PSIF_PARTITION_RECORD Gbl_BootPartitionRecord   = NULL;
DWORD                 Gbl_BootDiskIndex         = 0;

PSIF_INSTALLFILE_LIST Gbl_3rdPartyFileList  = NULL; 
PCONFIGURATION_INFORMATION Gbl_IoDevices    = NULL;

PWSTR RemoteBootAsrSifName = NULL;


// 
// delay the driver cab opening until required 
// (while repair is being performed)
//
PWSTR gszDrvInfDeviceName = 0;
PWSTR gszDrvInfDirName = 0;
HANDLE ghSif = 0;

//
// To Enable/Disable Emergency repair
//
BOOLEAN DisableER = TRUE;


// Module identification for debug traces
#define THIS_MODULE L"    spdr.c"
#define THIS_MODULE_CODE L"A"

// Keys valid on various menu screens

#define ASCI_C 67
#define ASCI_c 99

#define ASCI_F 70
#define ASCI_f 102

#define ASCI_M 77
#define ASCI_m 109

#define ASCI_R 82
#define ASCI_r 114

// Useful macros
#define FilesystemNotApplicable ((FilesystemType) FilesystemMax)

// External functions and variables
extern BOOLEAN ForceConsole;

extern const PWSTR SIF_ASR_GPT_PARTITIONS_SECTION; 
extern const PWSTR SIF_ASR_MBR_PARTITIONS_SECTION;

extern PWSTR NtBootDevicePath;
extern PWSTR DirectoryOnBootDevice;

extern VOID SpInitializePidString(
    IN HANDLE MasterSifHandle,
    IN PWSTR  SetupSourceDevicePath,
    IN PWSTR  DirectoryOnSourceDevice
    );

extern NTSTATUS SpOpenSetValueAndClose(
    IN HANDLE hKeyRoot,
    IN PWSTR  SubKeyName,  OPTIONAL
    IN PWSTR  ValueName,
    IN ULONG  ValueType,
    IN PVOID  Value,
    IN ULONG  ValueSize
    );

extern BOOLEAN
SpPtnCreateLogicalDrive(
    IN  ULONG         DiskNumber,
    IN  ULONGLONG     StartSector,
    IN  ULONGLONG     SizeInSectors,
    IN  BOOLEAN       ForNT,   
    IN  BOOLEAN       AlignToCylinder,
    IN  ULONGLONG     DesiredMB OPTIONAL,
    IN  PPARTITION_INFORMATION_EX PartInfo OPTIONAL,
    OUT PDISK_REGION *ActualDiskRegion OPTIONAL
    );

extern ULONG
SpPtnGetPartitionCountDisk(
    IN ULONG DiskId
    );

extern ULONG
SpPtnGetContainerPartitionCount(
    IN ULONG DiskId
    );

extern NTSTATUS
SpPtnZapSectors(
    IN HANDLE DiskHandle,
    IN ULONG BytesPerSector,
    IN ULONGLONG StartSector,
    IN ULONG SectorCount
    );

extern PDISK_REGION
SpPtnLocateESP(
    VOID
    );


VOID
SpAsrInitIoDeviceCount(VOID)
/*++

Routine Description:
    Gets the IO Devices counts and updates Gbl_IoDevices. Prints out
    debug information with the deves counts.

Arguments:
    None

Return Value:
    void

Side Effect:
    Updates Gbl_IoDevices with configuration information

--*/
{
    ULONG diskIndex;
    
    Gbl_IoDevices = IoGetConfigurationInformation();

    //!!review null?

    DbgStatusMesg((_asrinfo, "----- I/O Device Configurations: -----\n"));
    DbgMesg((_asrinfo, "  SCSI ports:         %lu\n", Gbl_IoDevices->ScsiPortCount));
    DbgMesg((_asrinfo, "  Floppy disk drives: %lu\n", Gbl_IoDevices->FloppyCount));
    DbgMesg((_asrinfo, "  CDROM disk drives:  %lu\n", Gbl_IoDevices->CdRomCount));

    if (Gbl_IoDevices->TapeCount) {
        DbgMesg((_asrinfo, "  Tape drives:        %lu\n", Gbl_IoDevices->TapeCount));
    }

    if (Gbl_IoDevices->MediumChangerCount) {
        DbgMesg((_asrinfo, "  Media changers:     %lu\n", Gbl_IoDevices->MediumChangerCount));
    }
    
    DbgMesg((_asrinfo, "  Hard disk drives:   %lu\n", Gbl_IoDevices->DiskCount));

    for (diskIndex = 0; diskIndex < Gbl_IoDevices->DiskCount; diskIndex++) {
        DbgMesg((_asrinfo, "   %ws %s %ws\n", 
            (PWSTR) HardDisks[diskIndex].DevicePath,
            DISK_IS_REMOVABLE(diskIndex) ?  "(rmvable):" : "(fixed):  ",
            (PWSTR) HardDisks[diskIndex].Description));
    }
    DbgStatusMesg((_asrinfo, "----- End of I/O Device Configurations: -----\n\n"));
}    


VOID
SpAsrDbgDumpRegion(
    IN PDISK_REGION pRegion
    )
{
    UCHAR partitionType = 0;
    PWSTR partitionPath = NULL;
   
    if (!pRegion) {
         KdPrintEx((_asrinfo, "pRegion is NULL.  Cannot be examined.\n"));
        return;
    }

    if (!SPPT_IS_REGION_PARTITIONED(pRegion)) {
          KdPrintEx((_asrinfo, "[/]: non-partitioned region.\n"));
          return;
    }
    else {
        SpNtNameFromRegion(
            pRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );

        partitionPath = SpDupStringW(TemporaryBuffer);

        partitionType = SPPT_GET_PARTITION_TYPE(pRegion);

        KdPrintEx((_asrinfo, "[%ws]: partitioned. type:0x%x dynamicVol:%s\n",
            partitionPath,
            partitionType,
            pRegion->DynamicVolume ? "Yes" : "No"));

        SpMemFree(partitionPath);
    }

}


VOID
SpAsrDbgDumpDisk(IN ULONG Disk)
{
    PDISK_REGION primaryRegion = NULL, 
        extRegion = NULL;

    DbgMesg((_asrinfo,        
        "\n     SpAsrDbgDumpDisk. Existing regions on disk %lu (sig:0x%x):\n",
        Disk,
        SpAsrGetActualDiskSignature(Disk)
        ));

    primaryRegion = SPPT_GET_PRIMARY_DISK_REGION(Disk);
    extRegion = SPPT_GET_EXTENDED_DISK_REGION(Disk);

    if (!primaryRegion && !extRegion) {
        DbgMesg((_asrinfo, "*** No Partitions ***\n"));
        return;
    }
    
    while (primaryRegion) {
        DbgMesg((_asrinfo, "(pri) "));
        SpAsrDbgDumpRegion(primaryRegion);
        primaryRegion = primaryRegion->Next;
    }

    while (extRegion) {
        DbgMesg((_asrinfo, "(ext) "));
        SpAsrDbgDumpRegion(extRegion);
        extRegion = extRegion->Next;
    }
}


VOID
SpAsrDeletePartitions(
    IN ULONG DiskNumber,
    IN BOOLEAN PreserveInterestingPartitions,  // ESP for GPT, InterestingPartitionType for MBR
    IN UCHAR InterestingMbrPartitionType,   // see above
    OUT BOOLEAN *IsBlank // this is set FALSE if disk contains partitions that weren't deleted 
    )
{
    PPARTITIONED_DISK pDisk = NULL;
    PDISK_REGION    CurrRegion = NULL;

    BOOLEAN         Changes = FALSE;
    NTSTATUS        Status, InitStatus;
    BOOLEAN         preserveThisPartition = FALSE;

    *IsBlank = TRUE;

    DbgStatusMesg((_asrinfo, 
        "Deleting partitions on DiskNumber %lu "
        "(partition count: %lu + %lu)\n", 
        DiskNumber,
        SpPtnGetPartitionCountDisk(DiskNumber),
        SpPtnGetContainerPartitionCount(DiskNumber)
        ));

    //
    // Check if disk has any partitions 
    //
    pDisk = &PartitionedDisks[DiskNumber];
    if (!pDisk) {
        return;
    }

    // 
    // Mark partitions for deletion
    //
    CurrRegion = pDisk->PrimaryDiskRegions;
    while (CurrRegion) {
        if (!SPPT_IS_REGION_FREESPACE(CurrRegion)) {

            preserveThisPartition = FALSE;

            if (PreserveInterestingPartitions) {
                if (SPPT_IS_GPT_DISK(DiskNumber)) {

                    if (SPPT_IS_REGION_EFI_SYSTEM_PARTITION(CurrRegion)) {
                        preserveThisPartition = TRUE;
                    }

                    //
                    // TODO:  OEM partitions on GPT, do we preserve them?
                    //
                }
                else {
                    // 
                    // Preserve the MBR partition, if it matches the OEM partition type
                    //
                    if ((PARTITION_ENTRY_UNUSED != InterestingMbrPartitionType) &&
                        (InterestingMbrPartitionType == SPPT_GET_PARTITION_TYPE(CurrRegion))) {

                        preserveThisPartition = TRUE;

                    }
                }
            }

            if (preserveThisPartition) {

                DbgStatusMesg((_asrinfo, "Preserving partition with start sector: %I64u\n", 
                    CurrRegion->StartSector));
                
                *IsBlank = FALSE;
                SPPT_SET_REGION_DELETED(CurrRegion, FALSE);
                SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);

            }
            else {
                
                DbgStatusMesg((_asrinfo, "Deleting partition with start sector: %I64u\n", 
                    CurrRegion->StartSector));

                SPPT_SET_REGION_DELETED(CurrRegion, TRUE);
                SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);
                
                //
                // If this is a container partition, make sure we zero it
                //
                if (SPPT_IS_REGION_CONTAINER_PARTITION(CurrRegion)) {
                    WCHAR    DiskPath[MAX_PATH];
                    HANDLE   DiskHandle;

                    //
                    // form the name
                    //
                    DbgStatusMesg((_asrinfo, 
                        "Zapping first sector for container partition with start sector: %I64u\n", 
                        CurrRegion->StartSector
                        ));

                    swprintf(DiskPath, L"\\Device\\Harddisk%u", DiskNumber);        
                    Status = SpOpenPartition0(DiskPath, &DiskHandle, TRUE);

                    if (NT_SUCCESS(Status)) {
                        SpPtnZapSectors(DiskHandle, SPPT_DISK_SECTOR_SIZE(DiskNumber), CurrRegion->StartSector, 2);
                        ZwClose(DiskHandle);
                    }
                    else {
                        DbgStatusMesg((_asrinfo, 
                            "Could not open handle to disk %lu to zap sector: %I64u (0x%x)\n", 
                            DiskNumber,
                            CurrRegion->StartSector,
                            Status
                            ));
                    }
                }

                //
                // Remove any boot sets pointing to this region.
                //
                SpPtDeleteBootSetsForRegion(CurrRegion);

                //
                //  Get rid of the compressed drives, if any
                //
                if (CurrRegion->NextCompressed != NULL) {
                    SpDisposeCompressedDrives(CurrRegion->NextCompressed);
                    CurrRegion->NextCompressed = NULL;
                    CurrRegion->MountDrive = 0;
                    CurrRegion->HostDrive = 0;
                }
            }
        }

        CurrRegion = CurrRegion->Next;
    }

    //
    // Commit the changes
    //
    Status = SpPtnCommitChanges(DiskNumber, &Changes);

    //
    // Initialize region structure for the disk again
    //
    InitStatus = SpPtnInitializeDiskDrive(DiskNumber);

    if (!NT_SUCCESS(Status) || !Changes || !NT_SUCCESS(InitStatus)) {

        DbgFatalMesg((_asrerr,
            "Could not successfully delete partitions on disk %lu (0x%x)",
            DiskNumber,
            Status
            ));

        //
        // If this is going to be a serious problem, we will hit a fatal error 
        // when we try to create partitions on this disk.  Let's defer
        // any UI error messages till then.
        //

    }
    else {
        DbgStatusMesg((_asrinfo, "Deleted all partitions on disk %lu.\n", DiskNumber));
    }
}


BOOLEAN
SpAsrProcessSetupLogFile(
    PWSTR FullLogFileName,
    BOOLEAN AllowRetry
    )
{

    PDISK_REGION region = NULL;
    BOOLEAN result = FALSE;

    DbgStatusMesg((_asrinfo, "ProcessSetupLogFile. (ER) Loading setup log file [%ws]\n", FullLogFileName));

    result = SpLoadRepairLogFile(FullLogFileName, &Gbl_HandleToSetupLog);

    if (!result) {

        if (AllowRetry) {
            
            DbgErrorMesg((_asrwarn, 
                "ProcessSetupLogFile. Error loading setup log file [%ws]. AllowRetry:TRUE. continuing.\n", 
                FullLogFileName));
            
            return FALSE;
        
        } 
        else {
            
            DbgFatalMesg((_asrerr, "ProcessSetupLogFile. Error loading setup log file [%ws]. AllowRetry:FALSE. Terminating.\n", 
                FullLogFileName));

            SpAsrRaiseFatalError(SP_TEXT_DR_NO_SETUPLOG,  L"Setup.log file not loaded successfully");
        }

    }

    //
    // Determine the system partition, system partition directory, NT partition,
    // and the NT partition directory from the setup.log file.
    //
    SppGetRepairPathInformation(Gbl_HandleToSetupLog,
        &Gbl_SystemPartitionName,
        &Gbl_SystemPartitionDirectory,
        &Gbl_BootPartitionName,
        &Gbl_BootPartitionDirectory);

    if (!(Gbl_SystemPartitionName && Gbl_SystemPartitionDirectory 
        && Gbl_BootPartitionName && Gbl_BootPartitionDirectory)) {

        DbgFatalMesg((_asrerr, 
            "ProcessSetupLogFile. Invalid NULL value in one of the following: \n"
            ));
        
        DbgMesg((_asrinfo, 
            "\tGbl_SystemPartitionName: %p      Gbl_SystemPartitionDirectory: %p\n",
            Gbl_SystemPartitionName,
            Gbl_SystemPartitionDirectory
            ));

        DbgMesg((_asrinfo, 
            "\tGbl_BootPartitionName:  %p      Gbl_BootPartitionDirectory:  %p\n",
            Gbl_BootPartitionName,
            Gbl_BootPartitionDirectory
            ));

        SpAsrRaiseFatalError(SP_TEXT_DR_BAD_SETUPLOG, L"One or more directory and partition names from setup.log were NULL.");

    }
            
    //
    // Check whether the system and nt partition regions exist on this machine
    //
    Gbl_SystemPartitionRegion = SpRegionFromNtName(Gbl_SystemPartitionName, PartitionOrdinalCurrent);
    if (!Gbl_SystemPartitionRegion) {
        DbgStatusMesg((_asrinfo, "ProcessSetupLogFile. System partition [%ws] does not yet exist\n", Gbl_SystemPartitionName));
    }

    Gbl_BootPartitionRegion = SpRegionFromNtName(Gbl_BootPartitionName, PartitionOrdinalCurrent);
    if (!Gbl_BootPartitionRegion) {
        DbgStatusMesg((_asrinfo, "ProcessSetupLogFile. Boot partition [%ws] does not yet exist\n", Gbl_BootPartitionName));
    }

    DbgStatusMesg((_asrinfo, "ProcessSetupLogFile. (ER) DONE loading setup log file [%ws]\n", 
        FullLogFileName));

    return TRUE;
}


BOOLEAN
SpAsrRegionCanBeFormatted(IN PDISK_REGION pRegion)
{
    UCHAR partitionType = 0x0;
    BOOLEAN canBeFormatted = FALSE;

    partitionType = SPPT_GET_PARTITION_TYPE(pRegion);

    switch (partitionType) {
        case PARTITION_HUGE:
        case PARTITION_FAT32:
        case PARTITION_IFS:
            canBeFormatted = TRUE;
            break;
    }

    return canBeFormatted;
}


FilesystemType
SpAsrGetFsTypeFromPartitionType(
    IN UCHAR PartitionType
    )
{
    FilesystemType fileSystemType = FilesystemUnknown;

    // if this is an extended partition, or logical disk, skip it.
    if (IsContainerPartition(PartitionType)) {
        return FilesystemNotApplicable;
    }

    if (IsRecognizedFatPartition(PartitionType)) {
        fileSystemType = FilesystemFat;
    } 
    else if (IsRecognizedFat32Partition(PartitionType)) {
        fileSystemType = FilesystemFat32;
    } 
    else if (IsRecognizedNtfsPartition(PartitionType)) {
        fileSystemType = FilesystemNtfs;
    } 
    else {
        fileSystemType = FilesystemUnknown;
    }
    return fileSystemType;
}


BOOLEAN
SpAsrPartitionNeedsFormatting(
    IN PDISK_REGION pRegion,
    IN UCHAR NewFileSystemType
    )
/*++

  Description:
    This routine is only called when checking whether an existing partition
    needs to be [re]formatted.

--*/
{
    BOOLEAN needsFormatting = FALSE;
    FilesystemType fsType;

    ASSERT(pRegion);

//    if (!SpAsrRegionCanBeFormatted(pRegion)) {
//        return FALSE;
//    }

//    *NewFilesystemType = SpAsrGetFsTypeFromPartitionType(RequiredSysId);

    fsType = SpIdentifyFileSystem(HardDisks[pRegion->DiskNumber].DevicePath,
                                  HardDisks[pRegion->DiskNumber].Geometry.BytesPerSector,
                                  SpPtGetOrdinal(pRegion,PartitionOrdinalCurrent));

    switch (fsType) {

    case FilesystemFat:
        if (!IsRecognizedFatPartition(NewFileSystemType)) {
            needsFormatting = TRUE;
        }
        break;

    case FilesystemNtfs:
        if (!IsRecognizedNtfsPartition(NewFileSystemType)) {
            needsFormatting = TRUE;
        }
        break;
    
    case FilesystemFat32: 
        if (!IsRecognizedFat32Partition(NewFileSystemType)) {
            needsFormatting = TRUE;
        }
        break;

    case FilesystemDoubleSpace:
        needsFormatting = FALSE;
        break;
    
    case FilesystemUnknown:
    case FilesystemNewlyCreated:
    default: 
        needsFormatting = TRUE;
        break;
    }

    DbgStatusMesg((_asrinfo, "SpAsrPartitionNeedsFormatting. DiskRegion %p Disk:%lu SS:%I64u SC:%I64u fsType:0x%x NewFsType:0x%x NeedsFmt:%s\n",
        pRegion,
        pRegion->DiskNumber, 
        pRegion->StartSector, 
        pRegion->SectorCount, 
        fsType, 
        NewFileSystemType, 
        needsFormatting ? "TRUE" : "FALSE"));

    return needsFormatting;
}


//
// Called only for boot and system partitions.
//
BOOLEAN
SpAsrReformatPartition(
    IN PDISK_REGION pRegion,
    IN UCHAR PartitionType,
    IN PVOID SifHandle,
    IN DWORD ClusterSize,
    IN PWSTR Local_SetupSourceDevicePath,
    IN PWSTR Local_DirectoryOnSetupSource,
    IN BOOL  IsBootPartition        // TRUE=>Boot, FALSE=>System
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PWSTR partitionDeviceName = NULL;
    FilesystemType Filesystem;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle = NULL;

    WCHAR formatStr[6];     // okay to hardcode "6".

    //
    // For the recognised partitions, ensure that the partition type matches the 
    // filesystem type.  For other partitions, we cannot perform this check.
    //
    switch (PartitionType) {

    case PARTITION_FAT32: {
        wcscpy(formatStr, L"FAT32");
        Filesystem = FilesystemFat32;
        break;
    }

    case PARTITION_HUGE: {
        wcscpy(formatStr, L"FAT");
        Filesystem = FilesystemFat;
        break;
    }

    case PARTITION_IFS: {
        wcscpy(formatStr, L"NTFS");
        Filesystem = FilesystemNtfs;
        break;
    }

    default: {
        //
        //  This is fatal, we need to format the boot and system drive.
        //
        DbgErrorMesg((_asrerr, 
            "Region %p, Partition Type 0x%x, SifHandle %p, SetupSrc [%ws], Dir [%ws], IsBoot %d\n", 
            pRegion, PartitionType, SifHandle, Local_SetupSourceDevicePath, 
            Local_DirectoryOnSetupSource, IsBootPartition
            ));

        ASSERT(0 && "Cannot format boot or system partition");

        swprintf(TemporaryBuffer, L"Partition type 0x%x for %s partition is not recognised\n", 
            PartitionType,
            (IsBootPartition ? "boot" : "system")
            );

        SpAsrRaiseFatalError(
            (IsBootPartition ? SP_TEXT_DR_UNKNOWN_NT_FILESYSTEM : SP_TEXT_DR_UNKNOWN_LOADER_FILESYSTEM), 
            TemporaryBuffer
            );
    }
    }

    if (SPPT_IS_MBR_DISK(pRegion->DiskNumber)) {
        //
        // This should only be set for MBR disks
        //
        SPPT_SET_PARTITION_TYPE(pRegion, PartitionType);
    }
    partitionDeviceName = SpAsrGetRegionName(pRegion);

    DbgStatusMesg((_asrinfo, "About to format [%ws] for [%ws].\n", partitionDeviceName, formatStr));

    //
    // If automated ASR tests are in progress, we won't actually format the drives
    //
    if (ASRMODE_NORMAL != SpAsrGetAsrMode()) {
        DbgStatusMesg((_asrerr, "ASR Quick Tests in Progress, skipping format\n"));
        status = STATUS_SUCCESS;

    }
    else {
        status = SpDoFormat(partitionDeviceName,
            pRegion,
            Filesystem,
            TRUE,                       // IsFailureFatal
            FALSE,                      // Check FAT Size, FALSE since we automatically convert if needed
#ifdef PRERELEASE
            TRUE,                       // To reduce testing time, we can quick format in pre-release
#else
            FALSE,                      // Quick Format
#endif
            SifHandle,
            ClusterSize,
            Local_SetupSourceDevicePath,
            Local_DirectoryOnSetupSource
            );
    }

    //
    // Won't get here if SpDoFormat failed, we set IsFailureFatal = TRUE.
    //
    ASSERT(NT_SUCCESS(status) && L"SpDoFormat returned on failure");

    //
    // To make sure the file system mounts, we'll open a handle to the 
    // partition and close it right back. 
    //
    INIT_OBJA(&Obja, &UnicodeString, partitionDeviceName);

    status = ZwCreateFile(
        &Handle,
        FILE_GENERIC_READ,
        &Obja,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
        );

    ZwClose(Handle);
    ASSERT(NT_SUCCESS(status) && L"Couldn't open the partition after formatting it");

    DbgStatusMesg((_asrinfo, "ReformatPartition. Done [%ws] for [%ws].\n", partitionDeviceName, formatStr));
    SpMemFree(partitionDeviceName);
    
    return TRUE;
}


VOID
SpAsrRemoveDiskMountPoints(IN ULONG Disk)
/*++

Description:
    For each partition on the specified disk, its drive letter (if 
    present) is removed.

Arguments:
    Disk    Specifies the disk containing the partitions whose drive letters 
            are to be removed.

Returns:
    None

  --*/
{
    PPARTITIONED_DISK pDisk = NULL;
    PDISK_REGION pDiskRegion = NULL;
    PWSTR partitionPath = NULL;
    UCHAR partitionType = 0;
    
    pDisk = &PartitionedDisks[Disk];

 
    DbgStatusMesg((_asrinfo, "SpAsrRemoveDiskMountPoints. Removing mount points for Disk %lu.\n", Disk));

    //
    // We first delete the primary partitions (other than the container partition)
    //
    pDiskRegion = pDisk->PrimaryDiskRegions;
    while (pDiskRegion) {

        if (SPPT_IS_REGION_PARTITIONED(pDiskRegion)) {
            //
            //  We don't want to delete the container partition yet
            //
            partitionType = SPPT_GET_PARTITION_TYPE(pDiskRegion);
            if (!IsContainerPartition(partitionType)) {

                partitionPath = SpAsrGetRegionName(pDiskRegion);
                SpAsrDeleteMountPoint(partitionPath);
                SpMemFree(partitionPath);

            }
        }

        pDiskRegion = pDiskRegion->Next;
    }
    
    // 
    // Next, delete the extended region mount points
    //
    pDiskRegion = pDisk->ExtendedDiskRegions;
    while (pDiskRegion) {

        if (SPPT_IS_REGION_PARTITIONED(pDiskRegion)) {

            partitionPath = SpAsrGetRegionName(pDiskRegion);
            SpAsrDeleteMountPoint(partitionPath);
            SpMemFree(partitionPath);

        }

        pDiskRegion = pDiskRegion->Next;
    }
}


VOID
SpAsrRemoveMountPoints(VOID)
{
    ULONG driveCount;
    
    // remove the mount points associated with all removable disk drives (Jaz, Zip, etc.,)
    for (driveCount = 0; driveCount < Gbl_IoDevices->DiskCount; driveCount++) {
        if (DISK_IS_REMOVABLE(driveCount)) {
            swprintf(TemporaryBuffer, L"%ws\\Partition1", (PWSTR) HardDisks[driveCount].DevicePath);
            SpAsrDeleteMountPoint(TemporaryBuffer);
        }
    }

    // next, unlink CD-ROM drive letters.
    // NB: the device name is case sensitive - Must be CdRom.
    for (driveCount = 0; driveCount < Gbl_IoDevices->CdRomCount; driveCount++) {
        swprintf(TemporaryBuffer, L"\\Device\\CdRom%u", driveCount);
        SpAsrDeleteMountPoint(TemporaryBuffer);
    }
    
    // finally, remove the mount points for all partitions on all fixed
    // disks attached to the system.
    for (driveCount = 0; driveCount < HardDiskCount; driveCount++) {
        if (Gbl_PartitionSetTable2[driveCount]) {
            SpAsrRemoveDiskMountPoints(driveCount);
        }
    }
}


VOID
SpAsrSetRegionMountPoint(
    IN PDISK_REGION pRegion,
    IN PSIF_PARTITION_RECORD pRec
    )
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PWSTR partitionDeviceName = NULL;
    BOOLEAN isBoot = FALSE;

    //
    // Make sure that the input's okay ...
    //
    if (!pRec) {
        DbgErrorMesg((_asrwarn, 
            "SpAsrSetRegionMountPoint. Rec %p is NULL!\n",
	        pRec
            ));
        return;
    }

    if (!pRegion || !(SPPT_IS_REGION_PARTITIONED(pRegion))) {
        DbgErrorMesg((_asrwarn, 
            "SpAsrSetRegionMountPoint. Region %p is NULL/unpartitioned for ptn-rec:[%ws].\n",
	        pRegion, pRec->CurrPartKey
            ));
        return;
    }

    partitionDeviceName = SpAsrGetRegionName(pRegion);

    //
    // If this is the boot volume, set the drive letter
    //
    isBoot = SpAsrIsBootPartitionRecord(pRec->PartitionFlag);
    if (isBoot) {

        DbgStatusMesg((_asrinfo, "Setting [%ws] boot drive-letter to [%wc]\n", 
            partitionDeviceName, 
            Gbl_BootPartitionDriveLetter
            ));

        status = SpAsrSetPartitionDriveLetter(pRegion, Gbl_BootPartitionDriveLetter);

        if (!NT_SUCCESS(status)) {
        
            DbgErrorMesg((_asrwarn, "SpAsrSetRegionMountPoint. SpAsrSetPartitionDriveLetter failed for boot-drive. boot-ptn:[%ws], ptn-rec:[%ws]. (0x%x)\n",
                partitionDeviceName,
                pRec->CurrPartKey,
                status
                ));
        }
    }

    //
    // And if the volume guid is present, set the volume guid
    //
    if ((pRec->VolumeGuid) && (wcslen(pRec->VolumeGuid) > 0)) {
        
        DbgStatusMesg((_asrinfo, 
            "SpAsrSetRegionMountPoint. Setting [%ws] guid to [%ws]\n", 
            partitionDeviceName, pRec->VolumeGuid 
            ));
    
        status = SpAsrSetVolumeGuid(pRegion, pRec->VolumeGuid);

        if (!NT_SUCCESS(status)) {

            DbgErrorMesg((_asrwarn, 
                "SpAsrSetRegionMountPoint. SpAsrSetVolumeGuid failed. device:[%ws], ptn-rec:[%ws]. (0x%x)\n",
                partitionDeviceName, pRec->CurrPartKey, status
                ));

        }
    }

    SpMemFree(partitionDeviceName);            
}


VOID
SpAsrRestoreDiskMountPoints(IN ULONG DiskIndex)
{
    PSIF_PARTITION_RECORD pRec = NULL;
    PDISK_REGION pRegion = NULL;
    
    //
    // Make sure there is a partition list for the disk
    //
    if (Gbl_PartitionSetTable2[DiskIndex] == NULL ||
        Gbl_PartitionSetTable2[DiskIndex]->pDiskRecord == NULL ||
        Gbl_PartitionSetTable2[DiskIndex]->pDiskRecord->PartitionList == NULL) {
        return;
    }

    //
    // Go through the paritions and set their mount points.  This will also 
    // set the drive letter for the boot volume.  (We have to set it now
    // since we can't change it in GUI-mode Setup)
    //
    pRec = Gbl_PartitionSetTable2[DiskIndex]->pDiskRecord->PartitionList->First;

    while (pRec) {

        pRegion = SpAsrDiskPartitionExists(DiskIndex, pRec);
        if (!pRegion) {
            //
            // We don't expect to find the regions for the non-critical disks.
            //
            DbgErrorMesg((_asrwarn, 
                "RestoreDiskMountPoints: Disk region not found, physical-disk %lu, ptn-rec-key %ws.\n",
                DiskIndex,
                pRec->CurrPartKey
                ));

        }
        else {

            SpAsrSetRegionMountPoint(pRegion, pRec);
        }

        pRec = pRec->Next;
    }
}


VOID
SpAsrUpdatePartitionRecord(
    IN ULONG Disk,
    IN ULONGLONG NewStartSector,
    IN ULONGLONG PrevStartSector,
    IN ULONGLONG NewSectorCount
    )
{
    PSIF_PARTITION_RECORD pRecNew = NULL;

    //
    // Update the partition record whose disk and partition start sector
    // match that of the Disk and PrevStartSector parameters.
    //
    pRecNew = Gbl_PartitionSetTable2[Disk]->pDiskRecord->PartitionList->First;
    while (pRecNew) {
        if (pRecNew->StartSector == PrevStartSector) {
            pRecNew->StartSector = NewStartSector;
            pRecNew->SectorCount = NewSectorCount;
            break;
        }
        pRecNew = pRecNew->Next;
    }      
}    


VOID
SpAsrGetFirstFreespace(
    IN ULONG DiskNumber,
    IN BOOLEAN IsAPrimaryPartition,
    OUT ULONGLONG *StartSector,
    OUT ULONGLONG *FreeSectors,
    OUT ULONGLONG *SizeMbFree,
    IN CONST ULONGLONG MinimumSectorCount
    )
{
    PDISK_REGION pRegion = NULL;
    ULONG NumPartitions = 0;

    BOOLEAN extendedExists;

    *StartSector = 0;
    *FreeSectors = 0;
    *SizeMbFree = 0;

    NumPartitions = SpPtnGetPartitionCountDisk(DiskNumber) 
        + SpPtnGetContainerPartitionCount(DiskNumber);

    DbgStatusMesg((_asrinfo, 
        "SpAsrGetFirstFreespace. Dsk %lu. PartitionCount= %lu\n",
        DiskNumber, 
        NumPartitions
        ));

    pRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);

    if (0 == NumPartitions) {

        if (pRegion) {
            *StartSector = pRegion->StartSector;
            *FreeSectors = pRegion->SectorCount;
            if ((*FreeSectors) < MinimumSectorCount) {
                *FreeSectors = 0;
            }

            *SizeMbFree =  SpAsrConvertSectorsToMB(*FreeSectors, SPPT_DISK_SECTOR_SIZE(DiskNumber));
            return;
        }
        else {
            //
            // We have the whole disk at our disposal.
            //
            *FreeSectors = SpAsrGetTrueDiskSectorCount(DiskNumber);
            if ((*FreeSectors) < MinimumSectorCount) {
                *FreeSectors = 0;
            }

            *SizeMbFree = SpAsrConvertSectorsToMB(*FreeSectors, SPPT_DISK_SECTOR_SIZE(DiskNumber));
            *StartSector = 0;

            return;
        }
    }


    while (pRegion) {
        DbgStatusMesg((_asrinfo, 
            "SpAsrGetFirstFreespace: MinSC: %I64u. Dsk %lu. Region: %p SS %I64u, SC %I64u, %spartitioned, %sfree-space \n",
            MinimumSectorCount,
            DiskNumber,
            pRegion,
            pRegion->StartSector,
            pRegion->SectorCount,
            (SPPT_IS_REGION_PARTITIONED(pRegion) ? "" : "non-"),
            (SPPT_IS_REGION_FREESPACE(pRegion) ? "IS " : "not ")
            ));

        if (SPPT_IS_REGION_FREESPACE(pRegion)) {
            ULONGLONG AvailableSectors = 0;
            BOOLEAN Found = (IsAPrimaryPartition ? 
                (!SPPT_IS_REGION_CONTAINER_PARTITION(pRegion) && !SPPT_IS_REGION_INSIDE_CONTAINER(pRegion)) : 
                (SPPT_IS_REGION_INSIDE_CONTAINER(pRegion))
                );

            AvailableSectors = pRegion->SectorCount;
            //
            // If we're trying to create a logical drive, we need to take into account that
            // the size of the Free region is not fully available to us for use--the first 
            // track will be used for the EBR.  So we must subtract out the first track
            // from the AvailableSectors.  
            //
            if (!IsAPrimaryPartition) {
                AvailableSectors -= SPPT_DISK_TRACK_SIZE(DiskNumber);
            }

            DbgStatusMesg((_asrinfo, 
                "SpAsrGetFirstFreespace: For this region %p, AvailableSectors:%I64u, Found is %s kind of free space)\n",
                pRegion,
                AvailableSectors,
                (Found ? "TRUE. (right" : "FALSE (wrong")
                ));

            if ((Found) && (pRegion->StartSector > 0) && (AvailableSectors >= MinimumSectorCount)) {
                *StartSector = pRegion->StartSector;
                *FreeSectors = AvailableSectors;
                *SizeMbFree =  SpAsrConvertSectorsToMB(AvailableSectors, SPPT_DISK_SECTOR_SIZE(DiskNumber));
                return;
            }
        }
        pRegion = pRegion->Next;
    }
}


VOID
SpAsrRecreatePartition(
    IN PSIF_PARTITION_RECORD pRec,
    IN ULONG DiskNumber,
    IN CONST BOOLEAN IsAligned
    )
{
    NTSTATUS status     = STATUS_SUCCESS;
    
    BOOLEAN diskChanged = FALSE, 
            result      = FALSE;

    ULONGLONG sizeMbFree    = 0,
            freeSectors     = 0,
            oldStartSector  = 0,
            oldSectorCount  = 0,
            alignedSector   = 0;

    WCHAR    DiskPath[MAX_PATH];
    HANDLE   DiskHandle = NULL;

    PDISK_REGION pRegion    = NULL;
    PARTITION_INFORMATION_EX PartInfo;

    DbgStatusMesg((_asrinfo, 
        "Recreating Ptn %p [%ws] (%s, SS %I64u, SC %I64u type 0x%x)\n",
        pRec,
        pRec->CurrPartKey,
        pRec->IsPrimaryRecord ? "Pri" : 
            pRec->IsContainerRecord ? "Con" :
            pRec->IsLogicalDiskRecord ? "Log" :
            pRec->IsDescriptorRecord ? "Des" :"ERR",
        pRec->StartSector,
        pRec->SectorCount,
        pRec->PartitionType
        ));

    //
    // Get needed parameters (start sector and remaining free space) from the
    // first unpartitioned region on the disk.
    //
    SpAsrGetFirstFreespace(DiskNumber,
        (pRec->IsPrimaryRecord || pRec->IsContainerRecord),
        &pRec->StartSector,
        &freeSectors,   // Sector count of this free space
        &sizeMbFree,
        pRec->SectorCount
        );

    //
    // We fail if the number of free sectors are less than the number 
    // of sectors required to create the partition.  
    //
    if (!freeSectors) {

        DbgFatalMesg((_asrerr, 
            "Ptn-record [%ws]: Disk %lu. reqSec %I64u > available sectors\n",
            pRec->CurrPartKey,
            DiskNumber,
            pRec->SectorCount
            ));
        
         SpAsrRaiseFatalError(
            SP_TEXT_DR_INSUFFICIENT_CAPACITY,
            L"Not enough free space left to create partition"
            );
    }

    pRec->SizeMB = SpAsrConvertSectorsToMB(pRec->SectorCount, BYTES_PER_SECTOR(DiskNumber));

    //
    // Check if this is an LDM partition on the boot/sys disk.  If so,
    // all the 0x42 partitions on that disk need to be retyped to a basic
    // type (6, 7 or B).  This is to prevent LDM from getting confused on
    // reboot.  At the end of GUI-Setup, asr_ldm will do the needful to 
    // reset the partition types as needed.
    //
    if (pRec->NeedsLdmRetype) {

        if (PARTITION_STYLE_MBR == pRec->PartitionStyle) {
            if (!IsRecognizedPartition(pRec->FileSystemType)) {
                //
                // This is an 0x42 partition on the boot/sys disk, but it is
                // not the boot or system partition.  The FileSystemType is not
                // recognised since it  is set to be 0x42 as well.  (The 
                // FileSystemType is only valid for the boot and system 
                // partitions--for all other partitions,
                // it is set to be the same as the PartitionType)
                //
                // We set it to 0x7 for the time being.  The actual file-system type
                // will be set later in GUI-Setup by asr_ldm and asr_fmt.
                //
                DbgStatusMesg((_asrinfo, 
                    "MBR ptn-rec %ws re-typed (0x%x->0x7) \n", 
                    pRec->CurrPartKey, pRec->FileSystemType));
                pRec->FileSystemType = PARTITION_IFS;
                pRec->PartitionType = PARTITION_IFS;
            }
            else {
                DbgStatusMesg((_asrinfo, 
                    "MBR ptn-rec %ws re-typed (0x%x->0x%x).\n", 
                    pRec->CurrPartKey, pRec->PartitionType, 
                    pRec->FileSystemType));
                pRec->PartitionType = pRec->FileSystemType;
            }
        }
        else if (PARTITION_STYLE_GPT == pRec->PartitionStyle) {

            DbgStatusMesg((_asrinfo, 
                "GPT ptn-rec %ws re-typed (%ws to basic).\n", 
                pRec->CurrPartKey, pRec->PartitionTypeGuid));

            CopyMemory(&(pRec->PartitionTypeGuid), 
                &PARTITION_BASIC_DATA_GUID, sizeof(GUID));

        }
        else {
            ASSERT(0 && L"Unrecognised partition style");
        }
    }

    RtlZeroMemory(&PartInfo, sizeof(PARTITION_INFORMATION_EX));

    //
    // Fill out the PARTITION_INFORMATION_EX structure that SpPtnCreate uses
    //
    PartInfo.PartitionStyle = pRec->PartitionStyle;

    if (PARTITION_STYLE_MBR == pRec->PartitionStyle) {
        PartInfo.Mbr.PartitionType = pRec->PartitionType;
        PartInfo.Mbr.BootIndicator =
                SpAsrIsSystemPartitionRecord(pRec->PartitionFlag);
    }
    else if (PARTITION_STYLE_GPT == pRec->PartitionStyle) {
        CopyMemory(&(PartInfo.Gpt.PartitionType), &(pRec->PartitionTypeGuid), 
            sizeof(GUID));
        CopyMemory(&(PartInfo.Gpt.PartitionId), &(pRec->PartitionIdGuid), 
            sizeof(GUID));
        PartInfo.Gpt.Attributes = pRec->GptAttributes;
        wcscpy(PartInfo.Gpt.Name, pRec->PartitionName);
    }
    else {
        //
        // Unrecognised disk layout?
        //
        return;
    }

    DbgStatusMesg((_asrinfo, 
        "Recreating Ptn [%ws] (%s, Adjusted SS %I64u, type 0x%x)\n",
        pRec->CurrPartKey, pRec->IsPrimaryRecord ? "Pri" : 
            pRec->IsContainerRecord ? "Con" :
            pRec->IsLogicalDiskRecord ? "Log" :
            pRec->IsDescriptorRecord ? "Des" :"ERR",
        pRec->StartSector, pRec->PartitionType));

    //
    // Before creating the partition, let's zero out the first few
    // sectors in that partition, so that we forcibly nuke any 
    // stale file-system or other information present
    //
    DbgStatusMesg((_asrinfo, 
        "Zeroing 2 sectors starting with sector: %I64u\n",pRec->StartSector));

    swprintf(DiskPath, L"\\Device\\Harddisk%u", DiskNumber);        
    status = SpOpenPartition0(DiskPath, &DiskHandle, TRUE);

    if (NT_SUCCESS(status)) {
        
        status = SpPtnZapSectors(DiskHandle, 
            SPPT_DISK_SECTOR_SIZE(DiskNumber),
            pRec->StartSector, 
            2);

        if (!NT_SUCCESS(status)) {
            DbgStatusMesg((_asrwarn, 
                "Could not zero sector %I64u on disk %lu (0x%x)\n", 
                pRec->StartSector, DiskNumber, status));
        }

        //
        // If the first partition we're creating is a container partition,
        // SpPtnCreate will align it to a cylinder boundary.  The problem
        // is that since we haven't zero'ed that sector (at the first
        // cylinder boundary), it may contain some stale EBR info, and we will
        // end up thinking that that EBR is valid.
        // 
        // So if this is a container partition, let's do one additional 
        // thing--check what the cylinder aligned boundary will be, and
        // zero that out if needed.
        //
        if (IsAligned && pRec->IsContainerRecord) {
            alignedSector = SpPtAlignStart(SPPT_GET_HARDDISK(DiskNumber), pRec->StartSector, TRUE);

            if (alignedSector != pRec->StartSector) {
                status = SpPtnZapSectors(DiskHandle, 
                    SPPT_DISK_SECTOR_SIZE(DiskNumber),
                    alignedSector,                
                    2);
                if (!NT_SUCCESS(status)) {
                    DbgStatusMesg((_asrwarn, 
                        "Could not zero aligned-sector %I64u on disk %lu (0x%x)\n", 
                        alignedSector, DiskNumber, status));
                }
            }
        }

        ZwClose(DiskHandle);
    }
    else {
        DbgStatusMesg((_asrwarn, 
            "Could not open handle to disk %lu to zap sector: %I64u (0x%x)\n", 
            DiskNumber,
            pRec->StartSector,
            status
            ));
    }

    //
    // Create this partition on disk.  If we aren't successful, we treat it as a fatal error.
    //
    if (pRec->IsLogicalDiskRecord) {
        //
        // For logical disks, we need to call SpPtnCreateLogicalDrive, which
        // will take care of creating the descriptor records as needed.
        //
        result = SpPtnCreateLogicalDrive(
            DiskNumber,
            pRec->StartSector,
            pRec->SectorCount,
            TRUE,
            IsAligned,
            pRec->SizeMB,
            &PartInfo,
            &pRegion
            );

    }
    else {
        //
        // If this is a container partition, make sure we zero the
        // first sector of the partition before creating it
        //
        result = SpPtnCreate(
            DiskNumber,
            pRec->StartSector,
            pRec->SectorCount,
            pRec->SizeMB,
            IsContainerPartition(pRec->PartitionType),
            IsAligned,
            &PartInfo,
            &pRegion
            );

    }

    if (!result) {

        DbgFatalMesg((_asrerr, "SpPtnCreate failed for ptn-rec %ws at %p (Disk %lu, SS %I64u, Size %I64u)\n",
            pRec->CurrPartKey,
            pRec,
            DiskNumber,
            pRec->StartSector,
            pRec->SizeMB
            ));
        
        SpAsrRaiseFatalError(
            SP_SCRN_DR_CREATE_ERROR_DISK_PARTITION,
            TemporaryBuffer
            );

        // does not return
    }


    if (pRec->NeedsLdmRetype) {

        pRec->NeedsLdmRetype = FALSE;
        pRegion->DynamicVolume = TRUE;
        pRegion->DynamicVolumeSuitableForOS = TRUE;

    }
    
    SpUpdateDoubleSpaceIni();

    //
    // If the new disk geometry is different, the start sector and sector count 
    // of the newly created region wil be different from the old values.
    //
    if ((pRec->StartSector != pRegion->StartSector) ||
        (pRec->SectorCount != pRegion->SectorCount)) {

        pRec->StartSector = pRegion->StartSector;
        pRec->SectorCount = pRegion->SectorCount;
    }

    DbgStatusMesg((_asrinfo, "Created %ws at sector %I64u for key [%ws], type 0x%x, region %p.\n",
        pRec->IsPrimaryRecord ? L"primary partition" : 
            pRec->IsContainerRecord ? L"container partition" :
            pRec->IsLogicalDiskRecord ? L"logical disk partition" : L"LDM Partition",
        pRegion->StartSector,
        pRec->CurrPartKey,
        pRec->PartitionType,
        pRegion
        ));
}


ULONGLONG
RoundUp(
    IN ULONGLONG Number,
    IN ULONG MultipleOf
    )
{
    if (Number % MultipleOf) {
        return (Number + (ULONGLONG) MultipleOf - (Number % (ULONGLONG) MultipleOf));

    }
    else {
        return Number;
    }
}


BOOLEAN
SpAsrRecreateDiskPartitions(
    IN ULONG Disk,
    IN BOOLEAN SkipSpecialPartitions,  // OEM partitions for amd64/x86, ESP for ia64
    IN UCHAR MbrOemPartitionType
    )
{
    ULONGLONG oldStartSector = 0,
        oldSectorCount = 0;
    PSIF_PARTITION_RECORD pRec = NULL;
    PSIF_PARTITION_RECORD_LIST pList = NULL;

    SIF_PARTITION_RECORD_LIST logicalDiskList;
    SIF_PARTITION_RECORD_LIST primaryPartList;
    ULONG count = 0,
        SectorsPerCylinder = 0;

    BOOLEAN isAligned = TRUE;
    BOOLEAN moveToNext = TRUE;

    ZeroMemory(&logicalDiskList, sizeof(SIF_PARTITION_RECORD_LIST));
    ZeroMemory(&primaryPartList, sizeof(SIF_PARTITION_RECORD_LIST));

    SectorsPerCylinder = HardDisks[Disk].SectorsPerCylinder;

    if (!Gbl_PartitionSetTable1[Disk]->pDiskRecord->PartitionList) {
        //
        // No partitions to recreate
        //
        return TRUE;
    }

    //
    // Split the partitions into two lists, one containing
    // just the primary partitions, and the second containing
    // the logical drives.  The primary partition list will
    // also include the container record if any.
    //
//    pList = SpAsrCopyPartitionRecordList(Gbl_PartitionSetTable1[Disk]->pDiskRecord->PartitionList);

    pList = Gbl_PartitionSetTable1[Disk]->pDiskRecord->PartitionList;
    ASSERT(pList);

    isAligned = Gbl_PartitionSetTable1[Disk]->IsAligned;

    pRec = SpAsrPopNextPartitionRecord(pList);
    while (pRec) {
        if (pRec->IsPrimaryRecord || pRec->IsContainerRecord) {
            //
            // Primary records go into the primaryPartList
            //
            if (SkipSpecialPartitions) {
                if ((PARTITION_STYLE_MBR == pRec->PartitionStyle) &&
                    (MbrOemPartitionType == pRec->PartitionType)) {
                    //
                    // This is an OEM partition that already exists on the 
                    // target machine.  Discard this record.
                    //
                    SpMemFree(pRec);
                    pRec = NULL;
                }
                else if ((PARTITION_STYLE_GPT == pRec->PartitionStyle) &&
                    (RtlEqualMemory(&(pRec->PartitionTypeGuid), &PARTITION_SYSTEM_GUID, sizeof(GUID)))
                    ) {
                    //
                    // This is the EFI System Partition, and it already 
                    // exists on the taget machine.  Discard this 
                    // record.
                    //
                    SpMemFree(pRec);
                    pRec = NULL;
                }
            }

            if (pRec) {
                SpAsrInsertPartitionRecord(&primaryPartList, pRec);
            }
        }
        else if (pRec->IsLogicalDiskRecord) {
            //
            // LogicalDiskRecords go into the logicalDisklist
            //
            SpAsrInsertPartitionRecord(&logicalDiskList, pRec);
        }
        else if (pRec->IsDescriptorRecord) {
            //
            // Discard the descriptor records 
            //
            SpMemFree(pRec);
        }
        else {
            ASSERT(0 && L"Partition record has incorrect flags set");
            SpMemFree(pRec);
        }
        pRec = SpAsrPopNextPartitionRecord(pList);
    }

    //
    // Recreate the primary partitions first.  
    //
    pRec = SpAsrPopNextPartitionRecord(&primaryPartList);
    while (pRec) {
        //
        // If it's the container partition, we need to make sure it's big
        // enough to hold all the logical drives
        // 
        if (pRec->IsContainerRecord) {
            ULONGLONG sectorCount = 0;
            PSIF_PARTITION_RECORD pLogicalDiskRec = NULL;

            pLogicalDiskRec = logicalDiskList.First;
            while (pLogicalDiskRec) {
                sectorCount += RoundUp(pLogicalDiskRec->SectorCount, SectorsPerCylinder);
                pLogicalDiskRec = pLogicalDiskRec->Next;
            }

            if (pRec->SectorCount < sectorCount) {
                pRec->SectorCount = sectorCount;
            }

        }

        oldStartSector = pRec->StartSector;
        oldSectorCount = pRec->SectorCount; 

        count = SpPtnGetPartitionCountDisk(Disk) + SpPtnGetContainerPartitionCount(Disk);
        SpAsrRecreatePartition(pRec, Disk, isAligned);

        if ((pRec->StartSector != oldStartSector) ||
            (pRec->SectorCount != oldSectorCount)) {

            SpAsrUpdatePartitionRecord(
                Disk,
                pRec->StartSector,
                oldStartSector,
                pRec->SectorCount
                );
        }

        SpMemFree(pRec);

        if (SpPtnGetPartitionCountDisk(Disk) + SpPtnGetContainerPartitionCount(Disk)  > (count + 1)) {
//            moveToNext = FALSE;
//            pRec = NULL;

            ASSERT(0 && L"Partition count differs from expected value (stale data?)");
        }
//        else {

        pRec = SpAsrPopNextPartitionRecord(&primaryPartList);
//        }
    }

    if (moveToNext) {
        //
        // Recreate the logical drives next
        //
        pRec = SpAsrPopNextPartitionRecord(&logicalDiskList);
        while (pRec) {

            oldStartSector = pRec->StartSector;
            oldSectorCount = pRec->SectorCount; 

            count = SpPtnGetPartitionCountDisk(Disk);
            SpAsrRecreatePartition(pRec, Disk, isAligned);

            if ((pRec->StartSector != oldStartSector) ||
                (pRec->SectorCount != oldSectorCount)) {

                SpAsrUpdatePartitionRecord(
                    Disk,
                    pRec->StartSector,
                    oldStartSector,
                    pRec->SectorCount
                    );
            }


            SpMemFree(pRec);

            if (SpPtnGetPartitionCountDisk(Disk) > (count + 1)) {
//                moveToNext = FALSE;
//                pRec = NULL;

                ASSERT(0 && L".. Partition count differs from expected value .. (stale data?)");

            }
//            else {
                pRec = SpAsrPopNextPartitionRecord(&logicalDiskList);
//            }
        }
    }

    return moveToNext;
}


BOOLEAN
SpAsrAttemptRepair(
    IN PVOID SifHandle,
    IN PWSTR Local_SetupSourceDevicePath,
    IN PWSTR Local_DirectoryOnSetupSource,
    IN PWSTR AutoSourceDevicePath,
    IN PWSTR AutoDirectoryOnSetupSource
    )
/*++

Routine Description:
    This routine attempts to replace any missing or corrupted system files with
    their counterparts from an installation source (CDROM, Harddisk, etc).  If
    successful, a full-scale installation is not required and the recovery can
    proceed much faster.

    To accomplish this, AsrAttemptRepair() employs the following logic:

        * If \Device\floppy0\setup.log cannot be opened, then repair can
        not proceed and a full-scale install must be performed.  Otherwise, the
        repair is begun.

        * The first step in the repair is to verify that the directories
        forming the NT tree are present and accessible.  If any of these
        directories are missing or inaccessible, they are recreated and made
        accessible.

        * The second step is to copy any missing or corrupted files from
        installation source.  To accomplish this, SppRepairWinntFiles() is
        called.  This function checks whether each file enumerated in the
        setup.log file is present on the disk AND that its checksum matches
        that specified in setup.log.  If either of these two conditions are
        not met, a new version of the file is copied from the installation
        source (e.g., the CDROM) to the disk.


Arguments:
    SifHandle       Handle to txtsetup.inf

    SetupSourceDevicePath   The physical device path of the media containing the
                            installation files.

    DirectoryOnSetupSource  The name of the directory on the source media (see
                            previous parameter) containing the installation files.


Returns:
    TRUE    if the attempted repair operation is successful.  
    FALSE   if the setup.log file was not opened (ie it wasn't present 
            on the ASR/ER floppy), or the system or boot partitions were NULL

--*/
{
    if (!(Gbl_HandleToSetupLog && 
        Gbl_SystemPartitionRegion && 
        Gbl_BootPartitionRegion)) {
        return FALSE;
    }

    // run autochk on boot and system partitions
    DbgStatusMesg((_asrinfo, 
        "AttemptRepair. Running AutoChk on boot and sys ptns\n"
        ));

    SpRunAutochkOnNtAndSystemPartitions(
        SifHandle,
        Gbl_BootPartitionRegion,
        Gbl_SystemPartitionRegion,
        Local_SetupSourceDevicePath,
        Local_DirectoryOnSetupSource,
        NULL
        );

    // 
    // Verify and repair security of the directories that form the NT tree
    // using the information obtained from the setup.log file.
    //
    DbgStatusMesg((_asrinfo, 
        "AttemptRepair. Verifying and repairing directory structure\n"
        ));

    SppVerifyAndRepairNtTreeAccess(SifHandle,
        Gbl_BootPartitionName,
        Gbl_BootPartitionDirectory,
        Gbl_SystemPartitionName,
        Gbl_SystemPartitionDirectory
        );

    // initialize the diamond compression engine.
    SpdInitialize();

    //
    // At this point, we are safe in assuming that the partition and directory
    // structures required to recover the system are still intact.  That being
    // the case, replace the files whose state is preventing the system from
    // booting.
    //
    if (RepairItems[RepairFiles]) {

        //
        // initialize PID only in case of normal ASR
        //
        if ((ASRMODE_NORMAL == SpAsrGetAsrMode()) && !RepairWinnt) {
            SpInitializePidString(SifHandle,
                Local_SetupSourceDevicePath,
                Local_DirectoryOnSetupSource
                );
        }                          

        SppRepairWinntFiles(Gbl_HandleToSetupLog,
            SifHandle,
            Local_SetupSourceDevicePath,
            Local_DirectoryOnSetupSource,
            Gbl_SystemPartitionName,
            Gbl_SystemPartitionDirectory,
            Gbl_BootPartitionName,
            Gbl_BootPartitionDirectory
            );

        SppRepairStartMenuGroupsAndItems(Gbl_BootPartitionName, Gbl_BootPartitionDirectory);
    }

    //
    // Repair the hives. This action is only available if the Fast Repair
    // option was chosen.
    //
    if (Gbl_RepairWinntFast) {

        PWSTR directoryOnHiveRepairSource = NULL;
        BOOLEAN tmpRepairFromErDisk = Gbl_RepairFromErDisk;

        // 
        // Create the complete hive repair path
        //
        wcscpy(TemporaryBuffer, Gbl_BootPartitionDirectory);
        SpConcatenatePaths(TemporaryBuffer, SETUP_REPAIR_DIRECTORY);
        directoryOnHiveRepairSource = SpDupStringW(TemporaryBuffer);
        Gbl_RepairFromErDisk = FALSE;

        SppRepairHives(SifHandle,
            Gbl_BootPartitionName,
            Gbl_BootPartitionDirectory,
            Gbl_BootPartitionName,
            directoryOnHiveRepairSource
            );

        SpMemFree(directoryOnHiveRepairSource);
        Gbl_RepairFromErDisk = tmpRepairFromErDisk;
    }

    SpdTerminate();
    return TRUE;
}

BOOLEAN
SpDoRepair(
    IN PVOID SifHandle,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource,
    IN PWSTR AutoSourceDevicePath,
    IN PWSTR AutoDirectoryOnSetupSource,
    IN PWSTR RepairPath,
    IN PULONG RepairOptions
    )
{
    
    ULONG count = 0;
    ASRMODE prevMode = ASRMODE_NONE;
    BOOLEAN returnValue = FALSE;

    for (count = 0; count < RepairItemMax; count++) {
        RepairItems[count] = RepairOptions[count];
    }

    prevMode = SpAsrSetAsrMode(TRUE);
    Gbl_SourceSetupLogFileName = RepairPath;
    SpAsrProcessSetupLogFile(Gbl_SourceSetupLogFileName, FALSE);

    returnValue = SpAsrAttemptRepair(SifHandle,
        SetupSourceDevicePath,
        DirectoryOnSetupSource,
        AutoSourceDevicePath,
        AutoDirectoryOnSetupSource
        );

    SpAsrSetAsrMode(prevMode);
    return returnValue;
}


VOID
SpAsrRepairOrDRMenu(VOID)
/*++

Routine Description:
    Display a screen allowing the user to choose among the repair
    options: Recovery Console, Conventional Repair, ASR or Exit.

Arguments:
    None.

Return Value:
    None.

Side Effects:
    Sets the following global flags to indicate user's selection:
    ForceConsole        set to TRUE if user wants Recovery Console
    RepairWinnt         set to TRUE if user wants Conventional Repair
    SpAsrSetAsrMode(ASRMODE_NORMAL)   if user wants Conventional Repair or ASR

--*/

{

    ULONG repairKeys[] = {KEY_F3, KEY_F10, 0};
    ULONG mnemonicKeys[] = {MnemonicConsole, MnemonicRepair, 0};
    BOOLEAN done = TRUE;
    ULONG UserOption;

    do {
        done = TRUE;

        if (SpIsERDisabled()) {
            UserOption = (MnemonicConsole | KEY_MNEMONIC);    // only Command console
        } else {
            // display the choice screen for the user.
            SpDisplayScreen(SP_SCRN_DR_OR_REPAIR,3,4);
            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                                    SP_STAT_C_EQUALS_CMDCONS,
                                    SP_STAT_R_EQUALS_REPAIR,
                                    SP_STAT_F3_EQUALS_EXIT,
                                    0
                                   );

            // wait for keypress.  Valid keys:
            // F3 = exit
            // F10,C = Recovery Console
            // R = Repair Winnt
            // A = Automated System Recovery (ASR)
            SpInputDrain();
            UserOption = SpWaitValidKey(repairKeys,NULL,mnemonicKeys);
        }            

        switch(UserOption) {
        case KEY_F3:
            // User wants to exit.
            SpConfirmExit();
            done = FALSE;
            break;

        case KEY_F10:
        case (MnemonicConsole | KEY_MNEMONIC):
            // User wants the recovery console.
            ForceConsole = TRUE;
            SpAsrSetAsrMode(ASRMODE_NONE);
            RepairWinnt = FALSE;
            break;            

        case (MnemonicRepair | KEY_MNEMONIC):
            // User wants conventional repair.
            SpAsrSetAsrMode(ASRMODE_NORMAL);
            RepairWinnt = TRUE;
            break;

        default:
            // User doesn't want any of our choices. Show him the same screen again.
            done = FALSE;
            break;

        }
    } while (!done);
}


BOOLEAN
SpAsrRepairManualOrFastMenu(VOID)
/*++

Routine Description:
    Display a screen allowing the user to choose between Manual and Fast
    Repair modes. Manual--user will select options on next screen, 
    Fast--defaults are used

Arguments:
    None.

Return Value:
    TRUE    if the user selected a repair mode
    FALSE   if the user hit <ESC> to cancel

Side Effect:
    Gbl_RepairWinntFast is set to TRUE if user selects Fast Repair, FALSE otherwise
                        
--*/
{
    ULONG repairKeys[] = {KEY_F3, ASCI_ESC, 0};
    ULONG mnemonicKeys[] = {MnemonicFastRepair, MnemonicManualRepair, 0};
    BOOLEAN done;

    do {
        done = TRUE;

        // 
        // Display the choice screen for the user.
        //
        SpDisplayScreen(SP_SCRN_REPAIR_MANUAL_OR_FAST,3,4);
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_M_EQUALS_REPAIR_MANUAL,
            SP_STAT_F_EQUALS_REPAIR_FAST,
            SP_STAT_ESC_EQUALS_CANCEL,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        // 
        // wait for keypress.  Valid keys:
        // F3 = exit
        // ESC = cancel
        // M = Manual Repair
        // F = Fast Repair
        //
        SpInputDrain();
        switch(SpWaitValidKey(repairKeys,NULL,mnemonicKeys)) {
        case KEY_F3:
            // User wants to exit.
            SpConfirmExit();
            break;

        case (MnemonicManualRepair | KEY_MNEMONIC):
            // User wants manual repair, i.e., choose from the list.
            Gbl_RepairWinntFast = FALSE;
            break;

        case (MnemonicFastRepair | KEY_MNEMONIC):
            // User wants fast repair, i.e., don't show the list.
            Gbl_RepairWinntFast = TRUE;
            break;

        case ASCI_ESC:
            // User wants to cancel
            return FALSE;

        default:
            // User doesn't want any of our choices
            done = FALSE;
            break;

        }
    } while (!done);

    return TRUE;
}


//
// Returns true if this physical disk is to be skipped while 
// repartitioning all the disks.  (i.e., this disk is intact,
// or is removable, etc)
//
BOOLEAN
SpAsrpSkipDiskRepartition(
    IN DWORD DiskIndex,
    IN BOOLEAN SkipNonCritical  // should we skip non-critical disks?
    ) 
{
    // 
    // Skip removable disks.  They are not counted in the 
    // partition set table, hence their entry is NULL.
    //
    if (NULL == Gbl_PartitionSetTable1[DiskIndex]) {
        return TRUE;
    }

    //
    // Skip disks for which no disk record exists in asr.sif
    //
    if (NULL == Gbl_PartitionSetTable1[DiskIndex]->pDiskRecord) {
        return TRUE;
    }
    
    //
    // Skip disks for which a disk record may exist but no 
    // partition records reference that disk record.
    //
    if (NULL == Gbl_PartitionSetTable1[DiskIndex]->pDiskRecord->PartitionList) {
        return TRUE;
    }

    //
    // Skip non-critical disks if told to.
    //
    if ((SkipNonCritical) && (FALSE == Gbl_PartitionSetTable1[DiskIndex]->pDiskRecord->IsCritical)) {
        return TRUE;
    }

    //
    // Skip disks that are intact
    //
    if (Gbl_PartitionSetTable1[DiskIndex]->PartitionsIntact) {
        return TRUE;
    }

    return FALSE;
}


VOID
SpAsrClobberDiskWarning(VOID)
/*++

Routine Description:
    Display a screen warning the user that when a partition on a disk is
    to be recreated, *all* partitions on that disk are clobbered, and
    allowing the user to abort.

Arguments:
    None.

Return Value:
    None.

--*/
{
    ULONG validKeys[] = {KEY_F3, 0};
    ULONG mnemonicKeys[] = {MnemonicContinueSetup, 0};
    BOOLEAN done = FALSE,
        skip = FALSE;
    DWORD diskIndex = 0;
    ULONG Keypress = 0;
    PVOID Menu;
    ULONG MenuTopY;

    //
    // Dummy variables for user selection data, we don't use these
    //
    ULONG_PTR FirstData = 0,
        ReturnedData = 0;


    if ((ASRMODE_NORMAL != SpAsrGetAsrMode()) || SpAsrGetSilentRepartitionFlag(ASR_SIF_SYSTEM_KEY)) {
        //
        // Automated tests; don't display warning menu
        //
        return;
    }


    // 
    // Display the "your disks will be repartitioned" warning message
    //
    SpDisplayScreen(SP_SCRN_DR_DISK_REFORMAT_WARNING,3,CLIENT_TOP+1);
    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_C_EQUALS_CONTINUE_SETUP,
        SP_STAT_F3_EQUALS_EXIT,
        0
        );

    //
    // And generate the list of disks that will be repartitioned.
    // Calculate menu placement.  Leave one blank line and one 
    // line for a frame.
    //
    MenuTopY = NextMessageTopLine + 2;

    //
    // Create a menu.
    //
    Menu = SpMnCreate(3, MenuTopY, (VideoVars.ScreenWidth-6),
        (VideoVars.ScreenHeight - MenuTopY - 
            (SplangQueryMinimizeExtraSpacing() ? 1 : 2) - STATUS_HEIGHT)
        );
    if (!Menu) {
        SpAsrRaiseFatalError(SP_SCRN_OUT_OF_MEMORY, L"SpMnCreate failed");
    }

    for (diskIndex = 0; diskIndex < HardDiskCount; diskIndex++) {

        skip = SpAsrpSkipDiskRepartition(diskIndex, FALSE);

        if (!skip) {
            PHARD_DISK Disk = SPPT_GET_HARDDISK(diskIndex);

            if (!FirstData) {
                FirstData = (ULONG_PTR)Disk;
            }
         
            if (!SpMnAddItem(Menu, Disk->Description, 3, (VideoVars.ScreenWidth-6), TRUE, (ULONG_PTR)Disk)) {
                SpAsrRaiseFatalError(SP_SCRN_OUT_OF_MEMORY, L"SpMnAddItem failed");
            }
        }
    }

    SpInputDrain();

    do {

        //
        // wait for keypress.  Valid keys:
        // C  = continue
        // F3 = exit
        //
        SpMnDisplay(Menu,
            FirstData,
            TRUE,
            validKeys,
            mnemonicKeys,
            NULL,      // no new highlight callback
            NULL,      // no selection callback
            &Keypress, 
            &ReturnedData
            );


        switch(Keypress) {
        case KEY_F3:
            // 
            // User wants to exit--confirm.
            //
            SpConfirmExit();
            break;

        case (MnemonicContinueSetup | KEY_MNEMONIC):
            // 
            // User wants to continue with Setup
            //
            done = TRUE;
            break;
        }
    } while (!done);

    SpMnDestroy(Menu);
}


VOID
SpAsrCannotDoER(VOID)
/*++

Routine Description:
    Display a screen informing the user that ER canot be performed on
    the system because the boot partition in not intact, i.e., ASR
    recreated/reformatted that partition.

Arguments:
    None.

Return Value:
    None.

--*/
{
    ULONG warningKeys[] = { KEY_F3, 0 };
    ULONG mnemonicKeys[] = { 0 };

    // display the message screen
    SpDisplayScreen(SP_SCRN_DR_CANNOT_DO_ER,3,4);
    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_F3_EQUALS_EXIT,
        0
        );

    // wait for keypress.  Valid key:
    // F3 = exit
    SpInputDrain();
    do {
        switch(SpWaitValidKey(warningKeys,NULL,mnemonicKeys)) {
        case KEY_F3:
            // User wants to exit.
            return;
        }
    } while (TRUE);
}


VOID
SpAsrQueryRepairOrDr()
/*++

  -pending code description

--*/
{
    BOOLEAN done = TRUE;

    do {
        done = TRUE;

        // ask the user if he wants repair or ASR
        SpAsrRepairOrDRMenu();

        if (RepairWinnt) {
            // User wants to repair, check Manual or Fast
           if (done = SpAsrRepairManualOrFastMenu()) {
                if (Gbl_RepairWinntFast) {              // Fast Repair
                    RepairItems[RepairNvram]    = 1;
                    RepairItems[RepairFiles]    = 1;
#if defined(_AMD64_) || defined(_X86_)
                    RepairItems[RepairBootSect] = 1;
#endif // defined(_AMD64_) || defined(_X86_)
                }
                else {                                  // Manual Repair
                    done = SpDisplayRepairMenu();
                }
            }
        }
    } while (!done);
}


BOOLEAN
SpAsrOpenAsrStateFile(ULONG *ErrorLine, PWSTR AsrSifPath)
{
    NTSTATUS status;

    ASSERT(ErrorLine);
    *ErrorLine = 0;

    // load asr.sif
    status = SpLoadSetupTextFile(
        AsrSifPath,
        NULL,
        0,
        &Gbl_HandleToDrStateFile,
        ErrorLine,
        TRUE,
        FALSE
        );

    if (!NT_SUCCESS(status)) {
        DbgErrorMesg((_asrerr, "SpAsrOpenAsrStateFile. Unable to open %ws. status:0x%x ErrorLine:%lu\n", 
            AsrSifPath,
            status, 
            *ErrorLine));

        Gbl_HandleToDrStateFile = NULL;
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
SpAsrLoadAsrDiskette(VOID)
/*++

Routine Description:
    This routine checks for a floppy drive. If one is not found, this routine 
    never returns, Setup terminates with an error. If a floppy drive is found, 
    this routine prompts for the ASR disk. If the disk is loaded, it reads and 
    parses the asr.sif file.

Arguments:
    None.

Return Values:
    TRUE  if disk was loaded successfully
    DOES NOT RETURN if no floppy drive was found, or if asr.sif is corrupt.

--*/
{
    ULONG errorAtLine = 0, 
        diskIndex = 0;

    PWSTR diskName = NULL;
    PWSTR diskDeviceName = NULL;
    PWSTR localAsrSifPath = NULL;

    BOOLEAN result = FALSE;

    if (!RemoteBootSetup) {
        //
        // Look for the asr.sif in the boot directory.  If it isn't present
        // in the boot directory, we'll look for it on the floppy drive.
        //
        localAsrSifPath = SpMemAlloc((wcslen(NtBootDevicePath)+wcslen(ASR_SIF_NAME)+2) * sizeof(WCHAR));

        if (localAsrSifPath) {
            localAsrSifPath[0] = UNICODE_NULL;
            wcscpy(localAsrSifPath,NtBootDevicePath);
            SpConcatenatePaths(localAsrSifPath,ASR_SIF_NAME);

            result = SpAsrOpenAsrStateFile(&errorAtLine, localAsrSifPath);
            Gbl_AsrSifOnInstallationMedia = result;
            
            SpMemFree(localAsrSifPath);
            localAsrSifPath = NULL;
        }

        if (!result) {
            // 
            // Check if the machine has a floppy drive.  This is kind of redundant,
            // since he couldn't have got this far if there isn't a floppy drive.
            // However, we've had cases where setupldr recognises the floppy drive, 
            // but we then loose the floppy by the time we get here.
            //
            if (SpGetFloppyDriveType(0) == FloppyTypeNone) {
                SpAsrRaiseFatalError(
                    SP_TEXT_DR_NO_FLOPPY_DRIVE,
                    L"Floppy drive does not exist"
                    );     
                // does not return
            }

            SpFormatMessage(TemporaryBuffer, sizeof(TemporaryBuffer), SP_TEXT_DR_DISK_NAME);
            diskName = SpDupStringW(TemporaryBuffer);
            diskDeviceName = SpDupStringW(ASR_FLOPPY0_DEVICE_PATH);

            // 
            // Prompt for the disk.  We don't allow him to hit ESC to cancel,
            // since he can't quit out of ASR at this point.
            //
            SpPromptForDisk(
                diskName,
                diskDeviceName,
                ASR_SIF_NAME,
                FALSE,              // no ignore disk in drive
                FALSE,              // no allow escape
                FALSE,              // no warn multiple prompts
                NULL                // don't care about redraw flag
                );

            DbgStatusMesg((_asrinfo, 
                "SpAsrLoadAsrDiskette. Disk [%ws] loaded successfully on %ws\n", 
                diskName, diskDeviceName
                ));

            SpMemFree(diskName);
            SpMemFree(diskDeviceName);

            // 
            // Open asr.sif from the floppy.  If we can't read it, it's a fatal
            // error.
            //
            result = SpAsrOpenAsrStateFile(&errorAtLine, ASR_SIF_PATH);
        }

    } else {
        //
        // open the file from the remote location
        //
        RemoteBootAsrSifName = SpGetSectionKeyIndex(
                                        WinntSifHandle,
                                        L"OSChooser", 
                                        L"ASRINFFile",
                                        0);

        if (!RemoteBootAsrSifName) {
            SpAsrRaiseFatalError(
                SP_TEXT_DR_NO_ASRSIF_RIS,
                L"Couldn't get ASRINFFile from winnt.sif in RIS case"
                );     
            // does not return
        }

        result = SpAsrOpenAsrStateFile(&errorAtLine, RemoteBootAsrSifName);
    }

    if (!result) {

        swprintf(TemporaryBuffer, L"Failed to load/parse asr.sif at line %lu\n",
            errorAtLine);

        if (errorAtLine > 0) {
            SpAsrRaiseFatalErrorLu(SP_TEXT_DR_STATEFILE_BAD_LINE,
                TemporaryBuffer,
                errorAtLine
                );
        }
        else {
            SpAsrRaiseFatalError(SP_TEXT_DR_STATEFILE_ERROR, TemporaryBuffer);
        }
        // does not return
    }

    // 
    // Set Gbl_FixedDiskCount
    //
    for (diskIndex = 0; diskIndex < HardDiskCount; diskIndex++) {
        Gbl_FixedDiskCount += DISK_IS_REMOVABLE(diskIndex) ? 0 : 1;
    }

    AutoPartitionPicker = FALSE;
    return TRUE;
}


BOOLEAN
SpAsrLoadErDiskette(VOID)
/*++

Routine Description:
    This routine checks for a floppy drive, and prompts for the ER 
    Diskette if a drive is found. If a floppy drive is not found, 
    this routine never returns, Setup terminates with an error.

Arguments:
    None.

Return Values:
    TRUE  if disk was loaded successfully
    FALSE otherwise (user hit cancel, or there was no floppy drive present)

--*/
{
    BOOLEAN diskLoaded = FALSE;
    PWSTR diskName = NULL,
        diskDeviceName = NULL;

    // check if an A: drive exists.
    if (SpGetFloppyDriveType(0) == FloppyTypeNone) {
        SpAsrRaiseFatalError(
            SP_TEXT_DR_NO_FLOPPY_DRIVE,
            L"Floppy drive does not exist"
            );     
        // does not return
    }

    SpFormatMessage(TemporaryBuffer, sizeof(TemporaryBuffer),
                    SP_TEXT_REPAIR_OR_DR_DISK_NAME);
    diskName = SpDupStringW(TemporaryBuffer);
    diskDeviceName = SpDupStringW(ASR_FLOPPY0_DEVICE_PATH);

    // prompt for the disk.
    diskLoaded = SpPromptForDisk(
        diskName,
        diskDeviceName,
        ASR_SETUP_LOG_NAME,
        TRUE,
        TRUE,
        FALSE,
        NULL
        );

    DbgStatusMesg((_asrinfo, "SpAsrLoadErDiskette. ER disk [%ws] %s loaded successfully on %s\n", 
        diskName, diskLoaded?"":"NOT", diskDeviceName));

    SpMemFree(diskName);
    SpMemFree(diskDeviceName);

    return diskLoaded;
}


BOOLEAN
SpAsrGetErFromHardDrive(
    IN PVOID MasterSifHandle,
    OUT PVOID *RepairSifHandle,
    OUT PWSTR *FullLogFileName 
   )
/*++

  -pending code description

--*/

{
    BOOLEAN foundRepairableSystem = FALSE,
        result = FALSE;

    DbgStatusMesg((_asrinfo, "SpAsrGetErFromHardDrive. ER: Attempting to load ER data from Hard drive"));

    // 
    // If user has no emergency repair diskette, we need to find out
    // if there is any NT to repair and which one to repair.
    //
    result = SpFindNtToRepair(MasterSifHandle,
        &Gbl_BootPartitionRegion,
        &Gbl_BootPartitionDirectory,
        &Gbl_SystemPartitionRegion,
        &Gbl_SystemPartitionDirectory,
        &foundRepairableSystem
        );

    if (result) {
        
        //
        // Repairable systems were found, and the user selected one to repair
        //

        //
        // Get the device path of the system and boot partitions.
        //
        SpNtNameFromRegion(Gbl_SystemPartitionRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );
        Gbl_SystemPartitionName = SpDupStringW(TemporaryBuffer);

        SpNtNameFromRegion(Gbl_BootPartitionRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );
        Gbl_BootPartitionName = SpDupStringW(TemporaryBuffer);

        // 
        // Form the full NT path of the setup.log file in the chosen
        // system on the hard drive.
        //
        SpConcatenatePaths(TemporaryBuffer, Gbl_BootPartitionDirectory);
        SpConcatenatePaths(TemporaryBuffer, SETUP_REPAIR_DIRECTORY);
        SpConcatenatePaths(TemporaryBuffer, SETUP_LOG_FILENAME);
        *FullLogFileName = SpDupStringW(TemporaryBuffer);

        DbgStatusMesg((_asrinfo, 
            "ER: User picked system to repair. boot-ptn:[%ws] sys-ptn:[%ws] log-file:[%ws]\n",
            Gbl_BootPartitionName, 
            Gbl_SystemPartitionName, 
            *FullLogFileName
            ));

        // 
        // Read and process the setup.log file.
        //
        result = SpLoadRepairLogFile(*FullLogFileName, RepairSifHandle);
        if (!result) {
            // 
            // Load setup.log failed. Ask user to insert a ER diskette again.
            //
            DbgErrorMesg((_asrwarn, 
                "ER: Attempt to load log file [%ws] FAILED\n", 
                *FullLogFileName
                ));
            return FALSE;
        }

        // 
        // Setup file was read. Will return TRUE
        // 
         Gbl_RepairFromErDisk = FALSE;
    }
    else {
        //
        // User did not select a system to repair
        //

        if (foundRepairableSystem) {
            // 
            // Setup found a WINNT installation, but no installation was 
            // chosen by the user.  We will go back to ask for the ER 
            // diskette again.
            //
            DbgErrorMesg((_asrwarn, "ER: Repairable systems were found, but user did not select any\n"));
            return FALSE;
        }
        else {
            //  
            // Couldn't find any NT to repair
            //
            ULONG validKeys[] = {KEY_F3, ASCI_CR, 0};
            ULONG mnemonicKeys[] = {MnemonicCustom, 0};

            DbgErrorMesg((_asrwarn, "ER: No repairable systems were found\n"));

            SpStartScreen(SP_SCRN_REPAIR_NT_NOT_FOUND,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE
                );

            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, 
                SP_STAT_ENTER_EQUALS_REPAIR,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

            SpInputDrain();

            switch (SpWaitValidKey(validKeys,NULL,NULL)) {
            case KEY_F3:
                // 
                // User wants to exit Setup
                //
                SpDone(0,TRUE,TRUE);
                break;

            default:
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOLEAN 
SpAsrGetErDiskette(IN PVOID SifHandle)
/*++

  -pending code description
  
--*/
{
    PWSTR fullLogFileName = NULL;
    BOOLEAN done = FALSE,
        hasErDisk = FALSE;

    while (!done) {
        // 
        // display message to let user know he can either provide his
        // own ER disk or let setup search for him.
        //
        if (!SpErDiskScreen(&hasErDisk)) {    
            return FALSE;        
        }

        Gbl_HandleToSetupLog = NULL;
        fullLogFileName = NULL;

        if (hasErDisk) {
            // 
            // Ask for emergency repair diskette until either we get it or
            // user cancels the request.
            //
            done = SpAsrLoadErDiskette();
            if (done) {
                Gbl_SourceSetupLogFileName = ASR_DEFAULT_SETUP_LOG_PATH;
                done = SpAsrProcessSetupLogFile(Gbl_SourceSetupLogFileName, TRUE);
            }
        }
        else {
            done = SpAsrGetErFromHardDrive(SifHandle, &Gbl_HandleToSetupLog, &fullLogFileName);

            if (fullLogFileName) {
                Gbl_SourceSetupLogFileName = SpDupStringW(fullLogFileName);
                SpMemFree(fullLogFileName);
            }
        }
    }

    DbgStatusMesg((_asrinfo, "SpAsrGetErDiskette. ER: %s Floppy. Using setup log file [%ws]\n", 
        hasErDisk?"Using":"NO", (Gbl_SourceSetupLogFileName ? Gbl_SourceSetupLogFileName : L"")));

    return TRUE;
}



PSIF_PARTITION_RECORD
SpAsrGetBootPartitionRecord(VOID)
{
    ULONG diskIndex = 0;
    PSIF_PARTITION_RECORD pRecord = NULL;

    if (Gbl_BootPartitionRecord) {
        return Gbl_BootPartitionRecord;
    }
    
    for (diskIndex = 0; diskIndex < HardDiskCount; diskIndex++) {
        //
        // Find NT partition record from the partition set table.
        //
        if (Gbl_PartitionSetTable2[diskIndex] == NULL ||
            Gbl_PartitionSetTable2[diskIndex]->pDiskRecord == NULL ||
            Gbl_PartitionSetTable2[diskIndex]->pDiskRecord->PartitionList == NULL) {
            continue;
        }

        DbgStatusMesg((_asrinfo, "Disk %lu ptn records: ", diskIndex));
        pRecord = Gbl_PartitionSetTable2[diskIndex]->pDiskRecord->PartitionList->First;

        while (pRecord) {
        
            DbgMesg((_asrinfo, "[%ws]", pRecord->CurrPartKey));
            
            if (SpAsrIsBootPartitionRecord(pRecord->PartitionFlag)) {
                ASSERT((pRecord->NtDirectoryName) && L"Boot partition is missing NT directory name.");
                return pRecord;
            }
        
            pRecord = pRecord->Next;            
        }

        DbgMesg((_asrinfo, "\n"));
    }

    DbgFatalMesg((_asrerr, "SpAsrGetBootPartitionRecord. No boot partition record was found.\n"));
    SpAsrRaiseFatalErrorWs(
        SP_SCRN_DR_SIF_BAD_RECORD,
        L"No boot partition found in asr.sif",
        SIF_ASR_PARTITIONS_SECTION
        );
    //
    // Never gets here
    //
    return NULL;
}


PWSTR
SpDrGetNtDirectory(VOID)
/*++

Routine Description:
    Returns the target path according to the value found in the asr.sif
    file, but without the leading drive letter and colon.

Arguments:
    None

Return Value:
    A pointer to a string containing the NT directory path.  This will be of
    the form:
            \WINDOWS
    and not:
            C:\WINDOWS
--*/
{
    PSIF_PARTITION_RECORD pRecord = SpAsrGetBootPartitionRecord();
    return (pRecord ? pRecord->NtDirectoryName : NULL);
}


ASRMODE
SpAsrGetAsrMode(VOID)
/*++

Routine Description:
    Returns whether ASR is in progress

Return Value:
    The Asr type currently in progress.

--*/
{
    return Gbl_AsrMode;
}


ASRMODE
SpAsrSetAsrMode(
    IN CONST ASRMODE NewAsrMode
    )
/*++

Routine Description:
    Sets the Gbl_AsrMode state variable to the value of NewAsrMode.

Arguments:
    NewAsrMode - new Asr mode

Return Value:
    Returns the previous Asr mode

--*/
{
    ASRMODE oldMode = Gbl_AsrMode;
    Gbl_AsrMode = NewAsrMode;
    return oldMode;
}



BOOLEAN
SpDrEnabled(VOID) {

    //
    // Asr is enabled if Gbl_AsrMode is set to anything other than
    // ASRMODE_NONE
    //
    return (ASRMODE_NONE != Gbl_AsrMode);
}

BOOLEAN
SpAsrIsQuickTest(VOID) {
    return (
        (ASRMODE_QUICKTEST_TEXT == Gbl_AsrMode) || 
        (ASRMODE_QUICKTEST_FULL == Gbl_AsrMode)
        );
}

BOOLEAN
SpDrIsRepairFast(VOID)
/*++

Routine Description:
    Tests whether the "Fast" Emergency Repair flag is set.

Return Value:
    TRUE    if "Fast" ER flag is set
    FALSE   otherwise

--*/
{
    return Gbl_RepairWinntFast;
}


BOOLEAN
SpDrSetRepairFast(BOOLEAN NewValue)
/*++

Routine Description:
  Sets the "Fast" Emergency Repair flag.

Arguments:
    Value   New Value (TRUE or FALSE) to which to set the
            Gbl_RepairWinntFast flag

Return Value:
    Previous value of Gbl_RepairWinntFast;

--*/
{
    BOOLEAN oldValue = Gbl_RepairWinntFast;

    Gbl_RepairWinntFast = NewValue;
    return oldValue;
}


extern VOID
SpAsrDbgDumpSystemMountPoints(VOID);

VOID
SpDrCleanup(VOID)
/*++

  -pending code description

--*/
{
    ULONG diskIndex = 0;
    
    //
    // Remove all the mountpoints in the system, we shall recreate them.
    //
    SpAsrRemoveMountPoints();

    DbgStatusMesg((_asrinfo, "Restoring volume mount points.\n"));

    for (diskIndex = 0; diskIndex < HardDiskCount; diskIndex++) {

        if (!(DISK_IS_REMOVABLE(diskIndex))) {
            SpAsrRestoreDiskMountPoints(diskIndex);
            SpAsrDbgDumpDisk(diskIndex);
        }
    }

//    DbgStatusMesg((_asrinfo, "Dumping mount points AFTER text-mode ASR:\n"));
//    SpAsrDbgDumpSystemMountPoints();
}


VOID
SpAsrCopyStateFile(VOID)
{
    NTSTATUS status = STATUS_SUCCESS;

    PWSTR diskName      = NULL,
        targetFilePath  = NULL,
        sourceFilePath  = NULL,
        bootPartition   = NULL,
        diskDeviceName  = NULL;

    SpdInitialize();

    SpFormatMessage(
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        SP_TEXT_DR_DISK_NAME
        );

    diskName = SpDupStringW(TemporaryBuffer);

    if (RemoteBootAsrSifName == NULL) {

        if (Gbl_AsrSifOnInstallationMedia) {
            wcscpy(TemporaryBuffer,NtBootDevicePath);
            SpConcatenatePaths(TemporaryBuffer,ASR_SIF_NAME);
            sourceFilePath = SpDupStringW(TemporaryBuffer);
        }
        else {
            // 
            // Prompt the user to insert the ASR disk, if it isn't
            // already in the drive
            //
            diskDeviceName = SpDupStringW(ASR_FLOPPY0_DEVICE_PATH);
            sourceFilePath = SpDupStringW(ASR_SIF_PATH);
        
            SpPromptForDisk(
                diskName,
                diskDeviceName,
                ASR_SIF_NAME,
                FALSE,              // no ignore disk in drive
                FALSE,              // no allow escape
                TRUE,               // warn multiple prompts
                NULL                // don't care about redraw flag
                );

            SpMemFree(diskDeviceName);
        }
    } else {
        sourceFilePath = SpDupStringW(RemoteBootAsrSifName);
    }

    //
    // Build the full path to the directory into which the file will be
    // written.
    //
    bootPartition = SpAsrGetRegionName(Gbl_BootPartitionRegion);
    if (!Gbl_BootPartitionDirectory) {
        Gbl_BootPartitionDirectory = SpDrGetNtDirectory();
    }
    wcscpy(TemporaryBuffer, bootPartition);
    SpConcatenatePaths(TemporaryBuffer, Gbl_BootPartitionDirectory);
    SpConcatenatePaths(TemporaryBuffer, ASR_SIF_TARGET_PATH);
    targetFilePath = SpDupStringW(TemporaryBuffer);
    SpMemFree(bootPartition);

    //
    // Copy the file.  In case of errors, user will have the option
    // to retry, or quit Setup.  We cannot skip this file.
    //
    do {

        if (SpFileExists(targetFilePath, FALSE)) {
            SpDeleteFile(targetFilePath, NULL, NULL);
        }

        status = SpCopyFileUsingNames(
            sourceFilePath,
            targetFilePath,
            0,
            0
            );

        if (!NT_SUCCESS(status)) {

            DbgErrorMesg((_asrwarn, "SpAsrCopyFiles. Could not copy asr.sif. src:[%ws] dest:[%ws]. (0x%x)\n",
                ASR_SIF_PATH,
                targetFilePath,
                status
                ));
            
            SpAsrFileErrorRetrySkipAbort(
                SP_SCRN_DR_SIF_NOT_FOUND,
                ASR_SIF_PATH,
                diskName,
                NULL,
                FALSE           // no allow skip
                );
        }
    } while (!NT_SUCCESS(status));


    SpdTerminate();
    SpMemFree(diskName);
    SpMemFree(targetFilePath);
    SpMemFree(sourceFilePath);
}


NTSTATUS
SpAsrCopy3rdPartyFiles(
    VOID
    )
{
    PWSTR bootPartition  = NULL,
        fullTargetPath   = NULL, 
        fullSourcePath   = NULL,
        windirPathPrefix = NULL,
        tempPathPrefix   = NULL;
        
    BOOL moveToNext = FALSE,
        diskLoaded  = FALSE;

    NTSTATUS status = STATUS_SUCCESS;
    PSIF_INSTALLFILE_RECORD pRec = NULL;

    if (!Gbl_3rdPartyFileList) {
        //
        // No files to copy, we're done
        //
        return STATUS_SUCCESS;  
    }

    //
    // Build the expansion strings for 
    //  %TEMP%, %TMP%, and %SYSTEMROOT%
    //
    bootPartition = SpAsrGetRegionName(Gbl_BootPartitionRegion);
    if (!Gbl_BootPartitionDirectory) {
        Gbl_BootPartitionDirectory = SpDrGetNtDirectory();
    }

    wcscpy(TemporaryBuffer, bootPartition);
    SpConcatenatePaths(TemporaryBuffer, Gbl_BootPartitionDirectory);
    windirPathPrefix = SpDupStringW(TemporaryBuffer);

    wcscpy(TemporaryBuffer, bootPartition);
    SpConcatenatePaths(TemporaryBuffer, ASR_TEMP_DIRECTORY_PATH);
    tempPathPrefix = SpDupStringW(TemporaryBuffer);

    //
    // Create the TEMP directory
    // 
    SpCreateDirectory(
        bootPartition,
        NULL,
        ASR_TEMP_DIRECTORY_PATH,
        0,
        0
        );

    SpMemFree(bootPartition);

    //
    // Initialize the compression engine. We may have to uncompress files
    //
    SpdInitialize();

    //
    // Begin copying the files over
    //

    //! display status setup is copying ...
    while (pRec = SpAsrRemoveInstallFileRecord(Gbl_3rdPartyFileList)) {

        if ((!pRec->DestinationFilePath) || 
            (!pRec->SourceFilePath) || 
            (!pRec->DiskDeviceName) ||
            (!pRec->SourceMediaExternalLabel)
            ) {
            ASSERT(0 && L"InstallFiles: Invalid record, one or more attributes are NULL");
            continue;
        }

        diskLoaded = TRUE;
    
        //
        // Prompt the user for the media if needed
        //
        if ((pRec->Flags & ASR_ALWAYS_PROMPT_FOR_MEDIA) ||
            (pRec->Flags & ASR_PROMPT_USER_ON_MEDIA_ERROR)
            ) {

            do {
                moveToNext = TRUE;

                //
                // Prompt the user to insert the appropriate disk
                //
                diskLoaded = SpPromptForDisk(
                    pRec->SourceMediaExternalLabel,
                    pRec->DiskDeviceName,   // if this isn't CD or floppy, SpPromptForDisk will always return true
                    pRec->SourceFilePath,
                    (BOOLEAN)(pRec->Flags & ASR_ALWAYS_PROMPT_FOR_MEDIA),     // IgnoreDiskInDrive if PromptAlways
                    ! (BOOLEAN)(pRec->Flags & ASR_FILE_IS_REQUIRED),           // AllowEscape if the File is not Required
                    TRUE,       // WarnMultiplePrompts
                    NULL
                    );

                //
                // If the user hit <ESC> to cancel, we put up a prompt allowing
                // him to retry, skip this file and continue, or exit from Setup.
                //
                if (!diskLoaded)  {

                    moveToNext = SpAsrFileErrorRetrySkipAbort(
                        SP_SCRN_DR_SIF_INSTALL_FILE_NOT_FOUND,
                        pRec->SourceFilePath,
                        pRec->SourceMediaExternalLabel,
                        pRec->VendorString,
                        !(pRec->Flags & ASR_FILE_IS_REQUIRED)            // allow skip
                        );

                }

            } while (!moveToNext);
        }


        if (!diskLoaded) {
            //
            // Disk was not loaded and the user wants to skip this file
            //
            DbgErrorMesg((_asrwarn, 
                "SpDrCopy3rdPartyFiles: User skipped file (disk not loaded), src:[%ws] dest[%ws]\n",
                pRec->SourceFilePath,
                pRec->DestinationFilePath
                ));

            continue;
        }

        //
        // The correct disk was loaded. Build the full target path.  pRec->CopyToDirectory 
        // indicates which prefix we should use.
        //
        switch (pRec->CopyToDirectory) {
            case _SystemRoot:
                wcscpy(TemporaryBuffer, windirPathPrefix);
                break;

            case _Temp:
            case _Tmp:
            case _Default:
            default:
                wcscpy(TemporaryBuffer, tempPathPrefix);
                break;
        }

        SpConcatenatePaths(TemporaryBuffer, pRec->DestinationFilePath);
        fullTargetPath = SpDupStringW(TemporaryBuffer);

        //
        // If the file already exists, prompt the user if needed.  We allow him
        // to over-write (delete the existing file), preserve existing
        // (skip copying this file), or exit from Setup.
        //
        if (SpFileExists(fullTargetPath, FALSE)) {
            BOOL deleteFile = FALSE;

            if (pRec->Flags & ASR_PROMPT_USER_ON_COLLISION) {
                if (SpAsrFileErrorDeleteSkipAbort(SP_SCRN_DR_OVERWRITE_EXISTING_FILE, fullTargetPath)) {
                    deleteFile = TRUE;
                }
            }
            else if (pRec->Flags & ASR_OVERWRITE_ON_COLLISION) {
                deleteFile = TRUE;
            }

            if (deleteFile) {
                //
                // User chose to overwrite (or OVERWRITE_ON_COLLISION flag was set)
                //
                SpDeleteFile(fullTargetPath, NULL, NULL);

                DbgErrorMesg((_asrwarn, 
                    "SpDrCopy3rdPartyFiles: Over-writing file, src:[%ws] dest[%ws]\n",
                    pRec->SourceFilePath,
                    fullTargetPath
                    ));
            }
            else {
                // 
                // User chose to preserve existing file
                // 
                DbgErrorMesg((_asrwarn, 
                    "SpDrCopy3rdPartyFiles: File exists, existing file was preserved. src:[%ws] dest[%ws]\n",
                    pRec->SourceFilePath,
                    fullTargetPath
                    ));
                continue;
            }
        }

        // 
        // Combine the devicepath ("\device\cdrom0") and the sourcefilepath 
        // ("i386\driver.sys") to get the full path ("\device\cdrom0\i386\driver.sys")
        // SpConcatenatePaths takes care of adding in the \ between the two if needed
        //
        wcscpy(TemporaryBuffer, pRec->DiskDeviceName);
        SpConcatenatePaths(TemporaryBuffer, pRec->SourceFilePath);
        fullSourcePath = SpDupStringW(TemporaryBuffer);

        moveToNext = FALSE;
        while (!moveToNext) {

            moveToNext = TRUE;
            status = SpCopyFileUsingNames(
                fullSourcePath,
                fullTargetPath,
                0,  // no attributes
                0   // no flags
                );

            if (!NT_SUCCESS(status)) {

                DbgErrorMesg((_asrwarn, "SpDrCopy3rdPartyFiles. SpCopyFileUsingNames failed. src:[%ws] dest:[%ws]. (0x%x)\n",
                    pRec->SourceFilePath,
                    fullTargetPath,
                    status
                    ));

                //
                // File copy was unsuccessful, we put up a prompt allowing
                // the user to retry, skip this file and continue, or exit 
                // from Setup.
                //
                if ((pRec->Flags & ASR_ALWAYS_PROMPT_FOR_MEDIA) || 
                    (pRec->Flags & ASR_PROMPT_USER_ON_MEDIA_ERROR)) {

                    moveToNext = SpAsrFileErrorRetrySkipAbort(
                        SP_SCRN_DR_SIF_INSTALL_FILE_NOT_FOUND,
                        pRec->SourceFilePath,
                        pRec->SourceMediaExternalLabel,
                        pRec->VendorString,
                        TRUE            // allow skip
                        );
                }
                else {
                    moveToNext = TRUE;
                }
            }
        }

        if (!NT_SUCCESS(status)) {
            DbgErrorMesg((_asrwarn, "SpDrCopy3rdPartyFiles: Unable to copy file (copy error), src:[%ws] dest[%ws]\n",
                pRec->SourceFilePath,
                fullTargetPath
                ));
        } 
        else {
           DbgStatusMesg((_asrinfo, "SpDrCopy3rdPartyFiles. Copied [%ws] to [%ws]\n", 
               pRec->SourceFilePath, 
               fullTargetPath
               ));
        }
        
        SpMemFree(fullSourcePath);
        SpMemFree(fullTargetPath);
        SpAsrDeleteInstallFileRecord(pRec);
    }

    //
    // Done.  Shut down the compression engine.
    //
    SpdTerminate();
    SpMemFree(Gbl_3rdPartyFileList);
    SpMemFree(tempPathPrefix);
    SpMemFree(windirPathPrefix);

    return STATUS_SUCCESS;
}


NTSTATUS
SpDrCopyFiles(VOID) 
{
    SpAsrCopyStateFile();
    return SpAsrCopy3rdPartyFiles();
}



#define STRING_VALUE(s) REG_SZ,(s),(wcslen((s))+1)*sizeof(WCHAR)

NTSTATUS
SpDrSetEnvironmentVariables(HANDLE *HiveRootKeys)
{
    NTSTATUS status;

    status = SpOpenSetValueAndClose(
                HiveRootKeys[SetupHiveSystem],
                ASR_CONTEXT_KEY,
                ASR_CONTEXT_VALUE,
                STRING_VALUE(ASR_CONTEXT_DATA));

    DbgStatusMesg((_asrinfo, "Set [%ws]\\[%ws] to [%ws] (0x%x)\n", 
                ASR_CONTEXT_KEY,
                ASR_CONTEXT_VALUE,
                ASR_CONTEXT_DATA, 
                status));

    if (!NT_SUCCESS(status)) {
        return status;
    }
    
    Gbl_SystemPartitionName = SpAsrGetRegionName(Gbl_SystemPartitionRegion);
    status = SpOpenSetValueAndClose(
                HiveRootKeys[SetupHiveSystem],
                ASR_CONTEXT_KEY,
                ASR_SYSTEM_PARTITION_VALUE,
                STRING_VALUE(Gbl_SystemPartitionName));

    DbgStatusMesg((_asrinfo, "Set [%ws]\\[%ws] to [%ws] (0x%x)\n", 
                ASR_CONTEXT_KEY,
                ASR_SYSTEM_PARTITION_VALUE,
                Gbl_SystemPartitionName,
                status));

    if (!NT_SUCCESS(status)) {
        return status;
    }

    Gbl_BootPartitionName = SpAsrGetRegionName(Gbl_BootPartitionRegion);
    status = SpOpenSetValueAndClose(
                HiveRootKeys[SetupHiveSystem],
                ASR_CONTEXT_KEY,
                ASR_BOOT_PARTITION_VALUE,
                STRING_VALUE(Gbl_BootPartitionName));

    DbgStatusMesg((_asrinfo, "Set [%ws]\\[%ws] to [%ws] (0x%x)\n", 
                ASR_CONTEXT_KEY,
                ASR_BOOT_PARTITION_VALUE,
                Gbl_BootPartitionName,
                status));

    return status;
}


PDISK_REGION
SpAsrPrepareBootRegion(
    IN PVOID SifHandle,
    IN PWSTR Local_SetupSourceDevicePath,
    IN PWSTR Local_DirectoryOnSetupSource
    )
/*++

  -pending code description

--*/
{
    PWSTR systemKey = ASR_SIF_SYSTEM_KEY;
    PWSTR ntDir = NULL;
    ULONG diskIndex = 0;
    PSIF_PARTITION_RECORD ppartitionRecord = NULL;
    FilesystemType regionFsType = FilesystemUnknown;
    BOOLEAN isBoot = FALSE;
    
    //
    // Initialize Gbl_BootPartitionDriveLetter.
    //
    ntDir = SpAsrGetNtDirectoryPathBySystemKey(systemKey);

    if (!SpAsrIsValidBootDrive(ntDir)) {
        SpAsrRaiseFatalErrorWs(
            SP_SCRN_DR_SIF_BAD_RECORD,
            L"Windows directory specified in asr.sif is invalid",
            SIF_ASR_SYSTEMS_SECTION
            );
        // Does not return 
    }

    Gbl_BootPartitionDriveLetter = ntDir[0];

    //
    // Find boot partition region from the partition set table. 
    // from the records in the global partition set.
    //
    Gbl_BootPartitionRegion = NULL;
    for (diskIndex = 0; (diskIndex < HardDiskCount); diskIndex++) {

        if (!(Gbl_PartitionSetTable2[diskIndex] &&
              Gbl_PartitionSetTable2[diskIndex]->pDiskRecord &&
              Gbl_PartitionSetTable2[diskIndex]->pDiskRecord->PartitionList)) {
            continue;
        }

        ppartitionRecord = Gbl_PartitionSetTable2[diskIndex]->pDiskRecord->PartitionList->First;
        
        while (ppartitionRecord) {
            isBoot = SpAsrIsBootPartitionRecord(ppartitionRecord->PartitionFlag);
            if (isBoot) {
                
                Gbl_BootPartitionRegion = SpAsrDiskPartitionExists(diskIndex, ppartitionRecord);

                if (!Gbl_BootPartitionRegion) {
                    DbgFatalMesg((_asrerr, 
                        "Partition record with boot region found, but boot (winnt) region is NULL\n"
                        ));

                    SpAsrRaiseFatalError(SP_SCRN_DR_CREATE_ERROR_DISK_PARTITION, 
                        L"Boot pRegion is NULL"
                        );
                }

                Gbl_BootPartitionRecord = SpAsrCopyPartitionRecord(ppartitionRecord);
                break;
            }

            ppartitionRecord = ppartitionRecord->Next;            
        }

    }

    if (!Gbl_BootPartitionRegion) {
        
        DbgFatalMesg((_asrerr, "No partition record with boot region found, boot (winnt) region is NULL\n"));

        SpAsrRaiseFatalErrorWs(
            SP_SCRN_DR_SIF_BAD_RECORD,
            L"No boot partition found in asr.sif",
            SIF_ASR_PARTITIONS_SECTION
            );
    }

    SpAsrReformatPartition(Gbl_BootPartitionRegion,
        Gbl_BootPartitionRecord->FileSystemType,
        SifHandle,
        Gbl_BootPartitionRecord->ClusterSize,
        Local_SetupSourceDevicePath,
        Local_DirectoryOnSetupSource,
        TRUE
        );

    return Gbl_BootPartitionRegion;
}


PDISK_REGION
SpAsrPrepareSystemRegion(
    IN PVOID SifHandle,
    IN PWSTR Local_SetupSourceDevicePath,
    IN PWSTR Local_DirectoryOnSetupSource
    )
/*++

  -pending code description

--*/
{
    ULONG diskIndex = 0;
    BOOLEAN found = FALSE;

    BOOLEAN diskChanged = FALSE;

    PWSTR partitionDeviceName = NULL;
    PDISK_REGION pRegion = NULL;
    PSIF_PARTITION_RECORD ppartitionRecord = NULL;
            
    ULONGLONG startSector = 0;
    DWORD diskNumber = 0;


    if (IsNEC_98) {
        // This is a NEC x86 machine

        pRegion = Gbl_BootPartitionRegion;
        ASSERT(pRegion);

    } else {
        // This is not a NEC x86 machine

#ifdef _IA64_

        WCHAR   RegionName[MAX_PATH];

        if (!(pRegion = SpPtnLocateESP())) {
            SpAsrRaiseFatalError(SP_SCRN_DR_CREATE_ERROR_DISK_PARTITION, 
                L"System Region is NULL"
                );
        }

        SPPT_MARK_REGION_AS_SYSTEMPARTITION(pRegion, TRUE);
        SPPT_SET_REGION_DIRTY(pRegion, TRUE);
        ValidArcSystemPartition = TRUE;
        //
        // Remove the drive letter also
        //
        swprintf(RegionName, 
            L"\\Device\\Harddisk%u\\Partition%u",
            pRegion->DiskNumber,
            pRegion->PartitionNumber);
        
        SpDeleteDriveLetter(RegionName);            
        pRegion->DriveLetter = 0;

#else 
    
        if (!(pRegion = SpPtValidSystemPartition())) {
            SpAsrRaiseFatalError(SP_SCRN_DR_CREATE_ERROR_DISK_PARTITION, 
                L"System Region is NULL"
                );
        }
    
#endif
    }

    partitionDeviceName = SpAsrGetRegionName(pRegion);
    DbgStatusMesg((_asrinfo, "PrepareSystemRegion. sys-ptn:[%ws]. Making Active\n", 
        partitionDeviceName));

    startSector = pRegion->StartSector;
    diskNumber = pRegion->DiskNumber;

#ifndef _IA64_
    
    SpPtnMakeRegionActive(pRegion);

#endif

    SpPtnCommitChanges(pRegion->DiskNumber, &diskChanged);
    DbgStatusMesg((
        _asrinfo, 
        "PrepareSystemRegion. sys-region made active. Disk %lu. %s.\n", 
        pRegion->DiskNumber, 
        diskChanged ? "Disk not changed.":"Disk changed"
        ));


    pRegion = SpPtLookupRegionByStart(SPPT_GET_PARTITIONED_DISK(diskNumber), FALSE, startSector);

    //
    // Consistency checks.  These can eventually be removed 
    //
    ASSERT(pRegion);

    diskIndex = pRegion->DiskNumber;
    ASSERT(Gbl_PartitionSetTable2[diskIndex]);
    ASSERT(Gbl_PartitionSetTable2[diskIndex]->pDiskRecord);
    ASSERT(Gbl_PartitionSetTable2[diskIndex]->pDiskRecord->PartitionList);
    
    //
    // Ensure that the partition is correctly formatted.  To accomplish this,
    // we need to find the record corresponding to this pRegion. We use the 
    // record to check for the correct file format.
    //
    ppartitionRecord = Gbl_PartitionSetTable2[diskIndex]->pDiskRecord->PartitionList->First;
    while (ppartitionRecord) {
        if ((ULONGLONG)ppartitionRecord->StartSector == pRegion->StartSector) {
            found = TRUE;
            break;
        }

        ppartitionRecord = ppartitionRecord->Next;
    }

    if (!found) {
        DbgFatalMesg((_asrerr, 
            "Did not find system partition, start sector: %I64u\n", 
            pRegion->StartSector
            ));

        SpAsrRaiseFatalErrorWs(
            SP_SCRN_DR_SIF_BAD_RECORD,
            L"No system partition found in asr.sif",
            SIF_ASR_PARTITIONS_SECTION
            );
    }
    
    //
    // Format the system partition if needed.  We don't re-format the system
    // partition if it's intact.
    //
    if (SpAsrPartitionNeedsFormatting(pRegion, ppartitionRecord->FileSystemType)) {

        SpAsrReformatPartition(
            pRegion,
            ppartitionRecord->FileSystemType,
            SifHandle,
            ppartitionRecord->ClusterSize,
            Local_SetupSourceDevicePath,
            Local_DirectoryOnSetupSource,
            FALSE
            );                        
    }

    SpMemFree(partitionDeviceName);

    Gbl_SystemPartitionRegion = pRegion;
    return Gbl_SystemPartitionRegion;
}


#if 0
//
// We don't convert the partition types any more--it is okay to leave
// them as type 0x42 if the partitions are intact.
//
BOOLEAN
SpAsrChangeLdmPartitionTypes(VOID)
/*++

Routine Description
    Changes disk types from 0x42 to 0x7 if needed
    (If the disk is intact, it would not have been re-created
    and hence re-typed above)

--*/

{
    ULONG setIndex;
    ULONG ptnIndex;
    PDISK_PARTITION_SET ppartitionSet;
    PSIF_DISK_RECORD pdiskRecord;
    PSIF_PARTITION_RECORD ppartitionRecord;
    BOOLEAN madeAChange = FALSE;

    // Look for any disks which were marked to change from type 0x42 to
    // type 0x7.

    for (setIndex = 0; setIndex < HardDiskCount; setIndex++) {

        ppartitionSet = Gbl_PartitionSetTable2[setIndex];

        if (ppartitionSet && ppartitionSet->pDiskRecord) {
            pdiskRecord = ppartitionSet->pDiskRecord;

            if (pdiskRecord->ContainsNtPartition  ||
                pdiskRecord->ContainsSystemPartition) {
                
                ppartitionRecord = pdiskRecord->PartitionList->First;

                while (ppartitionRecord)  {

                    if (ppartitionRecord->NeedsLdmRetype) {

                        // Disk type needs to be changed

                        PPARTITIONED_DISK pDisk;
                        PDISK_REGION pRegion = NULL;

                        pDisk = &PartitionedDisks[setIndex];

                        // try finding the disk region in the main list
                        pRegion = SpPtLookupRegionByStart(pDisk, FALSE, ppartitionRecord->StartSector);

                        if (!pRegion) {
                            // that failed, try finding disk region using the 
                            // extended partitions list
                            pRegion = SpPtLookupRegionByStart(pDisk, TRUE, ppartitionRecord->StartSector);
                        }

                        if (!pRegion) {
                            // the disk region couldn't be found
                            DbgErrorMesg((_asrwarn, "SpAsrChangeLdmPartitionTypes. Unable to reset LDM partition record %ws at SS %I64u\n",
                                        ppartitionRecord->CurrPartKey,
                                        ppartitionRecord->StartSector));

                            ppartitionRecord = ppartitionRecord->Next;
                            continue;
                        }

                        // The disk region was found, now change the disk type
                        if (!IsRecognizedPartition(ppartitionRecord->FileSystemType)) {
                            //
                            // This is an 0x42 partition on the boot/sys disk, but it is
                            // not the boot or system partition.  The FileSystemType is not
                            // recognised since it  is set to be 0x42 as well.  (The 
                            // FileSystemType is only valid for the boot and system 
                            // partitions--for all other partitions,
                            // it is set to be the same as the PartitionType)
                            //
                            // We set it to 0x7 for the time being.  The actual file-system type
                            // will be set later in GUI-Setup by asr_ldm and asr_fmt.
                            //
                            DbgStatusMesg((_asrinfo, 
                                "MBR ptn-rec %ws re-typed (0x%x->0x7) \n", 
                                ppartitionRecord->CurrPartKey, 
                                ppartitionRecord->FileSystemType
                                ));
                            ppartitionRecord->FileSystemType = PARTITION_IFS;
                            ppartitionRecord->PartitionType = PARTITION_IFS;

                        }
                        else {

                            DbgStatusMesg((_asrinfo, 
                                "MBR ptn-rec %ws re-typed (0x%x->0x%x).\n", 
                                ppartitionRecord->CurrPartKey, 
                                ppartitionRecord->PartitionType, 
                                ppartitionRecord->FileSystemType
                                ));
                            ppartitionRecord->PartitionType = ppartitionRecord->FileSystemType;

                        }
 
                        ppartitionRecord->NeedsLdmRetype = FALSE;

                        SPPT_SET_PARTITION_TYPE(pRegion, ppartitionRecord->FileSystemType);
                        SPPT_SET_REGION_DIRTY(pRegion, TRUE);
                        
                        pRegion->DynamicVolume = TRUE;
                        pRegion->DynamicVolumeSuitableForOS = TRUE;
                        madeAChange = TRUE;
 
                        DbgStatusMesg((_asrinfo, "SpAsrChangeLdmPartitionTypes. Changed disk [%ws] ptn [%ws] type to 0x%x\n", 
                                   pdiskRecord->CurrDiskKey, ppartitionRecord->CurrPartKey, ppartitionRecord->PartitionType));
                    }

                    ppartitionRecord = ppartitionRecord->Next;
                }
            }

        }
    }

    return madeAChange;
}
#endif  // 0

extern VOID
SpAsrDbgDumpInstallFileList(IN PSIF_INSTALLFILE_LIST pList);

VOID
SpAsrSetNewDiskID(
    IN ULONG DiskNumber,
    IN GUID *NewGuid,       // valid only for GPT disks
    IN ULONG NewSignature   // valid only for MBR disks
    ) 
{
    PPARTITIONED_DISK pDisk = &PartitionedDisks[DiskNumber];
    PDISK_REGION pFirstRegion = NULL;
    BOOLEAN Changes = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    if (PARTITION_STYLE_GPT == (PARTITION_STYLE) (pDisk->HardDisk->DriveLayout.PartitionStyle)) {
        //
        // Set the new disk GUID 
        //
        CopyMemory(&(pDisk->HardDisk->DriveLayout.Gpt.DiskId), NewGuid, sizeof(GUID));
    }
    else if (PARTITION_STYLE_MBR == (PARTITION_STYLE) (pDisk->HardDisk->DriveLayout.PartitionStyle)) {
        //
        // Set the new disk signature
        //
        pDisk->HardDisk->DriveLayout.Mbr.Signature = NewSignature;
    }
    else {
        return;
    }


    //
    // For Commit to pick up the new Guid, at least one region on the
    // disk must be marked dirty.
    //
    pFirstRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
    SPPT_SET_REGION_DIRTY(pFirstRegion, TRUE);

    Status = SpPtnCommitChanges(DiskNumber, &Changes);

    //
    // Reset the dirty flag on the first region
    //
    pFirstRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
    SPPT_SET_REGION_DIRTY(pFirstRegion, FALSE);

}


NTSTATUS
SpDrPtPrepareDisks(
    IN  PVOID           SifHandle,
    OUT PDISK_REGION    *BootPartitionRegion,
    OUT PDISK_REGION    *SystemPartitionRegion,
    IN  PWSTR           SetupSourceDevicePath,
    IN  PWSTR           DirectoryOnSetupSource,
    OUT BOOLEAN         *RepairedNt
    )
/*++

  Description:
    If necessary, SpDrPtPrepareDisks() restores (recreates and formats) the
    system and boot partitions based on information obtained from the
    asr.sif file.

  Arguments:
    SifHandle               - Handle to txtsetup.sif

    BootPartitionRegion    - Receives a pointer to the partition into 
                              which NT will be installed (e.g., \WINNT).
    
    SystemPartitionRegion   - Receives a pointer to the partition into 
                              which the boot loader will be installed.

    SetupSourceDevicePath   - Path to the CDROM

    DirectoryOnSetupSource  - The directory on the installation CDROM.  
                              (usually "\I386" for x86 installations)
    
    RepairedNt  - Receives a pointer to a boolean value that is set to:
                  TRUE: Indicates the partition structure on the loader 
                        disk and he partition structure on the NT disk were 
                        intact and that ASR attempted to perform a repair 
                        operation.
                  FALSE: Indicates the partition structure on either the
                        loader disk or the NT disk (or both) were removed
                        and recreated. When SpStartSetup() sees this value, 
                        it will proceed with a normal installation.

  Return Value:
    STATUS_SUCCESS, always! (as of now, anyway)

--*/
{
    BOOL done = TRUE,
        next = TRUE,
        warningScreenDone = FALSE;

    NTSTATUS status;

    ULONG diskIndex = 0;

    PWSTR setupSourceDevicePath = NULL, 
        directoryOnSetupSource = NULL;
 
    DbgStatusMesg((_asrinfo, "Entering SpDrPtPrepareDisks. Beginning ASR/ER/RC Processing\n"));
    DbgStatusMesg((_asrinfo, "SetupSourceDevicePath:[%ws], DirectoryOnSetupSource:[%ws]\n",
        SetupSourceDevicePath, DirectoryOnSetupSource));

    *RepairedNt = FALSE;

    //
    // find out if the user wants Recovery Console, traditional Emergency 
    // Repair (ER), or full scale Automated System Recovery (ASR)
    //
    Gbl_SifHandle = SifHandle;
    setupSourceDevicePath = SpDupStringW(SetupSourceDevicePath);
    directoryOnSetupSource = SpDupStringW(DirectoryOnSetupSource);

    do {

        if (!done) {
            DbgStatusMesg((_asrinfo, "User hit <ESC> to cancel. Prompting for ASR/ER/RC again\n"));
        }

        if (!SpDrEnabled() || RepairWinnt) {
            SpAsrQueryRepairOrDr();
        }

        if(ForceConsole) {          // Recovery Console
            DbgStatusMesg((_asrinfo, "User chose Recovery Console. Exiting SpDrPtPrepareDisks.\n"));
            return STATUS_SUCCESS;
        }

        DbgStatusMesg((_asrinfo, "User chose %s, sys-drive:[%wc], nt/boot-drive:[%wc]\n",
                    RepairWinnt ? Gbl_RepairWinntFast ? "Fast ER" : "Manual ER" : "ASR",
                    (Gbl_SystemPartitionRegion ? Gbl_SystemPartitionRegion->DriveLetter : L'\\'),
                    (Gbl_BootPartitionRegion ? Gbl_BootPartitionRegion->DriveLetter : L'\\') ));

        //
        // Prompt for ER/ASR floppy
        //
        if (RepairWinnt) {          // ER
            done = SpAsrGetErDiskette(SifHandle);
        }    
        else {                      // ASR
            if (ASRMODE_NORMAL == SpAsrGetAsrMode()) {
                SpInitializePidString(SifHandle, SetupSourceDevicePath, DirectoryOnSetupSource);
            }
            done = SpAsrLoadAsrDiskette();
        }
    } while (!done);


    //
    //  At this point, if RepairWinnt is TRUE, user wants ER, else user 
    //  wants ASR. (If he wanted Recovery Console we would've returned 
    //  STATUS_SUCCESS above.) In either case, the appropriate disk is 
    //  already in the drive
    //
    if (RepairWinnt) {              // ER

        //
        // if the boot partition was not repaired (deleted, recreated, and
        // reformatted), then attempt an emergency repair of the system.
        //
        if (Gbl_NtPartitionIntact == TRUE) {
            
            *RepairedNt = SpAsrAttemptRepair(
                SifHandle,
                SetupSourceDevicePath,
                DirectoryOnSetupSource,
                SetupSourceDevicePath,
                DirectoryOnSetupSource
                );
                
            if (*RepairedNt) {
                WinntSetup = FALSE;
            }

            *SystemPartitionRegion = Gbl_SystemPartitionRegion;
            *BootPartitionRegion = Gbl_BootPartitionRegion;
        }
        else {
            //
            // If the NT partition is not intact, we cannot do an ER.
            //
            SpAsrCannotDoER();
            SpDone(0, FALSE, TRUE);
        }
    }
    else {                          // ASR
        SpAsrInitIoDeviceCount();
        SpAsrCheckAsrStateFileVersion();
        SpAsrCreatePartitionSets(setupSourceDevicePath, directoryOnSetupSource);
        Gbl_3rdPartyFileList = SpAsrInit3rdPartyFileList(SetupSourceDevicePath);
        SpAsrDbgDumpPartitionSets();
        SpAsrDeleteMountedDevicesKey();
        SpAsrRemoveMountPoints();     // restored by asr_fmt.exe etc

        //
        // Check hard disks and repartition as needed
        //
        next = TRUE;
        for (diskIndex = 0; diskIndex < HardDiskCount; (diskIndex += (next ? 1 : 0))) {

            BOOLEAN skip = FALSE;

            next = TRUE;
            SpAsrDbgDumpDisk(diskIndex);

            if (!warningScreenDone) {
                skip = SpAsrpSkipDiskRepartition(diskIndex, FALSE);
                if (!skip) {
                    // 
                    // If we are going to repartition a disk, put up the 
                    // warning screen to make sure the user knows all 
                    // partitions on the disk are going to get clobbered, 
                    // but only once - after the first disk with a problem, 
                    // don't display the screen again.
                    //
                    SpAsrClobberDiskWarning();
                    warningScreenDone = TRUE;
                }
            }

            skip = SpAsrpSkipDiskRepartition(diskIndex, TRUE);
            if (!skip) {
                CREATE_DISK CreateDisk;
                PSIF_DISK_RECORD pCurrentDisk = Gbl_PartitionSetTable1[diskIndex]->pDiskRecord;
                PHARD_DISK HardDisk = SPPT_GET_HARDDISK(diskIndex);
                BOOLEAN IsBlank = TRUE;
                BOOLEAN preservePartitions = FALSE;
                UCHAR MbrPartitionType = PARTITION_ENTRY_UNUSED;

                //
                // We're here because the partition structure of the disk does not
                // match with that specified by the SIF file.  As a consequence
                // all of the partitions on this disk will be removed and recreated.
                //
                if (SpPtnGetPartitionCountDisk(diskIndex) || 
                    SpPtnGetContainerPartitionCount(diskIndex)) {
                    //
                    // The physical disk has partitions, clear them
                    //
                    // On GPT disks, we erase all the partitions with the 
                    // exception of the EFI System Partition.  Note that we
                    // delete all foreign/unrecognised partitions as
                    // well.
                    //
                    // For MBR disks, we erase all the partitions with the
                    // exception of any OEM partitions.  Note that as in the
                    // case of GPT disks, we delete unrecognised/foriegn
                    // partitions.
                    // 

                    //
                    // Get the partition type of the first partition on the
                    // sifDisk.  If this is an OEM partition, and the
                    // current disk has a partition with the same exact
                    // partition type, we should preserve it.
                    //
                    if (PARTITION_STYLE_MBR == pCurrentDisk->PartitionStyle) {

                        if (((pCurrentDisk->ContainsNtPartition) 
                                || (pCurrentDisk->ContainsSystemPartition)) &&
                            (pCurrentDisk->PartitionList) &&
                            (pCurrentDisk->PartitionList->First)) {

                            MbrPartitionType = pCurrentDisk->PartitionList->First->PartitionType;
                        }

                        if (IsOEMPartition(MbrPartitionType)) {
                            preservePartitions = TRUE;
                        }

                    }
                    else if (PARTITION_STYLE_GPT == pCurrentDisk->PartitionStyle) {

                        preservePartitions = TRUE;
                    }


                    SpAsrDeletePartitions(diskIndex, preservePartitions, MbrPartitionType, &IsBlank); 
                }

                if (IsBlank) {
                    //
                    // The disk is blank, set the appropriate signature/ID
                    //
                    ZeroMemory(&CreateDisk, sizeof(CREATE_DISK));
                    CreateDisk.PartitionStyle = pCurrentDisk->PartitionStyle;

                    if (PARTITION_STYLE_MBR == pCurrentDisk->PartitionStyle) {
                        CreateDisk.Mbr.Signature = pCurrentDisk->SifDiskMbrSignature;
                    }
                    else if (PARTITION_STYLE_GPT == pCurrentDisk->PartitionStyle) {

                        CopyMemory(&(CreateDisk.Gpt.DiskId), 
                            &(pCurrentDisk->SifDiskGptId), 
                            sizeof(GUID));

                        CreateDisk.Gpt.MaxPartitionCount = pCurrentDisk->MaxGptPartitionCount;
                    }
                    else {
                        ASSERT(0 && L"Unrecognised partition style");
                        continue;
                    }

                    SPPT_SET_DISK_BLANK(diskIndex, TRUE);

                    //
                    // Intialise the disk to the appropriate style
                    //
                    status = SpPtnInitializeDiskStyle(diskIndex, pCurrentDisk->PartitionStyle, &CreateDisk);

                    if (NT_SUCCESS(status)) {
                        status = SpPtnInitializeDiskDrive(diskIndex);
                    }
                }
                else {
                    //
                    // Special case:  the EFI system partition, or some OEM 
                    // partition, was preserved.  We should just update 
                    // the disk GUID or signature.
                    //
                    SpAsrSetNewDiskID(diskIndex, &(pCurrentDisk->SifDiskGptId), pCurrentDisk->SifDiskMbrSignature);
                }

                //
                // Create the new paritions
                //
                SpAsrRecreateDiskPartitions(diskIndex, (preservePartitions && (!IsBlank)), MbrPartitionType);
            }
        }

        SpAsrDbgDumpPartitionLists(2, L"After partition recreation.");

        //
        // Format the Boot partition.  (Always, EXCEPT in automated tests)
        // This won't return if the boot partition region doesn't exist
        //
        *BootPartitionRegion = SpAsrPrepareBootRegion(
            SifHandle,
            setupSourceDevicePath,
            directoryOnSetupSource
            );

        //
        // Format the system partition only if necessary.
        // This won't return if the system partition region doesn't exist
        //
        *SystemPartitionRegion = SpAsrPrepareSystemRegion(
            SifHandle,
            setupSourceDevicePath,
            directoryOnSetupSource
            );

    }  // RepairWinnt

    SpMemFree(setupSourceDevicePath);
    SpMemFree(directoryOnSetupSource);

    DbgStatusMesg((_asrinfo, "Exiting SpDrPtPrepareDisks\n"));
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spdriver.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdriver.c

Abstract:

    Device-driver interface routines for text setup.

Author:

    Ted Miller (tedm) 11-August-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop
#include "spcmdcon.h"


PSETUP_COMMUNICATION CommunicationParams;

PVOID                RequestReadyEventObjectBody;
PVOID                RequestReadyEventWaitObjectBody;

PVOID                RequestServicedEventObjectBody;
PVOID                RequestServicedEventWaitObjectBody;

PEPROCESS            UsetupProcess;
PAUTOCHK_MSG_PROCESSING_ROUTINE pAutochkCallbackRoutine;


SYSTEM_BASIC_INFORMATION SystemBasicInfo;

BOOLEAN AutochkRunning = FALSE;
BOOLEAN AutofrmtRunning = FALSE;

NTSTATUS
SetupOpenCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SetupClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SetupDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SetupUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SpInitialize0(
    IN PDRIVER_OBJECT DriverObject
    );

BOOLEAN
pSpVerifyEventWaitable(
    IN  HANDLE  hEvent,
    OUT PVOID  *EventObjectBody,
    OUT PVOID  *EventWaitObjectBody
    );

ULONG
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the setup driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
            for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status;
    UNICODE_STRING unicodeString;
    PDEVICE_OBJECT deviceObject;

    //
    // Create exclusive device object.
    //

    RtlInitUnicodeString(&unicodeString,DD_SETUP_DEVICE_NAME_U);

    status = IoCreateDevice(
                DriverObject,
                0,
                &unicodeString,
                FILE_DEVICE_UNKNOWN,
                0,
                FALSE,
                &deviceObject
                );

    if(!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create device object (%lx)\n",status));
        return(status);
    }

    //
    // Set up device driver entry points.
    //
  //DriverObject->DriverStartIo = NULL;
    DriverObject->DriverUnload = SetupUnload;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = SetupOpenCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = SetupClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SetupDeviceControl;
  //DriverObject->MajorFunction[IRP_MJ_CLEANUP] = NULL;

    return((ULONG)SpInitialize0(DriverObject));
}




VOID
SetupUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is the setup driver unload routine.

Arguments:

    DriverObject - Pointer to driver object.

Return Value:

    None.

--*/

{
    //
    // Delete the device object.
    //

    IoDeleteDevice(DriverObject->DeviceObject);

    return;
}



NTSTATUS
SetupOpenCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for open/create.
    When the setup device is opened, text setup begins.
    The open/create does not complete until text setup is done.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = FILE_OPENED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return(STATUS_SUCCESS);
}




NTSTATUS
SetupClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for close.
    Close requests are completed here.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    //
    // Complete the request and return status.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return(STATUS_SUCCESS);
}



NTSTATUS
SetupDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;
    PSETUP_START_INFO SetupStartInfo;
    BOOLEAN b;


    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch(IrpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_SETUP_START:

        //
        // Make sure we've been passed a suitable input buffer.
        //

        if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SETUP_START_INFO)) {

            Status = STATUS_INVALID_PARAMETER;

        } else {

            //
            // Save away relevent fields in the setup information
            // parameters.
            //
            SetupStartInfo = (PSETUP_START_INFO)Irp->AssociatedIrp.SystemBuffer;

            ResourceImageBase =  SetupStartInfo->UserModeImageBase;

            CommunicationParams = SetupStartInfo->Communication;

            UsetupProcess = PsGetCurrentProcess();
            // KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: usetup process = %lx \n", UsetupProcess));

            b = pSpVerifyEventWaitable(
                    SetupStartInfo->RequestReadyEvent,
                    &RequestReadyEventObjectBody,
                    &RequestReadyEventWaitObjectBody
                    );

            if(!b) {
                Status = STATUS_INVALID_HANDLE;
                break;
            }

            b = pSpVerifyEventWaitable(
                    SetupStartInfo->RequestServicedEvent,
                    &RequestServicedEventObjectBody,
                    &RequestServicedEventWaitObjectBody
                    );

            if(!b) {
                Status = STATUS_INVALID_HANDLE;
                ObDereferenceObject(RequestReadyEventObjectBody);
                break;
            }

            SystemBasicInfo = SetupStartInfo->SystemBasicInfo;

            //
            // Start Setup going.
            //
            SpStartSetup();

            ObDereferenceObject(RequestReadyEventObjectBody);
            ObDereferenceObject(RequestServicedEventObjectBody);

            Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_SETUP_FMIFS_MESSAGE:

        //
        // Make sure that we were not called by usetup.exe.
        // Make sure we've been passed a suitable input buffer.
        //
        if( (UsetupProcess == PsGetCurrentProcess()) ||
            (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SETUP_FMIFS_MESSAGE)) ) {

            ASSERT( UsetupProcess != PsGetCurrentProcess() );

            Status = STATUS_INVALID_PARAMETER;

        } else {
            PSETUP_FMIFS_MESSAGE    SetupFmifsMessage;
            SetupFmifsMessage = (PSETUP_FMIFS_MESSAGE)Irp->AssociatedIrp.SystemBuffer;

            Status = STATUS_SUCCESS;
            //
            // If there's a callback override specified, use it.
            //
            if(pAutochkCallbackRoutine) {
                Status = pAutochkCallbackRoutine(SetupFmifsMessage);
                break;
            }

            //
            //  If there is a gauge defined, then process the message.
            //  Otherwise, don't bother processing it.
            //
            if( UserModeGauge != NULL ) {
                //
                // Save away relevent fields in the setup information
                // parameters.
                //
                // KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: caller process = %lx \n", PsGetCurrentProcess()));
                // KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: FmIfsPacketType = %d \n", SetupFmifsMessage->FmifsPacketType));
                //
                //  Find out if the FmIfs packet is one of those that we care about
                //
                if( SetupFmifsMessage->FmifsPacketType == FmIfsPercentCompleted ) {
                    ULONG   PercentCompleted;

                    // KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: PercentCompleted = %d \n", ((PFMIFS_PERCENT_COMPLETE_INFORMATION)SetupFmifsMessage->FmifsPacket)->PercentCompleted ));
                    //
                    //  Save the percentage in a local variable, before we attach to
                    //  usetup address space
                    //
                    PercentCompleted = ((PFMIFS_PERCENT_COMPLETE_INFORMATION)SetupFmifsMessage->FmifsPacket)->PercentCompleted;

                    //
                    //  We need to adjust the percentage, depending on the partition
                    //  (System or NT partition) that is currently being accessed.
                    //  We use this because we want to use only one gauge to display
                    //  the progress on both System and NT partitions.
                    //  When autochk is running, 50% of the gauge will be used to
                    //  display the progress on the system partition, and the remaining
                    //  50% will be used for the NT partition.
                    //  Note that when there are two partitions, the range of the
                    //  gauge is initialized as 200. When there is only one partition
                    //  the range is initialized as 100.
                    //  Note also that when autofmt is running, we always set CurrentDiskIndex
                    //  to 0.
                    //
                    ASSERT( CurrentDiskIndex <= 1 );
                    PercentCompleted += 100*CurrentDiskIndex;

                    //
                    //  Attach to usetup.exe address space
                    //
                    KeAttachProcess( (PKPROCESS)UsetupProcess );

                    //
                    //  Call the function that processes FmIfsPackets
                    //
                    // KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Calling ProcessFmIfsPacket \n"));
                    // Status = ProcessFmIfsPacket( SetupFmifsMessage );

                    SpFillGauge( UserModeGauge, PercentCompleted );

                    if (AutochkRunning) {
                        SendSetupProgressEvent(PartitioningEvent, ValidatePartitionEvent, &PercentCompleted);
                    } else if (AutofrmtRunning) {
                        SendSetupProgressEvent(PartitioningEvent, FormatPartitionEvent, &PercentCompleted);
                    }

                    //
                    //  Now that the message was processed, detach from usetup.exe
                    //  address space
                    //
                    KeDetachProcess();
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: FmIfsPacketType = %d \n", SetupFmifsMessage->FmifsPacketType));
                }
            }
        }
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return(Status);
}


VOID
SpSetAutochkCallback(
    IN PAUTOCHK_MSG_PROCESSING_ROUTINE AutochkCallbackRoutine
    )
{
    pAutochkCallbackRoutine = AutochkCallbackRoutine;
}


BOOLEAN
pSpVerifyEventWaitable(
    IN  HANDLE  hEvent,
    OUT PVOID  *EventObjectBody,
    OUT PVOID  *EventWaitObjectBody
    )
{
    POBJECT_HEADER ObjectHeader;
    NTSTATUS Status;

    //
    // Reference the event and verify that it is waitable.
    //
    Status = ObReferenceObjectByHandle(
                hEvent,
                EVENT_ALL_ACCESS,
                NULL,
                KernelMode,
                EventObjectBody,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to reference event object (%lx)\n",Status));
        return(FALSE);
    }

    ObjectHeader = OBJECT_TO_OBJECT_HEADER(*EventObjectBody);
    if(!ObjectHeader->Type->TypeInfo.UseDefaultObject) {

        *EventWaitObjectBody = (PVOID)((PCHAR)(*EventObjectBody) +
                              (ULONG_PTR)ObjectHeader->Type->DefaultObject);

    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: event object not waitable!\n"));
        ObDereferenceObject(*EventObjectBody);
        return(FALSE);
    }

    return(TRUE);
}



NTSTATUS
SpInvokeUserModeService(
    VOID
    )
{
    NTSTATUS Status;

    //
    // Set the event indicating that the communication buffer is
    // ready for the user-mode process. Because this is a synchronization
    // event, it automatically resets after releasing the waiting
    // user-mode thread.  Note that we specify WaitNext to prevent the
    // race condition between setting this synchronization event and
    // waiting on the next one.
    //
    KeSetEvent(RequestReadyEventObjectBody,EVENT_INCREMENT,TRUE);

    //
    // Wait for the user-mode process to indicate that it is done
    // processing the request.  We wait in user mode so that we can be 
    // interrupted if necessary -- say, by an exit APC.
    //
    Status = KeWaitForSingleObject(
                RequestServicedEventWaitObjectBody,
                Executive,
                UserMode,
                FALSE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: KeWaitForSingleObject returns %lx\n",Status));
        return(Status);
    }

    //
    // Return the status returned by the user mode process.
    //
    return(CommunicationParams->u.Status);
}



NTSTATUS
SpExecuteImage(
    IN  PWSTR  ImagePath,
    OUT PULONG ReturnStatus,    OPTIONAL
    IN  ULONG  ArgumentCount,
    ...
    )
{
    va_list arglist;
    ULONG i;
    PSERVICE_EXECUTE RequestBuffer;
    NTSTATUS Status;

    //
    // Locate the request buffer and set up the request number.
    //
    CommunicationParams->u.RequestNumber = SetupServiceExecute;
    RequestBuffer = (PSERVICE_EXECUTE)&CommunicationParams->Buffer;

    //
    // Determine the lcoations of the two strings that get copied
    // into the request buffer for this service.
    //
    RequestBuffer->FullImagePath = RequestBuffer->Buffer;
    RequestBuffer->CommandLine = RequestBuffer->FullImagePath + wcslen(ImagePath) + 1;

    //
    // Copy the image path into the request buffer.
    //
    wcscpy(RequestBuffer->FullImagePath,ImagePath);

    //
    // Move the arguments into the request buffer one by one
    // starting with the image path.
    //
    wcscpy(RequestBuffer->CommandLine,ImagePath);
    va_start(arglist,ArgumentCount);
    for(i=0; i<ArgumentCount; i++) {

        wcscat(RequestBuffer->CommandLine,L" ");
        wcscat(RequestBuffer->CommandLine,va_arg(arglist,PWSTR));
    }
    va_end(arglist);

    //
    // Invoke the service.
    //
    Status = SpInvokeUserModeService();

    //
    // Set process's return status (if required)
    //
    if(NT_SUCCESS(Status) && ReturnStatus) {
        *ReturnStatus = RequestBuffer->ReturnStatus;
    }

    return Status;
}

NTSTATUS
SpLoadUnloadKey(
    IN HANDLE TargetKeyRootDirectory,  OPTIONAL
    IN HANDLE SourceFileRootDirectory, OPTIONAL
    IN PWSTR  TargetKeyName,
    IN PWSTR  SourceFileName           OPTIONAL
    )
{
    //
    // This was once a user-mode service but now the relevent apis
    // are exported from the kernel so don't bother.
    //
    UNICODE_STRING KeyName,FileName;
    OBJECT_ATTRIBUTES ObjaKey,ObjaFile;
    NTSTATUS Status;
    BOOLEAN Loading;
    BOOLEAN bFileExists = FALSE;

    //
    // Loading if we have a source filename, otherwise unloading.
    //
    Loading = (BOOLEAN)(SourceFileName != NULL);

    INIT_OBJA(&ObjaKey,&KeyName,TargetKeyName);
    ObjaKey.RootDirectory = TargetKeyRootDirectory;

    if(Loading) {

        INIT_OBJA(&ObjaFile,&FileName,SourceFileName);
        ObjaFile.RootDirectory = SourceFileRootDirectory;

        //
        // NOTE:ZwLoadKey(...) creates the file if does not exist
        // so we need to check for the existence of the file
        //
        if (SpFileExists(SourceFileName, FALSE))
            Status = ZwLoadKey(&ObjaKey,&ObjaFile);
        else
            Status = STATUS_NO_SUCH_FILE;
    } else {
        Status = ZwUnloadKey(&ObjaKey);
    }

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
            "SETUP: %wskey of %ws failed (%lx)\n",
            Loading ? L"load" : L"unload",
            TargetKeyName,
            Status
            ));
    }

    return(Status);
}

NTSTATUS
SpDeleteKey(
    IN HANDLE  KeyRootDirectory, OPTIONAL
    IN PWSTR   Key
    )
{
    PSERVICE_DELETE_KEY RequestBuffer;

    //
    // Locate the request buffer and set up the request number.
    //
    CommunicationParams->u.RequestNumber = SetupServiceDeleteKey;

    RequestBuffer = (PSERVICE_DELETE_KEY)&CommunicationParams->Buffer;

    //
    // Determine the lcoation of the strings that get copied
    // into the request buffer for this service.
    //
    RequestBuffer->Key = RequestBuffer->Buffer;

    //
    // Copy the string into the request buffer.
    //
    wcscpy(RequestBuffer->Buffer,Key);

    //
    // Initialize the root directory fields.
    //
    RequestBuffer->KeyRootDirectory  = KeyRootDirectory;

    //
    // Invoke the service.
    //
    return(SpInvokeUserModeService());
}

NTSTATUS
SpQueryDirectoryObject(
    IN     HANDLE  DirectoryHandle,
    IN     BOOLEAN RestartScan,
    IN OUT PULONG  Context
    )
{
    PSERVICE_QUERY_DIRECTORY_OBJECT RequestBuffer;
    NTSTATUS Status;

    CommunicationParams->u.RequestNumber = SetupServiceQueryDirectoryObject;

    RequestBuffer = (PSERVICE_QUERY_DIRECTORY_OBJECT)&CommunicationParams->Buffer;

    RequestBuffer->DirectoryHandle = DirectoryHandle;
    RequestBuffer->Context = *Context;
    RequestBuffer->RestartScan = RestartScan;

    Status = SpInvokeUserModeService();

    if(NT_SUCCESS(Status)) {
        *Context = RequestBuffer->Context;
    }

    return(Status);
}


NTSTATUS
SpFlushVirtualMemory(
    IN PVOID BaseAddress,
    IN ULONG RangeLength
    )
{
    PSERVICE_FLUSH_VIRTUAL_MEMORY RequestBuffer;

    CommunicationParams->u.RequestNumber = SetupServiceFlushVirtualMemory;

    RequestBuffer = (PSERVICE_FLUSH_VIRTUAL_MEMORY)&CommunicationParams->Buffer;

    RequestBuffer->BaseAddress = BaseAddress;
    RequestBuffer->RangeLength = RangeLength;

    return(SpInvokeUserModeService());
}

VOID
SpShutdownSystem(
    VOID
    )
{
    SendSetupProgressEvent(SetupCompletedEvent, ShutdownEvent, NULL);

    CommunicationParams->u.RequestNumber = SetupServiceShutdownSystem;

    SpInvokeUserModeService();

    //
    // Shouldn't get here, but just in case...
    //
    HalReturnToFirmware(HalRebootRoutine);

}

NTSTATUS
SpLoadKbdLayoutDll(
    IN  PWSTR  Directory,
    IN  PWSTR  DllName,
    OUT PVOID *TableAddress
    )
{
    PSERVICE_LOAD_KBD_LAYOUT_DLL RequestBuffer;
    NTSTATUS Status;

    CommunicationParams->u.RequestNumber = SetupServiceLoadKbdLayoutDll;

    RequestBuffer = (PSERVICE_LOAD_KBD_LAYOUT_DLL)&CommunicationParams->Buffer;

    wcscpy(RequestBuffer->DllName,Directory);
    SpConcatenatePaths(RequestBuffer->DllName,DllName);

    Status = SpInvokeUserModeService();

    if(NT_SUCCESS(Status)) {
        *TableAddress = RequestBuffer->TableAddress;
    }

    return(Status);
}

NTSTATUS
SpLockUnlockVolume(
    IN HANDLE   Handle,
    IN BOOLEAN  LockVolume
    )
{
    PSERVICE_LOCK_UNLOCK_VOLUME RequestBuffer;

    CommunicationParams->u.RequestNumber = (LockVolume)? SetupServiceLockVolume :
                                                         SetupServiceUnlockVolume;

    RequestBuffer = (PSERVICE_LOCK_UNLOCK_VOLUME)&CommunicationParams->Buffer;

    RequestBuffer->Handle = Handle;

    return(SpInvokeUserModeService());
}

NTSTATUS
SpDismountVolume(
    IN HANDLE   Handle
    )
{
    PSERVICE_DISMOUNT_VOLUME RequestBuffer;

    CommunicationParams->u.RequestNumber = SetupServiceDismountVolume;

    RequestBuffer = (PSERVICE_DISMOUNT_VOLUME)&CommunicationParams->Buffer;

    RequestBuffer->Handle = Handle;

    return(SpInvokeUserModeService());
}


NTSTATUS
SpSetDefaultFileSecurity(
    IN PWSTR FileName
    )
{
    PSERVICE_DEFAULT_FILE_SECURITY RequestBuffer;

    CommunicationParams->u.RequestNumber = SetupServiceSetDefaultFileSecurity;

    RequestBuffer = (PSERVICE_DEFAULT_FILE_SECURITY)&CommunicationParams->Buffer;

    wcscpy( RequestBuffer->FileName, FileName );

    return(SpInvokeUserModeService());
}

NTSTATUS
SpVerifyFileAccess(
    IN  PWSTR       FileName,
    IN  ACCESS_MASK DesiredAccess
    )
{
    PSERVICE_VERIFY_FILE_ACCESS RequestBuffer;

    CommunicationParams->u.RequestNumber = SetupServiceVerifyFileAccess;

    RequestBuffer = (PSERVICE_VERIFY_FILE_ACCESS)&CommunicationParams->Buffer;

    wcscpy( RequestBuffer->FileName, FileName );
    RequestBuffer->DesiredAccess = DesiredAccess;
    return(SpInvokeUserModeService());
}

NTSTATUS
SpCreatePageFile(
    IN PWSTR FileName,
    IN ULONG MinSize,
    IN ULONG MaxSize
    )
{
    PSERVICE_CREATE_PAGEFILE RequestBuffer;

    CommunicationParams->u.RequestNumber = SetupServiceCreatePageFile;

    RequestBuffer = (PSERVICE_CREATE_PAGEFILE)&CommunicationParams->Buffer;

    wcscpy(RequestBuffer->FileName,FileName);
    RequestBuffer->MinSize.HighPart = 0;
    RequestBuffer->MinSize.LowPart = MinSize;
    RequestBuffer->MaxSize.HighPart = 0;
    RequestBuffer->MaxSize.LowPart = MaxSize;

    return(SpInvokeUserModeService());
}

NTSTATUS
SpGetFullPathName(
    IN OUT PWSTR FileName
    )
{
    PSERVICE_GETFULLPATHNAME RequestBuffer;
    NTSTATUS Status;

    CommunicationParams->u.RequestNumber = SetupServiceGetFullPathName;

    RequestBuffer = (PSERVICE_GETFULLPATHNAME)&CommunicationParams->Buffer;

    wcscpy(RequestBuffer->FileName,FileName);

    Status = SpInvokeUserModeService();

    if(NT_SUCCESS(Status)) {
        wcscpy(FileName,RequestBuffer->NameOut);
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spdrpriv.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdrpriv.h

Abstract:
 
    Header file for disaster recovery symbols in text-mode setup.  These
    symbols are not to be referenced by modules other than those in the
    ASR family.

Revision History:
    Initial Code                Michael Peterson (v-michpe)     13.May.1997
    Code cleanup and changes    Guhan Suriyanarayanan (guhans)  21.Aug.1999

--*/
#pragma once
#if defined(ULONG_MAX) && !defined(_INC_LIMITS)
#undef ULONG_MAX
#endif
#include <limits.h>

#ifndef _SPDRPRIV_DEFN_
#define _SPDRPRIV_DEFN_

///////////////////////////////////////////////////////////////////////////////
//                      Data Types                                           //
///////////////////////////////////////////////////////////////////////////////


//
// For the InstallFiles section, we allow the file to end up on 
// one of the following directories.
//
typedef enum _AsrCopyDirEnum {
    _Temp = 0,
    _Tmp,
    _SystemRoot,
    _Default
} AsrCopyDirEnum;


#define ASR_ALWAYS_PROMPT_FOR_MEDIA     0x00000001
#define ASR_PROMPT_USER_ON_MEDIA_ERROR  0x00000002
#define ASR_FILE_IS_REQUIRED            0x00000004

#define ASR_OVERWRITE_ON_COLLISION      0x00000010
#define ASR_PROMPT_USER_ON_COLLISION    0x00000020



typedef struct _SIF_INSTALLFILE_RECORD {
    struct _SIF_INSTALLFILE_RECORD *Next;
    PWSTR SystemKey;
    PWSTR CurrKey;
    PWSTR SourceMediaExternalLabel;
    PWSTR DiskDeviceName;
    PWSTR SourceFilePath;
    PWSTR DestinationFilePath;
    PWSTR VendorString;
    DWORD Flags;
    AsrCopyDirEnum CopyToDirectory;
} SIF_INSTALLFILE_RECORD, *PSIF_INSTALLFILE_RECORD;

typedef struct _SIF_INSTALLFILE_LIST {

    PSIF_INSTALLFILE_RECORD First;
    ULONG                   Count;

} SIF_INSTALLFILE_LIST, *PSIF_INSTALLFILE_LIST;


typedef struct _SIF_PARTITION_RECORD {

    GUID    PartitionTypeGuid;  // GPT only
    GUID    PartitionIdGuid;    // GPT only

    ULONG64 GptAttributes;      // GPT only

    ULONGLONG   StartSector;
    ULONGLONG   SectorCount;

    ULONGLONG SizeMB;           // value is calculated

    struct _SIF_PARTITION_RECORD *Next;
    struct _SIF_PARTITION_RECORD *Prev;

    PWSTR   PartitionName;  // GPT only

    //
    // This member is valid iff this a boot partition record.  Otherwise, this
    // member is NULL
    //
    PWSTR   NtDirectoryName; 

    PWSTR   CurrPartKey;

    PWSTR   DiskKey;

    PWSTR   VolumeGuid;     // May be NULL

    //
    // If this is a descriptor or container record, then this member
    // refers to the logical disk record it contains.  Otherwise, the
    // value of this member is NULL.  Valid only for MBR partitions.
    //
    PWSTR   LogicalDiskKey;

    //
    // If this is a logical disk partition record, then this member
    // refers to its Descriptor or Container partition record.  Otherwise,
    // the value of this member is NULL.  Valid only for MBR partitions.
    //
    PWSTR   DescriptorKey;

    //
    // This is a bit mask. Valid bits are
    //  1: Boot partition   (ASR_PTN_MASK_BOOT)
    //  2: System partition (ASR_PTN_MASK_SYS)
    //  4: DC1--tbd         (ASR_PTN_MASK_DC1)
    //  8: DC2--tbd         (ASR_PTN_MASK_DC1)
    //
    ULONG   PartitionFlag;

    DWORD ClusterSize;

    DWORD   PartitionTableEntryIndex;

    //
    // GPT or MBR
    //
    PARTITION_STYLE PartitionStyle;
    
    //
    // The values of these members are read directly from the asr.sif file
    //
    UCHAR   PartitionType;  // mbr only
    UCHAR   ActiveFlag;     // mbr only

    UCHAR   FileSystemType;

    BOOLEAN IsPrimaryRecord;

    //
    // These can only be true for MBR partitions.  All GPT partitions are 
    // primary partitions.
    //
    BOOLEAN IsContainerRecord;
    BOOLEAN IsDescriptorRecord;
    BOOLEAN IsLogicalDiskRecord;
    BOOLEAN WillBeAutoextended;

    // Used for dynamic disks. 
    BOOLEAN NeedsLdmRetype;

    BOOLEAN IsAligned;

} SIF_PARTITION_RECORD, *PSIF_PARTITION_RECORD;


typedef struct _SIF_PARTITION_RECORD_LIST {

    ULONGLONG DiskSectorCount;
    ULONGLONG LastUsedSector;
    ULONGLONG TotalMbRequired;

    PSIF_PARTITION_RECORD First;
    PSIF_PARTITION_RECORD Last;
    
    ULONG ElementCount;

} SIF_PARTITION_RECORD_LIST, *PSIF_PARTITION_RECORD_LIST;


typedef struct _SIF_DISK_RECORD {

    GUID        SifDiskGptId;     // Valid only for GPT disks

    ULONGLONG   TotalSectors;

    //
    // The values of these members are calculated from the partition records
    // referencing this disk.  If the disk does not contain an extended
    // partition, then the value of the ExtendedPartitionStartSector is
    // ULONG_MAX and the ExtendedPartitionSectorCount is zero (0).
    //
    ULONGLONG   ExtendedPartitionStartSector;
    ULONGLONG   ExtendedPartitionSectorCount;
    ULONGLONG   ExtendedPartitionEndSector;

    ULONGLONG   LastUsedSector;
    ULONGLONG   LastUsedAlignedSector;

    PSIF_PARTITION_RECORD_LIST  PartitionList;
    
    struct _DISK_PARTITION_SET  *pSetRecord;
    
    //
    // The values of these members are read directly from the asr.sif
    // file.
    //
    PWSTR SystemKey;
    PWSTR CurrDiskKey;

    ULONG SifDiskNumber;

    DWORD BytesPerSector;
    DWORD SectorsPerTrack;
    DWORD TracksPerCylinder;

    ULONG BusKey;

    //
    // This is only valid if this is an MBR disk
    //
    ULONG SifDiskMbrSignature;

    ULONG MaxGptPartitionCount;


    STORAGE_BUS_TYPE BusType;
    //
    // Either an MBR or a GPT Disk
    //
    PARTITION_STYLE PartitionStyle;

    //
    // If this record has been assigned to a partition set, this value
    // is TRUE.  Unassigned disk records are FALSE;
    //
    BOOLEAN Assigned;
    BOOLEAN ContainsSystemPartition;
    BOOLEAN ContainsNtPartition;

    BOOLEAN IsCritical;
    
} SIF_DISK_RECORD, *PSIF_DISK_RECORD;


typedef struct _DISK_PARTITION_SET {
    
    ULONGLONG           ActualDiskSizeMB;

    PSIF_DISK_RECORD    pDiskRecord;
    
    PWSTR               NtPartitionKey;

    ULONG               ActualDiskSignature;
    ULONG               Index;
    
    PARTITION_STYLE     PartitionStyle;
    
    BOOLEAN             PartitionsIntact;
    BOOLEAN             IsReplacementDisk;
    BOOLEAN             IsAligned;

} DISK_PARTITION_SET, *PDISK_PARTITION_SET, **DISK_PARTITION_SET_TABLE;


typedef struct _ASR_PHYSICAL_DISK_INFO { 

    ULONGLONG           TrueDiskSize;       // size of partition0
    
    ULONG               BusKey;             // used for grouping
    DWORD               ControllerNumber;

    STORAGE_BUS_TYPE    BusType;            // scsi, ide, 1394, etc
    UCHAR               PortNumber;

} ASR_PHYSICAL_DISK_INFO, *PASR_PHYSICAL_DISK_INFO;

///////////////////////////////////////////////////////////////////////////////
//                      Macro Declaration Section                            //
///////////////////////////////////////////////////////////////////////////////

#define BYTES_PER_SECTOR(d)         (HardDisks[(d)].Geometry.BytesPerSector)

#define SECTORS_PER_TRACK(disk)     (HardDisks[(disk)].Geometry.SectorsPerTrack)
#define DISK_IS_REMOVABLE(d)        (HardDisks[(d)].Characteristics & FILE_REMOVABLE_MEDIA)

#define STRING_TO_LONG(s)           (SpStringToLong((s),NULL,10))
#define COMPARE_KEYS(k1,k2)         (STRING_TO_LONG(k1) == STRING_TO_LONG(k2))

#define STRING_TO_ULONG(str)        (ULONG) SpAsrStringToULong(str, NULL, 10)
#define STRING_TO_ULONGLONG(str)    (ULONGLONG) SpAsrStringToULongLong(str, NULL, 10)
#define STRING_TO_LONGLONG(str)     (LONGLONG) SpAsrStringToLongLong(str, NULL, 10)
#define STRING_TO_HEX(str)          SpStringToLong(str + 2, NULL, 16)

#define IsRecognizedFatPartition(PartitionType) ( \
    (PartitionType == PARTITION_HUGE) \
    )

#define IsRecognizedFat32Partition(PartitionType) ( \
    (PartitionType == PARTITION_FAT32) \
    )

#define IsRecognizedNtfsPartition(PartitionType) ( \
   (PartitionType == PARTITION_IFS) \
    )


#define INTERNAL_ERROR(msg) \
    SpAsrRaiseInternalError(THIS_MODULE,THIS_MODULE_CODE,__LINE__,msg)

#define BYTES_PER_MB 1048576  // 2^20, or 1024*1024

#define ASR_PTN_MASK_BOOT   1
#define ASR_PTN_MASK_SYS    2
#define ASR_PTN_MASK_DC1    4
#define ASR_PTN_MASK_DC2    8


// 
// Debug Trace Messages
//
#define _asrinfo    DPFLTR_SETUP_ID, ((ASRMODE_NORMAL == SpAsrGetAsrMode()) ? DPFLTR_INFO_LEVEL: DPFLTR_ERROR_LEVEL)
#define _asrwarn    DPFLTR_SETUP_ID, ((ASRMODE_NORMAL == SpAsrGetAsrMode()) ? DPFLTR_WARNING_LEVEL: DPFLTR_ERROR_LEVEL)
#define _asrerr     DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL

#define DbgMesg \
    KdPrintEx((_asrinfo, "      ")); \
    KdPrintEx

#define DbgStatusMesg  \
    KdPrintEx((_asrinfo, "ASR [%ws:%4d] (.) ", THIS_MODULE, __LINE__)); \
    KdPrintEx

#define DbgErrorMesg \
    KdPrintEx((_asrwarn, "ASR [%ws:%4d] (!) ", THIS_MODULE, __LINE__)); \
    KdPrintEx

#define DbgFatalMesg \
    KdPrintEx((_asrerr, "ASR [%ws:%4d] (X) ", THIS_MODULE, __LINE__)); \
    KdPrintEx



///////////////////////////////////////////////////////////////////////////////
//                      Global Variable Declarations                         //
///////////////////////////////////////////////////////////////////////////////


//      Defined in spdrpset.c
DISK_PARTITION_SET_TABLE     Gbl_PartitionSetTable1;
DISK_PARTITION_SET_TABLE     Gbl_PartitionSetTable2;

PVOID Gbl_HandleToDrStateFile;

//      Imported from non-Asr modules
extern WCHAR                        TemporaryBuffer[];


//
PWSTR ASR_SIF_SYSTEM_KEY;


///////////////////////////////////////////////////////////////////////////////
//                      Functions Declaration Section                        //
///////////////////////////////////////////////////////////////////////////////

//
//      Exported from spdrsif.c
//

//
// [VERSION] section functions
//
VOID
SpAsrCheckAsrStateFileVersion();

//
// [SYSTEMS] section functions
//
PWSTR   
SpAsrGetNtDirectoryPathBySystemKey(IN PWSTR SystemKey);

BOOLEAN
SpAsrGetAutoExtend(IN PWSTR SystemKey);

//
// [ASRFLAGS] section functions
//
BOOLEAN
SpAsrGetSilentRepartitionFlag(IN PWSTR SystemKey);

//
// [DISKS.MBR] and [DISKS.GPT] sections functions
//
ULONG   
SpAsrGetMbrDiskRecordCount(VOID);

ULONG   
SpAsrGetGptDiskRecordCount(VOID);

ULONG
SpAsrGetDiskRecordCount();

PWSTR   
SpAsrGetDiskKey(
    IN PARTITION_STYLE Style,   // GPT or MBR
    IN ULONG Index
    );

PSIF_DISK_RECORD
SpAsrGetDiskRecord(
    IN PARTITION_STYLE PartitionStyle,
    IN PWSTR DiskKey
    );

PSIF_DISK_RECORD    
SpAsrCopyDiskRecord(IN PSIF_DISK_RECORD pInput);

//
// [PARTITIONS.MBR] and [PARTITIONS.GPT] section functions
//
ULONG   
SpAsrGetMbrPartitionRecordCount(VOID);

ULONG   
SpAsrGetGptPartitionRecordCount(VOID);

PWSTR   
SpAsrGetMbrPartitionKey(IN ULONG Index);

PWSTR   
SpAsrGetGptPartitionKey(IN ULONG Index);

PWSTR
SpAsrGetDiskKeyByMbrPartitionKey(IN PWSTR PartitionKey);

PWSTR
SpAsrGetDiskKeyByGptPartitionKey(IN PWSTR PartitionKey);

ULONGLONG
SpAsrGetSectorCountByMbrDiskKey(IN PWSTR DiskKey);

ULONGLONG
SpAsrGetSectorCountByGptDiskKey(IN PWSTR DiskKey);

PSIF_PARTITION_RECORD
SpAsrGetMbrPartitionRecord(IN PWSTR PartitionKey);

PSIF_PARTITION_RECORD
SpAsrGetGptPartitionRecord(IN PWSTR PartitionKey);

PSIF_PARTITION_RECORD   
SpAsrCopyPartitionRecord(IN PSIF_PARTITION_RECORD pInput);

PSIF_PARTITION_RECORD_LIST 
SpAsrCopyPartitionRecordList(PSIF_PARTITION_RECORD_LIST pSrcList);

VOID
SpAsrInsertPartitionRecord(
    IN PSIF_PARTITION_RECORD_LIST   pList,
    IN PSIF_PARTITION_RECORD        pRec
    );


PSIF_PARTITION_RECORD
SpAsrPopNextPartitionRecord(IN PSIF_PARTITION_RECORD_LIST pList);


// [INSTALLFILES] section functions

PSIF_INSTALLFILE_RECORD
SpAsrRemoveInstallFileRecord(IN SIF_INSTALLFILE_LIST *InstallFileList);

VOID
SpAsrDeleteInstallFileRecord(IN OUT PSIF_INSTALLFILE_RECORD pRec);

PSIF_INSTALLFILE_LIST
SpAsrInit3rdPartyFileList(IN PCWSTR SetupSourceDevicePath);


//
//  Exported from spdrpset.c
//

ULONGLONG
SpAsrGetTrueDiskSectorCount(IN ULONG Disk);

VOID
SpAsrCreatePartitionSets(
    IN PWSTR SetupSourceDevicePath, 
    IN PWSTR DirectoryOnSetupSource
    );

PDISK_REGION
SpAsrDiskPartitionExists(
    IN ULONG Disk,
    IN PSIF_PARTITION_RECORD pRec
    );

VOID SpAsrDbgDumpPartitionSets(VOID);

VOID SpAsrDbgDumpPartitionLists(BYTE DataOption, PWSTR Msg);


//
// Exported from spdrmmgr.c
//
NTSTATUS
SpAsrDeleteMountPoint(IN PWSTR PartitionDevicePath);


NTSTATUS
SpAsrSetVolumeGuid(
    IN PDISK_REGION pRegion,
    IN PWSTR VolumeGuid
    );

WCHAR
SpAsrGetPartitionDriveLetter(IN PDISK_REGION pRegion);

NTSTATUS
SpAsrSetPartitionDriveLetter(
    IN  PDISK_REGION    pRegion,
    IN  WCHAR           DriveLetter);

//
//      Exported from spdrutil.c
//

ULONGLONG
SpAsrConvertSectorsToMB(
    IN  ULONGLONG   SectorCount,
    IN  ULONG   BytesPerSector);


PWSTR
SpAsrGetRegionName(IN PDISK_REGION pRegion);

ULONG
SpAsrGetActualDiskSignature(IN ULONG Disk);


PVOID
SpAsrMemAlloc(
    IN  ULONG   Size,
    IN  BOOLEAN IsErrorFatal);

BOOLEAN
SpAsrIsValidBootDrive(PWSTR NtDir);

BOOLEAN
SpAsrIsBootPartitionRecord(IN ULONG CriticalPartitionFlag);

BOOLEAN
SpAsrIsSystemPartitionRecord(IN ULONG CriticalPartitionFlag);

VOID
SpAsrDeleteStorageVolumes();

VOID
SpAsrRaiseFatalError(
    IN  ULONG   ErrorCode, 
    IN  PWSTR   KdPrintStr);


VOID
SpAsrRaiseFatalErrorWs(
    IN  ULONG   ErrorCode, 
    IN  PWSTR   KdPrintStr,
	IN  PWSTR   MessagStr
    );

VOID
SpAsrRaiseFatalErrorWsWs(
    IN  ULONG   ErrorCode, 
    IN  PWSTR   KdPrintStr,
	IN  PWSTR   MessagStr1,
    IN  PWSTR   MessagStr2
    );

VOID
SpAsrRaiseFatalErrorWsLu(
    IN  ULONG   ErrorCode, 
    IN  PWSTR   KdPrintStr,
	IN  PWSTR   MessagStr,
    IN  ULONG   MessagVal
    );

VOID
SpAsrRaiseFatalErrorLu(
    IN  ULONG   ErrorCode, 
    IN  PWSTR   KdPrintStr,
	IN  ULONG   MessagVal
    );

VOID
SpAsrRaiseFatalErrorLuLu(
    IN  ULONG   ErrorCode, 
    IN  PWSTR   KdPrintStr,
	IN  ULONG   MessagVal1,
    IN  ULONG   MessagVal2
    );


BOOL
SpAsrFileErrorDeleteSkipAbort(
	IN ULONG ErrorCode, 
	IN PWSTR DestinationFile
    );

BOOL
SpAsrFileErrorRetrySkipAbort(
	IN ULONG ErrorCode, 
	IN PWSTR SourceFile,
    IN PWSTR Label,
    IN PWSTR Vendor,
    IN BOOL AllowSkip
    );

VOID
SpAsrRaiseInternalError(
    IN  PWSTR   ModuleName,
    IN  PWSTR   ModuleCode,
    IN  ULONG   LineNumber, 
    IN  PWSTR   KdPrintStr);

ULONGLONG
SpAsrStringToULongLong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    );

LONGLONG
SpAsrStringToLongLong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    );

ULONG
SpAsrStringToULong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    );


VOID
SpAsrGuidFromString(
    IN OUT GUID* Guid,
    IN PWSTR GuidString
    );

BOOLEAN
SpAsrIsZeroGuid(
    IN GUID * Guid
    );

VOID SpAsrDeleteMountedDevicesKey(VOID);

#endif // _SPDRPRIV_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spdrpset.c ===
/*++
Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdrpset.c

Abstract:

    Contains all routines that create and initialize the partition sets.
    
Terminology

Restrictions:

Revision History:
    Initial Code                Michael Peterson (v-michpe)     21.Aug.1998
    Code cleanup and changes    Guhan Suriyanarayanan (guhans)  21.Aug.1999

--*/
#include "spprecmp.h"
#pragma hdrstop

#include "spdrpriv.h"
#include "ntddscsi.h"
//
// Module identification for debug traces
//
#define THIS_MODULE             L"spdrpset.c"
#define THIS_MODULE_CODE        L"P"

extern PVOID   Gbl_SifHandle;
extern const PWSTR SIF_ASR_MBR_DISKS_SECTION;
extern const PWSTR SIF_ASR_GPT_DISKS_SECTION;
extern const PWSTR SIF_ASR_DISKS_SECTION;
extern const PWSTR SIF_ASR_PARTITIONS_SECTION;

//
// Useful macros
//
#define DISK_SIZE_MB(n)         ((ULONGLONG) HardDisks[(n)].DiskSizeMB)

//
// constants
//
#define ASR_FREE_SPACE_FUDGE_FACTOR_BYTES  (16*1024*1024)
#define ASR_LDM_RESERVED_SPACE_BYTES (1024*1024)

//
// Variables global to this module.  
// These are not referenced outside of spdrpset.c.
//
ULONG                       Gbl_PartitionSetCount;
PSIF_DISK_RECORD            *Gbl_SifDiskTable;
BOOLEAN                     Gbl_AutoExtend;


// used to see if a disk can hold the private region at the end,
// and for bus-groupings
PASR_PHYSICAL_DISK_INFO    Gbl_PhysicalDiskInfo;

//
// Forward declarations
//
VOID SpAsrDbgDumpPartitionLists(BYTE DataOption, PWSTR Msg);

BOOLEAN
SpAsrDoesListFitOnDisk(
    IN PSIF_DISK_RECORD pDisk,
    IN ULONG DiskIndex,
    OUT BOOLEAN *IsAligned
    );


//
// Function definitions
//
PSIF_PARTITION_RECORD_LIST
SpAsrGetMbrPartitionListByDiskKey(
    IN PWSTR DiskKey
	)
{
    ULONG   numRecords = 0,
            index      = 0;

    PWSTR   diskKeyFromPartitionRec   = NULL,
            partitionKey              = NULL;

    PSIF_PARTITION_RECORD       pRec  = NULL;
    PSIF_PARTITION_RECORD_LIST  pList = NULL;

    ASSERT(DiskKey);

    numRecords = SpAsrGetMbrPartitionRecordCount();  // won't return if count < 1
    ASSERT(numRecords);

    pList = SpAsrMemAlloc(sizeof(SIF_PARTITION_RECORD_LIST), TRUE);

    for (index = 0; index < numRecords; index++) {

        partitionKey = SpAsrGetMbrPartitionKey(index);
        if (!partitionKey) {
            ASSERT(0 && L"Partition key is NULL!");
            continue;
        }

        diskKeyFromPartitionRec = SpAsrGetDiskKeyByMbrPartitionKey(partitionKey);
        if (!diskKeyFromPartitionRec) {
            ASSERT(0 && L"Disk key is NULL!");
            partitionKey = NULL;
            continue;
        }

        if (COMPARE_KEYS(diskKeyFromPartitionRec, DiskKey)) {
            //
            // This partition is on this disk
            //
            pRec = SpAsrGetMbrPartitionRecord(partitionKey);

            if (!pRec) {
                ASSERT(0 && L"Partition record is NULL!");
                partitionKey = NULL;
                diskKeyFromPartitionRec = NULL;
                continue;
            }

            SpAsrInsertPartitionRecord(pList, pRec);

            if ((pRec->StartSector + pRec->SectorCount) > pList->LastUsedSector) {
                pList->LastUsedSector = pRec->StartSector + pRec->SectorCount;
            }
        }

        partitionKey = NULL;
        diskKeyFromPartitionRec = NULL;
    }

    if (pList->ElementCount == 0) {

        DbgStatusMesg((_asrinfo, "Disk [%ws] appears to have no partitions\n", DiskKey));
        SpMemFree(pList);
        pList = NULL;

    }
    else {
        //
        // Get the sector count of the disk that this list used to be on
        //
        pList->DiskSectorCount = SpAsrGetSectorCountByMbrDiskKey(DiskKey);

    }
    return pList;
}


PSIF_PARTITION_RECORD_LIST
SpAsrGetGptPartitionListByDiskKey(
    IN PWSTR DiskKey
	)
{
    ULONG   numRecords = 0,
            index      = 0;

    PWSTR   diskKeyFromPartitionRec   = NULL,
            partitionKey              = NULL;

    PSIF_PARTITION_RECORD       pRec  = NULL;
    PSIF_PARTITION_RECORD_LIST  pList = NULL;

    ASSERT(DiskKey);

    numRecords = SpAsrGetGptPartitionRecordCount();  // won't return if count < 1
    ASSERT(numRecords);

    pList = SpAsrMemAlloc(sizeof(SIF_PARTITION_RECORD_LIST), TRUE);

    for (index = 0; index < numRecords; index++) {

        partitionKey = SpAsrGetGptPartitionKey(index);
        if (!partitionKey) {
            ASSERT(0 && L"Partition key is NULL!");
            continue;
        }

        diskKeyFromPartitionRec = SpAsrGetDiskKeyByGptPartitionKey(partitionKey);
        if (!diskKeyFromPartitionRec) {
            ASSERT(0 && L"Disk key is NULL!");
            partitionKey = NULL;
            continue;
        }

        if (COMPARE_KEYS(diskKeyFromPartitionRec, DiskKey)) {
            //
            // This partition is on this disk
            //
            pRec = SpAsrGetGptPartitionRecord(partitionKey);

            if (!pRec) {
                ASSERT(0 && L"Partition record is NULL!");
                partitionKey = NULL;
                diskKeyFromPartitionRec = NULL;
                continue;
            }

            SpAsrInsertPartitionRecord(pList, pRec);
            if ((pRec->StartSector + pRec->SectorCount) > pList->LastUsedSector) {
                pList->LastUsedSector = pRec->StartSector + pRec->SectorCount;
            }
        }

        partitionKey = NULL;
        diskKeyFromPartitionRec = NULL;
    }

    if (pList->ElementCount == 0) {

        DbgStatusMesg((_asrinfo, "Disk [%ws] appears to have no partitions\n", DiskKey));
        SpMemFree(pList);
        pList = NULL;

    }
    else {
        //
        // Get the sector count of the disk that this list used to be on
        //
        pList->DiskSectorCount = SpAsrGetSectorCountByGptDiskKey(DiskKey);

    }
    
    return pList;
}


PSIF_PARTITION_RECORD_LIST
SpAsrGetPartitionListByDiskKey(
    IN PARTITION_STYLE PartitionStyle,
    IN PWSTR DiskKey
	)
{

    switch (PartitionStyle) {
    case PARTITION_STYLE_MBR:
        return SpAsrGetMbrPartitionListByDiskKey(DiskKey);
        break;

    case PARTITION_STYLE_GPT:
        return SpAsrGetGptPartitionListByDiskKey(DiskKey);
        break;
    }

    ASSERT(0 && L"Unrecognised partition style");
    return NULL;
}

//
// Sets the extendedstartsector and extendedsectorcount values.  Only
// makes sense in the context of an MBR disk
//
VOID
SpAsrSetContainerBoundaries(IN ULONG Index)
{
    BOOLEAN hasExtendedPartition = FALSE;
    USHORT consistencyCheck = 0;
    PSIF_PARTITION_RECORD pRec = NULL;
    ULONGLONG extSectorCount = 0,
            extStartSector = -1,
            extEndSector = 0;
    
    if (!(Gbl_SifDiskTable[Index]) || 
        (PARTITION_STYLE_MBR != Gbl_SifDiskTable[Index]->PartitionStyle) ||
        !(Gbl_SifDiskTable[Index]->PartitionList)) {
        ASSERT(0 && L"SetContainerBoundaries called with invalid Index");
        return;
    }
    
    Gbl_SifDiskTable[Index]->LastUsedSector = 0;
    pRec = Gbl_SifDiskTable[Index]->PartitionList->First;

    while (pRec) {

        if ((pRec->StartSector + pRec->SectorCount) > Gbl_SifDiskTable[Index]->LastUsedSector) {
            Gbl_SifDiskTable[Index]->LastUsedSector = pRec->StartSector + pRec->SectorCount;
        }

        //
        // Find the lowest-valued start-sector and highest-valued
        // end-sector of all of the extended (0x05 or 0x0f) partitions.
        //
        if (IsContainerPartition(pRec->PartitionType)) {
            hasExtendedPartition = TRUE;

            if (pRec->StartSector < extStartSector) {
                
                extStartSector = pRec->StartSector;

                if ((pRec->StartSector + pRec->SectorCount) > extEndSector) {
                    extEndSector = pRec->StartSector + pRec->SectorCount;
                }
                else {

                    DbgErrorMesg((_asrwarn,
                        "SpAsrSetContainerBoundaries. Extended partition with lowest SS (%ld) does not have highest EndSec (This EndSec: %ld, Max EndSec: %ld)\n",
                        extStartSector, 
                        extStartSector+pRec->SectorCount, 
                        extEndSector
                        ));
                    
                    ASSERT(0 && L"Extended partition with lowest SS does not have highest EndSec");
                }
            }

            if ((pRec->StartSector + pRec->SectorCount) > extEndSector) {
                
                DbgErrorMesg((_asrwarn,
                    "SpAsrSetContainerBoundaries. Extended partition with highest EndSec (%ld) does not have lowest SS (this SS:%ld, MaxEndSec:%ld, LowestSS: %ld)\n",
                    pRec->StartSector + pRec->SectorCount, 
                    pRec->StartSector,
                    extEndSector,
                    extStartSector
                    ));
                
                ASSERT(0 && L"Extended partition with highest EndSec does not have lowest SS");
            }
        }

        pRec = pRec->Next;
    }
    extSectorCount = extEndSector - extStartSector;
    //
    // Update the table for the disk
    //
    if (!hasExtendedPartition) {
        Gbl_SifDiskTable[Index]->ExtendedPartitionStartSector = -1;
        Gbl_SifDiskTable[Index]->ExtendedPartitionSectorCount = 0;
        Gbl_SifDiskTable[Index]->ExtendedPartitionEndSector   = -1;
        return;
    }
    Gbl_SifDiskTable[Index]->ExtendedPartitionStartSector = extStartSector;
    Gbl_SifDiskTable[Index]->ExtendedPartitionSectorCount = extSectorCount;
    Gbl_SifDiskTable[Index]->ExtendedPartitionEndSector   = extEndSector;
    // 
    // Mark the container partition
    //
    pRec = Gbl_SifDiskTable[Index]->PartitionList->First;
    while (pRec) {
        pRec->IsContainerRecord = FALSE;

        if (pRec->StartSector == extStartSector) {
            consistencyCheck++;

            ASSERT((consistencyCheck == 1) && L"Two partitions start at the same sector");

            pRec->IsContainerRecord = TRUE;
            pRec->IsDescriptorRecord = FALSE;
            pRec->IsLogicalDiskRecord = FALSE;
            pRec->IsPrimaryRecord = FALSE;
        }
        pRec = pRec->Next;
    }
}


VOID
SpAsrDetermineMbrPartitionRecordTypes(IN ULONG Index)
{
    
    PSIF_PARTITION_RECORD pRec = NULL,
        pLogical = NULL,
        pDescr = NULL;

    ULONGLONG extStartSector = 0, 
        extEndSector = 0;

    if (!(Gbl_SifDiskTable[Index]) || 
        (PARTITION_STYLE_MBR != Gbl_SifDiskTable[Index]->PartitionStyle) ||
        !(Gbl_SifDiskTable[Index]->PartitionList)) {

        ASSERT(0 && L"DetermineMbrPartitionRecordTypes called with invalid Index");
        return;
    }

    extStartSector = Gbl_SifDiskTable[Index]->ExtendedPartitionStartSector;
    extEndSector  = Gbl_SifDiskTable[Index]->ExtendedPartitionEndSector;

    //
    // Check for descriptor, logical or primary
    //
    pRec = Gbl_SifDiskTable[Index]->PartitionList->First;

    while (pRec) {

        //
        // To start off, assume it's none of the recognised types
        //
        pRec->IsDescriptorRecord = FALSE;
        pRec->IsLogicalDiskRecord = FALSE;
        pRec->IsPrimaryRecord = FALSE;

        if (IsContainerPartition(pRec->PartitionType)) {
            //
            // Extended partition: this is either the container 
            // or a descriptor partition record.
            //
            if (pRec->StartSector != extStartSector) {

                ASSERT(pRec->StartSector > extStartSector);
                ASSERT(FALSE == pRec->IsContainerRecord); // should've been marked above

                pRec->IsContainerRecord = FALSE; // just in case
                //
                // Not the container, so it must be a descriptor partition record.
                //
                pRec->IsDescriptorRecord = TRUE;
            }  
        }
        else {  

            ASSERT(FALSE == pRec->IsContainerRecord); // should've been marked above
            pRec->IsContainerRecord = FALSE; // just in case

            //
            // Not an extended partition. It's a primary record if its 
            // StartSector lies outside of the container partition's 
            // boundaries. Otherwise, it's a logical disk partition record.
            //
            if (pRec->StartSector < extStartSector ||
                pRec->StartSector >= extEndSector) {
                pRec->IsPrimaryRecord = TRUE;
            }
            else {
                pRec->IsLogicalDiskRecord = TRUE;
            }
        }
        pRec = pRec->Next;
    }

    //
    // -guhans! this is O(n-squared)
    // Next, loop through the list once more and, for each logical disk 
    // record, find its descriptor partition.  For each descriptor partition
    // find its logical disk.  NB: All logical disk records will have a
    // descriptor record.  All descriptor records will have a logical disk
    // record.
    //
    // To determine this we make use of the observation that a logical disk
    // record's start sector and sector count have the following relationship
    // to its descriptor partition:
    //
    // Logical Disk Record          Descriptor Record
    //
    //  Start Sector        >=       Start Sector
    //  Sector Count        <=       Sector Count
    //
    // NB: In most cases, the container partition record also acts as a 
    // descriptor partition record for the first logical disk in the extended 
    // partition.
    //
    pLogical = Gbl_SifDiskTable[Index]->PartitionList->First;
    while (pLogical) {
        //
        // we're only interested in logical disks.
        //
        if (pLogical->IsLogicalDiskRecord) {
            //
            // Determine the descriptor record describing pLogical and vice versa.
            //
            pDescr = Gbl_SifDiskTable[Index]->PartitionList->First;
            while (pDescr) {
                //
                // skip this record itself.
                //
                if (pLogical == pDescr) {
                    pDescr = pDescr->Next;
                    continue;
                }
                //
                // skip primary or logical disk records.
                //
                if (pDescr->IsPrimaryRecord || pDescr->IsLogicalDiskRecord) {
                    pDescr = pDescr->Next;
                    continue;
                }
                //
                // At this point, the record describes a container or a descriptor
                // partition.  If the end sectors match, we this is the descriptor
                // record for our logical rec.
                //
                if ((pLogical->StartSector + pLogical->SectorCount) == 
                    (pDescr->StartSector   + pDescr->SectorCount)) {

                    pLogical->DescriptorKey = pDescr->CurrPartKey;
                    pDescr->LogicalDiskKey = pLogical->CurrPartKey;
            
                    break;
                }

                pDescr = pDescr->Next;
            }

        }
        pLogical = pLogical->Next;
    }
}


VOID
SpAsrDetermineGptPartitionRecordTypes(IN ULONG Index)
{

    PSIF_PARTITION_RECORD pRec = NULL;

    if (!(Gbl_SifDiskTable[Index]) || 
        (PARTITION_STYLE_GPT != Gbl_SifDiskTable[Index]->PartitionStyle) ||
        !(Gbl_SifDiskTable[Index]->PartitionList)) {

        ASSERT(0 && L"DetermineGptPartitionRecordTypes called with invalid Index");
        return;
    }

    //
    // Check for descriptor, logical or primary
    //
    pRec = Gbl_SifDiskTable[Index]->PartitionList->First;

    while (pRec) {
        //
        // All GPT partitions are "primary"
        //
        pRec->IsContainerRecord = FALSE; 
        pRec->IsDescriptorRecord = FALSE;
        pRec->IsLogicalDiskRecord = FALSE;

        pRec->IsPrimaryRecord = TRUE;

        pRec = pRec->Next;
    }
}

VOID
SpAsrDeterminePartitionRecordTypes(IN ULONG Index)
{
    switch (Gbl_SifDiskTable[Index]->PartitionStyle) {
    case PARTITION_STYLE_MBR:
        SpAsrDetermineMbrPartitionRecordTypes(Index);
        break;

    case PARTITION_STYLE_GPT:
        SpAsrDetermineGptPartitionRecordTypes(Index);
        break;

    default:
        ASSERT(0 && L"Unrecognised partition style");
        break;
    }
}


VOID
SpAsrSetDiskSizeRequirement(IN ULONG Index)
{
    PSIF_PARTITION_RECORD_LIST pList = NULL;
    PSIF_PARTITION_RECORD pRec = NULL;

    ASSERT(Gbl_SifDiskTable[Index]);
    
    pList = Gbl_SifDiskTable[Index]->PartitionList;
    if (!pList) {
        return;
    }

    pRec = pList->First;
    pList->TotalMbRequired = 0;
    
    while (pRec) {
        //
        // No need to sum the disk requirements of the descriptor and
        // logical disk partition records.
        //
        // In a GPT disk, all partitions are primary.
        //
        if (pRec->IsContainerRecord || pRec->IsPrimaryRecord) {
            pList->TotalMbRequired += pRec->SizeMB;
        }

        pRec = pRec->Next;
    }
}


VOID
SpAsrInitSifDiskTable(VOID)
{
    LONG count = 0,
        index = 0,
        mbrDiskRecordCount = 0,
        gptDiskRecordCount = 0;
    
    PWSTR diskKey = NULL,
        systemKey = ASR_SIF_SYSTEM_KEY;

    PSIF_DISK_RECORD pCurrent = NULL;

    BOOLEAN done = FALSE;

    Gbl_AutoExtend = SpAsrGetAutoExtend(systemKey);

    //
    // Allocate the array for the disk records.
    //
    mbrDiskRecordCount  = (LONG) SpAsrGetMbrDiskRecordCount();
    gptDiskRecordCount  = (LONG) SpAsrGetGptDiskRecordCount();
    if ((mbrDiskRecordCount + gptDiskRecordCount) <= 0) {
        //
        // We need at least one disk in asr.sif
        //
		SpAsrRaiseFatalErrorWs(
            SP_SCRN_DR_SIF_BAD_RECORD,
			L"No records in the disks sections",
			SIF_ASR_DISKS_SECTION
            );
    }

    Gbl_SifDiskTable = SpAsrMemAlloc(sizeof(PSIF_DISK_RECORD) * (mbrDiskRecordCount + gptDiskRecordCount), TRUE);

    //
    // Get each MBR disk's partition list from the sif.
    //
    for (count = 0; count < mbrDiskRecordCount; count++) {
        
        diskKey = SpAsrGetDiskKey(PARTITION_STYLE_MBR, count);
        if (!diskKey) {
            ASSERT(0 && L"Disk key is NULL!");
            continue;
        }

        pCurrent = SpAsrGetDiskRecord(PARTITION_STYLE_MBR, diskKey);
        if (!pCurrent) {
            ASSERT(0 && L"Disk Record is NULL!");
            continue;
        }

        //
        // Determine the index where this record is to be added.
        //
        index = count - 1;  // last entry added so far
        done = FALSE;
        while ((index >= 0) && (!done)) {
            if (Gbl_SifDiskTable[index]->TotalSectors > pCurrent->TotalSectors) {
                Gbl_SifDiskTable[index+1] = Gbl_SifDiskTable[index];
                --index;
            }
            else {
                done = TRUE;
            }
        }
        ++index;

        Gbl_SifDiskTable[index] = pCurrent;

        Gbl_SifDiskTable[index]->Assigned = FALSE;
        Gbl_SifDiskTable[index]->ContainsNtPartition = FALSE;
        Gbl_SifDiskTable[index]->ContainsSystemPartition = FALSE;
        //
        // Get the partitions on this disk.
        //
        Gbl_SifDiskTable[index]->PartitionList = SpAsrGetPartitionListByDiskKey(PARTITION_STYLE_MBR, diskKey);

        if (Gbl_SifDiskTable[index]->PartitionList) {
            //
            // Set the extended partition record boundaries, if any.
            //
            SpAsrSetContainerBoundaries(index);
            //
            // Walk the partition list and determine the type of each
            // partition record (i.e., IsDescriptorRecord, IsPrimaryRecord, 
            // IsLogicalDiskRecord).
            //
            SpAsrDeterminePartitionRecordTypes(index);
            //
            // Set the SizeMB member
            //
            SpAsrSetDiskSizeRequirement(index);
        }
    }

    //
    // Repeat for GPT disks.
    //
    for (count = 0; count < gptDiskRecordCount; count++) {
        
        diskKey = SpAsrGetDiskKey(PARTITION_STYLE_GPT, count);
        if (!diskKey) {
            ASSERT(0 && L"Disk key is NULL!");
            continue;
        }

        pCurrent = SpAsrGetDiskRecord(PARTITION_STYLE_GPT, diskKey);
        if (!pCurrent) {
            ASSERT(0 && L"Disk Record is NULL!");
            continue;
        }

        //
        // Determine the index where this record is to be added.
        //
        index = mbrDiskRecordCount + count - 1;  // last entry added so far
        done = FALSE;
        while ((index >= 0) && (!done)) {
            if (Gbl_SifDiskTable[index]->TotalSectors > pCurrent->TotalSectors) {
                Gbl_SifDiskTable[index+1] = Gbl_SifDiskTable[index];
                --index;
            }
            else {
                done = TRUE;
            }
        }
        ++index;

        Gbl_SifDiskTable[index] = pCurrent;

        Gbl_SifDiskTable[index]->Assigned = FALSE;
        Gbl_SifDiskTable[index]->ContainsNtPartition = FALSE;
        Gbl_SifDiskTable[index]->ContainsSystemPartition = FALSE;
        //
        // Get the partitions on this disk.
        //
        Gbl_SifDiskTable[index]->PartitionList = SpAsrGetPartitionListByDiskKey(PARTITION_STYLE_GPT, diskKey);

        if (Gbl_SifDiskTable[index]->PartitionList) {

            //
            // Mark all partitions as primary
            //
            SpAsrDeterminePartitionRecordTypes(index);
            //
            // Set the SizeMB member
            //
            SpAsrSetDiskSizeRequirement(index);
        }
    }
}


NTSTATUS
SpAsrGetPartitionInfo(
    IN  PWSTR                   PartitionPath,
    OUT PARTITION_INFORMATION  *PartitionInfo
    )
{
    NTSTATUS         status          = STATUS_SUCCESS;
    HANDLE           partitionHandle = NULL;
    IO_STATUS_BLOCK  ioStatusBlock;

    //
    // Open partition0 of the disk. This should always succeed.
    // Partition 0 is an alias for the entire disk.
    //
    status = SpOpenPartition0(
        PartitionPath,
        &partitionHandle,
        FALSE
        );

    if (!NT_SUCCESS(status)) {

        DbgErrorMesg((_asrerr,
            "SpAsrGetPartitionInfo. SpOpenPartition0 failed for [%ws]. (0x%lx)\n" ,
            PartitionPath,
            status));

        ASSERT(0 && L"SpOpenPartition0 failed");
        return status;
    }

    //
    // Use the Partition0 handle to get a PARTITION_INFORMATION structure.
    //
    status = ZwDeviceIoControlFile(
        partitionHandle,
        NULL,
        NULL,
        NULL,
        &ioStatusBlock,
        IOCTL_DISK_GET_PARTITION_INFO,
        NULL,
        0,
        PartitionInfo,
        sizeof(PARTITION_INFORMATION)
        );
    ZwClose(partitionHandle);

    if(!NT_SUCCESS(status)) {
        
        DbgErrorMesg((_asrerr,
            "IOCTL_DISK_GET_PARTITION_INFO failed for [%ws]. (0x%lx)\n", 
            PartitionPath, 
            status
            ));
        
//        ASSERT(0 && L"IOCTL_DISK_GET_PARTITION_INFO failed");
    }

    return status;
}


ULONGLONG
SpAsrGetTrueDiskSectorCount(IN ULONG Disk)
/*++

  Description:
    Gets the sector count of this disk by using the PARTITION_INFORMATION structure
    obtained by using the disk's device name in the IOCTL_GET_PARTITION_INFO ioct.

  Arguments:
    Disk    The physical number of the disk whose sectors are to be obtained.

  Returns:
        The total number of sectors on this disk.
--*/
{
    NTSTATUS status     = STATUS_SUCCESS;
    PWSTR devicePath    = NULL;
    ULONGLONG sectorCount = 0;
    PARTITION_INFORMATION partitionInfo;

    swprintf(TemporaryBuffer, L"\\Device\\Harddisk%u", Disk);
    devicePath = SpDupStringW(TemporaryBuffer);

    status = SpAsrGetPartitionInfo(devicePath, &partitionInfo);

    if (!NT_SUCCESS(status)) {

        DbgFatalMesg((_asrerr, 
            "Could not get true disk size (0x%x). devicePath [%ws], Disk %lu\n", 
            status, devicePath, Disk));

        swprintf(TemporaryBuffer, L"Failed to get partition info for %ws", devicePath);
        sectorCount = 0;
    }

    else {
        sectorCount = (ULONGLONG) (partitionInfo.PartitionLength.QuadPart / BYTES_PER_SECTOR(Disk));
    }
    
    SpMemFree(devicePath);
    return sectorCount;
}


VOID
DetermineBuses() 
{

    HANDLE handle = NULL;
    PWSTR devicePath = NULL;
    ULONG physicalIndex = 0;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status = STATUS_SUCCESS;
    STORAGE_PROPERTY_QUERY propertyQuery;
    STORAGE_DEVICE_DESCRIPTOR deviceDesc;
    DISK_CONTROLLER_NUMBER ControllerInfo;
    SCSI_ADDRESS scsiAddress;
    BOOLEAN newBus, done;
    DWORD targetController;
    ULONG targetBusKey;
    UCHAR targetPort;

    //
    // 
    //
    for (physicalIndex = 0; physicalIndex < HardDiskCount; physicalIndex++) {

        Gbl_PhysicalDiskInfo[physicalIndex].ControllerNumber = (DWORD) (-1);
        Gbl_PhysicalDiskInfo[physicalIndex].PortNumber = (UCHAR) (-1);
        Gbl_PhysicalDiskInfo[physicalIndex].BusKey = 0;
        Gbl_PhysicalDiskInfo[physicalIndex].BusType = BusTypeUnknown;
        //
        // Get a handle to the disk by opening partition 0 
        //
        swprintf(TemporaryBuffer, L"\\Device\\Harddisk%u", physicalIndex);
        devicePath = SpDupStringW(TemporaryBuffer);

        status = SpOpenPartition0(devicePath, &handle, FALSE);

        if (!NT_SUCCESS(status)) {

            DbgErrorMesg((_asrwarn,
                "DetermineBuses: SpOpenPartition0 failed for [%ws]. (0x%lx) Assumed to be unknown bus.\n" ,
                devicePath, status));

            ASSERT(0 && L"SpOpenPartition0 failed, assuming unknown bus");
            continue;
        }

        //
        // We have a handle to the disk now.  Get the controller number.
        //
        status = ZwDeviceIoControlFile(
            handle,
            NULL,
            NULL,
            NULL,
            &ioStatusBlock,
            IOCTL_DISK_CONTROLLER_NUMBER,
            NULL,
            0,
            &ControllerInfo,
            sizeof(DISK_CONTROLLER_NUMBER)
            );

        if (!NT_SUCCESS(status)) {

            DbgErrorMesg((_asrwarn,
                "DetermineBuses: Couldn't get controller number for [%ws]. (0x%lx)\n" ,
                devicePath,
                status
                ));

        }
        else {
            Gbl_PhysicalDiskInfo[physicalIndex].ControllerNumber = ControllerInfo.ControllerNumber;
        }

        //
        // Figure out the bus that this disk is on. 
        //
        propertyQuery.QueryType     = PropertyStandardQuery;
        propertyQuery.PropertyId    = StorageDeviceProperty;

        status = ZwDeviceIoControlFile(
            handle,
            NULL,
            NULL,
            NULL,
            &ioStatusBlock,
            IOCTL_STORAGE_QUERY_PROPERTY,
            &propertyQuery,
            sizeof(STORAGE_PROPERTY_QUERY),
            &deviceDesc,
            sizeof(STORAGE_DEVICE_DESCRIPTOR)
            );
        if (NT_SUCCESS(status)) {
            Gbl_PhysicalDiskInfo[physicalIndex].BusType = deviceDesc.BusType;
        }
        else {
           DbgErrorMesg((_asrwarn,
                "DetermineBuses: Couldn't get bus type for [%ws]. (0x%lx)\n" ,
                devicePath,
                status
                ));
        }

        //
        // Try to get the scsi address.  This will fail for non-SCSI/IDE disks.
        //
        status = ZwDeviceIoControlFile(
            handle,
            NULL,
            NULL,
            NULL,
            &ioStatusBlock,
            IOCTL_SCSI_GET_ADDRESS,
            NULL,
            0,
            &scsiAddress,
            sizeof(SCSI_ADDRESS)
            );
        if (NT_SUCCESS(status)) {
            Gbl_PhysicalDiskInfo[physicalIndex].PortNumber = scsiAddress.PortNumber;
        }

        SpMemFree(devicePath);
        ZwClose(handle);
    }


    //
    // Now we have the controller number and scsi port info for each of the disks
    // Group the disks based on this.
    //
    targetBusKey = 0;
    newBus = TRUE; done = FALSE;
    while (!done) {

        newBus = TRUE;
        
        for (physicalIndex = 0; physicalIndex < HardDiskCount; physicalIndex++) {

            if (newBus) {
                if (!(Gbl_PhysicalDiskInfo[physicalIndex].BusKey)) {
                    //
                    // This disk doesn't have a bus key yet.
                    //
                    newBus = FALSE;
                    ++targetBusKey; // we found a new bus

                    targetController = Gbl_PhysicalDiskInfo[physicalIndex].ControllerNumber;
                    targetPort = Gbl_PhysicalDiskInfo[physicalIndex].PortNumber;
                    Gbl_PhysicalDiskInfo[physicalIndex].BusKey = targetBusKey;
                }

            }
            else {
                if ((Gbl_PhysicalDiskInfo[physicalIndex].ControllerNumber == targetController) &&
                    (Gbl_PhysicalDiskInfo[physicalIndex].PortNumber == targetPort)) {
                    Gbl_PhysicalDiskInfo[physicalIndex].BusKey = targetBusKey;
               }
            }
        }

        if (newBus) {
            //
            // We went through the entire table without finding even a single disk
            // with BusKey = 0, ie, we've assigned BusKeys to all of them.
            //
            done = TRUE;
        }
    }
}


//
// Sets the disk sizes by getting info about partition 0
//
VOID
SpAsrInitPhysicalDiskInfo() 
{
    ULONG index = 0;
    IO_STATUS_BLOCK IoStatusBlock;
    DISK_CONTROLLER_NUMBER ControllerInfo;
    ULONGLONG TrueSectorCount = 0;


    Gbl_PhysicalDiskInfo = SpAsrMemAlloc((sizeof(ASR_PHYSICAL_DISK_INFO) * HardDiskCount), TRUE);

    DbgStatusMesg((_asrinfo, "Setting true disk sizes:\n"));

    for (index = 0; index < HardDiskCount; index++) {


        TrueSectorCount = SpAsrGetTrueDiskSectorCount(index);
        if (0 == TrueSectorCount) {
            Gbl_PhysicalDiskInfo[index].TrueDiskSize = HardDisks[index].DiskSizeSectors;
        }
        else {
            Gbl_PhysicalDiskInfo[index].TrueDiskSize = TrueSectorCount;
        }
    
        DbgStatusMesg((_asrinfo,
            "Disk %lu: %I64u sectors\n", 
            index, 
            Gbl_PhysicalDiskInfo[index].TrueDiskSize
            ));


    }

    //
    // Now determine the bus-topology of the disks.  This will be used later when
    // we're trying to find a match for the sif-disks.
    //
    DetermineBuses();

} // SpAsrInitPhysicalDiskInfo


VOID
SpAsrAllocateGblPartitionSetTable(VOID)
{
    ULONG size;

    //
    // Allocate memory for the partition set table.  One entry
    // for each physical disk attached to the system, including
    // removable disks (e.g., Jaz).  NB: HardDiskCount does not
    // include CDROMs.
    //
    size = sizeof(PDISK_PARTITION_SET) * HardDiskCount;
    Gbl_PartitionSetTable1 = SpAsrMemAlloc(size, TRUE);
}


VOID
SpAsrFreePartitionRecord(IN PSIF_PARTITION_RECORD pRec)
{
    if (pRec) {

        if (pRec->NtDirectoryName) {
            SpMemFree(pRec->NtDirectoryName);
        }

        SpMemFree(pRec);
    }
}


VOID
SpAsrFreePartitionList(IN PSIF_PARTITION_RECORD_LIST pList)
{
    PSIF_PARTITION_RECORD pRec;

    if (!pList) {
        return;
    }

    while (pRec = SpAsrPopNextPartitionRecord(pList)) {
        SpAsrFreePartitionRecord(pRec);
    }
    
    SpMemFree(pList);
}


VOID
SpAsrFreePartitionDisk(IN PSIF_DISK_RECORD pDisk)
{
    if (!pDisk) {
        return;
    }

    if (pDisk->PartitionList) {
        SpAsrFreePartitionList(pDisk->PartitionList);
    }

    SpMemFree(pDisk);
}


VOID
SpAsrFreePartitionSet(IN PDISK_PARTITION_SET pSet)
{
    if (!pSet) {
        return;
    }
    
    if (pSet->pDiskRecord) {
    
        if (pSet->pDiskRecord->PartitionList) {
            SpAsrFreePartitionList(pSet->pDiskRecord->PartitionList);
        }

        SpMemFree(pSet->pDiskRecord);
        pSet->pDiskRecord = NULL;

    }

    SpMemFree(pSet);
    pSet = NULL;
}



VOID
SpAsrFreePartitionSetTable(IN DISK_PARTITION_SET_TABLE Table)
{
    ULONG index;
    
    if (!Table) {
        return;
    }

    for (index = 0; index < HardDiskCount; index++) {            
        if (Table[index]) {
            SpAsrFreePartitionSet(Table[index]);
        }
    }

    SpMemFree(Table);
    Table = NULL;
}


PDISK_PARTITION_SET
SpAsrCopyPartitionSet(IN PDISK_PARTITION_SET pSetOriginal)
{
    PDISK_PARTITION_SET pSetNew;

    if (!pSetOriginal) {
        return NULL;
    }

    pSetNew = SpAsrMemAlloc(sizeof(DISK_PARTITION_SET), TRUE);
    pSetNew->ActualDiskSignature = pSetOriginal->ActualDiskSignature;
    pSetNew->PartitionsIntact = pSetOriginal->PartitionsIntact;
    pSetNew->IsReplacementDisk = pSetOriginal->IsReplacementDisk;
    pSetNew->NtPartitionKey = pSetOriginal->NtPartitionKey;

    if (pSetOriginal->pDiskRecord == NULL) {
        pSetNew->pDiskRecord = NULL;
    }
    else {
        pSetNew->pDiskRecord = SpAsrCopyDiskRecord(pSetOriginal->pDiskRecord);
        pSetNew->pDiskRecord->pSetRecord = pSetNew;
    }

    return pSetNew;
}


DISK_PARTITION_SET_TABLE
SpAsrCopyPartitionSetTable(IN DISK_PARTITION_SET_TABLE SrcTable)
{
    ULONG index = 0;
    DISK_PARTITION_SET_TABLE destTable = NULL;
    PSIF_PARTITION_RECORD_LIST pList = NULL;

    if (!SrcTable) {
        ASSERT(0 && L"SpAsrCopyPartitionSetTable: Copy failed, source partition table is NULL.");
        return NULL;
    }
        
    destTable = SpAsrMemAlloc(sizeof(PDISK_PARTITION_SET) * HardDiskCount, TRUE);

    for (index = 0; index < HardDiskCount; index++) {

        if (SrcTable[index]) {
            destTable[index] = SpAsrCopyPartitionSet(SrcTable[index]);
        }
        else {
            destTable[index] = NULL;
        }
    }
    
    return destTable;
}  // SpAsrCopyPartitionSetTable


BOOLEAN
PickABootPartition(
    IN OUT PSIF_PARTITION_RECORD    pCurrent,
    IN OUT PSIF_PARTITION_RECORD    pNew
    )
{

    ASSERT(pCurrent && pNew);
    
    // 
    // They must both be marked boot or sys.
    //
    ASSERT(SpAsrIsBootPartitionRecord(pCurrent->PartitionFlag)
            && SpAsrIsBootPartitionRecord(pNew->PartitionFlag));


    //
    // If this is a mirrored partition, then the volume guids must
    // be the same.  And they should be on different spindles.  But
    // in the interests of being nice to the user, we don't enforce this
    // here, we just ASSERT.
    //
    // We pick one of the two partitions marked as boot, based on:
    // 1.  If one of the partitions is marked active and the other isn't,
    // we use the active partition.
    // 2.  If they are of different sizes, we pick the smaller partition
    // since we don't want to mirror a partition to a smaller one.
    // 3.  Just pick the first one.
    //
    ASSERT(wcscmp(pCurrent->VolumeGuid, pNew->VolumeGuid) == 0);
    ASSERT(wcscmp(pCurrent->DiskKey, pNew->DiskKey) != 0);

    //
    // 1. Check active flags
    //
    if ((pCurrent->ActiveFlag) && (!pNew->ActiveFlag)) {
        //
        // pCurrent is marked active and pNew isn't
        //
        pNew->PartitionFlag -= ASR_PTN_MASK_BOOT;
        return FALSE;
    }

    if ((!pCurrent->ActiveFlag) && (pNew->ActiveFlag)) {
        //
        // pNew is marked active and pCurrent isn't
        //
        pCurrent->PartitionFlag -= ASR_PTN_MASK_BOOT;
        return TRUE;    // new boot ptn rec
    }

    //
    // 2. Check sizes
    //
    if (pCurrent->SizeMB != pNew->SizeMB) {
        if (pCurrent->SizeMB > pNew->SizeMB) {
            //
            // pNew is smaller, so that becomes the new boot ptn
            //
            pCurrent->PartitionFlag -= ASR_PTN_MASK_BOOT;
            return TRUE;
        } 
        else {
            //
            // pCurrent is smaller, so that is the boot ptn
            //
            pNew->PartitionFlag -= ASR_PTN_MASK_BOOT;
            return FALSE;
        }
    }

    //
    // 3. Just pick the first (pCurrent)
    //
    pNew->PartitionFlag -= ASR_PTN_MASK_BOOT;
    return FALSE;
}


BOOLEAN
PickASystemPartition(
    IN PSIF_PARTITION_RECORD    FirstPartition,
    IN PSIF_DISK_RECORD         FirstDisk,
    IN PSIF_PARTITION_RECORD    SecondPartition,
    IN PSIF_DISK_RECORD         SecondDisk,
    IN CONST DWORD              CurrentSystemDiskNumber,
    IN CONST BOOL               BootSameAsSystem
    )
{

    PHARD_DISK CurrentSystemDisk = NULL;
    BOOLEAN IsAligned = TRUE;

    if (CurrentSystemDiskNumber != (DWORD)(-1)) {
        CurrentSystemDisk = &HardDisks[CurrentSystemDiskNumber];
    }

    ASSERT(FirstPartition && SecondPartition);
    ASSERT(FirstDisk && SecondDisk);
    
    // 
    // They must both be marked system
    //
    ASSERT(SpAsrIsSystemPartitionRecord(FirstPartition->PartitionFlag)
            && SpAsrIsSystemPartitionRecord(SecondPartition->PartitionFlag));

    //
    // If this is a mirrored partition, then the volume guids must
    // be the same.  And they should be on different spindles.  But
    // in the interests of being nice to the user, we don't enforce this
    // here, we just ASSERT.
    //
    ASSERT(wcscmp(FirstPartition->VolumeGuid, SecondPartition->VolumeGuid) == 0);
    ASSERT(wcscmp(FirstPartition->DiskKey, SecondPartition->DiskKey) != 0);

    // 
    // If the partitioning style of either disk is different from the 
    // current system disk (very unlikely) then we should pick the other
    //
    if ((CurrentSystemDisk) && 
        ((PARTITION_STYLE)CurrentSystemDisk->DriveLayout.PartitionStyle != SecondDisk->PartitionStyle)
        ) {
        SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;
        if (BootSameAsSystem) {
            SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
        }

        return FALSE;
    }

    if ((CurrentSystemDisk) &&
        (PARTITION_STYLE)CurrentSystemDisk->DriveLayout.PartitionStyle != FirstDisk->PartitionStyle) {
        FirstPartition->PartitionFlag -= ASR_PTN_MASK_SYS;
        
        if (BootSameAsSystem) {
            FirstPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
        }

        return TRUE;
    }

    //
    // All three have the same partitioning style.  Check signatures/GUID.
    //
    if (PARTITION_STYLE_MBR == FirstDisk->PartitionStyle) {

        if ((CurrentSystemDisk) && 
           (CurrentSystemDisk->DriveLayout.Mbr.Signature == FirstDisk->SifDiskMbrSignature)) {
            SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

            if (BootSameAsSystem) {
                SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }
            
            return FALSE;
        }

        if ((CurrentSystemDisk) &&
            (CurrentSystemDisk->DriveLayout.Mbr.Signature == SecondDisk->SifDiskMbrSignature)) {
            FirstPartition->PartitionFlag -= ASR_PTN_MASK_SYS;
            
            if (BootSameAsSystem) {
                FirstPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }

            return TRUE;
        }
    }
    else if (PARTITION_STYLE_GPT == FirstDisk->PartitionStyle) {

        if ((CurrentSystemDisk) && 
            !RtlCompareMemory(
                &(CurrentSystemDisk->DriveLayout.Gpt.DiskId),
                &(FirstDisk->SifDiskGptId), 
                sizeof(GUID)
            )) {

            SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

            if (BootSameAsSystem) {
                SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }

            return FALSE;
        }
        
        if (!RtlCompareMemory(
            &(CurrentSystemDisk->DriveLayout.Gpt.DiskId), 
            &(SecondDisk->SifDiskGptId), 
            sizeof(GUID)
            )) {

            FirstPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

            if (BootSameAsSystem) {
                FirstPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }

            return TRUE;
        }

    }
    else {
        ASSERT(0 && L"Unrecognised partition style found");

        SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

        if (BootSameAsSystem) {
            SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
        }

        return FALSE;
    }

    //
    // The signatures didn't match.  Now try to see which might be a better fit
    //    
        

    //
    // Else, look for the better fit of the two disks.
    // 
    if ((!SpAsrDoesListFitOnDisk(SecondDisk, CurrentSystemDiskNumber, &IsAligned)) || 
        (!IsAligned)
        ) {
        //
        // The current system disk isn't big enough to hold the partitions
        // on the second disk, so return the first disk as our chosen one.
        //
        SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

        if (BootSameAsSystem) {
            SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
        }

        return FALSE;
    }


    if ((!SpAsrDoesListFitOnDisk(FirstDisk, CurrentSystemDiskNumber,  &IsAligned)) ||
        (!IsAligned)
        ) {
        //
        // The current system disk isn't big enough to hold the partitions
        // on the first disk, so return the second disk as our chosen one.
        //
        FirstPartition->PartitionFlag -= ASR_PTN_MASK_SYS;
        
        if (BootSameAsSystem) {
            FirstPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
        }


        return TRUE;
    }

    //
    // The current system disk is big enough to hold either of the two
    // disks we're trying to decide between.
    //

    //
    // Check active flags
    //
    if ((FirstPartition->ActiveFlag) && (!SecondPartition->ActiveFlag)) {
        //
        // FirstPartition is marked active and SecondPartition isn't
        //
        SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

        if (BootSameAsSystem) {
            SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
        }

        return FALSE;
    }

    if ((!FirstPartition->ActiveFlag) && (SecondPartition->ActiveFlag)) {
        //
        // SecondPartition is marked active and FirstPartition isn't
        //
        FirstPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

        if (BootSameAsSystem) {
            FirstPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
        }

        return TRUE;    // new sys ptn rec
    }

    //
    // Check sizes
    //
    if (FirstPartition->SizeMB != SecondPartition->SizeMB) {
        if (FirstPartition->SizeMB > SecondPartition->SizeMB) {
            //
            // SecondPartition is smaller, so that becomes the new system ptn
            //
            FirstPartition->PartitionFlag -= ASR_PTN_MASK_SYS;
            if (BootSameAsSystem) {
                FirstPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }

            return TRUE;
        } 
        else {
            //
            // FirstPartition is smaller, so that is the system ptn
            //
            SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

            if (BootSameAsSystem) {
                SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }

            return FALSE;
        }
    }

    //
    // Check sizes of the original disks
    //
    if (FirstDisk->TotalSectors != SecondDisk->TotalSectors) {
        if (FirstDisk->TotalSectors > SecondDisk->TotalSectors) {
            // 
            // First disk used to be bigger than the second (and
            // fits in our current system disk), so pick that
            //
            SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

            if (BootSameAsSystem) {
                SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }

            return FALSE;
        }
        else {
            // 
            // Second disk used to be bigger than the first (and
            // fits in our current system disk), so pick that
            //
            FirstPartition->PartitionFlag -= ASR_PTN_MASK_SYS;

            if (BootSameAsSystem) {
                FirstPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
            }

            return TRUE;    // new sys ptn rec
        }
    }

    //
    // Just pick the first (FirstPartition)
    //
    SecondPartition->PartitionFlag -= ASR_PTN_MASK_SYS;
    if (BootSameAsSystem) {
        SecondPartition->PartitionFlag -= ASR_PTN_MASK_BOOT;
    }

    return FALSE;

}


//
// This sets the "NeedsLdmRetype" flag to true for all the partitions on
// the system/boot disk, if the system/boot partition is of an 
// unrecognised partition type.  We need to do this because we can't install
// to unrecognised partition types.
//
VOID
MarkPartitionLdmRetypes(
    PSIF_PARTITION_RECORD pPartition,   // system/boot partition
    PSIF_PARTITION_RECORD pFirst        // first partition rec on the sys/boot disk
    )
{
    PSIF_PARTITION_RECORD pPtnRec = pFirst;

    //
    // Make sure it's an MBR or a GPT disk.  Also, if the system partition
    // is NOT a special partition--such as an 0x42 LDM partition or some other
    // third party FS type that we can't install to--then we don't need to 
    // retype any of the partitions.
    //
    if (PARTITION_STYLE_MBR == pPartition->PartitionStyle) {
        if (IsRecognizedPartition(pPartition->PartitionType)) {
            //
            // They system/boot partition has a recognised FS, such as FAT 
            // or NTFS.  We don't need any special handling.
            //
            return;
        }
    }
    else if (PARTITION_STYLE_GPT == pPartition->PartitionStyle) {
        if (!memcmp(&(pPartition->PartitionTypeGuid), &PARTITION_BASIC_DATA_GUID, sizeof(GUID)) ||
            !memcmp(&(pPartition->PartitionTypeGuid), &PARTITION_ENTRY_UNUSED_GUID, sizeof(GUID)) ||
            !memcmp(&(pPartition->PartitionTypeGuid), &PARTITION_SYSTEM_GUID, sizeof(GUID)) ||
            !memcmp(&(pPartition->PartitionTypeGuid), &PARTITION_MSFT_RESERVED_GUID, sizeof(GUID))
            )  {
            //
            // They system/boot partition is a basic partition type
            // We don't need any special handling.
            //
            return;
        }
    }
    else {
        ASSERT(0 && L"Unrecognised partition type");
        return;
    }

    //
    // The partition of interest is an LDM, or some other special third party
    // partition.  We need to mark all the partitions on that disk of the
    // same type (ie all LDM partitions on the disk) to be retyped to a basic 
    // partition.
    //
    while (pPtnRec) {
        //
        // They both better be the same--either MBR or GPT.
        //
        ASSERT(pPtnRec->PartitionStyle == pPartition->PartitionStyle);

        if (PARTITION_STYLE_MBR == pPtnRec->PartitionStyle) {

            if (pPtnRec->PartitionType == pPartition->PartitionType) {
                //
                // This partition has the same partition-type as the
                // partition of interest.  We need to retype it.
                //
                pPtnRec->NeedsLdmRetype = TRUE;

                DbgStatusMesg((_asrinfo, 
                    "Marked disk [%ws] ptn [%ws] to change (Ptn:0x%x Fs:0x%x)\n", 
                    pPtnRec->DiskKey,
                    pPtnRec->CurrPartKey, 
                    pPtnRec->PartitionType, 
                    pPtnRec->FileSystemType
                    ));
            }
        }
        else if (PARTITION_STYLE_GPT == pPtnRec->PartitionStyle) {
            if (!memcmp(&(pPtnRec->PartitionTypeGuid), &(pPartition->PartitionTypeGuid), sizeof(GUID))) {
                //
                // This partition has the same partition-type as the
                // partition of interest.  We need to retype it.
                //
                pPtnRec->NeedsLdmRetype = TRUE;

                DbgStatusMesg((_asrinfo, 
                    "Marked disk %d ptn [%ws] to change (%ws to basic)\n", 
                    pPtnRec->DiskKey,
                    pPtnRec->CurrPartKey, 
                    pPtnRec->PartitionTypeGuid
                    ));
            }
        }
        pPtnRec = pPtnRec->Next;
    }
}


//
// If more than one system/boot partitions exist (because of mirrors), this
// will mark one as the sys/boot ptns, and reset the others.
//
VOID
SpAsrCheckSifDiskTable(IN CONST DWORD CurrentSystemDiskNumber)
{
    ULONG numDiskRecords = 0,
        diskIndex = 0,
        partitionIndex = 0;

    USHORT numNtPartitionsFound = 0,
        numSysPartitionsFound = 0;
    
    PSIF_DISK_RECORD pDiskRec = NULL,
        pBootDiskRec = NULL, 
        pSysDiskRec = NULL;

    PSIF_PARTITION_RECORD pPtnRec = NULL,
        pBootPtnRec = NULL,
        pSysPtnRec = NULL;

    DWORD dwConsistencyCheck = 0;

    BOOLEAN needToRetypeBoot = TRUE;

    //
    // Go through the sif-disk list.  We check each partition on each of
    // these disks to see if it is marked as boot/sys.  We need
    // at least one boot/sys ptn.
    //
    numDiskRecords = SpAsrGetMbrDiskRecordCount() + SpAsrGetGptDiskRecordCount();

    for (diskIndex = 0; diskIndex < numDiskRecords; diskIndex++) {

        pDiskRec = Gbl_SifDiskTable[diskIndex];
        
        if (!pDiskRec || !(pDiskRec->PartitionList)) {
            continue;
        }
        
        pPtnRec = Gbl_SifDiskTable[diskIndex]->PartitionList->First;
        while (pPtnRec) {
            
            //
            // A system could end up having multiple boot and/or system
            // partitions.  For instance, LDM-Pro supports 3-way mirrors, 
            // and we would hence have three partitions marked as boot/sys.
            // 
            // We will reset this to have only one boot partition, 
            // and only one system partition.
            //
            
            if (SpAsrIsSystemPartitionRecord(pPtnRec->PartitionFlag) &&
                SpAsrIsBootPartitionRecord(pPtnRec->PartitionFlag)) {

                //
                // The boot and system volumes are the same
                //

                ASSERT((0 == dwConsistencyCheck) || (1 == dwConsistencyCheck));

                if (0 == dwConsistencyCheck) {
                    DbgStatusMesg((_asrinfo,
                    "Boot and system partitions are the same\n"
                    ));
                }

                dwConsistencyCheck = 1;

                numSysPartitionsFound++;
                numNtPartitionsFound++;

                if (numSysPartitionsFound == 1) {
                    //
                    // This is the first system/boot partition we found.  Save
                    // a pointer to it.
                    //
                    pDiskRec->ContainsSystemPartition = TRUE;

                    pSysPtnRec  = pPtnRec;
                    pSysDiskRec = pDiskRec;

                    pDiskRec->ContainsNtPartition = TRUE;

                    pBootPtnRec  = pPtnRec;
                    pBootDiskRec = pDiskRec;


                }
                else {
                    //
                    // We found more than one system/boot partition.  Pick one
                    // of them as the system/boot  partition and reset the 
                    // other for now.  (It will be recreated at the end of
                    // gui setup by the appropriate vol mgr utils).
                    //
                    BOOLEAN newSys = PickASystemPartition(pSysPtnRec, 
                        pSysDiskRec, 
                        pPtnRec, 
                        pDiskRec, 
                        CurrentSystemDiskNumber,
                        TRUE        // Boot and system are the same
                        );

                    if (newSys) {
                        //
                        // pPtnRec is the new system partition
                        //
                        pSysDiskRec->ContainsSystemPartition = FALSE;
                        pDiskRec->ContainsSystemPartition = TRUE;
                        pSysDiskRec = pDiskRec;
                        pSysPtnRec  = pPtnRec;


                        pBootDiskRec->ContainsNtPartition = FALSE;
                        pDiskRec->ContainsNtPartition = TRUE;
                        pBootDiskRec = pDiskRec;
                        pBootPtnRec  = pPtnRec;
                   }
                }
            }
            else {

                //
                // The boot and system volumes are distinct
                //

                if (SpAsrIsBootPartitionRecord(pPtnRec->PartitionFlag)) {

                    if (0 == dwConsistencyCheck) {
                        DbgStatusMesg((_asrinfo,
                        "Boot and system partitions different\n"
                        ));
                    }

                    ASSERT((0 == dwConsistencyCheck) || (2 == dwConsistencyCheck));
                    dwConsistencyCheck = 2;

                    numNtPartitionsFound++;

                    if (numNtPartitionsFound == 1) {
                        //
                        // This is the first boot partition we found, save
                        // a pointer to it.
                        //
                        pDiskRec->ContainsNtPartition = TRUE;

                        pBootPtnRec  = pPtnRec;
                        pBootDiskRec = pDiskRec;
                    } 
                    else {
                        //
                        // We found more than one boot partition.  Pick 
                        // one of them as the boot partition, reset the other
                        // for now.  (It will be recreated at the end of
                        // gui setup by the appropriate vol mgr utils).
                        //
                        BOOLEAN newBoot = PickABootPartition(pBootPtnRec, pPtnRec);

                        if (newBoot) {
                            // 
                            // pPtnRec is our new boot record
                            //
                            pBootDiskRec->ContainsNtPartition = FALSE;
                            pDiskRec->ContainsNtPartition = TRUE;
                            pBootDiskRec = pDiskRec;
                            pBootPtnRec  = pPtnRec;
                        }
                    }
                }

                if (SpAsrIsSystemPartitionRecord(pPtnRec->PartitionFlag)) {
                    
                    ASSERT((0 == dwConsistencyCheck) || (2 == dwConsistencyCheck));
                    dwConsistencyCheck = 2;

                    numSysPartitionsFound++;

                    if (numSysPartitionsFound == 1) {
                        //
                        // This is the first system partition we found.  Save
                        // a pointer to it.
                        //
                        pDiskRec->ContainsSystemPartition = TRUE;

                        pSysPtnRec  = pPtnRec;
                        pSysDiskRec = pDiskRec;

                    }
                    else {
                        //
                        // We found more than one system partition.  Pick one of
                        // them as the system partition and reset the other
                        // for now.  (It will be recreated at the end of
                        // gui setup by the appropriate vol mgr utils).
                        //
                        BOOLEAN newSys = PickASystemPartition(pSysPtnRec, 
                            pSysDiskRec, 
                            pPtnRec, 
                            pDiskRec, 
                            CurrentSystemDiskNumber,
                            FALSE   // Boot and system are distinct
                            );

                        if (newSys) {
                            //
                            // pPtnRec is the new system partition
                            //
                            pSysDiskRec->ContainsSystemPartition = FALSE;
                            pDiskRec->ContainsSystemPartition = TRUE;
                            pSysDiskRec = pDiskRec;
                            pSysPtnRec  = pPtnRec;

                        }
                    }
                }

            }

            pPtnRec = pPtnRec->Next;
        }
    }

    DbgStatusMesg((_asrinfo,
        "Found %hu boot partition(s) and %hu system partition(s) in asr.sif\n",
        numNtPartitionsFound,
        numSysPartitionsFound
        ));

    //
    // We should have at least one boot and one system volume
    // We can't proceed without them, so this has to be a fatal error.
    //
    if (numNtPartitionsFound < 1) {
        DbgFatalMesg((_asrerr, "Error in asr.sif: No boot partitions found.\n"));

        SpAsrRaiseFatalErrorWs(
            SP_SCRN_DR_SIF_BAD_RECORD,
            L"No boot partition found in asr.sif",
            SIF_ASR_PARTITIONS_SECTION
            );
    }

    if (numSysPartitionsFound < 1) {
        DbgFatalMesg((_asrerr, "Error in asr.sif: No system partitions found.\n"));

        SpAsrRaiseFatalErrorWs(
            SP_SCRN_DR_SIF_BAD_RECORD,
            L"No system partition found in asr.sif",
            SIF_ASR_PARTITIONS_SECTION
            );
    }

    //
    // Now, look for the disk(s) which contain the boot and system partitions.
    // If any partitions on these disks are not recognised (recognised implies
    // types 6, 7 and B--if they aren't recognised, they could be LDM (0x42), 
    // LDM-Pro, etc) then *all* the partitions on the disk that have the 
    // same type as the system or boot partition are changed to the basic type.
    // 
    // For the boot and system partitions, since we actually format them in text-
    // mode, we will change the type to the FS type.  For everything else, we
    // don't format them till the volumes are actually exposed by LDM/LDM-Pro.
    // So we just use type 0x7 as a place-holder.
    //
    // LDM needs this to recover its state after textmode setup. Mark them.
    //
    needToRetypeBoot = TRUE;
    if (PARTITION_STYLE_MBR == pSysDiskRec->PartitionStyle) {
        MarkPartitionLdmRetypes(pSysPtnRec, pSysDiskRec->PartitionList->First);
        if (pBootDiskRec == pSysDiskRec) {
            needToRetypeBoot = FALSE;
        }
    }
    
    if (needToRetypeBoot) {
        MarkPartitionLdmRetypes(pBootPtnRec, pBootDiskRec->PartitionList->First);
    }

} // SpAsrCheckSifDiskTable


PDISK_REGION
SpAsrDiskPartitionExists(
    IN ULONG Disk,
    IN PSIF_PARTITION_RECORD pRec
    )
{
    PPARTITIONED_DISK pDisk = NULL;
    PDISK_REGION pRegion = NULL;
    ULONGLONG startSector = 0;
    BOOLEAN isLogical = FALSE;

    pDisk = &PartitionedDisks[Disk];

    isLogical = pRec->IsLogicalDiskRecord;
    startSector = pRec->StartSector;// - (isLogical? SECTORS_PER_TRACK(Disk) : 0);

    pRegion = SpPtLookupRegionByStart(
        pDisk,
        (BOOLEAN) (pRec->IsPrimaryRecord ? 0 : 1),
        startSector
        );

    if (!pRegion && isLogical) {
        //
        // For logical drives, try finding their descriptor.
        //
        startSector = pRec->StartSector - SECTORS_PER_TRACK(Disk);
        pRegion = SpPtLookupRegionByStart(
            pDisk,
            (BOOLEAN) (pRec->IsPrimaryRecord ? 0 : 1),
            startSector
            );
    }

    if (!pRegion) {
        //
        // No primary or extended partition could be found at the specified start sector.
        //
        DbgErrorMesg((_asrwarn, "partition for record [%ws] not found at start sector %I64u (disk %lu)\n",
            pRec->CurrPartKey,
            startSector,
            Disk
            ));

        return NULL;
    }

    DbgStatusMesg((_asrinfo, "Partition for record [%ws] found at SS %I64u\n",
        pRec->CurrPartKey,
        startSector
        ));

    return pRegion;
}


//
// Goes through the list of sif-disks ("partition sets") and checks if
// they are intact.  A disk is intact if its signature and the partition 
// layout are intact.
//
VOID
MarkIntactSifDisk(IN ULONG Disk, IN PDISK_PARTITION_SET pSet)
{
    PSIF_PARTITION_RECORD pRec  = NULL;
    ULONG diskSignature = 0;
    PDISK_REGION pRegion = NULL;

    if (!pSet || !pSet->pDiskRecord) {
        DbgStatusMesg((_asrinfo, "Disk %lu contains no partition set\n", Disk));
        return;
    }

    pSet->IsReplacementDisk = TRUE;
    pSet->PartitionsIntact = FALSE;

    //
    // If one's an MBR and the other's a GPT, it's not the same disk
    //
    if (pSet->pDiskRecord->PartitionStyle != (PARTITION_STYLE) HardDisks[Disk].DriveLayout.PartitionStyle) {
        return;
    }

    //
    // If signatures (MBR) or disk ID's (GPT) are different, it 
    // is a replacement disk
    //
    if (PARTITION_STYLE_MBR == pSet->pDiskRecord->PartitionStyle) {
        diskSignature = SpAsrGetActualDiskSignature(Disk);
        if (pSet->pDiskRecord->SifDiskMbrSignature != diskSignature) {
            return;
        }
    }
    else if (PARTITION_STYLE_GPT == pSet->pDiskRecord->PartitionStyle) {

        if (memcmp(&(HardDisks[Disk].DriveLayout.Gpt.DiskId),
            &(pSet->pDiskRecord->SifDiskGptId),
            sizeof(GUID)
            )) {
            return;
        }
    }


    //
    // This is the same disk as the original system.  Now, determine whether 
    // the disk is intact.
    //
    pSet->IsReplacementDisk = FALSE;
    pSet->PartitionsIntact  = TRUE;

    // 
    // The disk had no partitions to begin with, we'll assume it's intact
    //
    if (!(pSet->pDiskRecord->PartitionList)) {
        DbgStatusMesg((_asrinfo,
            "MarkIntactSifDisk. ptn-list for disk %lu NULL, assuming it is intact\n", 
            Disk));
        return;
    }

    //
    // check if each partition exists
    //
    pRec = pSet->pDiskRecord->PartitionList->First;
    while (pRec) {
        //
        // we're interested only in primary partitions and logical disks
        //
        if ((pRec->IsPrimaryRecord) || (pRec->IsLogicalDiskRecord)) {

            //
            // Make sure the region exists
            //
            pRegion = SpAsrDiskPartitionExists(Disk, pRec);
            if (!pRegion) {
                
                DbgStatusMesg((_asrinfo, "Partition %p [%ws], SS "
                    "%I64u NOT intact: Region not found\n",
                    pRec, pRec->CurrPartKey, pRec->StartSector));

                pSet->PartitionsIntact = FALSE;
                break;
            }

            //
            // And it's not free space
            //
            if (!(SPPT_IS_REGION_PARTITIONED(pRegion))) {

                DbgStatusMesg((_asrinfo, "Partition %p [%ws], SS %I64u NOT "
                    "intact: Region %p not partitioned\n",
                    pRec, pRec->CurrPartKey, pRec->StartSector, pRegion));

                pSet->PartitionsIntact = FALSE;
                break;

            }

            //
            // And that the partition lengths match
            //
            if (pRegion->SectorCount != pRec->SectorCount) {

                DbgStatusMesg((_asrinfo, "Partition %p [%ws] Region %p, SS "
                    "%I64u NOT intact (Sector count orig-ptn: %I64u, Region: "
                    " %I64u)\n", pRec, pRec->CurrPartKey, pRegion, 
                    pRec->StartSector, pRec->SectorCount, pRegion->SectorCount));

                pSet->PartitionsIntact = FALSE;
                break;
            }

            //
            // And that the partition type is the same
            //
            if (PARTITION_STYLE_MBR == pSet->pDiskRecord->PartitionStyle) {
                if (pRegion->PartInfo.Mbr.PartitionType != pRec->PartitionType) {

                    DbgStatusMesg((_asrinfo, "Partition %p [%ws] Region %p, SS "
                        "%I64u NOT intact (Ptn types orig-ptn: 0x%x, Region: "
                        "0x%x)\n", pRec, pRec->CurrPartKey, pRegion,
                        pRec->StartSector, pRec->PartitionType,
                        pRegion->PartInfo.Mbr.PartitionType));

                    pSet->PartitionsIntact = FALSE;
                    break;
                }
            }
            else if (PARTITION_STYLE_GPT == pSet->pDiskRecord->PartitionStyle) {

                if (memcmp(&(pRegion->PartInfo.Gpt.PartitionId),
                    &(pRec->PartitionIdGuid), sizeof(GUID))) {

                    DbgStatusMesg((_asrinfo, "Partition %p [%ws] Region %p, "
                        "SS %I64u NOT intact (GPT partition Id's don't match)\n",
                        pRec, pRec->CurrPartKey,pRegion, pRec->StartSector));

                    pSet->PartitionsIntact = FALSE;
                    break;
                }

                if (memcmp(&(pRegion->PartInfo.Gpt.PartitionType),
                    &(pRec->PartitionTypeGuid), sizeof(GUID))) {

                    DbgStatusMesg((_asrinfo, "Partition %p [%ws] Region %p, "
                        "SS %I64u NOT intact (GPT partition types don't match)\n",
                        pRec, pRec->CurrPartKey, pRegion, pRec->StartSector));

                    pSet->PartitionsIntact = FALSE;
                    break;
                }

                //
                // Note that I'm not checking the GPT attributes here.  If 
                // the attributes are not intact, but everything else above 
                // is, we'll assume that the partition is intact.
                //
            }

            //
            // And finally, if the boot/system region is dynamic, we 
            // repartition the disk.
            //
            if (SpAsrIsBootPartitionRecord(pRec->PartitionFlag) || 
                SpAsrIsSystemPartitionRecord(pRec->PartitionFlag)) {

                if (pRegion->DynamicVolume) {

                    DbgStatusMesg((_asrinfo, "Boot/system partition %p [%ws] "
                        "Region %p,  SS %I64u NOT intact (Dynamic region)\n",
                        pRec, pRec->CurrPartKey, pRegion, pRec->StartSector));

                    pSet->PartitionsIntact = FALSE;
                    break;
                }
            }
        }

        pRec = pRec->Next;
    }

    DbgStatusMesg((_asrinfo, "Disk %lu is %wsintact\n", 
        Disk, (pSet->PartitionsIntact ? L"" : L"NOT ")));
}


VOID
MarkIntactSifDisks(VOID)
{
    ULONG disk;

    for (disk = 0; disk < HardDiskCount; disk++) {
        if (Gbl_PartitionSetTable1[disk]) {
           MarkIntactSifDisk(disk, Gbl_PartitionSetTable1[disk]);
        }
    }
}


//
// Snaps the partitions in the list pRecord to cylinder boundaries, using the
// disk geometry from HardDisks[PhysicalIndex].
//
// This should only be called for MBR partitions, though it should work for GPT
// partitions as well.
//
//
ULONGLONG
CylinderAlignPartitions(
    IN ULONG PhysicalIndex,
    IN PSIF_PARTITION_RECORD pFirst
    ) 
{
    ULONGLONG endSector = 0,
        logicalDisksNeed = 0;

    PSIF_PARTITION_RECORD pRecord = pFirst;

    //
    // First, figure out how much the logical disks need. The container 
    // partition must be big enough to hold these.
    //
    while (pRecord) {
        
        if (pRecord->IsLogicalDiskRecord) {

            logicalDisksNeed += SpPtAlignStart(
                &HardDisks[PhysicalIndex],
                pRecord->SectorCount,
                TRUE
                );

        }
        pRecord = pRecord->Next;
    }

    //
    // Next, calculate how much the primary partitions and the container need.
    //
    pRecord = pFirst;
    while (pRecord) {

        if (pRecord->IsPrimaryRecord) {
            endSector += SpPtAlignStart(&HardDisks[PhysicalIndex],
                pRecord->SectorCount,
                TRUE
                );
        }
        else if (pRecord->IsContainerRecord) {
            //
            // The container partition must be at least as big as the logical
            // drives inside it.
            //
            ULONGLONG ContainerNeeds = SpPtAlignStart(&HardDisks[PhysicalIndex],
                pRecord->SectorCount,
                TRUE
                );

            endSector += ((logicalDisksNeed > ContainerNeeds) ? logicalDisksNeed : ContainerNeeds);
        }

        pRecord = pRecord->Next;
    }

    return endSector;
}


VOID
SpAsrAssignPartitionSet(
    IN ULONG PhysicalDisk, 
    IN ULONG SifDisk,
    IN CONST BOOLEAN IsAligned
    )
{
    PDISK_PARTITION_SET pSet = NULL;
    PSIF_PARTITION_RECORD pRec = NULL;

    //
    // Ensure that the partition set isn't already assigned.  This is
    // a serious enough problem to report a fatal internal error if
    // it happens.
    //
    if (Gbl_PartitionSetTable1[PhysicalDisk]) {

        DbgFatalMesg((_asrerr,
            "SpAsrAssignPartitionSet. SifDisk Index %lu: Gbl_PartitionSetTable1[%lu] already assigned.\n",
            SifDisk, 
            PhysicalDisk
            ));

        swprintf(
            TemporaryBuffer,
            L"SifDisk Index %lu - Gbl_PartitionSetTable1[%lu] already assigned.",
            SifDisk, PhysicalDisk
            );

        INTERNAL_ERROR(TemporaryBuffer);         // ok
        // does not return
    }

    //
    // Assign the partition set
    //
    pSet = SpAsrMemAlloc(sizeof(DISK_PARTITION_SET), TRUE);
    pSet->pDiskRecord = Gbl_SifDiskTable[SifDisk];
    pSet->pDiskRecord->Assigned = TRUE;
    pSet->pDiskRecord->pSetRecord = pSet;
    pSet->PartitionStyle = pSet->pDiskRecord->PartitionStyle;

    if (PARTITION_STYLE_MBR == pSet->PartitionStyle) {
        pSet->ActualDiskSignature = pSet->pDiskRecord->SifDiskMbrSignature;
    }

    pSet->ActualDiskSizeMB = DISK_SIZE_MB(PhysicalDisk);
    pSet->PartitionsIntact = FALSE;
    pSet->IsReplacementDisk = TRUE;
    pSet->NtPartitionKey = NULL;
    pSet->Index = PhysicalDisk;
    pSet->IsAligned = IsAligned;

    //
    // Check for boot or system partitions
    //
    if (pSet->pDiskRecord->PartitionList) {
        pRec = pSet->pDiskRecord->PartitionList->First;
        while (pRec) {
            if (SpAsrIsBootPartitionRecord(pRec->PartitionFlag)) {
                pSet->NtPartitionKey = pRec->CurrPartKey;
                ASSERT(pSet->pDiskRecord->ContainsNtPartition);
    //            pSet->pDiskRecord->ContainsNtPartition = TRUE;    // should've already been set
            }

            if (SpAsrIsSystemPartitionRecord(pRec->PartitionFlag)) {
               ASSERT(pSet->pDiskRecord->ContainsSystemPartition);  // should've already been set
            }

            pRec = pRec->Next;
        }                    

        //
        // Cylinder align the partitions.
        //
        Gbl_SifDiskTable[SifDisk]->LastUsedAlignedSector = CylinderAlignPartitions(
            PhysicalDisk, 
            Gbl_SifDiskTable[SifDisk]->PartitionList->First
            );
    }
    else {
        Gbl_SifDiskTable[SifDisk]->LastUsedAlignedSector = 0;
    }
     
    Gbl_PartitionSetTable1[PhysicalDisk] = pSet;
    Gbl_PartitionSetCount += 1;
}


//
// We only extend FAT32, NTFS and Container partitions.  We don't extend
// FAT or unknown (including LDM) partitions
//
BOOLEAN
IsExtendable(UCHAR PartitionType) 
{
    switch (PartitionType) {

        case PARTITION_EXTENDED:

        case PARTITION_IFS:
    
        case PARTITION_XINT13:
        case PARTITION_XINT13_EXTENDED:

            return TRUE;
    }

    if (IsContainerPartition(PartitionType)) {
        return TRUE;
    }

    return FALSE;
}


//
// Will resize (extend) the last partition on the disk if there is free space
// at the end (and there was no free space at the end of the original disk).
// The last partition must be FAT32 or NTFS--we don't extend FAT or unknown
// partitions.  This routine also extends any container partitions that
// contained the last partition.
//
BOOLEAN
SpAsrAutoExtendDiskPartition(
    IN ULONG PhysicalIndex, 
    IN ULONG SifIndex
    )
{

    ULONGLONG oldFreeSpace = 0,
        newEndSector = 0,
        newEndOfDisk = 0,
        extraSpace = 0;

    BOOLEAN didAnExtend = FALSE;

    DWORD bytesPerSector = Gbl_SifDiskTable[SifIndex]->BytesPerSector;

    PSIF_PARTITION_RECORD pPtnRecord = NULL;

    //
    // We won't extend GPT partitions
    //
    if (PARTITION_STYLE_MBR != Gbl_SifDiskTable[SifIndex]->PartitionStyle) {
        return FALSE;
    }

    //
    // Check if there was free space at the end of the original disk
    //
    oldFreeSpace = (Gbl_SifDiskTable[SifIndex]->TotalSectors - 
        Gbl_SifDiskTable[SifIndex]->LastUsedSector) *
        bytesPerSector;


    if ((oldFreeSpace > ASR_FREE_SPACE_FUDGE_FACTOR_BYTES) ||  // free space at the end of old disk
        (!Gbl_AutoExtend) ||                                // auto-extend is disabled in the sif
        (!Gbl_SifDiskTable[SifIndex]->PartitionList)) {     // no partitions on disk

        return FALSE;
    }

    //
    // We can auto-extend.  Check how many free sectors are available at the end of 
    // the new disk.
    //
    newEndSector = Gbl_SifDiskTable[SifIndex]->LastUsedAlignedSector;
    
    //
    // Find the last cylinder boundary that we can use.  This is usually the last cylinder
    // boundary on the disk.  The only exception is when the "fall off sectors" after the
    // end of the last cylinder boundary are less than the 1 MB needed for LDM private region.
    //
    newEndOfDisk = HardDisks[PhysicalIndex].SectorsPerCylinder * 
        HardDisks[PhysicalIndex].Geometry.Cylinders.QuadPart;

    if (((newEndOfDisk - Gbl_PhysicalDiskInfo[PhysicalIndex].TrueDiskSize) * BYTES_PER_SECTOR(PhysicalIndex))
        < ASR_LDM_RESERVED_SPACE_BYTES) {
        newEndOfDisk -=  HardDisks[PhysicalIndex].SectorsPerCylinder;
    }

    extraSpace = newEndOfDisk - newEndSector;

    //
    // Go through all the partitions, and for partitions that end on the newEndSector,
    // add the extra space to their SectorCounts.
    //
    pPtnRecord = Gbl_SifDiskTable[SifIndex]->PartitionList->First;

    while (pPtnRecord) {

        if (((pPtnRecord->StartSector) + (pPtnRecord->SectorCount) == newEndSector) 
            && (IsExtendable(pPtnRecord->PartitionType))) {
            didAnExtend = TRUE;
            pPtnRecord->SectorCount += extraSpace;

            pPtnRecord->SizeMB = SpAsrConvertSectorsToMB(pPtnRecord->SectorCount, bytesPerSector);
    
        }
        pPtnRecord = pPtnRecord->Next;
    }

    return didAnExtend;
}



VOID
SpAsrSystemWasDataWarning()
/*++

Routine Description:
    Display a screen warning the user that his current system
    disk used to be a data disk that we recognise and will 
    destroy, and allow him to abort

Arguments:
    None.

Return Value:
    None.

--*/
{
    ULONG warningKeys[] = {KEY_F3, ASCI_CR, 0};
    ULONG mnemonicKeys[] = {0};
    BOOLEAN done = FALSE;

    //
    // We currently display a list of disks that will be repartitioned
    // anyway.  
    //
    return;

/*
// put this back in user\msg.mc if reactivating this bit of code.
MessageId=12429 SymbolicName=SP_SCRN_DR_SYSTEM_DISK_WAS_DATA_DISK
Language=English
The current system disk used to be a data disk.

To continue, press Enter

To quit Setup, press F3. No changes will be
made to any of the disks on the system.
.

  do {
        // display the warning message
        SpDisplayScreen(SP_SCRN_DR_SYSTEM_DISK_WAS_DATA_DISK,3,4);
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                               SP_STAT_ENTER_EQUALS_CONTINUE,
                               SP_STAT_F3_EQUALS_EXIT,
                               0
                               );

        // wait for keypress.  Valid keys:
        // ENTER = continue
        // F3 = exit
        SpInputDrain();
        switch(SpWaitValidKey(warningKeys,NULL,mnemonicKeys)) {
        case KEY_F3:
            // User wants to exit.
            SpConfirmExit();
            break;

        case ASCI_CR:
            // User wants to continue.
            done = TRUE;
            break;
        }
    } while (!done);

*/

}


//
// This assigns a disk based on signature (for MBR disks) or diskId (for GPT disks)
//
//
VOID
SpAsrAssignDisksBySignature(DWORD PhysicalSystemIndex)
{
    ULONG index =0,
        sifIndex = 0, 
        physicalIndex = 0,
        numDiskRecords = 0, 
        diskSignature = 0;

    BOOLEAN done = FALSE,
        matchFound = FALSE,
        IsAligned = TRUE;

    WCHAR physicalDiskGuid[MAX_PATH + 1];

    numDiskRecords = SpAsrGetDiskRecordCount();

    // 
    // Loop through the list of sif disks, and attempt to find a 
    // physical disk with the same signature.  
    //
    for (sifIndex = 0; sifIndex < numDiskRecords; sifIndex++) {

        if (
            ((PARTITION_STYLE_MBR == Gbl_SifDiskTable[sifIndex]->PartitionStyle) && 
            !(Gbl_SifDiskTable[sifIndex]->SifDiskMbrSignature)) ||

            ((PARTITION_STYLE_GPT == Gbl_SifDiskTable[sifIndex]->PartitionStyle) && 
            SpAsrIsZeroGuid(&(Gbl_SifDiskTable[sifIndex]->SifDiskGptId)))
            
            ) {
            //
            // Skip GPT disks that have no ID, and MBR disks that have no signature
            //
            continue;
        }

        if (Gbl_SifDiskTable[sifIndex]->ContainsSystemPartition) {
            //
            // The system disk would have already been assigned
            //
            ASSERT(Gbl_SifDiskTable[sifIndex]->Assigned && L"System disk should be assigned");
        }

        done = FALSE;
        for (physicalIndex = 0; (physicalIndex < HardDiskCount) && (!done); physicalIndex++) {

            matchFound = FALSE;

            if (DISK_IS_REMOVABLE(physicalIndex)) { 
                continue;
            }

            if (Gbl_SifDiskTable[sifIndex]->PartitionStyle != 
                (PARTITION_STYLE) HardDisks[physicalIndex].DriveLayout.PartitionStyle
                ) {
                //
                // The sif disk's MBR, and the physical disk's GPT, or vice-versa.
                //
                continue;
            }

            if (PARTITION_STYLE_MBR == Gbl_SifDiskTable[sifIndex]->PartitionStyle) {

                diskSignature = SpAsrGetActualDiskSignature(physicalIndex);
                if (!diskSignature) {   
                    //
                    // we won't assign disks with no signature here
                    //
                    continue;
                }

                if (diskSignature == Gbl_SifDiskTable[sifIndex]->SifDiskMbrSignature) {

                    if (Gbl_PartitionSetTable1[physicalIndex]) {
                        //
                        // The signatures match, but this physical-disk has already 
                        // been assigned.  This can be because this physical disk is
                        // the current system disk, or (!) there were duplicate
                        // signatures.
                        // 
                        if (Gbl_PartitionSetTable1[physicalIndex]->pDiskRecord &&
                            Gbl_PartitionSetTable1[physicalIndex]->pDiskRecord->ContainsSystemPartition) {
                        
                            if (PhysicalSystemIndex == physicalIndex) {
                                //
                                // This is the original system disk
                                //
                                Gbl_PartitionSetTable1[physicalIndex]->IsReplacementDisk = FALSE;
                            }
                            else {
                                //
                                // We recognise the physical disk to be some other data
                                // disk in the original system.  
                                //
                                SpAsrSystemWasDataWarning();
                            }
                        }
                        else {
                            ASSERT(0 && L"Disk already assigned");
                        }

                        continue;
                    }

                    //
                    // We found a disk with matching signatures
                    //
                    matchFound = TRUE;
                }
            }
            else if (PARTITION_STYLE_GPT == Gbl_SifDiskTable[sifIndex]->PartitionStyle) {

                if (!memcmp(&(HardDisks[physicalIndex].DriveLayout.Gpt.DiskId),
                    &(Gbl_SifDiskTable[sifIndex]->SifDiskGptId), 
                    sizeof(GUID)
                    )) {

                    if (Gbl_PartitionSetTable1[physicalIndex]) {
                        //
                        // The signatures match, but this physical-disk has already 
                        // been assigned.  This can be because this physical disk is
                        // the current system disk, or (!) there were duplicate
                        // signatures.
                        // 
                        if (Gbl_PartitionSetTable1[physicalIndex]->pDiskRecord &&
                            Gbl_PartitionSetTable1[physicalIndex]->pDiskRecord->ContainsSystemPartition) {
                            if (PhysicalSystemIndex == physicalIndex) {
                                Gbl_PartitionSetTable1[physicalIndex]->IsReplacementDisk = FALSE;
                            }
                            else {
                                //
                                // We recognise the physical disk to be some other data
                                // disk in the original system.  
                                //
                                SpAsrSystemWasDataWarning();
                            }
                        }
                        else {
                            ASSERT(0 && L"Disk already assigned");
                        }
                        continue;
                    }

                    //
                    // We found a disk with matching signatures
                    //
                    matchFound = TRUE;
                }
            }

            if (matchFound) {
                //
                // Make sure it fits (!)
                //
                if (SpAsrDoesListFitOnDisk(Gbl_SifDiskTable[sifIndex], physicalIndex, &IsAligned)) {

                    SpAsrAssignPartitionSet(physicalIndex, sifIndex, IsAligned);
                    //
                    // Will not auto-extend disks that match by signature
                    //

                    //
                    // The signatures match, so we assume it's original (may not be
                    // intact, but it's the original)
                    //
                    Gbl_PartitionSetTable1[physicalIndex]->IsReplacementDisk = FALSE;

                    DbgStatusMesg((_asrinfo, "Partition list %lu assigned to disk %lu (assign by signature).\n",
                        sifIndex,
                        physicalIndex
                        ));
                }
                else {

                    DbgStatusMesg((_asrerr, "Disk signatures match, but partitions don't fit!  Partition list %lu, disk %lu.  Not assigned\n",
                        sifIndex,
                        physicalIndex
                        ));
                }

                done = TRUE;
            }
        }
    }
} // SpAsrAssignDisksBySignature


//
// Checks if the partition list fits on the disk.  In addition to checking
// the total sizeSectors of the disk and the SectorCount of the partition list,
// we also need to try and "lay out" the partitions on the disk to make sure 
// that they fit--because of different disk geometries and the requirement that 
// partitions must be cylinder-aligned, we may have a list that doesn't fit on 
// a disk even if the total sectors it requires is less than the sectors on the 
// disk
//
BOOLEAN
SpAsrDoesListFitOnDisk(
    IN PSIF_DISK_RECORD pSifDisk,
    IN ULONG DiskIndex,
    OUT BOOLEAN *IsAligned
    )
{
    ULONGLONG endSector = 0;
    PSIF_PARTITION_RECORD_LIST pList = NULL;
    BOOLEAN tryNoAlign = FALSE;
    
    if ((DWORD)(-1) == DiskIndex) {
        return FALSE;
    }

    if (!(pSifDisk && pSifDisk->PartitionList)) {
        return TRUE;
    }

    ASSERT(pSifDisk && pSifDisk->PartitionList);
    pList = pSifDisk->PartitionList;
    *IsAligned = FALSE;
    
    //
    // Requirement 1.  The replacement disk must have at least as many 
    //  "true" sectors as the original disk.  This is a little more
    //  restrictive than is absolutely required, but it somewhat simplifies
    //  the LDM requirement of making sure we have enough cylinders to create
    //  the LDM private database at the end.  
    //
    if (pList->DiskSectorCount >  Gbl_PhysicalDiskInfo[DiskIndex].TrueDiskSize) {

        DbgStatusMesg((_asrinfo, 
            "Original Disk sector count %I64u, Current Disk %lu true sector count %I64u.  Not big enough\n",
            pList->DiskSectorCount, DiskIndex, Gbl_PhysicalDiskInfo[DiskIndex].TrueDiskSize
            ));
     
        return FALSE;
    }

    //
    // Requirement 2:
    //
    // "If the replacement disk has a different geometry, ASR will cylinder-
    // align the partitions--this may result in some partitions being marginally 
    // bigger than they used to be.  The requirement in this case is that the 
    // replacement disk must have at least as many true sectors as the original 
    // disk, plus the number of sectors required to cylinder-align all 
    // partitions."
    // 
    //

    //
    // Cylinder-align the partitions
    //
    endSector = CylinderAlignPartitions(DiskIndex, pList->First);
    *IsAligned = TRUE;

    //
    // And make sure that the space at the end is at least as much as it 
    // used to be
    //
    if ((pList->DiskSectorCount - pList->LastUsedSector) 
        > (Gbl_PhysicalDiskInfo[DiskIndex].TrueDiskSize - endSector)) {

        DbgStatusMesg((_asrinfo, 
            "List->DiskSectorCount: %I64u, LastUsedSector:%I64u, Disk->TrueDiskSize: %I64u, EndSector: %I64u.  Not big enough\n",
            pList->DiskSectorCount, pList->LastUsedSector, Gbl_PhysicalDiskInfo[DiskIndex].TrueDiskSize, endSector
            ));
     
        tryNoAlign = TRUE;
    }

    if (endSector > Gbl_PhysicalDiskInfo[DiskIndex].TrueDiskSize) {

        DbgStatusMesg((_asrinfo, 
            "List->DiskSectorCount: %I64u, Disk->TrueDiskSize: %I64u < EndSector: %I64u.  Not big enough\n",
            pList->DiskSectorCount, Gbl_PhysicalDiskInfo[DiskIndex].TrueDiskSize, endSector
            ));
     
        tryNoAlign = TRUE;
    }


    if (tryNoAlign) {
        //
        // We couldn't fit the partitions on the disk after cylinder-aligning
        // them.  If the disk has the exact same geometry as it used to, we
        // can try to fit the partitions on it without cylinder aligning them.
        //
        if ((pSifDisk->BytesPerSector == HardDisks[DiskIndex].Geometry.BytesPerSector) &&
            (pSifDisk->SectorsPerTrack == HardDisks[DiskIndex].Geometry.SectorsPerTrack) &&
            (pSifDisk->TracksPerCylinder == HardDisks[DiskIndex].Geometry.TracksPerCylinder)
            ) {
            //
            // The geometries are the same.  We don't really need to *check*
            // if the partitions will fit, since we already know that the disk
            // is large enough to hold them (we checked the sector count above)
            //
            *IsAligned = FALSE;
            return TRUE;
        }

        //
        // The partitions didn't fit, and the disk has a different geometry. 
        // Oh well.
        //
        return FALSE;
    }

    //
    // This disk is okay to hold this list
    //
    DbgStatusMesg((_asrinfo, 
        "List->DiskSectorCount: %I64u, LastUsedSector: %I64u, Disk->TrueDiskSize: %I64u, EndSector: %I64u.  Disk okay.\n",
        pList->DiskSectorCount, pList->LastUsedSector, Gbl_PhysicalDiskInfo[DiskIndex].TrueDiskSize, endSector
        ));

    return TRUE;
}


BOOLEAN
SpAsrIsThisDiskABetterFit(
    IN DWORD CurrentBest,
    IN DWORD PhysicalIndex,
    IN DWORD SifIndex,
    OUT BOOLEAN *IsAligned
    )
{

    if ((CurrentBest == HardDiskCount) || 
        (DISK_SIZE_MB(PhysicalIndex) < DISK_SIZE_MB(CurrentBest))) {
        
        if ((!DISK_IS_REMOVABLE(PhysicalIndex)) &&
            (BYTES_PER_SECTOR(PhysicalIndex) == (Gbl_SifDiskTable[SifIndex]->BytesPerSector)) &&
            SpAsrDoesListFitOnDisk(Gbl_SifDiskTable[SifIndex], PhysicalIndex, IsAligned)) {

            return TRUE;
        }
    }

    return FALSE;
}


//
// Attempts to assign remaining sif disks to physical disks that
// are on the same bus as the sif disk originally was (ie if
// any other disk on that bus has been assigned, this tries to assign
// this disk to the same bus)
//
VOID
SpAsrAssignCriticalDisksByBus()
{
    DWORD sifIndex = 0,
        sifIndex2 = 0,
        physicalIndex = 0,
        currentBest = 0,
        targetBusId = 0,
        numDiskRecords = 0;

    BOOLEAN done = FALSE,
        isAligned = FALSE,
        isAlignedTemp = FALSE;

    //
    // Loop through the list of sif disks, and for each disk that 
    // hasn't been assigned yet, attempt to find a sif-disk "X" that used
    // to be on the same bus, and has been assigned.  Then, attempt
    // to find other disks on the same physical bus that X is on.
    //
    numDiskRecords = SpAsrGetDiskRecordCount();
    for (sifIndex = 0; sifIndex < numDiskRecords; sifIndex++) {

        //
        // Skip sif-disks that have already been assigned, and
        // disks for which we don't have any bus info in the 
        // sif file
        //
        if ((!Gbl_SifDiskTable[sifIndex]->IsCritical) ||    // not critical
            (!Gbl_SifDiskTable[sifIndex]->PartitionList) || // no partitions
            (Gbl_SifDiskTable[sifIndex]->Assigned) ||       // assigned
            !(Gbl_SifDiskTable[sifIndex]->BusKey)) {        // no bus info

            continue;
        }

        //
        // Find another (sif) disk that used to be on the same (sif) bus, 
        // and has already been assigned to a physical disk.
        //
        targetBusId = 0;
        done = FALSE;
        for (sifIndex2 = 0; (sifIndex2 < numDiskRecords) && (!done); sifIndex2++) {

            if ((Gbl_SifDiskTable[sifIndex2]->BusKey == Gbl_SifDiskTable[sifIndex]->BusKey) // same bus
                && (Gbl_SifDiskTable[sifIndex2]->pSetRecord)) {                             // assigned

                ULONG index = Gbl_SifDiskTable[sifIndex2]->pSetRecord->Index; // set when disk was assigned
                targetBusId = Gbl_PhysicalDiskInfo[index].BusKey; // the physical bus

                //
                // If this physical disk is on an unknown bus, 
                // (target id = sifbuskey = 0) then we want to try and look 
                // for another disk on the same (sif) bus.  Hence done is 
                // TRUE only if targetId != 0
                //
                if (targetBusId) {  
                    done = TRUE;
                }
            }
        
        }   // for sifIndex2


        if (targetBusId) {      // we found another disk on the same sif bus
            //
            // Go through the physical disks on the same bus, and try to
            // find the best fit for this disk.  Best fit is the smallest
            // disk on the bus that's big enough for us.
            //
            currentBest = HardDiskCount;
            for (physicalIndex = 0; physicalIndex < HardDiskCount; physicalIndex++) {

                if ((NULL == Gbl_PartitionSetTable1[physicalIndex]) && // not assigned
                    (Gbl_PhysicalDiskInfo[physicalIndex].BusKey == targetBusId) && // same bus
                    (SpAsrIsThisDiskABetterFit(currentBest, physicalIndex, sifIndex, &isAlignedTemp))) {
                    
                    isAligned = isAlignedTemp;
                    currentBest = physicalIndex;
                }
            }

            if (currentBest < HardDiskCount) {      // we found a match
                //
                // Assign the disks, and extend the last partition if needed.
                //
                SpAsrAssignPartitionSet(currentBest, sifIndex, isAligned);
                SpAsrAutoExtendDiskPartition(currentBest, sifIndex);

                DbgStatusMesg((_asrinfo, "Partition list %lu assigned to disk %lu (assign by bus).\n",
                    sifIndex,
                    currentBest
                    ));
            }
        }
    }   // for sifIndex
}


//
// Attempts to assign remaining sif disks to physical disks that
// are on any bus of the same type (SCSI, IDE, etc) as the sif disk 
// originally was
//
VOID
SpAsrAssignCriticalDisksByBusType()
{
    DWORD sifIndex = 0,
        physicalIndex = 0,
        currentBest = 0,
        numDiskRecords = 0;

    BOOLEAN done = FALSE,
        isAligned = FALSE,
        isAlignedTemp = FALSE;

    numDiskRecords = SpAsrGetDiskRecordCount();
    for (sifIndex = 0; sifIndex < numDiskRecords; sifIndex++) {

        //
        // Skip sif-disks that have already been assigned, and
        // disks for which we don't have any bus info in the 
        // sif file
        //
        if ((!Gbl_SifDiskTable[sifIndex]->IsCritical) ||                // not critical
            (!Gbl_SifDiskTable[sifIndex]->PartitionList) ||             // no partitions
            (Gbl_SifDiskTable[sifIndex]->Assigned) ||                    // assigned
            (BusTypeUnknown == Gbl_SifDiskTable[sifIndex]->BusType)) {  // no bus info

            continue;
        }

        //
        // Go through the physical disks, and try to
        // find the best fit for this disk.  Best fit is the smallest
        // disk on any bus of the same bus type that's big enough for us.
        //
        currentBest = HardDiskCount;
        for (physicalIndex = 0; physicalIndex < HardDiskCount; physicalIndex++) {


            if ((NULL == Gbl_PartitionSetTable1[physicalIndex]) && // not assigned
                (Gbl_PhysicalDiskInfo[physicalIndex].BusType == Gbl_SifDiskTable[sifIndex]->BusType) && // same bus
                (SpAsrIsThisDiskABetterFit(currentBest, physicalIndex, sifIndex, &isAlignedTemp))) {
                
                isAligned = isAlignedTemp;
                currentBest = physicalIndex;
            }
        }

        if (currentBest < HardDiskCount) {      // we found a match
            //
            // Assign the disks, and extend the last partition if needed.
            //
            SpAsrAssignPartitionSet(currentBest, sifIndex, isAligned);
            SpAsrAutoExtendDiskPartition(currentBest, sifIndex);

            DbgStatusMesg((_asrinfo, "Partition list %lu assigned to disk %lu (assign by bus type).\n",
                sifIndex,
                currentBest
                ));
        
            //
            // Now call AssignByBus again
            //
            SpAsrAssignCriticalDisksByBus();

        }
    }   // for sifIndex
}


//
// Okay, so by now we've tried putting disks on the same bus, and
// the same bus type.  For disks that didn't fit using either of those
// rules (or for whom we didn't have any bus info at all), let's just 
// try to fit them where ever possible on the system.
//
BOOL
SpAsrAssignRemainingCriticalDisks(VOID)
{
   DWORD sifIndex = 0,
        physicalIndex = 0,
        currentBest = 0,
        numDiskRecords = 0;

    BOOLEAN done = FALSE,
        isAligned = FALSE,
        isAlignedTemp = FALSE;

    numDiskRecords = SpAsrGetDiskRecordCount();
    for (sifIndex = 0; sifIndex < numDiskRecords; sifIndex++) {
        //
        // Skip sif-disks that have already been assigned
        //
        if ((!Gbl_SifDiskTable[sifIndex]->IsCritical) ||    // not critical
            (!Gbl_SifDiskTable[sifIndex]->PartitionList) || // no partitions
            (Gbl_SifDiskTable[sifIndex]->Assigned)) {       // already assigned

            continue;
        }

        //
        // Go through the physical disks, and try to find the best 
        // fit for this disk.  Best fit is the smallest disk anywhere
        // on the system that's big enough for us.
        //
        currentBest = HardDiskCount;
        for (physicalIndex = 0; physicalIndex < HardDiskCount; physicalIndex++) {

            if ((NULL == Gbl_PartitionSetTable1[physicalIndex]) && // not assigned
                (SpAsrIsThisDiskABetterFit(currentBest, physicalIndex, sifIndex, &isAlignedTemp))) {
                
                isAligned = isAlignedTemp;
                currentBest = physicalIndex;
            }
        }

        if (currentBest < HardDiskCount) {      // we found a match
            //
            // Assign the disks, and extend the last partition if needed.
            //
            SpAsrAssignPartitionSet(currentBest, sifIndex, isAligned);
            SpAsrAutoExtendDiskPartition(currentBest, sifIndex);

            DbgStatusMesg((_asrinfo, "Partition list %lu assigned to disk %lu (assign by size).\n",
                sifIndex,
                currentBest
                ));

            
            SpAsrAssignCriticalDisksByBus();

            SpAsrAssignCriticalDisksByBusType();
        }
    }   // for sifIndex

    //
    // There should be no unassigned critical disks at this point
    //
    for (sifIndex = 0; sifIndex < numDiskRecords; sifIndex++) {
        if ((Gbl_SifDiskTable[sifIndex]->IsCritical) &&
            (Gbl_SifDiskTable[sifIndex]->PartitionList) &&
            (!Gbl_SifDiskTable[sifIndex]->Assigned)) {
            return FALSE;
        }
    }

    return TRUE;
}


VOID
SpAsrInitInternalData(VOID)
{
    SpAsrInitSifDiskTable();
    SpAsrAllocateGblPartitionSetTable();
    SpAsrInitPhysicalDiskInfo();
}


VOID
SpAsrFreeSifData(VOID)
{
    ULONG numDiskRecords;
    ULONG diskIndex;

//    SpAsrUnassignPartitionSets(TRUE);

    numDiskRecords = SpAsrGetDiskRecordCount();
    for (diskIndex = 0; diskIndex < numDiskRecords; diskIndex++) {
        SpAsrFreePartitionDisk(Gbl_SifDiskTable[diskIndex]);
    }        
}

DWORD 
SpAsrGetCurrentSystemDiskNumber(
    IN PWSTR SetupSourceDevicePath, 
    IN PWSTR DirectoryOnSetupSource
    ) 
{

    DWORD physicalIndex = (DWORD) (-1);

    //
    // Get the index of the current (physical) system disk
    //

/*  (guhans, 10.May.2001) Turns out that SpDetermineDisk0 should work on
	IA-64 as well.
  
	if (SpIsArc()) {
        PDISK_REGION systemPartitionArea = NULL;

        systemPartitionArea = SpPtnValidSystemPartitionArc(Gbl_SifHandle,
                                    SetupSourceDevicePath,
                                    DirectoryOnSetupSource,
                                    FALSE
                                    );
        if (systemPartitionArea) {
            physicalIndex =  systemPartitionArea->DiskNumber;
        }


    }
    else {
*/
        physicalIndex = SpDetermineDisk0();
//  }

    return physicalIndex;
}



//
// This goes through the list of physical disks, and checks which disk
// is marked as the system disk.  It then assigns the system-disk in the
// sif file to the current disk.  
//
// If the current system disk isn't "compatible" with the sif-system-disk
// (ie it isn't big enough, it doesn't have the same bytes-per-sector), 
// it's a fatal error.
//
// If the current system disk is recognised as a data disk that used to 
// exist in the sif-file, a warning is displayed to the user 
//
VOID
SpAsrAssignSystemDisk(
    IN DWORD CurrentPhysicalSystemDisk
    ) 
{

    DWORD sifIndex = 0,
        numDiskRecords = 0;

    BOOLEAN isAligned = FALSE;

    numDiskRecords = SpAsrGetMbrDiskRecordCount() + SpAsrGetGptDiskRecordCount();

    //
    // Find the index of the system-disk in the sif 
    //
    for (sifIndex = 0; sifIndex < numDiskRecords; sifIndex++) {
        if (Gbl_SifDiskTable[sifIndex]->ContainsSystemPartition) {
            break;
        }
    }

    if (SpAsrIsThisDiskABetterFit(HardDiskCount, CurrentPhysicalSystemDisk, sifIndex, &isAligned)) {
        SpAsrAssignPartitionSet(CurrentPhysicalSystemDisk, sifIndex, isAligned);

        DbgStatusMesg((_asrinfo, "Partition list %lu assigned to disk %lu (system disk).\n",
            sifIndex,
            CurrentPhysicalSystemDisk
            ));

    }
    else {
        //
        // Fatal Error
        //

        DbgErrorMesg((_asrerr, 
            "Current sytem disk smaller than original system disk.  Curr:%lu  sifIndex:%lu\n" ,
            CurrentPhysicalSystemDisk,
            sifIndex
            ));
        ASSERT(0 && L"Current sytem disk smaller than original system disk");

        SpAsrRaiseFatalError(
            SP_SCRN_DR_SYSTEM_DISK_TOO_SMALL,
            L"The current system disk is too small to hold the partitions"
            );
    }
}


VOID
SpAsrCreatePartitionSets(
    IN PWSTR SetupSourceDevicePath, 
    IN PWSTR DirectoryOnSetupSource
    )
/*++

Description:
    This is the top-level routine from which all of the partition set services
    are called.  When complete, all partitions in the asr.sif file will
    have been assigned to a physical disks attached to the system.

    The list of partitions associated with a physical disk is called a
    partition set.  Partition lists exist in one of two states: Unassigned and
    Assigned.  Physical disks exist in one of two states: Unassigned or
    Assigned.  A disk is assigned if it is a member of a partition set, that is
    the disk is associated with a list of partitions.  Like an assigned disk, a
    partition list is assigned if it is a member of a partition set, i.e., it
    is associated with a physical disk.

    The rules by which partition sets are constructed are executed in the
    following sequence:

        0. Assign-system-disk

  
        1. Assign-by-signature:

        ASR attempts to assign each partition list found in the asr.sif
        file to the physical disk on the system whose disk signature is
        identical to the disk signature specified in the asr.sif file.


        2. Assign-by-bus
        
        3. Assign-by-bus-type

        4. Assign-by-size:

        All remaining unassigned partition lists are assigned to disks on the
        basis of their storage requirements.  The partition list with the
        smallest storage requirement is assigned to the disk with the smallest
        storage capacity where partition list's storage capacity is less than
        or equal to the disk's storage capacity.


Returns:
    None
--*/ 
{

    BOOL    result = TRUE;
    DWORD   systemDiskNumber = (DWORD)(-1);

    //
    // Initialise our global structs.  If there's a fatal error, these
    // won't return
    //
    SpAsrInitInternalData();
    
    systemDiskNumber = SpAsrGetCurrentSystemDiskNumber(SetupSourceDevicePath, DirectoryOnSetupSource);

    SpAsrCheckSifDiskTable(systemDiskNumber);

    if (systemDiskNumber != (DWORD) (-1)) {
        SpAsrAssignSystemDisk(systemDiskNumber);
    }

    //
    // If the signatures of the sif-disks match that of the physical-disks,
    // assign them to each other.
    //
    SpAsrAssignDisksBySignature(systemDiskNumber);

    //
    // If this is a new system disk, we should extend the last partition if 
    // needed.
    //
    if (Gbl_PartitionSetTable1[systemDiskNumber] && 
        Gbl_PartitionSetTable1[systemDiskNumber]->IsReplacementDisk &&
        Gbl_PartitionSetTable1[systemDiskNumber]->pDiskRecord) {
        SpAsrAutoExtendDiskPartition(systemDiskNumber, 
            Gbl_PartitionSetTable1[systemDiskNumber]->pDiskRecord->SifDiskNumber);
    }

    //
    // Attempt to assign the remaining critical disks.  We first attempt 
    // to assign disks to the buses they used to be on, then by bus-types, 
    // and finally just by smallest-fit.
    //
    SpAsrAssignCriticalDisksByBus();

    SpAsrAssignCriticalDisksByBusType();

    result = SpAsrAssignRemainingCriticalDisks();
    
    if (!result) {
         SpAsrRaiseFatalError(
            SP_TEXT_DR_INSUFFICIENT_CAPACITY,
            L"Some critical disks could not be assigned"
            );
    }

    MarkIntactSifDisks();

    SpAsrDbgDumpPartitionLists(1, L"After validate ...");
    Gbl_PartitionSetTable2 = SpAsrCopyPartitionSetTable(Gbl_PartitionSetTable1);
}


// Debug routines
VOID
SpAsrDbgDumpPartitionSet(IN ULONG Disk, PDISK_PARTITION_SET pSet)
{
    PSIF_PARTITION_RECORD pRec;

    if (!pSet->pDiskRecord) {
        
        DbgMesg((_asrinfo,
            "No disk (or partition) records assigned to [%ws] (0x%lx)\n\n",
           (PWSTR) HardDisks[Disk].DevicePath,
           pSet->ActualDiskSignature
           ));

        return;
    }

    if (!pSet->pDiskRecord->PartitionList) {
        DbgMesg((_asrinfo, "Disk record [%ws] ([%ws] (0x%lx)). Not referenced by any partition record.\n\n",
                pSet->pDiskRecord->CurrDiskKey,
                (PWSTR) HardDisks[Disk].DevicePath,
                pSet->ActualDiskSignature));
        return;
    }
    
    // dump the partition table.
    DbgMesg((_asrinfo, "Disk record [%ws] assigned to [%ws] (0x%lx)\n",
            pSet->pDiskRecord->CurrDiskKey,
            (PWSTR) HardDisks[Disk].DevicePath,
            pSet->ActualDiskSignature));

    DbgMesg((_asrinfo, "[%ws] Capacity:%lu Mb. Partitions require:%I64u Mb\n",
            (PWSTR) HardDisks[Disk].DevicePath,
            HardDisks[Disk].DiskSizeMB,
            pSet->pDiskRecord->PartitionList->TotalMbRequired));

    if (pSet->pDiskRecord->ExtendedPartitionStartSector != -1) {
        DbgMesg((_asrinfo, "Extended partition exists. SS:%I64u  SC:%I64u\n",
            pSet->pDiskRecord->ExtendedPartitionStartSector,
            pSet->pDiskRecord->ExtendedPartitionSectorCount));
    }

    DbgMesg((_asrinfo, "Ptns-intact: %s  Ptn-recs: ", pSet->PartitionsIntact? "Yes" : "No" ));

    pRec = pSet->pDiskRecord->PartitionList->First;
    while (pRec) {
        KdPrintEx((_asrinfo, "[%ws] ", pRec->CurrPartKey));
        pRec = pRec->Next;
    }
    
    KdPrintEx((_asrinfo, "\n\n"));
}


VOID
SpAsrDbgDumpPartitionSets(VOID)
{
    ULONG i;

    DbgMesg((_asrinfo, "     ----- Partition Set Tables -----\n\n"));
    
    for (i = 0; i < HardDiskCount; i++) {
        if (!Gbl_PartitionSetTable1[i]) {
            if (DISK_IS_REMOVABLE(i)) {
                DbgMesg((_asrinfo, "- No disk records assigned to removable drive [%ws].\n",
                        (PWSTR) HardDisks[i].DevicePath));
            } 
            else {
                DbgMesg((_asrinfo, "- No disk records assigned to %ws (0x%lx).\n",
                        (PWSTR) HardDisks[i].DevicePath,
                        SpAsrGetActualDiskSignature(i)));
            }
        }
        else {
            SpAsrDbgDumpPartitionSet(i, Gbl_PartitionSetTable1[i]);
        }
    }  
    DbgMesg((_asrinfo, "----- End of Partition Set Tables -----\n\n"));

}
                                    
VOID
SpAsrDbgDumpADisk(PSIF_DISK_RECORD pDiskRec)
{
    PSIF_PARTITION_RECORD pPtnRec;
    PSIF_PARTITION_RECORD_LIST pList;

    pList = pDiskRec->PartitionList;

    DbgMesg((_asrinfo, "DiskRec %ws. sig:0x%x%s%s\n", 
                      pDiskRec->CurrDiskKey,
                      pDiskRec->SifDiskMbrSignature,
                      pDiskRec->ContainsNtPartition ? " [Boot]" : "",
                      pDiskRec->ContainsSystemPartition ? " [Sys]" : ""));

    if (pDiskRec->Assigned) {
        DbgMesg((_asrinfo, "Assigned-to:0x%x  [%sintact]  [%s]  size:%I64u MB\n",
                    pDiskRec->pSetRecord->ActualDiskSignature,
                    pDiskRec->pSetRecord->PartitionsIntact ? "" : "not ",
                    pDiskRec->pSetRecord->IsReplacementDisk ? "replacement" : "original",
                    pDiskRec->pSetRecord->ActualDiskSizeMB));
    }

    if (!pList) {
        DbgMesg((_asrinfo, "No partition records.\n\n"));
        return;
    }

    DbgMesg((_asrinfo, "Partition records. count:%lu,  totalMbRequired:%I64u\n",
                      pList->ElementCount, pList->TotalMbRequired));

    pPtnRec = pList->First;
    while (pPtnRec) {

        DbgMesg((_asrinfo, "Ptn %2ws. sz:%4I64u SS:%8I64u SC:%8I64u type:%s FS:0x%-2x %s %s\n",
                pPtnRec->CurrPartKey,
                pPtnRec->SizeMB,
                pPtnRec->StartSector,
                pPtnRec->SectorCount,
                pPtnRec->IsPrimaryRecord ? "Pri" : 
                  pPtnRec->IsContainerRecord ? "Con" :
                    pPtnRec->IsLogicalDiskRecord ? "Log" :
                        pPtnRec->IsDescriptorRecord ? "Des" :"ERR",
                pPtnRec->PartitionType,
                SpAsrIsBootPartitionRecord(pPtnRec->PartitionFlag) ? "boot" : "",
                SpAsrIsSystemPartitionRecord(pPtnRec->PartitionFlag) ? "sys" : ""));

        pPtnRec = pPtnRec->Next;
    }
    DbgMesg((_asrinfo, "\n"));
}

VOID
SpAsrDbgDumpPartitionLists(BYTE DataOption, PWSTR Msg)
{
    ULONG DiskRecords;
    ULONG DiskIndex;
    ULONG SetIndex;
    PSIF_DISK_RECORD pDiskRec;
    PDISK_PARTITION_SET pSetRec;

    DbgMesg((_asrinfo, "     ----- Partition Lists: [%ws] -----\n\n", Msg));

    if (DataOption == 1) {
        DiskRecords = SpAsrGetDiskRecordCount();
    
        for (DiskIndex = 0; DiskIndex < DiskRecords; DiskIndex++) {
            pDiskRec = Gbl_SifDiskTable[DiskIndex];
            if (pDiskRec != NULL) {
                SpAsrDbgDumpADisk(pDiskRec);
            }
        }
    }
    else if (DataOption == 2) {
        ULONG SetRecords = sizeof(Gbl_PartitionSetTable2) / sizeof(PDISK_PARTITION_SET);        

        for (SetIndex = 0; SetIndex < HardDiskCount; SetIndex++) {
            pSetRec = Gbl_PartitionSetTable2[SetIndex];

            if (pSetRec != NULL && pSetRec->pDiskRecord != NULL) {
                SpAsrDbgDumpADisk(pSetRec->pDiskRecord);
            }
        }
    }

    DbgMesg((_asrinfo, "----- End of Partition Lists: [%ws] -----\n\n", Msg));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spdr.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdr.h

Abstract:

    Header file for Automated System Recovery functions in text-mode setup.

Author:

    Michael Peterson (v-michpe) 13-May-1997
    Guhan Suriyanarayanan (guhans) 21-Aug-1999

Revision History:
    13-May-1997 v-michpe Created file
    21-Aug-1999 guhans   Clean-up

--*/
#ifndef _SPDR_DEFN_
#define _SPDR_DEFN_

typedef enum _ASRMODE {
    ASRMODE_NONE = 0,
    ASRMODE_NORMAL,
    ASRMODE_QUICKTEST_TEXT,
    ASRMODE_QUICKTEST_FULL
} ASRMODE;


//
// Returns the current ASR (Automated System Recovery) mode
//
ASRMODE
SpAsrGetAsrMode(VOID);

//
// Sets the current ASR mode
//
ASRMODE
SpAsrSetAsrMode(
    IN CONST ASRMODE NewAsrMode
    );

//
// Returns TRUE if we're in any of the ASR modes other than ASRMODE_NONE.
//
BOOLEAN
SpDrEnabled(VOID);

//
// Returns TRUE if we're in any of the ASR QuickTest modes.
//
BOOLEAN
SpAsrIsQuickTest(VOID);

//
// Returns TRUE if the user is doing a fast repair
//
BOOLEAN
SpDrIsRepairFast(VOID);

//
// Set or reset the fast-repair flag
//
BOOLEAN
SpDrSetRepairFast(BOOLEAN Value);


//
// Returns the Boot directory
//
PWSTR
SpDrGetNtDirectory(VOID);

PWSTR
SpDrGetNtErDirectory(VOID);


//
// Copies the recovery device drivers (e.g., tape drivers) specified
// in the asr.sif file.  If no device drivers are specified, nothing gets
// copied.  Source media can be Floppy or CDROM.
//
// Also copies asr.sif from the ASR floppy to the %windir%\repair 
// directory.
//
NTSTATUS
SpDrCopyFiles(VOID);


PWSTR
SpDrGetSystemPartitionDirectory(VOID);

//
// Cleanup.  This function removes the "InProgress" flag.
//
VOID
SpDrCleanup(VOID);

//
// This is the main ASR / ER entry point.  
// 
//
NTSTATUS
SpDrPtPrepareDisks(
    IN PVOID SifHandle,
    OUT PDISK_REGION *NtPartitionRegion,
    OUT PDISK_REGION *LoaderPartitionRegion,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource,
    OUT BOOLEAN *RepairedNt);


BOOLEAN
SpDoRepair(
    IN PVOID SifHandle,
    IN PWSTR Local_SetupSourceDevicePath,
    IN PWSTR Local_DirectoryOnSetupSource,
    IN PWSTR AutoSourceDevicePath,
    IN PWSTR AutoDirectoryOnSetupSource,
    IN PWSTR RepairPath,
    IN PULONG RepairOptions
    );



NTSTATUS
SpDrSetEnvironmentVariables(HANDLE *HiveRootKeys);

extern BOOLEAN DisableER;

__inline
BOOLEAN
SpIsERDisabled(
    VOID
    ) 
{    
    return DisableER;
}    

__inline
VOID
SpSetERDisabled(
    IN BOOLEAN Disable
    )
{
    DisableER = Disable;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spdrsif.c ===
/*++
Copyright (c) 1993 Microsoft Corporation

Module Name:
    spdrsif.c

Abstract:
    Contains all routines involved in reading attributes from the asr.sif
    file and constructing partition records.

Terminology

Restrictions:

Revision History:
    Initial Code                Michael Peterson (v-michpe)     21.Aug.1998
    Code cleanup and changes    Guhan Suriyanarayanan (guhans)  21.Aug.1999

--*/
#include "spprecmp.h"
#pragma hdrstop

// Module identification for debug traces
#define THIS_MODULE L" spdrsif.c"
#define THIS_MODULE_CODE L"S"
#define ASR_NULL_STRING (L"")

//
// Section names and other data used for retrieving information from the
// asr.sif file
//
const PWSTR SIF_ASR_VERSION_SECTION = L"VERSION";
const PWSTR SIF_ASR_SYSTEMS_SECTION = L"SYSTEMS";
const PWSTR SIF_ASRFLAGS_SECTION    = L"ASRFLAGS";
const PWSTR SIF_ASR_BUSES_SECTION = L"BUSES";
const PWSTR SIF_ASR_PARTITIONS_SECTION = L"PARTITIONS";
const PWSTR SIF_ASR_DISKS_SECTION = L"DISKS";
const PWSTR SIF_ASR_MBR_DISKS_SECTION = L"DISKS.MBR";
const PWSTR SIF_ASR_GPT_DISKS_SECTION = L"DISKS.GPT";
const PWSTR SIF_ASR_MBR_PARTITIONS_SECTION = L"PARTITIONS.MBR";
const PWSTR SIF_ASR_GPT_PARTITIONS_SECTION = L"PARTITIONS.GPT";
const PWSTR SIF_ASR_INSTALLFILES_SECTION = L"INSTALLFILES";

const PWSTR SIF_ASR_SIGNATURE_KEY = L"Signature";
const PWSTR SIF_ASR_PROVIDER_KEY = L"Provider";
const PWSTR SIF_ASR_SIFVERSION_KEY = L"ASR-Version";
const PWSTR ASR_SIF_RECOGNISED_SIGNATURE = L"$Windows NT$";
const PWSTR ASR_SIF_RECOGNISED_VERSION = L"1.";

const PWSTR ASR_FLOPPY_DEVICE_ALIAS     = L"%FLOPPY%";
const PWSTR ASR_CDROM_DEVICE_ALIAS      = L"%CDROM%";
const PWSTR ASR_SOURCE_DEVICE_ALIAS     = L"%SETUPSOURCE%";

const PWSTR ASR_SIF_TEMP_DIRECTORY_ALIAS   = L"%TEMP%\\";
const PWSTR ASR_SIF_TMP_DIRECTORY_ALIAS    = L"%TMP%\\";
const PWSTR ASR_SIF_SYSTEM_ROOT_ALIAS      = L"%SystemRoot%\\";

const PWSTR ASR_SIF_SILENT_REPARTITION_VALUE = L"SilentRepartition";

extern const PWSTR ASR_FLOPPY0_DEVICE_PATH;
extern const PWSTR ASR_CDROM0_DEVICE_PATH;
extern const PWSTR ASR_TEMP_DIRECTORY_PATH;
extern ULONG SuiteType;


// Indices for the [SYSTEMS] section.
typedef enum _SIF_SYSTEM_FIELD_INDEX {
    SIF_SYSTEM_NAME = 0,                    // Computer name    (not used in textmode ASR)
    SIF_SYSTEM_PLATFORM,                    // amd64, x86 or ia64
    SIF_SYSTEM_OSVERSION,                   // Windows version
    SIF_SYSTEM_NT_DIRECTORY_NAME,           // Windows directory
    SIF_SYSTEM_PARTITION_AUTOEXTEND_OPTION, // [optional]

    SIF_SYSTEM_PRODUCT_SUITE,               // SKU information

    //
    // Time Zone Information (not used in textmode ASR)
    //
    SIF_SYSTEM_TIMEZONE_INFORMATION,
    SIF_SYSTEM_TIMEZONE_STANDARD_NAME,
    SIF_SYSTEM_TIMEZONE_DAYLIGHT_NAME,

    SIF_SYSTEM_NUMFIELDS                // Must always be last
} SIF_SYSTEM_FIELD_INDEX;

// Indices for the [ASRFLAGS] section.
typedef enum _SIF_ASRFLAGS_FIELD_INDEX {
    SIF_ASRFLAGS_SILENT_REPARTITION_OPTION = 0,
    SIF_ASRFLAGS_NUMFIELDS                // Must always be last
} SIF_ASRFLAGS_FIELD_INDEX;


// Indices for the [BUSES] section.
typedef enum _SIF_BUSES_FIELD_INDEX {
    SIF_BUSES_SYSTEMKEY = 0,
    SIF_BUSES_BUS_TYPE,
    SIF_BUSES_NUMFIELDS                // Must always be last
} SIF_BUSES_FIELD_INDEX;


//
// Indices for the [DISKS.MBR] section.
//
// [DISKS.MBR] format
//
// disk-key = 0.system-key, 1.bus-key, 2.critical-flag,
//              3.disk-signature, 4.bytes-per-sector, 5.total-sectors
//
typedef enum _SIF_MBR_DISK_FIELD_INDEX {
    SIF_MBR_DISK_SYSTEMKEY = 0,
    SIF_MBR_DISK_BUSKEY,
    SIF_MBR_DISK_CRITICAL_FLAG,
    SIF_MBR_DISK_SIGNATURE,
    SIF_MBR_DISK_BYTES_PER_SECTOR,
    SIF_MBR_DISK_SECTORS_PER_TRACK,
    SIF_MBR_DISK_TRACKS_PER_CYLINDER,
    SIF_MBR_DISK_TOTALSECTORS,
    SIF_MBR_DISK_NUMFIELDS                // Must always be last
} SIF_MBR_DISK_FIELD_INDEX;


//
// Indices for the [DISKS.GPT] section.
//
// [DISKS.GPT] format
//
// disk-key = 0.system-key, 1.bus-key, 2.critical-flag, 3.disk-id,
//              4.min-partition-count, 5.bytes-per-sector, 6.total-sectors
//
typedef enum _SIF_GPT_DISK_FIELD_INDEX {
    SIF_GPT_DISK_SYSTEMKEY = 0,
    SIF_GPT_DISK_BUSKEY,
    SIF_GPT_DISK_CRITICAL_FLAG,
    SIF_GPT_DISK_DISK_ID,
    SIF_GPT_DISK_MAX_PTN_COUNT,
    SIF_GPT_DISK_BYTES_PER_SECTOR,
    SIF_GPT_DISK_SECTORS_PER_TRACK,
    SIF_GPT_DISK_TRACKS_PER_CYLINDER,
    SIF_GPT_DISK_TOTALSECTORS,
    SIF_GPT_DISK_NUMFIELDS                // Must always be last
} SIF_GPT_DISK_FIELD_INDEX;


//
// Indices for the [PARTITIONS.MBR] section.
//
// [PARTITIONS.MBR]
//
// partition-key = 0.disk-key, 1.slot-index, 2.boot-sys-flag,
//                 3."volume-guid", 4.active-flag, 5.partition-type,
//                 6.file-system-type, 7.start-sector, 8.sector-count,
//                 9.fs-cluster-size
//
typedef enum _SIF_MBR_PARTITION_FIELD_INDEX {
    SIF_MBR_PARTITION_DISKKEY = 0,
    SIF_MBR_PARTITION_SLOT_INDEX,
    SIF_MBR_PARTITION_SYSBOOT_FLAGS,
    SIF_MBR_PARTITION_VOLUME_GUID,      //optional
    SIF_MBR_PARTITION_ACTIVE_FLAG,
    SIF_MBR_PARTITION_PTN_TYPE,
    SIF_MBR_PARTITION_FS_TYPE,
    SIF_MBR_PARTITION_STARTSECTOR,
    SIF_MBR_PARTITION_SECTORCOUNT,
    SIF_MBR_PARTITION_CLUSTER_SIZE,
    SIF_MBR_PARTITION_NUMFIELDS                // Must always be last
} SIF_MBR_PARTITION_FIELD_INDEX;


//
// Indices for the [PARTITIONS.GPT] section.
//
// [PARTITIONS.GPT]
//
// partition-key = 0.disk-key, 1.slot-index, 2.boot-sys-flag,
//                 3."volume-guid", 4."partition-type-guid", 5."partition-id-guid"
//                 6.gpt-attributes, 7."partition-name", 8.file-system-type,
//                 9.start-sector, 10.sector-count, 11.fs-cluster-size
//
typedef enum _SIF_GPT_PARTITION_FIELD_INDEX {
    SIF_GPT_PARTITION_DISKKEY = 0,
    SIF_GPT_PARTITION_SLOT_INDEX,
    SIF_GPT_PARTITION_SYSBOOT_FLAGS,
    SIF_GPT_PARTITION_VOLUME_GUID,      //optional
    SIF_GPT_PARTITION_TYPE_GUID,
    SIF_GPT_PARTITION_ID_GUID,
    SIF_GPT_PARTITION_GPT_ATTRIBUTES,
    SIF_GPT_PARTITION_NAME,
    SIF_GPT_PARTITION_FS_TYPE,
    SIF_GPT_PARTITION_STARTSECTOR,
    SIF_GPT_PARTITION_SECTORCOUNT,
    SIF_GPT_PARTITION_CLUSTER_SIZE,
    SIF_GPT_PARTITION_NUMFIELDS                // Must always be last
} SIF_GPT_PARTITION_FIELD_INDEX;


// Indices for the [INSTALLFILES] section.
typedef enum _SIF_INSTALLFILE_FIELD_INDEX {
    SIF_INSTALLFILE_SYSTEM_KEY = 0,
    SIF_INSTALLFILE_SOURCE_MEDIA_LABEL,
    SIF_INSTALLFILE_SOURCE_DEVICE,
    SIF_INSTALLFILE_SOURCE_FILE_PATH,
    SIF_INSTALLFILE_DESTFILE,
    SIF_INSTALLFILE_VENDORSTRING,
    SIF_INSTALLFILE_FLAGS,
    SIF_INSTALLFILE_NUMFIELDS        // Must always be last
} SIF_INSTALLFILE_FIELD_INDEX;

// Global
PVOID           Gbl_HandleToDrStateFile;
extern PWSTR    Gbl_SifSourcePath;


// Forward Declarations
VOID
SpAsrDbgDumpInstallFileList(IN PSIF_INSTALLFILE_LIST pList);

PSIF_PARTITION_RECORD_LIST
SpAsrCopyPartitionRecordList(PSIF_PARTITION_RECORD_LIST pSrcList);


///////////////////////////////
// Generic functions for all sections
//

//
// The string returned should not be freed, since it's part of Setup's internal sif
// data structure!
//
PWSTR
SpAsrGetSifDataBySectionAndKey(
    IN const PWSTR Section,
    IN const PWSTR Key,
    IN const ULONG Value,
    IN const BOOLEAN NonNullRequired
    )                               // does not return on error if NonNullRequired is TRUE
{
    PWSTR data = NULL;
    ASSERT(Section && Key);  // debug

    data = SpGetSectionKeyIndex(
        Gbl_HandleToDrStateFile,
        Section,
        Key,
        Value
        );

    if (NonNullRequired) {
        if (!data || !wcscmp(data, ASR_NULL_STRING)) {
            DbgFatalMesg((_asrerr, "SpAsrGetSifDataBySectionAndKey. Data is "
                "NULL. Section:[%ws], Key:[%ws], Value:[%lu]\n",
                Section, Key, Value));
            swprintf(TemporaryBuffer, L"%lu value not specified in %ws "
                L"record %ws", Value, Section, Key);
            SpAsrRaiseFatalErrorWs(SP_SCRN_DR_SIF_BAD_RECORD,
                TemporaryBuffer, Section);
            // does not return
        }
    }

    return data;
}


ULONG
SpAsrGetRecordCount(
    IN PWSTR Section,
    IN ULONG MinimumValid
    )
{
    ULONG count;
    ASSERT(Section);

    count = SpCountLinesInSection(Gbl_HandleToDrStateFile, Section);

    if (count < MinimumValid) {
        DbgFatalMesg((_asrerr, "SpAsrGetRecordCount. No records in [%ws] section.\n",
                             Section));

        swprintf(TemporaryBuffer, L"No records in section");

        SpAsrRaiseFatalErrorWs(SP_SCRN_DR_SIF_BAD_RECORD,
                           TemporaryBuffer,
                           Section);
        // does not return
    }

    return count;
}


PWSTR
SpAsrGetSifKeyBySection(
    IN PWSTR Section,
    IN ULONG Index
    )                           // does not return on error
{
    PWSTR key;
    ULONG count = SpAsrGetRecordCount(Section, 1);

    // is index too big?
    if (Index > count) {
        DbgFatalMesg((_asrerr,
            "SpAsrGetSifKeyBySection. Section [%ws]. Index (%lu) greater than NumRecords (%lu)\n",
            Section,
            Index,
            count
            ));

        swprintf(TemporaryBuffer, L"Index too large: Key not found.");

        SpAsrRaiseFatalErrorWs(SP_SCRN_DR_SIF_BAD_RECORD,
            TemporaryBuffer,
            Section
            );
        // does not return
    }

    key = SpGetKeyName(Gbl_HandleToDrStateFile, Section, Index);

    if (!key || !wcscmp(key, ASR_NULL_STRING)) {

        DbgFatalMesg((_asrerr,
            "SpAsrGetSifKeyBySection. SpGetKeyName failed in Section:[%ws] for Index:%lu.\n",
            Section,
            Index
            ));

        swprintf(TemporaryBuffer, L"%ws key not found for record %lu", Section, Index + 1);

        SpAsrRaiseFatalErrorWs(SP_SCRN_DR_SIF_BAD_RECORD,
            TemporaryBuffer,
            Section
            );
        // does not return
     }

    return key;
}


///////////////////////////////
// [SYSTEMS] section functions
//

#define ASR_PRODUCTSUITES_TO_MATCH ((  VER_SUITE_SMALLBUSINESS               \
                                 | VER_SUITE_ENTERPRISE                  \
                                 | VER_SUITE_BACKOFFICE                  \
                                 | VER_SUITE_COMMUNICATIONS              \
                                 | VER_SUITE_SMALLBUSINESS_RESTRICTED    \
                                 | VER_SUITE_EMBEDDEDNT                  \
                                 | VER_SUITE_DATACENTER                  \
                                 | VER_SUITE_PERSONAL))

//
// This checks to make sure that Windows media being used for the recovery
// is the same SKU as that in asr.sif  (so the user isn't trying to recover
// an ADS installation with a PRO CD, for instance), and that the platform
// of the target machine is the same as that in asr.sif  (so the user isn't
// trying to recover an ia64 with an amd64 or x86 asr.sif, for instance)
//
VOID
SpAsrCheckSystemCompatibility()
{
    PWSTR sifPlatform = NULL;
    WCHAR currentPlatform[10];
    DWORD suiteInSif = 0, currentSuite = 0, productInSif = 0;
    BOOLEAN validSKU = TRUE;

    sifPlatform = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_SYSTEMS_SECTION,
        ASR_SIF_SYSTEM_KEY,
        SIF_SYSTEM_PLATFORM,
        TRUE
        );

    wcscpy(currentPlatform, L"unknown");
#if defined(_X86_)
    wcscpy(currentPlatform, L"x86");
#elif defined(_AMD64_)
    wcscpy(currentPlatform, L"amd64");
#elif defined(_IA64_)
    wcscpy(currentPlatform, L"ia64");
#endif

    if (_wcsicmp(sifPlatform, currentPlatform)) {

        DbgFatalMesg((_asrerr,
            "asr.sif SYSTEM section. Invalid platform [%ws] (does not match the current platform)\n",
            sifPlatform
            ));

        SpAsrRaiseFatalError(
            SP_SCRN_DR_INCOMPATIBLE_MEDIA,
            L"Invalid platform"
            );
    }

    suiteInSif = STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_SYSTEMS_SECTION,
        ASR_SIF_SYSTEM_KEY,
        SIF_SYSTEM_PRODUCT_SUITE,
        TRUE
        ));

    productInSif = HIWORD(suiteInSif);
    suiteInSif = LOWORD(suiteInSif) & ASR_PRODUCTSUITES_TO_MATCH;

    if (suiteInSif) {
        if (!SuiteType) {
            //
            // SuiteType is set to 0 for PRO and SRV, and so cannot directly be
            // used in SpIsProductSuite().  These are the values that SuiteType
            // seems to be set to:
            //
            // PER  0x200   VER_SUITE_PERSONAL
            // BLA  0x400   VER_SUITE_BLADE
            // PRO  0x0	
            // SRV  0x0
            // ADS  0x2	    VER_SUITE_ENTERPRISE
            // DTC  0x82    VER_SUITE_DATACENTER | VER_SUITE_ENTERPRISE
            //
            //
            //
            // Not sure of the reasoning behind this, but let's make use of this
            // fact (cf SpGetHeaderTextId)
            //

            //
            // Since SuiteType is 0, this must be PRO or SRV.  This can be determined
            // by checking the global AdvancedServer
            //
            validSKU = (AdvancedServer ?
                (
                 ((productInSif == VER_NT_SERVER) ||             // must be SRV
                 (productInSif == VER_NT_DOMAIN_CONTROLLER)) &&  //
                 !(suiteInSif | VER_SUITE_ENTERPRISE)            // and not ADS or DTC
                )
                :
                ( (productInSif == VER_NT_WORKSTATION) &&       // must be PRO
                  !(suiteInSif | VER_SUITE_PERSONAL)            // and not PER
                )
            );
        }
        else if (
            ((productInSif != VER_NT_SERVER) && (productInSif != VER_NT_DOMAIN_CONTROLLER)) ||
            !SpIsProductSuite(suiteInSif)
            ) {
            validSKU = FALSE;
        }
    }

    if (!validSKU) {
        DbgFatalMesg((_asrerr,
            "asr.sif SYSTEM Section. Invalid suite 0x%08x (does not match the current media).\n",
            suiteInSif
            ));

        SpAsrRaiseFatalError(
            SP_SCRN_DR_INCOMPATIBLE_MEDIA,
            L"Invalid version"
            );
    }
}


ULONG
SpAsrGetSystemRecordCount(VOID)   // does not return on error
{
    return SpAsrGetRecordCount(SIF_ASR_SYSTEMS_SECTION, 1);
}


PWSTR
SpAsrGetNtDirectoryPathBySystemKey(IN PWSTR SystemKey)        // does not return on error
{
    return SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_SYSTEMS_SECTION,
        SystemKey,
        SIF_SYSTEM_NT_DIRECTORY_NAME,
        TRUE
        );
}


BOOLEAN
SpAsrGetAutoExtend(IN PWSTR SystemKey)
{
    PWSTR value = NULL;
    ASSERT(SystemKey);

    value = SpGetSectionKeyIndex(
        Gbl_HandleToDrStateFile,
        SIF_ASR_SYSTEMS_SECTION,
        SystemKey,
        SIF_SYSTEM_PARTITION_AUTOEXTEND_OPTION
        );

    if (!value || !wcscmp(value, ASR_NULL_STRING)) {
        DbgErrorMesg((_asrwarn, "Auto-extend not specified, assuming Enabled\n"));
        return TRUE;
    }
    else {
        return (BOOLEAN) STRING_TO_LONG(value);
    }
}


///////////////////////////////
// [ASRFLAGS] section functions
//

BOOLEAN
SpAsrGetSilentRepartitionFlag(IN PWSTR SystemKey)
{
    PWSTR value = NULL;
    ASSERT(SystemKey);

    value = SpGetSectionKeyIndex(
        Gbl_HandleToDrStateFile,
        SIF_ASRFLAGS_SECTION,
        SystemKey,
        SIF_ASRFLAGS_SILENT_REPARTITION_OPTION
        );

    if (value && !_wcsicmp(value, ASR_SIF_SILENT_REPARTITION_VALUE)) {
        DbgErrorMesg((_asrwarn, "SilentRepartition flag is set; will NOT prompt before repartitioning disks!\n"));
        return TRUE;
    }

    DbgStatusMesg((_asrinfo, "SilentRepartition flag not set; will prompt user before repartitioning disks\n"));
    return FALSE;
}


///////////////////////////////
// [VERSION] section functions
//

VOID
SpAsrCheckAsrStateFileVersion()
{
    PWSTR signature = NULL,
        provider = NULL,
        sifVersion = NULL;

    signature = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_VERSION_SECTION,
        SIF_ASR_SIGNATURE_KEY,
        0,
        TRUE
        );

    provider = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_VERSION_SECTION,
        SIF_ASR_PROVIDER_KEY,
        0,
        FALSE
        );     // ProviderName is optional

    sifVersion = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_VERSION_SECTION,
        SIF_ASR_SIFVERSION_KEY,
        0,
        TRUE
        );

    DbgStatusMesg((_asrinfo,
        "Asr Sif Version. sig:[%ws], provider:[%ws], sifVer:[%ws]\n",
        signature,
        provider ? provider : L"",
        sifVersion
        ));

    if (_wcsicmp(signature, ASR_SIF_RECOGNISED_SIGNATURE)) {

        DbgFatalMesg((_asrerr,
            "asr.sif VERSION section. Invalid signature [%ws] (it MUST be $Windows NT$).\n",
            signature
            ));

        SpAsrRaiseFatalError(
            SP_TEXT_DR_STATEFILE_ERROR,
            L"Invalid signature"
            );
    }

    if (_wcsnicmp(sifVersion, ASR_SIF_RECOGNISED_VERSION, wcslen(ASR_SIF_RECOGNISED_VERSION))) {

        DbgFatalMesg((_asrerr,
            "asr.sif VERSION Section. Invalid asr.sif version [%ws] (it MUST be 1.x).\n",
            sifVersion
            ));

        SpAsrRaiseFatalError(
            SP_TEXT_DR_STATEFILE_ERROR,
            L"Invalid version"
            );
    }

    SpAsrCheckSystemCompatibility();
}


/////////////////////////////////
// InstallFiles section functions
//

ULONG
SpAsrGetInstallFilesRecordCount(VOID)         // does not return on error
{
    return SpAsrGetRecordCount(SIF_ASR_INSTALLFILES_SECTION, 0);
}


PSIF_INSTALLFILE_RECORD
SpAsrGetInstallFileRecord(IN PWSTR InstallFileKey, IN PCWSTR SetupSourceDevicePath)
{
    PSIF_INSTALLFILE_RECORD pRec = NULL;
    PWSTR   tempStr = NULL;
    BOOL    isValid = FALSE;

    if (!InstallFileKey) {
        DbgFatalMesg((_asrerr, "SpAsrGetInstallFileRecord. InstallFileKey is NULL\n"));

        SpAsrRaiseFatalErrorWs(
            SP_SCRN_DR_SIF_BAD_RECORD,
            L"InstallFileKey is NULL",
            SIF_ASR_INSTALLFILES_SECTION
            );
    }

    pRec = SpAsrMemAlloc(sizeof(SIF_INSTALLFILE_RECORD), TRUE);

    pRec->SystemKey = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_INSTALLFILES_SECTION,
        InstallFileKey,
        SIF_INSTALLFILE_SYSTEM_KEY,
        TRUE
        );

    pRec->CurrKey = InstallFileKey;

    pRec->SourceMediaExternalLabel = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_INSTALLFILES_SECTION,
        InstallFileKey,
        SIF_INSTALLFILE_SOURCE_MEDIA_LABEL,
        TRUE
        );


    tempStr = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_INSTALLFILES_SECTION,
        InstallFileKey,
        SIF_INSTALLFILE_SOURCE_DEVICE,
        TRUE
        );

    //
    // Check if the device is specified as %FLOPPY%, %CDROM% or %SETUPSOURCE%,
    // and use the full path (\device\floppy0 or \device\CdRom0 or 
    // SetupSourceDevicePath) if so.
    //
    if (!_wcsicmp(tempStr, ASR_FLOPPY_DEVICE_ALIAS)) {
        pRec->DiskDeviceName = SpDupStringW(ASR_FLOPPY0_DEVICE_PATH);
    }
    else if (!_wcsicmp(tempStr, ASR_CDROM_DEVICE_ALIAS)) {
        pRec->DiskDeviceName = SpDupStringW(ASR_CDROM0_DEVICE_PATH);
    }
    else if (!_wcsicmp(tempStr, ASR_SOURCE_DEVICE_ALIAS) && SetupSourceDevicePath) {
        pRec->DiskDeviceName = SpDupStringW(SetupSourceDevicePath);
    }
    else {
        //
        // It wasn't any of the aliases--he's allowed to specify
        // the full device path, so we use it as is.
        //
        pRec->DiskDeviceName = SpDupStringW(tempStr);
    }

    pRec->SourceFilePath = (PWSTR) SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_INSTALLFILES_SECTION,
        InstallFileKey,
        SIF_INSTALLFILE_SOURCE_FILE_PATH,
        TRUE
        );

    tempStr = (PWSTR) SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_INSTALLFILES_SECTION,
        InstallFileKey,
        SIF_INSTALLFILE_DESTFILE,
        TRUE
        );

    //
    //  Set the CopyToDirectory based on the tempStr path
    //
    if (!_wcsnicmp(tempStr, ASR_SIF_TEMP_DIRECTORY_ALIAS, wcslen(ASR_SIF_TEMP_DIRECTORY_ALIAS))) {
        //
        // Begins is %TEMP%\
        //
        pRec->CopyToDirectory = _Temp;
        pRec->DestinationFilePath = SpDupStringW((PWSTR)(&tempStr[wcslen(ASR_SIF_TEMP_DIRECTORY_ALIAS)]));
    }
    else if (!_wcsnicmp(tempStr, ASR_SIF_TMP_DIRECTORY_ALIAS, wcslen(ASR_SIF_TMP_DIRECTORY_ALIAS))) {
        //
        // Begins is %TMP%\
        //
        pRec->CopyToDirectory = _Tmp;
        pRec->DestinationFilePath = SpDupStringW((PWSTR)(&tempStr[wcslen(ASR_SIF_TMP_DIRECTORY_ALIAS)]));
    }
    else if (!_wcsnicmp(tempStr, ASR_SIF_SYSTEM_ROOT_ALIAS, wcslen(ASR_SIF_SYSTEM_ROOT_ALIAS))) {
        //
        // Begins is %SYSTEMROOT%\
        //
        pRec->CopyToDirectory = _SystemRoot;
        pRec->DestinationFilePath = SpDupStringW((PWSTR)(&tempStr[wcslen(ASR_SIF_SYSTEM_ROOT_ALIAS)]));
    }
    else {
        //
        // Not specified, or unknown: use default.
        //
        pRec->CopyToDirectory = _Default;
        pRec->DestinationFilePath = SpDupStringW(tempStr);
    }

    pRec->VendorString = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_INSTALLFILES_SECTION,
        InstallFileKey,
        SIF_INSTALLFILE_VENDORSTRING,
        TRUE
        );

    tempStr = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_INSTALLFILES_SECTION,
        InstallFileKey,
        SIF_INSTALLFILE_FLAGS,
        FALSE
        );
    if (tempStr) {
        pRec->Flags = STRING_TO_HEX(tempStr);
    }

    return pRec;
}


VOID
SpAsrInsertInstallFileRecord(
    IN SIF_INSTALLFILE_LIST *InstallFileList,
    IN PSIF_INSTALLFILE_RECORD pRec
    )
{
    pRec->Next = InstallFileList->First;
    InstallFileList->First = pRec;
    InstallFileList->Count += 1;
}


PSIF_INSTALLFILE_RECORD
SpAsrRemoveInstallFileRecord(IN SIF_INSTALLFILE_LIST *InstallFileList)
{
    PSIF_INSTALLFILE_RECORD pRec = NULL;

    if (InstallFileList->Count > 0) {
        pRec = InstallFileList->First;
        InstallFileList->First = pRec->Next;
        InstallFileList->Count -= 1;
    }

    return pRec;
}


VOID
SpAsrDeleteInstallFileRecord(
    IN OUT PSIF_INSTALLFILE_RECORD pRec
    )
{
    //
    // Free the memory we allocated.  The other fields are pointers to
    // setup's internal inf data structure, we shouldn't free those
    // else they'd get freed twice.
    //
    if (pRec->DiskDeviceName) {
        SpMemFree(pRec->DiskDeviceName);
        pRec->DiskDeviceName = NULL;
    }

    if (pRec->DestinationFilePath) {
        SpMemFree(pRec->DestinationFilePath);
        pRec->DestinationFilePath = NULL;
    }

    SpMemFree(pRec);
    pRec = NULL;
}


PSIF_INSTALLFILE_LIST
SpAsrInit3rdPartyFileList(IN PCWSTR SetupSourceDevicePath)
{
    PSIF_INSTALLFILE_RECORD pRec;
    PSIF_INSTALLFILE_LIST pList = NULL;
    ULONG count, index;

    if ((count = SpAsrGetInstallFilesRecordCount()) == 0) {
        return NULL;
    }

    pList = SpAsrMemAlloc(sizeof(SIF_INSTALLFILE_LIST), TRUE);

    for (index = 0; index < count; index++) {

        pRec = SpAsrGetInstallFileRecord(SpAsrGetSifKeyBySection(SIF_ASR_INSTALLFILES_SECTION, index), SetupSourceDevicePath);
        DbgStatusMesg((_asrinfo, "SpAsrInit3rdPartyFileList. Adding [%ws] to list\n", pRec->SourceFilePath));
        SpAsrInsertInstallFileRecord(pList, pRec);
    }

    return pList;
}



////////////////////////////
// [BUSES] section function
//

STORAGE_BUS_TYPE
SpAsrGetBusType(IN ULONG Index)
{

    STORAGE_BUS_TYPE BusType;

    PWSTR BusKey = SpAsrGetSifKeyBySection(SIF_ASR_BUSES_SECTION, Index);

    BusType = (STORAGE_BUS_TYPE) (STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
            SIF_ASR_BUSES_SECTION,
            BusKey,
            SIF_BUSES_BUS_TYPE,
            TRUE
             )));

    return BusType;
}




////////////////////////////
// [DISKS] section function
//

//
// Returns the total number of disk records (both MBR and GPT)
//
ULONG
SpAsrGetGptDiskRecordCount(VOID)         // does not return on error
{
    static ULONG Count = (ULONG) (-1);

    if ((ULONG) (-1) == Count) {
        Count = SpAsrGetRecordCount(SIF_ASR_GPT_DISKS_SECTION, 0);
    }

    return Count;
}


ULONG
SpAsrGetMbrDiskRecordCount(VOID)         // does not return on error
{
    static ULONG Count = (ULONG) (-1);

    if ((ULONG) (-1) == Count) {
        Count = SpAsrGetRecordCount(SIF_ASR_MBR_DISKS_SECTION, 0);
    }

    return Count;
}

ULONG
SpAsrGetDiskRecordCount(VOID)         // does not return on error
{
    static ULONG Total = (ULONG) (-1);

    if ((ULONG) (-1) == Total ) {
        Total = SpAsrGetMbrDiskRecordCount() + SpAsrGetGptDiskRecordCount();
    }

    return Total;
}



PWSTR
SpAsrGetDiskKey(
    IN PARTITION_STYLE Style,   // GPT or MBR
    IN ULONG Index
    )       // does not return on error
{
    switch (Style) {

    case PARTITION_STYLE_GPT:
        return SpAsrGetSifKeyBySection(SIF_ASR_GPT_DISKS_SECTION, Index);
        break;

    case PARTITION_STYLE_MBR:
        return SpAsrGetSifKeyBySection(SIF_ASR_MBR_DISKS_SECTION, Index);
        break;

    }

    ASSERT(0 && L"Illegal partition style specified");
    return NULL;
}


PSIF_DISK_RECORD
SpAsrGetMbrDiskRecord(
    IN PWSTR DiskKey
    )
{
    PSIF_DISK_RECORD pRec;

    if (!DiskKey) {
        ASSERT(0 && L"SpAsrGetMbrDiskRecord:  DiskKey is NULL!");
        return NULL;
    }

    pRec = SpAsrMemAlloc(sizeof(SIF_DISK_RECORD), TRUE);
    //
    // This is an MBR disk
    //
    pRec->PartitionStyle = PARTITION_STYLE_MBR;

    //
    // [DISKS.MBR] format
    //
    // 0.disk-key = 1.system-key, 2.bus-key, 3.critical-flag,
    //              4.disk-signature, 5.bytes-per-sector, 6.total-sectors
    //

    pRec->CurrDiskKey = DiskKey;

    pRec->SystemKey = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        DiskKey,
        SIF_MBR_DISK_SYSTEMKEY,
        TRUE
        );

    pRec->BusKey = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        DiskKey,
        SIF_MBR_DISK_BUSKEY,
        TRUE
        ));
    pRec->BusType = SpAsrGetBusType(pRec->BusKey - 1);   // our key is 1 based, AsrGetBusType index is 0 based

    if (ASRMODE_NORMAL != SpAsrGetAsrMode()) {
        pRec->IsCritical = TRUE;
    }
    else {
        pRec->IsCritical = (STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
            SIF_ASR_MBR_DISKS_SECTION ,
            DiskKey,
            SIF_MBR_DISK_CRITICAL_FLAG,
            TRUE
            ))) ? TRUE : FALSE;
    }

    pRec->SifDiskMbrSignature = STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        DiskKey,
        SIF_MBR_DISK_SIGNATURE,
        TRUE
        ));

    pRec->BytesPerSector = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        DiskKey,
        SIF_MBR_DISK_BYTES_PER_SECTOR,
        TRUE
        ));

    pRec->SectorsPerTrack = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        DiskKey,
        SIF_MBR_DISK_SECTORS_PER_TRACK,
        TRUE
        ));

    pRec->TracksPerCylinder = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        DiskKey,
        SIF_MBR_DISK_TRACKS_PER_CYLINDER,
        TRUE
        ));

    pRec->TotalSectors = STRING_TO_LONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        DiskKey,
        SIF_MBR_DISK_TOTALSECTORS,
        TRUE
        ));

    return pRec;
}


PSIF_DISK_RECORD
SpAsrGetGptDiskRecord(
    IN PWSTR DiskKey
    )
{
    PSIF_DISK_RECORD pRec = NULL;
    PWSTR GuidString = NULL;

    if (!DiskKey) {
        ASSERT(0 && L"SpAsrGetGptDiskRecord:  DiskKey is NULL!");
        return NULL;
    }

    pRec = SpAsrMemAlloc(sizeof(SIF_DISK_RECORD), TRUE);

    pRec->PartitionStyle = PARTITION_STYLE_GPT;

    //
    // [DISKS.GPT] format
    //
    // 0.disk-key = 1.system-key, 2.bus-key, 3.critical-flag, 4.disk-id,
    //              5.min-partition-count, 6.bytes-per-sector, 7.total-sectors
    //

    pRec->CurrDiskKey = DiskKey;

    pRec->SystemKey = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION,
        DiskKey,
        SIF_GPT_DISK_SYSTEMKEY,
        TRUE
        );

    pRec->BusKey = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        DiskKey,
        SIF_GPT_DISK_BUSKEY,
        TRUE
        ));

    pRec->BusType = SpAsrGetBusType(pRec->BusKey - 1);   // our key is 1 based, AsrGetBusType index is 0 based

    if (ASRMODE_NORMAL != SpAsrGetAsrMode()) {
        pRec->IsCritical = TRUE;
    }
    else {
        pRec->IsCritical = (STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
            SIF_ASR_GPT_DISKS_SECTION ,
            DiskKey,
            SIF_GPT_DISK_CRITICAL_FLAG,
            TRUE
            ))) ? TRUE : FALSE;
    }

    GuidString = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        DiskKey,
        SIF_GPT_DISK_DISK_ID,
        TRUE
        );
    SpAsrGuidFromString(&(pRec->SifDiskGptId), GuidString);

    pRec->MaxGptPartitionCount = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        DiskKey,
        SIF_GPT_DISK_MAX_PTN_COUNT,
        TRUE
        ));

    pRec->BytesPerSector = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        DiskKey,
        SIF_GPT_DISK_BYTES_PER_SECTOR,
        TRUE
        ));

    pRec->SectorsPerTrack = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        DiskKey,
        SIF_GPT_DISK_SECTORS_PER_TRACK,
        TRUE
        ));

    pRec->TracksPerCylinder = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        DiskKey,
        SIF_GPT_DISK_TRACKS_PER_CYLINDER,
        TRUE
        ));

    pRec->TotalSectors = STRING_TO_LONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        DiskKey,
        SIF_GPT_DISK_TOTALSECTORS,
        TRUE
        ));

    return pRec;
}


PSIF_DISK_RECORD
SpAsrGetDiskRecord(
    IN PARTITION_STYLE PartitionStyle,
    IN PWSTR DiskKey
    )
{
    switch (PartitionStyle) {
    case PARTITION_STYLE_MBR:
        return SpAsrGetMbrDiskRecord(DiskKey);
        break;

    case PARTITION_STYLE_GPT:
        return SpAsrGetGptDiskRecord(DiskKey);
        break;
    }

    ASSERT(0 && L"Invalid partition type specified");
    return NULL;

}



PSIF_DISK_RECORD
SpAsrCopyDiskRecord(IN PSIF_DISK_RECORD pInput)
{
    PSIF_DISK_RECORD pRec;

    pRec = SpAsrMemAlloc(sizeof(SIF_DISK_RECORD), TRUE);

    CopyMemory(pRec, pInput, sizeof(SIF_DISK_RECORD));

    pRec->PartitionList = NULL;

    // copy the list of partitions, if any.
    if (pInput->PartitionList) {
        pRec->PartitionList = SpAsrCopyPartitionRecordList(pInput->PartitionList);
    }

    return pRec;
}


////////////////////////////////
// [PARTITIONS] section function
//

ULONG
SpAsrGetMbrPartitionRecordCount(VOID)
{
    return SpAsrGetRecordCount(SIF_ASR_MBR_PARTITIONS_SECTION, 0);
}

ULONG
SpAsrGetGptPartitionRecordCount(VOID)
{
    return SpAsrGetRecordCount(SIF_ASR_GPT_PARTITIONS_SECTION, 0);
}

PWSTR
SpAsrGetMbrPartitionKey(ULONG Index)
{
    return SpAsrGetSifKeyBySection(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        Index);
}


PWSTR
SpAsrGetGptPartitionKey(ULONG Index)
{
    return SpAsrGetSifKeyBySection(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        Index);
}


PWSTR
SpAsrGetDiskKeyByMbrPartitionKey(IN PWSTR PartitionKey)
{
    return SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_DISKKEY,
        TRUE);
}


PWSTR
SpAsrGetDiskKeyByGptPartitionKey(IN PWSTR PartitionKey)
{
    return SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_DISKKEY,
        TRUE);
}

ULONGLONG
SpAsrGetSectorCountByMbrDiskKey(
    IN PWSTR DiskKey
    )
{
    return STRING_TO_ULONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION,
        DiskKey,
        SIF_MBR_DISK_TOTALSECTORS,
        FALSE
        ));
}

ULONGLONG
SpAsrGetSectorCountByGptDiskKey(
    IN PWSTR DiskKey
    )
{
    return STRING_TO_ULONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION,
        DiskKey,
        SIF_GPT_DISK_TOTALSECTORS,
        FALSE
        ));
}


//
// Reads in a partition record from the [PARTITIONS.MBR] section.
//
// [PARTITIONS.MBR]
//
// partition-key = 0.disk-key, 1.slot-index, 2.boot-sys-flag,
//                 3."volume-guid", 4.active-flag, 5.partition-type,
//                 6.file-system-type, 7.start-sector, 8.sector-count
//
PSIF_PARTITION_RECORD
SpAsrGetMbrPartitionRecord(IN PWSTR PartitionKey)
{
    PSIF_PARTITION_RECORD pRec = NULL;
    ULONG bytesPerSector = 0;
    ULONG ntSysMask = 0;

    //
    // PartitionKey better not be null
    //
    if (!PartitionKey) {
        DbgErrorMesg((_asrwarn, "SpAsrGetPartitionRecord. PartitionKey is NULL\n"));
        ASSERT(0 && L"Partition key is NULL");
        return NULL;
    }

    pRec = SpAsrMemAlloc(sizeof(SIF_PARTITION_RECORD), TRUE);

    //
    // Read in the fields
    //
    pRec->CurrPartKey = PartitionKey;
    pRec->PartitionStyle = PARTITION_STYLE_MBR;

    pRec->DiskKey = SpAsrGetDiskKeyByMbrPartitionKey(PartitionKey);

    pRec->PartitionTableEntryIndex = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_SLOT_INDEX,
        TRUE
        ));

    pRec->PartitionFlag = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_SYSBOOT_FLAGS,
        TRUE
        ));

    pRec->VolumeGuid = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_VOLUME_GUID,
        FALSE
        );

    pRec->ActiveFlag = (UCHAR) STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_ACTIVE_FLAG,
        TRUE
        ));

    pRec->PartitionType = (UCHAR) STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_PTN_TYPE,
        TRUE
        ));

    pRec->FileSystemType = (UCHAR) STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_FS_TYPE,
        TRUE
        ));

    pRec->StartSector = STRING_TO_LONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_STARTSECTOR,
        TRUE
        ));

    pRec->SectorCount = STRING_TO_LONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_SECTORCOUNT,
        TRUE
        ));

    pRec->ClusterSize = (DWORD) STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_PARTITIONS_SECTION,
        PartitionKey,
        SIF_MBR_PARTITION_CLUSTER_SIZE,
        TRUE
        ));

    if (SpAsrIsBootPartitionRecord(pRec->PartitionFlag)) {

        // do not free!
        PWSTR ntDirPath = SpAsrGetNtDirectoryPathBySystemKey(ASR_SIF_SYSTEM_KEY);

        if (!SpAsrIsValidBootDrive(ntDirPath)) {

            SpAsrRaiseFatalErrorWs(SP_SCRN_DR_SIF_BAD_RECORD,
                L"ASSERT FAILURE: Improperly formed NT Directory Name",
                SIF_ASR_MBR_PARTITIONS_SECTION
                );
            // does not return
        }

        pRec->NtDirectoryName = SpAsrMemAlloc((SpGetMaxNtDirLen()*sizeof(WCHAR)), TRUE);

        wcsncpy(pRec->NtDirectoryName, ntDirPath + 2, wcslen(ntDirPath) - 2);
    }
    else {
        pRec->NtDirectoryName = NULL;
    }

    bytesPerSector = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_MBR_DISKS_SECTION ,
        pRec->DiskKey,
        SIF_MBR_DISK_BYTES_PER_SECTOR,
        TRUE
        ));

    pRec->SizeMB = SpAsrConvertSectorsToMB(pRec->SectorCount, bytesPerSector);

    return pRec;
}


PSIF_PARTITION_RECORD
SpAsrGetGptPartitionRecord(IN PWSTR PartitionKey)
{
    PSIF_PARTITION_RECORD pRec = NULL;
    ULONG bytesPerSector = 0;
    ULONG ntSysMask = 0;
    PWSTR GuidString = NULL;

    if (!PartitionKey) {

        DbgErrorMesg((_asrwarn, "SpAsrGetPartitionRecord. PartitionKey is NULL\n"));

        ASSERT(0 && L"Partition key is NULL");

        return NULL;
    }

    pRec = SpAsrMemAlloc(sizeof(SIF_PARTITION_RECORD), TRUE);

    //
    // Read in the fields
    //
    pRec->CurrPartKey = PartitionKey;
    pRec->PartitionStyle = PARTITION_STYLE_GPT;

    pRec->DiskKey = SpAsrGetDiskKeyByGptPartitionKey(PartitionKey);

    pRec->PartitionTableEntryIndex = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_SLOT_INDEX,
        TRUE
        ));

    pRec->PartitionFlag = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_SYSBOOT_FLAGS,
        TRUE
        ));

    pRec->VolumeGuid = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_VOLUME_GUID,
        FALSE
        );

    GuidString = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_TYPE_GUID,
        FALSE
        );
    SpAsrGuidFromString(&(pRec->PartitionTypeGuid), GuidString);

    GuidString = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_ID_GUID,
        FALSE
        );
    SpAsrGuidFromString(&(pRec->PartitionIdGuid), GuidString);

    pRec->PartitionName = SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_NAME,
        FALSE
        );

    pRec->GptAttributes = STRING_TO_LONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_GPT_ATTRIBUTES,
        TRUE
        ));

    pRec->FileSystemType = (UCHAR) STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_FS_TYPE,
        TRUE
        ));

    pRec->StartSector = STRING_TO_LONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_STARTSECTOR,
        TRUE
        ));

    pRec->SectorCount = STRING_TO_LONGLONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_SECTORCOUNT,
        TRUE
        ));


    pRec->ClusterSize = (DWORD) STRING_TO_HEX(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_PARTITIONS_SECTION,
        PartitionKey,
        SIF_GPT_PARTITION_CLUSTER_SIZE,
        TRUE
        ));

    if (SpAsrIsBootPartitionRecord(pRec->PartitionFlag)) {

        // do not free!
        PWSTR ntDirPath = SpAsrGetNtDirectoryPathBySystemKey(ASR_SIF_SYSTEM_KEY);

        if (!SpAsrIsValidBootDrive(ntDirPath)) {

            SpAsrRaiseFatalErrorWs(SP_SCRN_DR_SIF_BAD_RECORD,
                L"ASSERT FAILURE: Improperly formed NT Directory Name",
                SIF_ASR_GPT_PARTITIONS_SECTION
                );
            // does not return
        }


        pRec->NtDirectoryName = SpAsrMemAlloc((SpGetMaxNtDirLen()*sizeof(WCHAR)), TRUE);

        wcsncpy(pRec->NtDirectoryName, ntDirPath + 2, wcslen(ntDirPath) - 2);

    }
    else {
        pRec->NtDirectoryName = NULL;
    }

    bytesPerSector = STRING_TO_ULONG(SpAsrGetSifDataBySectionAndKey(
        SIF_ASR_GPT_DISKS_SECTION ,
        pRec->DiskKey,
        SIF_GPT_DISK_BYTES_PER_SECTOR,
        TRUE
        ));

    pRec->SizeMB = SpAsrConvertSectorsToMB(pRec->SectorCount, bytesPerSector);

    return pRec;
}


PSIF_PARTITION_RECORD
SpAsrCopyPartitionRecord(IN PSIF_PARTITION_RECORD pInput)
{
    PSIF_PARTITION_RECORD pRec = NULL;

    if (!pInput) {
        ASSERT(0 && L"SpAsrCopyPartitionRecord: Invalid NULL input parameter");
        return NULL;
    }

    pRec = SpAsrMemAlloc(sizeof(SIF_PARTITION_RECORD), TRUE);
    //
    // Won't return if pRec is NULL
    //
    ASSERT(pRec);

    //
    // Copy the record over
    //
    CopyMemory(pRec, pInput, sizeof(SIF_PARTITION_RECORD));

    //
    // And allocate space for the directory name
    //
    pRec->NtDirectoryName = NULL;
    if (
        SpAsrIsBootPartitionRecord(pRec->PartitionFlag)  &&
        pInput->NtDirectoryName
        ) {

        pRec->NtDirectoryName = SpAsrMemAlloc(
            (wcslen(pInput->NtDirectoryName) + 1) * sizeof(WCHAR),
            TRUE
            );
        //
        // Won't return NULL
        //
        ASSERT(pRec->NtDirectoryName);

        wcscpy(pRec->NtDirectoryName, pInput->NtDirectoryName);
    }

    return pRec;
}


VOID
SpAsrInsertPartitionRecord(
    IN PSIF_PARTITION_RECORD_LIST pList,
    IN PSIF_PARTITION_RECORD pRec
    )
/*++
Description:

    Inserts a partition record into a list of partition records.  Partition
    records are ordered in ascending order by start sector.  That is, the
    partition record with the lowest numbered start sector will be the first
    partition record in the list.

Arguments:

    pList   The list into which the record is to be inserted.

    pRec    The record to insert.

Returns:

    None.
--*/
{
    SIF_PARTITION_RECORD *curr = NULL, *prev = NULL;

    ASSERT(pList && pRec);

    // set the initial conditions.
    pRec->Next = NULL;
    pRec->Prev = NULL;

    pList->ElementCount += 1;


    // special Case I:  Insert into an empty list.
    if( pList->ElementCount == 1 ) {
        pList->First = pList->Last = pRec;
        return;
    }


    // Special Case II: pRec must be inserted before the first element.
    if( pRec->StartSector < pList->First->StartSector ) {
        pRec->Next = pList->First;
        pList->First = pRec;
        pRec->Next->Prev = pRec;
        return;
    }


    // Special Case III:  pRec must be appended after the last element
    // because pRec's start sector is greater than the last element
    // on the list (which, by construction, must have the largest
    // start sector).
    //
    if( pList->Last->StartSector < pRec->StartSector ) {
        pRec->Prev = pList->Last;
        pList->Last->Next = pRec;
        pList->Last = pRec;
        return;
    }

    // If we're here, then pRec's start sector must be greater than
    // the start sector of the first element on the list but less than
    // the start sector of the list's last element.  We walk the list
    // to find the insertion point, i.e., immediately before the first
    // element in the list whose start sector is greater than that of
    // pRec's.
    curr = prev = pList->First;
    while (pRec->StartSector > curr->StartSector && curr->Next) {
        prev = curr;
        curr = curr->Next;
    }


    // insert pRec between curr and prev
    pRec->Next = curr;
    pRec->Prev = prev;

    curr->Prev = pRec;
    prev->Next = pRec;

    ASSERT (pRec->Prev->Next == pRec);
    ASSERT (pRec->Next->Prev == pRec);
}


VOID
SpAsrRemovePartitionRecord(
    IN PSIF_PARTITION_RECORD_LIST pList,
    IN PSIF_PARTITION_RECORD pRec
    )
/*++

  Description:
    Unhook a partition record from a list of partition records.

--*/
{
    ASSERT(pList && pRec);

    // unhook it from the list.
    if (pRec->Prev) {
        pRec->Prev->Next = pRec->Next;
    }

    if (pRec->Next) {
        pRec->Next->Prev = pRec->Prev;
    }

    // was this the first record in the list?
    if (pList->First == pRec) {
        pList->First = pRec->Next;
    }

    // or the last record?
    if (pList->Last == pRec) {
        pList->Last = pRec->Prev;
    }

    pRec->Next = pRec->Prev = NULL;
}


PSIF_PARTITION_RECORD
SpAsrPopNextPartitionRecord(IN PSIF_PARTITION_RECORD_LIST pList)
{
    PSIF_PARTITION_RECORD poppedRecord = NULL;

    if (!pList) {
//        ASSERT(0 && L"Trying to pop records off of a NULL list");
        return NULL;
    }

    // get the first node in the list
    if (poppedRecord = pList->First) {

        // advance the First pointer to the next node
        if (pList->First = pList->First->Next) {

            // and make the Prev of the new first-node be NULL
            pList->First->Prev = NULL;
        }

        pList->ElementCount -= 1;

        // the poppedRecord is not part of the list any more
        poppedRecord->Next = NULL;
        poppedRecord->Prev = NULL;
    }

    return poppedRecord;
}


PSIF_PARTITION_RECORD_LIST
SpAsrCopyPartitionRecordList(PSIF_PARTITION_RECORD_LIST pSrcList)
{
    PSIF_PARTITION_RECORD_LIST pDestList = NULL;
    PSIF_PARTITION_RECORD pRec = NULL, pNew = NULL;

    if (!pSrcList) {
        ASSERT(0 && L"SpAsrCopyPartitionRecordList:  Invalid NULL input parameter");
        return NULL;
    }

    pDestList = SpAsrMemAlloc(sizeof(SIF_PARTITION_RECORD_LIST), TRUE);
    //
    // Won't return if pDestList is NULL.
    //
    ASSERT(pDestList);

    pRec = pSrcList->First;
    while (pRec) {

        pNew = SpAsrCopyPartitionRecord(pRec);
        ASSERT(pNew);

        SpAsrInsertPartitionRecord(pDestList, pNew);

        pRec = pRec->Next;
    }

    pDestList->TotalMbRequired = pSrcList->TotalMbRequired;

    return pDestList;
}



VOID
SpAsrCheckAsrSifVersion()
{

    return;
}


//
// Debug routines
//
#if 0
VOID
SpAsrDbgDumpSystemRecord(IN PWSTR Key)
{

    PWSTR osVer = SpAsrGetSifDataBySectionAndKey(SIF_ASR_SYSTEMS_SECTION,
                                               Key,
                                               SIF_SYSTEM_OSVERSION,
                                               FALSE);

    DbgMesg((_asrinfo,
        "Key:%ws = SysName:[%ws], OsVer:[%ws], NtDir:[%ws], AutoExt:[%ws]\n",
        Key,
        SpAsrGetSifDataBySectionAndKey(SIF_ASR_SYSTEMS_SECTION, Key, SIF_SYSTEM_NAME, TRUE),
        osVer? osVer : L"",
        SpAsrGetNtDirectoryPathBySystemKey(Key),
        SpAsrGetAutoExtend(Key)
        ));
}


VOID
SpAsrDbgDumpSystemRecords(VOID)
{
    ULONG index, count = SpAsrGetSystemRecordCount();
    DbgStatusMesg((_asrinfo, "----- Dumping [SYSTEM] Section (%lu Records): -----\n", count));
    for (index = 0; index < count; index++) {
        SpAsrDbgDumpSystemRecord(SpAsrGetSifKeyBySection(SIF_ASR_SYSTEMS_SECTION, index));
    }
    DbgStatusMesg((_asrinfo, "----- End of [SYSTEM] Section (%lu Records) -----\n", count));
}


VOID
SpAsrDbgDumpDiskRecord(IN PWSTR Key)
{
    PSIF_DISK_RECORD pRec = NULL;

    if (!Key) {
        return;
    }

    pRec = SpAsrGetDiskRecord(Key);
    if (!pRec) {
        return;
    }

    DbgMesg((_asrinfo,
        "Key:[%ws] = Sys:[%ws] SifDskNum:[%ws], SifDskSig:0x%lx, ScSz:%lu, TtlSc:%I64u",
        pRec->CurrDiskKey,
        pRec->SystemKey,
        pRec->SifDiskSignature,
        pRec->BytesPerSector,
        pRec->TotalSectors
        ));


    if (pRec->ExtendedPartitionStartSector > -1) {
        KdPrintEx((_asrinfo, ", extSS:%I64u, extSC:%I64u",
                    pRec->ExtendedPartitionStartSector,
                    pRec->ExtendedPartitionSectorCount));
    }

    KdPrintEx((_asrinfo, "\n"));
    SpMemFree(pRec);
}


VOID
SpAsrDbgDumpDiskRecords(VOID)
{
    ULONG index, count = SpAsrGetMbrDiskRecordCount();
    DbgStatusMesg((_asrinfo, "----- Dumping [DISK.MBR] Section (%lu Records): -----\n", count));
    for (index = 0; index < count; index++) {
        SpAsrDbgDumpDiskRecord(SpAsrGetSifKeyBySection(SIF_ASR_MBR_DISKS_SECTION , index));
    }
    DbgStatusMesg((_asrinfo, "----- End of [DISK.MBR] Section (%lu Records) -----\n", count));

    count = SpAsrGetGptDiskRecordCount();
    DbgStatusMesg((_asrinfo, "----- Dumping [DISK.GPT] Section (%lu Records): -----\n", count));
    for (index = 0; index < count; index++) {
        SpAsrDbgDumpDiskRecord(SpAsrGetSifKeyBySection(SIF_ASR_GPT_DISKS_SECTION , index));
    }
    DbgStatusMesg((_asrinfo, "----- End of [DISK.GPT] Section (%lu Records) -----\n", count));
}


VOID
SpAsrDbgDumpPartitionRecord(IN PARTITION_STYLE PartitinStyle, IN PWSTR Key)
{
    PSIF_PARTITION_RECORD pRec =  SpAsrGetPartitionRecord(Key);

    DbgMesg((_asrinfo,
        "Key:[%ws] = Dsk %ws, ntDir:[%ws], volGd:[%ws], actv:0x%x, type:0x%x, fs:0x%x boot:%ws, sys:%ws, SS:%I64u SC:%I64u sz:%I64u\n",
        pRec->CurrPartKey,
        pRec->DiskKey,
        SpAsrIsBootPartitionRecord(pRec->PartitionFlag) ? pRec->NtDirectoryName : L"n/a",
        pRec->VolumeGuid ? pRec->VolumeGuid : L"n/a",
        pRec->ActiveFlag,
        pRec->PartitionType,
        pRec->FileSystemType,
        SpAsrIsBootPartitionRecord(pRec->PartitionFlag) ? "Y" : "N",
        SpAsrIsSystemPartitionRecord(pRec->PartitionFlag) ? "Y" : "N",
        pRec->StartSector,
        pRec->SectorCount,
        pRec->SizeMB
        ));

    SpMemFree(pRec);
}


VOID
SpAsrDbgDumpPartitionList(IN PSIF_PARTITION_RECORD_LIST pList)
{
    PSIF_PARTITION_RECORD pRec;
    ASSERT(pList);
    DbgStatusMesg((_asrinfo, "----- Dumping Partition List: -----\n"));

    pRec = pList->First;
    while (pRec) {
        SpAsrDbgDumpPartitionRecord(pRec->CurrPartKey);
        pRec = pRec->Next;
    }
    DbgStatusMesg((_asrinfo, "----- End of Partition List -----\n"));
}


VOID
SpAsrDbgDumpPartitionRecords(VOID)
{
    ULONG index, count = SpAsrGetPartitionRecordCount();
    DbgStatusMesg((_asrinfo, "----- Dumping [PARTITION] Section (%lu Records): -----\n", count));
    for (index = 0; index < count; index++) {
        SpAsrDbgDumpPartitionRecord(SpAsrGetSifKeyBySection(SIF_ASR_MBR_PARTITIONS_SECTION, index));
    }
    DbgStatusMesg((_asrinfo, "----- End of [PARTITION] Section (%lu Records) -----\n", count));
}


VOID
SpAsrDbgDumpInstallFileRecord(IN PWSTR Key)
{
    PSIF_INSTALLFILE_RECORD pRec = SpAsrGetInstallFileRecord(Key,NULL);

    DbgMesg((_asrinfo,
        "Key:[%ws] = SysKey:[%ws], MediaLabel:[%ws], Media:[%ws], Src:[%ws], Dest:[%ws], Vendor:[%ws]",
        Key,
        pRec->SystemKey,
        pRec->SourceMediaExternalLabel,
        pRec->DiskDeviceName,
        pRec->SourceFilePath,
        pRec->DestinationFilePath,
        pRec->VendorString
        ));

    SpMemFree(pRec);
}

VOID
SpAsrDbgDumpInstallFileRecords(VOID)
{
    ULONG index, count = SpAsrGetInstallFilesRecordCount();
    DbgStatusMesg((_asrinfo, "----- Dumping [INSTALLFILE] Section (%lu Records): -----\n", count));
    for (index = 0; index < count; index++) {
        SpAsrDbgDumpInstallFileRecord(SpAsrGetSifKeyBySection(SIF_ASR_INSTALLFILES_SECTION, index));
    }
    DbgStatusMesg((_asrinfo, "----- End of [INSTALLFILE] Section (%lu Records) -----\n", count));
}

VOID
SpAsrDbgDumpInstallFileList(IN PSIF_INSTALLFILE_LIST pList)
{
    PSIF_INSTALLFILE_RECORD pRec;

    if (pList == NULL) {
        DbgStatusMesg((_asrinfo, "No 3rd party files are specified.\n"));
    }
    else {
        DbgStatusMesg((_asrinfo, "----- Dumping Install-file List: -----\n"));
        pRec = pList->First;
        while (pRec) {
            SpAsrDbgDumpInstallFileRecord(pRec->CurrKey);
            pRec = pRec->Next;
        }
        DbgStatusMesg((_asrinfo, "----- End of Install-file List -----\n"));
    }
}

VOID
SpAsrDbgTestSifFunctions(VOID)
{
    SpAsrDbgDumpSystemRecords();
    SpAsrDbgDumpDiskRecords();
    SpAsrDbgDumpPartitionRecords();
    SpAsrDbgDumpInstallFileRecords();
}
#endif // Debug routines
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spfatfmt.c ===
#include "spprecmp.h"
#pragma hdrstop

//
//  This variable is needed since it contains a buffer that can
//  be used in kernel mode. The buffer is used by NtFsControlFile,
//  since the Zw API is not exported
//
extern PSETUP_COMMUNICATION  CommunicationParams;

#define VERIFY_SIZE   65536


typedef struct {
    UCHAR   IntelNearJumpCommand[1];    // Intel Jump command
    UCHAR   BootStrapJumpOffset[2];     // offset of boot strap code
    UCHAR   OemData[8];                 // OEM data
    UCHAR   BytesPerSector[2];          // BPB
    UCHAR   SectorsPerCluster[1];       //
    UCHAR   ReservedSectors[2];         //
    UCHAR   Fats[1];                    //
    UCHAR   RootEntries[2];             //
    UCHAR   Sectors[2];                 //
    UCHAR   Media[1];                   //
    UCHAR   SectorsPerFat[2];           //
    UCHAR   SectorsPerTrack[2];         //
    UCHAR   Heads[2];                   //
    UCHAR   HiddenSectors[4];           //
    UCHAR   LargeSectors[4];            //
    UCHAR   PhysicalDrive[1];           // 0 = removable, 80h = fixed
    UCHAR   CurrentHead[1];             // not used by fs utils
    UCHAR   Signature[1];               // boot signature
    UCHAR   SerialNumber[4];            // serial number
    UCHAR   Label[11];                  // volume label, aligned padded
    UCHAR   SystemIdText[8];            // system ID, FAT for example
} UNALIGNED_SECTOR_ZERO, *PUNALIGNED_SECTOR_ZERO;


#define CSEC_FAT32MEG   65536
#define CSEC_FAT16BIT   32680
#define MIN_CLUS_BIG    4085    // Minimum clusters for a big FAT.
#define MAX_CLUS_BIG    65525   // Maximum + 1 clusters for big FAT.


USHORT
ComputeSecPerCluster(
    IN  ULONG   NumSectors,
    IN  BOOLEAN SmallFat
    )
/*++

Routine Description:

    This routine computes the number of sectors per cluster.

Arguments:

    NumSectors  - Supplies the number of sectors on the disk.
    SmallFat    - Supplies whether or not the FAT should be small.

Return Value:

    The number of sectors per cluster necessary.

--*/
{
    ULONG   threshold;
    USHORT  sec_per_clus;
    USHORT  min_sec_per_clus;

    threshold = SmallFat ? MIN_CLUS_BIG : MAX_CLUS_BIG;
    sec_per_clus = 1;

    while (NumSectors >= threshold) {
        sec_per_clus *= 2;
        threshold *= 2;
    }

    if (SmallFat) {
        min_sec_per_clus = 8;
    } else {
        min_sec_per_clus = 4;
    }

    return max(sec_per_clus, min_sec_per_clus);
}


ULONG
SpComputeSerialNumber(
    VOID
    )
/*++

Routine Description:

    This routine computes a new serial number for a volume.

Arguments:

    Seed    - Supplies a seed for the serial number.

Return Value:

    A new volume serial number.

--*/
{
    PUCHAR p;
    ULONG i;
    TIME_FIELDS time_fields;
    static ULONG Seed = 0;
    ULONG SerialNumber;
    BOOLEAN b;

    //
    // If this is the first time we've entered this routine,
    // generate a seed value based on the real time clock.
    //
    if(!Seed) {

        b = HalQueryRealTimeClock(&time_fields);
        ASSERT(b);

        Seed = ((time_fields.Year - 1970) *366*24*60*60) +
               (time_fields.Month *31*24*60*60) +
               (time_fields.Day *24*60*60) +
               (time_fields.Hour *60*60) +
               (time_fields.Minute *60) +
               time_fields.Second +
               ((ULONG)time_fields.Milliseconds << 10);

        ASSERT(Seed);
        if(!Seed) {
            Seed = 1;
        }

    }

    SerialNumber = Seed;
    p = (PUCHAR)&SerialNumber;

    for(i=0; i<sizeof(ULONG); i++) {

        SerialNumber += p[i];
        SerialNumber = (SerialNumber >> 2) + (SerialNumber << 30);
    }

    if(++Seed == 0) {       // unlikely, but possible.
        Seed++;
    }

    return SerialNumber;
}


VOID
EditFat(
    IN      USHORT  ClusterNumber,
    IN      USHORT  ClusterEntry,
    IN OUT  PUCHAR  Fat,
    IN      BOOLEAN SmallFat
    )
/*++

Routine Description:

    This routine edits the FAT entry 'ClusterNumber' with 'ClusterEntry'.

Arguments:

    ClusterNumber   - Supplies the number of the cluster to edit.
    ClusterEntry    - Supplies the new value for that cluster number.
    Fat             - Supplies the FAT to edit.
    SmallFat        - Supplies whether or not the FAT is small.

Return Value:

    None.

--*/
{
    ULONG   n;

    if (SmallFat) {

        n = ClusterNumber*3;
        if (n%2) {
            Fat[n/2] = (UCHAR) ((Fat[n/2]&0x0F) | ((ClusterEntry&0x000F)<<4));
            Fat[n/2 + 1] = (UCHAR) ((ClusterEntry&0x0FF0)>>4);
        } else {
            Fat[n/2] = (UCHAR) (ClusterEntry&0x00FF);
            Fat[n/2 + 1] = (UCHAR) ((Fat[n/2 + 1]&0xF0) |
                                    ((ClusterEntry&0x0F00)>>8));
        }

    } else {

        ((PUSHORT) Fat)[ClusterNumber] = ClusterEntry;

    }
}


NTSTATUS
FmtFillFormatBuffer(
    IN  ULONGLONG  NumberOfSectors,
    IN  ULONG    SectorSize,
    IN  ULONG    SectorsPerTrack,
    IN  ULONG    NumberOfHeads,
    IN  ULONGLONG NumberOfHiddenSectors,
    OUT PVOID    FormatBuffer,
    IN  ULONG    FormatBufferSize,
    OUT PULONGLONG SuperAreaSize,
    IN  PULONG   BadSectorsList,
    IN  ULONG    NumberOfBadSectors,
    OUT PUCHAR   SystemId
    )
/*++

Routine Description:

    This routine computes a FAT super area based on the disk size,
    disk geometry, and bad sectors of the volume.

Arguments:

    NumberOfSectors         - Supplies the number of sectors on the volume.
    SectorSize              - Supplies the number of bytes per sector.
    SectorsPerTrack         - Supplies the number of sectors per track.
    NumberOfHeads           - Supplies the number of heads.
    NumberOfHiddenSectors   - Supplies the number of hidden sectors.
    FormatBuffer            - Returns the super area for the volume.
    FormatBufferSize        - Supplies the number of bytes in the supplied
                                buffer.
    SuperAreaSize           - Returns the number of bytes in the super area.
    BadSectorsList          - Supplies the list of bad sectors on the volume.
    NumberOfBadSectors      - Supplies the number of bad sectors in the list.

Return Value:

    ENOMEM  - The buffer wasn't big enough.
    E2BIG   - The disk is too large to be formatted.
    EIO     - There is a bad sector in the super area.
    EINVAL  - There is a bad sector off the end of the disk.
    ESUCCESS

--*/
{
    PUNALIGNED_SECTOR_ZERO  psecz;
    PUCHAR                  puchar;
    USHORT                  tmp_ushort;
    ULONG                   tmp_ulong;
    BOOLEAN                 small_fat;
    ULONG                   num_sectors;
    UCHAR                   partition_id;
    ULONG                   sec_per_fat;
    ULONG                   sec_per_root;
    ULONG                   sec_per_clus;
    ULONG                   i;
    ULONG                   sec_per_sa;


    RtlZeroMemory(FormatBuffer,FormatBufferSize);

    // Make sure that there's enough room for the BPB.

    if(!FormatBuffer || FormatBufferSize < SectorSize) {
        return(STATUS_BUFFER_TOO_SMALL);
    }

    // Compute the number of sectors on disk.
    num_sectors = (ULONG)NumberOfSectors;

    // Compute the partition identifier.
    partition_id = num_sectors < CSEC_FAT16BIT ? PARTITION_FAT_12 :
                   num_sectors < CSEC_FAT32MEG ? PARTITION_FAT_16 :
                                                 PARTITION_HUGE;

    // Compute whether or not to have a big or small FAT.
    small_fat = (BOOLEAN) (partition_id == PARTITION_FAT_12);


    psecz = (PUNALIGNED_SECTOR_ZERO) FormatBuffer;
    puchar = (PUCHAR) FormatBuffer;

    //
    // Copy the fat boot code into the format buffer.
    //
    if (!IsNEC_98) { //NEC98
        ASSERT(sizeof(FatBootCode) == 512);
        RtlMoveMemory(psecz,FatBootCode,sizeof(FatBootCode));

        // Set up the jump instruction.
        psecz->IntelNearJumpCommand[0] = 0xeb;
        psecz->IntelNearJumpCommand[1] = 0x3c;
        psecz->IntelNearJumpCommand[2] = 0x90;
    } else {
        ASSERT(sizeof(PC98FatBootCode) == 512);
        RtlMoveMemory(psecz,PC98FatBootCode,sizeof(PC98FatBootCode));

        //
        // Already written jump instruction to bootcode.
        // So,do not reset jump code.
        //
    } //NEC98

    // Set up the OEM data.
    memcpy(psecz->OemData, "MSDOS5.0", 8);

    // Set up the bytes per sector.
    U_USHORT(psecz->BytesPerSector) = (USHORT)SectorSize;

    // Set up the number of sectors per cluster.
    sec_per_clus = ComputeSecPerCluster(num_sectors, small_fat);
    if (sec_per_clus > 128) {

        // The disk is too large to be formatted.
        return(STATUS_INVALID_PARAMETER);
    }
    psecz->SectorsPerCluster[0] = (UCHAR) sec_per_clus;

    // Set up the number of reserved sectors.
    U_USHORT(psecz->ReservedSectors) = (USHORT)max(1,512/SectorSize);

    // Set up the number of FATs.
    psecz->Fats[0] = 2;

    // Set up the number of root entries and number of sectors for the root.
    U_USHORT(psecz->RootEntries) = 512;
    sec_per_root = (512*32 - 1)/SectorSize + 1;

    // Set up the number of sectors.
    if (num_sectors >= 1<<16) {
        tmp_ushort = 0;
        tmp_ulong = num_sectors;
    } else {
        tmp_ushort = (USHORT) num_sectors;
        tmp_ulong = 0;
    }
    U_USHORT(psecz->Sectors) = tmp_ushort;
    U_ULONG(psecz->LargeSectors) = tmp_ulong;

    // Set up the media byte.
    psecz->Media[0] = 0xF8;

    // Set up the number of sectors per FAT.
    if (small_fat) {
        sec_per_fat = num_sectors/(2 + SectorSize*sec_per_clus*2/3);
    } else {
        sec_per_fat = num_sectors/(2 + SectorSize*sec_per_clus/2);
    }
    sec_per_fat++;
    U_USHORT(psecz->SectorsPerFat) = (USHORT)sec_per_fat;

    // Set up the number of sectors per track.
    U_USHORT(psecz->SectorsPerTrack) = (USHORT)SectorsPerTrack;

    // Set up the number of heads.
    U_USHORT(psecz->Heads) = (USHORT)NumberOfHeads;

    // Set up the number of hidden sectors.
    U_ULONG(psecz->HiddenSectors) = (ULONG)NumberOfHiddenSectors;

    // Set up the physical drive number.
    psecz->PhysicalDrive[0] = 0x80;
    psecz->CurrentHead[0] = 0;

    // Set up the BPB signature.
    psecz->Signature[0] = 0x29;

    // Set up the serial number.
    U_ULONG(psecz->SerialNumber) = SpComputeSerialNumber();

    // Set up the volume label.
    memcpy(psecz->Label, "NO NAME    ",11);

    // Set up the system id.
    memcpy(psecz->SystemIdText, small_fat ? "FAT12   " : "FAT16   ", 8);

    // Set up the boot signature.
    puchar[510] = 0x55;
    puchar[511] = 0xAA;

    // Now make sure that the buffer has enough room for both of the
    // FATs and the root directory.

    sec_per_sa = 1 + 2*sec_per_fat + sec_per_root;
    *SuperAreaSize = SectorSize*sec_per_sa;
    if (*SuperAreaSize > FormatBufferSize) {
        return(STATUS_BUFFER_TOO_SMALL);
    }


    // Set up the first FAT.

    puchar[SectorSize] = 0xF8;
    puchar[SectorSize + 1] = 0xFF;
    puchar[SectorSize + 2] = 0xFF;

    if (!small_fat) {
        puchar[SectorSize + 3] = 0xFF;
    }


    for (i = 0; i < NumberOfBadSectors; i++) {

        if (BadSectorsList[i] < sec_per_sa) {
            // There's a bad sector in the super area.
            return(STATUS_UNSUCCESSFUL);
        }

        if (BadSectorsList[i] >= num_sectors) {
            // Bad sector out of range.
            return(STATUS_NONEXISTENT_SECTOR);
        }

        // Compute the bad cluster number;
        tmp_ushort = (USHORT)
                     ((BadSectorsList[i] - sec_per_sa)/sec_per_clus + 2);

        EditFat(tmp_ushort, (USHORT) 0xFFF7, &puchar[SectorSize], small_fat);
    }


    // Copy the first FAT onto the second.

    memcpy(&puchar[SectorSize*(1 + sec_per_fat)],
           &puchar[SectorSize],
           (unsigned int) SectorSize*sec_per_fat);

    *SystemId = partition_id;

    return(STATUS_SUCCESS);
}


VOID
FmtVerifySectors(
    IN  HANDLE      Handle,
    IN  ULONG       NumberOfSectors,
    IN  ULONG       SectorSize,
    OUT PULONG*     BadSectorsList,
    OUT PULONG      NumberOfBadSectors
    )
/*++

Routine Description:

    This routine verifies all of the sectors on the volume.
    It returns a pointer to a list of bad sectors.  The pointer
    will be NULL if there was an error detected.

Arguments:

    Handle              - Supplies a handle to the partition for verifying.
    NumberOfSectors     - Supplies the number of partition sectors.
    SectorSize          - Supplies the number of bytes per sector.
    BadSectorsList      - Returns the list of bad sectors.
    NumberOfBadSectors  - Returns the number of bad sectors in the list.

Return Value:

    None.

--*/
{
    ULONG           num_read_sec;
    ULONG           i, j;
    PULONG          bad_sec_buf;
    ULONG           max_num_bad;
    PVOID           Gauge;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS        Status;
    VERIFY_INFORMATION VerifyInfo;


    max_num_bad = 100;
    bad_sec_buf = SpMemAlloc(max_num_bad*sizeof(ULONG));
    ASSERT(bad_sec_buf);

    *NumberOfBadSectors = 0;

    num_read_sec = VERIFY_SIZE/SectorSize;

    //
    // Initialize the Gas Gauge
    //
    SpFormatMessage(
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        SP_TEXT_SETUP_IS_FORMATTING
        );

    Gauge = SpCreateAndDisplayGauge(
                NumberOfSectors/num_read_sec,
                0,
                VideoVars.ScreenHeight - STATUS_HEIGHT - (3*GAUGE_HEIGHT/2),
                TemporaryBuffer,
                NULL,
                GF_PERCENTAGE,
                0
                );

    VerifyInfo.StartingOffset.QuadPart = 0;

    for (i = 0; i < NumberOfSectors; i += num_read_sec) {

        if (i + num_read_sec > NumberOfSectors) {
            num_read_sec = NumberOfSectors - i;
        }

        //
        // Verify this many sectors at the current offset.
        //
        VerifyInfo.Length = num_read_sec * SectorSize;
        Status = ZwDeviceIoControlFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_DISK_VERIFY,
                    &VerifyInfo,
                    sizeof(VerifyInfo),
                    NULL,
                    0
                    );
        //
        // I/O should be synchronous.
        //
        ASSERT(Status != STATUS_PENDING);

        if(!NT_SUCCESS(Status)) {

            //
            // Range is bad -- verify individual sectors.
            //
            VerifyInfo.Length = SectorSize;

            for (j = 0; j < num_read_sec; j++) {

                Status = ZwDeviceIoControlFile(
                            Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_DISK_VERIFY,
                            &VerifyInfo,
                            sizeof(VerifyInfo),
                            NULL,
                            0
                            );

                ASSERT(Status != STATUS_PENDING);

                if(!NT_SUCCESS(Status)) {

                    if (*NumberOfBadSectors == max_num_bad) {

                        max_num_bad += 100;
                        bad_sec_buf = SpMemRealloc(
                                        bad_sec_buf,
                                        max_num_bad*sizeof(ULONG)
                                        );

                        ASSERT(bad_sec_buf);
                    }

                    bad_sec_buf[(*NumberOfBadSectors)++] = i + j;
                }

                //
                // Advance to next sector.
                //
                VerifyInfo.StartingOffset.QuadPart += SectorSize;
            }
        } else {

            //
            // Advance to next range of sectors.
            //
            VerifyInfo.StartingOffset.QuadPart += VerifyInfo.Length;
        }

        if(Gauge) {
            SpTickGauge(Gauge);
        }
    }

    if(Gauge) {
        SpTickGauge(Gauge);
    }

    *BadSectorsList = bad_sec_buf;

    //return(STATUS_SUCCESS);
}


#if 0
//
// Code not used, we call autoformat
//
NTSTATUS
SpFatFormat(
    IN PDISK_REGION Region
    )
/*++

Routine Description:

    This routine does a FAT format on the given partition.

    The caller should have cleared the screen and displayed
    any message in the upper portion; this routine will
    maintain the gas gauge in the lower portion of the screen.

Arguments:

    Region - supplies the disk region descriptor for the
        partition to be formatted.

Return Value:


--*/
{
    ULONG           hidden_sectors;
    PULONG          bad_sectors;
    ULONG           num_bad_sectors;
    PVOID           format_buffer;
    PVOID           unaligned_format_buffer;
    ULONG           max_sec_per_sa;
    ULONG           super_area_size;
    PHARD_DISK      pHardDisk;
    ULONG           PartitionOrdinal;
    NTSTATUS        Status;
    HANDLE          Handle;
    ULONG           BytesPerSector;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER   LargeZero;
    UCHAR           SysId;
    ULONG           ActualSectorCount;
    SET_PARTITION_INFORMATION PartitionInfo;


    ASSERT(Region->PartitionedSpace);
    ASSERT(Region->TablePosition < PTABLE_DIMENSION);
    ASSERT(Region->Filesystem != FilesystemDoubleSpace);
    pHardDisk = &HardDisks[Region->DiskNumber];
    BytesPerSector = pHardDisk->Geometry.BytesPerSector;
    PartitionOrdinal = SpPtGetOrdinal(Region,PartitionOrdinalCurrent);

    //
    // Make SURE it's not partition0!  The results of formatting partition0
    // are so disasterous that theis warrants a special check.
    //
    if(!PartitionOrdinal) {
        SpBugCheck(
            SETUP_BUGCHECK_PARTITION,
            PARTITIONBUG_B,
            Region->DiskNumber,
            0
            );
    }

#if defined(_AMD64_) || defined(_X86_)
    //
    // If we're going to format C:, then clear the previous OS entry
    // in boot.ini.
    //
    if(Region == SpPtValidSystemPartition()) {
        *OldSystemLine = '\0';
    }
#endif // defined(_AMD64_) || defined(_X86_)

    //
    // Query the number of hidden sectors and the actual number
    // of sectors in the volume.
    //
    SpPtGetSectorLayoutInformation(Region,&hidden_sectors,&ActualSectorCount);

    //
    // Open the partition for read/write access.
    // This shouldn't lock the volume so we need to lock it below.
    //
    Status = SpOpenPartition(
                pHardDisk->DevicePath,
                PartitionOrdinal,
                &Handle,
                TRUE
                );

    if(!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "SETUP: SpFatFormat: unable to open %ws partition %u (%lx)\n",
            pHardDisk->DevicePath,
            PartitionOrdinal,
            Status
            ));

        return(Status);
    }

    //
    //  Lock the drive
    //
    Status = SpLockUnlockVolume( Handle, TRUE );

    //
    //  We shouldn't have any file opened that would cause this volume
    //  to already be locked, so if we get failure (ie, STATUS_ACCESS_DENIED)
    //  something is really wrong.  This typically indicates something is
    //  wrong with the hard disk that won't allow us to access it.
    //
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpFatFormat: status %lx, unable to lock drive \n",Status));
        ZwClose(Handle);
        return(Status);
    }

    bad_sectors = NULL;

    FmtVerifySectors(
        Handle,
        ActualSectorCount,
        BytesPerSector,
        &bad_sectors,
        &num_bad_sectors
        );

    max_sec_per_sa = 1 +
                     2*((2*65536 - 1)/BytesPerSector + 1) +
                     ((512*32 - 1)/BytesPerSector + 1);


    unaligned_format_buffer = SpMemAlloc(max_sec_per_sa*BytesPerSector);
    ASSERT(unaligned_format_buffer);
    format_buffer = ALIGN(unaligned_format_buffer,BytesPerSector);

    Status = FmtFillFormatBuffer(
                ActualSectorCount,
                BytesPerSector,
                pHardDisk->Geometry.SectorsPerTrack,
                pHardDisk->Geometry.TracksPerCylinder,
                hidden_sectors,
                format_buffer,
                max_sec_per_sa*BytesPerSector,
                &super_area_size,
                bad_sectors,
                num_bad_sectors,
                &SysId
                );

    if(bad_sectors) {
        SpMemFree(bad_sectors);
    }

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpFatFormat: status %lx from FmtFillFormatBuffer\n",Status));
        SpLockUnlockVolume( Handle, FALSE );
        ZwClose(Handle);
        SpMemFree(unaligned_format_buffer);
        return(Status);
    }

    //
    // Write the super area.
    //
    LargeZero.QuadPart = 0;
    Status = ZwWriteFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                format_buffer,
                super_area_size,
                &LargeZero,
                NULL
                );

    //
    // I/O should be synchronous.
    //
    ASSERT(Status != STATUS_PENDING);

    SpMemFree(unaligned_format_buffer);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpFatFormat: status %lx from ZwWriteFile\n",Status));
        SpLockUnlockVolume( Handle, FALSE );
        ZwClose(Handle);
        return(Status);
    }

    //
    // If we wrote the super area then the drive is now FAT!
    // If we don't change, say, a type of ntfs to fat, then code
    // that lays down the amd64/x86 boot code (*\bootini.c) will
    // come along and write 16 sectors of NTFS boot code into
    // sector 0 of our nice FAT volume -- very bad!
    // Preserve the filesystem type of FilesystemNewlyCreated
    // since other code later in setup relies on this.
    //
    if(Region->Filesystem >= FilesystemFirstKnown) {
        Region->Filesystem = FilesystemFat;
    }

    //
    // Set the partition type.
    //
    PartitionInfo.PartitionType = SysId;

    Status = ZwDeviceIoControlFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_DISK_SET_PARTITION_INFO,
                &PartitionInfo,
                sizeof(PartitionInfo),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to set partition type (status = %lx)\n",Status));
    }

    //
    // Dismount the drive
    //
    Status = SpDismountVolume( Handle );
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpFatFormat: status %lx, unable to dismount drive\n",Status));
        SpLockUnlockVolume( Handle, FALSE );
        ZwClose(Handle);
        return(Status);
    }

    //
    // Unlock the drive
    //
    Status = SpLockUnlockVolume( Handle, FALSE );
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpFatFormat: status %lx, unable to unlock drive\n",Status));
    }

    ZwClose(Handle);
    return(Status);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spdsputl.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spvideo.h

Abstract:

    Public header file for text setup display utilitiy functions.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/


#ifndef _SPDSPUTL_DEFN_
#define _SPDSPUTL_DEFN_


#define HEADER_HEIGHT 3
#define STATUS_HEIGHT 1
#define CLIENT_HEIGHT (VideoVars.ScreenHeight - (HEADER_HEIGHT+STATUS_HEIGHT))
#define CLIENT_TOP    HEADER_HEIGHT


#define CLEAR_ENTIRE_SCREEN()                       \
                                                    \
    SpvidClearScreenRegion(                         \
        0,                                          \
        0,                                          \
        0,                                          \
        0,                                          \
        DEFAULT_BACKGROUND                          \
        )

#define CLEAR_CLIENT_SCREEN()                       \
                                                    \
    SpvidClearScreenRegion(                         \
        0,                                          \
        HEADER_HEIGHT,                              \
        VideoVars.ScreenWidth,                      \
        VideoVars.ScreenHeight-(HEADER_HEIGHT+STATUS_HEIGHT), \
        DEFAULT_BACKGROUND                          \
        )

#define CLEAR_HEADER_SCREEN()                       \
                                                    \
    SpvidClearScreenRegion(                         \
        0,                                          \
        0,                                          \
        VideoVars.ScreenWidth,                      \
        HEADER_HEIGHT,                              \
        DEFAULT_BACKGROUND                          \
        )



ULONG
SpDisplayText(
    IN PWCHAR  Message,
    IN ULONG   MsgLen,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    IN ULONG   X,
    IN ULONG   Y
    );


ULONG
vSpDisplayFormattedMessage(
    IN ULONG   MessageId,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    IN ULONG   X,
    IN ULONG   Y,
    IN va_list arglist
    );


ULONG
SpDisplayFormattedMessage(
    IN ULONG   MessageId,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    IN ULONG   X,
    IN ULONG   Y,
    ...
    );


VOID
SpStartScreen(
    IN ULONG   MessageId,
    IN ULONG   LeftMargin,
    IN ULONG   TopLine,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    ...
    );


VOID
SpContinueScreen(
    IN ULONG   MessageId,
    IN ULONG   LeftMargin,
    IN ULONG   SpacingLines,
    IN BOOLEAN CenterHorizontally,
    IN UCHAR   Attribute,
    ...
    );


VOID
SpBugCheck(
    IN ULONG BugCode,
    IN ULONG Param1,
    IN ULONG Param2,
    IN ULONG Param3
    );


VOID
SpDisplayRawMessage(
    IN ULONG   MessageId,
    IN ULONG   SpacingLines,
    ...
    );


#define SpDisplayScreen(MessageId,LeftMargin,TopLine)   \
                                                        \
    SpStartScreen(                                      \
        MessageId,                                      \
        LeftMargin,                                     \
        TopLine,                                        \
        FALSE,                                          \
        FALSE,                                          \
        DEFAULT_ATTRIBUTE                               \
        )


//
// As messages are built on on-screen, with SpStartScreen and
// SpContinueScreen, this value remembers where
// the next message in the screen should be placed.
//
extern ULONG NextMessageTopLine;


VOID
SpDisplayHeaderText(
    IN ULONG   MessageId,
    IN UCHAR   Attribute
    );


VOID
SpDisplayStatusText(
    IN ULONG   MessageId,
    IN UCHAR   Attribute,
    ...
    );

VOID
SpCmdConsEnableStatusText(
  IN BOOLEAN EnableStatusText
  );
    

VOID
SpDisplayStatusOptions(
    IN UCHAR Attribute,
    ...
    );

VOID
SpDisplayStatusActionLabel(
    IN ULONG ActionMessageId,   OPTIONAL
    IN ULONG FieldWidth
    );

VOID
SpDisplayStatusActionObject(
    IN PWSTR ObjectText
    );

VOID
SpDrawFrame(
    IN ULONG   LeftX,
    IN ULONG   Width,
    IN ULONG   TopY,
    IN ULONG   Height,
    IN UCHAR   Attribute,
    IN BOOLEAN DoubleLines
    );

//
// There are places where the user has to press C for custom setup, etc.
// These keystrokes are referred to as the nmemonic keys, and they must be
// localizable.  To accomplish this, the enum below indexes the SP_MNEMONICS
// message.
//
typedef enum {
    MnemonicUnused = 0,
    MnemonicCustom,             // as in "C=Custom Setup"
    MnemonicCreatePartition,    // as in "C=Create Partition"
    MnemonicDeletePartition,    // as in "D=Delete Partition"
    MnemonicContinueSetup,      // as in "C=Continue Setup"
    MnemonicFormat,             // as in "F=Format"
    MnemonicConvert,            // as in "C=Convert"
    MnemonicRemoveFiles,        // as in "R=Remove Files"
    MnemonicNewPath,            // as in "N=Different Directory"
    MnemonicSkipDetection,      // as in "S=Skip Detection"
    MnemonicScsiAdapters,       // as in "S=Specify Additional SCSI Adapter"
    MnemonicDeletePartition2,   // as in "L=Delete"
    MnemonicOverwrite,          // as in "O=Overwrite"
    MnemonicRepair,             // as in "R=Repair"
    MnemonicRepairAll,          // as in "A=Repair All"
    MnemonicUpgrade,            // as in "U=Upgrade"
    MnemonicAutomatedSystemRecovery,   // as in "A=ASR"
    MnemonicInitializeDisk,     // as in "I=Initialize Disk"
    MnemonicLocate,             // as in "L=Locate"
    MnemonicFastRepair,         // as in "F=Fast Repair"
    MnemonicManualRepair,       // as in "M=Manual Repair"
    MnemonicConsole,            // as in "C=Console"
    MnemonicChangeDiskStyle,    // as in "S=Change Disk Style"
    MnemonicMakeSystemPartition,// as in "M=Make System Partition"
    MnemonicMax
} MNEMONIC_KEYS;

#define KEY_MNEMONIC    0x80000000

extern PWCHAR MnemonicValues;

ULONG
SpWaitValidKey(
    IN const ULONG *ValidKeys1,
    IN const ULONG *ValidKeys2,  OPTIONAL
    IN const ULONG *MnemonicKeys OPTIONAL
    );

//
// Enum for values that can be retuned by a KEYRESS_CALLBACK routine.
//
typedef enum {
    ValidateAccept,
    ValidateReject,
    ValidateIgnore,
    ValidateTerminate,
    ValidateRepaint
} ValidationValue;

//
// Type for routine to be passed as ValidateKey parameter to SpGetInput().
//
typedef
ValidationValue
(*PKEYPRESS_CALLBACK) (
    IN ULONG Key
    );

BOOLEAN
SpGetInput(
    IN     PKEYPRESS_CALLBACK ValidateKey,
    IN     ULONG              X,
    IN     ULONG              Y,
    IN     ULONG              MaxLength,
    IN OUT PWCHAR             Buffer,
    IN     BOOLEAN            ValidateEscape,
    IN     WCHAR              CoverCharacter
    );

#endif // ndef _SPDSPUTL_DEFN_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spdrutil.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    spdrutil.c

Abstract:

    This module contains general utility and helper functions used by ASR
    in textmode Setup.

Authors:

    Michael Peterson, Seagate Software (v-michpe) 13-May-1997
    Guhan Suriyanarayanan (guhans)  21-Aug-1999

Environment:

    Textmode Setup, Kernel-mode.

Revision History:
    
    21-Aug-1999 guhans
        Code clean-up and re-write.

    13-May-1997 v-michpe
        Initial implementation.

--*/

#include "spprecmp.h"
#pragma hdrstop

#define THIS_MODULE L"spdrutil.c"
#define THIS_MODULE_CODE L"U"

static const PCWSTR ASR_MOUNTED_DEVICES_KEY = L"\\registry\\machine\\SYSTEM\\MountedDevices";
static const PCWSTR ASR_HKLM_SYSTEM_KEY     = L"\\registry\\machine\\SYSTEM";

#ifndef ULONGLONG_MAX
#define ULONGLONG_MAX   (0xFFFFFFFFFFFFFFFF)
#endif

//
// Caller must free the string
//
PWSTR
SpAsrGetRegionName(IN PDISK_REGION pRegion)
{
    SpNtNameFromRegion(
        pRegion,
        (PWSTR) TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    return SpDupStringW((PWSTR)TemporaryBuffer);
}


ULONG
SpAsrGetActualDiskSignature(IN ULONG DiskNumber)
{
    PHARD_DISK pDisk = &HardDisks[DiskNumber];
    ULONG Signature = 0;
    
    if (PARTITION_STYLE_MBR == (PARTITION_STYLE) pDisk->DriveLayout.PartitionStyle) {

        Signature = pDisk->DriveLayout.Mbr.Signature;
    }

    return Signature;
}

ULONGLONG
SpAsrConvertSectorsToMB(
    IN ULONGLONG SectorCount,
    IN ULONG BytesPerSector
    )
{
    ULONGLONG mb = 1024 * 1024;

    if ((ULONGLONG) (SectorCount / mb) > (ULONGLONG) (ULONGLONG_MAX / BytesPerSector)) {
        //
        // This is strange.  The sizeMB of the disk is too big to fit in 64-bits,
        // yet the SectorCount does.  This implies that this disk has more than 
        // 1 MB Per Sector.  Since this is very improbable (disks commonly have 512 
        // BytesPerSector today), we bail out with an internal error.
        // 
        DbgFatalMesg((_asrerr, "SpAsrConvertSectorsToMB. Disk has too many sectors\n"));
        INTERNAL_ERROR((L"Disk has too many sectors\n"));   // ok
    }

    return (ULONGLONG) ((SectorCount * BytesPerSector) / mb);
}

extern 
VOID
SpDeleteStorageVolumes (
    IN HANDLE SysPrepRegHandle,
    IN DWORD ControlSetNumber
    );

extern 
NTSTATUS
SpGetCurrentControlSetNumber(
    IN  HANDLE SystemHiveRoot,
    OUT PULONG Number
    );


VOID
SpAsrDeleteMountedDevicesKey(VOID)
{
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objAttrib;
    UNICODE_STRING      unicodeString;
    HANDLE              keyHandle;

    // 
    // Delete HKLM\SYSTEM\MountedDevices.
    //
    INIT_OBJA(&objAttrib, &unicodeString, ASR_MOUNTED_DEVICES_KEY);

    objAttrib.RootDirectory = NULL;

    status = ZwOpenKey(&keyHandle, KEY_ALL_ACCESS, &objAttrib);
    if(NT_SUCCESS(status)) {
        status = ZwDeleteKey(keyHandle);
        DbgStatusMesg((_asrinfo, 
            "SpAsrDeleteMountedDevicesKey. DeleteKey [%ls] on the setup hive returned 0x%lx. \n",
            ASR_MOUNTED_DEVICES_KEY, 
            status
            ));
        
        ZwClose(keyHandle);
    } 
    else {
        DbgErrorMesg((_asrwarn, 
            "SpAsrDeleteMountedDevicesKey. No [%ls] on the setup hive.\n", 
            ASR_MOUNTED_DEVICES_KEY));
    }
}


PVOID
SpAsrMemAlloc(
    ULONG Size, 
    BOOLEAN IsErrorFatal
    )
{
    PVOID ptr = SpMemAlloc(Size);

    if (ptr) {
        RtlZeroMemory(ptr, Size);
    }
    else {          // allocation failed
        if (IsErrorFatal) {
            DbgFatalMesg((_asrerr, 
                "SpAsrMemAlloc. Memory allocation failed, SpMemAlloc(%lu) returned NULL.\n",
                Size
                ));
            SpAsrRaiseFatalError(SP_SCRN_OUT_OF_MEMORY, L"Out of memory.");
        }
        else {
            DbgErrorMesg((_asrerr, 
                "SpAsrMemAlloc. Memory allocation failed, SpMemAlloc(%lu) returned NULL. Continuing.\n",
                Size
                ));
        }
    }

    return ptr;
}



BOOLEAN
SpAsrIsValidBootDrive(IN OUT PWSTR NtDir)
/*
    Returns TRUE if NtDir starts with ?:\, 
    where ? is between C and Z or c and z,
    and wcslen(NtDir) <= SpGetMaxNtDirLen().
    
    
    Converts the drive letter to uppercase.

*/
{
    if (!NtDir ||
        wcslen(NtDir) > SpGetMaxNtDirLen()
        ) {
        return FALSE;
    }



    // convert drive-letter to upper-case
    if (NtDir[0] >= L'c' && NtDir[0] <= L'z') {
        NtDir[0] = NtDir[0] - L'a' + L'A';
    }

    // check drive letter
    if (NtDir[0] < L'C' || NtDir[0] > L'Z') {
        return FALSE;
    }

    // check " :\"
    if (NtDir[1] == L':' && NtDir[2] == L'\\') {
        return TRUE;
    }

    return FALSE;
}


BOOLEAN
SpAsrIsBootPartitionRecord(IN ULONG CriticalPartitionFlag)
{
    return (BOOLEAN) (CriticalPartitionFlag & ASR_PTN_MASK_BOOT);
}


BOOLEAN
SpAsrIsSystemPartitionRecord(IN ULONG CriticalPartitionFlag)
{
    return (BOOLEAN) (CriticalPartitionFlag & ASR_PTN_MASK_SYS);
}



// Fatal Error Routines
//	-guhans! Lots of code-repitition here, there must be a more efficient way.


VOID
SpAsrRaiseFatalError(
	IN ULONG ErrorCode, 
	IN PWSTR KdPrintStr
	)
            
/*++
Routine:
  Terminate setup

Returns:

    None.
--*/
{
    KdPrintEx((_asrerr, "SETUP: + %ws\n", KdPrintStr));

    SpStartScreen(ErrorCode,
                  3,
                  HEADER_HEIGHT+1,
                  FALSE,
                  FALSE,
                  DEFAULT_ATTRIBUTE);

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                           SP_STAT_F3_EQUALS_EXIT,
                           0);
    SpInputDrain();
    
    while(SpInputGetKeypress() != KEY_F3);
    
    SpDone(0, FALSE, TRUE);
}


VOID
SpAsrRaiseFatalErrorWs(
	IN ULONG ErrorCode, 
	IN PWSTR KdPrintStr,
	IN PWSTR MessageStr
	)
{
    KdPrintEx((_asrerr, "SETUP: + %ws\n", KdPrintStr));

    SpStartScreen(ErrorCode,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        MessageStr
        );
    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_F3_EQUALS_EXIT, 0);
    SpInputDrain();
    
    while(SpInputGetKeypress() != KEY_F3);
    
    SpDone(0, FALSE, TRUE);
}

VOID
SpAsrRaiseFatalErrorWsWs(
	IN ULONG ErrorCode, 
	IN PWSTR KdPrintStr,
	IN PWSTR MessageStr1,
	IN PWSTR MessageStr2
	)
{
    KdPrintEx((_asrerr, "SETUP: + %ws\n", KdPrintStr));

    SpStartScreen(ErrorCode,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        MessageStr1,
        MessageStr2
        );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_F3_EQUALS_EXIT, 0);
    SpInputDrain();
    
    while(SpInputGetKeypress() != KEY_F3);
    
    SpDone(0, FALSE, TRUE);
}

VOID
SpAsrRaiseFatalErrorWsLu(
	IN ULONG ErrorCode, 
	IN PWSTR KdPrintStr,
	IN PWSTR MessageStr,
	IN ULONG MessageVal
	)
{
    KdPrintEx((_asrerr, "SETUP: + %ws\n", KdPrintStr));

    SpStartScreen(ErrorCode,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        MessageStr,
        MessageVal
        );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_F3_EQUALS_EXIT, 0);
    SpInputDrain();
    
    while(SpInputGetKeypress() != KEY_F3);
    
    SpDone(0, FALSE, TRUE);
}

VOID
SpAsrRaiseFatalErrorLu(
	IN ULONG ErrorCode, 
	IN PWSTR KdPrintStr,
	IN ULONG MessageVal
	)
{
    KdPrintEx((_asrerr, "SETUP: + %ws\n", KdPrintStr));

    SpStartScreen(ErrorCode,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        MessageVal
        );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_F3_EQUALS_EXIT, 0);
    SpInputDrain();
    
    while(SpInputGetKeypress() != KEY_F3);
    
    SpDone(0, FALSE, TRUE);
}

VOID
SpAsrRaiseFatalErrorLuLu(
	IN ULONG ErrorCode, 
	IN PWSTR KdPrintStr,
	IN ULONG MessageVal1,
	IN ULONG MessageVal2
	)
{
    KdPrintEx((_asrerr, "SETUP: + %ws\n", KdPrintStr));

    SpStartScreen(ErrorCode,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        MessageVal1,
        MessageVal2
        );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_F3_EQUALS_EXIT, 0);
    SpInputDrain();
    
    while(SpInputGetKeypress() != KEY_F3);
    
    SpDone(0, FALSE, TRUE);
}


#define ASCI_O 79
#define ASCI_o 111

//
// SpAsrFileErrorRetryIgnoreAbort
//  Display an error screen if the file that we are trying to
//  copy already exists on target system.  Allows user to
//  O   = Over-write existing file
//  ESC = Skip this file (preserve existing file)
//  F3  = Exit from Setup
//
//  Returns TRUE if the user chose overwrite
//          FALSE if the user chose skip
//  Does not return if the user hit ESC
//
BOOL
SpAsrFileErrorDeleteSkipAbort(
	IN ULONG ErrorCode, 
	IN PWSTR DestinationFile
    )
{
    ULONG optionKeys[] = {KEY_F3, ASCI_ESC};
    ULONG mnemonicKeys[] = {MnemonicOverwrite, 0};
    ULONG *keysPtr;
    BOOL done = FALSE, 
        overwriteFile = FALSE;

    while (!done) {

        SpStartScreen(
            ErrorCode,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            DestinationFile
            );

        keysPtr = optionKeys;

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_O_EQUALS_OVERWRITE,
            SP_STAT_ESC_EQUALS_SKIP_FILE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        SpInputDrain();
    
        switch(SpWaitValidKey(keysPtr,NULL,mnemonicKeys)) {
            case (MnemonicOverwrite | KEY_MNEMONIC):
                overwriteFile = TRUE;
                done = TRUE;
                break;

            case ASCI_ESC:
                overwriteFile = FALSE;
                done = TRUE;
                break;

            case KEY_F3:
                SpDone(0, FALSE, TRUE);
                break;

        }
    }

    return overwriteFile;
}


//
// SpAsrFileErrorRetryIgnoreAbort
//  Display an error screen if the file could not be copied
//  over to the target system.  Allows user to
//  ENTER   = Retry
//  ESC     = Skip this file and continue
//  F3      = Exit from Setup
//
//  Returns TRUE if the user chose skip
//          FALSE if the user chose retry
//  Does not return if the user hit ESC
//
BOOL
SpAsrFileErrorRetrySkipAbort(
	IN ULONG ErrorCode, 
	IN PWSTR SourceFile,
    IN PWSTR Label,
    IN PWSTR Vendor,
    IN BOOL  AllowSkip
    )
{
    ULONG optionKeys[] = {KEY_F3, ASCI_CR, ASCI_ESC};
    ULONG mnemonicKeys[] = {0};
    ULONG *keysPtr;
    BOOL    done     = FALSE, 
            skipFile = FALSE;

    while (!done) {

        SpStartScreen(
            ErrorCode,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            SourceFile,
            Label,
            Vendor);

        keysPtr = optionKeys;

        if (AllowSkip) {
            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_RETRY,
                SP_STAT_ESC_EQUALS_SKIP_FILE,
                SP_STAT_F3_EQUALS_EXIT,
                0);
        }
        else {
            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_RETRY,
                SP_STAT_F3_EQUALS_EXIT,
                0);
        }

        SpInputDrain();
    
        switch(SpWaitValidKey(keysPtr,NULL,mnemonicKeys)) {
            case ASCI_CR:
                skipFile = FALSE;
                done = TRUE;
                break;

            case ASCI_ESC:
                if (AllowSkip) {
                    skipFile = TRUE;
                    done = TRUE;
                }
                break;

            case KEY_F3:
                SpDone(0, FALSE, TRUE);
                break;

        }
    }

    return skipFile;
}


VOID
SpAsrRaiseInternalError(
    IN  PWSTR   ModuleName,
    IN  PWSTR   ModuleCode,
    IN  ULONG   LineNumber,
    IN  PWSTR   KdPrintStr)
{
    PWSTR TmpMsgBuf = SpAsrMemAlloc(4096 * sizeof(WCHAR), TRUE);
    swprintf(TmpMsgBuf, L"%ws%lu", ModuleCode, LineNumber);

    DbgFatalMesg((_asrerr, 
        " Internal Error (%ws:%lu %ws) %ws\n", 
        ModuleName,
        LineNumber,
        TmpMsgBuf,
        KdPrintStr
        ));

    SpAsrRaiseFatalErrorWs(SP_TEXT_DR_INTERNAL_ERROR,
       KdPrintStr,
       TmpMsgBuf
       );
    //
    // Never gets here
    //

}


ULONGLONG
SpAsrStringToULongLong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    )
{
    PWSTR p;
    BOOLEAN Negative;
    ULONGLONG Accum,v;
    WCHAR HighestDigitAllowed,HighestLetterAllowed;
    WCHAR c;

    //
    // Validate radix, 0 or 2-36.
    //
    if((Radix == 1) || (Radix > 36)) {
        if(EndOfValue) {
            *EndOfValue = String;
        }
        return(0);    
    }
    
    p = String;

    //
    // Skip whitespace.
    //
    while(SpIsSpace(*p)) {
        p++;
    }

    //
    // First char may be a plus or minus.
    //
    Negative = FALSE;
    if(*p == L'-') {
        Negative = TRUE;            
        p++;
    } else {
        if(*p == L'+') {
            p++;
        }
    }

    if(!Radix) {
        if(*p == L'0') {
            //
            // Octal number
            //
            Radix = 8;
            p++;
            if((*p == L'x') || (*p == L'X')) {
                //
                // hex number
                //
                Radix = 16;
                p++;
            }
        } else {
            Radix = 10;
        }
    }

    HighestDigitAllowed = (Radix < 10) ? L'0'+(WCHAR)(Radix-1) : L'9';
    HighestLetterAllowed = (Radix > 10) ? L'A'+(WCHAR)(Radix-11) : 0;

    Accum = 0;

    while(1) {

        c = *p;

        if((c >= L'0') && (c <= HighestDigitAllowed)) {
            v = c - L'0';
        } else {

            c = SpToUpper(c);

            if((c >= L'A') && (c <= HighestLetterAllowed)) {
                v = c - L'A' + 10;
            } else {
                break;
            }
        }

        Accum *= Radix;
        Accum += v;

        p++;
    }

    if(EndOfValue) {
        *EndOfValue = p;
    }

    return(Negative ? (0-Accum) : Accum);
}

LONGLONG
SpAsrStringToLongLong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    )
{
    PWSTR p;
    BOOLEAN Negative;
    LONGLONG Accum,v;
    WCHAR HighestDigitAllowed,HighestLetterAllowed;
    WCHAR c;

    //
    // Validate radix, 0 or 2-36.
    //
    if((Radix == 1) || (Radix > 36)) {
        if(EndOfValue) {
            *EndOfValue = String;
        }
        return(0);    
    }
    
    p = String;

    //
    // Skip whitespace.
    //
    while(SpIsSpace(*p)) {
        p++;
    }

    //
    // First char may be a plus or minus.
    //
    Negative = FALSE;
    if(*p == L'-') {
        Negative = TRUE;            
        p++;
    } else {
        if(*p == L'+') {
            p++;
        }
    }

    if(!Radix) {
        if(*p == L'0') {
            //
            // Octal number
            //
            Radix = 8;
            p++;
            if((*p == L'x') || (*p == L'X')) {
                //
                // hex number
                //
                Radix = 16;
                p++;
            }
        } else {
            Radix = 10;
        }
    }

    HighestDigitAllowed = (Radix < 10) ? L'0'+(WCHAR)(Radix-1) : L'9';
    HighestLetterAllowed = (Radix > 10) ? L'A'+(WCHAR)(Radix-11) : 0;

    Accum = 0;

    while(1) {

        c = *p;

        if((c >= L'0') && (c <= HighestDigitAllowed)) {
            v = c - L'0';
        } else {

            c = SpToUpper(c);

            if((c >= L'A') && (c <= HighestLetterAllowed)) {
                v = c - L'A' + 10;
            } else {
                break;
            }
        }

        Accum *= Radix;
        Accum += v;

        p++;
    }

    if(EndOfValue) {
        *EndOfValue = p;
    }

    return(Negative ? (0-Accum) : Accum);
}

ULONG
SpAsrStringToULong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    )
{
    PWSTR p;
    BOOLEAN Negative;
    ULONG Accum,v;
    WCHAR HighestDigitAllowed,HighestLetterAllowed;
    WCHAR c;

    //
    // Validate radix, 0 or 2-36.
    //
    if((Radix == 1) || (Radix > 36)) {
        if(EndOfValue) {
            *EndOfValue = String;
        }
        return(0);    
    }
    
    p = String;

    //
    // Skip whitespace.
    //
    while(SpIsSpace(*p)) {
        p++;
    }

    //
    // First char may be a plus or minus.
    //
    Negative = FALSE;
    if(*p == L'-') {
        Negative = TRUE;            
        p++;
    } else {
        if(*p == L'+') {
            p++;
        }
    }

    if(!Radix) {
        if(*p == L'0') {
            //
            // Octal number
            //
            Radix = 8;
            p++;
            if((*p == L'x') || (*p == L'X')) {
                //
                // hex number
                //
                Radix = 16;
                p++;
            }
        } else {
            Radix = 10;
        }
    }

    HighestDigitAllowed = (Radix < 10) ? L'0'+(WCHAR)(Radix-1) : L'9';
    HighestLetterAllowed = (Radix > 10) ? L'A'+(WCHAR)(Radix-11) : 0;

    Accum = 0;

    while(1) {

        c = *p;

        if((c >= L'0') && (c <= HighestDigitAllowed)) {
            v = c - L'0';
        } else {

            c = SpToUpper(c);

            if((c >= L'A') && (c <= HighestLetterAllowed)) {
                v = c - L'A' + 10;
            } else {
                break;
            }
        }

        Accum *= Radix;
        Accum += v;

        p++;
    }

    if(EndOfValue) {
        *EndOfValue = p;
    }

    return(Negative ? (0-Accum) : Accum);
}


USHORT
SpAsrStringToUShort(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  USHORT    Radix
    )
{
    PWSTR p;
    BOOLEAN Negative;
    USHORT Accum,v;
    WCHAR HighestDigitAllowed,HighestLetterAllowed;
    WCHAR c;

    //
    // Validate radix, 0 or 2-36.
    //
    if((Radix == 1) || (Radix > 36)) {
        if(EndOfValue) {
            *EndOfValue = String;
        }
        return(0);    
    }
    
    p = String;

    //
    // Skip whitespace.
    //
    while(SpIsSpace(*p)) {
        p++;
    }

    //
    // First char may be a plus or minus.
    //
    Negative = FALSE;
    if(*p == L'-') {
        Negative = TRUE;            
        p++;
    } else {
        if(*p == L'+') {
            p++;
        }
    }

    if(!Radix) {
        if(*p == L'0') {
            //
            // Octal number
            //
            Radix = 8;
            p++;
            if((*p == L'x') || (*p == L'X')) {
                //
                // hex number
                //
                Radix = 16;
                p++;
            }
        } else {
            Radix = 10;
        }
    }

    HighestDigitAllowed = (Radix < 10) ? L'0'+(WCHAR)(Radix-1) : L'9';
    HighestLetterAllowed = (Radix > 10) ? L'A'+(WCHAR)(Radix-11) : 0;

    Accum = 0;

    while(1) {

        c = *p;

        if((c >= L'0') && (c <= HighestDigitAllowed)) {
            v = c - L'0';
        } else {

            c = SpToUpper(c);

            if((c >= L'A') && (c <= HighestLetterAllowed)) {
                v = c - L'A' + 10;
            } else {
                break;
            }
        }

        Accum *= Radix;
        Accum += v;

        p++;
    }

    if(EndOfValue) {
        *EndOfValue = p;
    }

    return(Negative ? (0-Accum) : Accum);
}


int
SpAsrCharToInt(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  USHORT    Radix
    )
{
    PWSTR p;
    BOOLEAN Negative;
    USHORT Accum,v;
    WCHAR HighestDigitAllowed,HighestLetterAllowed;
    WCHAR c;

    //
    // Validate radix, 0 or 2-36.
    //
    if((Radix == 1) || (Radix > 36)) {
        if(EndOfValue) {
            *EndOfValue = String;
        }
        return(0);    
    }
    
    p = String;

    //
    // Skip whitespace.
    //
    while(SpIsSpace(*p)) {
        p++;
    }

    //
    // First char may be a plus or minus.
    //
    Negative = FALSE;
    if(*p == L'-') {
        Negative = TRUE;            
        p++;
    } else {
        if(*p == L'+') {
            p++;
        }
    }

    if(!Radix) {
        if(*p == L'0') {
            //
            // Octal number
            //
            Radix = 8;
            p++;
            if((*p == L'x') || (*p == L'X')) {
                //
                // hex number
                //
                Radix = 16;
                p++;
            }
        } else {
            Radix = 10;
        }
    }

    HighestDigitAllowed = (Radix < 10) ? L'0'+(WCHAR)(Radix-1) : L'9';
    HighestLetterAllowed = (Radix > 10) ? L'A'+(WCHAR)(Radix-11) : 0;

    Accum = 0;

    while(1) {

        c = *p;

        if((c >= L'0') && (c <= HighestDigitAllowed)) {
            v = c - L'0';
        } else {

            c = SpToUpper(c);

            if((c >= L'A') && (c <= HighestLetterAllowed)) {
                v = c - L'A' + 10;
            } else {
                break;
            }
        }

        Accum *= Radix;
        Accum += v;

        p++;
    }

    if(EndOfValue) {
        *EndOfValue = p;
    }

    return(Negative ? (0-Accum) : Accum);
}


PWSTR
SpAsrHexStringToUChar (
    IN PWSTR String,
    OUT unsigned char * Number
    )
/*++
Routine Description:

    This routine converts the hex representation of a number into an
    unsigned char.  The hex representation is assumed to be a full
    two characters long.

Arguments:

    String - Supplies the hex representation of the number.

    Number - Returns the number converted from hex representation.

Return Value:

    A pointer to the end of the hex representation is returned if the
    hex representation was successfully converted to an unsigned char.
    Otherwise, zero is returned, indicating that an error occured.

--*/
{
    WCHAR Result;
    int Count;

    Result = 0;
    for (Count = 0; Count < 2; Count++, String++) {
        if ((*String >= L'0') && (*String <= L'9')) {
            Result = (Result << 4) + *String - L'0';
        }
        else if ((*String >= L'A') && (*String <= L'F')) {
            Result = (Result << 4) + *String - L'A' + 10;
        }
        else if ((*String >= L'a') && (*String <= L'f')) {
            Result = (Result << 4) + *String - L'a' + 10;
        }
    }
    *Number = (unsigned char)Result;
    
    return String;
}


VOID
SpAsrGuidFromString(
    IN OUT GUID* Guid,
    IN PWSTR GuidString
    )
/*++

Routine Description:

  Gets a GUID from a string
    
Arguments:

    Guid    -   The GUID that holds string representation
    Buffer  -   The string version of the guid, in the form
    "%x-%x-%x-%x%x%x%x%x%x%x%x"

Return Value:

    Returns the converted string version of the given GUID

--*/            
{
    PWSTR Buffer = GuidString;
    int i = 0;

    if (Guid) {
        ZeroMemory(Guid, sizeof(GUID));
    }

    if (Guid && Buffer) {

        Guid->Data1 = SpAsrStringToULong(Buffer, NULL, 16);
        Buffer += 9;

        Guid->Data2 = SpAsrStringToUShort(Buffer, NULL, 16);
        Buffer += 5;

        Guid->Data3 = SpAsrStringToUShort(Buffer, NULL, 16);
        Buffer += 5;

        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[0]));
        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[1]));
        ++Buffer;
        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[2]));
        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[3]));
        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[4]));
        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[5]));
        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[6]));
        Buffer = SpAsrHexStringToUChar(Buffer,&(Guid->Data4[7]));
    }
}


BOOLEAN
SpAsrIsZeroGuid(
    IN GUID * Guid
    ) 
{

    GUID ZeroGuid;

    ZeroMemory(&ZeroGuid, sizeof(GUID));

    if (!memcmp(&ZeroGuid, Guid, sizeof(GUID))) {
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spdsputl.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spdsputl.c

Abstract:

    Display utility routines for text setup.

Author:

    Ted Miller (tedm) 12-Aug-1993

Revision History:

--*/



#include "spprecmp.h"
#pragma hdrstop

extern BOOLEAN ForceConsole;
BOOLEAN DisableCmdConsStatusText = TRUE;

//
// This value will hold the localized mnemonic keys,
// in order indicated by the MNEMONIC_KEYS enum.
//
PWCHAR MnemonicValues;


//
// As messages are built on on-screen, this value remembers where
// the next message in the screen should be placed.
//
ULONG NextMessageTopLine = 0;


ULONG
SpDisplayText(
    IN PWCHAR  Message,
    IN ULONG   MsgLen,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    IN ULONG   X,
    IN ULONG   Y
    )

/*++

Routine Description:

    Worker routine for vSpDisplayFormattedMessage().

Arguments:

    Message - supplies message text.

    MsgLen - supplies the number of unicode characters in the message,
        including the terminating nul.

    CenterHorizontally - if TRUE, each line will be centered horizontally
        on the screen.

    Attribute - supplies attributes for text.

    X - supplies the x coordinate (0-based) for the left margin of the text.
        If the text spans multiple line, all will start at this coordinate.

    Y - supplies the y coordinate (0-based) for the first line of
        the text.

    arglist - supply arguments gfor insertion into the given message.

Return Value:

    Number of lines the text took up on the screen, unless CenterVertically
    is TRUE, in which case n is the line number of the first line below where
    the text was displayed.

--*/

{
    PWCHAR p,q;
    WCHAR c;
    ULONG y;
    int i;

    //
    // Must have at least one char + terminating nul in there.
    //
    if(MsgLen <= 1) {
        return(CenterVertically ? (VideoVars.ScreenHeight/2) : 0);
    }

    //
    // MsgLen includes terminating nul.
    //
    p = Message + MsgLen - 1;

    //
    // Find last non-space char in message.
    //
    while((p > Message) && SpIsSpace(*(p-1))) {
        p--;
    }

    //
    // Find end of the last significant line and terminate the message
    // after it.
    //
    if(q = wcschr(p,L'\n')) {
        *(++q) = 0;
    }

    for(i = (CenterVertically ? 0 : 1); i<2; i++) {

        for(y=Y, p=Message; q = SpFindCharFromListInString(p,L"\n\r"); y++) {

            c = *q;
            *q = 0;

            if(i) {

                BOOLEAN Intense = (BOOLEAN)((p[0] == L'%') && (p[1] == L'I'));

                SpvidDisplayString(
                    Intense ? p+2 : p,
                    (UCHAR)(Attribute | (Intense ? ATT_FG_INTENSE : 0)),
                    CenterHorizontally
                        ? (VideoVars.ScreenWidth-(SplangGetColumnCount(p)-(Intense ? 2 : 0)))/2 : X,
                    y
                    );
            }

            *q = c;

            //
            // If cr/lf terminated the line, make sure we skip both chars.
            //
            if((c == L'\r') && (*(q+1) == L'\n')) {
                q++;
            }

            p = ++q;
        }

        //
        // Write the final line (if there is one).
        //
        if(i) {
            if(wcslen(p)) {
                SpvidDisplayString(
                    p,
                    Attribute,
                    CenterHorizontally ? (VideoVars.ScreenWidth-SplangGetColumnCount(p))/2 : X,
                    y++
                    );
            }
        }

        if(i == 0) {
            //
            // Center the text on the screen (not within the client area).
            //
            Y = (VideoVars.ScreenHeight - (y-Y)) / 2;
        }
    }

    return(CenterVertically ? y : (y-Y));
}


ULONG
vSpDisplayFormattedMessage(
    IN ULONG   MessageId,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    IN ULONG   X,
    IN ULONG   Y,
    IN va_list arglist
    )

/*++

Routine Description:

    A formatted multiline message may be displayed with this routine.
    The format string is fetched from setup's text resources; arguments
    are substituted into the format string according to FormatMessage
    semantics.

    The screen is NOT cleared by this routine.

    If a line starts with %I (ie, the first 2 characters at the
    start of the message, or after a newline), it will be displayed
    with the intensity attribute on.

Arguments:

    MessageId - supplies id of message resource containing the text,
        which is treated as a format string for FormatMessage.

    CenterHorizontally - if TRUE, each line will be centered horizontally
        on the screen.

    Attribute - supplies attributes for text.

    X - supplies the x coordinate (0-based) for the left margin of the text.
        If the text spans multiple line, all will start at this coordinate.

    Y - supplies the y coordinate (0-based) for the first line of
        the text.

    arglist - supply arguments gfor insertion into the given message.

Return Value:

    Number of lines the text took up on the screen, unless CenterVertically
    is TRUE, in which case n is the line number of the first line below where
    the text was displayed.

--*/

{
    ULONG BytesInMsg;
    ULONG n;

    vSpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),MessageId,&BytesInMsg,&arglist);

    //
    // Must have at least one char + terminating nul in there.
    //
    if(BytesInMsg <= sizeof(WCHAR)) {
        return(CenterVertically ? (VideoVars.ScreenHeight/2) : 0);
    }

    n = SpDisplayText(
            TemporaryBuffer,
            BytesInMsg / sizeof(WCHAR),
            CenterHorizontally,
            CenterVertically,
            Attribute,
            X,
            Y
            );

    return(n);
}



ULONG
SpDisplayFormattedMessage(
    IN ULONG   MessageId,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    IN ULONG   X,
    IN ULONG   Y,
    ...
    )

/*++

Routine Description:

    Display a message on the screen.  Does not clear the screen first.

Arguments:

    MessageId - supplies id of message resource containing the text,
        which is treated as a format string for FormatMessage.

    CenterHorizontally - if TRUE, each line will be centered horizontally
        on the screen.

    Attribute - supplies attributes for text.

    X - supplies the x coordinate (0-based) for the left margin of the text.
        If the text spans multiple line, all will start at this coordinate.

    Y - supplies the y coordinate (0-based) for the first line of
        the text.

    ... - supply arguments gfor insertion into the given message.

Return Value:

    Number of lines the text took up on the screen.

--*/

{
    va_list arglist;
    ULONG   n;

    va_start(arglist,Y);

    n = vSpDisplayFormattedMessage(
            MessageId,
            CenterHorizontally,
            CenterVertically,
            Attribute,
            X,
            Y,
            arglist
            );

    va_end(arglist);

    return(n);
}




VOID
SpDisplayHeaderText(
    IN ULONG   MessageId,
    IN UCHAR   Attribute
    )

/*++

Routine Description:

    Display text in the header area of the screen. The header area will be
    cleared to the given attribute before displaying the text. We will
    draw a double-underline under the text also.

Arguments:

    MessageId - supplies id of message resource containing the text.

    Attribute - supplies attributes for text.

Return Value:

    none.

--*/

{
    ULONG Length,i;
    WCHAR Underline;
    WCHAR *p;

    SpvidClearScreenRegion(0,0,VideoVars.ScreenWidth,HEADER_HEIGHT,(UCHAR)(Attribute >> 4));

    //
    // Get message and display at (1,1)
    //
    vSpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),MessageId,NULL,NULL);
    p = (WCHAR *)TemporaryBuffer;
    SpvidDisplayString(p,Attribute,1,1);

    //
    // Build a row of underline characters.
    //
    Length = SplangGetColumnCount(p) + 2;
    Underline = SplangGetLineDrawChar(LineCharDoubleHorizontal);

    for(i=0; i<Length; i++) {
        p[i] = Underline;
    }
    p[Length] = 0;

    SpvidDisplayString(p,Attribute,0,2);

}


#define MAX_STATUS_ACTION_LABEL 50
WCHAR StatusActionLabel[MAX_STATUS_ACTION_LABEL];
ULONG StatusActionLeftX;
ULONG StatusActionObjectX;
BOOLEAN StatusActionLabelDisplayed = FALSE;

VOID
SpDisplayStatusActionLabel(
    IN ULONG ActionMessageId,   OPTIONAL
    IN ULONG FieldWidth
    )
{
    ULONG l;

    if(ActionMessageId) {
        //
        // Prefix the text with a separating vertical bar.
        //
        StatusActionLabel[0] = SplangGetLineDrawChar(LineCharSingleVertical);

        //
        // Fetch the action verb (something like "Copying:")
        //
        SpFormatMessage(
            StatusActionLabel+1,
            sizeof(StatusActionLabel)-sizeof(WCHAR),
            ActionMessageId
            );

        //
        // Now calculate the position on the status line
        // for the action label.  We want to leave 1 space
        // between the colon and the object, and a space between
        // the object and the rightmost column on the screen.
        //
        l = SplangGetColumnCount(StatusActionLabel);

        StatusActionObjectX = VideoVars.ScreenWidth - FieldWidth - 1;
        StatusActionLeftX = StatusActionObjectX - l - 1;

        //
        // Display the label and clear out the rest of the line.
        //
        SpvidDisplayString(
            StatusActionLabel,
            DEFAULT_STATUS_ATTRIBUTE,
            StatusActionLeftX,
            VideoVars.ScreenHeight-STATUS_HEIGHT
            );

        SpvidClearScreenRegion(
            StatusActionObjectX-1,
            VideoVars.ScreenHeight-STATUS_HEIGHT,
            VideoVars.ScreenWidth-StatusActionObjectX+1,
            STATUS_HEIGHT,
            DEFAULT_STATUS_BACKGROUND
            );

        StatusActionLabelDisplayed = TRUE;
    } else {
        //
        // Caller wants to clear out the previous area.
        //
        StatusActionLabel[0] = 0;
        SpvidClearScreenRegion(
            StatusActionLeftX,
            VideoVars.ScreenHeight-STATUS_HEIGHT,
            VideoVars.ScreenWidth-StatusActionLeftX,
            STATUS_HEIGHT,
            DEFAULT_STATUS_BACKGROUND
            );
        StatusActionLabelDisplayed = FALSE;
    }
}

VOID
SpDisplayStatusActionObject(
    IN PWSTR ObjectText
    )
{
    //
    // clear the area and draw the text.
    //
    SpvidClearScreenRegion(
        StatusActionObjectX,
        VideoVars.ScreenHeight-STATUS_HEIGHT,
        VideoVars.ScreenWidth-StatusActionObjectX,
        STATUS_HEIGHT,
        DEFAULT_STATUS_BACKGROUND
        );

    SpvidDisplayString(
        ObjectText,
        DEFAULT_STATUS_ATTRIBUTE,
        StatusActionObjectX,
        VideoVars.ScreenHeight-STATUS_HEIGHT
        );
}

VOID
SpCmdConsEnableStatusText(
  IN BOOLEAN EnableStatusText
  )
{
  DisableCmdConsStatusText = !EnableStatusText;
}


VOID
SpDisplayStatusText(
    IN ULONG   MessageId,
    IN UCHAR   Attribute,
    ...
    )
{
    va_list arglist;

    if (ForceConsole && DisableCmdConsStatusText) {
        return;
    }

    SpvidClearScreenRegion(
        0,
        VideoVars.ScreenHeight-STATUS_HEIGHT,
        VideoVars.ScreenWidth,
        STATUS_HEIGHT,
        (UCHAR)(Attribute >> 4)      // background part of attribute
        );

    va_start(arglist,Attribute);

    vSpDisplayFormattedMessage(
        MessageId,
        FALSE,FALSE,            // no centering
        Attribute,
        2,
        VideoVars.ScreenHeight-STATUS_HEIGHT,
        arglist
        );

    va_end(arglist);
}


VOID
SpDisplayStatusOptions(
    IN UCHAR Attribute,
    ...
    )
{
    WCHAR StatusText[79];
    WCHAR Option[79];
    va_list arglist;
    ULONG MessageId;


    StatusText[0] = 0;

    va_start(arglist,Attribute);

    while(MessageId = va_arg(arglist,ULONG)) {

        //
        // Fetch the message text for this option.
        //
        Option[0] = 0;
        SpFormatMessage(Option,sizeof(Option),MessageId);

        //
        // If the option fits, place it in the status text line we're
        // building up.
        //
        if((SplangGetColumnCount(StatusText) + SplangGetColumnCount(Option) + 2)
                                                     < (sizeof(StatusText)/sizeof(StatusText[0]))) {
            wcscat(StatusText,L"  ");
            wcscat(StatusText,Option);
        }
    }

    va_end(arglist);

    //
    // Display the text.
    //

    SpvidClearScreenRegion(
        0,
        VideoVars.ScreenHeight-STATUS_HEIGHT,
        VideoVars.ScreenWidth,
        STATUS_HEIGHT,
        (UCHAR)(Attribute >> (UCHAR)4)      // background part of attribute
        );

    SpvidDisplayString(StatusText,Attribute,0,VideoVars.ScreenHeight-STATUS_HEIGHT);
}



VOID
SpStartScreen(
    IN ULONG   MessageId,
    IN ULONG   LeftMargin,
    IN ULONG   TopLine,
    IN BOOLEAN CenterHorizontally,
    IN BOOLEAN CenterVertically,
    IN UCHAR   Attribute,
    ...
    )

/*++

Routine Description:

    Display a formatted message on the screen, treating it as the first
    message in what might be a multi-message screen.

    The client area of the screen will be cleared before displaying the message.

Arguments:

    MessageId - supplies id of message resource containing the text.

    LeftMargin - supplies the 0-based x-coordinate for the each line of the text.

    TopLine - supplies the 0-based y-coordinate for the topmost line of the text.

    CenterHorizontally - if TRUE, each line in the message will be printed
        centered horizontally.  In this case, LeftMargin is ignored.

    CenterVertically - if TRUE, the message will approximately centered vertically
        within the client area of the screen.  In this case, TopLine is ignored.

    Attribute - supplies attribute for text.

    ... - supply arguments for insertion/substitution into the message text.

Return Value:

    none.

--*/

{
    va_list arglist;
    ULONG   n;

    CLEAR_CLIENT_SCREEN();

    va_start(arglist,Attribute);

    n = vSpDisplayFormattedMessage(
            MessageId,
            CenterHorizontally,
            CenterVertically,
            Attribute,
            LeftMargin,
            TopLine,
            arglist
            );

    va_end(arglist);

    //
    // Remember where the message ended.
    //
    NextMessageTopLine = CenterVertically ? n : TopLine+n;
}



VOID
SpContinueScreen(
    IN ULONG   MessageId,
    IN ULONG   LeftMargin,
    IN ULONG   SpacingLines,
    IN BOOLEAN CenterHorizontally,
    IN UCHAR   Attribute,
    ...
    )

/*++

Routine Description:

    Display a formatted message on the screen, treating it as the continuation
    of a multi-message screen previously begun by calling SpStartScreen().
    The message will be placed under the previously displayed message.

Arguments:

    MessageId - supplies id of message resource containing the text.

    LeftMargin - supplies the 0-based x-coordinate for the each line of the text.

    SpacingLines - supplies the number of lines to leave between the end of the
        previous message and the start of this message.

    CenterHorizontally - if TRUE, each line in the message will be printed
        centered horizontally.  In this case, LeftMargin is ignored.

    Attribute - supplies attribute for text.

    ... - supply arguments for insertion/substitution into the message text.

Return Value:

    none.

--*/

{
    va_list arglist;
    ULONG   n;

    va_start(arglist,Attribute);

    n = vSpDisplayFormattedMessage(
            MessageId,
            CenterHorizontally,
            FALSE,
            Attribute,
            LeftMargin,
            NextMessageTopLine + SpacingLines,
            arglist
            );

    va_end(arglist);

    //
    // Remember where the message ended.
    //
    NextMessageTopLine += n + SpacingLines;
}


VOID
vSpDisplayRawMessage(
    IN ULONG   MessageId,
    IN ULONG   SpacingLines,
    IN va_list arglist
    )

/*++

Routine Description:

    This routine outputs a multiline message to the screen, dumping it
    terminal style, to the console.

    The format string is fetched from setup's text resources; arguments are
    substituted into the format string according to FormatMessage semantics;
    and then the resulting unicode string is translated into an ANSI string
    suitable for the HAL printing routine.

    The screen is NOT cleared by this routine.

Arguments:

    MessageId    - supplies id of message resource containing the text,
                   which is treated as a format string for FormatMessage.

    SpacingLines - supplies the number of lines to skip down before starting this
                   message.

    arglist      - supply arguments for insertion into the given message.

Return Value:

    none.

--*/

{
    ULONG BytesInMsg, BufferLeft, i;
    PWCHAR p, q;
    WCHAR  c;
    PUCHAR HalPrintString;

    vSpFormatMessage(
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            MessageId,
            &BytesInMsg,
            &arglist
            );

    //
    // Must have at least one char + terminating nul in there.
    //
    if(BytesInMsg <= sizeof(WCHAR)) {
        return;
    } else {
        for(i=0; i<SpacingLines; i++) {
            InbvDisplayString("\r\n");
        }
    }

    //
    // BytesInMsg includes terminating nul.
    //
    p = TemporaryBuffer + (BytesInMsg / sizeof(WCHAR)) - 1;

    //
    // Find last non-space char in message.
    //
    while((p > TemporaryBuffer) && SpIsSpace(*(p-1))) {
        p--;
    }

    //
    // Find end of the last significant line and terminate the message
    // after it.
    //
    if(q = wcschr(p, L'\n')) {
        *(++q) = 0;
        q++;
    } else {
        q = TemporaryBuffer + (BytesInMsg / sizeof(WCHAR));
    }

    //
    // Grab rest of buffer to put ANSI translation into
    //
    HalPrintString = (PUCHAR)q;
    BufferLeft = (ULONG)(sizeof(TemporaryBuffer) - ((PUCHAR)q - (PUCHAR)TemporaryBuffer));

    //
    // Print out message, line-by-line
    //
    for(p=TemporaryBuffer; q = SpFindCharFromListInString(p, L"\n\r"); ) {

        c = *q;
        *q = 0;

        RtlUnicodeToOemN(
            HalPrintString,
            BufferLeft,
            &BytesInMsg,
            p,
            (ULONG)((PUCHAR)q - (PUCHAR)p + sizeof(WCHAR))
            );

        if(BytesInMsg) {
            InbvDisplayString(HalPrintString);
        }

        InbvDisplayString("\r\n");

        *q = c;

        //
        // If cr/lf terminated the line, make sure we skip both chars.
        //
        if((c == L'\r') && (*(q+1) == L'\n')) {
            q++;
        }

        p = ++q;
    }

    //
    // Write the final line (if there is one).
    //
    if(wcslen(p)) {

        RtlUnicodeToOemN(
            HalPrintString,
            BufferLeft,
            &BytesInMsg,
            p,
            (wcslen(p) + 1) * sizeof(WCHAR)
            );

        if(BytesInMsg) {
            InbvDisplayString(HalPrintString);
        }
        InbvDisplayString("\r\n");

    }
}


VOID
SpDisplayRawMessage(
    IN ULONG   MessageId,
    IN ULONG   SpacingLines,
    ...
    )

/*++

Routine Description:

    Output a message to the screen using the HAL-supplied console output routine.
    The message is merely dumped, line-by-line, to the screen, terminal-style.

Arguments:

    MessageId    - supplies id of message resource containing the text,
                   which is treated as a format string for FormatMessage.

    SpacingLines - supplies the number of lines to skip down before starting this
                   message.

    ...          - supply arguments for insertion into the given message.

Return Value:

    none.

--*/

{
    va_list arglist;

    va_start(arglist, SpacingLines);

    vSpDisplayRawMessage(
            MessageId,
            SpacingLines,
            arglist
            );

    va_end(arglist);
}


VOID
SpBugCheck(
    IN ULONG BugCode,
    IN ULONG Param1,
    IN ULONG Param2,
    IN ULONG Param3
    )

/*++

Routine Description:

    Display a message on the screen, informing the user that a fatal
    Setup error has occurred, and that they should reboot the machine.

Arguments:

    BugCode     - Bugcheck code number as defined in spmisc.h and documented in
                  ntos\nls\bugcodes.txt

    Param1      - 1st informative parameter

    Param2      - 2nd informative parameter

    Param3      - 3rd informative parameter

Return Value:

    DOES NOT RETURN

--*/

{
    if(VideoInitialized) {

        //
        // If we are in upgrade graphics mode then
        // switch to textmode
        //
        SpvidSwitchToTextmode();


        SpStartScreen(
                SP_SCRN_FATAL_SETUP_ERROR,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                BugCode,
                Param1,
                Param2,
                Param3
                );

        if(KbdLayoutInitialized) {
            SpContinueScreen(
                    SP_SCRN_F3_TO_REBOOT,
                    3,
                    1,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );
            SpDisplayStatusText(SP_STAT_F3_EQUALS_EXIT, DEFAULT_STATUS_ATTRIBUTE);
            SpInputDrain();
            while(SpInputGetKeypress() != KEY_F3);
            SpDone(0,FALSE, TRUE);

        } else {
            //
            // we haven't loaded the layout dll yet, so we can't prompt for a keypress to reboot
            //
            SpContinueScreen(
                    SP_SCRN_POWER_DOWN,
                    3,
                    1,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );

            SpDisplayStatusText(SP_STAT_KBD_HARD_REBOOT, DEFAULT_STATUS_ATTRIBUTE);

            while(TRUE);    // Loop forever
        }
    } else {
        SpDisplayRawMessage(
                SP_SCRN_FATAL_SETUP_ERROR,
                2,
                BugCode,
                Param1,
                Param2,
                Param3
                );
        SpDisplayRawMessage(SP_SCRN_POWER_DOWN, 1);

        while(TRUE);    // loop forever
    }
}


VOID
SpDrawFrame(
    IN ULONG   LeftX,
    IN ULONG   Width,
    IN ULONG   TopY,
    IN ULONG   Height,
    IN UCHAR   Attribute,
    IN BOOLEAN DoubleLines
    )
{
    PWSTR Buffer;
    ULONG u;
    WCHAR w;

    Buffer = SpMemAlloc((Width+1) * sizeof(WCHAR));
    ASSERT(Buffer);
    if(!Buffer) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to allocate memory for buffer to draw frame\n"));
        return;
    }

    Buffer[Width] = 0;

    //
    // Top.
    //
    w = SplangGetLineDrawChar(DoubleLines ? LineCharDoubleHorizontal : LineCharSingleHorizontal);
    for(u=1; u<Width-1; u++) {
        Buffer[u] = w;
    }

    Buffer[0]       = SplangGetLineDrawChar(DoubleLines ? LineCharDoubleUpperLeft  : LineCharSingleUpperLeft);
    Buffer[Width-1] = SplangGetLineDrawChar(DoubleLines ? LineCharDoubleUpperRight : LineCharSingleUpperRight);

    SpvidDisplayString(Buffer,Attribute,LeftX,TopY);

    //
    // Bottom.
    //

    Buffer[0]       = SplangGetLineDrawChar(DoubleLines ? LineCharDoubleLowerLeft  : LineCharSingleLowerLeft);
    Buffer[Width-1] = SplangGetLineDrawChar(DoubleLines ? LineCharDoubleLowerRight : LineCharSingleLowerRight);

    SpvidDisplayString(Buffer,Attribute,LeftX,TopY+Height-1);

    //
    // Interior lines.
    //
    for(u=1; u<Width-1; u++) {
        Buffer[u] = L' ';
    }

    Buffer[0]       = SplangGetLineDrawChar(DoubleLines ? LineCharDoubleVertical : LineCharSingleVertical);
    Buffer[Width-1] = SplangGetLineDrawChar(DoubleLines ? LineCharDoubleVertical : LineCharSingleVertical);

    for(u=1; u<Height-1; u++) {
        SpvidDisplayString(Buffer,Attribute,LeftX,TopY+u);
    }

    SpMemFree(Buffer);
}



ULONG
SpWaitValidKey(
    IN const ULONG *ValidKeys1,
    IN const ULONG *ValidKeys2,  OPTIONAL
    IN const ULONG *MnemonicKeys OPTIONAL
    )

/*++

Routine Description:

    Wait for a key to be pressed that appears in a list of valid keys.

Arguments:

    ValidKeys1 - supplies list of valid keystrokes.  The list must be
        terminated with a 0 entry.

    ValidKeys2 - if specified, supplies an additional list of valid keystrokes.

    MnemonicKeys - if specified, specifies a list of indices into the
        SP_MNEMONICS message string (see the MNEMONIC_KEYS enum).
        If the user's keystroke is not listed in ValidKeys, it will be
        uppercased and compared against each character indexed by a value
        in MnemonicKeys.  If a match is found, the returned value is the
        index (ie,MNEMONIC_KEYS enum value), and the high bit will be set.

Return Value:

    The key that was pressed (see above).

--*/

{
    ULONG c;
    ULONG i;


    SpInputDrain();

    while(1) {

        c = SpInputGetKeypress();

        //
        // Check for normal key.
        //

        for(i=0; ValidKeys1[i]; i++) {
            if(c == ValidKeys1[i]) {
                return(c);
            }
        }

        //
        // Check secondary list.
        //
        if(ValidKeys2) {
            for(i=0; ValidKeys2[i]; i++) {
                if(c == ValidKeys2[i]) {
                    return(c);
                }
            }
        }

        //
        // Check for mnemonic keys.
        //
        if(MnemonicKeys && !(c & KEY_NON_CHARACTER)) {

            c = (ULONG)RtlUpcaseUnicodeChar((WCHAR)c);

            for(i=0; MnemonicKeys[i]; i++) {

                if((WCHAR)c == MnemonicValues[MnemonicKeys[i]]) {

                    return((ULONG)MnemonicKeys[i] | KEY_MNEMONIC);
                }
            }
        }
    }
}

//
// Attributes for text edit fields.
//
#define EDIT_FIELD_BACKGROUND ATT_WHITE
#define EDIT_FIELD_TEXT       (ATT_FG_BLACK | ATT_BG_WHITE)


BOOLEAN
SpGetInput(
    IN     PKEYPRESS_CALLBACK ValidateKey,
    IN     ULONG              X,
    IN     ULONG              Y,
    IN     ULONG              MaxLength,
    IN OUT PWCHAR             Buffer,
    IN     BOOLEAN            ValidateEscape,
    IN     WCHAR              CoverCharacter
    )

/*++

Routine Description:

    Allow the user to enter text in an edit field of a specified size.

    Some special keys are interpreted and handled locally; others are passed
    to a caller-supplied routine for validation.

    Keys handled locally include ENTER, BACKSPACE, and ESCAPE (subject to ValidateEscape):
    these keys will never be passed to the callback routine.

    Other keys are passed to the callback function.  This specifically includes
    function keys, which may have special meaning to the caller, and upon which
    the caller must act before returning.  (IE, if the user presses F3, the caller
    might put up an exit confirmation dialog.

Arguments:

    ValidateKey - supplies address of a function to be called for each keypress.
        The function takes the keypress as an argument, and returns one of the
        following values:

        ValidationAccept - acecpt the keystroke into the string being input.
            If the keystroke is not a unicode character (ie, is a function key)
            then this value must not be returned.

        ValidationIgnore - do not accept the keystroke into the string.

        ValidationReject - same as ValidationIgnore, except that there may be some
            addition action, such as beeping the speaker.

        ValidationTerminate - end input ad return from SpGetInput immediately
            with a value of FALSE.

        ValidationRepaint - same as ValidationIgnore, except that the input field is
            repainted.

    X,Y - specify the coordinate for the leftmost character in the edit field.

    MaxLength - supplies the maximum number of characters in the edit field.

    Buffer - On input supplies a default string for the edit field. On output,
        receives the string entered by the user.  This buffer should be large
        enough to contain MaxLength +1 unicode characters (ie, should be able to
        hold a nul-terminated string of length MaxLength).

    ValidateEscape - if TRUE, treat escape like a normal character, passing it to
        the validation routine.  If FALSE, escape clears the input field.
        
    CoverCharacter - Optional variable that, if present, will be displayed instead
                     of the typed-in character.  For example, if we're retrieving
                     a password, we would like to echo '*' for each character
                     instead of the character typed in.

Return Value:

    TRUE if the user's input was terminated normally (ie, by he user pressed ENTER).
    FALSE if terminated by ValidateKey returning ValidationTerminate.

--*/

{
    ULONG c;
    ValidationValue vval;
    ULONG CurrentCharCount;
    WCHAR str[3];
    WCHAR CURSOR = SplangGetCursorChar();

    //
    // Make sure edit field is in a reasonable place on the screen.
    //
    ASSERT(X + MaxLength + 1 < VideoVars.ScreenWidth);
    ASSERT(Y < VideoVars.ScreenHeight - STATUS_HEIGHT);

    //
    // Prime the pump.
    //
    vval = ValidateRepaint;
    CurrentCharCount = wcslen(Buffer);
    str[1] = 0;
    str[2] = 0;

    ASSERT(CurrentCharCount <= MaxLength);

    while(1) {

        //
        // Perform action based on previous state.
        //
        switch(vval) {

        case ValidateAccept:

            //
            // Insert the previous key into the input.
            //
            ASSERT(Buffer[CurrentCharCount] == 0);
            ASSERT(CurrentCharCount < MaxLength);
            ASSERT(!(c & KEY_NON_CHARACTER));

            Buffer[CurrentCharCount++] = (USHORT)c;
            Buffer[CurrentCharCount  ] = 0;
            break;

        case ValidateRepaint:

            //
            // Repaint the edit field in its current state.
            // The edit field is one character too large, to accomodate
            // the cursor after the last legal character in the edit field.
            //
            SpvidClearScreenRegion(X,Y,MaxLength+1,1,EDIT_FIELD_BACKGROUND);
            if( CoverCharacter ) {
                //
                // Hide the buffer.
                //
                str[0] = CoverCharacter;
                for( c = 0; c < CurrentCharCount; c++ ) {
                    SpvidDisplayString(str,EDIT_FIELD_TEXT,X+c,Y);
                }
            } else {
                SpvidDisplayString(Buffer,EDIT_FIELD_TEXT,X,Y);
            }

            //
            // Draw the cursor.
            //
            str[0] = CURSOR;
            SpvidDisplayString(str,EDIT_FIELD_TEXT,X+CurrentCharCount,Y);
            break;

        case ValidateIgnore:
        case ValidateReject:

            //
            // Ignore the previous keystroke.
            //
            break;


        case ValidateTerminate:

            //
            // Callback wants us to terminate.
            //
            return(FALSE);
        }

        //
        // Get a keystroke.
        //
        c = SpInputGetKeypress();

        //
        // Do something with the key.
        //
        switch(c) {

        case ASCI_CR:

            //
            // Input is terminated. We're done.
            //
            return(TRUE);

        case ASCI_BS:

            //
            // Backspace character.  If we're not at the beginning
            // of the edit field, erase the previous character, replacing it
            // with the cursor character.
            //
            if(CurrentCharCount) {

                Buffer[--CurrentCharCount] = 0;
                str[0] = CURSOR;
                str[1] = L' ';
                SpvidDisplayString(str,EDIT_FIELD_TEXT,X+CurrentCharCount,Y);
                str[1] = 0;
            }

            vval = ValidateIgnore;
            break;

        case ASCI_ESC:

            //
            // Escape character. Clear the edit field.
            //
            if(!ValidateEscape) {
                RtlZeroMemory(Buffer,(MaxLength+1) * sizeof(WCHAR));
                CurrentCharCount = 0;
                vval = ValidateRepaint;
                break;
            }

            //
            // Otherwise, we want to validate escape like a normal character.
            // So just fall through.
            //

        default:

            //
            // Some other character. Pass it to the callback function
            // for validation.
            //
            vval = ValidateKey(c);

            if(vval == ValidateAccept) {

                //
                // We want to accept the keystroke.  If there is not enough
                // room in the buffer, convert acceptance to ignore.
                // Otherwise (ie, there is enough room), put the character
                // up on the screen and advance the cursor.
                //
                if(CurrentCharCount < MaxLength) {

                    ASSERT(!(c & KEY_NON_CHARACTER));

                    if( CoverCharacter ) {
                        str[0] = (WCHAR)CoverCharacter;                        
                    } else {
                        str[0] = (WCHAR)c;
                    }
                    SpvidDisplayString(str,EDIT_FIELD_TEXT,X+CurrentCharCount,Y);

                    str[0] = CURSOR;
                    SpvidDisplayString(str,EDIT_FIELD_TEXT,X+CurrentCharCount+1,Y);

                } else {

                    vval = ValidateIgnore;
                }
            }

            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spfile.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spfile.h

Abstract:

    Public header file for file-related functions in text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/


#ifndef _SPFILE_DEFN_
#define _SPFILE_DEFN_


NTSTATUS
SpGetFileSize(
    IN  HANDLE hFile,
    OUT PULONG Size
    );

NTSTATUS
SpMapEntireFile(
    IN  HANDLE   hFile,
    OUT PHANDLE  Section,
    OUT PVOID   *ViewBase,
    IN  BOOLEAN  WriteAccess
    );

BOOLEAN
SpUnmapFile(
    IN HANDLE Section,
    IN PVOID  ViewBase
    );

NTSTATUS
SpOpenAndMapFile_Ustr(
    IN     PCUNICODE_STRING FileName,
    IN OUT PHANDLE  FileHandle,
    OUT    PHANDLE  SectionHandle,
    OUT    PVOID   *ViewBase,
    OUT    PULONG   FileSize,
    IN     BOOLEAN  WriteAccess
    );

NTSTATUS
SpOpenAndMapFile(
    IN     PWSTR    FileName,
    IN OUT PHANDLE  FileHandle,
    OUT    PHANDLE  SectionHandle,
    OUT    PVOID   *ViewBase,
    OUT    PULONG   FileSize,
    IN     BOOLEAN  WriteAccess
    );

NTSTATUS
SpSetInformationFile(
    IN HANDLE                 Handle,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG                  Length,
    IN PVOID                  FileInformation
    );

NTSTATUS
SpDeleteFileEx_Ustr(
    IN PCUNICODE_STRING Name1,
    IN PCUNICODE_STRING Name2, OPTIONAL
    IN PCUNICODE_STRING Name3, OPTIONAL
    IN ULONG ShareFlags, OPTIONAL
    IN ULONG OpenFlags OPTIONAL
    );

NTSTATUS
SpDeleteFileEx(
    IN PCWSTR Name1,
    IN PCWSTR Name2, OPTIONAL
    IN PCWSTR Name3, OPTIONAL
    IN ULONG ShareFlags, OPTIONAL
    IN ULONG OpenFlags OPTIONAL
    );

NTSTATUS
SpDeleteFile_Ustr(
    IN PCUNICODE_STRING Name1,
    IN PCUNICODE_STRING Name2, OPTIONAL
    IN PCUNICODE_STRING Name3  OPTIONAL
    );

NTSTATUS
SpDeleteFile(
    IN PCWSTR Name1,
    IN PCWSTR Name2, OPTIONAL
    IN PCWSTR Name3  OPTIONAL
    );

NTSTATUS
SpSetAttributes_Ustr (
    IN      PCUNICODE_STRING SrcNTPath,
    IN      ULONG FileAttributes
    );

NTSTATUS
SpSetAttributes (
    IN      PWSTR SrcNTPath,
    IN      ULONG FileAttributes
    );

NTSTATUS
SpGetAttributes_Ustr (
    IN      PCUNICODE_STRING SrcNTPath,
    OUT     PULONG FileAttributesPtr
    );

NTSTATUS
SpGetAttributes (
    IN      PWSTR SrcNTPath,
    OUT     PULONG FileAttributesPtr
    );

BOOLEAN
SpFileExists_Ustr(
    IN PCUNICODE_STRING PathName,
    IN BOOLEAN Directory
    );

BOOLEAN
SpFileExists(
    IN PCWSTR PathName,
    IN BOOLEAN Directory
    );

NTSTATUS
SpRenameFile_Ustr(
    IN PCUNICODE_STRING   OldName,
    IN PCUNICODE_STRING   NewName,
    IN BOOLEAN AllowDirectoryRename
    );

NTSTATUS
SpRenameFile(
    IN PCWSTR  OldName,
    IN PCWSTR  NewName,
    IN BOOLEAN AllowDirectoryRename
    );

PIMAGE_NT_HEADERS
SpChecksumMappedFile(
    IN  PVOID  BaseAddress,
    IN  ULONG  FileSize,
    OUT PULONG HeaderSum,
    OUT PULONG Checksum
    );

NTSTATUS
SpOpenNameMayBeCompressed(
    IN  PWSTR    FullPath,
    IN  ULONG    OpenAccess,
    IN  ULONG    FileAttributes,
    IN  ULONG    ShareFlags,
    IN  ULONG    Disposition,
    IN  ULONG    OpenFlags,
    OUT PHANDLE  Handle,
    OUT PBOOLEAN OpenedCompressedName   OPTIONAL
    );

NTSTATUS
SpGetFileSizeByName(
    IN  PWSTR DevicePath OPTIONAL,
    IN  PWSTR Directory  OPTIONAL,
    IN  PWSTR FileName,
    OUT PULONG Size
    );

VOID
SpVerifyNoCompression(
    IN PWSTR FileName
    );

#define SP_DELETE_FILE_OR_EMPTY_DIRECTORY_FLAG_DO_NOT_CLEAR_ATTRIBUTES (0x00000001)
NTSTATUS
SpDeleteFileOrEmptyDirectory(
    IN ULONG  Flags,
    IN PCUNICODE_STRING Path
    );

#endif // ndef _SPFILE_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spfontup.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spfontup.c

Abstract:

    Code to handle upgrading fonts.

    Around build 1150 or so, fonts were moved from the system
    directory to the fonts directory to be compatible with win95.
    In Setup, we want to preserve the user's existing font situation
    (ie, only upgrade the fonts that he already had, etc) and at
    the same time layout.inf/txtsetup.sif needed to be changed to
    put/locate the font files in fonts instead of system.

    So what we do is 'precopy' all font files from the system dir
    to the fonts. Then when the rest of the upgrade runs, it does
    the usual thing (upgrading font files according to how they are
    marked for upgrade in txtsetup.sif).

    Later when GDI runs it will take care of cleaning up wierd references
    to fonts (lile .fots that points to .ttfs that were not in the
    system dir).

Author:

    Ted Miller (tedm) 16-Oct-195

Revision History:

--*/

#include "spprecmp.h"
#pragma hdrstop


BOOLEAN
SpFontSystemDirEnumCallback(
    IN  PCWSTR                      Directory,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT PULONG                      ReturnData,
    IN  PVOID                       Pointer
    )

/*++

Routine Description:

    This routine is called by the file enumerator as a callback for
    each file found in the system directory. We examine the file
    and if it's a font file, we copy it to the fonts directory.

Arguments:

    Directory - supplies the full NT path to the system directory.

    FileInfo - supplies find data for a file in the system dir.

    ReturnData - receives an error code if an error occurs.
        We ignore errors in this routine and thus we always
        just fill this in with NO_ERROR.

    Pointer - An optional pointer. Not used in this function.

Return Value:

    Always TRUE.

--*/

{
    ULONG Len;
    PWSTR temp,p;
    PWSTR SourceFilename,TargetFilename;
    NTSTATUS Status;

    ReturnData = NO_ERROR;

    ASSERT(NTUpgrade == UpgradeFull);
    if(NTUpgrade != UpgradeFull) {
        return(FALSE);
    }

    //
    // Ignore directories.
    //
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        return(TRUE);
    }

    //
    // Break out the filename, which is not nul terminated
    // in the dir information structure.
    // Form the fully qualified source filename.
    //
    // Note how we use the temporary buffer. Be careful if you
    // change this code.
    //
    temp = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);
    Len = FileInfo->FileNameLength/sizeof(WCHAR);

    wcsncpy(temp,FileInfo->FileName,Len);
    temp[Len] = 0;

    wcscpy(TemporaryBuffer,Directory);
    SpConcatenatePaths(TemporaryBuffer,temp);

    SourceFilename = SpDupStringW(TemporaryBuffer);

    //
    // Check to see whether we care about this file.
    //
    if (SourceFilename) {
        temp = wcsrchr(SourceFilename,L'\\');
    } else {
        temp = NULL;
    }
    
    if(temp) {
        temp++;
        Len = wcslen(temp);
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: That's strange: system dir font enum got file %ws\n",SourceFilename));
        return(TRUE);
    }

    //
    // At this point temp points at the filename part and len is its length.
    // See whether we care about this file.
    //
    if((Len > 4)
    && (   !_wcsicmp(temp+Len-4,L".ttf")
        || !_wcsicmp(temp+Len-4,L".fot")
        || !_wcsicmp(temp+Len-4,L".ttc")
        || !_wcsicmp(temp+Len-4,L".fon")
        || !_wcsicmp(temp+Len-4,L".jfr")))
    {
        //
        // Font file. Needs to be moved.
        // Locate the backslash just prior to SYSTEM in the source filename.
        //
        for(p=temp-2; (p>SourceFilename) && (*p != L'\\'); --p) {
            ;
        }
        if(p > SourceFilename) {

            *p = 0;
            wcscpy(TemporaryBuffer,SourceFilename);
            *p = L'\\';
            wcscat(TemporaryBuffer,L"\\FONTS\\");
            wcscat(TemporaryBuffer,temp);

            TargetFilename = SpDupStringW(TemporaryBuffer);
            SpDisplayStatusText(SP_STAT_FONT_UPGRADE,DEFAULT_STATUS_ATTRIBUTE,temp);

            //
            // Copy the file. Note that if it's one of our fonts,
            // it will get overwritten with the latest version anyway,
            // so we're not worried about whether the target file is
            // already there in the fonts directory and newer, etc.
            // Ignore errors.
            //
            Status = SpCopyFileUsingNames(SourceFilename,TargetFilename,0,COPY_DELETESOURCE);
            SpDisplayStatusText(SP_STAT_EXAMINING_CONFIG,DEFAULT_STATUS_ATTRIBUTE);
            SpMemFree(TargetFilename);

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: That's strange: system dir font enum got file %ws\n",SourceFilename));
        }
    }

    SpMemFree(SourceFilename);
    return(TRUE);
}


VOID
SpPrepareFontsForUpgrade(
    IN PCWSTR SystemDirectory
    )

/*++

Routine Description:

    Prepares the system to upgrade fonts by copying all font files
    that are in the system directory into the fonts directory.

    Note: this routine should only be called in the upgrade case.

Arguments:

Return Value:

    Always TRUE.

--*/
{
    ULONG x;

    ASSERT(NTUpgrade == UpgradeFull);
    if(NTUpgrade != UpgradeFull) {
        return;
    }

    SpDisplayStatusText(SP_STAT_EXAMINING_CONFIG,DEFAULT_STATUS_ATTRIBUTE);

    SpEnumFiles(SystemDirectory,SpFontSystemDirEnumCallback,&x, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spfsrec.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spfsrec.c

Abstract:

    Filesystem recognition/identification routines.

Author:

    Ted Miller (tedm) 16-September-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

#include <bootfat.h>
#include <bootf32.h>
#include <bootntfs.h>
#include <boot98f.h> //NEC98
#include <boot98n.h> //NEC98
#include <boot98f2.h> //NEC98
#include <patchbc.h>

//
// Packed FAT boot sector.
//
typedef struct _BOOTSECTOR {
    UCHAR Jump[3];                                  // offset = 0x000   0
    UCHAR Oem[8];                                   // offset = 0x003   3
    UCHAR BytesPerSector[2];
    UCHAR SectorsPerCluster[1];
    UCHAR ReservedSectors[2];
    UCHAR Fats[1];
    UCHAR RootEntries[2];
    UCHAR Sectors[2];
    UCHAR Media[1];
    UCHAR SectorsPerFat[2];
    UCHAR SectorsPerTrack[2];
    UCHAR Heads[2];
    UCHAR HiddenSectors[4];
    UCHAR LargeSectors[4];
    UCHAR PhysicalDriveNumber[1];                   // offset = 0x024  36
    UCHAR Reserved[1];                              // offset = 0x025  37
    UCHAR Signature[1];                             // offset = 0x026  38
    UCHAR Id[4];                                    // offset = 0x027  39
    UCHAR VolumeLabel[11];                          // offset = 0x02B  43
    UCHAR SystemId[8];                              // offset = 0x036  54
    UCHAR BootStrap[510-62];
    UCHAR AA55Signature[2];
} BOOTSECTOR, *PBOOTSECTOR;


//
// Packed NTFS boot sector.
//
typedef struct _NTFS_BOOTSECTOR {
    UCHAR         Jump[3];
    UCHAR         Oem[8];
    UCHAR         BytesPerSector[2];
    UCHAR         SectorsPerCluster[1];
    UCHAR         ReservedSectors[2];
    UCHAR         Fats[1];
    UCHAR         RootEntries[2];
    UCHAR         Sectors[2];
    UCHAR         Media[1];
    UCHAR         SectorsPerFat[2];
    UCHAR         SectorsPerTrack[2];
    UCHAR         Heads[2];
    UCHAR         HiddenSectors[4];
    UCHAR         LargeSectors[4];
    UCHAR         Unused[4];
    LARGE_INTEGER NumberSectors;
    LARGE_INTEGER MftStartLcn;
    LARGE_INTEGER Mft2StartLcn;
    CHAR          ClustersPerFileRecordSegment;
    UCHAR         Reserved0[3];
    CHAR          DefaultClustersPerIndexAllocationBuffer;
    UCHAR         Reserved1[3];
    LARGE_INTEGER SerialNumber;
    ULONG         Checksum;
    UCHAR         BootStrap[512-86];
    USHORT        AA55Signature;
} NTFS_BOOTSECTOR, *PNTFS_BOOTSECTOR;


//
// Various signatures
//
#define BOOTSECTOR_SIGNATURE    0xaa55


BOOLEAN
SpIsFat(
    IN  HANDLE   PartitionHandle,
    IN  ULONG    BytesPerSector,
    IN  PVOID    AlignedBuffer,
    OUT BOOLEAN *Fat32
    )

/*++

Routine Description:

    Determine whether a partition contians a FAT or FAT32 filesystem.

Arguments:

    PartitionHandle - supplies handle to open partition.
        The partition should have been opened for synchronous i/o.

    BytesPerSector - supplies the number of bytes in a sector on
        the disk.  This value should be ultimately derived from
        IOCTL_DISK_GET_DISK_GEOMETRY.

    AlignedBuffer - supplies buffer to be used for i/o of a single sector.

    Fat32 - if this routine returns TRUE then this receives a flag
        indicating whether the volume is fat32.

Return Value:

    TRUE if the drive appears to be FAT.

--*/

{
    PBOOTSECTOR BootSector;
    USHORT bps;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PARTITION_INFORMATION PartitionInfo;
    ULONG SecCnt;

    //
    // Get partition info. This is so we can check to make sure the
    // file system on the partition isn't actually larger than the
    // partition itself. This happens for example when people
    // abuse the win9x rawread/rawwrite oem tool.
    //
    Status = ZwDeviceIoControlFile(
                PartitionHandle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_DISK_GET_PARTITION_INFO,
                NULL,
                0,
                &PartitionInfo,
                sizeof(PartitionInfo)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpIsFat: unable to get partition info (%lx)\n",Status));
        return(FALSE);
    }

    if((ULONGLONG)(PartitionInfo.PartitionLength.QuadPart / BytesPerSector) > 0xffffffffUi64) {
        //
        // This can't happen since the BPB can't describe it.
        //
        return(FALSE);
    }
    SecCnt = (ULONG)(PartitionInfo.PartitionLength.QuadPart / BytesPerSector);

    ASSERT(sizeof(BOOTSECTOR)==512);
    BootSector = AlignedBuffer;

    //
    // Read the boot sector (sector 0).
    //
    Status = SpReadWriteDiskSectors(
                PartitionHandle,
                0,
                1,
                BytesPerSector,
                BootSector,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpIsFat: Error %lx reading sector 0\n",Status));
        return(FALSE);
    }

    //
    // Adjust large sector count if necessary.
    //
    if(U_USHORT(BootSector->Sectors)) {
        U_ULONG(BootSector->LargeSectors) = 0;

        if((ULONG)U_USHORT(BootSector->Sectors) > SecCnt) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Boot sector on a disk has inconsistent size information!!\n"));
            return(FALSE);
        }
    } else {
        if(U_ULONG(BootSector->LargeSectors) > SecCnt) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Boot sector on a disk has inconsistent size information!!\n"));
            return(FALSE);
        }
    }

    //
    // Check various fields for permissible values.
    // Note that this check does not venture into fields beyond the BPB,
    // so disks with sector size < 512 are allowed.
    //
    if((BootSector->Jump[0] != 0x49)        // Fujitsu FMR
    && (BootSector->Jump[0] != 0xe9)
    && (BootSector->Jump[0] != 0xeb)) {
        return(FALSE);
    }

    bps = U_USHORT(BootSector->BytesPerSector);
    if((bps !=  128) && (bps !=  256)
    && (bps !=  512) && (bps != 1024)
    && (bps !=  2048) && (bps != 4096)) {
       return(FALSE);
    }

    if((BootSector->SectorsPerCluster[0] !=  1)
    && (BootSector->SectorsPerCluster[0] !=  2)
    && (BootSector->SectorsPerCluster[0] !=  4)
    && (BootSector->SectorsPerCluster[0] !=  8)
    && (BootSector->SectorsPerCluster[0] != 16)
    && (BootSector->SectorsPerCluster[0] != 32)
    && (BootSector->SectorsPerCluster[0] != 64)
    && (BootSector->SectorsPerCluster[0] != 128)) {

        return(FALSE);
    }

    if(!U_USHORT(BootSector->ReservedSectors) || !BootSector->Fats[0]) {
        return(FALSE);
    }

    if(!U_USHORT(BootSector->Sectors) && !U_ULONG(BootSector->LargeSectors)) {
        return(FALSE);
    }

    if((BootSector->Media[0] != 0x00)       // FMR (formatted by OS/2)
    && (BootSector->Media[0] != 0x01)       // FMR (floppy, formatted by DOS)
    && (BootSector->Media[0] != 0xf0)
    && (BootSector->Media[0] != 0xf8)
    && (BootSector->Media[0] != 0xf9)
    && (BootSector->Media[0] != 0xfa)       // FMR
    && (BootSector->Media[0] != 0xfb)
    && (BootSector->Media[0] != 0xfc)
    && (BootSector->Media[0] != 0xfd)
    && (BootSector->Media[0] != 0xfe)
    && (BootSector->Media[0] != 0xff)) {
        return(FALSE);
    }

    //
    // Final distinction is between FAT and FAT32.
    // Root dir entry count is 0 on FAT32.
    //
    if(U_USHORT(BootSector->SectorsPerFat) && !U_USHORT(BootSector->RootEntries)) {
        return(FALSE);
    }
    *Fat32 = (BOOLEAN)(U_USHORT(BootSector->RootEntries) == 0);
    return(TRUE);
}


BOOLEAN
SpIsNtfs(
    IN HANDLE PartitionHandle,
    IN ULONG  BytesPerSector,
    IN PVOID  AlignedBuffer,
    IN ULONG  WhichOne
    )

/*++

Routine Description:

    Determine whether a partition contians an NTFS filesystem.

Arguments:

    PartitionHandle - supplies handle to open partition.
        The partition should have been opened for synchronous i/o.

    BytesPerSector - supplies the number of bytes in a sector on
        the disk.  This value should be ultimately derived from
        IOCTL_DISK_GET_DISK_GEOMETRY.

    AlignedBuffer - supplies buffer to be used for i/o of a single sector.

    WhichOne - supplies a value that allows the caller to try more than
        one sector. 0 = sector 0. 1 = sector n-1. 2 = sector n/2, where
        n = number of sectors in the partition.

Return Value:

    TRUE if the drive appears to be FAT.

--*/

{
    PNTFS_BOOTSECTOR BootSector;
    NTSTATUS Status;
    PULONG l;
    ULONG Checksum;
    IO_STATUS_BLOCK IoStatusBlock;
    PARTITION_INFORMATION PartitionInfo;
    ULONGLONG SecCnt;

    //
    // Get partition information.
    //
    Status = ZwDeviceIoControlFile(
                PartitionHandle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_DISK_GET_PARTITION_INFO,
                NULL,
                0,
                &PartitionInfo,
                sizeof(PartitionInfo)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpIsNtfs: unable to get partition info (%lx)\n",Status));
        return(FALSE);
    }

    SecCnt = (ULONGLONG)PartitionInfo.PartitionLength.QuadPart / BytesPerSector;

    ASSERT(sizeof(NTFS_BOOTSECTOR)==512);
    BootSector = AlignedBuffer;

    //
    // Read the boot sector (sector 0).
    //
    Status = SpReadWriteDiskSectors(
                PartitionHandle,
                (ULONG)(WhichOne ? ((WhichOne == 1) ? SecCnt-1 : SecCnt/2) : 0),
                1,
                BytesPerSector,
                BootSector,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpIsNtfs: Error %lx reading sector %u\n",Status,WhichOne ? ((WhichOne == 1) ? SecCnt-1 : SecCnt/2) : 0));
        return(FALSE);
    }

    //
    // Caulculate the checksum.
    //
    for(Checksum=0,l=(PULONG)BootSector; l<(PULONG)&BootSector->Checksum; l++) {
        Checksum += *l;
    }

    //
    // Ensure that NTFS appears in the OEM field.
    //
    if(strncmp(BootSector->Oem,"NTFS    ",8)) {
        return(FALSE);
    }

    //
    // The number of bytes per sector must match the value
    // reported by the device, and must be less than or equal to
    // the page size.
    //
    if((U_USHORT(BootSector->BytesPerSector) != BytesPerSector)
    || (U_USHORT(BootSector->BytesPerSector) > PAGE_SIZE))
    {
        return(FALSE);
    }

    //
    // Other checks.
    // Note that these checks do not venture into fields beyond 128 bytes,
    // so disks with sector size < 512 are allowed.
    //
    if((BootSector->SectorsPerCluster[0] !=  1)
    && (BootSector->SectorsPerCluster[0] !=  2)
    && (BootSector->SectorsPerCluster[0] !=  4)
    && (BootSector->SectorsPerCluster[0] !=  8)
    && (BootSector->SectorsPerCluster[0] != 16)
    && (BootSector->SectorsPerCluster[0] != 32)
    && (BootSector->SectorsPerCluster[0] != 64)
    && (BootSector->SectorsPerCluster[0] != 128)) {

        return(FALSE);
    }

    if(U_USHORT(BootSector->ReservedSectors)
    || BootSector->Fats[0]
    || U_USHORT(BootSector->RootEntries)
    || U_USHORT(BootSector->Sectors)
    || U_USHORT(BootSector->SectorsPerFat)
    || U_ULONG(BootSector->LargeSectors)) {

        return(FALSE);
    }

    //
    // ClustersPerFileRecord can be less than zero if file records
    // are smaller than clusters.  This number is the negative of a shift count.
    // If clusters are smaller than file records then this number is
    // still the clusters per file records.
    //

    if(BootSector->ClustersPerFileRecordSegment <= -9) {
        if(BootSector->ClustersPerFileRecordSegment < -31) {
            return(FALSE);
        }

    } else if((BootSector->ClustersPerFileRecordSegment !=  1)
           && (BootSector->ClustersPerFileRecordSegment !=  2)
           && (BootSector->ClustersPerFileRecordSegment !=  4)
           && (BootSector->ClustersPerFileRecordSegment !=  8)
           && (BootSector->ClustersPerFileRecordSegment != 16)
           && (BootSector->ClustersPerFileRecordSegment != 32)
           && (BootSector->ClustersPerFileRecordSegment != 64)) {

        return(FALSE);
    }

    //
    // ClustersPerIndexAllocationBuffer can be less than zero if index buffers
    // are smaller than clusters.  This number is the negative of a shift count.
    // If clusters are smaller than index buffers then this number is
    // still the clusters per index buffers.
    //

    if(BootSector->DefaultClustersPerIndexAllocationBuffer <= -9) {
        if(BootSector->DefaultClustersPerIndexAllocationBuffer < -31) {
            return(FALSE);
        }

    } else if((BootSector->DefaultClustersPerIndexAllocationBuffer !=  1)
           && (BootSector->DefaultClustersPerIndexAllocationBuffer !=  2)
           && (BootSector->DefaultClustersPerIndexAllocationBuffer !=  4)
           && (BootSector->DefaultClustersPerIndexAllocationBuffer !=  8)
           && (BootSector->DefaultClustersPerIndexAllocationBuffer != 16)
           && (BootSector->DefaultClustersPerIndexAllocationBuffer != 32)
           && (BootSector->DefaultClustersPerIndexAllocationBuffer != 64)) {

        return(FALSE);
    }

    if((ULONGLONG)BootSector->NumberSectors.QuadPart > SecCnt) {
        return(FALSE);
    }

    if((((ULONGLONG)BootSector->MftStartLcn.QuadPart * BootSector->SectorsPerCluster[0]) > SecCnt)
    || (((ULONGLONG)BootSector->Mft2StartLcn.QuadPart * BootSector->SectorsPerCluster[0]) > SecCnt)) {

        return(FALSE);
    }

    return(TRUE);
}


FilesystemType
SpIdentifyFileSystem(
    IN PWSTR     DevicePath,
    IN ULONG     BytesPerSector,
    IN ULONG     PartitionOrdinal
    )

/*++

Routine Description:

    Identify the filesystem present on a given partition.

Arguments:

    DevicePath - supplies the name in the nt namespace for
        the disk's device object.

    BytesPerSector - supplies value reported by IOCTL_GET_DISK_GEOMETRY.

    PartitionOrdinal - supplies the ordinal of the partition
        to be identified.

Return Value:

    Value from the FilesystemType enum identifying the filesystem.

--*/

{
    NTSTATUS Status;
    HANDLE Handle;
    FilesystemType fs;
    PUCHAR UnalignedBuffer,AlignedBuffer;
    BOOLEAN Fat32;

    //
    // First open the partition.
    //
    Status = SpOpenPartition(DevicePath,PartitionOrdinal,&Handle,FALSE);

    if(!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "SETUP: SpIdentifyFileSystem: unable to open %ws\\partition%u (%lx)\n",
            DevicePath,
            PartitionOrdinal
            ));

        return(FilesystemUnknown);
    }

    UnalignedBuffer = SpMemAlloc(2*BytesPerSector);
    AlignedBuffer = ALIGN(UnalignedBuffer,BytesPerSector);

    //
    // Check for each filesystem we know about.
    //
    if(SpIsFat(Handle,BytesPerSector,AlignedBuffer,&Fat32)) {
        fs = Fat32 ? FilesystemFat32 : FilesystemFat;
    } else {
        if(SpIsNtfs(Handle,BytesPerSector,AlignedBuffer,0)) {
            fs = FilesystemNtfs;
        } else {
            fs = FilesystemUnknown;
        }
    }

    SpMemFree(UnalignedBuffer);

    ZwClose(Handle);

    return(fs);
}

ULONG
NtfsMirrorBootSector (
    IN      HANDLE  Handle,
    IN      ULONG   BytesPerSector,
    IN OUT  PUCHAR  *Buffer
    )

/*++

Routine Description:

    Finds out where the mirror boot sector is.

Arguments:

    Handle - supplies handle to open partition.
        The partition should have been opened for synchronous i/o.

    BytesPerSector - supplies the number of bytes in a sector on
        the disk.  This value should be ultimately derived from
        IOCTL_DISK_GET_DISK_GEOMETRY.

    Buffer - receives the address of the buffer we use to read the boot sector

Return Value:

    0 - mirror sector not found
    1 - mirror in sector n-1
    2 - mirror in sector n/2
    where n = number of sectors in the partition.

--*/

{
    NTSTATUS    Status;
    PUCHAR      UnalignedBuffer, AlignedBuffer;
    ULONG       Mirror;

    Mirror = 0;

    //
    // Set up our buffer
    //

    UnalignedBuffer = SpMemAlloc (2*BytesPerSector);
    ASSERT (UnalignedBuffer);
    AlignedBuffer = ALIGN (UnalignedBuffer, BytesPerSector);

    //
    // Look for the mirror boot sector
    //

    if (SpIsNtfs (Handle,BytesPerSector,AlignedBuffer,1)) {
        Mirror = 1;
    } else if (SpIsNtfs (Handle,BytesPerSector,AlignedBuffer,2)) {
        Mirror = 2;
    }

    //
    // Give the caller a copy of the buffer
    //

    if (Buffer) {
        *Buffer = SpMemAlloc (BytesPerSector);
        RtlMoveMemory (*Buffer, AlignedBuffer, BytesPerSector);
    }

    SpMemFree (UnalignedBuffer);
    return Mirror;
}


VOID
WriteNtfsBootSector (
    IN HANDLE PartitionHandle,
    IN ULONG  BytesPerSector,
    IN PVOID  Buffer,
    IN ULONG  WhichOne
    )

/*++

Routine Description:

    Writes a NTFS boot sector to sector 0 or one of the mirror locations.

Arguments:

    PartitionHandle - supplies handle to open partition.
        The partition should have been opened for synchronous i/o.

    BytesPerSector - supplies the number of bytes in a sector on
        the disk.  This value should be ultimately derived from
        IOCTL_DISK_GET_DISK_GEOMETRY.

    AlignedBuffer - supplies buffer to be used for i/o of a single sector.

    WhichOne - supplies a value that allows the caller to try more than
        one sector. 0 = sector 0. 1 = sector n-1. 2 = sector n/2, where
        n = number of sectors in the partition.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PARTITION_INFORMATION PartitionInfo;
    PUCHAR      UnalignedBuffer, AlignedBuffer;
    ULONGLONG SecCnt;


    UnalignedBuffer = SpMemAlloc (2*BytesPerSector);
    ASSERT (UnalignedBuffer);
    AlignedBuffer = ALIGN (UnalignedBuffer, BytesPerSector);
    RtlMoveMemory (AlignedBuffer, Buffer, BytesPerSector);

    //
    // Get partition information.
    //

    Status = ZwDeviceIoControlFile(
                PartitionHandle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_DISK_GET_PARTITION_INFO,
                NULL,
                0,
                &PartitionInfo,
                sizeof(PartitionInfo)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: WriteNtfsBootSector: unable to get partition info (%lx)\n",
            Status));
        return;
    }

    SecCnt = (ULONGLONG)PartitionInfo.PartitionLength.QuadPart / BytesPerSector;

    ASSERT(sizeof(NTFS_BOOTSECTOR)==512);

    //
    // Write the boot sector.
    //

    Status = SpReadWriteDiskSectors(
                PartitionHandle,
                (ULONG)(WhichOne ? ((WhichOne == 1) ? SecCnt-1 : SecCnt/2) : 0),
                1,
                BytesPerSector,
                AlignedBuffer,
                TRUE
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: WriteNtfsBootSector: Error %lx reading sector 0\n",
            Status));
        return;
    }

    SpMemFree (UnalignedBuffer);
}


BOOLEAN
SpPatchBootMessages(
    VOID
    )
{
    LPWSTR UnicodeMsg;
    LPSTR FatNtldrMissing;
    LPSTR FatDiskError;
    LPSTR FatPressKey;
    LPSTR NtfsNtldrMissing;
    LPSTR NtfsNtldrCompressed;
    LPSTR NtfsDiskError;
    LPSTR NtfsPressKey;
    LPSTR MbrInvalidTable;
    LPSTR MbrIoError;
    LPSTR MbrMissingOs;
    ULONG l;
    extern unsigned char x86BootCode[512];

    //
    // we don't touch boot code on NEC98
    //
    if (IsNEC_98) { //NEC98
        return(TRUE);
    } //NEC98

    UnicodeMsg = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);

    //
    // Deal with FAT -- get messages and patch.
    //
    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_FAT_NTLDR_MISSING);
    FatNtldrMissing = (PCHAR)TemporaryBuffer;
    RtlUnicodeToOemN(FatNtldrMissing,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_FAT_DISK_ERROR);
    FatDiskError = FatNtldrMissing + l;
    RtlUnicodeToOemN(FatDiskError,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_FAT_PRESS_KEY);
    FatPressKey = FatDiskError + l;
    RtlUnicodeToOemN(FatPressKey,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    if(!PatchMessagesIntoFatBootCode(FatBootCode,FALSE,FatNtldrMissing,FatDiskError,FatPressKey)) {
        return(FALSE);
    }

    if(!PatchMessagesIntoFatBootCode(Fat32BootCode,TRUE,FatNtldrMissing,FatDiskError,FatPressKey)) {
        return(FALSE);
    }

    //
    // Deal with NTFS -- get messages and patch.
    //
    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_NTFS_NTLDR_MISSING);
    NtfsNtldrMissing = (PCHAR)TemporaryBuffer;
    RtlUnicodeToOemN(NtfsNtldrMissing,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_NTFS_NTLDR_COMPRESSED);
    NtfsNtldrCompressed = NtfsNtldrMissing + l;
    RtlUnicodeToOemN(NtfsNtldrCompressed,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_NTFS_DISK_ERROR);
    NtfsDiskError = NtfsNtldrCompressed + l;
    RtlUnicodeToOemN(NtfsDiskError,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_NTFS_PRESS_KEY);
    NtfsPressKey = NtfsDiskError + l;
    RtlUnicodeToOemN(NtfsPressKey,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    if(!PatchMessagesIntoNtfsBootCode(NtfsBootCode,NtfsNtldrMissing,NtfsNtldrCompressed,NtfsDiskError,NtfsPressKey)) {
        return(FALSE);
    }

    //
    // Deal with MBR -- get messages and patch.
    //
    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_MBR_INVALID_TABLE);
    MbrInvalidTable = (PCHAR)TemporaryBuffer;
    RtlUnicodeToOemN(MbrInvalidTable,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_MBR_IO_ERROR);
    MbrIoError = MbrInvalidTable + l;
    RtlUnicodeToOemN(MbrIoError,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    SpFormatMessage(UnicodeMsg,100,SP_BOOTMSG_MBR_MISSING_OS);
    MbrMissingOs = MbrIoError + l;
    RtlUnicodeToOemN(MbrMissingOs,100,&l,UnicodeMsg,(wcslen(UnicodeMsg)+1)*sizeof(WCHAR));

    if(!PatchMessagesIntoMasterBootCode(x86BootCode,MbrInvalidTable,MbrIoError,MbrMissingOs)) {
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spfile.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spfile.c

Abstract:

    File operations for text setup.

Author:

    Ted Miller (tedm) 2-Aug-1993

Revision History:

    Jim Schmidt (jimschm) 10-Apr-1997   Added file attribute routines

--*/


#include "spprecmp.h"
#pragma hdrstop


NTSTATUS
SpGetFileSize(
    IN  HANDLE hFile,
    OUT PULONG Size
    )

/*++

Routine Description:

    Determine the size of a file.  Only the low 32 bits of the size
    are considered.

Arguments:

    hFile - supplies open handle to file whose size is desired.

    Size - receives size of file.

Return Value:

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_STANDARD_INFORMATION StandardInfo;

    Status = ZwQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &StandardInfo,
                sizeof(StandardInfo),
                FileStandardInformation
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpGetFileSize: status %lx from ZwQueryInformationFile\n",Status));
        return(Status);
    }

    *Size = StandardInfo.EndOfFile.LowPart;

    return(STATUS_SUCCESS);
}


NTSTATUS
SpMapEntireFile(
    IN  HANDLE   hFile,
    OUT PHANDLE  Section,
    OUT PVOID   *ViewBase,
    IN  BOOLEAN  WriteAccess
    )

/*++

Routine Description:

    Map an entire file for read or write access access.

Arguments:

    hFile - supplies handle of open file to be mapped.

    Section - receives handle for section object created to map file.

    ViewBase - receives address of the view of the file

    WriteAccess - if TRUE, map file for read and write access.
        If FALSE, map file for read access.

Return Value:

--*/

{
    NTSTATUS Status;
    LARGE_INTEGER SectionOffset;
    SIZE_T   ViewSize = 0;

    SectionOffset.QuadPart = 0;

    Status = ZwCreateSection(
                Section,
                  STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ
                | (WriteAccess ? SECTION_MAP_WRITE : 0),
                NULL,
                NULL,       // entire file
                WriteAccess ? PAGE_READWRITE : PAGE_READONLY,
                SEC_COMMIT,
                hFile
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Status %lx from ZwCreateSection\n",Status));
        return(Status);
    }

    *ViewBase = NULL;
    Status = ZwMapViewOfSection(
                *Section,
                NtCurrentProcess(),
                ViewBase,
                0,
                0,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0,
                WriteAccess ? PAGE_READWRITE : PAGE_READONLY
                );

    if(!NT_SUCCESS(Status)) {

        NTSTATUS s;

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpMapEntireFile: Status %lx from ZwMapViewOfSection\n",Status));

        s = ZwClose(*Section);

        if(!NT_SUCCESS(s)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpMapEntireFile: Warning: status %lx from ZwClose on section handle\n",s));
        }

        return(Status);
    }

    return(STATUS_SUCCESS);
}



BOOLEAN
SpUnmapFile(
    IN HANDLE Section,
    IN PVOID  ViewBase
    )
{
    NTSTATUS Status;
    BOOLEAN  rc = TRUE;

    Status = ZwUnmapViewOfSection(NtCurrentProcess(),ViewBase);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Warning: status %lx from ZwUnmapViewOfSection\n",Status));
        rc = FALSE;
    }

    Status = ZwClose(Section);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Warning: status %lx from ZwClose on section handle\n",Status));
        rc = FALSE;
    }

    return(rc);
}



NTSTATUS
SpOpenAndMapFile(
    IN     PWSTR    FileName,  OPTIONAL  // only needed if no FileHandle
    IN OUT PHANDLE  FileHandle,
    OUT    PHANDLE  SectionHandle,
    OUT    PVOID   *ViewBase,
    OUT    PULONG   FileSize,
    IN     BOOLEAN  WriteAccess
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    BOOLEAN MustClose = FALSE;

    //
    // If necessary, open the file.
    //
    if(!(*FileHandle)) {
        INIT_OBJA(&Obja,&UnicodeString,FileName);
        Status = ZwCreateFile(
                    FileHandle,
                    FILE_GENERIC_READ | (WriteAccess ? FILE_GENERIC_WRITE : 0),
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ,
                    FILE_OPEN,
                    0,
                    NULL,
                    0
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpOpenAndMapFile: Unable to open %ws (%lx)\n",FileName,Status));
            return(Status);
        } else {
            MustClose = TRUE;
        }
    }

    //
    // Get the size of the file.
    //
    Status = SpGetFileSize(*FileHandle,FileSize);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpOpenAndMapFile: unable to determine size of file %ws(%lx)\n",
                FileName ? FileName : L"(handle)", Status));
        if(MustClose) {
            ZwClose(*FileHandle);
        }
        return(Status);
    }

    //
    // Map the file.
    //
    Status = SpMapEntireFile(*FileHandle,SectionHandle,ViewBase,WriteAccess);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpOpenAndMapFile: unable to map %ws (%lx)\n",
                FileName ? FileName : L"(handle)", Status));
        if(MustClose) {
            ZwClose(*FileHandle);
        }
        return(Status);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
SpSetInformationFile(
    IN HANDLE                 Handle,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG                  Length,
    IN PVOID                  FileInformation
    )
{
    NTSTATUS Status;
    PFILE_OBJECT FileObject;
    OBJECT_HANDLE_INFORMATION HandleInfo;

    //
    // Reference the object.
    //
    Status = ObReferenceObjectByHandle(
                    Handle,
                    (ACCESS_MASK)DELETE,
                    *IoFileObjectType,
                    ExGetPreviousMode(),
                    &FileObject,
                    &HandleInfo
                    );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpSetInformationFile: ObReferenceObjectByHandle failed (%lx)\n",Status));
        return(Status);
    }

    //
    // Set the information.
    //
    Status = IoSetInformation(FileObject,FileInformationClass,Length,FileInformation);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: IoSetInformation returns %lx\n",Status));
    }

    //
    // Clean up and return.
    //
    ObDereferenceObject(FileObject);
    return(Status);
}


NTSTATUS
SpSetAttributes (
    IN      PWSTR SrcNTPath,
    IN      ULONG FileAttributes
    )
{
    UNICODE_STRING UnicodeString;
    NTSTATUS NtStatus;

    NtStatus = RtlInitUnicodeStringEx(&UnicodeString, SrcNTPath);
    if (!NT_SUCCESS(NtStatus)) {
        goto Exit;
    }
    NtStatus = SpSetAttributes_Ustr(&UnicodeString, FileAttributes);
Exit:
    return NtStatus;
}

NTSTATUS
SpSetAttributes_Ustr (
    IN      PCUNICODE_STRING SrcNTPath,
    IN      ULONG FileAttributes
    )

/*++

Routine Description:

  Applies FileAttributes to the specified file.

Arguments:

  SrcNTPath      - The NT path of the file needing attribute modification

  FileAttributes - The FILE_ATTRIBUTE_* flags to apply.

Return Value:

  NTSTATUS code.

--*/

{
    OBJECT_ATTRIBUTES Obja;                 // for ZwOpenFile
    IO_STATUS_BLOCK IoStatusBlock;          // for ZwOpenFile
    NTSTATUS Status;                        // Return value
    HANDLE FileHandle;                      // Handle of file to be modified
    FILE_BASIC_INFORMATION BasicInfo;       // For attribs modification

    InitializeObjectAttributes(&Obja, (PUNICODE_STRING)SrcNTPath, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = ZwOpenFile(
                &FileHandle,
                (ACCESS_MASK)(DELETE|FILE_WRITE_ATTRIBUTES),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_DELETE|FILE_SHARE_READ|FILE_SHARE_WRITE,
                FILE_NON_DIRECTORY_FILE|FILE_OPEN_FOR_BACKUP_INTENT
                );

    if (!NT_SUCCESS (Status)) {
        Status = ZwOpenFile(
                    &FileHandle,
                    (ACCESS_MASK)(DELETE|FILE_WRITE_ATTRIBUTES),
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_DELETE|FILE_SHARE_READ|FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE|FILE_OPEN_FOR_BACKUP_INTENT
                    );
    }

    if(NT_SUCCESS(Status)) {

        RtlZeroMemory( &BasicInfo, sizeof( FILE_BASIC_INFORMATION ) );
        BasicInfo.FileAttributes = FileAttributes;

        Status = SpSetInformationFile(
                    FileHandle,
                    FileBasicInformation,
                    sizeof(BasicInfo),
                    &BasicInfo
                    );

        ZwClose(FileHandle);
    }

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpSetAttributes failed for %ws, Status=%lx\n", SrcNTPath, Status));
    }

    return Status;
}

NTSTATUS
SpGetAttributes (
    IN      PWSTR SrcNTPath,
    OUT     PULONG FileAttributesPtr
    )
{
    UNICODE_STRING UnicodeString;
    NTSTATUS NtStatus;

    NtStatus = RtlInitUnicodeStringEx(&UnicodeString, SrcNTPath);
    if (!NT_SUCCESS(NtStatus)) {
        goto Exit;
    }
    NtStatus = SpGetAttributes_Ustr(&UnicodeString, FileAttributesPtr);
Exit:
    return NtStatus;
}

NTSTATUS
SpGetAttributes_Ustr (
    IN      PCUNICODE_STRING SrcNTPath,
    OUT     PULONG FileAttributesPtr
    )

/*++

Routine Description:

  Obtains FileAttributes for the specified file.

Arguments:

  SrcNTPath         - The NT path of the file to obtain attributes

  FileAttributesPtr - A poitner to a DWORD that recieves FILE_ATTRIBUTE_*
                      flags

Return Value:

  NTSTATUS code.  FileAttributePtr is modified only with status is NO_ERROR.

--*/

{
    OBJECT_ATTRIBUTES Obja;                 // for ZwOpenFile
    IO_STATUS_BLOCK IoStatusBlock;          // for ZwOpenFile
    NTSTATUS Status;                        // Return value
    HANDLE FileHandle;                      // Handle of file to be queried
    FILE_BASIC_INFORMATION BasicInfo;       // For attribs retrieval

    InitializeObjectAttributes(&Obja, (PUNICODE_STRING)SrcNTPath, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = ZwOpenFile(
                &FileHandle,
                (ACCESS_MASK)(FILE_TRAVERSE | FILE_READ_ATTRIBUTES),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ,
                FILE_NON_DIRECTORY_FILE
                );

    if (!NT_SUCCESS (Status)) {
        Status = ZwOpenFile(
                    &FileHandle,
                    (ACCESS_MASK)(FILE_TRAVERSE | FILE_READ_ATTRIBUTES),
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ,
                    FILE_DIRECTORY_FILE
                    );
    }

    if(NT_SUCCESS(Status)) {
        Status = ZwQueryInformationFile(
                    FileHandle,
                    &IoStatusBlock,
                    &BasicInfo,
                    sizeof(BasicInfo),
                    FileBasicInformation
                    );

        ZwClose(FileHandle);
        if (NT_SUCCESS(Status)) {
            *FileAttributesPtr = BasicInfo.FileAttributes;
        }
    }

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpGetAttributes failed for %wZ, Status=%lx\n", SrcNTPath, Status));
    }

    return Status;
}

NTSTATUS
SpDeleteFileOrEmptyDirectory(
    IN ULONG  Flags,
    IN PCUNICODE_STRING Path
    )
/*
This is based on SpMigDeleteFile.
It does not perform optimally, in terms of limiting the number of NtOpenFile calls.
*/
{
    UNICODE_STRING ustr;
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    const ULONG ValidFlags = SP_DELETE_FILE_OR_EMPTY_DIRECTORY_FLAG_DO_NOT_CLEAR_ATTRIBUTES;

    if ((Flags & ~ValidFlags) != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ((Flags & SP_DELETE_FILE_OR_EMPTY_DIRECTORY_FLAG_DO_NOT_CLEAR_ATTRIBUTES) == 0) {
        SpSetAttributes_Ustr (Path, FILE_ATTRIBUTE_NORMAL);
    }

    if (SpFileExists_Ustr (Path, FALSE)) {

        //
        // Delete the file
        //
        Status = SpDeleteFile_Ustr (Path, NULL, NULL);

    } else if (SpFileExists_Ustr (Path, TRUE)) {

        //
        // Delete the empty directory
        //
        Status = SpDeleteFileEx_Ustr (
                    Path,
                    NULL,
                    NULL,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_FOR_BACKUP_INTENT
                    );
    } else {
        Status = STATUS_SUCCESS;
    }
Exit:
    return Status;
}

NTSTATUS
SpDeleteFileEx(
    IN PCWSTR Name1,
    IN PCWSTR Name2, OPTIONAL
    IN PCWSTR Name3, OPTIONAL
    IN ULONG ShareFlags, OPTIONAL
    IN ULONG OpenFlags OPTIONAL
    )
{
    UNICODE_STRING UnicodeString1;
    UNICODE_STRING UnicodeString2;
    UNICODE_STRING UnicodeString3;
    NTSTATUS Status = STATUS_INTERNAL_ERROR;

    Status = RtlInitUnicodeStringEx(&UnicodeString1, Name1);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    Status = RtlInitUnicodeStringEx(&UnicodeString2, Name2);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    Status = RtlInitUnicodeStringEx(&UnicodeString3, Name3);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    Status = SpDeleteFileEx_Ustr(&UnicodeString1, &UnicodeString2, &UnicodeString3, ShareFlags, OpenFlags);
Exit:
    return Status;
}

NTSTATUS
SpDeleteFileEx_Ustr(
    IN PCUNICODE_STRING Name1,
    IN PCUNICODE_STRING Name2, OPTIONAL
    IN PCUNICODE_STRING Name3, OPTIONAL
    IN ULONG ShareFlags, OPTIONAL
    IN ULONG OpenFlags OPTIONAL
    )
{
    UNICODE_STRING p;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    FILE_DISPOSITION_INFORMATION Disposition;
    FILE_BASIC_INFORMATION       BasicInfo;

    //
    // Point to temporary buffer for pathname.
    //
    p = TemporaryBufferUnicodeString;

    //
    // Build up the full name of the file to delete.
    //
    RtlMoveMemory(p.Buffer, Name1->Buffer, Name1->Length);
    p.Length = Name1->Length;
    if(Name2 != NULL && Name2->Length != 0) {
        SpConcatenatePaths_Ustr(&p,Name2);
    }
    if(Name3 != NULL && Name3->Length != 0) {
        SpConcatenatePaths_Ustr(&p,Name3);
    }

    //
    // Prepare to open the file.
    //
    InitializeObjectAttributes(&Obja, &p, OBJ_CASE_INSENSITIVE, NULL, NULL);

    //
    // Attempt to open the file.
    //
    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)(DELETE | FILE_WRITE_ATTRIBUTES),
                &Obja,
                &IoStatusBlock,
                ShareFlags,
                OpenFlags
              );

    if(!NT_SUCCESS(Status)) {
        if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to open %wZ for delete (%lx)\n",p,Status));
        }
        return(Status);
    }

    //
    //  Change the file attribute to normal
    //

    RtlZeroMemory( &BasicInfo, sizeof( FILE_BASIC_INFORMATION ) );
    BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;

    Status = SpSetInformationFile(
                Handle,
                FileBasicInformation,
                sizeof(BasicInfo),
                &BasicInfo
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to change attribute of %wZ, Status = (%lx)\n",p,Status));
        return(Status);
    }

    //
    // Set up for delete and call worker to do it.
    //
    #undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = SpSetInformationFile(
                Handle,
                FileDispositionInformation,
                sizeof(Disposition),
                &Disposition
                );

    //
    // Clean up and return.
    //
    ZwClose(Handle);
    return(Status);
}

NTSTATUS
SpDeleteFile(
    IN PCWSTR Name1,
    IN PCWSTR Name2, OPTIONAL
    IN PCWSTR Name3  OPTIONAL
    )
{
    UNICODE_STRING UnicodeString1;
    UNICODE_STRING UnicodeString2;
    UNICODE_STRING UnicodeString3;
    NTSTATUS Status = STATUS_INTERNAL_ERROR;

    Status = RtlInitUnicodeStringEx(&UnicodeString1, Name1);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    Status = RtlInitUnicodeStringEx(&UnicodeString2, Name2);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    Status = RtlInitUnicodeStringEx(&UnicodeString3, Name3);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    Status = SpDeleteFile_Ustr(&UnicodeString1, &UnicodeString2, &UnicodeString3);
Exit:
    return Status;
}

NTSTATUS
SpDeleteFile_Ustr(
    IN PCUNICODE_STRING Name1,
    IN PCUNICODE_STRING Name2, OPTIONAL
    IN PCUNICODE_STRING Name3  OPTIONAL
    )
{

    return( SpDeleteFileEx_Ustr( Name1,
                            Name2,
                            Name3,
                            FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT ) );

}

BOOLEAN
SpFileExists(
    IN PCWSTR PathName,
    IN BOOLEAN Directory
    )
{
    BOOLEAN Result;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString(&UnicodeString, PathName);

    Result = SpFileExists_Ustr(&UnicodeString, Directory);

    return Result;
}

BOOLEAN
SpFileExists_Ustr(
    IN PCUNICODE_STRING PathName,
    IN BOOLEAN Directory
    )

/*++

Routine Description:

    Determine if a file or directory exists

Arguments:

    PathName - PathName of file or directory to check

    Directory - Whether PathName refers to a directory or a file

Return Value:

    NT_SUCCESS(NTSTATUS) if file exists.

--*/

{
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    InitializeObjectAttributes(&Obja, (PUNICODE_STRING)PathName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = ZwCreateFile(
                &Handle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                Directory ? FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE,
                NULL,
                0
                );

    if(NT_SUCCESS(Status)) {
        ZwClose(Handle);
        return(TRUE);
    } else {
        return(FALSE);
    }
}

NTSTATUS
SpRenameFile(
    IN PCWSTR  OldName,
    IN PCWSTR  NewName,
    IN BOOLEAN AllowDirectoryRename
    )
{
    UNICODE_STRING OldUnicodeString;
    UNICODE_STRING NewUnicodeString;
    NTSTATUS Status = STATUS_INTERNAL_ERROR;

    Status = RtlInitUnicodeStringEx(&OldUnicodeString, OldName);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    Status = RtlInitUnicodeStringEx(&NewUnicodeString, NewName);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    Status = SpRenameFile_Ustr(&OldUnicodeString, &NewUnicodeString, AllowDirectoryRename);
Exit:
    return Status;
}


NTSTATUS
SpRenameFile_Ustr(
    IN PCUNICODE_STRING   OldName,
    IN PCUNICODE_STRING   NewName,
    IN BOOLEAN AllowDirectoryRename
    )
/*++

Routine Description:

    Rename a file or directory

Arguments:

    OldName - Old name of file

    NewName - New name of file

    AllowDirectoryRename - if TRUE, then this routine will rename a directory,
        otherwise directory renames are not allowed.

Return Value:

    NT_SUCCESS(NTSTATUS) if file successfully renamed

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    struct {
        FILE_RENAME_INFORMATION NameInfo;
        WCHAR Buffer[ACTUAL_MAX_PATH];
    } Buffer;

    //
    // Prepare to open the file.
    //
    InitializeObjectAttributes(&Obja, (PUNICODE_STRING)OldName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    //
    // Attempt to open the file as a file.
    //
    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)(DELETE | SYNCHRONIZE),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if(!NT_SUCCESS(Status) && AllowDirectoryRename) {
        //
        // Attempt to open the file as a directory.
        //
        Status = ZwOpenFile(
                    &Handle,
                    (ACCESS_MASK)(DELETE | SYNCHRONIZE),
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                    );
    }

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to open %wZ for rename (%lx)\n",OldName,Status));
        return(Status);
    }

    //
    //  Change the file name
    //

    RtlZeroMemory(&Buffer, sizeof(Buffer));

    Buffer.NameInfo.ReplaceIfExists = FALSE;
    Buffer.NameInfo.RootDirectory   = NULL;
    Buffer.NameInfo.FileNameLength  = NewName->Length;
    RtlCopyMemory( Buffer.NameInfo.FileName, NewName->Buffer, NewName->Length );

    Status = SpSetInformationFile(
                Handle,
                FileRenameInformation,
                sizeof(Buffer),
                (PVOID)&Buffer
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to change name of %wZ to %wZ. Status = (%lx)\n",OldName,NewName,Status));
    }

    //
    // Clean up and return.
    //

    ZwClose(Handle);
    return(Status);


}

USHORT
SpChkSum(
    ULONG PartialSum,
    PUSHORT Source,
    ULONG Length
    )

/*++

Routine Description:

    Compute a partial checksum on a portion of an imagefile.

Arguments:

    PartialSum - Supplies the initial checksum value.

    Sources - Supplies a pointer to the array of words for which the
        checksum is computed.

    Length - Supplies the length of the array in words.

Return Value:

    The computed checksum value is returned as the function value.

--*/

{

    //
    // Compute the word wise checksum allowing carries to occur into the
    // high order half of the checksum longword.
    //

    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xffff);
    }

    //
    // Fold final carry into a single word result and return the resultant
    // value.
    //

    return (USHORT)(((PartialSum >> 16) + PartialSum) & 0xffff);
}


PIMAGE_NT_HEADERS
SpChecksumMappedFile(
    IN  PVOID  BaseAddress,
    IN  ULONG  FileSize,
    OUT PULONG HeaderSum,
    OUT PULONG Checksum
    )
{
    PIMAGE_NT_HEADERS NtHeaders;
    USHORT            PartialSum;
    PUSHORT           AdjustSum;

    try {

        //
        // Compute the checksum of this file and zero the header sum.
        //
        PartialSum = SpChkSum(0,BaseAddress,(FileSize+1) >> 1);
        *HeaderSum = 0;

        //
        // See whether this is an image.
        //
        if(NtHeaders = RtlImageNtHeader(BaseAddress)) {

            //
            // The file is an image file -- subtract the two checksum words
            // in the optional header from the computed checksum before adding
            // the file length, and set the value of the header checksum.
            //
            *HeaderSum = NtHeaders->OptionalHeader.CheckSum;
            AdjustSum = (PUSHORT)(&NtHeaders->OptionalHeader.CheckSum);
            PartialSum -= (PartialSum < AdjustSum[0]);
            PartialSum -= AdjustSum[0];
            PartialSum -= (PartialSum < AdjustSum[1]);
            PartialSum -= AdjustSum[1];
        }

        //
        // Compute the checksum.
        //
        *Checksum = (ULONG)PartialSum + FileSize;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        NtHeaders = NULL;
    }

    return(NtHeaders);
}


NTSTATUS
SpOpenNameMayBeCompressed(
    IN  PWSTR    FullPath,
    IN  ULONG    OpenAccess,
    IN  ULONG    FileAttributes,
    IN  ULONG    ShareFlags,
    IN  ULONG    Disposition,
    IN  ULONG    OpenFlags,
    OUT PHANDLE  Handle,
    OUT PBOOLEAN OpenedCompressedName   OPTIONAL
    )
{
    NTSTATUS Status;
    PWSTR compname;
    PWSTR names[2];
    int compord,uncompord;
    static BOOLEAN PreviousWasCompressed = FALSE;
    BOOLEAN IsComp;
    int i;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Generate compressed name.
    //
    compname = SpGenerateCompressedName(FullPath);

    //
    // Figure out which name to try to use first.  If the last successful
    // call to this routine opened the file using the compressed name, then
    // try to open the compressed name first.  Otherwise try to open the
    // uncompressed name first.
    //
    if(PreviousWasCompressed) {
        compord = 0;
        uncompord = 1;
    } else {
        compord = 1;
        uncompord = 0;
    }

    names[uncompord] = FullPath;
    names[compord] = compname;

    for(i=0; i<2; i++) {

        INIT_OBJA(&Obja,&UnicodeString,names[i]);

        Status = ZwCreateFile(
                    Handle,
                    OpenAccess,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FileAttributes,
                    ShareFlags,
                    Disposition,
                    OpenFlags,
                    NULL,
                    0
                    );

        if(NT_SUCCESS(Status)) {

            IsComp = (BOOLEAN)(i == compord);

            PreviousWasCompressed = IsComp;
            if(OpenedCompressedName) {
                *OpenedCompressedName = IsComp;
            }

            break;
        }
    }

    SpMemFree(compname);
    return(Status);
}

NTSTATUS
SpGetFileSizeByName(
    IN  PWSTR DevicePath OPTIONAL,
    IN  PWSTR Directory  OPTIONAL,
    IN  PWSTR FileName,
    OUT PULONG Size
    )

/*++

Routine Description:

    Determine the size of a file.  Only the low 32 bits of the size
    are considered.

Arguments:

    DevicePath - Path to the device that contains the file.

    Directory - Name of the directory that contains the file.

    FileName - Name of the file.

    Size - receives size of file.

Return Value:

    NTSTATUs -

--*/

{
    PWSTR               CompleteFileName;
    HANDLE              FileHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeFileName;
    ULONG               FileNameLength;

    FileNameLength = wcslen( FileName ) + 1;
    if( DevicePath != NULL ) {
        FileNameLength += wcslen( DevicePath ) + 1;
    }
    if( Directory != NULL ) {
        FileNameLength += wcslen( Directory ) + 1;
    }

    CompleteFileName = SpMemAlloc( FileNameLength*sizeof( WCHAR ) );
    if( CompleteFileName == NULL ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to allocate memory on SpGetFileSizeByName \n" ));
        return( STATUS_NO_MEMORY );
    }

    *CompleteFileName = (WCHAR)'\0';
    if( DevicePath != NULL ) {
        SpConcatenatePaths( CompleteFileName, DevicePath );
    }
    if( Directory != NULL ) {
        SpConcatenatePaths( CompleteFileName, Directory );
    }
    SpConcatenatePaths( CompleteFileName, FileName );

    RtlInitUnicodeString( &UnicodeFileName,
                          CompleteFileName );

    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = ZwOpenFile( &FileHandle,
                         STANDARD_RIGHTS_READ | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         0,
                         FILE_SYNCHRONOUS_IO_NONALERT );

    if( !NT_SUCCESS( Status ) ) {
        SpMemFree( CompleteFileName );
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: ZwOpenFile() failed. File = %ls, Status = %x\n",FileName, Status ) );
        return( Status );
        }

    Status = SpGetFileSize( FileHandle, Size );
    ZwClose( FileHandle );
    SpMemFree( CompleteFileName );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpGetFileSize() failed. File = %ls, Status = %x\n",FileName, Status ) );
        return( Status );
    }
    return( Status );
}


VOID
SpVerifyNoCompression(
    IN PWSTR FileName
    )

/*++

Routine Description:

    Determine if the file is compressed (via NTFS compression), and if so,
    uncompress it.

Arguments:

    FileName - Name of the file that must be uncompressed.

Return Value:

    none

--*/

{
    HANDLE FileHandle;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    FILE_BASIC_INFORMATION BasicFileInfo;

    INIT_OBJA(&Obja, &UnicodeString, FileName);
    Status = ZwCreateFile(
                &FileHandle,
                0,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                0,
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        //
        // Ignore error.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpVerifyNoCompression unable to open file %ws (%lx)\n", FileName, Status));
        return;
    }

    Status = ZwQueryInformationFile(
                FileHandle,
                &IoStatusBlock,
                &BasicFileInfo,
                sizeof(BasicFileInfo),
                FileBasicInformation
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpVerifyNoCompression unable to get basic file info for %ws (%lx)\n", FileName, Status));
        goto ComprVerifyDone;
    }

    if(BasicFileInfo.FileAttributes & FILE_ATTRIBUTE_COMPRESSED) {

        USHORT CompressionState = 0;

        Status = ZwFsControlFile(
                     FileHandle,
                     NULL,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     FSCTL_SET_COMPRESSION,
                     &CompressionState,
                     sizeof(CompressionState),
                     NULL,
                     0
                     );
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpVerifyNoCompression unable to uncompress %ws (%lx)\n", FileName, Status));
        }
    }

ComprVerifyDone:
    ZwClose(FileHandle);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spgauge.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    spgauge.c

Abstract:

    Code implementing a gas gauge for file copies for text mode NT setup.

Author:

    Ted Miller (tedm) 14-April-1992

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop


PWSTR PctFmtStr = L"%u%%   ";


VOID
pSpDrawVariableParts(
    IN PGAS_GAUGE Gauge
    );



PVOID
SpCreateAndDisplayGauge(
    IN ULONG  ItemCount,
    IN ULONG  GaugeWidth,       OPTIONAL
    IN ULONG  Y,
    IN PWCHAR Caption,
    IN PWCHAR ProgressFmtStr,   OPTIONAL
    IN ULONG  Flags,            OPTIONAL
    IN UCHAR  Attribute         OPTIONAL
    )
{
    PGAS_GAUGE Gauge;
    ULONG X;


    //
    // Allocate a gauge structure.
    //
    Gauge = SpMemAlloc(sizeof(GAS_GAUGE));
    if(!Gauge) {
        return(NULL);
    }

    Gauge->Buffer = SpMemAlloc(VideoVars.ScreenWidth*sizeof(WCHAR));
    if(!Gauge->Buffer) {
        SpMemFree(Gauge);
        return(NULL);
    }

    Gauge->Caption = SpMemAlloc((wcslen(Caption)+1)*sizeof(WCHAR));
    if(!Gauge->Caption) {
        SpMemFree(Gauge->Buffer);
        SpMemFree(Gauge);
        return(NULL);
    }
    wcscpy(Gauge->Caption,Caption);

    if (ProgressFmtStr) {
        Gauge->ProgressFmtStr = SpMemAlloc((wcslen(ProgressFmtStr)+1)*sizeof(WCHAR));
        if(!Gauge->ProgressFmtStr) {
            SpMemFree(Gauge->Buffer);
            SpMemFree(Gauge->Caption);
            SpMemFree(Gauge);
            return(NULL);
        }
        wcscpy(Gauge->ProgressFmtStr,ProgressFmtStr);
        Gauge->ProgressFmtWidth = SplangGetColumnCount(ProgressFmtStr);
    } else {
        Gauge->ProgressFmtStr = PctFmtStr;
        Gauge->ProgressFmtWidth = 3;
    }

    Gauge->Flags = Flags;

    if (Attribute) {
       Gauge->Attribute = Attribute;
    } else {
       Gauge->Attribute = GAUGE_ATTRIBUTE;
    }

    //
    // If the caller did not specify a width, calculate one.
    // Originally, a gauge was 66 chars wide on an 80 character vga screen.
    // To preserve that ratio, make the width 66/80ths of the screen.
    //
    if(!GaugeWidth) {

        GaugeWidth = VideoVars.ScreenWidth * 66 / 80;
        if(GaugeWidth & 1) {
            GaugeWidth++;        // make sure it's even.
        }
    }

    //
    // Center the gauge horizontally.
    //
    X = (VideoVars.ScreenWidth - GaugeWidth) / 2;

    Gauge->GaugeX = X;
    Gauge->GaugeY = Y;
    Gauge->GaugeW = GaugeWidth;

    //
    // Calculate the size of the thermometer box.
    // The box is always offset by 6 characters from the gauge itself.
    //

    Gauge->ThermX = X+6;
    Gauge->ThermY = Y+3;
    Gauge->ThermW = GaugeWidth-12;

    //
    // Save away additional info about the gauge.
    //

    Gauge->ItemCount = max (ItemCount, 1);  // ensure no divide-by-zero bug checks
    Gauge->ItemsElapsed = 0;
    Gauge->CurrentPercentage = 0;

    SpDrawGauge(Gauge);

    return(Gauge);
}


VOID
SpDestroyGauge(
    IN PVOID GaugeHandle
    )
{
    PGAS_GAUGE Gauge = (PGAS_GAUGE)GaugeHandle;

    if (Gauge == NULL)
        return;

    if (Gauge->ProgressFmtStr != PctFmtStr) {
       SpMemFree(Gauge->ProgressFmtStr);
    }
    SpMemFree(Gauge->Caption);
    SpMemFree(Gauge->Buffer);
    SpMemFree(Gauge);
}



VOID
SpDrawGauge(
    IN PVOID GaugeHandle
    )
{
    PGAS_GAUGE Gauge = (PGAS_GAUGE)GaugeHandle;

    //
    // Draw the outer box.
    //
    SpDrawFrame(
        Gauge->GaugeX,
        Gauge->GaugeW,
        Gauge->GaugeY,
        GAUGE_HEIGHT,
        DEFAULT_ATTRIBUTE,
        TRUE
        );

    //
    // Draw the thermometer box.
    //
    SpDrawFrame(
        Gauge->ThermX,
        Gauge->ThermW,
        Gauge->ThermY,
        3,
        DEFAULT_ATTRIBUTE,
        FALSE
        );

    //
    // Percent complete, etc.
    //
    pSpDrawVariableParts(Gauge);

    //
    // Caption text
    //
    SpvidDisplayString(Gauge->Caption,DEFAULT_ATTRIBUTE,Gauge->GaugeX+2,Gauge->GaugeY+1);
}



VOID
SpTickGauge(
    IN PVOID GaugeHandle
    )
{
    PGAS_GAUGE Gauge = (PGAS_GAUGE)GaugeHandle;
    ULONG NewPercentage;

    if(Gauge->ItemsElapsed < Gauge->ItemCount) {

        Gauge->ItemsElapsed++;

        NewPercentage = 100 * Gauge->ItemsElapsed / Gauge->ItemCount;

        if(NewPercentage != Gauge->CurrentPercentage) {

            Gauge->CurrentPercentage = NewPercentage;

            pSpDrawVariableParts(Gauge);
        }
    }
}


VOID
pSpDrawVariableParts(
    IN PGAS_GAUGE Gauge
    )
{
    ULONG Spaces;
    ULONG i;
    WCHAR Percent[128];

    //
    // Figure out how many spaces this is.
    //
    Spaces = Gauge->ItemsElapsed * (Gauge->ThermW-2) / Gauge->ItemCount;

    for(i=0; i<Spaces; i++) {
        Gauge->Buffer[i] = L' ';
    }
    Gauge->Buffer[Spaces] = 0;

    SpvidDisplayString(Gauge->Buffer,Gauge->Attribute,Gauge->ThermX+1,Gauge->ThermY+1);

    //
    // Now put the percentage text up.
    //
    switch (Gauge->Flags) {
        case GF_PERCENTAGE:
            swprintf( Percent, Gauge->ProgressFmtStr, Gauge->CurrentPercentage );
            break;

        case GF_ITEMS_REMAINING:
            swprintf( Percent, Gauge->ProgressFmtStr, Gauge->ItemCount - Gauge->ItemsElapsed );
            break;

        case GF_ITEMS_USED:
            swprintf( Percent, Gauge->ProgressFmtStr, Gauge->ItemsElapsed );
            break;
    }

    SpvidDisplayString(
        Percent,
        DEFAULT_ATTRIBUTE,
        Gauge->GaugeX + ((Gauge->GaugeW-Gauge->ProgressFmtWidth)/2),
        Gauge->GaugeY+2
        );
}


VOID
SpFillGauge(
    IN PVOID GaugeHandle,
    IN ULONG Amount
    )
{
    PGAS_GAUGE Gauge = (PGAS_GAUGE)GaugeHandle;
    ULONG NewPercentage;

    if(Amount <= Gauge->ItemCount) {

        Gauge->ItemsElapsed = Amount;

        NewPercentage = 100 * Gauge->ItemsElapsed / Gauge->ItemCount;

        if(NewPercentage != Gauge->CurrentPercentage) {

            Gauge->CurrentPercentage = NewPercentage;

            pSpDrawVariableParts(Gauge);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spgauge.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spgauge.h

Abstract:

    Public header file for gas gauge functions in text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/


#ifndef _SPGAUGE_DEFN_
#define _SPGAUGE_DEFN_


#define GF_PERCENTAGE           0
#define GF_ITEMS_REMAINING      1
#define GF_ITEMS_USED           2

PVOID
SpCreateAndDisplayGauge(
    IN ULONG  ItemCount,
    IN ULONG  GaugeWidth,       OPTIONAL
    IN ULONG  Y,
    IN PWCHAR Caption,
    IN PWCHAR ProgressFmtStr,   OPTIONAL
    IN ULONG  Flags,            OPTIONAL
    IN UCHAR  Attribute         OPTIONAL
    );

VOID
SpDestroyGauge(
    IN PVOID GaugeHandle
    );

VOID
SpDrawGauge(
    IN PVOID GaugeHandle
    );

VOID
SpTickGauge(
    IN PVOID GaugeHandle
    );

VOID
SpFillGauge(
    IN PVOID GaugeHandle,
    IN ULONG Amount
    );


//
// Character attribute for thermometer portion of the gas gauge.
// Because we're using spaces for the gauge, the foreground attribute
// is irrelevent.
//
// Need intense attribute or the thermometer comes out orange on some machines.
//
#define GAUGE_ATTRIBUTE (ATT_BG_YELLOW | ATT_BG_INTENSE )


#define GAUGE_HEIGHT 7

#endif // ndef _SPGAUGE_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sphelp.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sphelp.c

Abstract:

    Routines for displaying on-line help during text setup.

Author:

    Ted Miller (tedm) 2-Aug-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop


#define MAX_HELP_SCREENS 100

PWSTR HelpScreen[MAX_HELP_SCREENS+1];


VOID
SpHelp(
    IN ULONG    MessageId,      OPTIONAL
    IN PCWSTR   FileText,       OPTIONAL
    IN ULONG    Flags
    )
{
    UCHAR StatusAttribute, BackgroundAttribute, HeaderAttribute,
          ClientAttribute, ClientIntenseAttribute;
    PWSTR HelpText,p,q;
    ULONG ScreenCount;
    ULONG ValidKeys[8];
    ULONG CurrentScreen;
    ULONG y;
    BOOLEAN Intense;
    BOOLEAN Done;
    unsigned kc;

    //
    // Pick the video attributes we want
    //
    if(Flags & SPHELP_LICENSETEXT) {

        StatusAttribute = DEFAULT_STATUS_ATTRIBUTE;
        BackgroundAttribute = DEFAULT_BACKGROUND;
        HeaderAttribute = DEFAULT_ATTRIBUTE;
        ClientAttribute = DEFAULT_ATTRIBUTE;
        ClientIntenseAttribute = (ATT_FG_INTENSE  | ATT_BG_INTENSE);

    } else {

        StatusAttribute = (ATT_FG_WHITE | ATT_BG_BLUE);
        BackgroundAttribute = ATT_WHITE;
        HeaderAttribute = (ATT_FG_BLUE  | ATT_BG_WHITE);
        ClientAttribute = (ATT_FG_BLACK | ATT_BG_WHITE);
        ClientIntenseAttribute = (ATT_FG_BLUE  | ATT_BG_WHITE);
    }

    //
    // Retreive the help text.
    //
    if (FileText) {
        HelpText = (PWSTR)FileText;
    } else {
        HelpText = SpRetreiveMessageText(NULL,MessageId,NULL,0);
        if (!HelpText) { // no way to return an error code, so fail quietly
	    goto s0;
        }
    }

    //
    // Shop off extra blank lines in the text.
    //
    p = HelpText + wcslen(HelpText);
    while((p > HelpText) && SpIsSpace(*(p-1))) {
        p--;
    }
    if(q = wcschr(p,L'\n')) {
        *(++q) = 0;
    }

    //
    // Break up the help text into screens.
    // The maximum length of a help screen will be the client screen size
    // minus two lines for spacing.  A %P alone at the beginning of a line
    // forces a page break.
    //
    for(p=HelpText,ScreenCount=0; (p && *p); ) {

        //
        // Mark the start of a new screen.
        //
        HelpScreen[ScreenCount++] = p;

        //
        // Count lines in the help text.
        //
        for(y=0; (p && *p); ) {

            //
            // Determine whether this line is really a hard page break
            // or if we have exhausted the number of lines allowed on a screen.
            //
            if(((p[0] == L'%') && (p[1] == 'P')) || (++y == CLIENT_HEIGHT-2)) {
                break;
            }

            //
            // Find next line start.
            //
            if(q = wcschr(p,L'\r')) {
                p = q + 2;
            } else {
                p = wcschr(p,0);
            }
        }

        //
        // Find the end of the line that broke us out of the loop
        // and then the start of the next line (if any).
        //
        if(q = wcschr(p,L'\r')) {
            p = q + 2;
        } else {
            p = wcschr(p,0);
        }

        if(ScreenCount == MAX_HELP_SCREENS) {
            break;
        }
    }

    //
    // Sentinal value: point to the terminating nul byte.
    //
    HelpScreen[ScreenCount] = p;

    //
    // Display header text in blue on white.
    //
    SpvidClearScreenRegion(0,0,VideoVars.ScreenWidth,HEADER_HEIGHT,BackgroundAttribute);
    if(Flags & SPHELP_LICENSETEXT) {
        SpDisplayHeaderText(SP_HEAD_LICENSE,HeaderAttribute);
    } else {
        SpDisplayHeaderText(SP_HEAD_HELP,HeaderAttribute);
    }

    //
    // The first screen to display is screen 0.
    //
    CurrentScreen = 0;

    Done = FALSE;
    do {

        SpvidClearScreenRegion(
            0,
            HEADER_HEIGHT,
            VideoVars.ScreenWidth,
            VideoVars.ScreenHeight-(HEADER_HEIGHT+STATUS_HEIGHT),
            BackgroundAttribute
            );

        //
        // Display the current screen.
        //
        for(y=HEADER_HEIGHT+1, p=HelpScreen[CurrentScreen]; *p && (p < HelpScreen[CurrentScreen+1]); y++) {

            Intense = FALSE;
            if(p[0] == L'%') {
                if(p[1] == L'I') {
                    Intense = TRUE;
                    p += 2;
                } else {
                    if(p[1] == L'P') {
                        p += 2;     // don't display %P
                    }
                }
            }

            q = wcschr(p,L'\r');
            if(q) {
                *q = 0;
            }

            SpvidDisplayString(
                p,
                (UCHAR)(Intense ? ClientIntenseAttribute : ClientAttribute),
                3,
                y
                );

            if(q) {
                *q = '\r';
                p = q + 2;
            } else {
                p = wcschr(p,0);
            }
        }

        //
        // Construct a list of valid keypresses from the user, depending
        // on whether this is the first, last, etc. screen.
        //
        // If there are previous screens, BACKSPACE=Read Last Help is an option.
        // If there are additional screens, ENTER=Continue Reading Help is an option.
        // ESC=Cancel Help is always an option for help text.
        //
        // For licensing text, we allow pageup/pagedown when appropriate,
        // and on the last page we allow accept/reject.
        //
        kc = 0;

        if(Flags & SPHELP_LICENSETEXT) {

            ValidKeys[kc++] = KEY_F8;
            ValidKeys[kc++] = ASCI_ESC;

            if(CurrentScreen) {
                ValidKeys[kc++] = KEY_PAGEUP;
            }
            if(CurrentScreen < ScreenCount-1) {
                ValidKeys[kc++] = KEY_PAGEDOWN;
            }

        } else {

            ValidKeys[kc++] = ASCI_ESC;

            if(CurrentScreen) {
                ValidKeys[kc++] = ASCI_BS;
                ValidKeys[kc++] = KEY_PAGEUP;
            }
            if(CurrentScreen < ScreenCount-1) {
                ValidKeys[kc++] = ASCI_CR;
                ValidKeys[kc++] = KEY_PAGEDOWN;
            }
        }

        ValidKeys[kc] = 0;

        if(CurrentScreen && (CurrentScreen < ScreenCount-1)) {
            //
            // There are screens before and after this one.
            //
            if(Flags & SPHELP_LICENSETEXT) {

                SpDisplayStatusOptions(
                    StatusAttribute,
                    SP_STAT_X_EQUALS_ACCEPT_LICENSE,
                    SP_STAT_X_EQUALS_REJECT_LICENSE,
                    SP_STAT_PAGEDOWN_EQUALS_NEXT_LIC,
                    SP_STAT_PAGEUP_EQUALS_PREV_LIC,
                    0
                    );

            } else {

                SpDisplayStatusOptions(
                    StatusAttribute,
                    SP_STAT_ENTER_EQUALS_CONTINUE_HELP,
                    SP_STAT_BACKSP_EQUALS_PREV_HELP,
                    SP_STAT_ESC_EQUALS_CANCEL_HELP,
                    0
                    );
            }
        } else {
            if(CurrentScreen) {
                //
                // This is the last page but not the only page.
                //
                if(Flags & SPHELP_LICENSETEXT) {

                    SpDisplayStatusOptions(
                        StatusAttribute,
                        SP_STAT_X_EQUALS_ACCEPT_LICENSE,
                        SP_STAT_X_EQUALS_REJECT_LICENSE,
                        SP_STAT_PAGEUP_EQUALS_PREV_LIC,
                        0
                        );

                } else {

                    SpDisplayStatusOptions(
                        StatusAttribute,
                        SP_STAT_BACKSP_EQUALS_PREV_HELP,
                        SP_STAT_ESC_EQUALS_CANCEL_HELP,
                        0
                        );
                }
            } else {
                if(CurrentScreen < ScreenCount-1) {
                    //
                    // This is the first page but additional pages exist.
                    //
                    if(Flags & SPHELP_LICENSETEXT) {

                        SpDisplayStatusOptions(
                            StatusAttribute,
                            SP_STAT_X_EQUALS_ACCEPT_LICENSE,
                            SP_STAT_X_EQUALS_REJECT_LICENSE,
                            SP_STAT_PAGEDOWN_EQUALS_NEXT_LIC,
                            0
                            );

                    } else {

                        SpDisplayStatusOptions(
                            StatusAttribute,
                            SP_STAT_ENTER_EQUALS_CONTINUE_HELP,
                            SP_STAT_ESC_EQUALS_CANCEL_HELP,
                            0
                            );
                    }
                } else {
                    //
                    // This is the only page.
                    //
                    if(Flags & SPHELP_LICENSETEXT) {

                        SpDisplayStatusOptions(
                            StatusAttribute,
                            SP_STAT_X_EQUALS_ACCEPT_LICENSE,
                            SP_STAT_X_EQUALS_REJECT_LICENSE,
                            0
                            );

                    } else {

                        SpDisplayStatusOptions(
                            StatusAttribute,
                            SP_STAT_ESC_EQUALS_CANCEL_HELP,
                            0
                            );
                    }
                }
            }
        }

        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case ASCI_ESC:

            if(Flags & SPHELP_LICENSETEXT) {
                SpDone(0,FALSE,TRUE);
            }

            // ELSE FALL THROUGH

        case KEY_F8:

            Done = TRUE;
            break;

        case KEY_PAGEUP:
        case ASCI_BS:

            ASSERT(CurrentScreen);
            CurrentScreen--;
            break;

        case KEY_PAGEDOWN:
        case ASCI_CR:

            ASSERT(CurrentScreen < ScreenCount-1);
            CurrentScreen++;
            break;
        }
    } while(!Done);

    //
    // Clean up.
    //
    if(!FileText) {
        SpMemFree(HelpText);
    }

s0:
    CLEAR_ENTIRE_SCREEN();
    
    SpDisplayHeaderText(
        SpGetHeaderTextId(),
        DEFAULT_ATTRIBUTE
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sphw.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sphw.h

Abstract:

    Header file for hardware detection and
    confirmation routines for text setup.

Author:

    Ted Miller (tedm) 1-October-1993

Revision History:

--*/


#ifndef _SPHW_DEFN_
#define _SPHW_DEFN_

VOID
SpConfirmScsiMiniports(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    );

VOID
SpConfirmHardware(
    IN PVOID SifHandle
    );

VOID
SpInitializePreinstallList(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        OemPreinstallSourcePath
    );


//
// In splddrv.c
//
VOID
SpLoadScsiClassDrivers(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnBootDevice
    );

VOID
SpLoadCdRomDrivers(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnBootDevice
    );

VOID
SpLoadDiskDrivers(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnBootDevice
    );

BOOLEAN
SpInstallingMp(
    VOID
    );

BOOLEAN
SpSelectSectionItem(
    IN    PVOID   SifHandle,
    IN    PWSTR   SectionName,
    IN    ULONG   SelectScreenId,
    IN    ULONG   DefaultSelection OPTIONAL,
    OUT   PULONG  SelectedOption
    );

//
// enum to represent flopy disk drive types.
//
typedef enum {    
    FloppyTypeNone,
    FloppyType525Low,
    FloppyType525High,
    FloppyType35Low,
    FloppyType35High,
    FloppyType35High120MB
} FloppyDriveType;

FloppyDriveType
SpGetFloppyDriveType(
    IN ULONG FloppyOrdinal
    );

#define IS_525_DRIVE(x)  (((x)==FloppyType525Low) || ((x)==FloppyType525High))
#define IS_35_DRIVE(x)   (((x)==FloppyType35Low) || ((x)==FloppyType35High))


typedef struct _HARDWARE_COMPONENT_REGISTRY {

    struct _HARDWARE_COMPONENT_REGISTRY *Next;

    //
    // The name of the key.  The empty string means the key in the
    // services key itself.
    //

    PWSTR KeyName;

    //
    // The name of the value within the registry key
    //

    PWSTR ValueName;

    //
    // The data type for the value (ie, REG_DWORD, etc)
    //

    ULONG ValueType;

    //
    // The buffer containing the data to be placed into the value
    //

    PVOID Buffer;

    //
    // The size of the buffer in bytes
    //

    ULONG BufferSize;


} HARDWARE_COMPONENT_REGISTRY, *PHARDWARE_COMPONENT_REGISTRY;


//
// One of these will be created for each file to be copied for a
// third party device.
//
typedef struct _HARDWARE_COMPONENT_FILE {

    struct _HARDWARE_COMPONENT_FILE *Next;

    //
    // Filename of the file.
    //

    PWSTR Filename;

    //
    // type of the file (hal, port, class, etc).
    //

    HwFileType FileType;

    //
    // Part of name of the section in txtsetup.oem [Config.<ConfigName>]
    // that contains registry options.  If this is NULL, then no registry
    // information is associated with this file.
    //
    PWSTR ConfigName;

    //
    // Registry values for the node in the services list in the registry.
    //

    PHARDWARE_COMPONENT_REGISTRY RegistryValueList;

    //
    // These two fields are used when prompting for the diskette
    // containing the third-party-supplied driver's files.
    //

    PWSTR DiskDescription;
    PWSTR DiskTagFile;

    //
    // Directory where files are to be found on the disk.
    //
    PWSTR Directory;

    //
    // Arc name of the device from which the file was copied
    //
    PWSTR ArcDeviceName;

} HARDWARE_COMPONENT_FILE, *PHARDWARE_COMPONENT_FILE;



//
// structure for storing information about a driver we have located and
// will install.
//

typedef struct _HARDWARE_COMPONENT {

    struct _HARDWARE_COMPONENT *Next;

    //
    // String used as a key into the relevent section (like [Display],
    // [Mouse], etc).
    //

    PWSTR IdString;

    //
    // String that describes the hardware.
    //

    PWSTR Description;

    //
    // If this is TRUE, then there is an OEM option selected for this
    // hardware.
    //

    BOOLEAN ThirdPartyOptionSelected;

    //
    // Bits to be set if a third party option is selected, indicating
    // which type of files are specified in the oem inf file.
    //

    ULONG FileTypeBits;

    //
    // Files for a third party option.
    //

    PHARDWARE_COMPONENT_FILE Files;

    //
    // For some components this is the name of a device driver file.
    //
    PWSTR BaseDllName;

    //
    // If this is TRUE, then the driver for this device was migrated from an
    // existing NT system.
    //

    BOOLEAN MigratedDriver;

} HARDWARE_COMPONENT, *PHARDWARE_COMPONENT;


PHARDWARE_COMPONENT
SpSetupldrHwToHwDevice(
    IN PDETECTED_DEVICE SetupldrHw
    );

extern PHARDWARE_COMPONENT HardwareComponents[HwComponentMax];
extern PHARDWARE_COMPONENT ScsiHardware;
extern PHARDWARE_COMPONENT BootBusExtenders;
extern PHARDWARE_COMPONENT BusExtenders;
extern PHARDWARE_COMPONENT InputDevicesSupport;
extern PHARDWARE_COMPONENT PreinstallHardwareComponents[HwComponentMax];
extern PHARDWARE_COMPONENT PreinstallScsiHardware;
extern PHARDWARE_COMPONENT UnsupportedScsiHardwareToDisable;

#ifdef _ALPHA_

extern PWSTR OemPalFilename, OemPalDiskDescription;

#endif _ALPHA_

VOID
SpFreeHwComponent(
    IN OUT PHARDWARE_COMPONENT *HwComp,
    IN     BOOLEAN              FreeAllInList
    );


//
// These are the names of the components.  This is array is not localized
// because it is used only to index hardware-related sections in the
// setup information file.
//
extern PWSTR NonlocalizedComponentNames[HwComponentMax];

extern PWSTR ScsiSectionName;

extern ULONG LoadedScsiMiniportCount;


//
// structure for storing the PNP database.
//

typedef struct _SETUP_PNP_HARDWARE_ID {

    struct _SETUP_PNP_HARDWARE_ID *Next;

    //
    // String that represents the hardware id of a PNP device.
    //

    PWSTR Id;

    //
    // Driver for the device
    //

    PWSTR DriverName;

    //
    // Class GUID for this device, if any
    //

    PWSTR ClassGuid;


} SETUP_PNP_HARDWARE_ID, *PSETUP_PNP_HARDWARE_ID;


PSETUP_PNP_HARDWARE_ID
SpSetupldrPnpDatabaseToSetupPnpDatabase(
    IN PPNP_HARDWARE_ID HardwareIdDatabase
    );

//
// OEM Virtual Source Device abstraction
//
typedef struct _VIRTUAL_OEM_SOURCE_DEVICE {
    //
    // Next device
    //
    struct _VIRTUAL_OEM_SOURCE_DEVICE *Next;

    //
    // Device Id (for ARC name mapping)
    //
    ULONG   DeviceId;

    //
    // Arc device name
    //
    PWSTR   ArcDeviceName;

    //
    // Memory address where the device image is copied
    // by the loader
    //
    PVOID   ImageBase;

    //
    // Image size
    //
    ULONGLONG   ImageSize;
    
} VIRTUAL_OEM_SOURCE_DEVICE, *PVIRTUAL_OEM_SOURCE_DEVICE;

#define MS_RAMDISK_DRIVER_PARAM    L"Disk"

//
// Virtual OEM source devices (accessible through RAM driver)
//
extern PVIRTUAL_OEM_SOURCE_DEVICE VirtualOemSourceDevices;

NTSTATUS
SpInitVirtualOemDevices(
    IN PSETUP_LOADER_BLOCK SetupLoaderBlock,
    OUT PVIRTUAL_OEM_SOURCE_DEVICE *SourceDevices
    );

#endif // ndef _SPHW_DEFN_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spfsrec.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spfsrec.h

Abstract:

    Header file for filesystem recognition.

Author:

    Ted Miller (tedm) 16-Sep-1993

Revision History:

--*/


#ifndef _SPFSREC_
#define _SPFSREC_


//
// Do NOT rearrange this enum without changing
// the order of the filesystem names in the message file
// (starting at SP_TEXT_FS_NAME_BASE).
//
typedef enum {
    FilesystemUnknown       = 0,
    FilesystemNewlyCreated  = 1,
    FilesystemFat           = 2,
    FilesystemFirstKnown    = FilesystemFat,
    FilesystemNtfs          = 3,
    FilesystemFat32         = 4,
    FilesystemDoubleSpace   = 5,
    FilesystemMax
} FilesystemType;



FilesystemType
SpIdentifyFileSystem(
    IN PWSTR     DevicePath,
    IN ULONG     BytesPerSector,
    IN ULONG     PartitionOrdinal
    );

ULONG
NtfsMirrorBootSector (
    IN      HANDLE  Handle,
    IN      ULONG   BytesPerSector,
    IN OUT  PUCHAR  *Buffer
    );

VOID
WriteNtfsBootSector (
    IN HANDLE PartitionHandle,
    IN ULONG  BytesPerSector,
    IN PVOID  Buffer,
    IN ULONG  WhichOne
    );

//
// File system boot code.
//
extern UCHAR FatBootCode[512];
extern UCHAR Fat32BootCode[3*512];
extern UCHAR NtfsBootCode[16*512];
extern UCHAR PC98FatBootCode[512]; //NEC98
extern UCHAR PC98Fat32BootCode[3*512]; //NEC98
extern UCHAR PC98NtfsBootCode[8192]; //NEC98

#endif // ndef _SPFSREC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spkbd.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spkbd.h

Abstract:

    Public header file for text setup input support.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:
    + Added defines for ASCI_D
      (Michael Peterson, Seagate Software, 29 April, 1997)

--*/


#ifndef _SPINPUT_DEFN_
#define _SPINPUT_DEFN_



VOID
SpInputInitialize(
    VOID
    );

VOID
SpInputTerminate(
    VOID
    );

VOID
SpInputLoadLayoutDll(
    IN PVOID SifHandle,
    IN PWSTR Directory
    );

ULONG
SpInputGetKeypress(
    VOID
    );

BOOLEAN
SpInputIsKeyWaiting(
    VOID
    );

VOID
SpInputDrain(
    VOID
    );

VOID
SpSelectAndLoadLayoutDll(
  IN PWSTR Directory,
  IN PVOID SifHandle,
  IN BOOLEAN ShowStatus
  );

#define ASCI_ETX    3   //  control-C
#define ASCI_BS     8
#define ASCI_NL     10
#define ASCI_C      67
#define ASCI_LOWER_C 99
#define ASCI_CR     13
#define ASCI_ESC    27

//
// Character codes are passed around as ULONGs within setup.
// The low word is a Unicode character value; the high word
// is used for various other keypresses.
//
#define KEY_PAGEUP          0x00010000
#define KEY_PAGEDOWN        0x00020000
#define KEY_UP              0x00030000
#define KEY_DOWN            0x00040000
#define KEY_LEFT            0x00050000
#define KEY_RIGHT           0x00060000
#define KEY_HOME            0x00070000
#define KEY_END             0x00080000
#define KEY_INSERT          0x00090000
#define KEY_DELETE          0x000a0000
#define KEY_F1              0x00110000
#define KEY_F2              0x00120000
#define KEY_F3              0x00130000
#define KEY_F4              0x00140000
#define KEY_F5              0x00150000
#define KEY_F6              0x00160000
#define KEY_F7              0x00170000
#define KEY_F8              0x00180000
#define KEY_F9              0x00190000
#define KEY_F10             0x001a0000
#define KEY_F11             0x001b0000
#define KEY_F12             0x001c0000

#define KEY_NON_CHARACTER   0xffff0000

#endif // ndef _SPINPUT_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spkbd.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spkbd.c

Abstract:

    Text setup keyboard support routines.

Author:

    Ted Miller (tedm) 30-July-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop
#include <kbd.h>
#include <ntddkbd.h>

PKBDTABLES KeyboardTable;

HANDLE hKeyboard;

BOOLEAN KeyboardInitialized = FALSE;
BOOLEAN KbdLayoutInitialized = FALSE;

USHORT CurrentLEDs;

//
// Globals for async I/O calls
//
KEYBOARD_INDICATOR_PARAMETERS asyncKbdParams;
IO_STATUS_BLOCK asyncIoStatusBlock;


#define MAX_KEYBOARD_ITEMS 10



VOID
spkbdApcProcedure(
    IN PVOID            ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG            Reserved
    );

VOID
spkbdSetLEDs(
    VOID
    );

VOID
SpkbdInitialize(
    VOID
    );

VOID
SpkbdTerminate(
    VOID
    );
    
VOID
SpkbdLoadLayoutDll(
    IN PVOID SifHandle,
    IN PWSTR Directory
    );
    
ULONG
SpkbdGetKeypress(
    VOID
    );

BOOLEAN
SpkbdIsKeyWaiting(
    VOID
    );

VOID
SpkbdDrain(
    VOID
    );


//
// Buffer for one character.
//
volatile ULONG KbdNextChar;


//
// The following are used in async calls to NtReadFile and so
// cannot be on the stack.
//
IO_STATUS_BLOCK     IoStatusKeyboard;
KEYBOARD_INPUT_DATA KeyboardInputData[MAX_KEYBOARD_ITEMS];
LARGE_INTEGER       DontCareLargeInteger;


//
// Current state of shift, control, alt keys.
//
USHORT  ModifierBits = 0;

#define START_KEYBOARD_READ()       \
                                    \
    ZwReadFile(                     \
        hKeyboard,                  \
        NULL,                       \
        spkbdApcProcedure,          \
        NULL,                       \
        &IoStatusKeyboard,          \
        KeyboardInputData,          \
        sizeof(KeyboardInputData),  \
        &DontCareLargeInteger,      \
        NULL                        \
        )



VOID
SpInputInitialize(
    VOID
    )

/*++

Routine Description:

    Initialize all input support.  This includes

    - opening the serial port and checking for a terminal.
    - opening the keyboard device.

Arguments:

    None.

Return Value:

    None. Does not return if not successful.

--*/

{
    SpkbdInitialize();
    SpTermInitialize();
}

VOID
SpInputTerminate(
    VOID
    )

/*++

Routine Description:

    Terminate all input support.  This includes

    - closing the serial port.
    - closing the keyboard device.

Arguments:

    None.

Return Value:

    None.

--*/

{
    SpkbdTerminate();
    SpTermTerminate();
}

VOID
SpInputLoadLayoutDll(
    IN PVOID SifHandle,
    IN PWSTR Directory
    )
{
    SpkbdLoadLayoutDll(SifHandle, Directory);
}

ULONG
SpInputGetKeypress(
    VOID
    )

/*++

Routine Description:

    Wait for a keypress and return it to the caller.
    The return value will be an ASCII value (ie, not a scan code).

Arguments:

    None.

Return Value:

    ASCII value.

--*/

{
    ULONG Tmp;

    //
    // If we are in upgrade graphics mode then
    // switch to textmode
    //
    SpvidSwitchToTextmode();

    while (TRUE) {
    
        if (SpTermIsKeyWaiting()) {
            Tmp = SpTermGetKeypress();
            if (Tmp != 0) {
                return Tmp;
            }
        }
        
        if (SpkbdIsKeyWaiting()) {
            return SpkbdGetKeypress();
        }
        
    }
    
}

BOOLEAN
SpInputIsKeyWaiting(
    VOID
    )

/*++

Routine Description:

    Tell the caller if a keypress is waiting to be fetched by
    a call to SpInputGetKeypress().

Arguments:

    None.

Return Value:

    TRUE is key waiting; FALSE otherwise.

--*/

{
    return (SpTermIsKeyWaiting() || SpkbdIsKeyWaiting());
}

VOID
SpInputDrain(
    VOID
    )
{
    SpTermDrain();
    SpkbdDrain();
}











//
//
// Below here are all the functions for keyboard operations...
//
//

VOID
SpkbdInitialize(
    VOID
    )

/*++

Routine Description:

    Initialize keyboard support.  This includes

    - opening the keyboard device.

Arguments:

    None.

Return Value:

    None. Does not return if not successful.

--*/

{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES Attributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    UnicodeString;

    ASSERT(!KeyboardInitialized);
    if(KeyboardInitialized) {
        return;
    }

    //
    // Open the keyboard.
    //
    RtlInitUnicodeString(&UnicodeString,DD_KEYBOARD_DEVICE_NAME_U L"0");

    InitializeObjectAttributes(
        &Attributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
                &hKeyboard,
                GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &Attributes,
                &IoStatusBlock,
                NULL,                   // allocation size
                FILE_ATTRIBUTE_NORMAL,
                0,                      // no sharing
                FILE_OPEN,
                0,
                NULL,                   // no EAs
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: NtOpenFile of " DD_KEYBOARD_DEVICE_NAME "0 returns %lx\n",Status));
        SpFatalKbdError(SP_SCRN_KBD_OPEN_FAILED);
    }

    //
    // Initialize LEDs.
    //

    //
    // No NEC98 has NumLock and NumLock LED.
    // Num keys must be act as Numlock alternated keys.
    //
    CurrentLEDs = (!IsNEC_98 ? 0 : KEYBOARD_NUM_LOCK_ON);
    spkbdSetLEDs();

    KeyboardInitialized = TRUE;

    //
    // Do not initialize keyboard input yet because we don't have a layout.
    //
}


VOID
SpkbdTerminate(
    VOID
    )

/*++

Routine Description:

    Terminate keyboard support.  This includes

    - closing the keyboard device.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    ASSERT(KeyboardInitialized);

    if(KeyboardInitialized) {

        Status = ZwClose(hKeyboard);

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to close " DD_KEYBOARD_DEVICE_NAME "0 (status = %lx)\n",Status));
        }

        KeyboardInitialized = FALSE;
    }
}


VOID
SpkbdLoadLayoutDll(
    IN PVOID SifHandle,
    IN PWSTR Directory
    )
{
    PWSTR    p,LayoutDll;
    NTSTATUS Status;

    //
    // Determine layout name.
    //
    if(p = SpGetSectionKeyIndex(SifHandle,SIF_NLS,SIF_DEFAULTLAYOUT,1)) {
        LayoutDll = p;
    } else {
        p = SpGetSectionKeyIndex(SifHandle,SIF_NLS,SIF_DEFAULTLAYOUT,0);
        if(!p) {
            SpFatalSifError(SifHandle,SIF_NLS,SIF_DEFAULTLAYOUT,0,0);
        }

        LayoutDll = SpGetSectionKeyIndex(SifHandle,SIF_KEYBOARDLAYOUTFILES,p,0);
        if(!LayoutDll) {
            SpFatalSifError(SifHandle,SIF_KEYBOARDLAYOUTFILES,p,0,0);
        }
    }

    SpDisplayStatusText(SP_STAT_LOADING_KBD_LAYOUT,DEFAULT_STATUS_ATTRIBUTE,LayoutDll);

    //
    // Bugcheck if we can't load the layout dll, because we won't be able
    // to put up a screen and ask the user to hit f3, etc.
    //
    Status = SpLoadKbdLayoutDll(Directory,LayoutDll,&KeyboardTable);
    if(!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load layout dll %ws (%lx)\n",LayoutDll,Status));
        SpFatalKbdError(SP_SCRN_KBD_LAYOUT_FAILED, LayoutDll);
    }

    //
    // Erase status text line.
    //
    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,0);

    //
    // Now that we've loaded the layout, we can start accepting keyboard input.
    //
    START_KEYBOARD_READ();

    KbdLayoutInitialized = TRUE;
}


ULONG
SpkbdGetKeypress(
    VOID
    )

/*++

Routine Description:

    Wait for a keypress and return it to the caller.
    The return value will be an ASCII value (ie, not a scan code).

Arguments:

    None.

Return Value:

    ASCII value.

--*/

{
    ULONG k;

    //
    // Shouldn't be calling this until we have loaded a keyboard layout.
    //
    ASSERT(KeyboardTable);

    //
    // Wait for the user to press a key.
    //
    while(!KbdNextChar) {
        ;
    }

    k = KbdNextChar;
    KbdNextChar = 0;

    return(k);
}


BOOLEAN
SpkbdIsKeyWaiting(
    VOID
    )

/*++

Routine Description:

    Tell the caller if a keypress is waiting to be fetched by
    a call to SpkbdGetKeypress().

Arguments:

    None.

Return Value:

    TRUE is key waiting; FALSE otherwise.

--*/

{
    //
    // Shouldn't be calling this until we have loaded a keyboard layout.
    //
    ASSERT(KeyboardTable);

    return((BOOLEAN)(KbdNextChar != 0));
}


VOID
SpkbdDrain(
    VOID
    )

/*++

Routine Description:

    Drain the keyboard buffer, throwing away any keystrokes
    in the buffer waiting to be fetched.

Arguments:

    None.

Return Value:

    TRUE is key waiting; FALSE otherwise.

--*/

{
    ASSERT(KeyboardTable);

    KbdNextChar = 0;
}



ULONG
spkbdScanCodeToChar(
    IN UCHAR   Prefix,
    IN USHORT  ScanCode,
    IN BOOLEAN Break
    );


VOID
spkbdApcProcedure(
    IN PVOID            ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG            Reserved
    )

/*++

Routine Description:

    Async Procedure Call routine for keyboard reads.  The I/O
    system will call this routine when the keyboard class driver
    wants to return some data to us.

Arguments:

Return Value:

    None.

--*/

{
    UCHAR bPrefix;
    PKEYBOARD_INPUT_DATA pkei;
    ULONG k;

    UNREFERENCED_PARAMETER(ApcContext);
    UNREFERENCED_PARAMETER(Reserved);

    for(pkei = KeyboardInputData;
        (PUCHAR)pkei < (PUCHAR)KeyboardInputData + IoStatusBlock->Information;
        pkei++)
    {
        if(pkei->Flags & KEY_E0) {
            bPrefix = 0xE0;
        } else if (pkei->Flags & KEY_E1) {
            bPrefix = 0xE1;
        } else {
            bPrefix = 0;
        }

        k = spkbdScanCodeToChar(
                bPrefix,
                pkei->MakeCode,
                (BOOLEAN)((pkei->Flags & KEY_BREAK) != 0)
                );

        if(k) {
            KbdNextChar = k;
        }
    }

    //
    // Keyboard might have been terminated.
    //
    if(KeyboardInitialized) {
        START_KEYBOARD_READ();
    }
}


WCHAR SavedDeadChar = 0;
UCHAR AltNumpadAccum = 0;

struct {
    BYTE CursorKey;
    BYTE NumberKey;
    BYTE Value;
} NumpadCursorToNumber[] = { { VK_INSERT, VK_NUMPAD0,  0 },
                             { VK_END   , VK_NUMPAD1,  1 },
                             { VK_DOWN  , VK_NUMPAD2,  2 },
                             { VK_NEXT  , VK_NUMPAD3,  3 },
                             { VK_LEFT  , VK_NUMPAD4,  4 },
                             { VK_CLEAR , VK_NUMPAD5,  5 },
                             { VK_RIGHT , VK_NUMPAD6,  6 },
                             { VK_HOME  , VK_NUMPAD7,  7 },
                             { VK_UP    , VK_NUMPAD8,  8 },
                             { VK_PRIOR , VK_NUMPAD9,  9 },
                             { VK_DELETE, VK_DECIMAL, 10 }, // no value.
                             { 0        , 0         ,  0 }
                           };

ULONG
spkbdScanCodeToChar(
    IN UCHAR   Prefix,
    IN USHORT  ScanCode,
    IN BOOLEAN Break
    )
{
    USHORT VKey = 0;
    PVSC_VK VscVk;
    PVK_TO_WCHAR_TABLE pVKT;
    PVK_TO_WCHARS1 pVK;
    USHORT Modifier;
    USHORT ModBits,ModNum;
    WCHAR deadChar;

    ScanCode &= 0x7f;

    if(Prefix == 0) {

        if(ScanCode < KeyboardTable->bMaxVSCtoVK) {

            //
            // Index directly into non-prefix scan code table.
            //
            VKey = KeyboardTable->pusVSCtoVK[ScanCode];
            if(VKey == 0) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unknown scan code 0x%x\n",ScanCode));
                return (0);
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unknown scan code 0x%x\n",ScanCode));
            return(0);
        }
    } else {
        if(Prefix == 0xe0) {
            //
            // Ignore the SHIFT keystrokes generated by the hardware
            //
            if((ScanCode == SCANCODE_LSHIFT) || (ScanCode == SCANCODE_RSHIFT)) {
                return(0);
            }
            VscVk = KeyboardTable->pVSCtoVK_E0;
        } else if(Prefix == 0xe1) {
            VscVk = KeyboardTable->pVSCtoVK_E1;
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unknown keyboard scan prefix 0x%x\n",Prefix));
            return(0);
        }

        while(VscVk->Vk) {
            if(VscVk->Vsc == ScanCode) {
                VKey = VscVk->Vk;
                break;
            }
            VscVk++;
        }
        if(VKey == 0) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unknown keyboard scan prefix/code 0x%x/0x%x\n",Prefix,ScanCode));
            return(0);
        }
    }


    //
    // VirtualKey --> modifier bits.  This translation is also
    // mapped out in the pCharModifiers field in the keyboard layout
    // table but that seems redundant.
    //
    Modifier = 0;
    switch(VKey & 0xff) {
    case VK_LSHIFT:
    case VK_RSHIFT:
        Modifier = KBDSHIFT;
        break;
    case VK_LCONTROL:
    case VK_RCONTROL:
        Modifier = KBDCTRL;
        break;
    case VK_RMENU:
        //
        // AltGr ==> control+alt modifier.
        //
        if(KeyboardTable->fLocaleFlags & KLLF_ALTGR) {
            Modifier = KBDCTRL;
        }
        // fall through
    case VK_LMENU:
        Modifier |= KBDALT;
        break;
    }

    if(Break) {
        //
        // Key is being released.
        // If it's not a modifer, ignore it.
        //
        if(!Modifier) {
            return(0);
        }
        //
        // Key being released is a modifier.
        //
        ModifierBits &= ~Modifier;

        //
        // If it's ALT going up and we have a numpad key being entered,
        // return it.
        //
        if((Modifier & KBDALT) && AltNumpadAccum) {

            WCHAR UnicodeChar;

            RtlOemToUnicodeN(
                &UnicodeChar,
                sizeof(UnicodeChar),
                NULL,
                &AltNumpadAccum,
                1
                );

            AltNumpadAccum = 0;

            return(UnicodeChar);
        }
        return(0);
    } else {
        if(Modifier) {
            //
            // Key is being pressed and is a modifier.
            //
            ModifierBits |= Modifier;

            //
            // If ALT is going down, reset alt+numpad value.
            //
            if(Modifier & KBDALT) {
                AltNumpadAccum = 0;
            }
            return(0);
        }
    }

    //
    // If we get here, we've got a non-modifier key being made (pressed).
    // If the previous key was a dead key, the user gets only
    // one try to get a valid second half.
    //
    deadChar = SavedDeadChar;
    SavedDeadChar = 0;


    //
    // Special processing if the key is a numeric keypad key.
    //
    if(VKey & KBDNUMPAD) {

        int i;

        for(i=0; NumpadCursorToNumber[i].CursorKey; i++) {
            if(NumpadCursorToNumber[i].CursorKey == (BYTE)VKey) {

                //
                // Key is a numeric keypad key.  If ALT (and only alt) is down,
                // then we have an alt+numpad code being entered.
                //
                if(((ModifierBits & ~KBDALT) == 0) && (NumpadCursorToNumber[i].Value < 10)) {

                    AltNumpadAccum = (AltNumpadAccum * 10) + NumpadCursorToNumber[i].Value;
                }

                //
                // If numlock is on, translate the key from cursor movement
                // to a number key.
                //
                if(CurrentLEDs & KEYBOARD_NUM_LOCK_ON) {
                    VKey = NumpadCursorToNumber[i].NumberKey;
                }
                break;
            }
        }
    }

    //
    // We need to filter out keystrokes that we know are not part of any
    // character set here.
    //
    if((!deadChar)) {
        switch(VKey & 0xff) {
        case VK_CAPITAL:
            if(CurrentLEDs & KEYBOARD_CAPS_LOCK_ON) {
                CurrentLEDs &= ~KEYBOARD_CAPS_LOCK_ON;
            } else {
                CurrentLEDs |= KEYBOARD_CAPS_LOCK_ON;
            }
            spkbdSetLEDs();
            return(0);
        case VK_NUMLOCK:
            if(CurrentLEDs & KEYBOARD_NUM_LOCK_ON) {
                CurrentLEDs &= ~KEYBOARD_NUM_LOCK_ON;
            } else {
                CurrentLEDs |= KEYBOARD_NUM_LOCK_ON;
            }
            spkbdSetLEDs();
            return(0);
        case VK_PRIOR:
            return(KEY_PAGEUP);
        case VK_NEXT:
            return(KEY_PAGEDOWN);
        case VK_UP:
            return(KEY_UP);
        case VK_DOWN:
            return(KEY_DOWN);
        case VK_LEFT:
            return(KEY_LEFT);
        case VK_RIGHT:
            return(KEY_RIGHT);
        case VK_HOME:
            return(KEY_HOME);
        case VK_END:
            return(KEY_END);
        case VK_INSERT:
            return(KEY_INSERT);
        case VK_DELETE:
            return(KEY_DELETE);
        case VK_F1:
            return(KEY_F1);
        case VK_F2:
            return(KEY_F2);
        case VK_F3:
            return(KEY_F3);
        case VK_F4:
            return(KEY_F4);
        case VK_F5:
            return(KEY_F5);
        case VK_F6:
            return(KEY_F6);
        case VK_F7:
            return(KEY_F7);
        case VK_F8:
            return(KEY_F8);
        case VK_F9:
            return(KEY_F9);
        case VK_F10:
            return(KEY_F10);
        case VK_F11:
            return(KEY_F11);
        case VK_F12:
            return(KEY_F12);
        }
    }

    //
    // We think the character is probably a 'real' character.
    // Scan through all the shift-state tables until a matching Virtual
    // Key is found.
    //
    for(pVKT = KeyboardTable->pVkToWcharTable; pVKT->pVkToWchars; pVKT++) {
        pVK = pVKT->pVkToWchars;
        while(pVK->VirtualKey) {
            if(pVK->VirtualKey == (BYTE)VKey) {
                goto VK_Found;
            }
            pVK = (PVK_TO_WCHARS1)((PBYTE)pVK + pVKT->cbSize);
        }
    }

    //
    // Key is not valid with requested modifiers.
    //
    return(0);

    VK_Found:

    ModBits = ModifierBits;

    //
    // If CapsLock affects this key and it is on: toggle SHIFT state
    // only if no other state is on.
    // (CapsLock doesn't affect SHIFT state if Ctrl or Alt are down).
    //
    if((pVK->Attributes & CAPLOK) && ((ModBits & ~KBDSHIFT) == 0)
    && (CurrentLEDs & KEYBOARD_CAPS_LOCK_ON))
    {
        ModBits ^= KBDSHIFT;
    }

    //
    // Get the modification number.
    //
    if(ModBits > KeyboardTable->pCharModifiers->wMaxModBits) {
        return(0);  // invalid keystroke
    }

    ModNum = KeyboardTable->pCharModifiers->ModNumber[ModBits];
    if(ModNum == SHFT_INVALID) {
        return(0);  // invalid keystroke
    }

    if(ModNum >= pVKT->nModifications) {

        //
        // Key is not valid with current modifiers.
        // Could still be a control char that we can convert directly.
        //
        if((ModBits == KBDCTRL) || (ModBits == (KBDCTRL | KBDSHIFT))) {
            if(((UCHAR)VKey >= 'A') && ((UCHAR)VKey <= 'Z')) {
                return((ULONG)VKey & 0x1f);
            }
        }
        return(0);  // invalid keystroke
    }

    if(pVK->wch[ModNum] == WCH_NONE) {
        return(0);
    }

    if((pVK->wch[ModNum] == WCH_DEAD)) {

        if(!deadChar) {
            //
            // Remember the current dead character, whose value follows
            // the current entry in the modifier mapping table.
            //
            SavedDeadChar = ((PVK_TO_WCHARS1)((PUCHAR)pVK + pVKT->cbSize))->wch[ModNum];
        }
        return(0);
    }

    //
    // The keyboard layout table contains some dead key mappings.
    // If previous key was a dead key, attempt to compose it with the
    // current character by scanning the keyboard layout table for a match.
    //
    if(deadChar) {

        ULONG    chr;
        PDEADKEY DeadKeyEntry;

        chr = MAKELONG(pVK->wch[ModNum],deadChar);

        if(DeadKeyEntry = KeyboardTable->pDeadKey) {

            while(DeadKeyEntry->dwBoth) {

                if(DeadKeyEntry->dwBoth == chr) {
                    //
                    // Got a match.  Return the composed character.
                    //
                    return((ULONG)DeadKeyEntry->wchComposed);
                }

                DeadKeyEntry++;
            }
        }

        //
        // If we get here, then the previous key was a dead char,
        // but the current key could not be composed with it.
        // So return nothing.  Note that the dead key has been forgotten.
        //
        return(0);
    }


    return((ULONG)pVK->wch[ModNum]);
}



VOID
spkbdSetLEDs(
    VOID
    )
{
    asyncKbdParams.UnitId = 0;
    asyncKbdParams.LedFlags = CurrentLEDs;

    ZwDeviceIoControlFile(
        hKeyboard,
        NULL,
        NULL,
        NULL,
        &asyncIoStatusBlock,
        IOCTL_KEYBOARD_SET_INDICATORS,
        &asyncKbdParams,
        sizeof(asyncKbdParams),
        NULL,
        0
    );
}

VOID
SpSelectAndLoadLayoutDll(
  IN PWSTR Directory,
  IN PVOID SifHandle,
  IN BOOLEAN ShowStatus
  )
/*++

Routine Description:

  Allows the user to select a keyboard layout DLL and loads it.
  

Arguments:

  Directory - The setup startup directory
  SifHandle - Handle to txtsetup.sif
  ShowStatus - Whether status should be displayed or not

Return Value:

  None

--*/  
{
  ULONG SelectedLayout;
  ULONG DefLayout = -1;
  PWSTR TempPtr = 0;
  PWSTR LayoutDll = 0;
  NTSTATUS  Status;

  //
  // Get the default layout (index)
  //
  TempPtr = SpGetSectionKeyIndex(SifHandle, SIF_NLS, SIF_DEFAULTLAYOUT, 0);

  if(!TempPtr) {
    SpFatalSifError(SifHandle, SIF_NLS, SIF_DEFAULTLAYOUT, 0, 0);
  }

  DefLayout = SpGetKeyIndex(SifHandle, SIF_KEYBOARDLAYOUTDESC, TempPtr);

  if(DefLayout == -1) {
    SpFatalSifError(SifHandle, SIF_NLS, SIF_DEFAULTLAYOUT, 0, 0);
  }

  SelectedLayout = -1;  

  //
  // Let the user select the layout which he wants
  //    
  if (SpSelectSectionItem(SifHandle, SIF_KEYBOARDLAYOUTDESC, 
                     SP_SELECT_KBDLAYOUT, DefLayout, &SelectedLayout)) {
    //
    // Load the layout if its not already loaded
    //
    if (DefLayout != SelectedLayout) {
      //
      // get the key
      //
      TempPtr = SpGetKeyName(SifHandle, SIF_KEYBOARDLAYOUTDESC, SelectedLayout);

      if (TempPtr) {
        //
        // get the KDB layout dll name
        //
        LayoutDll = SpGetSectionKeyIndex(SifHandle, SIF_KEYBOARDLAYOUTFILES,
                          TempPtr, 0);

        if (LayoutDll) {
          if (ShowStatus) {
            SpDisplayStatusText(SP_STAT_LOADING_KBD_LAYOUT,
                DEFAULT_STATUS_ATTRIBUTE, LayoutDll);
          }                
              
          //
          // Load the new KDB layout dll
          //
          Status = SpLoadKbdLayoutDll(Directory, LayoutDll, &KeyboardTable);
        }          
        else
          Status = STATUS_INVALID_PARAMETER;

        if (!NT_SUCCESS(Status)) {
          CLEAR_ENTIRE_SCREEN();
          SpFatalKbdError(SP_SCRN_KBD_LAYOUT_FAILED, LayoutDll);          
        } else {
          if (ShowStatus) {
            //
            // Erase status text line.
            //
            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, 0);
          }

          //
          // Now that we've loaded the layout, 
          // we can start accepting keyboard input.
          //
          START_KEYBOARD_READ();
          KbdLayoutInitialized = TRUE;          
        }
      } else {
        CLEAR_ENTIRE_SCREEN();
        SpFatalSifError(SifHandle, SIF_KEYBOARDLAYOUTDESC, 0, 0, 0);
      }
    }
  }                                              
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\sphw.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sphw.c

Abstract:

    Hardware detection and confirmation routines for text setup.

Author:

    Ted Miller (tedm) 1-October-1993

Revision History:

--*/

#include "spprecmp.h"
#pragma hdrstop

extern BOOLEAN HandleLineContinueChars;

VOID
SpHardwareConfirmInteract(
    IN PVOID SifHandle
    );

VOID
SpConfirmScsiInteract(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    );

BOOLEAN
SpSelectHwItem(
    IN     PVOID               SifHandle,
    IN     PWSTR               NonlocalizedComponentName,
    IN     PWSTR               OemSectionName,            OPTIONAL
    IN     ULONG               SelectHwScreenId,
    IN     ULONG               SelectOemHwScreenId,
    IN     ULONG               AllowedFileTypes,
    IN     ULONG               RequiredFileTypes,
    IN OUT PHARDWARE_COMPONENT HwComp
    );

VOID
SpScanHardwareDescription(
    IN PWSTR DesiredKeyName
    );

VOID
SpDetectComputer(
    IN PVOID SifHandle
    );

VOID
SpDetectVideo(
    IN PVOID SifHandle
    );

VOID
SpDetectKeyboard(
    IN PVOID SifHandle
    );

VOID
SpDetectMouse(
    IN PVOID SifHandle
    );

VOID
SpDetectLayout(
    IN PVOID SifHandle
    );

VOID
SpDetectScsi(
    IN PVOID SifHandle,
    IN PWSTR SourceDevicePath,
    IN PWSTR DirectoryOnSourceDevice
    );

VOID
SpDetermineComponent(
    IN  PVOID               SifHandle,
    OUT PHARDWARE_COMPONENT HwComp,
    IN  PWSTR               HardwareDescriptionKeyName,
    IN  PWSTR               FallbackIdentifier,
    IN  PWSTR               ComponentName
    );

BOOLEAN
SpOemDiskette(
    IN     PVOID               SifHandle,
    IN     PWSTR               SectionName,
    IN     ULONG               SelectOemHwScreenId,
    IN     ULONG               AllowedFileTypes,
    IN     ULONG               RequiredFileTypes,
    IN OUT PHARDWARE_COMPONENT HwComp,
    IN     ULONG               ErrorId
    );

BOOLEAN
SpOemInfSelection(
    IN  PVOID               TxtsetupOem,
    IN  PWSTR               NonlocalizedComponentName,
    IN  PWSTR               SelectedId,
    IN  PWSTR               ItemDescription,
    IN  ULONG               AllowedFileTypes,
    IN  ULONG               RequiredFileTypes,
    OUT PHARDWARE_COMPONENT HwComp,
    IN  ULONG               ErrorId
    );

VOID
SpFreeLocatedIdStrings(
    VOID
    );

VOID
SpScanHardwareDescriptionWorker(
    IN HANDLE KeyHandle,
    IN PWSTR  KeyName,
    IN PWSTR  DesiredKeyName
    );

BOOLEAN
SpScanMapSection(
    IN  PVOID               SifHandle,
    OUT PHARDWARE_COMPONENT HwComp,
    IN  PWSTR               ComponentName,
    IN  PWSTR               IdString
    );

VOID
SpInitHwComponent(
    OUT PHARDWARE_COMPONENT HwComp,
    IN  PWSTR               IdString,
    IN  PWSTR               Description,
    IN  BOOLEAN             ThirdPartyOption,
    IN  ULONG               FileTypeBits,
    IN  PWSTR               BaseDllName,
    IN  BOOLEAN             MigratedDriver
    );

VOID
SpInitHwComponentFile(
    OUT PHARDWARE_COMPONENT_FILE HwCompFile,
    IN  PWSTR                    Filename,
    IN  HwFileType               FileType,
    IN  PWSTR                    ConfigName,
    IN  PWSTR                    DiskDescription,
    IN  PWSTR                    DiskTagFile,
    IN  PWSTR                    Directory,
    IN  PWSTR                    ArcDeviceName
    );

VOID
SpInitHwComponentRegVal(
    OUT PHARDWARE_COMPONENT_REGISTRY HwCompReg,
    IN  PWSTR                        KeyName,
    IN  PWSTR                        ValueName,
    IN  ULONG                        ValueType,
    IN  PVOID                        Buffer,
    IN  ULONG                        BufferSize
    );

VOID
SpFreeHwComponentFile(
    IN OUT PHARDWARE_COMPONENT_FILE *HwCompFile
    );

VOID
SpFreeHwComponentReg(
    IN OUT PHARDWARE_COMPONENT_REGISTRY *HwCompReg
    );

PHARDWARE_COMPONENT_REGISTRY
SpInterpretOemRegistryData(
    IN PVOID          SifHandle,
    IN PWSTR          SectionName,
    IN ULONG          Line,
    IN ULONG          ValueType,
    IN PWSTR          KeyName,
    IN PWSTR          ValueName
    );

VOID
SpGetDriverValuesForLoad(
    IN  PVOID  SifHandle,
    IN  PWSTR  ComponentSectionName,
    IN  PWSTR  ComponentLoadSectionName,
    IN  PWSTR  Shortname,
    OUT PWSTR *Filename,
    OUT PWSTR *MediaDesignator,
    OUT PWSTR *Description OPTIONAL
    );


//
// These two globals track a table that gets built as the
// hardware description in the registry is scanned for a
// particular hardware component.  See SpScanHardwareDescription().
//
PWSTR *IdStringArray;
ULONG  IdStringCount;

//
// Array of ulongs that are the message ids for screens that
// prompt the user to select a type of a component from the
// list below.
//
ULONG SelectHwScreens[HwComponentMax] = { SP_SCRN_SELECT_COMPUTER,
                                          SP_SCRN_SELECT_DISPLAY,
                                          SP_SCRN_SELECT_KEYBOARD,
                                          SP_SCRN_SELECT_LAYOUT,
                                          SP_SCRN_SELECT_MOUSE
                                        };

//
// Array of ulongs that are the message ids for screens that
// prompt the user to select an option from an oem disk for
// a component from the list below.
//
ULONG SelectOemHwScreens[HwComponentMax] = { SP_SCRN_SELECT_OEM_COMPUTER,
                                             SP_SCRN_SELECT_OEM_DISPLAY,
                                             SP_SCRN_SELECT_OEM_KEYBOARD,
                                             SP_SCRN_SELECT_OEM_LAYOUT,
                                             SP_SCRN_SELECT_OEM_MOUSE
                                           };

ULONG UnknownHwScreens[HwComponentMax] = { SP_SCRN_UNKNOWN_COMPUTER,
                                           SP_SCRN_UNKNOWN_DISPLAY,
                                           SP_SCRN_UNKNOWN_KEYBOARD,
                                           SP_SCRN_UNKNOWN_LAYOUT,
                                           SP_SCRN_UNKNOWN_MOUSE
                                         };

//
// These are the names of the components.  This is array is not localized
// because it is used only to index hardware-related sections in the
// setup information file.
//
PWSTR NonlocalizedComponentNames[HwComponentMax] = { L"Computer",
                                                     L"Display",
                                                     L"Keyboard",
                                                     L"Keyboard Layout",
                                                     L"Mouse"
                                                   };

//
// The following is the name of the SCSI section in txtsetup.sif.
// On amd64/x86 machines, this is one of SCSI.ISA, SCSI.EISA, or SCSI.MCA.
// On other machines, this is just SCSI.
//
PWSTR ScsiSectionName;
PWSTR ScsiLoadSectionName;

PWSTR FileTypeNames[HwFileMax+1] = { L"Driver",
                                     L"Port",
                                     L"Class",
                                     L"Inf",
                                     L"Dll",
                                     L"Detect",
                                     L"Hal",
                                     L"Catalog",
                                     NULL
                                   };

PWSTR RegistryTypeNames[HwRegistryMax+1] = { L"REG_DWORD",
                                             L"REG_BINARY",
                                             L"REG_SZ",
                                             L"REG_EXPAND_SZ",
                                             L"REG_MULTI_SZ",
                                             NULL
                                           };

ULONG RegistryValueTypeMap[HwRegistryMax] = { REG_DWORD,
                                              REG_BINARY,
                                              REG_SZ,
                                              REG_EXPAND_SZ,
                                              REG_MULTI_SZ
                                              };

PHARDWARE_COMPONENT HardwareComponents[HwComponentMax] = { NULL,NULL,NULL,NULL,NULL };

PHARDWARE_COMPONENT ScsiHardware;

PHARDWARE_COMPONENT BootBusExtenders;

PHARDWARE_COMPONENT BusExtenders;

PHARDWARE_COMPONENT InputDevicesSupport;

PHARDWARE_COMPONENT PreinstallHardwareComponents[HwComponentMax] = { NULL,NULL,NULL,NULL,NULL };

PHARDWARE_COMPONENT PreinstallScsiHardware = NULL;

PHARDWARE_COMPONENT UnsupportedScsiHardwareToDisable = NULL;


PWSTR PreinstallSectionNames[HwComponentMax] = { WINNT_U_COMPUTERTYPE_W,
                                                 WINNT_OEMDISPLAYDRIVERS_W,
                                                 WINNT_OEMKEYBOARDDRIVERS_W,
                                                 WINNT_U_KEYBOARDLAYOUT_W,
                                                 WINNT_OEMPOINTERDRIVERS_W
                                               };

#define MAX_SCSI_MINIPORT_COUNT 5
ULONG LoadedScsiMiniportCount;


//
// This array lists the type of files allowed for each component type.
// For example, detect files are allowed for computer and driver files are
// allowed for all component types. Keep in sync with HwComponentType enum!
//

ULONG AllowedFileTypes[HwComponentMax] = {

    // Computer

    FILETYPE(HwFileDriver) | FILETYPE(HwFilePort) | FILETYPE(HwFileClass)
  | FILETYPE(HwFileInf)    | FILETYPE(HwFileDll)  | FILETYPE(HwFileDetect)
  | FILETYPE(HwFileHal)    | FILETYPE(HwFileCatalog),

    // Display

    FILETYPE(HwFileDriver) | FILETYPE(HwFilePort) | FILETYPE(HwFileInf)
  | FILETYPE(HwFileDll)    | FILETYPE(HwFileCatalog),

    // Keyboard

    FILETYPE(HwFileDriver) | FILETYPE(HwFilePort) | FILETYPE(HwFileClass)
  | FILETYPE(HwFileInf)    | FILETYPE(HwFileDll)  | FILETYPE(HwFileCatalog),

    // Layout

    FILETYPE(HwFileDll)    | FILETYPE(HwFileInf),

    // Mouse

    FILETYPE(HwFileDriver) | FILETYPE(HwFilePort) | FILETYPE(HwFileClass)
  | FILETYPE(HwFileInf)    | FILETYPE(HwFileDll)  | FILETYPE(HwFileCatalog)

};

#define SCSI_ALLOWED_FILETYPES (FILETYPE(HwFileDriver) | FILETYPE(HwFilePort) | FILETYPE(HwFileInf) | FILETYPE(HwFileCatalog))

//
// This array lists the type of files required for each component type.
// For example, a hal is required for computer.  Keep in sync with
// HwComponentType enum!
//

ULONG RequiredFileTypes[HwComponentMax] = {

    // Computer

    FILETYPE(HwFileHal),

    // Display

    FILETYPE(HwFileDriver) | FILETYPE(HwFileDll),

    // Keyboard

    FILETYPE(HwFileDriver),

    // Layout

    FILETYPE(HwFileDll),

    // Mouse

    FILETYPE(HwFileDriver)

};

#define SCSI_REQUIRED_FILETYPES FILETYPE(HwFileDriver)



#define MAP_SECTION_NAME_PREFIX     L"Map."
#define HARDWARE_MENU_SIZE          HwComponentMax

#define MICROSOFT_BUS_MOUSE_NAME    L"MICROSOFT BUS MOUSE"


FloppyDriveType
SpGetFloppyDriveType(
    IN ULONG FloppyOrdinal
    )

/*++

Routine Description:

    Inspect a floppy disk drive attempting to classify it as a
    5.25 or 3.5" drive, hi or low density.  For 5.25" disks,
    1.2MB drives are high density; smaller drives are low-density.
    For 3.5" drives, 1.44, 2.88, or 20.8MB is high density, smaller
    drives are low density.

    Any other drive types are unrecognized and result in
    FloppyTypeNone being returned.

Arguments:

    FloppyOrdinal - supplies ordinal number of floppy (0=A:, etc).

Return Value:

    Value from the FloppyDriveType enum indicating which type the drive is.
    FloppyTypeNone if we couldn't determine this information.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    WCHAR OpenPath[64];
    DISK_GEOMETRY DiskGeom[25];
    ULONG_PTR MediaTypeCount;
    static FloppyDriveType CachedTypes[2] = { -1,-1 };
    FloppyDriveType FloppyType;

    //
    // If we have already determined this for this drive,
    // return the cached info.
    //
    if((FloppyOrdinal < ELEMENT_COUNT(CachedTypes))
    && (CachedTypes[FloppyOrdinal] != -1))
    {
        return(CachedTypes[FloppyOrdinal]);
    }

    //
    // Assume the floppy doesn't exist or we can't tell what type it is.
    //
    FloppyType = FloppyT