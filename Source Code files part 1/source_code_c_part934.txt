iEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessMIMEInfo(riEngine, fFalse);
}

/*---------------------------------------------------------------------------
	UnregisterMIMEInfo action - 
---------------------------------------------------------------------------*/
iesEnum UnregisterMIMEInfo(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessMIMEInfo(riEngine, fTrue);
}


/*---------------------------------------------------------------------------
	RegisterExtensionInfo action - 
---------------------------------------------------------------------------*/
iesEnum RegisterExtensionInfo(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessExtensionInfo(riEngine, fFalse);
}

/*---------------------------------------------------------------------------
	UnregisterExtensionInfo action - 
---------------------------------------------------------------------------*/
iesEnum UnregisterExtensionInfo(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessExtensionInfo(riEngine, fTrue);
}

/*---------------------------------------------------------------------------
	CreateShortcuts action - 
---------------------------------------------------------------------------*/
iesEnum CreateShortcuts(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallShortcuts))
		return iesSuccess;

	iesEnum iesRet = ProcessShortcutInfo(riEngine, fFalse); // advertised shortcuts
	if((iesRet != iesSuccess) || (fMode & iefAdvertise))
		return iesRet;
	return ProcessShortcutInfo(riEngine, fFalse, fFalse); // non-advertised shortcuts
}

/*---------------------------------------------------------------------------
	RemoveShortcuts action - 
---------------------------------------------------------------------------*/
iesEnum RemoveShortcuts(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallShortcuts))
		return iesSuccess;
	iesEnum iesRet = ProcessShortcutInfo(riEngine, fTrue); // advertised shortcuts
	if(iesRet != iesSuccess)
		return iesRet;
	return ProcessShortcutInfo(riEngine, fTrue, fFalse); // non-advertised shortcuts
}

/*---------------------------------------------------------------------------
	RegisterTypeLibraries action - 
---------------------------------------------------------------------------*/
iesEnum RegisterTypeLibraries(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessTypeLibraryInfo(riEngine, fFalse);
}

/*---------------------------------------------------------------------------
	UnregisterTypeLibraries action - 
---------------------------------------------------------------------------*/
iesEnum UnregisterTypeLibraries(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessTypeLibraryInfo(riEngine, fTrue);
}

/*---------------------------------------------------------------------------
	AllocateRegistrySpace action - 
---------------------------------------------------------------------------*/
iesEnum AllocateRegistrySpace(IMsiEngine& riEngine)
{
	// validate that the registry has enough free space, if a desired size requested
	int iIncrementKB = 	riEngine.GetPropertyInt(*MsiString(*IPROPNAME_AVAILABLEFREEREG));
	if(iIncrementKB != iMsiNullInteger)
	{
		using namespace IxoRegAllocateSpace;

		PMsiServices piServices(riEngine.GetServices());
		PMsiRecord pSetRegistrySizeRec = &piServices->CreateRecord(Args);

		pSetRegistrySizeRec->SetInteger(Space, iIncrementKB);

		return riEngine.ExecuteRecord(ixoRegAllocateSpace,*pSetRegistrySizeRec);
	}
	return iesSuccess;
}

/*---------------------------------------------------------------------------
	ResolveSource action - 

	Ensure that the properties SOURCEDIR and SourcedirProduct are set
---------------------------------------------------------------------------*/
iesEnum ResolveSource(IMsiEngine& riEngine)
{
	PMsiPath   pPath(0);	
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiRecord pErrRec = ENG::GetSourcedir(*pDirectoryMgr, *&pPath);
	if (pErrRec)
	{
		if (pErrRec->GetInteger(1) == imsgUser)
			return iesUserExit;
		else
			return riEngine.FatalError(*pErrRec);
	}
	return iesSuccess; 
}

/*---------------------------------------------------------------------------
	ACL Generation -- used by several actions, but not an action by itself
---------------------------------------------------------------------------*/
BOOL AllocateAndInitializeUserSid (const ICHAR* szUser, PSID *Sid, DWORD &cbSid)
{
	
	// On foreign systems the "SYSTEM" account isn't under that name.
	// There is a separate API for looking it up.   However,
	// to avoid requiring localization of account names, and to conform
	// to our callers current conventions, we'll get called with "SYSTEM" and make
	// the correct translation.

	ICHAR        szDomain[MAX_PATH+1];
	DWORD        cbDomain = MAX_PATH; 
	SID_NAME_USE snu = SidTypeUnknown;
	cbSid = 0;

	BOOL fStatus = fTrue;

	// Guess at the size of a Sid.
	// If we get it wrong, we end up with two LookupAccountName calls, which is
	// *really* slow

	// On the other hand, if we allocate too big a buffer, the API isn't polite
	// enough to tell us how much we actually used.

	// The well known SIDs allocate their own buffer, so the resizing isn't needed.
	cbSid = 80;
	char SidBuffer[80];
	char* pSidBuffer = SidBuffer;
	Bool fWellKnown = fFalse;

	//   LookupAccountName is *reaaaaaalllly* slow.
	//   We cache what we can.

	MsiString strUser(szUser);

	DWORD dwRet = ERROR_SUCCESS;
	SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;

	if (strUser.Compare(iscExactI, TEXT("SYSTEM")))
	{
		DEBUGMSG("Using well known SID for System");
		fStatus = fWellKnown = fTrue;
		if (!AllocateAndInitializeSid(&sia, 1, SECURITY_LOCAL_SYSTEM_RID,0,0,0,0,0,0,0,(void**)&(pSidBuffer)))
			return fFalse;
	}
	else if (strUser.Compare(iscExactI, TEXT("Administrators")))
	{
		DEBUGMSG("Using well known SID for Administrators");
		fStatus = fWellKnown = fTrue;
		if (!AllocateAndInitializeSid(&sia, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,0,0,0,0,0,0,(void**)&(pSidBuffer)))
			return fFalse;
	}
	else if (strUser.Compare(iscExactI, TEXT("Everyone")))
	{
		DEBUGMSG("Using well known SID for Everyone");
		fStatus = fWellKnown = fTrue;

		SID_IDENTIFIER_AUTHORITY sia = SECURITY_WORLD_SID_AUTHORITY;
		if (!AllocateAndInitializeSid(&sia, 1, SECURITY_WORLD_RID,0,0,0,0,0,0,0,(void**)&(pSidBuffer)))
			return fFalse;
	}
   else 
	{

#ifdef DEBUG
		ICHAR rgchDebug[256];
		wsprintf(rgchDebug,TEXT("Initializing new user SID for %s"), szUser);
		DEBUGMSG(rgchDebug);
#endif
		
		AssertNonZero(StartImpersonating());
		fStatus = WIN::LookupAccountName (NULL, szUser,(void*) SidBuffer, &cbSid, szDomain, &cbDomain, &snu);
		DWORD dwLastError = GetLastError();
		StopImpersonating();

		if (fStatus)
		{
			cbSid = WIN::GetSidLengthRequired(*WIN::GetSidSubAuthorityCount(SidBuffer));
		}
		else
		{
			if (dwLastError != ERROR_INSUFFICIENT_BUFFER)
			{
				WIN::SetLastError(dwLastError);
				return fFalse;
			}
		}
	}
	
	if (fWellKnown)
	{
		if (ERROR_SUCCESS == dwRet)
			cbSid = WIN::GetLengthSid(pSidBuffer);
		else return fFalse;
	}

	*Sid = (PSID) new byte[cbSid];
	Assert(Sid);

	cbDomain = MAX_PATH;

	if (fStatus)
	{
		AssertNonZero(WIN::CopySid(cbSid, *Sid, pSidBuffer));
	}
	else
	{
		AssertNonZero(StartImpersonating());
		fStatus = WIN::LookupAccountName (NULL, szUser, *Sid, &cbSid, szDomain, &cbDomain, &snu);
		StopImpersonating();
	}

	if (fWellKnown)
		FreeSid(pSidBuffer);

	Assert(WIN::IsValidSid(*Sid));
	Assert(WIN::GetLengthSid(*Sid) == cbSid);
	Assert(SidTypeInvalid != snu);

	//!! what to do if the snu maps to invalid or deleted users...
	DEBUGMSG("Finished allocating new user SID");
	return fStatus;
}

#ifndef ENSURE
#define ENSURE_DEFINED_LOCALLY
#define ENSURE(function) {	\
							IMsiRecord* piError;\
							piError = function;	\
							if (piError) \
								return piError; \
						 }
#endif
IMsiRecord* LookupSid(IMsiEngine& riEngine, const IMsiString& riUser, IMsiStream*& rpistrmSid)
{
	MsiString strSidCacheTable(TEXT("SidCache"));

	PSID psidUser;
	DWORD cbSid = 0;

	PMsiServices pServices = riEngine.GetServices();
	Assert(pServices);

	ICHAR szReferencedDomainName[MAX_PATH] = TEXT("");
	DWORD cbReferencedDomainName = MAX_PATH;

	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiTable ptblSidCache(0);
	PMsiRecord pError(0);
	if ((pError = pDatabase->LoadTable(*strSidCacheTable, 1, *&ptblSidCache)))
	{
		ENSURE(pDatabase->CreateTable(*strSidCacheTable,1,*&ptblSidCache));
		AssertNonZero(ptblSidCache->CreateColumn(icdString | icdPrimaryKey,*MsiString(*TEXT("USER"))));
		AssertNonZero(ptblSidCache->CreateColumn(icdObject, *MsiString(*TEXT("SIDBlob"))));

		// We want this table available during the entire script generation process.  Generating the 
		// Sids are *very* expensive.
		AssertNonZero(pDatabase->LockTable(*strSidCacheTable, fTrue));
	}

	PMsiCursor pcurSidCache = ptblSidCache->CreateCursor(fFalse);
	pcurSidCache->Reset();
	pcurSidCache->SetFilter(1);
	AssertNonZero(pcurSidCache->PutString(1, riUser));

	if (pcurSidCache->Next())
	{
		rpistrmSid = (IMsiStream*) pcurSidCache->GetMsiData(2);
		rpistrmSid->Reset();
		Assert(rpistrmSid);
	}
	else
	{
		if (iesSuccess != AllocateAndInitializeUserSid(riUser.GetString(), &psidUser, cbSid))
		{
			return PostError(Imsg(imsgCreateAclFailed), riUser.GetString(), WIN::GetLastError());
		}

		char* pbstrmSid = pServices->AllocateMemoryStream((unsigned int) cbSid, rpistrmSid);
		Assert(pbstrmSid);

		Assert(WIN::IsValidSid(psidUser));
		AssertNonZero(WIN::CopySid(cbSid, pbstrmSid, psidUser));
		AssertZero(memcmp(pbstrmSid, psidUser, cbSid));

		delete[] psidUser;
		Assert(WIN::IsValidSid(pbstrmSid));
		

		AssertNonZero(pcurSidCache->PutString(1, riUser));
		Assert(rpistrmSid);
		AssertNonZero(pcurSidCache->PutMsiData(2, rpistrmSid));
		AssertNonZero(pcurSidCache->Insert());
	}

	return 0;
}

const IMsiString& FormatUser(IMsiEngine& riEngine, const IMsiString& riDomain, const IMsiString& riUser)
{
	riDomain.AddRef();
	MsiString strUser(riDomain);
	if (strUser.TextSize())
		strUser += TEXT("\\");
	strUser += riUser;
	strUser = riEngine.FormatText(*strUser);

	return strUser.Return();
}

bool InitializeAceHeader(ACL* pACL, int iIndex)
{
	// iIndex is a 0 based index for which ACE to set up.

	// AceType and AceSize are filled in by the AddAccess*ACE functions.
	LPVOID pACE = 0;
	if (GetAce(pACL, iIndex, &pACE))
	{
		// get the ace, and make sure the inheritance flags are set correctly.
		_ACE_HEADER* pAceHeader = (struct _ACE_HEADER*) pACE;

		// objects created under this one will get the same set of permissions.
		pAceHeader->AceFlags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;
		return true;
	}
	else 
	{
		return false;
	}
}

IMsiRecord* GenerateSD(IMsiEngine& riEngine, IMsiView& riviewLockList, IMsiRecord* piExecute, IMsiStream*& rpiSD)
{
	// Assumes that the LockList comes in already executed,
	// the Execute record is to allow us to re-execute the view if necessary.

	// First pass updates the SID cache, and calculates the total size of the ACL we're generating.
	// Second pass fetches the SIDs from the cache, and starts filling in an allocated ACL.

	// this is much better than using a function that takes a single ACE, and re-allocates the ACL
	// each time.  (The example in the SDK does this.  *yuck*)

	Assert(!g_fWin9X);

	const int cbDefaultSid = sizeof(SID) + sizeof(DWORD)*SID_MAX_SUB_AUTHORITIES;
	int cbSid = 0;

	PMsiStream pstrmSid(0);
	PMsiRecord precFetch(0);
	PMsiServices pServices = riEngine.GetServices();
	MsiString strUser;


	DWORD cbSids = 0;
	static DWORD cbDefaultSids = 0;
	int cAllowSids = 0;
	int cDenySids = 0;

	if (!cbDefaultSids)
	{
		ENSURE(LookupSid(riEngine, *MsiString(TEXT("SYSTEM")), *&pstrmSid));
		cbDefaultSids += pstrmSid->GetIntegerValue();
	}

	while((precFetch = riviewLockList.Fetch()))
	{
		// we must know how many ACEs to add, and their SIDs, before can initialize an ACL.

		strUser = FormatUser(riEngine, *MsiString(precFetch->GetMsiString(1)), *MsiString(precFetch->GetMsiString(2)));
		ENSURE(LookupSid(riEngine, *strUser, *&pstrmSid));

		if (pstrmSid)
		{
			//REVIEW:  How do we handle not being able to find a particular user's SID?
			if (precFetch->GetInteger(3))
				cAllowSids++;
			else
				cDenySids++;

			cbSids += pstrmSid->GetIntegerValue();
		}
	}	
	
	// initialize ACL with appropriate calculated sizes + sizes for default ACEs (system/interactive, and everyone denied)

	// the SIDs and the ACEs share a structure in common, so the size is calculated
	// by adding the sizes together, then substracting that particular piece.
	// see documentation for InitializeAcl

	if (!cDenySids && !cAllowSids) 
		return 0;

	const DWORD cbACLSize = sizeof (ACL) + cbDefaultSids + cbSids + 
		 (cDenySids	 + 0 /*defaults*/)*(sizeof(ACCESS_DENIED_ACE)  - sizeof(DWORD /*ACCESS_DENIED_ACE.SidStart*/)) +       
		 (cAllowSids + 1 /*defaults*/)*(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD/*ACCESS_ALLOWED_ACE.SidStart*/));

	const int cbDefaultAcl = 512;
	CTempBuffer<char, cbDefaultAcl> pchACL;
	if (cbDefaultAcl < cbACLSize)
		pchACL.SetSize(cbACLSize);

	ACL* pACL = (ACL*) (char*) pchACL;

	if (!WIN::InitializeAcl (pACL, cbACLSize, ACL_REVISION))
		return PostError(Imsg(idbgCreateAclFailed), WIN::GetLastError());

	CTempBuffer<char, cbDefaultSid> pchSid;

	ENSURE(riviewLockList.Close());
	ENSURE(riviewLockList.Execute(piExecute));

	BOOL fAllowSet = fFalse;

	int cACE = 0;
	while((precFetch = riviewLockList.Fetch()))
	{
		
		// build ACL with Access Allowed ACEs...
		strUser = FormatUser(riEngine, *MsiString(precFetch->GetMsiString(1)), *MsiString(precFetch->GetMsiString(2)));
		ENSURE(LookupSid(riEngine, *strUser, *&pstrmSid));
		if (!pstrmSid) 
		{
			continue;
		}
			
		cbSid = pstrmSid->GetIntegerValue();
		if (cbSid > pchSid.GetSize())
			pchSid.SetSize(cbSid);

		pstrmSid->GetData(pchSid, cbSid);

		Assert(WIN::IsValidSid(pchSid));
		// build permission mask

		//Permission mask a bit field for easy
		// passing directly through

		// See also: GENERIC_READ, GENERIC_WRITE, GENERIC_EXECUTE, GENERIC_ALL
		DWORD dwPermissions = precFetch->GetInteger(3);


		if (dwPermissions)
		{
			fAllowSet = fTrue;

			if (!WIN::AddAccessAllowedAce(pACL, ACL_REVISION, dwPermissions, pchSid))
				return PostError(Imsg(idbgCreateAclFailed), WIN::GetLastError());
		}
		else
		{
			// All denies must be handled before allows.
			Assert(fFalse == fAllowSet);
			if (!WIN::AddAccessDeniedAce(pACL, ACL_REVISION, dwPermissions, pchSid))
				return PostError(Imsg(idbgCreateAclFailed), WIN::GetLastError());
		}
		AssertNonZero(InitializeAceHeader(pACL, cACE++));
	}
	
	ENSURE(LookupSid(riEngine, *MsiString(TEXT("SYSTEM")), *&pstrmSid));
	Assert(pstrmSid);

	cbSid = pstrmSid->GetIntegerValue();
	Assert(cbSid <= cbDefaultSid);

	pstrmSid->GetData(pchSid, cbSid);
	Assert(WIN::IsValidSid(pchSid));

	if (!WIN::AddAccessAllowedAce(pACL, ACL_REVISION, GENERIC_ALL, pchSid))
		return PostError(Imsg(idbgCreateAclFailed), WIN::GetLastError());
	AssertNonZero(InitializeAceHeader(pACL, cACE++));

	Assert(WIN::IsValidAcl(pACL));

	SECURITY_DESCRIPTOR sd;
	if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
		return PostError(Imsg(idbgCreateAclFailed), WIN::GetLastError());
	if (!SetSecurityDescriptorDacl(&sd, TRUE, pACL, FALSE))
		return PostError(Imsg(idbgCreateAclFailed), WIN::GetLastError());
  	if (!WIN::IsValidSecurityDescriptor(&sd))
		return PostError(Imsg(idbgCreateAclFailed), WIN::GetLastError());

	CTempBuffer<char, cbDefaultSD> pchSD;
	DWORD cbSD = WIN::GetSecurityDescriptorLength(&sd);
	if (cbSD > cbDefaultSD)
		pchSD.SetSize(cbSD);

	AssertNonZero(WIN::MakeSelfRelativeSD(&sd, pchSD, &cbSD));
		
	char* pchstrmSD = pServices->AllocateMemoryStream(cbSD, rpiSD);
	Assert(pchstrmSD);

	memcpy(pchstrmSD, pchSD, cbSD);

	return 0;
}

#ifdef ENSURE_DEFINED_LOCALLY
#undef ENSURE
#undef ENSURE_DEFINED_LOCALLY
#endif


//
// From shared.cpp
//
extern iesEnum RegisterFonts(IMsiEngine& riEngine);
extern iesEnum UnregisterFonts(IMsiEngine& riEngine);
extern iesEnum WriteRegistryValues(IMsiEngine& riEngine);
extern iesEnum WriteIniValues(IMsiEngine& riEngine);
extern iesEnum RemoveRegistryValues(IMsiEngine& riEngine);
extern iesEnum RemoveIniValues(IMsiEngine& riEngine);
extern iesEnum AppSearch(IMsiEngine& riEngine);
extern iesEnum CCPSearch(IMsiEngine& riEngine);
extern iesEnum RMCCPSearch(IMsiEngine& riEngine);
extern iesEnum SelfRegModules(IMsiEngine& riEngine);
extern iesEnum SelfUnregModules(IMsiEngine& riEngine);
extern iesEnum BindImage(IMsiEngine& riEngine);
extern iesEnum ProcessComponents(IMsiEngine& riEngine);
extern iesEnum StartServices(IMsiEngine& riEngine);
extern iesEnum StopServices(IMsiEngine& riEngine);
extern iesEnum DeleteServices(IMsiEngine& riEngine);
extern iesEnum ServiceInstall(IMsiEngine& riEngine);
extern iesEnum SetODBCFolders(IMsiEngine& riEngine);
extern iesEnum InstallODBC(IMsiEngine& riEngine);
extern iesEnum RemoveODBC(IMsiEngine& riEngine);
extern iesEnum WriteEnvironmentStrings(IMsiEngine& riEngine);
extern iesEnum RemoveEnvironmentStrings(IMsiEngine& riEngine);
extern iesEnum InstallSFPCatalogFile(IMsiEngine& riEngine);

//
// From fileactn.cpp
//
extern iesEnum InstallFiles(IMsiEngine& riEngine);
extern iesEnum RemoveFiles(IMsiEngine& riEngine);
extern iesEnum MoveFiles(IMsiEngine& riEngine);
extern iesEnum DuplicateFiles(IMsiEngine& riEngine);
extern iesEnum RemoveDuplicateFiles(IMsiEngine& riEngine);
extern iesEnum InstallValidate(IMsiEngine& riEngine);
extern iesEnum FileCost(IMsiEngine& riEngine);
extern iesEnum PatchFiles(IMsiEngine& riEngine);
extern iesEnum CreateFolders(IMsiEngine& riEngine);
extern iesEnum RemoveFolders(IMsiEngine& riEngine);
extern iesEnum InstallAdminPackage(IMsiEngine& riEngine);
extern iesEnum IsolateComponents(IMsiEngine& riEngine);

//
// From complus.cpp
//
extern iesEnum RegisterComPlus(IMsiEngine& riEngine);
extern iesEnum UnregisterComPlus(IMsiEngine& riEngine);

// action m_fSafeInRestrictedEngine settings
const bool fUnsafeAction = false; // action not allowed in restricted engine
const bool fSafeAction   = true;  // action allowed in restricted engine

// Action registration object, to put action in modules action table
// {m_szName, m_fSafeInRestrictedEngine, m_pfAction}

// This list must be in sorted order by ASCII value, not alphabetical
const CActionEntry rgcae[] = {
	{IACTIONNAME_ADMIN, fSafeAction, Admin},
	{IACTIONNAME_ADVERTISE, fSafeAction, Advertise},
	{TEXT("AllocateRegistrySpace"), fUnsafeAction, AllocateRegistrySpace},
	{TEXT("AppSearch"), fSafeAction, AppSearch},
	{TEXT("BindImage"), fUnsafeAction, BindImage},
	{TEXT("CCPSearch"), fSafeAction, CCPSearch},
	{TEXT("CollectUserInfo"), fUnsafeAction, CollectUserInfo},
	{TEXT("CostFinalize"), fSafeAction, CostFinalize},
	{TEXT("CostInitialize"), fSafeAction, CostInitialize},
	{TEXT("CreateFolders"), fUnsafeAction, CreateFolders},
	{TEXT("CreateShortcuts"), fUnsafeAction, CreateShortcuts},
	{TEXT("DeleteServices"), fUnsafeAction, DeleteServices},
	{TEXT("DisableRollback"), fUnsafeAction, DisableRollback},
	{TEXT("DuplicateFiles"), fUnsafeAction, DuplicateFiles},
	{TEXT("ExecuteAction"), fUnsafeAction, ExecuteAction},
	{TEXT("FileCost"), fSafeAction, FileCost},
	{TEXT("FindRelatedProducts"), fSafeAction, FindRelatedProducts},
	{TEXT("ForceReboot"), fUnsafeAction, ForceReboot},
	{IACTIONNAME_INSTALL, fSafeAction, Install},
	{TEXT("InstallAdminPackage"), fUnsafeAction, InstallAdminPackage},
	{TEXT("InstallExecute"), fUnsafeAction, InstallExecute},
	{TEXT("InstallExecuteAgain"), fUnsafeAction, InstallExecuteAgain},
	{TEXT("InstallFiles"), fUnsafeAction, InstallFiles},
	{TEXT("InstallFinalize"), fUnsafeAction, InstallFinalize},
	{TEXT("InstallInitialize"), fUnsafeAction, InstallInitialize},
	{TEXT("InstallODBC"), fUnsafeAction, InstallODBC},
	{TEXT("InstallSFPCatalogFile"), fUnsafeAction, InstallSFPCatalogFile},
	{TEXT("InstallServices"), fUnsafeAction, ServiceInstall},
	{TEXT("InstallValidate"), fUnsafeAction, InstallValidate},
	{TEXT("IsolateComponents"), fSafeAction, IsolateComponents},
	{TEXT("LaunchConditions"), fSafeAction, LaunchConditions},
	{TEXT("MigrateFeatureStates"), fSafeAction, MigrateFeatureStates},
	{TEXT("MoveFiles"), fUnsafeAction, MoveFiles},
	{TEXT("MsiPublishAssemblies"), fUnsafeAction, MsiPublishAssemblies},
	{TEXT("MsiUnpublishAssemblies"), fUnsafeAction, MsiUnpublishAssemblies},
	{TEXT("PatchFiles"), fUnsafeAction, PatchFiles},
	{TEXT("ProcessComponents"), fUnsafeAction, ProcessComponents},
	{TEXT("PublishComponents"), fUnsafeAction, PublishComponents},
	{TEXT("PublishFeatures"), fUnsafeAction, PublishFeatures},
	{TEXT("PublishProduct"), fUnsafeAction, PublishProduct},
	{TEXT("RMCCPSearch"), fSafeAction, RMCCPSearch},
	{TEXT("RegisterClassInfo"), fUnsafeAction, RegisterClassInfo},
	{TEXT("RegisterComPlus"), fUnsafeAction, RegisterComPlus},
	{TEXT("RegisterExtensionInfo"), fUnsafeAction, RegisterExtensionInfo},
	{TEXT("RegisterFonts"), fUnsafeAction, RegisterFonts},
	{TEXT("RegisterMIMEInfo"), fUnsafeAction, RegisterMIMEInfo},
	{TEXT("RegisterProduct"), fUnsafeAction, RegisterProduct},
	{TEXT("RegisterProgIdInfo"), fUnsafeAction, RegisterProgIdInfo},
	{TEXT("RegisterTypeLibraries"), fUnsafeAction, RegisterTypeLibraries},
	{TEXT("RegisterUser"), fUnsafeAction, RegisterUser},
	{TEXT("RemoveDuplicateFiles"), fUnsafeAction, RemoveDuplicateFiles},
	{TEXT("RemoveEnvironmentStrings"), fUnsafeAction, RemoveEnvironmentStrings},
	{TEXT("RemoveExistingProducts"), fUnsafeAction, RemoveExistingProducts},
	{TEXT("RemoveFiles"), fUnsafeAction, RemoveFiles},
	{TEXT("RemoveFolders"), fUnsafeAction, RemoveFolders},
	{TEXT("RemoveIniValues"), fUnsafeAction, RemoveIniValues},
	{TEXT("RemoveODBC"), fUnsafeAction, RemoveODBC},
	{TEXT("RemoveRegistryValues"), fUnsafeAction, RemoveRegistryValues},
	{TEXT("RemoveShortcuts"), fUnsafeAction, RemoveShortcuts},
	{TEXT("ResolveSource"), fSafeAction, ResolveSource},
	{IACTIONNAME_SEQUENCE, fSafeAction, Sequence},
	{TEXT("ScheduleReboot"), fUnsafeAction, ScheduleReboot},
	{TEXT("SelfRegModules"), fUnsafeAction, SelfRegModules},
	{TEXT("SelfUnregModules"), fUnsafeAction, SelfUnregModules},
	{TEXT("SetODBCFolders"), fUnsafeAction, SetODBCFolders},
	{TEXT("StartServices"), fUnsafeAction, StartServices},
	{TEXT("StopServices"), fUnsafeAction, StopServices},
	{TEXT("UnpublishComponents"), fUnsafeAction, UnpublishComponents},
	{TEXT("UnpublishFeatures"), fUnsafeAction, UnpublishFeatures},
	{TEXT("UnpublishProduct"), fUnsafeAction, UnpublishProduct}, //!! shouldn't be an action
	{TEXT("UnregisterClassInfo"), fUnsafeAction, UnregisterClassInfo},
	{TEXT("UnregisterComPlus"), fUnsafeAction, UnregisterComPlus},
	{TEXT("UnregisterExtensionInfo"), fUnsafeAction, UnregisterExtensionInfo},
	{TEXT("UnregisterFonts"), fUnsafeAction, UnregisterFonts},
	{TEXT("UnregisterMIMEInfo"), fUnsafeAction, UnregisterMIMEInfo},
	{TEXT("UnregisterProgIdInfo"), fUnsafeAction, UnregisterProgIdInfo},
	{TEXT("UnregisterTypeLibraries"), fUnsafeAction, UnregisterTypeLibraries},
	{TEXT("ValidateProductID"), fSafeAction, ValidateProductID},
	{TEXT("WriteEnvironmentStrings"), fUnsafeAction, WriteEnvironmentStrings},
	{TEXT("WriteIniValues"), fUnsafeAction, WriteIniValues},
	{TEXT("WriteRegistryValues"), fUnsafeAction, WriteRegistryValues},
	{ 0, 0, 0 },
};
	
#define cCae	(sizeof(rgcae)/sizeof(CActionEntry))

const CActionEntry* CActionEntry::Find(const ICHAR* szName)
{
#ifdef DEBUG
	static boolean fCheckedOrder = false;
	int i = cCae - 2;
	int cch;
	
	if (!fCheckedOrder)
	{
		for ( const CActionEntry* pAction = &rgcae[0] ; i > 0 ; pAction = pAction++, i--)
		{		
			cch = (lstrlen(pAction->m_szName) + 1) * sizeof(ICHAR);
			if (memcmp(pAction->m_szName, (pAction+1)->m_szName, cch) >= 0)
			{
				ICHAR rgchMsg[256];

				
				wsprintf(rgchMsg, TEXT("Action strings out of order [%s] [%s]"), pAction->m_szName, (pAction+1)->m_szName);
				FailAssertMsg(rgchMsg);
			}
		}
	fCheckedOrder = true;
	}
#endif //DEBUG
	for ( const CActionEntry* pAction = &rgcae[0] ; pAction->m_szName ; pAction = pAction++)
		if (IStrComp(pAction->m_szName, szName) == 0)
			return pAction;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\database.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       database.cpp
//
//--------------------------------------------------------------------------

/* database.cpp - common database implementation

CMsiDatabase - common database implementation, MSI database functions
CMsiTable - low-level in-memory database table management
CMsiCursor - data access to CMsiTable
____________________________________________________________________________*/

#define ALIGN(x) (x+(-x & 3))
#include "precomp.h"
#include "_databas.h"// CMsiTable, CMsiCursor, CMsiDatabase, CreateString() factory
#include "tables.h" // table and column name definitions

// database option flag definitions, any unknown option makes a database incompatible
const int idbfExpandedStringIndices = 1 << 31;
const int idbfDatabaseOptionsMask   = 0xFF000000L;
const int idbfHashBinCountMask      = 0x000F0000L;
const int idbfHashBinCountShift     = 16;
const int idbfReservedMask          = 0x00F00000L;
const int idbfCodepageMask          = 0x0000FFFFL;
const int idbfKnownDatabaseOptions  = idbfExpandedStringIndices;

const GUID IID_IMsiDatabase   = GUID_IID_IMsiDatabase;
const GUID IID_IMsiView       = GUID_IID_IMsiView;
const GUID IID_IMsiTable      = GUID_IID_IMsiTable;
const GUID IID_IMsiCursor     = GUID_IID_IMsiCursor;
const GUID STGID_MsiDatabase1 = GUID_STGID_MsiDatabase1;
const GUID STGID_MsiDatabase2 = GUID_STGID_MsiDatabase2;
const GUID STGID_MsiPatch1    = GUID_STGID_MsiPatch1;
const GUID STGID_MsiPatch2    = GUID_STGID_MsiPatch2;
const GUID STGID_MsiTransformTemp = GUID_STGID_MsiTransformTemp; //!! remove at 1.0 ship

const int cRowCountDefault = 16; // default number of rows for new table
const int cRowCountGrowMin = 4;  // minimum number of rows to expand table
const int cCatalogInitRowCount = 30; // initial row count for catalog
const int iFileNullInteger   = 0x8000;  // null integer in file stream

const ICHAR szSummaryInfoTableName[]   = TEXT("_SummaryInformation");  // name recognized by Import()
const ICHAR szForceCodepageTableName[] = TEXT("_ForceCodepage");       // name recognized by Import()
const ICHAR szSummaryInfoColumnName1[] = TEXT("PropertyId");
const ICHAR szSummaryInfoColumnName2[] = TEXT("Value");
const ICHAR szSummaryInfoColumnType1[] = TEXT("i2");
const ICHAR szSummaryInfoColumnType2[] = TEXT("l255");
const int rgiMaxDateField[6] = {2099, 12, 31, 23, 59, 59};
const ICHAR rgcgDateDelim[6] = TEXT("// ::"); // yyyy/mm/dd hh:mm:ss

// exposed catalog column names
const ICHAR sz_TablesName[]    = TEXT("Name");
const ICHAR sz_ColumnsTable[]  = TEXT("Table");
const ICHAR sz_ColumnsNumber[] = TEXT("Number");
const ICHAR sz_ColumnsName[]   = TEXT("Name");
const ICHAR sz_ColumnsType[]   = TEXT("Type");
const ICHAR sz_StreamsName[]   = TEXT("Name");
const ICHAR sz_StreamsData[]   = TEXT("Data");


//____________________________________________________________________________
//
// Storage class validation
//____________________________________________________________________________

bool ValidateStorageClass(IStorage& riStorage, ivscEnum ivsc)
{
	if (ivsc == ivscDatabase)
		return ValidateStorageClass(riStorage, ivscDatabase2) ? true : ValidateStorageClass(riStorage, ivscDatabase1);

	if (ivsc == ivscTransform)
		return ValidateStorageClass(riStorage, ivscTransform2) ? true : (ValidateStorageClass(riStorage, ivscTransform1) ? true: ValidateStorageClass(riStorage, ivscTransformTemp)); //!! remove last test at 1.0 ship

	if (ivsc == ivscPatch)
		return ValidateStorageClass(riStorage, ivscPatch2) ? true : ValidateStorageClass(riStorage, ivscPatch1);

	STATSTG statstg;
	HRESULT hres = riStorage.Stat(&statstg, STATFLAG_NONAME);
	if (hres != S_OK || statstg.clsid.Data1 != ivsc)     // iidMsi* is the low-order 32-bits
		return false;
	return  memcmp(&statstg.clsid.Data2, &STGID_MsiDatabase2.Data2, sizeof(GUID)-sizeof(DWORD)) == 0;
}

//____________________________________________________________________________
//
// String cache private definitions
//____________________________________________________________________________

struct MsiCacheLink  // 8 byte array element, should be power of 2 for alignment
{
	const IMsiString*    piString;  // pointer to string object, holds single refcnt
	MsiCacheIndex        iNextLink; // array index of next hash link or free link
}; // MsiCacheRefCnt[] kept separate for alignment, follows this array

const int cHashBitsMinimum =  8; // miminum bit count of hash value
const int cHashBitsMaximum = 12; // maximum bit count of hash value
const int cHashBitsDefault = 10; // default bit count of hash value

const int cCacheInitSize   = 256; // initial number of entries in string cache
const int cCacheLoadReserve=  32; // entries on reload to allow from growth
const int cCacheMaxGrow = 1024;  // limit growth to reasonable value

//____________________________________________________________________________
//
// CMsiTextKeySortCursor definitions - used for ExportTable
//____________________________________________________________________________

const Bool ictTextKeySort = Bool(2);  // internal use cursor type

class CMsiTextKeySortCursor : public CMsiCursor
{
	unsigned long __stdcall Release();
	int           __stdcall Next();
	void          __stdcall Reset();
 public:
	CMsiTextKeySortCursor(CMsiTable& riTable, CMsiDatabase& riDatabase, int cRows, int* rgiIndex);
 private:
	int  m_iIndex;
	int  m_cIndex;
	int* m_rgiIndex;
 private: // eliminate warning: assignment operator could not be generated
	void operator =(const CMsiTextKeySortCursor&){}
};

//____________________________________________________________________________________________________
//
// CMsiValConditionParser enums
//____________________________________________________________________________________________________

enum ivcpEnum
{
	ivcpInvalid = 0, // Invalid expression
	ivcpValid   = 1, // Valid exression
	ivcpNone    = 2, // No expression
	ivcNextEnum
};

enum vtokEnum // token parsed by Lex, operators from low to high precedence
{
	vtokEos,        // End of string
	vtokRightPar,   // right parenthesis
	vtokImp,
	vtokEqv,
	vtokXor,
	vtokOr,
	vtokAnd,
	vtokNot,        // unaray, between logical and comparison ops
	vtokEQ, vtokNE, vtokGT, vtokLT, vtokGE, vtokLE, vtokLeft, vtokMid, vtokRight,
	vtokValue,
	vtokLeftPar,    // left parenthese
	vtokError
};

//____________________________________________________________________________________________________
//
// CMsiValConditionParser class declaration
//		Borrowed from:  engine.cpp
//____________________________________________________________________________________________________

struct CMsiValConditionParser  // Non-recursive Lex state structure
{
	CMsiValConditionParser(const ICHAR* szExpression);
   ~CMsiValConditionParser();
    vtokEnum Lex();
	void     UnLex();                           // cache current token for next Lex call
	ivcpEnum Evaluate(vtokEnum vtokPrecedence); // recursive evaluator
 private:                   // Result of Lex
	vtokEnum     m_vtok;        // current token type
	iscEnum      m_iscMode;     // string compare mode flags
	MsiString    m_istrToken;   // string value of token if vtok==vtokValue
	int          m_iToken;      // integer value if obtainable, else iMsiNullInteger
 private:                   // To Lex
	int          m_iParenthesisLevel;
	const ICHAR* m_pchInput;
	Bool         m_fAhead;
 private:                   //  Eliminate warning
	void operator =(const CMsiValConditionParser&) {}
};
inline CMsiValConditionParser::CMsiValConditionParser(const ICHAR* szExpression)
	: m_pchInput(szExpression), m_iParenthesisLevel(0), m_fAhead(fFalse), m_vtok(vtokError) {}
inline CMsiValConditionParser::~CMsiValConditionParser() {}
inline void CMsiValConditionParser::UnLex() { Assert(m_fAhead == fFalse); m_fAhead = fTrue; }


//________________________________________________________________________________
//
// Separate Validator implementation
//________________________________________________________________________________

// Buffer sizes
const int cchBuffer                    = 512;
const int cchMaxCLSID                  = 40;

// Mask for Lang Ids
const int iMask                        = ~((15 << 10) + 0x7f);

//___________________________________________
//
// Validator functions
//___________________________________________

static Bool CheckIdentifier(const ICHAR* szIdentifier);
static Bool CheckCase(MsiString& rstrData, Bool fUpperCase);
static Bool ParsePath(MsiString& rstrPath, bool fRelative);
static Bool GetProperties(const ICHAR* szRecord, Bool fFormatted, Bool fKeyAllowed, int iCol, int& iForeignKeyMask);
static Bool ParseProperty(const ICHAR* szProperty, Bool fFormatted, Bool fKeyAllowed, int iCol, int& iForeignKeyMask);
static Bool CheckSet(MsiString& rstrSet, MsiString& rstrData, Bool fIntegerData);
static Bool ParseFilename(MsiString& strFile, Bool fWildCard);
static ifvsEnum CheckWildFilename(const ICHAR *szFileName, Bool fLFN, Bool fWildCard);

//____________________________________________________________________________
//
// IMsiDatabase factory
//____________________________________________________________________________

IMsiRecord* CreateDatabase(const ICHAR* szDatabase, idoEnum idoOpenMode, IMsiServices&  riServices,
									IMsiDatabase*& rpiDatabase)
{
	IMsiRecord* piRec = &riServices.CreateRecord(3);
	ISetErrorCode(piRec, Imsg(idbgDbConstructor));
	piRec->SetString(2, szDatabase);
	piRec->SetInteger(3, idoOpenMode);

	if (idoOpenMode == idoListScript)
	{
		CScriptDatabase* piDb;
		piDb = new CScriptDatabase(riServices);
		if (piDb != 0)
		{
			piRec->Release();
			if ((piRec = piDb->OpenDatabase(szDatabase)) != 0)
			{
				piDb->Release(); //if we delete here then services are never released
				piDb = 0;
			}
		}
		rpiDatabase = piDb;
		return piRec;
	}

	CMsiDatabase* piDb = new CMsiDatabase(riServices);
	if (piDb != 0)
	{
		piRec->Release();
		if ((piRec = piDb->OpenDatabase(szDatabase, idoOpenMode)) != 0)
		{
			piDb->Release(); //if we delete here then services are never released
			piDb = 0;
		}
	}
	rpiDatabase = piDb;
	return piRec;
}

IMsiRecord*  CreateDatabase(IMsiStorage& riStorage, Bool fReadOnly,
									 IMsiServices&  riServices,
									 IMsiDatabase*& rpiDatabase)
{
	IMsiRecord* piRec = &riServices.CreateRecord(3);
	ISetErrorCode(piRec, Imsg(idbgDbConstructor));
	//!! other parameters???
	CMsiDatabase* piDb;
	piDb = new CMsiDatabase(riServices);
	if (piDb != 0)
	{
		piRec->Release();
		if ((piRec = piDb->OpenDatabase(riStorage, fReadOnly)) != 0)
		{
			piDb->Release(); //if we delete here then services are never released
			piDb = 0;
		}
	}
	rpiDatabase = piDb;
	return piRec;
}


#ifdef USE_OBJECT_POOL
// Pointer-Pool implementation
const IMsiData**	g_rgpvObject = NULL;
int		g_iNextFree	 = -1;
HGLOBAL g_hGlobal;
int		g_rcRows	 = 0;
int		g_rcTotalRows = 0;

#ifndef _WIN64
bool	g_fUseObjectPool = false;
#endif

extern CRITICAL_SECTION vcsHeap;

const IMsiData* GetObjectDataProc(int iIndex)
{

	if (iIndex != iMsiStringBadInteger && iIndex < (g_rcTotalRows + iMaxStreamId + 1) && iIndex > iMaxStreamId)
	{
		iIndex -= iMaxStreamId + 1;
		if (g_rgpvObject[iIndex] == (IMsiData*)(INT_PTR)(0xdeadf00d))
			AssertNonZero(0);
		return g_rgpvObject[iIndex];
	}
	else
		return (const IMsiData*)(INT_PTR)(iIndex);
}

//
// Adds the object to the pool
// The Caller is expected to have addrefed this object if it is an IUnknown
// We use the Heap's critical section here because we want to avoid deadlock and we know
// that another thread would not be waiting to allocate memory until we returned.
//
int PutObjectDataProc(const IMsiData* pvData)
{

	if (pvData == 0)
		return 0;

	EnterCriticalSection(&vcsHeap);
	unsigned int iIndex = pvData->GetUniqueId();
	Assert(iIndex < g_rcTotalRows || iIndex == 0);

	if (iIndex == 0)
	{
		if (g_iNextFree < 0) 				// no free space
		{
			int rcNewRows = g_rcTotalRows*2;
			if (!g_rcTotalRows)					// allocate memory- first time
			{
				rcNewRows = 20;				//!! to change.
				while(NULL == (g_hGlobal = GlobalAlloc(GMEM_MOVEABLE, sizeof(PVOID)*rcNewRows)))
					HandleOutOfMemory();
				g_rgpvObject = (const IMsiData**)GlobalLock(g_hGlobal);
			}
			else 							// out of space- realloc more.
			{
				GlobalUnlock(g_hGlobal);
				HGLOBAL hGlobalT;
				while(NULL == (hGlobalT = (PVOID *)GlobalReAlloc(g_hGlobal, sizeof(PVOID)*rcNewRows, GMEM_MOVEABLE)))
					HandleOutOfMemory();
				g_hGlobal = hGlobalT;
				g_rgpvObject = (const IMsiData**)GlobalLock(g_hGlobal);
			}
			
			// set new cells to point to next free cell
			for (int i = g_rcTotalRows; i < rcNewRows-1; i++)
				g_rgpvObject[i] = (IMsiData*)(INT_PTR)(i + 1);

			g_rgpvObject[rcNewRows-1] = (IMsiData*)(-1);	// last free cell has -1
			g_iNextFree = g_rcTotalRows;				// newly added cells (from rg[g_rcTotalRows] to rg[rcNewRows-1]) are free
			g_rcTotalRows = rcNewRows;
		}

		g_rcRows++;
		iIndex = g_iNextFree;			// store data in next available cell
		g_iNextFree = PtrToInt(g_rgpvObject[iIndex]);

		g_rgpvObject[iIndex] = pvData;
		iIndex++;
		((IMsiData*)pvData)->SetUniqueId(iIndex);
		Assert(pvData->GetUniqueId() == iIndex);
	}
	LeaveCriticalSection(&vcsHeap);
	
	// Returned value must be > iMaxStreamId
	return iIndex + iMaxStreamId;
}

//
// Removes the data from the Object pool
// Called when an object is deleted
// iIndex is the index into the object pool + 1 (the value stored in the object itself, not in the Tables
//
void RemoveObjectData(int iIndex)
{

	if (iIndex == 0)
		return;

	iIndex--;

#ifndef _WIN64
	if (!g_fUseObjectPool)
		return;
#endif // !_WIN64
		
	EnterCriticalSection(&vcsHeap);
	g_rcRows--;
	g_rgpvObject[iIndex] = (IMsiData*)(INT_PTR)g_iNextFree;
	g_iNextFree = iIndex;
	LeaveCriticalSection(&vcsHeap);
}

void CMsiDatabase::RemoveObjectData(int iIndex)
{
	::RemoveObjectData(iIndex);
}

// End Pointer-Pool Implementation
#endif // ifdef USE_OBJECT_POOL

//
// Assumes the object is IUnknown* and does a release on it before removing it
//
inline void ReleaseObjectData(int iIndex)
{
	const IMsiData* piUnk = GetObjectData(iIndex);
	if ((INT_PTR)piUnk > iMaxStreamId)
	{
		piUnk->Release();
	}
}

inline int AddRefObjectData(int iIndex)
{
	const IMsiData* piUnk = GetObjectData(iIndex);
	if ((INT_PTR)piUnk > iMaxStreamId)
	{
		return piUnk->AddRef();
	}
	return 0;
}


//____________________________________________________________________________
//
//  CScriptDatabase virtual function implementation
//____________________________________________________________________________


CScriptDatabase::CScriptDatabase(IMsiServices& riServices): m_riServices(riServices)
{
	m_piName = &::CreateString();
	m_riServices.AddRef();
}



IMsiServices& CScriptDatabase::GetServices()
{
	m_riServices.AddRef();
	return m_riServices;
}


IMsiRecord* __stdcall CScriptDatabase::OpenView(const ICHAR* /*szQuery*/, ivcEnum /*ivcIntent*/, IMsiView*& rpiView)
{

	m_piView = new CScriptView(*this, m_riServices);
	Assert(m_piView != 0);
	if ( ! m_piView )
		return PostError(Imsg(idbgDbDataMemory), *m_piName);
	IMsiRecord* piRec = m_piView->Initialise(m_piName->GetString());
	if (piRec != 0)
	{
		m_piView->Release();
		rpiView = 0;
		return piRec;
	}

	rpiView=m_piView;
	return 0;
}


const IMsiString& __stdcall CScriptDatabase::DecodeString(MsiStringId /*iString*/)
{

	return ::CreateString();
	
//	const IMsiString* piString;
//	if (iString == 0
//	 || iString >= m_cCacheUsed
//	 || (piString = m_rgCache[iString].piString) == 0)
//		return g_MsiStringNull;
//	piString->AddRef();
//	return *piString;
}

const IMsiString& __stdcall CScriptDatabase::CreateTempTableName()
{
	static ICHAR rgchTempName[] = TEXT("#TEMP0000");  // leading '#' designates SQLServer local temp table
	ICHAR* pchName = rgchTempName + sizeof(rgchTempName)/sizeof(ICHAR) - 2; // last char
	ICHAR ch;
	while ((ch = *pchName) >= '9')
	{
		*pchName = '0';  // overflow digit to next
		if (ch == '9')   // if was a digit
			pchName--;
	}
	(*pchName)++;
	const IMsiString* piName = &::CreateString();
	piName->SetString(rgchTempName, piName);
	return *piName;
}


IMsiRecord* CScriptDatabase::OpenDatabase(const ICHAR* szDataSource)
{
	m_piName->SetString(szDataSource, m_piName);
	return 0;
}


CScriptDatabase::~CScriptDatabase()
{
}


unsigned long __stdcall CScriptDatabase::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}

unsigned long __stdcall CScriptDatabase::Release()
{
	ReleaseTrack();
	if (m_Ref.m_iRefCnt == 1)  // no external refs to database object remain
	{
		m_piName->Release();
		IMsiServices& riServices = m_riServices;  // save pointer before destruction
		delete this;  // remove ourselves before releasing Services
		riServices.Release();
		return 0;
	}
	return --m_Ref.m_iRefCnt;
}

#ifdef USE_OBJECT_POOL
void CScriptDatabase::RemoveObjectData(int iIndex)
{
	::RemoveObjectData(iIndex);
}
#endif //USE_OBJECT_POOL

//____________________________________________________________________________
//
// CStreamTable definitions - subclassed table to manage raw streams
//____________________________________________________________________________

class CStreamTable : public CMsiTable
{
 public:
	unsigned long __stdcall Release();
   bool WriteData();
 public:  // constructor
	static CStreamTable* Create(CMsiDatabase& riDatabase);
	CStreamTable(CMsiDatabase& riDatabase, IMsiStorage& riStorage);
 protected:
	bool m_fErrorOnRelease;
};

//____________________________________________________________________________
//
// CStorageTable definitions - subclassed table to manage raw substorages
//____________________________________________________________________________

class CStorageTable : public CStreamTable
{
 public:
	unsigned long __stdcall Release();
   bool WriteData();
 public:  // constructor
	static CStorageTable* Create(CMsiDatabase& riDatabase);
	CStorageTable(CMsiDatabase& riDatabase, IMsiStorage& riStorage);
};

inline CStorageTable::CStorageTable(CMsiDatabase& riDatabase, IMsiStorage& riStorage)
	: CStreamTable(riDatabase, riStorage) { m_fStorages = fTrue; }

//____________________________________________________________________________
//
// CStreamTable methods
//____________________________________________________________________________

CStreamTable* CStreamTable::Create(CMsiDatabase& riDatabase)
{
	IMsiStorage* piStorage = riDatabase.GetCurrentStorage();
	if (!piStorage)
		return 0;
	CStreamTable* piTable = new CStreamTable(riDatabase, *piStorage);
	PEnumMsiString pEnum(piStorage->GetStreamEnumerator());
	PMsiCursor pCursor(piTable->CreateCursor(fFalse));
	const IMsiString* pistrName;
	unsigned long cFetched;
	while (pEnum->Next(1, &pistrName, &cFetched) == S_OK)
	{
		pCursor->PutString(1, *pistrName);
		pistrName->Release();
		if (!pCursor->PutInteger(2, iPersistentStream)
		 || !pCursor->Insert())
		{
			piTable->Release();
			return 0;
		}
	}
	piTable->m_fDirty = 0;
	return piTable;
}

CStreamTable::CStreamTable(CMsiDatabase& riDatabase, IMsiStorage& riStorage)
	: CMsiTable(riDatabase, 0, 64/*rows*/, iNonCatalog), m_fErrorOnRelease(fFalse)
{
	m_pinrStorage = &riStorage;  // non-ref counted, refcnt held by database
	CreateColumn(icdString + icdPrimaryKey + icdTemporary + 62, *MsiString(sz_StreamsName));
	CreateColumn(icdObject + icdNullable   + icdTemporary, *MsiString(sz_StreamsData));
	m_rgiColumnDef[1] |= icdPersistent;  // allow CMsiCursor to check for stream column
	m_rgiColumnDef[2] |= icdPersistent;  // restrict objects to stream type
	riDatabase.AddTableCount();
}

bool CStreamTable::WriteData()
{
	bool fStat = true;
	if (m_idsUpdate != idsWrite || !(m_fDirty & iColumnBit(2)))
		return true;
	PMsiRecord pError(0);
	MsiTableData* pData = m_rgiData;
	int cRows = m_cRows;
	for (; cRows--; pData += m_cWidth)
	{
		bool fOk = true;
		const IMsiString& ristrName = m_riDatabase.DecodeStringNoRef(pData[1]);
		int iInStream = pData[2];
		if (iInStream == 0)
		{
			if ((pError = m_pinrStorage->RemoveElement(ristrName.GetString(), fFalse)) != 0)
				fOk = fFalse;
		}
		else if (iInStream != iPersistentStream)
		{
			IMsiStream *piInStream = (IMsiStream *)GetObjectData(iInStream);
			piInStream->Reset(); //!! should clone stream here to save/restore current loc in stream
			IMsiStream* piOutStream;
			if ((pError = m_pinrStorage->OpenStream(ristrName.GetString(), fTrue, piOutStream)) != 0)
				fOk = fFalse;
			else
			{
				char rgbBuffer[512];
				int cbInput = piInStream->GetIntegerValue();
				while (cbInput > 0)
				{
					int cb = sizeof(rgbBuffer);
					if (cb > cbInput)
						cb = cbInput;
					piInStream->GetData(rgbBuffer, cb);
					piOutStream->PutData(rgbBuffer, cb);
					cbInput -= cb;
				}
				if (piInStream->Error() || piOutStream->Error())
					fOk = fFalse; // continue to process remaining data
				piOutStream->Release();
			}
			if (fOk)
				piInStream->Release();  // ref count from table
		}
		if (fOk)
			pData[2] = iPersistentStream;
		else
			fStat = false;
	}
	if (fStat)
		m_fDirty = 0;
	if (m_fErrorOnRelease)  // ref count transferred to database
		Release();
	return fStat;
}

unsigned long CStreamTable::Release()
{
	if (m_Ref.m_iRefCnt == 1)
	{
		if (!m_fErrorOnRelease && !WriteData())
		{
			m_fErrorOnRelease = true;  // try again on commit
			return m_Ref.m_iRefCnt;   // database now owns this refcnt
		}
		m_riDatabase.StreamTableReleased();
	}
	m_fErrorOnRelease = false;  // in case Commit called while other refs remain
	return CMsiTable::Release();
}

//____________________________________________________________________________
//
// CStorageTable methods
//____________________________________________________________________________

CStorageTable* CStorageTable::Create(CMsiDatabase& riDatabase)
{
	IMsiStorage* piStorage = riDatabase.GetCurrentStorage();
	if (!piStorage)
		return 0;
	CStorageTable* piTable = new CStorageTable(riDatabase, *piStorage);
	PEnumMsiString pEnum(piStorage->GetStorageEnumerator());
	PMsiCursor pCursor(piTable->CreateCursor(fFalse));
	const IMsiString* pistrName;
	unsigned long cFetched;
	while (pEnum->Next(1, &pistrName, &cFetched) == S_OK)
	{
		pCursor->PutString(1, *pistrName);
		pistrName->Release();
		if (!pCursor->PutInteger(2, iPersistentStream)
		 || !pCursor->Insert())
		{
			piTable->Release();
			return 0;
		}
	}
	piTable->m_fDirty = 0;
	return piTable;
}

bool CStorageTable::WriteData()
{
	bool fStat = true;
	if (m_idsUpdate != idsWrite || !(m_fDirty & iColumnBit(2)))
		return true;
	PMsiRecord pError(0);
	MsiTableData* pData = m_rgiData;
	int cRows = m_cRows;
	for (; cRows--; pData += m_cWidth)
	{
		bool fOk = true;
		const IMsiString& ristrName = m_riDatabase.DecodeStringNoRef(pData[1]);
		int iInStream = pData[2];
		if (iInStream == 0)
		{
			if ((pError = m_pinrStorage->RemoveElement(ristrName.GetString(), fTrue)) != 0)
				fOk = fFalse;
		}
		else if (iInStream != iPersistentStream)
		{
			IMsiStream* piInStream = (IMsiStream*)GetObjectData(iInStream);
			piInStream->Reset(); //!! should clone stream here to save/restore current loc in stream
			PMsiStorage pOutStorage(0);
			PMsiStorage pInStorage(0);
			pError = SRV::CreateMsiStorage(*piInStream, *&pInStorage);
			if (pError
			|| (pError = m_pinrStorage->OpenStorage(ristrName.GetString(), ismCreate, *&pOutStorage)) != 0
			|| (pError = pInStorage->CopyTo(*pOutStorage, 0)) != 0)
				fOk = fFalse;
			else
				piInStream->Release();  // ref count from table
		}
		if (fOk)
			pData[2] = iPersistentStream;
		else
			fStat = false;
	}
	if (fStat)
		m_fDirty = 0;
	if (m_fErrorOnRelease)  // ref count transferred to database
		Release();
	return fStat;
}

unsigned long CStorageTable::Release()
{
	if (m_Ref.m_iRefCnt == 1)
	{
		if (!m_fErrorOnRelease && !WriteData())
		{
			m_fErrorOnRelease = true;  // try again on commit
			return m_Ref.m_iRefCnt;   // database now owns this refcnt
		}
		m_riDatabase.StorageTableReleased();
	}
	m_fErrorOnRelease = false;  // in case Commit called while other refs remain
	return CMsiTable::Release();
}

//____________________________________________________________________________
//
//  CMsiDatabase virtual function implementation
//____________________________________________________________________________

HRESULT CMsiDatabase::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown) || MsGuidEqual(riid, IID_IMsiDatabase))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CMsiDatabase::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}
unsigned long CMsiDatabase::Release()
{
	ReleaseTrack();
	if (m_Ref.m_iRefCnt == 1) // no external refs to database object remain
	{  // if tables are still loaded, remove all locks
		IMsiCursor* piCursor;
		if (m_iTableCnt != 0
		 && (piCursor = m_piCatalogTables->CreateCursor(fFalse)) != 0)
		{
			while (piCursor->Next()) // need separate cursor, table may be updated
			{	
				IMsiTable* piTable = (IMsiTable*)GetObjectData(piCursor->GetInteger(ctcTable));
				if (piTable)  // table still loaded
				{
					int iState = piCursor->GetInteger(~iTreeLinkMask);  // get raw row attribute bits
					if (iState & iRowTableSaveErrorBit)  // failed to persist on table release, refcnt held by database
					{
						int iName = piCursor->GetInteger(ctcName);
						m_piCatalogTables->SetTableState(iName, ictsNoSaveError);  // remove flag, fatal if fails this time
						piTable->Release();  // remove refcount set when itsSaveError state set, refcnt still held by pTable
					}

					while (m_piCatalogTables->SetTableState(piCursor->GetInteger(ctcName), ictsUnlockTable))
						;
				}
			}
			piCursor->Release();
		}

		if (m_piTransformCatalog)			// must be released before catalogs
		{
			m_piTransformCatalog->Release();
			m_piTransformCatalog=0;
		}

		if (m_iTableCnt == 0)
		{
			IMsiServices& riServices = m_riServices;  // save pointer before destruction
			delete this;  // remove ourselves before releasing Services
			riServices.Release();
			return 0;
		}
	}
	return --m_Ref.m_iRefCnt;
}

IMsiServices& CMsiDatabase::GetServices()
{
	m_riServices.AddRef();
	return m_riServices;
}

IMsiRecord* CMsiDatabase::OpenView(const ICHAR* szQuery, ivcEnum ivcIntent,
												IMsiView*& rpiView)
{
	return CreateMsiView(*this, m_riServices, szQuery, ivcIntent, rpiView);
}

IMsiRecord* CMsiDatabase::GetPrimaryKeys(const ICHAR* szTable)
{
	Block();
	IMsiRecord* pirecKeys;
	MsiString istrTableName(szTable);
	CMsiTable* piTable;
	int iState = m_piCatalogTables->GetLoadedTable(EncodeString(*istrTableName), piTable);
	if (iState == -1)
	{
		Unblock();
		return 0;
	}
	int cPrimaryKeys = 0;
	int iColumn = 1;
	if (piTable)
	{
		cPrimaryKeys = piTable->GetPrimaryKeyCount();
		pirecKeys = &SRV::CreateRecord(cPrimaryKeys);
		for (; iColumn <= cPrimaryKeys; iColumn++)
			pirecKeys->SetMsiString(iColumn, DecodeStringNoRef(piTable->GetColumnName(iColumn)));
		pirecKeys->SetMsiString(0, *istrTableName);
		Unblock();
		return pirecKeys;
	}
	// else must query column catalog table
	MsiStringId iTableName = EncodeString(*istrTableName);
	m_piColumnCursor->Reset();  //!! necessary?
	m_piColumnCursor->SetFilter(iColumnBit(cccTable));
	m_piColumnCursor->PutInteger(cccTable, iTableName);
	while (m_piColumnCursor->Next() && (m_piColumnCursor->GetInteger(cccType) & icdPrimaryKey))
		cPrimaryKeys++;
	pirecKeys = &SRV::CreateRecord(cPrimaryKeys);
	m_piColumnCursor->Reset();
	m_piColumnCursor->PutInteger(cccTable, iTableName);
	for (; iColumn <= cPrimaryKeys; iColumn++)
	{
		m_piColumnCursor->Next();
		pirecKeys->SetMsiString(iColumn, DecodeStringNoRef(m_piColumnCursor->GetInteger(cccName)));
	}
	m_piColumnCursor->Reset();  //!! necessary?
	pirecKeys->SetMsiString(0, *istrTableName);
	Unblock();
	return pirecKeys;
}

IMsiRecord* CMsiDatabase::ImportTable(IMsiPath& riPath, const ICHAR* szFile)
{
//!! critical section?
	IMsiRecord* piError = 0;

	// may change path so create a new path object
	PMsiPath pPath(0);
	piError = riPath.ClonePath(*&pPath);
	if(piError)
		return piError;

	Bool fSummaryInfo = fFalse;
	MsiString istrField;  // must have lifetime longer than last PostError
	const ICHAR* szError = szFile;  // text field for error message
	IMsiStorage* piStorage = GetOutputStorage();  // this pointer not ref counted
	if (!piStorage || m_idsUpdate != idsWrite)
		return PostError(Imsg(idbgDbNotWritable));

	int iFileCodePage = m_iCodePage;
	for(;;)  // retry loop in case codepage changed by import file
	{
	// read row of column names into array of strings
	int iRow = 1;  // for error reporting
	CFileRead File(iFileCodePage);
	if (!File.Open(*pPath, szFile))
		return PostError(Imsg(idbgDbImportFileOpen), szFile);
	MsiColumnDef rgColumnDef[32];
	MsiString rgistrName[32];
	const IMsiString* piData;
	ICHAR ch;
	IErrorCode iErr = 0;
	int iCol = 0;
	Bool fEmptyData = fFalse;
	do
	{
		if (iCol == 32)
			return PostError(Imsg(idbgDbImportFileRead), szFile, iRow);

		ch = File.ReadString(piData);
		if (!piData->TextSize())
			fEmptyData = fTrue;
		rgistrName[iCol] = *piData; // transfers refcnt
		iCol++;
	} while (ch != '\n');
	int nCol = iCol;

	// read row of column specifications, convert to MsiColumnDef format
	iRow++;
	iCol = 0;
	do
	{
		ch = File.ReadString(piData); // datatype
		if (!piData->TextSize())
		{
			fEmptyData = fTrue;
			continue;
		}
		int chType = piData->GetString()[0];
		piData->Remove(iseFirst, 1, piData);
		unsigned int iLength = piData->GetIntegerValue();
		piData->Release();
		if (iLength == iMsiStringBadInteger)
			return PostError(Imsg(idbgDbImportFileRead), szFile, iRow);
		int fNullable = 0;
		int icdType = 0;
		switch(chType | 0x20) // force lower case
		{
		case 'b':
			if (iLength == 0)
				icdType = icdShort;  // backwards compatibility
			else
				icdType = icdObject;
			break;
		case 'd':
			if (iLength == 6)  // date only
				icdType = icdShort;
			else if (iLength != 16) // date and time
				iErr = Imsg(idbgDbImportFileRead);
			break;
		case 'k':  // allow counter column for now, treat as integer
		case 'i':
			if (iLength <= 2)  // boolean, byte, or short
				icdType = icdShort;
			else if (iLength != 4) // long integer
				iErr = Imsg(idbgDbImportFileRead);
			break;
		case 'l':
			icdType = icdString + icdLocalizable;
			break;
		case 'c':
		case 's':
			icdType = icdString;
			break;
		case 'v':
			icdType = icdObject;
			break;
		default:
			iErr = Imsg(idbgDbImportFileRead);
		};
		if (iErr)
			return PostError(iErr, szFile, iRow);
		if (icdType == icdObject)  // stream column, create subdirectory
		{
			MsiString istrFolder(szFile);
			istrFolder.Remove(iseFrom, '.');   // remove extension
			PMsiRecord precError = pPath->AppendPiece(*istrFolder);
			Assert(precError == 0);
		}
		icdType |= iLength;
		icdType |= icdPersistent;
		if (chType <= 'Z')
			icdType |= icdNullable;
		rgColumnDef[iCol] = MsiColumnDef(icdType);
	} while (iCol++, ch != '\n');
	if (iCol != nCol)
		return PostError(Imsg(idbgDbImportFileRead), szFile, iRow);

	// read row containing codepage, table name, and primary key columns
	iRow++;
	MsiString istrTable;
	ch = File.ReadString(*&istrTable);  // table name, primary keys
	int iCodePage = istrTable;  // check if codepage specifier
	if (iCodePage != iMsiStringBadInteger)
	{
		if (iCodePage != 0 && iCodePage != CP_UTF8 && iCodePage != CP_UTF7 && !WIN::IsValidCodePage(iCodePage))
			return PostError(Imsg(idbgDbCodepageNotSupported), iCodePage);
		ch = File.ReadString(*&istrTable);  // next should be table name
		if (istrTable.Compare(iscExact, szForceCodepageTableName))
		{
			m_iCodePage = iCodePage & idbfCodepageMask; // unconditional code page override
			if (iCodePage & idbfHashBinCountMask)  // explicit hash bin count set, only affect persisted database
				m_iDatabaseOptions = (m_iDatabaseOptions & ~idbfHashBinCountMask) | (iCodePage & idbfHashBinCountMask);
			return 0;                  // ignore any data
		}
		if (m_iCodePage && iCodePage != m_iCodePage)
			return PostError(Imsg(idbgDbCodepageConflict), szFile, iRow);
		if (iCodePage != iFileCodePage)  // oops, possibly reading file with wrong codepage
		{
			iFileCodePage = iCodePage;   // reopen file using codepage stamped into file
			continue;
		}
	}
	if (fEmptyData || !ch || !istrTable.TextSize())
		return PostError(Imsg(idbgDbImportFileRead), szFile, iRow);
	int cKeys = 0;
	while (ch == '\t')  // read in primary keys, must be in column order or else
	{
		ch = File.ReadString(piData);
		int iMatch = 0;
		if (cKeys < nCol)
			iMatch = rgistrName[cKeys].Compare(iscExact, piData->GetString());
		piData->Release();
		if (!iMatch)
			return PostError(Imsg(idbgDbImportFileRead), szFile, iRow);
		rgColumnDef[cKeys++] |= icdPrimaryKey;
	}
	if (!cKeys)  //!! if no primary key, error, used to assume 1st column only
		return PostError(Imsg(idbgDbImportFileRead), szFile, iRow);

	// check for pseudo-table representing SummaryInformation stream
	CComPointer<CMsiTable> pTable(0);
	if (istrTable.Compare(iscExact, szSummaryInfoTableName))  // summary stream stored as table
	{
		if ((rgColumnDef[0] & icdObject)                  // Column 1 is PID, must be integer
		 || ((rgColumnDef[1] & icdString) != icdString))    // Column 2 is data, must be string
			return PostError(Imsg(idbgDbImportFileRead), szFile, iRow);
		fSummaryInfo = fTrue;
		if ((pTable = new CMsiTable(*this, 0, 0, iNonCatalog))==0) // temporary, not a catalog table
			return PostError(Imsg(idbgDbTableCreate), szSummaryInfoTableName);
	}
	else
	{
		// drop any existing table by that name
		piError = DropTable(istrTable);
		if (piError)
		{
			int iError = piError->GetInteger(1);
			if (iError == idbgDbTableUndefined)
				piError->Release(); // OK if table doesn't exist
			else if (iError == idbgStgRemoveStream) // OK no stream data for table
				piError->Release();
			else
				return piError;
		}
		piError = CreateTable(*istrTable, 0 /*initRows*/, (IMsiTable*&)*&pTable);
		if (piError)
			return piError;
	}
	// create new table according to column specifications
	for (iCol = 0; iCol < nCol; iCol++)
	{
		int iColumnDef = rgColumnDef[iCol];
		if (fSummaryInfo)
			iColumnDef &= ~icdPersistent;
		int iNewCol = pTable->CreateColumn(iColumnDef, *rgistrName[iCol]);
		Assert(iNewCol == iCol + 1);
	}

	// read data rows into cursor and insert rows into table
	PMsiCursor pCursor(pTable->CreateCursor(fFalse));
	for (;;)  // loop to read in rows
	{
		iRow++;
		for (iCol = 1; iCol <= nCol; iCol++)  // loop to read in fields
		{
			MsiColumnDef iColDef = rgColumnDef[iCol-1];
			ch = File.ReadString(*&istrField);
			if (ch == 0) //!! john, please confirm - chetanp
//			if (ch == 0 && iCol != nCol) //!! for now allow last line to be missing CR/LF
			{
				if (iCol != 1)
					iErr = Imsg(idbgDbImportFileRead); // file truncated
				break;
			}
			if (ch == '\n' && iCol != nCol)
			{
					iErr = Imsg(idbgDbImportFileRead); // record truncated
					break;
			}
			if (!istrField.TextSize())  // if null data
			{
				if (!(iColDef & icdNullable))
					iErr = Imsg(idbgDbImportFileRead); // nulls not accepted
			}
			else if (!(iColDef & icdObject)) // integer
			{
				int i = istrField;
				if (i == iMsiStringBadInteger || !pCursor->PutInteger(iCol, i))
					iErr = Imsg(idbgDbImportFileRead); // invalid integer
			}
			else if (iColDef & icdShort)  // string
			{
				//!! should also handle long text data here
				pCursor->PutString(iCol, *istrField);
				//!! if (non-ASCII data && iCodePage not set) iCodePage = WIN::GetACP();
			}
			else // binary stream
			{
				szError = istrField; // set name in error message
				CFileRead LongDataFile;
				if (!LongDataFile.Open(*pPath, istrField))
				{
					iErr = Imsg(idbgDbImportFileRead); // couldn't open stream file
					break;
				}
				unsigned int cbBuf = LongDataFile.GetSize();
				IMsiStream* piStream;
				char* pbBuf = SRV::AllocateMemoryStream(cbBuf, piStream);
				if (!pbBuf)
				{
					iErr = Imsg(idbgDbDataMemory);
					break;
				}
				if (LongDataFile.ReadBinary(pbBuf, cbBuf) == cbBuf)
					pCursor->PutMsiData(iCol, piStream);
				else
					iErr = Imsg(idbgDbImportFileRead); // couldn't read all bytes from file
				piStream->Release();
				szError = szFile; // restore
			}
		}
		if (iErr != 0 || iCol == 1)  // error or end of file
			break;
		if (!pCursor->Insert())
			return PostError(Imsg(idbgDbImportFileRead), szFile, iRow); // key violation
		pCursor->Reset();  // clear fields to null for next row
	}
	if (iErr)
	{
		DropTable(istrTable);
		return PostError(iErr, szError, iRow);
	}
	Bool fSuccess = fTrue;
	if (fSummaryInfo)
		fSuccess = pTable->SaveToSummaryInfo(*piStorage);
	else
		fSuccess = pTable->SaveToStorage(*istrTable, *piStorage);
	if (iCodePage != iMsiStringBadInteger)
		m_iCodePage = iCodePage;
	if (!fSuccess)
		return PostError(Imsg(idbgDbSaveTableFailure), *istrTable); // save to storage failed
	break;
	} // end of codepage retry loop, always breaks unless continue from within
	return 0;
}

const int rgcbDate[6] = { 7, 4, 5, 5, 6, 5 };  // bits for each date field
const char rgchDelim[6] = "// ::";
void DateTimeToString(int iDateTime, ICHAR* rgchBuffer) // must be at least 20 characters long
{
	int iValue;
	int rgiDate[6];
	for (iValue = 5; iValue >= 0; iValue--)
	{
		rgiDate[iValue] = iDateTime & (( 1 << rgcbDate[iValue]) - 1);
		iDateTime >>= rgcbDate[iValue];
	}
	rgiDate[0] += 1980;
	rgiDate[5] *= 2;
	ICHAR* pBuffer = rgchBuffer;
	if (rgiDate[0] != 0 || rgiDate[1] != 0)
		pBuffer += wsprintf(pBuffer, TEXT("%4i/%02i/%02i "), rgiDate[0],rgiDate[1],rgiDate[2]);
	wsprintf(pBuffer, TEXT("%02i:%02i:%02i"), rgiDate[3],rgiDate[4],rgiDate[5]);
}

IMsiRecord* CMsiDatabase::ExportTable(const ICHAR* szTable, IMsiPath& riPath, const ICHAR* szFile)
{
//!! critical section? needed if access simultaneously by custom actions
	CFileWrite File(m_iCodePage);
	IMsiRecord* piError = 0;

	// may change path so create a new path object
	PMsiPath pPath(0);
	piError = riPath.ClonePath(*&pPath);
	if(piError)
		return piError;

	// check for pseudo-table representing forced codepage setting
	if (m_piStorage && IStrComp(szTable, szForceCodepageTableName) == 0)
	{
		if (!File.Open(*pPath, szFile))
			return PostError(Imsg(idbgDbExportFile), szFile);
		File.WriteString(0, fTrue);
		File.WriteString(0, fTrue);
		File.WriteInteger(m_iCodePage + (m_iDatabaseOptions & idbfHashBinCountMask), fFalse);
		File.WriteString(szForceCodepageTableName, fTrue);
		return 0;
	}

	// check for pseudo-table representing SummaryInformation stream, MSI databases only
	if (m_piStorage && IStrComp(szTable, szSummaryInfoTableName) == 0)
	{
		PMsiSummaryInfo pSummary(0);
		IMsiRecord* piError = m_piStorage->CreateSummaryInfo(0, *&pSummary);
		if (piError)
			return piError;
		if (!File.Open(*pPath, szFile))
			return PostError(Imsg(idbgDbExportFile), szFile);
		File.WriteString(szSummaryInfoColumnName1, fFalse);
		File.WriteString(szSummaryInfoColumnName2, fTrue);
		File.WriteString(szSummaryInfoColumnType1, fFalse);
		File.WriteString(szSummaryInfoColumnType2, fTrue);
		File.WriteString(szSummaryInfoTableName,   fFalse);
		File.WriteString(szSummaryInfoColumnName1, fTrue);
		int cProperties = pSummary->GetPropertyCount();
		int iPropType;
		for (int iPID = 0; cProperties; iPID++)
		{
			if ((iPropType = pSummary->GetPropertyType(iPID)) == 0)
				continue;
			cProperties--;
			ICHAR rgchTemp[20];
			File.WriteInteger(iPID, fFalse);
			int iValue;
			int iDateTime;
			switch (iPropType)
			{
			case VT_I2:
			case VT_I4:
				pSummary->GetIntegerProperty(iPID, iValue);
				File.WriteInteger(iValue, fTrue);
				break;
			case VT_LPSTR:
				File.WriteMsiString(*MsiString(pSummary->GetStringProperty(iPID)), fTrue);
				break;
			case VT_FILETIME:
				pSummary->GetTimeProperty(iPID, (MsiDate&)iDateTime);
				DateTimeToString(iDateTime, rgchTemp);
				File.WriteString(rgchTemp, fTrue);
				break;
			case VT_CF:
				File.WriteString(TEXT("(Bitmap)"), fTrue);
				break;
			default:
				File.WriteString(TEXT("(Unknown format)"), fTrue);
			}
		}
		if (!File.Close())
			return PostError(Imsg(idbgDbExportFile), szFile);
		return 0;
	}

	// load table into memory, insure not temporary table
	MsiString istrTableName(szTable);
	MsiString istrSubFolder;
	CComPointer<CMsiTable> pTable(0);
	piError = LoadTable(*istrTableName, 0, *(IMsiTable**)&pTable);
	if (piError)
		return piError;
	int cPersist = pTable->GetPersistentColumnCount();
	if (!cPersist)
		return PostError(Imsg(idbgDbExportFile), szFile);

	// open output file
	if (!File.Open(*pPath, szFile))
		return PostError(Imsg(idbgDbExportFile), szFile);

	// output row of column names
	int iCol;
	for (iCol = 1; iCol <= cPersist; iCol++)
		File.WriteMsiString(DecodeStringNoRef(pTable->GetColumnName(iCol)),iCol==cPersist);

	// output row of column specifications
	MsiColumnDef* pColumnDef = pTable->GetColumnDefArray();
	for (iCol = 1; iCol <= cPersist; iCol++)
	{
		MsiColumnDef iColumnDef = *(++pColumnDef);
		int iSize = iColumnDef & icdSizeMask;
		ICHAR chType = 'i';
		if (!(iColumnDef & icdObject)) // integer
		{
			if (iColumnDef & icdShort)
			{
				if (iSize == 6)
					chType = 'd';
			}
			else
			{
				if (iSize == 16)
					chType = 'd';
				else if (!iSize)
				{
					Assert(0); //!! until test at create column
					iSize = 4;
				}
			}
		}
		else if (iColumnDef & icdShort) // string
		{
			chType = (iColumnDef & icdLocalizable) ? 'l' : 's';
		}
		else // persistent stream
		{
			chType = 'v'; //!! will change to 'b'
			MsiString istrFolder(szFile);
			istrFolder.Remove(iseFrom, '.');   // remove extension
			PMsiRecord precError = pPath->AppendPiece(*istrFolder); // create subdirectory for stream files
			Assert(precError == 0);
			int cCreated;
			precError = pPath->EnsureExists(&cCreated);
			Assert(precError == 0);
		}
		if (iColumnDef & icdNullable)
			chType -= ('a' - 'A');
		ICHAR szTemp[20];
		wsprintf(szTemp, TEXT("%c%i"), chType, iSize);
		File.WriteString(szTemp, iCol==cPersist);
	}

	// output codepage if non-neutral codepage
	IMsiCursor* piCursor = pTable->CreateCursor(fFalse);
	const IMsiString* piStr;
	Bool fExtended = fFalse;   // scan for non-ASCII characters
	while (!fExtended && piCursor && piCursor->Next())
	{
		pColumnDef = pTable->GetColumnDefArray();
		for (iCol = 1; iCol <= cPersist; iCol++)
		{
			MsiColumnDef iColumnDef = *(++pColumnDef);
			if ((iColumnDef & (icdObject | icdShort)) == (icdObject | icdShort))
			{
				piStr = &piCursor->GetString(iCol);
				const ICHAR* pch = piStr->GetString();
				while (*pch)
					if (*pch++ >= 0x80)
					{
						fExtended = fTrue;
						iCol = cPersist;
						break;  // break out of all three loops
					}
				piStr->Release();
			}
		}
	}
	if (piCursor)
		piCursor->Release();
	if (fExtended)
	{
		int iCodePage = m_iCodePage;   // use codepage of database
		if (iCodePage == 0)            // if no database codepage, use current codepage
			iCodePage = WIN::GetACP();
		File.WriteInteger(iCodePage, fFalse);
	}

	// output table name and primary key columns
	int cPrimaryKey = pTable->GetPrimaryKeyCount();
	for (iCol = 0; iCol <= cPrimaryKey; iCol++)
	{
		MsiStringId iName = iCol ? pTable->GetColumnName(iCol) : pTable->GetTableName();
		File.WriteMsiString(DecodeStringNoRef(iName),iCol==cPrimaryKey);
	}

	// output table rows
	PMsiCursor pCursor(pTable->CreateCursor(ictTextKeySort));
	while (pCursor && pCursor->Next())
	{
		pColumnDef = pTable->GetColumnDefArray();
		for (iCol = 1; iCol <= cPersist; iCol++)
		{
			MsiColumnDef iColumnDef = *(++pColumnDef);
			MsiString strColData;
			if (!(iColumnDef & icdObject)) // integer
			{
				File.WriteInteger(pCursor->GetInteger(iCol), iCol==cPersist);
				continue;
			}
			else if (iColumnDef & icdShort) // string
			{
				strColData = pCursor->GetString(iCol);
				//FUTURE if size == 0, then we could ".imd" extension and use separate file
			}
			else // persistent stream
			{
				PMsiStream pStream(pCursor->GetStream(iCol));
				if (pStream)
				{
					// Compute stream name for filename
					strColData = pCursor->GetMoniker();
					strColData.Remove(iseIncluding, '.'); // subtract table name and '.'
					strColData += TEXT(".ibd"); // append default extension
					CFileWrite LongDataFile;
					if (!LongDataFile.Open(*pPath, strColData))
						return PostError(Imsg(idbgDbExportFile), *strColData);

					char rgchBuf[1024];
					int cbRead, cbWrite;
					do
					{
						cbRead = sizeof(rgchBuf);
						cbWrite = pStream->GetData(rgchBuf, cbRead);
						if (cbWrite)
							LongDataFile.WriteBinary(rgchBuf, cbWrite);
					} while (cbWrite == cbRead);
				}
			}
			File.WriteMsiString(*strColData,iCol==cPersist);
		}
	}
	if (!File.Close())
		return PostError(Imsg(idbgDbExportFile), szFile);
	return 0;
}

IMsiRecord* CMsiDatabase::DropTable(const ICHAR* szName)
{
	IMsiRecord* piError;
	CComPointer<CMsiTable> piTable(0);
	MsiString istrTable(szName);
	MsiStringId iTableName = EncodeString(*istrTable);
	CMsiTable* piTableTemp;
	int iState = m_piCatalogTables->GetLoadedTable(iTableName, piTableTemp);
	if (iState == -1)
		return PostError(Imsg(idbgDbTableUndefined), szName);
	if (iState & iRowTemporaryBit)
		return PostError(Imsg(idbgDbDropTable), szName);
	Block();
	if (m_piStorage || piTableTemp)
	{
		if ((piError = LoadTable(*istrTable, 0, (IMsiTable*&)*&piTable)) != 0)
			return Unblock(), piError;
	}
	IMsiStorage* piStorage = GetOutputStorage();
	Bool fRemoveFromStorage = piStorage ? fTrue : fFalse;
	if (!piTable || piTable->GetInputStorage() != piStorage) // streams never transferred
		fRemoveFromStorage = fFalse;
	if (fRemoveFromStorage)
	{
		if ((piError = piStorage->RemoveElement(szName, Bool(fFalse | iCatalogStreamFlag))) != 0)
			piError->Release(); // Stream might not exist....
		if (!piTable->RemovePersistentStreams(iTableName, *m_piStorage))
			return Unblock(), PostError(Imsg(idbgDbDropTable), szName);
	}
	while(m_piCatalogTables->SetTableState(iTableName, ictsUnlockTable)) // remove locks
		;
	// remove entries from catalogs
	m_piCatalogTables->SetTableState(iTableName, ictsTemporary); //!! TEMP to force TableReleased to delete row
	TableReleased(iTableName);  // remove entry from table catalog
	m_piColumnCursor->Reset();  //!! necessary?
	m_piColumnCursor->SetFilter(iColumnBit(cccTable));
	m_piColumnCursor->PutInteger(cccTable, iTableName);
	while (m_piColumnCursor->Next())
		m_piColumnCursor->Delete();
	if (piTable)
		piTable->TableDropped(); // remove all data and definitions
	Unblock();
	return 0;
}  // TableReleased() will not be called again since m_fNonCatalog is true

bool CMsiDatabase::GetTableState(const ICHAR * szTable, itsEnum its)
{
	Block();
	bool fRet = m_piCatalogTables->GetTableState(EncodeStringSz(szTable), (ictsEnum)its);
	Unblock();
	return fRet;
}

int CMsiDatabase::GetANSICodePage()
{
	return m_iCodePage;
}


//!! OBSOLETE - will remove soon
itsEnum CMsiDatabase::FindTable(const IMsiString& ristrTable)  //!! OBSOLETE
{
	CMsiTable* piTable;
	int iState = m_piCatalogTables->GetLoadedTable(EncodeString(ristrTable), piTable);
	if (iState == -1)
		return  itsUnknown;
	if (piTable == 0)
		return  itsUnloaded; // or itsTransform
	if (iState & iRowTemporaryBit)
		return itsTemporary;
	return itsLoaded; // or itsSaveError
}

IMsiRecord*  CMsiDatabase::LoadTable(const IMsiString& ristrTable,
												 unsigned int cAddColumns,
												 IMsiTable*& rpiTable)
{
	IMsiRecord* piError = 0;
	CMsiTable* piTable;
	int iName  = EncodeString(ristrTable);
	Block();
	int iState = m_piCatalogTables->GetLoadedTable(iName, piTable);
	if (iState == -1)
	{
		if (ristrTable.Compare(iscExact, szStreamCatalog) != 0)
		{
			if (!m_piCatalogStreams)
				m_piCatalogStreams = CStreamTable::Create(*this);
			else
				m_piCatalogStreams->AddRef();
			piTable = m_piCatalogStreams;
		}
		else if (ristrTable.Compare(iscExact, szStorageCatalog) != 0)
		{
			if (!m_piCatalogStorages)
				m_piCatalogStorages = CStorageTable::Create(*this);
			else
				m_piCatalogStorages->AddRef();
			piTable = m_piCatalogStorages;
		}
		else
			piTable = 0;
		rpiTable = piTable;        // the single refcnt transferred to caller
		Unblock();
		return piTable ? 0 : PostError(Imsg(idbgDbTableUndefined), ristrTable);
	}
	if (piTable == 0)   // table not in memory
	{  // unfortunately we don't know how many rows we have, too slow to execute twice
		Bool fStat;
		if ((piTable = new CMsiTable(*this, iName, 0, cAddColumns)) != 0)
		{
			int cbStringIndex = (iState & iRowTableStringPoolBit) ? 2 : m_cbStringIndex;
			int cbFileWidth = piTable->CreateColumnsFromCatalog(iName, cbStringIndex);
			if (piTable->GetColumnCount() + cAddColumns > cMsiMaxTableColumns)
				fStat = fFalse;
			else if (iState & iRowTableOutputDbBit)
				fStat = piTable->LoadFromStorage(ristrTable, *m_piOutput, cbFileWidth, cbStringIndex);
			else if (m_piStorage)  // itsUnloaded and MSI storage
				fStat = piTable->LoadFromStorage(ristrTable, *m_piStorage, cbFileWidth, cbStringIndex);
			else // no storage, can ever happen?
				fStat = fFalse;
			if (fStat == fFalse)
			{
				piTable->MakeNonCatalog();  // remove name to prevent catalog operations
				piTable->Release();
				piTable = 0;
			}
		}
		if (!piTable)
			piError = PostError(Imsg(idbgDbTableCreate), ristrTable);
		else
		{
			m_iTableCnt++;             // keep count of table objects
			// set the cursor position back to where it belongs
			int iState = m_piCatalogTables->SetLoadedTable(iName, piTable); // will addref only if locked
			while (cAddColumns)  // fill temp columns with null
				piTable->FillColumn(piTable->GetColumnCount() + cAddColumns--, 0);
			if (m_piCatalogTables->GetTableState(iName, ictsTransform))
			{
				piError = ApplyTransforms(iName, *piTable, iState);
				if (piError)
				{
					piTable->Release();
					Unblock();
					return piError;
				}
			}
		}
	}
	else
		piTable->AddRef();
	rpiTable = piTable;        // refcnt transferred to caller
	Unblock();
	return piError;
}

IMsiRecord* CMsiDatabase::CreateTable(const IMsiString& ristrTable,
												  unsigned int cInitRows,
												  IMsiTable*& rpiTable)
{
	IMsiTable* piTable;
	IMsiRecord* piError = 0;
	Block();
	if (m_piCatalogTables->GetTableState(EncodeString(ristrTable), ictsTableExists))
	{
		piTable = 0;
		piError = PostError(Imsg(idbgDbTableDefined), ristrTable);
	}
	else
	{
		m_piTableCursor->PutString(ctcName, ristrTable);  // does a BindString
		int iName = m_piTableCursor->GetInteger(ctcName);
		if (!iName)
		{
			piTable = 0;
			piError = PostError(Imsg(idbgDbNoTableName));
		}
		else if ((piTable = new CMsiTable(*this, iName, cInitRows, 0)) != 0)
		{
			m_piTableCursor->PutMsiData(ctcTable, piTable);      // adds a refcnt
			m_piTableCursor->PutInteger(0, 1<<iraTemporary);  // temporary if no columns
			AssertNonZero(m_piTableCursor->Insert());
			m_iTableCnt++;                // keep count of table objects
			piTable->Release();  // release extra refcnt by catalog table insert
		}
		else
			piError = PostError(Imsg(idbgDbTableCreate), ristrTable);
	}
	m_piTableCursor->Reset();   // clear ref counts in cursor
	rpiTable = piTable;           // the single refcnt transferred to caller
	Unblock();
	return piError;
}

Bool CMsiDatabase::LockTable(const IMsiString& ristrTable, Bool fLock)
{
	if (m_Ref.m_iRefCnt == 0)
		return fFalse;
	bool fRet;
	Block();
		fRet = m_piCatalogTables->SetTableState(EncodeString(ristrTable), fLock?ictsLockTable:ictsUnlockTable);
	Unblock();
	return fRet ? fTrue : fFalse;
}

IMsiTable* CMsiDatabase::GetCatalogTable(int iTable)
{
	IMsiTable* piTable;
	switch (iTable)
	{
	case 0:  piTable = m_piCatalogTables;  break;
	case 1:  piTable = m_piCatalogColumns; break;
	default: piTable = 0;
	};
	if (piTable)
		piTable->AddRef();
	return piTable;
}

const IMsiString& CMsiDatabase::CreateTempTableName()
{
	static ICHAR rgchTempName[] = TEXT("#TEMP0000");  // leading '#' designates SQLServer local temp table
	Block();
	ICHAR* pchName = rgchTempName + sizeof(rgchTempName)/sizeof(ICHAR) - 2; // last char
	ICHAR ch;
	while ((ch = *pchName) >= '9')
	{
		*pchName = '0';  // overflow digit to next
		if (ch == '9')   // if was a digit
			pchName--;
	}
	(*pchName)++;
	const IMsiString* piName = &::CreateString();
	piName->SetString(rgchTempName, piName);
	Unblock();
	return *piName;
}

IMsiRecord* CMsiDatabase::CreateOutputDatabase(const ICHAR* szFile, Bool fSaveTempRows)
//!! fSaveTempRows is not supported and could be removed, along with m_fSaveTempRows
{
	if (m_piOutput != 0)
		return PostError(Imsg(idbgCreateOutputDb), szFile);

	if (!szFile) // the mode where szFile == 0 is obsolete and should generate an error
		szFile = TEXT("");

	ismEnum ismOpen = ismCreate;
		m_pguidClass = &STGID_MsiDatabase2;
	if (m_fRawStreamNames)
	{
		ismOpen = ismEnum(ismCreate + ismRawStreamNames);
		m_pguidClass = &STGID_MsiDatabase1;
	}
	Block();
	IMsiRecord* piError = CreateMsiStorage(szFile, ismOpen, m_piOutput);
	Unblock();
	if (piError)
		return piError;

	m_idsUpdate = idsWrite;
	m_fSaveTempRows = fSaveTempRows;  // not supported
	return 0;
}

IMsiRecord* CMsiDatabase::Commit()
{
	Bool fStat;
	IMsiStream* piStream;
	IMsiRecord* piError;
	IMsiRecord* piTransformError = 0;
	IMsiStorage* piStorage = GetOutputStorage(); // doesn't bump refcnt - don't release
	if (!piStorage)
		return 0;  // ignore if read-only

	int cErrors = 0;
	CTempBuffer<MsiCacheRefCnt, 1024> rgRefCnt;  // non-persistent string ref counts
	if ((piError = piStorage->OpenStream(szTableCatalog, Bool(fTrue + iCatalogStreamFlag), piStream)) != 0)
		return piError;
	Block();
	rgRefCnt.SetSize(m_cCacheUsed);
	int cTempRefCnt = rgRefCnt.GetSize();
	memset(rgRefCnt, 0, sizeof (MsiCacheRefCnt) * cTempRefCnt);
	m_rgiCacheTempRefCnt = rgRefCnt; // set for DerefTemporaryString

	if (m_piCatalogStreams  && !m_piCatalogStreams->WriteData())
		cErrors++;
	if (m_piCatalogStorages && !m_piCatalogStorages->WriteData())
		cErrors++;

	IMsiCursor* piCursor = m_piCatalogTables->CreateCursor(fFalse);
	//!!FIX
	((CMsiCursor*)(IMsiCursor*)piCursor)->m_idsUpdate = idsWrite; //!!FIX allow updates
	//!!FIX

	int cbOldStringIndex = m_cbStringIndex;

	while (piCursor->Next()) // need separate cursor, table may be updated
	{
		int cbFileWidth;
		int iName = piCursor->GetInteger(ctcName);
		const IMsiString& riTableName = DecodeStringNoRef(iName); // not ref counted

		CComPointer<CMsiTable> pTable((CMsiTable*)piCursor->GetMsiData(ctcTable));
		int iState = piCursor->GetInteger(~iTreeLinkMask);  // get raw row attribute bits
		if (pTable == 0)  // not loaded
		{
			if ((iState & iRowTableStringPoolBit) != 0
			 || (iState & iRowTableTransformBit) != 0
			 ||((iState & iRowTableOutputDbBit) == 0 && m_piOutput != 0))
			{
				if (!(pTable = new CMsiTable(*this, iName, 0, iNonCatalog))) // avoid catalog mgmt
				{
					cErrors++;
					continue;
				}
				int cbStringIndex = (iState & iRowTableStringPoolBit) ? 2 : m_cbStringIndex;
				cbFileWidth = pTable->CreateColumnsFromCatalog(iName, cbStringIndex);
				fStat = pTable->LoadFromStorage(riTableName, *m_piStorage, cbFileWidth, cbStringIndex);
				if (fStat == fFalse)
				{
					cErrors++;
					continue;
				}
				else
				{
					if (m_piOutput && !(iState & iRowTableOutputDbBit))
						m_piCatalogTables->SetTableState(iName, ictsOutputDb);
				}

				if (iState & iRowTableTransformBit)
				{
					piError = ApplyTransforms(iName, *pTable, iState);
					if (piError)
					{
						if (piTransformError)
							piError->Release(); // keep first one
						else
							piTransformError = piError;
						cErrors++;
						continue;
					}
				}
				fStat = pTable->SaveToStorage(riTableName, *piStorage);
				if (fStat == fFalse)
				{
					cErrors++;
					continue;
				}
				// table will be released at end of loop
			}
		}
		else if (iState & iRowTemporaryBit) // temporary table loaded
		{
			pTable->DerefStrings();
			continue;
		}
		else  // persistent table already loaded
		{
			if (iState & iRowTableSaveErrorBit)  // failed to persist on table release, refcnt held by database
			{
				m_piCatalogTables->SetTableState(iName, ictsNoSaveError);  // remove flag, fatal if fails this time
				AssertNonZero(pTable->Release());  // remove refcount set when itsSaveError state set, refcnt still held by pTable
//				iNewState &= ~iRowTableSaveErrorBit;
			}
			pTable->DerefStrings();  // table remains in memory
			fStat = pTable->SaveToStorage(riTableName, *piStorage);
			if (fStat == fFalse)
			{
				cErrors++;
				continue;
			}
		}
//		if (iNewState != iState)
//		{
//			piCursor->PutInteger(~iTreeLinkMask, iNewState);
//			if (!piCursor->Update())
//				cErrors++; // should never happen
//		}
		piStream->PutData(&iName, m_cbStringIndex);  // table catalog row, name only
	}
	piCursor->Release();
	piStream->Release();  // close table catalog stream

	if (cbOldStringIndex != m_cbStringIndex) // transform may have increased the string index size. if this is the case then we need to go again.
	{
		DEBUGMSG(TEXT("Change in string index size during commit. Recommitting database."));
		return Unblock(), Commit();
	}
	else
	{
		m_idsUpdate = idsWrite; // restore state in case of any error below
		if (piTransformError)
			return Unblock(), piTransformError;
		if (cErrors)
			return Unblock(), PostError(Imsg(idbgDbCommitTables));

		// write catalog tables to storage and deref temporary table refs
		CMsiTable* pTable = m_piTables;
		while(pTable)
		{
			pTable->DerefStrings();
			pTable = pTable->GetNextNonCatalogTable();
		}
		if (!m_piCatalogColumns->SaveToStorage(*MsiString(*szColumnCatalog), *piStorage)
		 || (piError = StoreStringCache(*piStorage, rgRefCnt, cTempRefCnt)) != 0
		 || (m_pguidClass && (piError = piStorage->SetClass(*m_pguidClass)) != 0)
		 || (piError = piStorage->Commit()) != 0)
			return Unblock(), piError;
	}
	Unblock();
	return 0;
}

IMsiRecord* CMsiDatabase::StoreStringCache(IMsiStorage &riStorage, MsiCacheRefCnt* rgRefCntTemp, int cRefCntTemp)
{
	// write string cache to storage

	IMsiRecord* piError;
	PMsiStream pPoolStream(0);
	PMsiStream pDataStream(0);
	if ((piError = riStorage.OpenStream(szStringPool, Bool(fTrue + iCatalogStreamFlag), *&pPoolStream)) != 0
	 || (piError = riStorage.OpenStream(szStringData, Bool(fTrue + iCatalogStreamFlag), *&pDataStream)) != 0)
		return piError;

#ifdef UNICODE
	CTempBuffer<char, 1024> rgbBuf;  // intermediate buffer for non-Unicode strings
	int cBadStrings = 0;
	DWORD dwFlags = 0; // WC_COMPOSITECHECK fails on Vietnamese
	const char* szDefault = "\177";
	BOOL fDefaultUsed = 0;
	BOOL* pfDefaultUsed = &fDefaultUsed;
	if (m_iCodePage >= CP_UTF7 || m_iCodePage >= CP_UTF8)
	{
		dwFlags = 0;    // flags must be 0 to avoid invalid argument errors
		szDefault = 0;
		pfDefaultUsed = 0;
	}
#endif

	pPoolStream->PutInt32(m_iCodePage + m_iDatabaseOptions); // write header entry
	int cEntries = m_cCacheUsed;
	MsiCacheLink*   pCache = m_rgCacheLink; // skip over header, [0], null string index
	MsiCacheRefCnt* pRefCnt = m_rgCacheRefCnt;
	int iPool;
	while (--cEntries > 0)  // truncate empty entries at end, keep [0] entry for codepage and flags
	{
		iPool = pRefCnt[cEntries] & 0x7FFF;
		if (cRefCntTemp > cEntries)
			iPool -= rgRefCntTemp[cEntries];
		if (iPool != 0)
			break;
		if (cRefCntTemp > cEntries)
			cRefCntTemp--;
	}
	while (++pCache, ++pRefCnt, cEntries-- != 0)
	{
		iPool = *pRefCnt & 0x7FFF;
		if (--cRefCntTemp > 0)
			iPool -= *(++rgRefCntTemp);
		if (iPool != 0)
		{
			const IMsiString* piStr = pCache->piString;
			int cch = piStr->TextSize();
#ifdef UNICODE
			int cb = WIN::WideCharToMultiByte(m_iCodePage, dwFlags,
								piStr->GetString(), cch, rgbBuf, rgbBuf.GetSize(), szDefault, pfDefaultUsed);
			if (cb == 0)   // can only happen on invalid argurment or buffer overflow
			{
				cb = WIN::WideCharToMultiByte(m_iCodePage, dwFlags,
								piStr->GetString(), cch, 0, 0, 0, 0);
				rgbBuf.SetSize(cb);
				cb = WIN::WideCharToMultiByte(m_iCodePage, dwFlags,
								piStr->GetString(), cch, rgbBuf, rgbBuf.GetSize(), szDefault, pfDefaultUsed);
				Assert(cb);
			}
			if (fDefaultUsed)
				cBadStrings++;
			iPool <<= 16;
			if (cb > cch)   // must be DBCS characters in string
				iPool |= (1<<31);
			if (cb > 0xFFFF)
			{
				pPoolStream->PutInt32(iPool);  // 0 length designates next int as extended size
				iPool = 0;
			}
			iPool += cb;
			pDataStream->PutData(rgbBuf, cb);
#else // !UNICODE
			iPool <<= 16;
			if (piStr->IsDBCS())
				iPool |= (1<<31);
			if (cch > 0xFFFF)
			{
				pPoolStream->PutInt32(iPool);  // 0 length designates next int as extended size
				iPool = 0;
			}
			iPool += cch;
			pDataStream->PutData(piStr->GetString(), cch);
#endif // UNICODE

		}
		pPoolStream->PutInt32(iPool);
	}
#ifdef UNICODE
	if (cBadStrings)
	{
		DEBUGMSG1(TEXT("Database Commit: %i strings with unconvertible characters"), (const ICHAR*)(INT_PTR)cBadStrings);
	}
#endif // UNICODE
	if (pDataStream->Error() | pPoolStream->Error())
		return PostError(Imsg(idbgDbCommitTables));
	
	return 0;
}

idsEnum CMsiDatabase::GetUpdateState()
{
	return m_idsUpdate;
}

IMsiStorage* CMsiDatabase::GetStorage(int iStorage)
{
	IMsiStorage* piStorage = 0;
	if (iStorage == 0) // output database
	{
		piStorage = m_piOutput;
	}
	else if (iStorage == 1) // input (main) database
	{
		piStorage = m_piStorage;
	}
	else // transform storage file
	{
		// Apply all transforms, in order
		IMsiCursor* piCursor = m_piTransformCatalog->CreateCursor(fFalse);
		Assert(piCursor);

		piCursor->PutInteger(tccID, iStorage);
		if (piCursor->Next())
			piStorage = (IMsiStorage*)piCursor->GetMsiData(tccTransform);

		piCursor->Release();	
	}
	if (piStorage)
		piStorage->AddRef();
	return piStorage;
}



//____________________________________________________________________________
//
//  CMsiDatabase non-virtual implementation
//____________________________________________________________________________

CMsiDatabase::CMsiDatabase(IMsiServices& riServices)  // members zeroed bv operator new
 : m_cCacheInit(cCacheInitSize), m_cHashBins(1<<cHashBitsDefault), m_riServices(riServices)
{
	m_riServices.AddRef();
	m_piDatabaseName = &g_MsiStringNull;
	Debug(m_Ref.m_pobj = this);
	WIN::InitializeCriticalSection(&m_csBlock);
#if !defined(_WIN64) && defined(DEBUG)
	g_fUseObjectPool = GetTestFlag('O');
#endif // _WIN64
}

CMsiDatabase::~CMsiDatabase() // cannot be called until all tables released
{
	if (m_idsUpdate == idsWrite)
	{
		IMsiStorage* piStorage = GetOutputStorage();
		if (piStorage)    // ignore if read-only
		{
			IMsiRecord* piError = piStorage->Rollback();
			if (piError)
				SRV::SetUnhandledError(piError);
		}
	}

	if (m_piCatalogTables)
		m_piCatalogTables->Release();
	if (m_piTableCursor)
		m_piTableCursor->Release();
	if (m_piCatalogColumns)
		m_piCatalogColumns->Release();
	if (m_piColumnCursor)
		m_piColumnCursor->Release();
	if (m_piCatalogStreams)  // unprocessed error
		m_piCatalogStreams->Release();
	if (m_piCatalogStorages)  // unprocessed error
		m_piCatalogStorages->Release();
	
	delete m_rgHash;
	if (m_rgCacheLink)
	{
		if (m_cCacheUsed > 0)
		{
			MsiCacheLink* pCache = m_rgCacheLink + m_cCacheUsed;  // free in reverse order to help debug mem mgr
			for (int cEntries = m_cCacheUsed; --pCache,--cEntries != 0; )
			{
				if (pCache->piString)
					pCache->piString->Release();
			}
		}
		GlobalUnlock(m_hCache);
		GlobalFree(m_hCache);
	}
	m_piDatabaseName->Release();
	if (m_piStorage)
		m_piStorage->Release();
	if (m_piOutput)
		m_piOutput->Release();

	WIN::DeleteCriticalSection(&m_csBlock);
}

IMsiRecord* CMsiDatabase::OpenDatabase(const ICHAR* szDataSource, idoEnum idoOpenMode)
{
	m_piDatabaseName->SetString(szDataSource, m_piDatabaseName);
	m_idsUpdate = ((idoOpenMode & idoOpenModeMask) == idoReadOnly ? idsRead : idsWrite);
	ismEnum ismOpenMode = (ismEnum)idoOpenMode;  // idoListScript already processed

	IMsiStorage* piStorage = 0;
	IMsiRecord* piError;
	if (szDataSource && *szDataSource)
	{
		piError = SRV::CreateMsiStorage(szDataSource, ismOpenMode, piStorage);
		if (piError)
			return piError;
	}
	if ((piError = CreateSystemTables(piStorage, idoOpenMode)) != 0) // initialize string cache, catalog tables
	{
		if (piStorage)
			piStorage->Release();
		return piError;
	}
	m_piStorage = piStorage;  // transfers ref cnt
	return 0;
}

IMsiRecord* CMsiDatabase::OpenDatabase(IMsiStorage& riStorage, Bool fReadOnly)
{
	m_idsUpdate = fReadOnly ? idsRead : idsWrite;
	idoEnum idoOpenMode = (fReadOnly ? idoReadOnly : idoTransact);
	IMsiRecord* piError;
	if ((piError = CreateSystemTables(&riStorage, idoOpenMode)) != 0) // initialize string cache, catalog tables
		return piError;
	m_piStorage = &riStorage;
	riStorage.AddRef();
	return 0;
}

IMsiRecord* CMsiDatabase::PostError(IErrorCode iErr, const IMsiString& istr)
{
	return ::PostError(iErr, *m_piDatabaseName, istr);
}

IMsiRecord* CMsiDatabase::PostError(IErrorCode iErr, const ICHAR* szText1,
                                    const ICHAR* szText2)
{
	return ::PostError(iErr, *m_piDatabaseName, *MsiString(szText1), *MsiString(szText2));
}

IMsiRecord* CMsiDatabase::PostError(IErrorCode iErr, const IMsiString& istr, int iCol)
{
	return ::PostError(iErr, *m_piDatabaseName, istr, iCol);
}

IMsiRecord* CMsiDatabase::PostError(IErrorCode iErr, const ICHAR* szText, int iRow)
{
	return ::PostError(iErr, *m_piDatabaseName, *MsiString(szText), iRow);
}

IMsiRecord* CMsiDatabase::PostError(IErrorCode iErr, int iCol)
{
	return ::PostError(iErr, *m_piDatabaseName, iCol);
}

IMsiRecord* CMsiDatabase::PostError(IErrorCode iErr, int i1, int i2)
{
	return ::PostError(iErr, *m_piDatabaseName, i1, i2);
}

IMsiRecord* CMsiDatabase::PostOutOfMemory()
{
	IMsiRecord* piRec = &m_riServices.CreateRecord(3);
	ISetErrorCode(piRec, Imsg(idbgDbInitMemory));
	piRec->SetMsiString(2, *m_piDatabaseName);
	return piRec;
}

// Notificaton of CMsiTable destruction, called from CMsiTable::Release, DropTable
// caller must AddRef the Database to prevent premature database destruction

void CMsiDatabase::TableReleased(MsiStringId iName)
{
	m_piTableCursor->SetFilter(iColumnBit(ctcName));
	m_piTableCursor->PutInteger(ctcName, iName);
	AssertNonZero(m_piTableCursor->Next());
	int iState = m_piTableCursor->GetInteger(~iTreeLinkMask);
	const IMsiData* piData = m_piTableCursor->GetMsiData(ctcTable); // do AddRef to cancel Release when table ref cleared
	if (iState & iRowTemporaryBit)
		AssertNonZero(m_piTableCursor->Delete());
	else // release object from table row
	{
		m_piCatalogTables->SetLoadedTable(iName, 0);
		if (m_piOutput)
			m_piCatalogTables->SetTableState(iName, ictsOutputDb);
	}
	m_piTableCursor->Reset();   // clear ref counts in cursor
	if (piData)
		--m_iTableCnt;
	return;
}

const IMsiString& CMsiDatabase::ComputeStreamName(const IMsiString& riTableName, MsiTableData* pData, MsiColumnDef* pColumnDef)
{
	const IMsiString* piStreamName = &g_MsiStringNull;
	int cchTable = riTableName.TextSize();
	const IMsiString* pistr;
	MsiString istrTemp;
	for(;;)
	{
		if (cchTable)
		{
			pistr = &riTableName;
			cchTable = 0;
		}
		else if (!(*pColumnDef++ & icdObject)) // integer primary key
		{
			istrTemp = int(*pData++ - iIntegerDataOffset);
			pistr = istrTemp;
		}
		else // string primary key
		{
			pistr = &DecodeStringNoRef(*pData++);
		}
		piStreamName->AppendMsiString(*pistr, piStreamName);
		if (!(*pColumnDef & icdPrimaryKey))
			return *piStreamName;  // extra refcnt returned
		piStreamName->AppendMsiString(*MsiString(MsiChar('.')), piStreamName);
	}
}

Bool CMsiDatabase::LockIfNotPersisted(MsiStringId iTable)
{
	if (m_piCatalogTables->GetTableState(iTable, ictsLockTable))
		return fTrue;
	return m_piCatalogTables->SetTableState(iTable, ictsLockTable) ? fTrue : fFalse;
}

IMsiStorage* CMsiDatabase::GetTransformStorage(unsigned int iStorage)
{
	Assert(iStorage > iPersistentStream && iStorage <= iMaxStreamId && m_piTransformCatalog != 0);
	IMsiCursor* piCursor = m_piTransformCatalog->CreateCursor(fFalse);
	if (piCursor == 0)
		return 0;  // should never happen
	piCursor->SetFilter(tccID);
	piCursor->PutInteger(tccID, iStorage);
	if (!piCursor->Next())
		return 0; // only should happen if internal error
	IMsiStorage* piStorage = (IMsiStorage*)piCursor->GetMsiData(tccTransform);
	piCursor->Release();
	return piStorage;
}

//____________________________________________________________________________
//
//  CMsiDatabase string cache implementation
//____________________________________________________________________________

IMsiRecord* CMsiDatabase::InitStringCache(IMsiStorage* piStorage)
{
	PMsiStream pPoolStream(0);
	PMsiStream pDataStream(0);
	IMsiRecord* piError;
	int cbDataStream;
	int cbStringPool = 0; //prevent warning

	// Open persistent streams, read string pool header word
	if (piStorage)
	{
		piError = piStorage->OpenStream(szStringPool, Bool(fFalse + iCatalogStreamFlag), *&pPoolStream);
		if (piError == 0)
		{
			piError = piStorage->OpenStream(szStringData, Bool(fFalse + iCatalogStreamFlag), *&pDataStream);
#ifndef UNICODE  // stream name bug in OLE32 causes all both of these opens to map to the same stream, which errors
			AssertSz(piError == 0, "Database open failed, possible stream name bug in OLE32.DLL");
#endif
		}
		if (piError != 0)
		{
			piError->Release();
			return PostError(Imsg(idbgDbInvalidFormat));
		}
		cbStringPool = pPoolStream->GetIntegerValue();
		cbDataStream = pDataStream->GetIntegerValue();
		m_cCacheInit = m_cCacheUsed = cbStringPool/sizeof(int);
		m_cCacheTotal = m_cCacheUsed + cCacheLoadReserve;
		int iPoolHeader = pPoolStream->GetInt32();  // 1st cache entry (string index 0) reserved for header
		m_iCodePage        = iPoolHeader & idbfCodepageMask;
		if (m_iCodePage != 0 && m_iCodePage != CP_UTF8 && m_iCodePage != CP_UTF7 && !WIN::IsValidCodePage(m_iCodePage))
			return PostError(Imsg(idbgDbCodepageNotSupported), m_iCodePage);
		if (iPoolHeader & idbfHashBinCountMask)  // explicit hash bin count set
			m_cHashBins = 1 << ((iPoolHeader & idbfHashBinCountMask) >> idbfHashBinCountShift);
		else
		{
		// Make a rough guess at what the number should be
			int iBits = cHashBitsMinimum + 1;

			iBits = iBits + m_cCacheTotal/10000;

			if (iBits > cHashBitsMaximum)
				iBits = cHashBitsMaximum;

			Assert (iBits >= cHashBitsMinimum);
			
			m_cHashBins = 1 << iBits;
		}
		m_iDatabaseOptions = iPoolHeader & (idbfDatabaseOptionsMask | idbfHashBinCountMask); // preserve forced hash count
		if (m_iDatabaseOptions & ~(idbfKnownDatabaseOptions | idbfHashBinCountMask))
			return PostError(Imsg(idbgDbInvalidFormat));
	}
	else
	{
		m_cCacheTotal = m_cCacheInit;
		m_cCacheUsed  = 1;  // reserve [0] for header
	}

	// Initialize hash table
	int cHashBins = m_cHashBins;
	if ((m_rgHash = new MsiCacheIndex[cHashBins]) == 0)
		return PostOutOfMemory();
	int iHashBin = 0x80000000L;     // point hash bins to themselves
	MsiCacheIndex* pHash = m_rgHash;
	while (cHashBins--)
		*pHash++ = MsiCacheIndex(iHashBin++);

	// Initialize string array, cache link array followed by refcount array
	while ((m_hCache = GlobalAlloc(GMEM_MOVEABLE, m_cCacheTotal
						* (sizeof(MsiCacheLink) + sizeof(MsiCacheRefCnt)))) == 0)
		HandleOutOfMemory();
	if ((m_rgCacheLink = (MsiCacheLink*)GlobalLock(m_hCache)) == 0)
		return PostOutOfMemory(); // should never fail
	m_rgCacheLink->piString = 0;   // [0] reserved for null string
	m_rgCacheLink->iNextLink = 0;  // to force assert on hash chain errors
	m_rgCacheRefCnt = (MsiCacheRefCnt*)(m_rgCacheLink + m_cCacheTotal);
	m_rgCacheRefCnt[0] = 0;    // should never be accessed
	m_cbStringIndex = 2;       // default string index persistent size
	if (piStorage)
	{
		int cEntries = m_cCacheUsed;
		MsiCacheLink*   pCache  = m_rgCacheLink + 1;
		MsiCacheRefCnt* pRefCnt = m_rgCacheRefCnt;
#ifdef UNICODE
		CTempBuffer<char, 1024> rgbBuf;  // intermediate buffer for non-Unicode strings
#endif
		for (MsiStringId iCache = 1; iCache < cEntries; pCache++, iCache++)
		{
			int iPool = pPoolStream->GetInt32();
			if (iPool == 0)
			{
				*(++pRefCnt) = 0;
				pCache->piString = 0;
				pCache->iNextLink = MsiCacheIndex(m_iFreeLink);
				m_iFreeLink = iCache;
			}
			else
			{
				*(++pRefCnt) = (short)((iPool >> 16) & 0x7FFF);
				int cb = iPool & 0xFFFF;
				if (cb == 0)
				{
					cb = pPoolStream->GetInt32();
					cEntries--;
					m_cCacheUsed--;
				}
				Bool fDBCS = iPool < 0 ? fTrue : fFalse;
#ifdef UNICODE
				rgbBuf.SetSize(cb);
				pDataStream->GetData(rgbBuf, cb);
				int cch = cb;
				if (fDBCS)  // need extra call to find size of DBCS string
					cch = WIN::MultiByteToWideChar(m_iCodePage, 0, rgbBuf, cb, 0, 0);
				ICHAR* pchStr = SRV::AllocateString(cch, fFalse, pCache->piString);
				WIN::MultiByteToWideChar(m_iCodePage, 0, rgbBuf, cb, pchStr, cch);
#else // !UNICODE
				ICHAR* pchStr = SRV::AllocateString(cb, fDBCS, pCache->piString);
				pDataStream->GetData(pchStr, cb);
#endif // UNICODE
				int iLen;
				unsigned int iHash = HashString(pchStr, iLen);
				pCache->iNextLink = m_rgHash[iHash];
				m_rgHash[iHash] = MsiCacheIndex(iCache);
			}
		}
		if (pDataStream->Error() | pPoolStream->Error())
			return PostError(Imsg(idbgDbOpenStorage)); //!! different msg?
	}
	else
	{
		m_iCodePage        = 0;  // initialize to neutral
		m_iDatabaseOptions = 0;
	}
	m_cbStringIndex = (m_iDatabaseOptions & idbfExpandedStringIndices) ? 3 : 2;
	return 0;

}

IMsiRecord* CMsiDatabase::CreateSystemTables(IMsiStorage* piStorage, idoEnum idoOpenMode)
{
	idoEnum idoOpenType = idoEnum(idoOpenMode & idoOpenModeMask);  // filter off option flags
	bool fCreate = (idoOpenType== idoCreate || idoOpenType == idoCreateDirect);

	if (fCreate)
	{
		if ((idoOpenMode & idoRawStreamNames) || GetTestFlag('Z')) //!! temp option to force old storage name format
		{
			m_pguidClass = (idoOpenMode & idoPatchFile) ? &STGID_MsiPatch1 : &STGID_MsiDatabase1;
			m_fRawStreamNames = fTrue;
		}
		else if (idoOpenMode & idoPatchFile)
			m_pguidClass = &STGID_MsiPatch2;
		else
			m_pguidClass = &STGID_MsiDatabase2;
	}
	else if (idoOpenMode & idoPatchFile)  // request to open a patch file as a database for query or update
	{
		if (piStorage->ValidateStorageClass(ivscPatch1))   // temp support for update of obsolete patch files
			m_fRawStreamNames = fTrue;
		else if (!piStorage->ValidateStorageClass(ivscPatch2))
			return PostError(Imsg(idbgDbInvalidFormat));
	}
	else if (piStorage->ValidateStorageClass(ivscDatabase1)) // old database with uncompressed stream names
	{
		m_fRawStreamNames = fTrue;  // internal flag, used when creating transform or output database
		piStorage->OpenStorage(0, ismRawStreamNames, piStorage); // force storage to uncompressed streams
	}
	else if (!piStorage->ValidateStorageClass(ivscDatabase2))  // current database format
		return PostError(Imsg(idbgDbInvalidFormat));

	IMsiRecord* piError = InitStringCache(fCreate ? 0 : piStorage);
	if (piError)
		return piError;

	// create system catalog tables - currently not stored in catalog
	CCatalogTable* piCatalog;
	if ((piCatalog = new CCatalogTable(*this, cCatalogInitRowCount, 2)) == 0
	 || ctcName  != piCatalog->CreateColumn(icdString + icdPrimaryKey + icdPersistent + 64, *MsiString(sz_TablesName))
	 || ctcTable != piCatalog->CreateColumn(icdObject + icdNullable   + icdTemporary, g_MsiStringNull))
		return PostOutOfMemory();
	m_piCatalogTables = piCatalog;
	if ((piCatalog = new CCatalogTable(*this, cCatalogInitRowCount, 2)) == 0
	 || cccTable != piCatalog->CreateColumn(icdString  + icdPrimaryKey + icdPersistent + 64, *MsiString(sz_ColumnsTable))
	 || cccColumn!= piCatalog->CreateColumn(icdShort   + icdPrimaryKey + icdPersistent + 2,  *MsiString(sz_ColumnsNumber))
	 || cccName  != piCatalog->CreateColumn(icdString  + icdNullable   + icdPersistent + 64, *MsiString(sz_ColumnsName))
	 || cccType  != piCatalog->CreateColumn(icdShort   + icdNoNulls    + icdPersistent + 2,  *MsiString(sz_ColumnsType)))
		return PostOutOfMemory();
	m_piCatalogColumns = piCatalog;
	if (!fCreate)
	{
		//!! check error when changed to return IMsiRecord!
		if (!m_piCatalogTables->LoadData(*MsiString(*szTableCatalog), *piStorage, m_cbStringIndex, m_cbStringIndex)
		 || !m_piCatalogColumns->LoadData(*MsiString(*szColumnCatalog), *piStorage, m_cbStringIndex * 2 + sizeof(short) * 2, m_cbStringIndex))
			return PostError(Imsg(idbgDbInvalidFormat));
		AssertNonZero(m_piCatalogTables->FillColumn(ctcTable, 0));
	}

	if ((m_piTableCursor  = m_piCatalogTables->CreateCursor(fFalse)) == 0
	 || (m_piColumnCursor = m_piCatalogColumns->CreateCursor(fFalse)) == 0)
		return PostOutOfMemory();
	m_piCatalogTables->SetReadOnly();  // prevent update by user cursors
	m_piCatalogColumns->SetReadOnly();

	// eventually we could put these table into the catalog, need column names?

	// Create transform table to hold all transforms associated w/ this database
	CMsiTable* piTable;
	if ((piTable = new CMsiTable(*this, 0, 0, iNonCatalog)) == 0
		|| tccID     != piTable->CreateColumn(icdShort + icdPrimaryKey +
															icdTemporary, g_MsiStringNull)
		|| tccTransform != piTable->CreateColumn(icdObject +
															icdTemporary, g_MsiStringNull)
		|| tccErrors != piTable->CreateColumn(icdShort +
															icdTemporary, g_MsiStringNull))
		return PostOutOfMemory();
	m_piTransformCatalog = piTable;
	m_iLastTransId= 1; // Reserve 1 for identifying local persistent streams
	return 0;
}

unsigned int CMsiDatabase::HashString(const ICHAR* sz, int& iLen)
{
	unsigned int iHash = 0;
	int iHashBins = m_cHashBins;
	int iHashMask = iHashBins - 1;
	const ICHAR *pchStart = sz;
	
	iLen = 0;
	while (*sz != 0)
	{
		int carry;
		carry = iHash & 0x80000000;	
		iHash <<= 1;
		if (carry)
			iHash |= 1;
		iHash ^= *sz;
		sz++;
	}
	iLen = (int)(sz - pchStart);
	iHash &= iHashMask;
	return iHash;
}

MsiStringId CMsiDatabase::FindString(int iLen, int iHash, const ICHAR* sz)
{
	MsiCacheIndex iLink = m_rgHash[iHash];
	while (iLink >= 0)
	{
		MsiCacheLink* pCache = &m_rgCacheLink[iLink];
		const IMsiString* piStr = pCache->piString;
		if (piStr->TextSize() == iLen && piStr->Compare(iscExact, sz))
			return iLink;
		iLink = pCache->iNextLink;
	}
	return 0; // if not found
}

inline MsiStringId CMsiDatabase::MaxStringIndex()
{
	return m_cCacheUsed - 1;
}

MsiStringId CMsiDatabase::BindString(const IMsiString& riString)
{
	//!! do we need to have a reserve, and indicate when we're getting low?
	int iLen = riString.TextSize();
	if (iLen == 0)
		return 0;
	Assert(m_rgCacheLink);
	const ICHAR* sz = riString.GetString();
	int iHash = HashString(sz, iLen);
	MsiStringId iLink = FindString(iLen, iHash, sz);
	if (iLink)
	{
		++m_rgCacheRefCnt[iLink];
		AssertSz(m_rgCacheRefCnt[iLink] != 0, "Refcounts wrapped, all bets are off");
	}
	else
	{
		MsiCacheLink* pLink;
		if (m_iFreeLink)
		{
			iLink = m_iFreeLink;
			m_iFreeLink = m_rgCacheLink[iLink].iNextLink;
		}
		else
		{
			if (m_cCacheUsed >= m_cCacheTotal)
			{
				int cCacheGrow = m_cCacheTotal - m_cCacheInit;
				if (cCacheGrow == 0)
					cCacheGrow = m_cCacheInit >> 2;
				int cOldCacheTotal = m_cCacheTotal;
				m_cCacheTotal += cCacheGrow;
				GlobalUnlock(m_hCache);
				HGLOBAL hCache;
				while((hCache = GlobalReAlloc(m_hCache, m_cCacheTotal
									* (sizeof(MsiCacheLink) + sizeof(MsiCacheRefCnt)), GMEM_MOVEABLE)) == 0)
					HandleOutOfMemory();

				m_hCache = hCache;
				m_rgCacheLink = (MsiCacheLink*)GlobalLock(hCache); // caution, data may move
				MsiCacheRefCnt* pOldRefCnt = (MsiCacheRefCnt*)(m_rgCacheLink + cOldCacheTotal);
				m_rgCacheRefCnt = (MsiCacheRefCnt*)(m_rgCacheLink + m_cCacheTotal);
				memmove(m_rgCacheRefCnt, pOldRefCnt, cOldCacheTotal * sizeof(MsiCacheRefCnt));
				Assert(m_rgCacheLink);
				if (!m_rgCacheLink)  // should never fail, but be safe anyway
					return 0;
			}
			iLink = m_cCacheUsed++;
			// check if overflowing 2-byte persistent string indices
			// if so, must flag all persistent tables (including those tables in memory) with 2-byte indices for reprocessing
			// temporary tables are excluded
			if (m_cCacheUsed == (1<<16) && m_cbStringIndex != 3)
			{
				DEBUGMSG(TEXT("Exceeded 64K strings. Bumping database string index size."));
				m_cbStringIndex = 3;
				m_iDatabaseOptions |= idbfExpandedStringIndices;
				if (m_piCatalogTables) // transforms use the database object to hold the string pool, but not catalog tables
				{
					PMsiCursor pCursor = m_piCatalogTables->CreateCursor(fFalse); // catalog cursor may be in use
					while (pCursor->Next())
					{
						if (!(pCursor->GetInteger(~iTreeLinkMask) & iRowTemporaryBit))  // table not temporary
							m_piCatalogTables->SetTableState(pCursor->GetInteger(ctcName), ictsStringPoolSet);
					}
				}
			}
		}
		m_rgCacheRefCnt[iLink] = 1;
		pLink = &m_rgCacheLink[iLink];
		pLink->piString  = &riString;
		pLink->iNextLink = m_rgHash[iHash];
		m_rgHash[iHash] = MsiCacheIndex(iLink);
		riString.AddRef();
	}
	return iLink;
}

inline void CMsiDatabase::DerefTemporaryString(MsiStringId iString)
{
	Assert(iString < m_cCacheUsed);
	if (iString != 0)
		++m_rgiCacheTempRefCnt[iString];
}

void CMsiDatabase::UnbindStringIndex(MsiStringId iString)
{
	if (iString == 0)
		return;
	if(iString >= m_cCacheUsed || m_rgCacheRefCnt[iString] == 0)
	{
		AssertSz(0, "Database string pool is corrupted.");
		DEBUGMSGV("Database string pool is corrupted.");
		return;
	}
	unsigned int i = --m_rgCacheRefCnt[iString];
	if (!i)
	{
		MsiCacheLink* pLink = &m_rgCacheLink[iString];
		MsiCacheIndex iLink = pLink->iNextLink;
		MsiCacheIndex* pPrev;
		do // walk circular list until previous link found
		{
			if (iLink < 0)  // pass through hash bin
				pPrev = &m_rgHash[iLink & 0x7FFFFFFF];
			else
				pPrev = &m_rgCacheLink[iLink].iNextLink;
			iLink = *pPrev;
			if (iLink == 0)
			{
				AssertSz(0, "Database string pool is corrupted.");
				DEBUGMSGV("Database string pool is corrupted.");
				return;
			}
		} while (iLink !=  iString);
		*pPrev = pLink->iNextLink;

		pLink->piString->Release();
		pLink->piString = 0;
		pLink->iNextLink = MsiCacheIndex(m_iFreeLink);
		m_iFreeLink = iString;
	}
}

const IMsiString& CMsiDatabase::DecodeString(MsiStringId iString)
{
	const IMsiString* piString;
	if (iString == 0
	 || iString >= m_cCacheUsed
	 || (piString = m_rgCacheLink[iString].piString) == 0)
		return g_MsiStringNull;
	piString->AddRef();
	return *piString;
}

const IMsiString& CMsiDatabase::DecodeStringNoRef(MsiStringId iString)
{
	Assert(iString < m_cCacheUsed);
	const IMsiString* piString = m_rgCacheLink[iString].piString;
//	return piString ? *piString : g_MsiStringNull; //!! compiler error, constructs dead IMsiString object
	if (piString)
		return *piString;
	else
		return g_MsiStringNull;
}

MsiStringId CMsiDatabase::EncodeStringSz(const ICHAR* pstr)
{
	if (*pstr == 0)
		return 0;
	int iLen;
	int iHash = HashString((const ICHAR *)pstr, iLen);
	if (iLen == 0)
		return 0;
	return FindString(iLen, iHash, pstr);
}

MsiStringId CMsiDatabase::EncodeString(const IMsiString& riString)
{
	return EncodeStringSz(riString.GetString());
}

//____________________________________________________________________________
//
// CMsiTable external virtual function implementation
//____________________________________________________________________________

HRESULT CMsiTable::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_IMsiTable)
	 || MsGuidEqual(riid, IID_IMsiData))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CMsiTable::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}
	
unsigned long CMsiTable::Release()
{
	ReleaseTrack();
	if (--m_Ref.m_iRefCnt != 0)  // note that refcnt for catalog cancelled when entered
		return m_Ref.m_iRefCnt;
	CMsiDatabase* piDatabase = &m_riDatabase;  // save pointer before destruction
	piDatabase->Block();
	piDatabase->AddRef();  // prevent Services destruction before we're gone
	if (!m_fNonCatalog)  // tables without names are not managed in catalog
	{
		m_Ref.m_iRefCnt = 3;  // prevent recursive destruction during catalog operations
		if (!SaveIfDirty())
		{
			piDatabase->SetTableState(m_iName, ictsSaveError); // mark table catalog
			piDatabase->Unblock();
			piDatabase->Release();
			return m_Ref.m_iRefCnt = 1;   // database now owns this refcnt, may try to save again
		}
		ReleaseData(); // release references before notifying database
		piDatabase->TableReleased(m_iName); // will cause reentry of Release, may release database
	}
	else if(m_ppiPrevTable) // we need to check this since if a table is dropped, it becomes anonymous
	{
		// remove from link
		if (m_piNextTable)
			m_piNextTable->m_ppiPrevTable = m_ppiPrevTable;
		*m_ppiPrevTable = m_piNextTable;
		//!! may be safe to combine ReleaseData in both cases to common place in beginning
		ReleaseData(); // release references before notifying database
	}
	MsiStringId* piName = m_rgiColumnNames;  //!!TEMP dereference column names after Close
	for (int cColumns = m_cColumns; cColumns--; )
		piDatabase->UnbindStringIndex(*piName++);
	// delete before release
	delete this;   // now we can remove ourselves
	piDatabase->Unblock();  // need to do this before releasing the database
	piDatabase->Release();  // now release the database, will destruct if no tables outstanding
	return 0;
}

const IMsiString& CMsiTable::GetMsiStringValue() const
{
	return m_riDatabase.DecodeString(m_iName);
}

int CMsiTable::GetIntegerValue() const
{
	return iMsiNullInteger;
}

#ifdef USE_OBJECT_POOL
unsigned int CMsiTable::GetUniqueId() const
{
	return m_iCacheId;
}

void CMsiTable::SetUniqueId(unsigned int id)
{
	Assert(m_iCacheId == 0);
	m_iCacheId = id;
}
#endif //USE_OBJECT_POOL

int CMsiTable::CreateColumn(int iColumnDef, const IMsiString& istrName)
{
	if ((iColumnDef & icdPersistent) != 0 && istrName.TextSize() == 0)  // persistent columns must be named
		return 0;
	m_riDatabase.Block();
	int iName = m_riDatabase.EncodeStringSz(istrName.GetString());  // OK if name not in string pool yet
	if (iName)
	{
		for (int iCol = m_cColumns; iCol--; )
			if (m_rgiColumnNames[iCol] == (MsiStringId)iName)
				return m_riDatabase.Unblock(), ~iCol;  // duplicate name, return negative of column number
	}
	if (m_cColumns >= cMsiMaxTableColumns
	 || ((iColumnDef & icdPersistent) && m_cColumns >= 31) //!! TEMP FOR 1.0 until our problems w/ 32 columns are sorted out; don't allow more than 31 persistent columns
	 || ((iColumnDef & icdPersistent) && m_cPersist != m_cColumns)
	 || ((iColumnDef & icdPrimaryKey) && m_cPrimaryKey != m_cColumns)
	 || (m_cColumns == 0 && !(iColumnDef & icdPrimaryKey)))  //!! allow this for temp tables?
		return m_riDatabase.Unblock(), 0;
	if (m_rgiData && (m_cColumns + 1) == m_cWidth)
	{  // if array allocated, must widen rows and realloc data if no spares
		int cOldWidth = m_cWidth;
		int cNewWidth = cOldWidth + 1;
		int cNewLength = (cOldWidth * m_cLength) / cNewWidth;
		if (cNewLength >= m_cRows)  // enough room to grow
		{
			m_cLength = cNewLength;
			m_cWidth  = cNewWidth;
		}
		else  // not enough spare room in unused rows, must realloc table
		{
			if (!AllocateData(cNewWidth, m_cLength))
				return m_riDatabase.Unblock(), 0;
		}

		if (m_cRows) //no data to move if there aren't any rows
		{
			MsiTableData* pNewData = m_rgiData + m_cRows * cNewWidth;
			MsiTableData* pOldData = m_rgiData + m_cRows * cOldWidth;
			for(;;) // starts pointing beyond last row
			{
				*(pNewData - 1) = 0;   // null out new field
				pNewData -= cNewWidth;
				pOldData -= cOldWidth;
				if (pNewData == pOldData)
					break;   // no need to move first row
				memmove(pNewData, pOldData, cOldWidth * sizeof(MsiTableData));
			}
		}
	}
	MsiStringId iColumnName = m_riDatabase.BindString(istrName);
	if (iColumnDef & icdPrimaryKey)
		m_cPrimaryKey++;
	if (iColumnDef & icdPersistent)  // put persistent columns into catalog //!!REMOVE THIS TEST, temp columns need to go in catalog
	{
		m_cPersist++;
		if (!m_fNonCatalog)
		{
			IMsiCursor* piColumnCursor = m_riDatabase.GetColumnCursor(); // no ref cnt
			piColumnCursor->PutInteger(cccTable,  m_iName);
			piColumnCursor->PutInteger(cccColumn, m_cPersist);
			piColumnCursor->PutInteger(cccName,   iColumnName);
			piColumnCursor->PutInteger(cccType,   GetUpdateState() == idsWrite ? iColumnDef : (iColumnDef & ~icdPersistent));
			AssertNonZero(piColumnCursor->Insert());
			//!! need to unbind string, columns names not ref counted in table array
			//!! m_riDatabase.UnbindStringIndex(iColumnName); // refcnt held in catalog
			m_fDirty |= (1 << m_cColumns); // do this to make sure the table is saved
													 // to storage even if no data is changed
			piColumnCursor->Reset(); // remove ref counts from cursor
		}
		if (m_cColumns == 0)
			m_riDatabase.SetTableState(m_iName, ictsPermanent);
	}
	else if (m_cColumns == 0)  // now we know its a temporary table
	{
		if (m_idsUpdate == idsRead)   // only temp updates allowed
			m_idsUpdate = idsWrite;    // allow inserts
		// temporary set at table creation, not needed->  m_riDatabase.SetTableState(m_iName, ictsTemporary);
	}
	m_rgiColumnNames[m_cColumns++] = (MsiStringId)iColumnName;
	m_rgiColumnDef[m_cColumns] = MsiColumnDef(iColumnDef);
	m_riDatabase.Unblock();
	return m_cColumns;
}

Bool CMsiTable::CreateRows(unsigned int cRows) // called after all columns defined
{
	if (m_rgiData)
	{
		//!! need to realloc, or do we simply not allow this call
		return fFalse;
	}
	m_riDatabase.Block();
	Bool fRet = AllocateData(0, cRows);
	m_riDatabase.Unblock();
	return fRet;
}

IMsiDatabase& CMsiTable::GetDatabase()
{
	m_riDatabase.AddRef();
	return m_riDatabase;
}	

unsigned int CMsiTable::GetRowCount()
{
	return m_cRows;
}	

unsigned int CMsiTable::GetColumnCount()
{
	return m_cColumns;
}

unsigned int CMsiTable::GetPersistentColumnCount()
{
	return m_cPersist;
}

unsigned int CMsiTable::GetPrimaryKeyCount()
{
	return m_cPrimaryKey;
}

/*OBSOLETE*/Bool CMsiTable::IsReadOnly()
{
	return m_idsUpdate == idsWrite ? fFalse : fTrue;
}

unsigned int CMsiTable::GetColumnIndex(MsiStringId iColumnName)
{

	MsiStringId* piName = m_rgiColumnNames;
	for (unsigned int i = m_cColumns; i--; piName++)
		if (*piName == (MsiStringId)iColumnName)
			return m_cColumns - i;
	return 0;
}

MsiStringId CMsiTable::GetColumnName(unsigned int iColumn)
{
	if (iColumn == 0)
		return m_iName;
	if (--iColumn >= m_cColumns)
		return 0;
	return m_rgiColumnNames[iColumn];
}

int CMsiTable::GetColumnType(unsigned int iColumn)
{
	if (iColumn > m_cColumns)
		return -1;
	return m_rgiColumnDef[iColumn];  // allow 0 for row state access
}

int CMsiTable::LinkTree(unsigned int iParentColumn)
{
	int cRoots = 0;
	if (m_cPrimaryKey != 1 || iParentColumn == 1)
		return -1;

	m_riDatabase.Block();
	MsiTableData* pData = m_rgiData;
	for (int cRows = m_cRows; cRows--; pData += m_cWidth)
		pData[0] &= ~iTreeInfoMask;
	m_iTreeRoot = 0;
	if ((m_iTreeParent = iParentColumn) != 0)
	{
		pData = m_rgiData;
		for (int iRow = 0; ++iRow <= m_cRows ; pData += m_cWidth)
		{
			if ((pData[0] & iTreeInfoMask) == 0)
				switch(LinkParent(iRow, pData))
				{
				case -1: LinkTree(0); m_riDatabase.Unblock(); return -1; // parent unresolved
				case  1: cRoots++;
				};
		}
	}
	m_riDatabase.Unblock();
	return cRoots;
}

IMsiCursor*  CMsiTable::CreateCursor(Bool fTree)
{
	m_riDatabase.Block();
	if (!m_rgiData && !AllocateData(0, 0))
		return m_riDatabase.Unblock(), 0;
	if (fTree == ictTextKeySort) // special case for use with ExportTable()
	{
		int* rgiIndex = IndexByTextKey();
		if (rgiIndex)
		{
			IMsiCursor* piCursor = new CMsiTextKeySortCursor(*this, m_riDatabase, m_cRows, rgiIndex);
			m_riDatabase.Unblock();
			return piCursor;
		}
		fTree = fFalse;
	}
	IMsiCursor* piCursor = new CMsiCursor(*this, m_riDatabase, fTree);
	m_riDatabase.Unblock();
	return piCursor;
}

//____________________________________________________________________________
//
// CMsiTable internal function implementation
//____________________________________________________________________________

CMsiTable::CMsiTable(CMsiDatabase& riDatabase, MsiStringId iName,
						unsigned int cInitRows, unsigned int cAddColumns)
 : m_riDatabase(riDatabase), m_iName(iName),
	m_cInitRows(cInitRows), m_cAddColumns(cAddColumns)
{
	m_idsUpdate = riDatabase.GetUpdateState();
	// m_rgiColumnDef[0] initialized to 0, == icdLong to force simple copy of RowState to cursor

	// if table is a table not in the catalog, add to separate link list
	if(!m_iName || cAddColumns == iNonCatalog)
	{
		m_cAddColumns = 0;
		m_fNonCatalog = fTrue;
		CMsiTable** ppiTableHead = riDatabase.GetNonCatalogTableListHead();
		if ((m_piNextTable = *ppiTableHead) != 0)
			m_piNextTable->m_ppiPrevTable = &m_piNextTable;
		m_ppiPrevTable = ppiTableHead;
		*ppiTableHead = this;
	}
	Debug(m_Ref.m_pobj = this);
} // doesn't keep refcnt on database to avoid deadlock

Bool CMsiTable::SaveToStorage(const IMsiString& riName, IMsiStorage& riStorage)  //!! change to IMsiRecord return
{
	if (m_cRows == 0) // don't write out stream --> no data
	{
		PMsiRecord pError(riStorage.RemoveElement(riName.GetString(), Bool(fFalse | iCatalogStreamFlag)));
		return fTrue;
	}

	Bool fStat = fTrue;
	PMsiStream  pStream(0);
	IMsiRecord* piError = riStorage.OpenStream(riName.GetString(), Bool(fTrue + iCatalogStreamFlag), *&pStream);
	if (piError)
	{
		piError->Release();
		return fFalse;
	}
	int cbStringIndex = m_riDatabase.GetStringIndexSize();
	MsiColumnDef* pColumnDef = m_rgiColumnDef + 1;
	for (int iColumn = 1; iColumn <= m_cPersist; iColumn++, pColumnDef++)
	{
		int cRows = m_cRows;  // multiple loops below for performance gain
		MsiTableData* pData = m_rgiData;
		if (*pColumnDef & icdObject)
		{
			if (*pColumnDef & icdShort) // string
				for (; cRows-- && !(*pData & iRowTemporaryBit); pData += m_cWidth)
					pStream->PutData(&pData[iColumn], cbStringIndex);
			else // stream
				for (; cRows-- && !(*pData & iRowTemporaryBit); pData += m_cWidth)
				{
					MsiTableData iData = pData[iColumn];
					if (iData != 0)
					{
						MsiString istrStream(m_riDatabase.ComputeStreamName(riName, pData + 1, m_rgiColumnDef+1));
						IMsiStream* piInStream;
						if (iData == iPersistentStream)  // persisted MSI stream data
						{
							if (GetInputStorage() == &riStorage)  // writing to the input storage
							{
								pStream->PutInt16((short)iData); // already persisted
								continue;
							}
							if ((piError = GetInputStorage()->OpenStream(istrStream, fFalse, *&piInStream)) != 0)
							{
								piError->Release();
								fStat = fFalse;
								continue;
							}
						}
						else if (iData <= iMaxStreamId) // stream is in transform file
						{
							// iData is a transform id. Find correct trans file.
							IMsiStorage* piStorage = m_riDatabase.GetTransformStorage(iData);
							Assert(piStorage);
							piError = piStorage->OpenStream(istrStream, fFalse, *&piInStream);
							piStorage->Release();
							if (piError)
							{
								piError->Release();
								fStat = fFalse;
								continue;
							}
						}
						else // stream object, memory stream or loaded MSI stream
						{
							IMsiData* piData = (IMsiData*)GetObjectData(iData);
							if (piData->QueryInterface(IID_IMsiStream, (void**)&piInStream) != NOERROR)
							{
								fStat = fFalse;
								continue;
							}
							piData->Release(); // piInStream owns refcnt
							piInStream->Reset(); //!! should clone stream here to save/restore current loc in stream
							
						}
						IMsiStream* piOutStream;
						if ((piError = riStorage.OpenStream(istrStream, fTrue, piOutStream)) != 0)
						{
							// don't release piInStream - will attempt write again at Commit()
							piError->Release();
							fStat = fFalse;
							continue;
						}
						char rgbBuffer[512];
						int cbInput = piInStream->GetIntegerValue();
						while (cbInput)
						{
							int cb = sizeof(rgbBuffer);
							if (cb > cbInput)
								cb = cbInput;
							piInStream->GetData(rgbBuffer, cb);
							piOutStream->PutData(rgbBuffer, cb);
							cbInput -= cb;
						}
						if (piInStream->Error() || piOutStream->Error())
						{
							// don't release piInStream - will attempt write again at Commit()
							piOutStream->Release();
							fStat = fFalse; // continue to process remaining data
							continue;
						}
						// stream successfully written
						piInStream->Release();
						piOutStream->Release();
						pData[iColumn] = iData = iPersistentStream;
					}
					pStream->PutInt16((short)iData);
				}
		}
		else
		{
			if (*pColumnDef & icdShort) // short integer
				for (; cRows-- && !(*pData & iRowTemporaryBit); pData += m_cWidth)
				{
					int i;
					if ((i = pData[iColumn]) != 0)  // if not null
						i ^= 0x8000;    // translate offset
					pStream->PutInt16((short)i);
				}
			else // long integer
				for (; cRows-- && !(*pData & iRowTemporaryBit); pData += m_cWidth)
					pStream->PutInt32(pData[iColumn]);
		}
	}
	if (pStream->Error())
		fStat = fFalse;  // mark not dirty even if failure to prevent retry at persist
	m_fDirty = 0;
	m_riDatabase.SetTableState(m_iName, ictsNoTransform); // transform permanently applied
	if (m_riDatabase.GetStringIndexSize() == 3)
		m_riDatabase.SetTableState(m_iName, ictsStringPoolClear); // indexes are now at 3 bytes
	m_pinrStorage = &riStorage;  // update storage to prevent needless write on release
	return fStat;
}

Bool CMsiTable::SaveToSummaryInfo(IMsiStorage& riStorage)  // used only for IMsiDatabase::Import
{
	PMsiSummaryInfo pSummary(0);
	IMsiRecord* piError = riStorage.CreateSummaryInfo(32, *&pSummary);
	if (piError)
		return piError->Release(), fFalse;
	MsiString istrValue;
	MsiTableData* pData = m_rgiData;
	for (int cRows = m_cRows;  cRows--; pData += m_cWidth)
	{
		int iPID = pData[1] - iIntegerDataOffset;
		istrValue = m_riDatabase.DecodeString(pData[2]);
		int iValue = istrValue;
		if (iValue != iMsiStringBadInteger)
		{
			pSummary->SetIntegerProperty(iPID, iValue);
		}
		else // date or string
		{
			int rgiDate[6] = {0,0,0,0,0,0};
			int iDateField = -1; // flag to indicate empty
			int cDateField = 0;
			const ICHAR* pch = istrValue;
			int ch;
			while (cDateField < 6)
			{
				ch = *pch++;
				if (ch == rgcgDateDelim[cDateField])
				{
					rgiDate[cDateField++] = iDateField;
					iDateField = -1;  // reinitialize
				}
				else if (ch >= '0' && ch <= '9')
				{
					ch -= '0';
					if (iDateField < 0)
						iDateField = ch;
					else
					{
						iDateField = iDateField * 10 + ch;
						if (iDateField > rgiMaxDateField[cDateField])
							cDateField = 7;  // field overflow, quiet
					}
				}
				else if (ch == 0 && iDateField >= 0) // less than 6 fields
				{
					rgiDate[cDateField++] = iDateField;
					break;  // all done, successful
				}
				else
					cDateField = 99; // error, not a date
			}
			if (cDateField == 3 || cDateField == 6) // actual date found
			{
				//!! check if date format error (!= 99)
				MsiDate iDateTime = MsiDate(((((((((((rgiDate[0] - 1980) << 4)
																+ rgiDate[1]) << 5)
																+ rgiDate[2]) << 5)
																+ rgiDate[3]) << 6)
																+ rgiDate[4]) << 5)
																+ rgiDate[5] / 2);
				pSummary->SetTimeProperty(iPID, iDateTime);
			}
			else // string data
				pSummary->SetStringProperty(iPID, *istrValue);
		}
	}
	return pSummary->WritePropertyStream();
}

Bool CMsiTable::RemovePersistentStreams(MsiStringId iName, IMsiStorage& riStorage)
{
//	if (m_pinrStorage != &riStorage)
//		return fTrue;  // stream not present in output database
	MsiColumnDef* pColumnDef = m_rgiColumnDef + 1;
	int iColumn = -1;
	do
	{
		if (++iColumn >= m_cColumns)
			return fTrue;  // table has no persisten streams
	} while ((*pColumnDef++ & (icdObject|icdPersistent|icdShort))
								  != (icdObject|icdPersistent));
	int cErrors = 0;
	MsiTableData* pData = m_rgiData + 1;
	for (int cRows = m_cRows; cRows--; pData += m_cWidth)
	{
		// Transformed streams can be ignored -- they can't have been saved to
		// storage. If they were, they'd turn into iPersistentStreams.
		if (pData[iColumn] != iPersistentStream)
			continue;
		MsiString istrStream(m_riDatabase.ComputeStreamName(m_riDatabase.DecodeStringNoRef(iName),
																			pData, m_rgiColumnDef+1));
		IMsiRecord* piError = riStorage.RemoveElement(istrStream, m_fStorages);
		if (piError)
		{
		//!! OK if doesn't exist?
			piError->Release();
			cErrors++;
		}
		pData[iColumn] = 0;
	}
	return cErrors ? fFalse : fTrue;
}

// Called from Commit() prior to saving string table to remove ref counts for non-persistent strings

void CMsiTable::DerefStrings()
{
	MsiColumnDef* pColumnDef = m_rgiColumnDef;
	for (int iColumn = 1; pColumnDef++, iColumn <= m_cColumns; iColumn++)
	{
		m_riDatabase.DerefTemporaryString(m_rgiColumnNames[iColumn-1]); //!!TEMP until columns names not ref counted
		if ((*pColumnDef & (icdObject|icdShort)) != (icdObject|icdShort))
			continue;
		MsiTableData* pData = m_rgiData;
		if (iColumn > m_cPersist)  // all temporary column data is non-persistent
			for (int cRows = m_cRows; cRows--; pData += m_cWidth)
				m_riDatabase.DerefTemporaryString(pData[iColumn]);
		else
			for (int cRows = m_cRows; cRows--; pData += m_cWidth)
				if ((pData[0] & iRowTemporaryBit) != 0)
					m_riDatabase.DerefTemporaryString(pData[iColumn]);
	}
	if (m_piCursors)
		m_piCursors->DerefStrings();  // notify all cursors
}

Bool CMsiTable::SaveIfDirty()
{
//	Assert(m_piCursors == 0);
	IMsiStorage* piStorage = m_riDatabase.GetOutputStorage(); // no AddRef done
	if (!piStorage)  // no output storage
		return fTrue;
	int cbStringIndex = m_riDatabase.GetStringIndexSize();
	if (m_cPersist && m_riDatabase.GetUpdateState() == idsWrite)  // if not temporary table
	{
		if (piStorage != m_pinrStorage || (m_fDirty & ((1 << m_cPersist)-1))
			|| m_riDatabase.GetTableState(m_iName, ictsStringPoolSet)) // if output storage, any persistent columns dirty, or string pool bumped
		{
			if (!SaveToStorage(m_riDatabase.DecodeStringNoRef(m_iName), *piStorage))
				return fFalse;
		}
		else // persistent data unchanged, or no writable output
		{
		}
	}
	return fTrue;
}

Bool CMsiTable::ReleaseData()
{
	MsiColumnDef* pColumnDef = m_rgiColumnDef;
	int cPersistData = 0;
//	if (m_riDatabase.GetCurrentStorage())
		cPersistData = m_cPersist;
	Bool fCountedTemp = fFalse;
	int cTempRows = 0;
	for (int iColumn = 1; pColumnDef++, iColumn <= m_cColumns; iColumn++)
	{
		if ((*pColumnDef & icdObject) == 0)
			continue;
		MsiTableData* pData = m_rgiData;
		int cRows = m_cRows;
		if (iColumn <= cPersistData)
		{
			if (*pColumnDef & icdShort) // string
			{
				if (fCountedTemp && cTempRows == 0)
					continue;
				for (; cRows--; pData += m_cWidth)
					if (pData[0] & iRowTemporaryBit)
					{
						m_riDatabase.UnbindStringIndex(pData[iColumn]);
						if (!fCountedTemp)
							cTempRows++;
					}
				fCountedTemp = fTrue;
			}
			else
			{

				for (; cRows--; pData += m_cWidth)
				{
					MsiTableData iData = pData[iColumn];
					ReleaseObjectData(iData);
				}
			}
		}
		else
		{
			if (*pColumnDef & icdShort) // string
			{
				for (pData += iColumn; cRows--; pData += m_cWidth)
					m_riDatabase.UnbindStringIndex(*pData);
			}
			else
			{

				for (pData += iColumn; cRows--; pData += m_cWidth)
					ReleaseObjectData(*pData);
			}
		}
	}
	return fTrue;
}

void CMsiTable::TableDropped()
{
	m_iName = 0;    // table is anonymous in case external references still remain
	m_fNonCatalog = fTrue;
	if (m_piCursors)
		m_piCursors->RowDeleted(0, 0);  // notify all cursors to Reset
	MsiStringId* piName = m_rgiColumnNames;  //!!TEMP dereference column names after Close
	for (int cColumns = m_cColumns; cColumns--; )
		m_riDatabase.UnbindStringIndex(*piName++);
	m_cPersist = 0;  // force all data to be released
	//!! can we let this ReleaseData happen in CMsiTable::Release ?
	ReleaseData();   // remove all string and object references
	if (m_hData != 0)
	{
		GlobalUnlock(m_hData);
		GlobalFree(m_hData);
		m_hData = 0;
	}
	m_rgiData = 0;
	m_cRows = m_cColumns = 0;
	SetReadOnly();  // prevent further updates
}

CMsiTable::~CMsiTable()
{
	RemoveObjectData(m_iCacheId);
	if (m_hData != 0)
	{
		GlobalUnlock(m_hData);
		GlobalFree(m_hData);
		m_hData = 0;
	}
}

// Load CMsiTable data array from storage

Bool CMsiTable::LoadFromStorage(const IMsiString& riName, IMsiStorage& riStorage, int cbFileWidth, int cbStringIndex)
{
	m_pinrStorage = &riStorage;  // save, non-ref counted, for comparison with output
	PMsiStream  pStream(0);
	IMsiRecord* piError = riStorage.OpenStream(riName.GetString(), Bool(fFalse + iCatalogStreamFlag), *&pStream);
	if (piError)
	{
		int iError = piError->GetInteger(1);
		piError->Release();
		return (iError == idbgStgStreamMissing) ? fTrue : fFalse;
	}
	Assert(cbFileWidth);
	m_cRows = pStream->GetIntegerValue()/cbFileWidth;
	if (m_cRows > m_cInitRows)
		m_cInitRows = m_cRows;
	if (!AllocateData(0, 0))
		return fFalse;
	MsiColumnDef* pColumnDef = m_rgiColumnDef;
	for (int iColumn = 1; pColumnDef++, iColumn <= m_cPersist; iColumn++)
	{
		if (iColumn <= m_cLoadColumns)
		{
				int cRows = m_cRows;
			MsiTableData* pData = &m_rgiData[iColumn];
			if (*pColumnDef & icdObject) // string or stream(as Bool)
			{
				if (*pColumnDef & icdShort) // string index
					for (; cRows--; pData += m_cWidth)
					{
						*pData = 0;   // to clear high-order bits
						pStream->GetData(pData, cbStringIndex);
					}
				else // stream flag
					for (; cRows--; pData += m_cWidth)
						*pData = pStream->GetInt16();
			}
			else
			{
				if (*pColumnDef & icdShort) // short integer
					for (; cRows--; pData += m_cWidth)
					{
						int i;
						if ((i = (int)(unsigned short)pStream->GetInt16()) != 0)
							i += 0x7FFF8000L;  // translate offset if not null
						*pData = i;
					}
				else // long integer
					for (; cRows--; pData += m_cWidth)
						*pData = pStream->GetInt32();
			}
			if (pStream->Error())
				return fFalse;
		}
		else
			FillColumn(iColumn, 0);
	}
	FillColumn(0, 0); //!! set TableState into column 0
	return fTrue;
}

int CMsiTable::CreateColumnsFromCatalog(MsiStringId iName, int cbStringIndex)
{
	IMsiCursor* piColumnCursor = m_riDatabase.GetColumnCursor(); // no ref cnt
	piColumnCursor->Reset();
	piColumnCursor->SetFilter(cccTable);
	piColumnCursor->PutInteger(cccTable, iName);
	int cbFileWidth = 0;
	while (piColumnCursor->Next())
	{
		int iColType = piColumnCursor->GetInteger(cccType);
		if (iColType & icdPrimaryKey)
			m_cPrimaryKey++;
		if (iColType & icdPersistent)
		{
			m_cLoadColumns++;
			cbFileWidth += (iColType & icdShort) ? ((iColType & icdObject) ? cbStringIndex : 2)
															 : ((iColType & icdObject) ? 2 : 4);
		}
		else
		{
			iColType |= icdPersistent;
			if (GetUpdateState() == idsWrite)
			{
				piColumnCursor->PutInteger(cccType, iColType);
				AssertNonZero(piColumnCursor->Update() == fTrue);
			}  // else leave as temporary to produce proper file width on subsequent load
		}
//		if (!m_fNonCatalog) // no column names if system or transfer table
//		{
			int iName = piColumnCursor->GetInteger(cccName);
			m_rgiColumnNames[m_cColumns] = (MsiStringId)iName;
			m_riDatabase.BindStringIndex(iName);
//		}
		m_rgiColumnDef[++m_cColumns] = (MsiColumnDef)iColType;
		Assert(piColumnCursor->GetInteger(cccColumn) == m_cColumns);
	}
	m_cPersist = m_cColumns;
	return cbFileWidth;
}

Bool CMsiTable::AllocateData(int cWidth, int cLength)
{
	HGLOBAL hData;
	if (m_rgiData)
	{
		Assert(cWidth  >= m_cWidth);
		Assert(cLength >= m_cLength);
		GlobalUnlock(m_hData);
		while((hData = GlobalReAlloc(m_hData, cLength * cWidth * sizeof(MsiTableData),
									 GMEM_MOVEABLE)) == NULL)
			HandleOutOfMemory();
	}
	else
	{
		if (!cWidth)
			cWidth = m_cColumns + m_cAddColumns + 1;
		if (!cLength)
			cLength = m_cInitRows ? m_cInitRows : cRowCountDefault;
		if (!cWidth)
			return fFalse;
		m_cInitRows = cLength;
		while((hData = GlobalAlloc(GMEM_MOVEABLE, cLength * cWidth*sizeof(MsiTableData))) == NULL)
			HandleOutOfMemory();
	}
	m_hData = hData;
	m_cLength = cLength;
	m_cWidth = cWidth;
	m_rgiData = (MsiTableData*)GlobalLock(m_hData);
	Assert(m_rgiData);   // should never fail, if so we've lost our data
	return (m_rgiData != 0 ? fTrue : fFalse);
}

Bool CMsiTable::FillColumn(unsigned int iColumn, MsiTableData iData)
{
	if (iColumn >= m_cWidth || !m_rgiData) // can fill unused columns
		return fFalse;
	MsiTableData* pData = m_rgiData + iColumn;
	for (int cRows = m_cRows; cRows--; pData += m_cWidth)
		*pData = iData;
	return fTrue;
}

int CMsiTable::LinkParent(int iChildRow, MsiTableData* rgiChild)
{  // assumes that iTreeInfoMask are zero on entry, except for recursion check
	MsiTableData* pData = m_rgiData;
	int iParent = rgiChild[m_iTreeParent];
	if (iParent == 0 || iParent == rgiChild[1]) // root node
	{
		rgiChild[0] |= m_iTreeRoot + (1 << iTreeLinkBits); // root is level 1
		m_iTreeRoot = iChildRow;
		return 1;   // indicate a new root found
	}
	int cRows = m_cRows;
	for (int iRow = 0; ++iRow <= cRows; pData += m_cWidth)
	{
		if (pData[1] == iParent)  // parent row found
		{
			int iStat = 0; // initialize to no new root
			if ((pData[0] & iTreeLinkMask) == iTreeLinkMask)  // caught recursion check
				iStat = -1;  // circular reference
			else if ((pData[0] & iTreeInfoMask) == 0)  // parent unresolved
			{
				rgiChild[0] |= iTreeLinkMask;   // flag link to prevent infinite recursion
				iStat = LinkParent(iRow, pData);
			}
			if (iStat != -1)  // check for missing parent
			{
				rgiChild[0] &= ~iTreeInfoMask;  // preserve row flags
				rgiChild[0] |= (pData[0] & iTreeInfoMask) + (1 << iTreeLinkBits);  // child level is one more
				pData[0] = (pData[0] & ~iTreeLinkMask) | iChildRow;
			}
			return iStat;
		}
	}
	return -1; // parent missing
}

// FindFirstKey - quick search for matching key
//   iKeyData is value to match exactly
//   iRowLower is the highest row to exclude, 1-based, 0 to search all
//   iRowCurrent is the initial guess on input, 1-based, returns matched row on output
//   If key is found the pointer to the row data is returned [0]=row attributes
//   If key is not matched, iRowCurrent is set to the insert location
MsiTableData* CMsiTable::FindFirstKey(MsiTableData iKeyData, int iRowLower, int& iRowCurrent)
{
	if (m_cRows == 0)
		return (iRowCurrent = 1, 0);
	iRowLower--;                 // lowest excluded row, 0-based
	int iRowUpper = m_cRows;     // highest excluded row, 0-based
	int iRowOffset;
	int iRow = iRowCurrent - 1;  // iRow is 0-based in this function, unlike arg
	if ((unsigned int)iRow >= iRowUpper)
		iRow = iRowUpper - 1;     // cursor reset, position at end in case sorted insert
	MsiTableData* pTableBase = m_rgiData + 1;  // skip over row attributes
	MsiTableData* pTable = pTableBase + iRow * m_cWidth;
	while (*pTable != iKeyData)  // check if already positioned at first key column
	{
		if (*pTable < iKeyData) // positioned before matching row
		{
			if ((iRowOffset = (iRowUpper - iRow)/2) == 0) // no intervening rows
			{
				iRow++;  // separate to allow common return code to merge
				return (iRowCurrent = iRow + 1, 0);
			}
			iRowLower = iRow;
			iRow += iRowOffset;
		}
		else                  // positioned after matching row
		{
			if ((iRowOffset = (iRow - iRowLower)/2) == 0) // no intervening rows
				return (iRowCurrent = iRow + 1, 0);
			iRowUpper = iRow;
			iRow = iRowLower + iRowOffset;
		}
		pTable = pTableBase + iRow * m_cWidth;
	}
	return (iRowCurrent = iRow + 1, pTable - 1);
}

// FindNextRow - advance cursor to next row matching filter
// private used by CMsiCursor::Next

Bool CMsiTable::FindNextRow(int& iRow, MsiTableData* pData, MsiColumnMask fFilter, Bool fTree)
{
	fFilter &= ((unsigned int)-1 >> (32 - m_cColumns)); // ignore filter bits beyond column count

	if (fTree && m_iTreeParent && !(iRow == 0 && fFilter & 1))
	{
		int iNextNode = iRow ? m_rgiData[(iRow - 1) * m_cWidth] & iTreeLinkMask : m_iTreeRoot;
		while ((iRow = iNextNode) != 0)
		{
			if (fFilter == 0)
				return fTrue;
			MsiTableData* pRow = &m_rgiData[(iRow - 1) * m_cWidth];
			iNextNode = *pRow & iTreeLinkMask;
			MsiTableData* pCursor = pData;
			for (MsiColumnMask fMask = fFilter;  pCursor++, pRow++, fMask;  fMask >>=1)
				if ((fMask & 1) && *pCursor != *pRow)
					break;
			if (fMask == 0)
				return fTrue;
		}
		return fFalse;
	}

	if (iRow >= m_cRows)
		return (iRow = 0, fFalse);

	if (fFilter == 0)  // no filter columns
		return (iRow++, fTrue);
	MsiTableData* pRow;
	int iNextRow = iRow;  // initialize to just before first row to search
	if (fFilter & 1)   // first primary key column in filter, optimize search
	{
		iNextRow++;     // first possible row
		pRow = FindFirstKey(pData[1], iRow, iNextRow);  // updates iNextRow
		if (!pRow)
			return (iRow = 0, fFalse);
		if (fFilter == 1 && m_cPrimaryKey == 1) // quick exit if single key lookup
			return (iRow = iNextRow, fTrue);
		while (--iNextRow > iRow && pRow[1 - m_cWidth] == pData[1])
			pRow -= m_cWidth;  // backup to start of multiple key group
	}  // iNextRow low by 1 after this loop, fixed below by preincrement
	else
		pRow = m_rgiData + iRow * m_cWidth; // first row to check (iRow + 1)
	for ( ; ++iNextRow <= m_cRows; pRow += m_cWidth)
	{
		MsiTableData* pCursor = pData;
		MsiTableData* pTable  = pRow;
		for (MsiColumnMask fMask = fFilter; pCursor++, pTable++, fMask; fMask >>=1)
			if ((fMask & 1) && *pCursor != *pTable)
				break;
		if (fMask == 0)
			return (iRow = iNextRow, fTrue);
	}
	return (iRow = 0, fFalse);
}

// Copies data from requested table row into cursor data buffer
// Returns tree level, or 1 if not tree-linked
// Does not fail, row validity check on previous Find.. call

int CMsiTable::FetchRow(int iRow, MsiTableData* pData)
{
	Assert(unsigned(iRow-1) < m_cRows);
	MsiTableData* pRow = m_rgiData + (iRow-1) * m_cWidth; // points to row status word
	int iLevel = 1;  // default level if not tree-linked
	if (m_iTreeParent)
		iLevel = (pRow[0] >> iTreeLinkBits) & iTreeLevelMask;
	MsiColumnDef* pColumnDef = m_rgiColumnDef;
	for (int cCol = m_cColumns; cCol-- >= 0; pColumnDef++, pData++, pRow++)
	{
		if (*pData != *pRow)  // optimize in case data is identical
		{
			if (*pColumnDef & icdObject)
			{
				if (*pColumnDef & icdShort) // string index
				{
					m_riDatabase.UnbindStringIndex(*pData);
					m_riDatabase.BindStringIndex(*pData = *pRow);
				}
				else  // object pointer
				{
					ReleaseObjectData(*pData);
					if ((*pData = *pRow) != 0 && *pData > iMaxStreamId)
						AddRefObjectData(*pData);
				}
			}
			else  // integer
			{
				*pData = *pRow;
			}
		}
	}
	return iLevel;
}

// FindKey - local function used by Update, Delete, Assign methods
// to validate row position before modification of data.
// Returns fTrue if key found, else positioned just before insert point if not found.
// The supplied row is the current position, which may be 0 if reset. This row
// position is used only as a hint for faster access. The actual row is
// determined by the primary key and the reference argument will be updated.

Bool CMsiTable::FindKey(int& iCursorRow, MsiTableData* pData)
{
	Assert(iCursorRow <= m_cRows);
	if (m_cRows == 0)
		return (iCursorRow = 1, fFalse);
	MsiTableData* pTable = FindFirstKey(pData[1], 0, iCursorRow);
	if (!pTable)
		return fFalse;
	int iScan = 0; // + if scanning forward, - if scanning backwards
	int iCol = 2;  // start at 2nd column 1st time as we matched above
	while (iCol <= m_cPrimaryKey) // test all key values
	{
		if (pTable[iCol] < pData[iCol])   // positioned before matching row
		{
			if (iCursorRow++ == m_cRows || iScan < 0)
				return fFalse;
			pTable += m_cWidth; // check next row
			iScan++;            // indicate scanning downwards
			iCol = 1;           // restart compare with new row
		}
		else if (pTable[iCol] > pData[iCol]) // positioned after matching row
		{
			if (iCursorRow == 1 || iScan > 0)
				return fFalse;
			iCursorRow--;
			pTable -= m_cWidth;  // check previous row
			iScan--;             // indicate scanning upwards
			iCol = 1;            // restart compare with new row
		}
		else
			iCol++;  // this column matches, check if more key columns
	} // > 1 primary key
	return fTrue;
}
	
Bool CMsiTable::ReplaceRow(int& iRow, MsiTableData* pData)
{
	Assert(unsigned(iRow-1) < m_cRows);
	MsiTableData* pRow = m_rgiData + (iRow-1) * m_cWidth;
	if (m_iTreeParent && pRow[m_iTreeParent] != pData[m_iTreeParent])
		return fFalse;  // cannot update parent column if tree-linked
	MsiColumnDef* pColumnDef = m_rgiColumnDef + 1;  // skip RowStatus
	int iMask = 1;
	pRow[0] &= ~(iRowSettableBits | iRowMergeFailedBit);
	pRow[0] |= (pData[0] & iRowSettableBits) + iRowModifiedBit;
	for (int cCol = m_cColumns; pData++, pRow++, cCol--; pColumnDef++, iMask <<= 1)
	{
		MsiTableData iData = *pData;
		if (iData == *pRow)  // optimize in case data is identical
			continue;
		m_fDirty |= iMask;  // mark table column as changed
		if (*pColumnDef & icdObject)
		{
			if (*pColumnDef & icdShort) // string index
			{
				m_riDatabase.UnbindStringIndex(*pRow);
				m_riDatabase.BindStringIndex(*pRow = iData);
			}
			else  // object pointer
			{
				ReleaseObjectData(*pRow);
				if ((*pRow = iData) != 0 && *pRow > iMaxStreamId)
					AddRefObjectData(iData);
			}
		}
		else  // integer
		{
			*pRow = iData;
		}
	}
	return fTrue;
}

Bool CMsiTable::InsertRow(int& iRow, MsiTableData* pData)
{
	Assert(unsigned(iRow-1) <= m_cRows);
	if (m_cRows == m_cLength)
	{
		int cGrowPrev = (m_cLength - m_cInitRows)/2;
		int cGrow = m_cLength / 4;
		if (cGrowPrev > cGrow)
			cGrow = cGrowPrev;
		if (cGrow < cRowCountGrowMin)
			cGrow = cRowCountGrowMin;
		if (!AllocateData(m_cWidth, m_cLength + cGrow))
			return fFalse;
	}
	MsiTableData* pRow = m_rgiData + (iRow-1) * m_cWidth; // insert location
	int cbRow = m_cWidth * sizeof(MsiTableData);
	int cbMove = (++m_cRows - iRow) * cbRow;
	if (cbMove != 0)
	{
		if (m_piCursors)  // notify all cursors if row not added at end
		{
			m_piCursors->RowInserted(iRow--);// prevent increment of this cursor
			iRow++;
		}
		if (m_iTreeParent)
		{
			if (m_iTreeRoot >= iRow)
				m_iTreeRoot++;
			MsiTableData* pTable = m_rgiData;
			for (int cRows = m_cRows; cRows--; pTable += m_cWidth)
				if ((pTable[0] & iTreeLinkMask) >= iRow)
					pTable[0]++;
		}
		memmove((char*)pRow + cbRow, pRow, cbMove);
	}
	memset(pRow, 0, cbRow);
	MsiColumnDef* pColumnDef = m_rgiColumnDef + 1;
	MsiTableData* pTable = pRow; //!! check temp.flag here
	pRow[0] = (pData[0] & iRowSettableBits) + iRowInsertedBit;
	for (int cCol = m_cColumns; pData++, pTable++, cCol--; pColumnDef++)
	{
		MsiTableData iData = *pTable = *pData;
		if (iData == 0)
			continue;
		if (*pColumnDef & icdObject)
		{
			if (*pColumnDef & icdShort) // string index
				m_riDatabase.BindStringIndex(iData);
			else  // object pointer
				AddRefObjectData(iData);
		}
	}
	if (m_iTreeParent)
	{
		if (LinkParent(iRow, pRow) == -1)
		{
			int fDirty = m_fDirty;    // save current state
			m_fDirty = ~(MsiColumnMask)0; // preserve cursor data
			DeleteRow(iRow);
			m_fDirty = fDirty;
			return fFalse;
		}
	}
	m_fDirty = ~(MsiColumnMask)0;  // mark all columns as changed
	return fTrue;
}

// Checks for exact match of cursor with table data, excluding temporary columns
// Sets or clears the row attribute: iraMergeFailed

Bool CMsiTable::MatchRow(int& iRow, MsiTableData* pData)
{
	Assert(iRow-1 < unsigned(m_cRows));
	MsiTableData* pRow = m_rgiData + (iRow-1) * m_cWidth;
	for (int iCol = m_cPrimaryKey; ++iCol <= m_cPersist; )
	{
		if (pRow[iCol] != pData[iCol])
		{
			if ((pData[iCol] != 0) && (pRow[iCol] != 0) &&
				((m_rgiColumnDef[iCol] & (icdObject + icdShort + icdPersistent))
								== (icdObject + icdPersistent)))
			{
				PMsiStream pTableStream(0);
				if (pRow[iCol] == iPersistentStream)
				{
					// load stream
					MsiString istrStream
						(m_riDatabase.ComputeStreamName(m_riDatabase.DecodeStringNoRef(m_iName),
										 pRow + 1, m_rgiColumnDef + 1));
					IMsiStorage* piStorage = GetInputStorage();
					IMsiRecord* piError = piStorage->OpenStream(istrStream, fFalse,
																*&pTableStream);
					if (piError)
					{
						piError->Release();
					}
				}
				else
				{
					pTableStream = (IMsiStream*)GetObjectData(pRow[iCol]);
					pTableStream->AddRef();
				}
				IMsiStream* piDataStream = (IMsiStream*)GetObjectData(pData[iCol]);

				Assert(pTableStream);
				Assert(piDataStream);

				// compare the streams
				int cbRemaining;
				if (((cbRemaining = pTableStream->GetIntegerValue())) == piDataStream->GetIntegerValue())
				{
					char rgchTableStreamBuf[1024];
					char rgchDataStreamBuf[1024];

					int cbRead = sizeof(rgchTableStreamBuf);

					do
					{
						if (cbRemaining < cbRead)
							cbRead = cbRemaining;
						pTableStream->GetData(rgchTableStreamBuf, cbRead);
						piDataStream->GetData(rgchDataStreamBuf, cbRead);
						if (memcmp(rgchTableStreamBuf, rgchDataStreamBuf,
												cbRead) != 0)
							break;
						cbRemaining -= cbRead;
					}
					while (cbRemaining);

					Assert(!pTableStream->Error());
					Assert(!piDataStream->Error());

					// reset streams
					pTableStream->Reset();
					piDataStream->Reset();

					if (cbRemaining == 0)
					{
						pRow[0] &= ~iRowMergeFailedBit;
						return fTrue;
					}
				}
			}
			pRow[0] |= iRowMergeFailedBit;
			return fFalse;
		}
	}
	pRow[0] &= ~iRowMergeFailedBit;
	return fTrue;
}

Bool CMsiTable::DeleteRow(int iRow)
{
	Assert(iRow-1 < unsigned(m_cRows));
	MsiTableData* pRow = m_rgiData + (iRow-1) * m_cWidth; // delete location
	unsigned int iPrevNode = 0;  // initialize to cursor reset position
	if (m_iTreeParent)  // validate that tree node has no children
	{
		int iNextNode = pRow[0] & iTreeLinkMask;
		if (iNextNode != 0
			 && ((m_rgiData + (iNextNode-1) * m_cWidth)[0] & (iTreeLevelMask<<iTreeLinkBits))
															> (pRow[0] & (iTreeLevelMask<<iTreeLinkBits)))
			return fFalse;  // error if node has children
		
		if (iNextNode > iRow)
			iNextNode--;
		if (m_iTreeRoot > iRow)
			m_iTreeRoot--;
		else if (m_iTreeRoot == iRow)
			m_iTreeRoot = iNextNode;
			
		MsiTableData* pTable = m_rgiData;
		for (int cRows = m_cRows; cRows--; pTable += m_cWidth)
		{
			int iNext = pTable[0] & iTreeLinkMask;
			if (iNext > iRow)
				pTable[0]--;
			else if (iNext == iRow)
			{
				pTable[0] += iNextNode - iNext;  // splice out current node
				iPrevNode = m_cRows - cRows;  // row to set in tree cursors
				if (iPrevNode > iRow)
					iPrevNode--;     // adjust for deleted row
			}
		}  // could also have walked the tree list, better?
	}
	else
		iPrevNode = iRow - 1;  // in case not tree-linked
	if (m_piCursors)
		m_piCursors->RowDeleted(iRow, iPrevNode);  // notify all cursors
	m_fDirty = ~(MsiColumnMask)0;  // mark all columns as changed

	MsiColumnDef* pColumnDef = m_rgiColumnDef + m_cColumns;
	MsiTableData* pData = pRow + m_cColumns;  // last data field
	// must go backwards to avoid dereferencing string columns need for stream name
	for (; pData > pRow; pData--, pColumnDef--)
	{
		if (*pData != 0)
		{	
			if (*pColumnDef & icdObject)
			{
				if (*pColumnDef & icdShort)
				{
					m_riDatabase.UnbindStringIndex(*pData);
				}
				else if (*pData == iPersistentStream)
				{
						MsiString istrStream(m_riDatabase.ComputeStreamName(m_riDatabase.
								DecodeStringNoRef(m_iName), pRow+1, m_rgiColumnDef+1));
						IMsiStorage* piStorage = m_riDatabase.GetOutputStorage();
						if (piStorage && piStorage == m_pinrStorage) // if present in output database
						{
							PMsiRecord pError = piStorage->RemoveElement(istrStream, m_fStorages);
							if (pError && pError->GetInteger(1) != idbgStgStreamMissing) // could be missing due to Replace
								return fFalse;
						}
				}
				else if (*pData <= iMaxStreamId)
				{
					// Transformed streams can be ignored -- they can't have been saved to
					// storage. If they were, they'd turn into iPersistentStreams.
					continue;	
				}
				else
					ReleaseObjectData(*pData);
			}
		}
	}
	int cbRow = m_cWidth * sizeof(MsiTableData);
	int cbMove = (m_cRows-- - iRow) * cbRow;
	if (cbMove != 0)
		memmove(pRow, (char*)pRow + cbRow, cbMove);
	return fTrue;
}

int* CMsiTable::IndexByTextKey()
{
	int cIndex = m_cRows;
	int cKeys = m_cPrimaryKey;
	int iKey, cTextKey;
	MsiTableData* pDataBase = m_rgiData + 1;
	int cRowWidth = m_cWidth;
	const ICHAR* rgszIndex[cMsiMaxTableColumns];
	for (cTextKey = 0; cTextKey < cKeys && (m_rgiColumnDef[cTextKey+1] & icdObject); cTextKey++)
		;
	if (!cTextKey)
		return 0;  // integer keys already sorted
	int* rgiIndex = new int[cIndex];
	if ( ! rgiIndex )
		return 0;
	int iIndex, iBefore;  // indexes into rgiIndex, 0-based
	MsiTableData* pDataIndex = pDataBase;
	for (iIndex = 0; iIndex < cIndex; iIndex++, pDataIndex += cRowWidth) // major index walk
	{
		for (iKey = 0; iKey < cTextKey; iKey++) // set compare string values
			rgszIndex[iKey] = m_riDatabase.DecodeStringNoRef(pDataIndex[iKey]).GetString();

		MsiTableData* pData = NULL;
		int iRowBefore = 0;
		for (iKey = 0, iBefore = iIndex; iBefore; ) // bubble up loop
		{
			if (iKey == 0)
			{
				iRowBefore = rgiIndex[iBefore-1];
				pData = pDataBase + (iRowBefore - 1) * cRowWidth;
			}
			const ICHAR* szBefore = m_riDatabase.DecodeStringNoRef(pData[iKey]).GetString();
			int iComp = IStrComp(szBefore, rgszIndex[iKey]);
			if (iComp < 0) // szBefore < szIndex, we're done
				break;
			if (iComp == 0) // match, must check other keys
			{
				if (++iKey >= cTextKey)
					break;   // numeric keys already ordered
				continue;
			}
			rgiIndex[iBefore--] = iRowBefore;
			iKey = 0;
		}
		rgiIndex[iBefore] = iIndex + 1; // row number for newly-placed key
	}
	return rgiIndex;  // caller must free array
}

bool CMsiTable::HideStrings()
{
	bool fHidden = false;
	MsiColumnDef* pColumnDef = m_rgiColumnDef + 1;
	for (int cCol = m_cPersist; cCol--; pColumnDef++)
		if ((*pColumnDef & (icdShort | icdObject)) == (icdShort | icdObject))
		{
			*pColumnDef &= ~(icdShort | icdObject);
			*pColumnDef |= icdInternalFlag;
			fHidden = true;
		}
	return fHidden;
}

bool CMsiTable::UnhideStrings()
{
	MsiColumnDef* pColumnDef = m_rgiColumnDef + 1;
	for (int cCol = m_cPersist; cCol--; pColumnDef++)
		if (*pColumnDef & icdInternalFlag)
		{
			*pColumnDef |= (icdShort | icdObject);
			*pColumnDef &= ~icdInternalFlag;
		}
	return false;  // no longer hidden
}

Bool CMsiTable::RenameStream(unsigned int iCurrentRow, MsiTableData* pNewData, unsigned int iStreamCol)
{
	Assert(iCurrentRow-1 < unsigned(m_cRows));
	unsigned int iStorage = pNewData[iStreamCol];
	if (iStorage == 0 || iStorage > iMaxStreamId)
		return fTrue;   // no action needed if null or data is actual stream object
	MsiTableData* pRow = m_rgiData + (iCurrentRow-1) * m_cWidth;
	MsiString istrOldName(m_riDatabase.ComputeStreamName(m_riDatabase.DecodeStringNoRef(m_iName), pRow+1, m_rgiColumnDef+1));
	MsiString istrNewName(m_riDatabase.ComputeStreamName(m_riDatabase.DecodeStringNoRef(m_iName), pNewData+1, m_rgiColumnDef+1));
	if (iStorage == iPersistentStream && m_pinrStorage == m_riDatabase.GetOutputStorage())  // stream in current output database
	{
		PMsiRecord precError = m_pinrStorage->RenameElement(istrOldName, istrNewName, m_fStorages); // must rename otherwise will be deleted
		return precError == 0 ? fTrue : fFalse;
	}
	else  // stream in output database or transform storage, must create stream object
	{
		IMsiStorage* piStorage;
		if (iStorage == iPersistentStream)
			piStorage = m_pinrStorage;  // no refcnt
		else
			piStorage = m_riDatabase.GetTransformStorage(iStorage);
		if (!piStorage)
			return fFalse; // should never happen
		IMsiStream* piStream = 0;
		IMsiRecord* piError = piStorage->OpenStream(istrOldName, fFalse, piStream);
		if (iStorage != iPersistentStream)
			piStorage->Release();
		if (piError)
			return piError->Release(), fFalse;
		pNewData[iStreamCol] = (MsiTableData)PutObjectData(piStream);
		return fTrue;
	}
}

//____________________________________________________________________________
//
// CCatalogTable overridden methods
//____________________________________________________________________________

CCatalogTable::CCatalogTable(CMsiDatabase& riDatabase, unsigned int cInitRows, int cRefBase)
	: CMsiTable(riDatabase, 0, cInitRows, 0), m_cRefBase(cRefBase)
{
	//!! is the following necessary? as we mark the row temporary anyway, we could use InsertTemporary
	m_idsUpdate = idsWrite;  // always allow insertion of temporary tables
}

unsigned long CCatalogTable::AddRef()
{
	AddRefTrack();
	if (m_Ref.m_iRefCnt == m_cRefBase)
		m_riDatabase.AddTableCount();
	return ++m_Ref.m_iRefCnt;
}

unsigned long CCatalogTable::Release()
{
	ReleaseTrack();
	if (--m_Ref.m_iRefCnt == 0)  // can't happen until released by database
	{
		delete this;
		return 0;
	}
	if (m_Ref.m_iRefCnt == m_cRefBase)       // all external references removed
	{
		m_riDatabase.AddRef();            // add count so that Release may destruct
		m_riDatabase.RemoveTableCount();  // remove count for this table, internal refs only remain
		if (m_riDatabase.Release() == 0)  // will destruct if no external refs remain
			return 0;                      // this table is now destroyed, can't return refcnt
	}
	return m_Ref.m_iRefCnt;
}

//____________________________________________________________________________
//
// CCatalogTable table management methods
//____________________________________________________________________________

bool CCatalogTable::SetTransformLevel(MsiStringId iName, int iTransform)
{
	int iRow = 0;
	MsiTableData* pRow;
	if (iName==0 || (pRow = FindFirstKey(iName, 0, iRow))== 0)
		return false;
	int iRowStatus = *pRow;
	
	*pRow = (*pRow & ~(iRowTableTransformMask << iRowTableTransformOffset))
						| (iTransform << iRowTableTransformOffset);
	return true;
}

bool CCatalogTable::SetTableState(MsiStringId iName, ictsEnum icts)
{
	int iRow = 0;
	MsiTableData* pRow;
	if (iName==0 || (pRow = FindFirstKey(iName, 0, iRow))== 0)
		return false;
	int iRowStatus = *pRow;
	int cLocks = iRowStatus & iRowTableLockCountMask;
	switch (icts)
	{
	case ictsPermanent: iRowStatus &= ~iRowTemporaryBit; break;
	case ictsTemporary: iRowStatus |=  iRowTemporaryBit; break;

	case ictsLockTable:
		if (cLocks == iRowTableLockCountMask)
			return false;  // overflow, should never happen
		if (!cLocks && pRow[ctcTable] != 0)  // unlocked table is loaded
			AddRefObjectData(pRow[ctcTable]);  // table keeps a refcnt	
		iRowStatus++;
		break;
	case ictsUnlockTable:
		if (!cLocks)
			return false;
		(*pRow)--;  // must decrement before table is released, row may be deleted!
		if (cLocks == 1)
		{
			ReleaseObjectData(pRow[ctcTable]);
		}
		return true;

	case ictsUserClear:       iRowStatus &= ~iRowUserInfoBit; break;
	case ictsUserSet:         iRowStatus |=  iRowUserInfoBit; break;

	case ictsOutputDb:        iRowStatus |=  iRowTableOutputDbBit; break;
	case ictsTransform:       iRowStatus |=  iRowTableTransformBit; break;
	case ictsNoTransform:     iRowStatus &= ~iRowTableTransformBit; break;
//	case ictsTransformDone:   iRowStatus |=  iRowTableTransformedBit; break;
	case ictsSaveError:       iRowStatus |=  iRowTableSaveErrorBit; break;
	case ictsNoSaveError:     iRowStatus &= ~iRowTableSaveErrorBit; break;

	case ictsStringPoolSet:   iRowStatus |=  iRowTableStringPoolBit; break;
	case ictsStringPoolClear: iRowStatus &= ~iRowTableStringPoolBit; break;

	default: return false;  // ictsDataLoaded and ictsTableExists are read-only
	};
	*pRow = iRowStatus;
	return true;
}

bool CCatalogTable::GetTableState(MsiStringId iName, ictsEnum icts)
{
	int iRow = 0;
	MsiTableData* pRow;
	if (iName==0 || (pRow = FindFirstKey(iName, 0, iRow))==0)
		return false;
	int iRowStatus = *pRow;
	switch (icts)
	{
	case ictsPermanent:       iRowStatus ^= iRowTemporaryBit; // fall through
	case ictsTemporary:       iRowStatus &= iRowTemporaryBit; break;
	case ictsUserClear:       iRowStatus ^= iRowUserInfoBit; // fall through
	case ictsUserSet:         iRowStatus &= iRowUserInfoBit; break;
	case ictsUnlockTable:     iRowStatus = (iRowStatus & iRowTableLockCountMask) - 1 & iRowTableLockCountMask + 1; break;
	case ictsLockTable:       iRowStatus &= iRowTableLockCountMask; break;
	case ictsOutputDb:        iRowStatus &= iRowTableOutputDbBit; break;
	case ictsTransform:       iRowStatus &= iRowTableTransformBit; break;
//	case ictsTransformDone:   iRowStatus &= iRowTableTransformedBit; break;
	case ictsSaveError:       iRowStatus &= iRowTableSaveErrorBit; break;
	case ictsStringPoolClear: iRowStatus ^= iRowTableStringPoolBit; // fall through
	case ictsStringPoolSet:   iRowStatus &= iRowTableStringPoolBit; break;
	case ictsDataLoaded:      iRowStatus =  pRow[ctcTable]; break;
	case ictsTableExists: return true;
	default:              return false;
	};
	return iRowStatus ? true : false;
}

int CCatalogTable::GetLoadedTable(MsiStringId iName, CMsiTable*& rpiTable)
{
	int iRow = 0;
	MsiTableData* pRow;
	if (iName==0 || (pRow = FindFirstKey(iName, 0, iRow))==0)
		return rpiTable = 0, -1;
	rpiTable = (CMsiTable*)GetObjectData(pRow[ctcTable]);
	return *pRow;
}

int CCatalogTable::SetLoadedTable(MsiStringId iName, CMsiTable* piTable)
{
	int iRow = 0;
	MsiTableData* pRow;
	if (iName==0 || (pRow = FindFirstKey(iName, 0, iRow))==0)
	{
		AssertSz(0, "Table not in catalog");
		return 0;
	}
	if (piTable)
	{
		if (pRow[ctcTable] != 0)  // error if already loaded
		{
			AssertSz(0, "Table already loaded");
			return 0;
		}
		if (pRow[0] & iRowTableLockCountMask)
			piTable->AddRef();
	}
	else // removing table, no refcnt kept by table if no locks
	{
		if (pRow[ctcTable] == 0)  // no error if not loaded, is this right?
			return pRow[0];
		Assert((pRow[0] & iRowTableLockCountMask) == 0); // assume that no locks can remain, and thus no refcnt held
	}
	pRow[ctcTable] = PutObjectData(piTable);
	return pRow[0];
}

//____________________________________________________________________________
//
// CMsiCursor implementation
//____________________________________________________________________________

CMsiCursor::CMsiCursor(CMsiTable& riTable, CMsiDatabase& riDatabase, Bool fTree)
 : m_riTable(riTable), m_riDatabase(riDatabase), m_fTree(fTree),
	m_pColumnDef(riTable.GetColumnDefArray()), m_rcColumns(riTable.GetColumnCountRef())
{
	riTable.AddRef();  // current implementation holds a refcnt on table
	m_Ref.m_iRefCnt = 1;
	m_idsUpdate = riTable.GetUpdateState();
	if (fTree == ictUpdatable)  // special case for applying transform to read-only db
	{
		m_idsUpdate = idsWrite;
		m_fTree = fFalse;
	}
	CMsiCursor** ppiCursorHead = riTable.GetCursorListHead();
	if ((m_piNextCursor = *ppiCursorHead) != 0)
		m_piNextCursor->m_ppiPrevCursor = &m_piNextCursor;
	m_ppiPrevCursor = ppiCursorHead;
	*ppiCursorHead = this;
	Debug(m_Ref.m_pobj = this);
}

HRESULT CMsiCursor::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown) || MsGuidEqual(riid, IID_IMsiCursor))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CMsiCursor::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}
unsigned long CMsiCursor::Release()
{
	ReleaseTrack();
	if (--m_Ref.m_iRefCnt != 0)
		return m_Ref.m_iRefCnt;
	m_riDatabase.Block();
	Reset();
	if (m_piNextCursor)
		m_piNextCursor->m_ppiPrevCursor = m_ppiPrevCursor;
	*m_ppiPrevCursor = m_piNextCursor;
	CMsiTable& riTable = m_riTable;  // copy before deleting memory
	m_riDatabase.Unblock();
	delete this;  // remove memory before possibly releasing Services
	riTable.Release();
	return 0;
}

IMsiTable& CMsiCursor::GetTable()
{
	m_riTable.AddRef();
	return m_riTable;
}

void CMsiCursor::Reset()
{
	m_riDatabase.Block();
	MsiColumnDef* pColumnDef = m_pColumnDef;
	MsiTableData* pData = m_Data;
	for (int cCol = m_rcColumns; cCol-- >= 0; pColumnDef++, pData++)
	{
		if (*pData != 0)
		{
			if (*pColumnDef & icdObject)
			{
				if (*pColumnDef & icdShort)
					m_riDatabase.UnbindStringIndex(*pData);
				else
					ReleaseObjectData(*pData);
			}
			*pData = 0;
		}
	}
	m_iRow = 0;
	m_fDirty = 0;
	m_riDatabase.Unblock();
}

int CMsiCursor::Next()
{
	int iRet;
	m_riDatabase.Block();
	if (m_riTable.FindNextRow (m_iRow, m_Data, m_fFilter, m_fTree))
		iRet = m_riTable.FetchRow(m_iRow, m_Data);
	else
	{
		Reset();
		iRet = 0;
	}
	m_riDatabase.Unblock();
	return iRet;
}

unsigned int CMsiCursor::SetFilter(unsigned int fFilter)
{
	unsigned int fOld = m_fFilter;
	m_fFilter = fFilter;
	return fOld;
}

int CMsiCursor::GetInteger(unsigned int iCol)
{
	if (iCol-1 >= m_rcColumns)
	{
		if (iCol == 0)
			return (m_Data[0] >> iRowBitShift) & ((1 << iraTotalCount) - 1);
		if (iCol == ~iTreeLinkMask)  // for accessing raw row bits internally
			return m_Data[0];
		return 0;
	}
	return m_pColumnDef[iCol] & icdObject ? m_Data[iCol] : m_Data[iCol] - iIntegerDataOffset;
}


// internal function to return object from column assured to be of type icdObject
IMsiStream* CMsiCursor::GetObjectStream(int iCol)
{
	unsigned int iStream = m_Data[iCol];
	if (!iStream)
		return 0;
	if (iStream > iMaxStreamId)
	{
		IMsiStream* piStream = (IMsiStream*)GetObjectData(iStream);
		piStream->AddRef();
		return piStream;
	}
	if (iStream == iPersistentStream)
		return CreateInputStream(0);
	IMsiStorage* piStorage = m_riDatabase.GetTransformStorage(iStream);
	if (!piStorage)
		return 0; //!! Is this sufficient?
	IMsiStream* piStream = CreateInputStream(piStorage);
	piStorage->Release();
	return piStream;
}

const IMsiString& CMsiCursor::GetString(unsigned int iCol)
{
	if (iCol-1 >= m_rcColumns)
		return ::CreateString();
	MsiColumnDef iColumnDef = m_pColumnDef[iCol];
	if (iColumnDef & icdObject)
	{
		if (iColumnDef & icdShort) // string index
		{
			return m_riDatabase.CMsiDatabase::DecodeString(m_Data[iCol]);
		}
		else // data object
		{
			PMsiData pData = GetObjectStream(iCol);
			if (pData != 0)
				return pData->GetMsiStringValue();
		}
	}
	return ::CreateString();
}

const IMsiData* CMsiCursor::GetMsiData(unsigned int iCol)
{
	if (iCol-1 >= m_rcColumns)
		return 0;
	MsiColumnDef iColumnDef = m_pColumnDef[iCol];
	if (iColumnDef & icdObject)
	{
		if (iColumnDef & icdShort) // string index
		{
			MsiStringId iStr = m_Data[iCol];
			return iStr ? &m_riDatabase.DecodeString(iStr) : 0;
		}
		else // data object
		{
			return GetObjectStream(iCol);	 // OK if a non-stream object
		}
	}
	return 0;
}

IMsiStream* CMsiCursor::GetStream(unsigned int iCol)
{
	if (iCol-1 >= m_rcColumns)
		return 0;
	if ((m_pColumnDef[iCol] & (icdObject|icdPersistent|icdShort))
								  != (icdObject|icdPersistent))
		return 0;
	return GetObjectStream(iCol);
}

Bool CMsiCursor::PutStream(unsigned int iCol, IMsiStream* piStream)
{
	if (iCol-1 >= m_rcColumns)
		return fFalse;
	MsiColumnDef iColumnDef = m_pColumnDef[iCol];
	if ((iColumnDef & (icdObject|icdShort|icdPersistent)) != (icdObject|icdPersistent))
		return fFalse;
	if (piStream != 0)
		piStream->AddRef();
	else if (!(iColumnDef & icdNullable))
 		return fFalse;
	IUnknown* piData = (IUnknown *)GetObjectData(m_Data[iCol]);
	if (piData > (IUnknown*)((INT_PTR)iMaxStreamId))
		piData->Release();
	m_Data[iCol] = (MsiTableData)PutObjectData(piStream);
	m_fDirty |= (1 << (iCol-1));
	return fTrue;
}


Bool CMsiCursor::PutInteger(unsigned int iCol, int iData)
{
	if (iCol-1 >= m_rcColumns)
	{
		if (iCol == 0)
		{
			int iMask = m_idsUpdate == idsWrite ? iRowTemporaryBit|iRowUserInfoBit : iRowUserInfoBit;
			m_Data[0] = (m_Data[0] & ~iMask) | ((iData << iRowBitShift) & iMask);
			return fTrue;
		}
		if (iCol == ~iTreeLinkMask)  // for accessing raw row bits internally
		{
			m_Data[0] = iData;
			return fTrue;
		}
//		if ((iCol & iTreeLinkMask) == 0)  // internal call with row state mask
//		{
//			m_Data[0] = (m_Data[0] & ~iCol) | (iData & iCol);
//			return fTrue;
//		}
		return fFalse;
	}
	MsiColumnDef iColumnDef = m_pColumnDef[iCol];
	if (iColumnDef & icdObject)
	{
		if (iData == 0 && !(iColumnDef & icdNullable))
			return fFalse;
		if (iColumnDef & icdShort) // string index
		{
			if (m_Data[iCol] != iData) // optimization
			{
				m_riDatabase.Block();
				m_riDatabase.BindStringIndex(iData); // Bind before Unbind incase =
				m_riDatabase.UnbindStringIndex(m_Data[iCol]);
				m_riDatabase.Unblock();
			}
		}
		else  // object					
		{
			int iDataOld = m_Data[iCol];
			if (iData > iMaxStreamId)
			{
#ifndef _WIN64
 				(*(IUnknown**)&iData)->AddRef();				//!!merced: Converting INT (iData) to PTR
#endif // !_WIN64
				Assert(fFalse);
			}
			ReleaseObjectData(iDataOld);
		}
		m_Data[iCol] = iData;
	}
	else // integer
	{
		if (iData == iMsiNullInteger)
		{
		 	if (!(iColumnDef & icdNullable))
				return fFalse;
			m_Data[iCol] = 0;
		}
		else if ((iColumnDef & icdShort) && (iData + 0x8000 & 0xFFFF0000L)) // short integer
			return fFalse;
		m_Data[iCol] = iData + iIntegerDataOffset;
	}
	m_fDirty |= (1 << (iCol-1)); // dirty even if data unchanged? prevents removal on delete
	return fTrue;
}

Bool CMsiCursor::PutString(unsigned int iCol, const IMsiString& riData)
{
	if (iCol-1 >= m_rcColumns)
		return fFalse;
	MsiColumnDef iColumnDef = m_pColumnDef[iCol];
	if ((iColumnDef & icdObject) == 0) // integer column
		return fFalse;
	if (iColumnDef & icdShort) // string index column
	{
		CDatabaseBlock dbBlk(m_riDatabase);
		int iData = m_riDatabase.BindString(riData);
		if (iData == 0 && !(iColumnDef & icdNullable))
			return fFalse;
		m_riDatabase.UnbindStringIndex(m_Data[iCol]);
		m_Data[iCol] = iData;
	}
	else  // object column
	{
		if (iColumnDef & icdPersistent)
			return fFalse;
		IUnknown* piData = *(IUnknown**)&m_Data[iCol];
		if (riData.TextSize() == 0)
			m_Data[iCol] = 0;
		else
		{
			riData.AddRef();
			Assert(fFalse);
			m_Data[iCol] = PutObjectData(&riData);
		}
		if (piData > (IUnknown*)((INT_PTR)iMaxStreamId))
			piData->Release(); // release after AddRef
	}
	m_fDirty |= (1 << (iCol-1));
	return fTrue;
}

Bool CMsiCursor::PutMsiData(unsigned int iCol, const IMsiData* piData)
{
	if (iCol-1 >= m_rcColumns)
		return fFalse;
	MsiColumnDef iColumnDef = m_pColumnDef[iCol];
	if (!(iColumnDef & icdObject) || (iColumnDef & icdShort))
		return fFalse;
	if (piData == 0 && !(iColumnDef & icdNullable))
		return fFalse;
	if (piData && (iColumnDef & icdPersistent))
	{
		IUnknown* piunk;
		if (piData->QueryInterface(IID_IMsiStream, (void**)&piunk) != S_OK)
			return fFalse;  // must be a stream if persistent
		piunk->Release();
	}
	if (piData)
		piData->AddRef();
	int iDataOld = m_Data[iCol];
	ReleaseObjectData(iDataOld);
	m_Data[iCol] = PutObjectData(piData);
	m_fDirty |= (1 << (iCol-1));
	return fTrue;
}

Bool CMsiCursor::PutNull(unsigned int iCol)
{
	if (iCol-1 >= m_rcColumns)
		return fFalse;
	MsiColumnDef iColumnDef = m_pColumnDef[iCol];
	if (!(iColumnDef & icdNullable))
		return fFalse;
	if (iColumnDef & icdObject)
	{
		if (iColumnDef & icdShort) // string index
		{
			m_riDatabase.Block();
			m_riDatabase.UnbindStringIndex(m_Data[iCol]);
			m_riDatabase.Unblock();
		}
		else  // object
		{
			ReleaseObjectData(m_Data[iCol]);
		}
	}
	m_Data[iCol] = 0;
	m_fDirty |= (1 << (iCol-1)); // dirty even if data unchanged? prevents removal on delete
	return fTrue;
}

Bool CMsiCursor::Update()  // update fetched row, no primary key changes allowed
{
	if (m_idsUpdate == idsNone)
		return fFalse;
	if (m_iRow == 0 || (m_Data[0] & iTreeInfoMask) == iTreeInfoMask)  // current row has been deleted
#ifdef DEBUG  //!!TEMP
/*temp*/		return AssertSz(0,"Update: not positioned on fetched row"), fFalse;   // must be positioned on a valid row
#else
		return fFalse;   // must be positioned on a valid row
#endif
	m_riDatabase.Block();
	if (m_idsUpdate == idsRead)  // allow temporary changes
	{
		if ((m_Data[0] & iRowTemporaryBit) == 0)  // permanent row, must check columns
		{
			if (m_riTable.MatchRow(m_iRow, m_Data) == fFalse)
				return m_riDatabase.Unblock(), fFalse;
		}
	}
	if (((1 << m_riTable.GetPrimaryKeyCount()) - 1) & m_fDirty)  // primary key changed
	{
		int iCurrentRow = m_iRow;   // OK if dirty but same value
		if (m_riTable.FindKey(m_iRow, m_Data) == fFalse || m_iRow != iCurrentRow)
			return m_riDatabase.Unblock(), fFalse;   // sorry, can't change primary key with Update
	}
	Bool fRet = m_riTable.ReplaceRow(m_iRow, m_Data);
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::Insert()  // insert unique record, fails if primary key exists
{
	if (m_idsUpdate != idsWrite)
		return fFalse;
	if (!CheckNonNullColumns())
		return fFalse;
	m_riDatabase.Block();
	Bool fRet;
	if (m_riTable.FindKey(m_iRow, m_Data))
	{
		m_iRow = 0;  // not representing a valid row, prevent Update from succeeding
		fRet = fFalse;
	}
	else
		fRet = m_riTable.InsertRow(m_iRow, m_Data);
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::InsertTemporary()  // insert temporary record, fails if primary key exists
{
	if (m_idsUpdate == idsNone)
		return fFalse;
	if (!CheckNonNullColumns())
		return fFalse;
	m_riDatabase.Block();
	Bool fRet;
	if (m_riTable.FindKey(m_iRow, m_Data))
	{
		m_iRow = 0;  // not representing a valid row, prevent Update from succeeding
		fRet = fFalse;
	}
	else
	{
		m_Data[0] |= iRowTemporaryBit;
		fRet = m_riTable.InsertRow(m_iRow, m_Data);
	}
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::Assign()  // force insert by overwriting any existing row
{
	if (m_idsUpdate != idsWrite)
		return fFalse;
	if (!CheckNonNullColumns())
		return fFalse;
	m_riDatabase.Block();
	Bool fRet;
	if (m_riTable.FindKey(m_iRow, m_Data))
		fRet = m_riTable.ReplaceRow(m_iRow, m_Data);
	else
		fRet = m_riTable.InsertRow(m_iRow, m_Data);
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::Replace()  // force update of fetched row, allowing primary key changes
{
	if (m_idsUpdate != idsWrite)
		return fFalse;
	if (m_iRow == 0)
		return fFalse;   // must be positioned on a row, may be a deleted row
	if (!CheckNonNullColumns())
		return fFalse;
	m_riDatabase.Block();
	Bool fRet = fTrue;
	if (((1 << m_riTable.GetPrimaryKeyCount()) - 1) & m_fDirty)  // primary key changed
	{
		int iCurrentRow = m_iRow;
		if (m_riTable.FindKey(m_iRow, m_Data))
		{
			if (iCurrentRow == m_iRow)  // primary key value unchanged
				fRet = m_riTable.ReplaceRow(m_iRow, m_Data); // do a normal update, not really dirty
			else
				fRet = fFalse;   // new primary key cannot exist already
		}
		else  // changed key value does not exist
		{
			// check for persisted stream column
			MsiColumnDef* pColumnDef = m_pColumnDef + 1;
			for (int iCol = 1; iCol <= m_rcColumns && (*pColumnDef & icdPersistent); iCol++, pColumnDef++)
				if ((*pColumnDef & (icdObject | icdShort)) == icdObject)
					fRet = m_riTable.RenameStream(iCurrentRow, m_Data, iCol);

			// insert new row and delete row referenced by previous key value, if not already deleted
			if (!m_riTable.InsertRow(m_iRow, m_Data))
				fRet = fFalse;
			else if ((m_Data[0] & iTreeInfoMask) != iTreeInfoMask)  // current row has not been deleted
				m_riTable.DeleteRow(iCurrentRow + (m_iRow <= iCurrentRow));// if inserted ahead of row to be deleted, add 1
		}
	}
	else if (m_riTable.FindKey(m_iRow, m_Data))
		fRet = m_riTable.ReplaceRow(m_iRow, m_Data);
	else
		fRet = m_riTable.InsertRow(m_iRow, m_Data);
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::Merge()
{
//	if (m_fReadOnly)
//		return fFalse;
	Bool fRet;
	m_riDatabase.Block();
	if (m_riTable.FindKey(m_iRow, m_Data))
		fRet = m_riTable.MatchRow(m_iRow, m_Data);
	else if (!CheckNonNullColumns())
		fRet = fFalse;
	else
		fRet = m_riTable.InsertRow(m_iRow, m_Data);
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::Refresh()
{
	if (m_iRow == 0)
	{
		Reset();
		return fFalse;
	}
	Bool fRet;
	m_riDatabase.Block();
	if ((m_Data[0] & iTreeInfoMask) == iTreeInfoMask)  // current row has been deleted
	{
		int iRow = m_iRow;
		Reset();
		m_Data[0] = iTreeInfoMask;   // restore deleted state
		m_iRow = iRow;       // and position
		fRet = fFalse;
	}
	else
	{
		fRet = m_riTable.FetchRow(m_iRow, m_Data) ? fTrue : fFalse;
		m_fDirty = 0;
	}
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::Seek()
{
	Bool fRet = fFalse;
	m_riDatabase.Block();
	if (m_riTable.FindKey(m_iRow, m_Data))
		fRet = m_riTable.FetchRow(m_iRow, m_Data) ? fTrue : fFalse;
	if (!fRet)
		Reset();
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::Delete()
{
//	if (m_fReadOnly || (m_Data[0] & iTreeInfoMask) == iTreeInfoMask)  // can't delete twice
	if ((m_Data[0] & iTreeInfoMask) == iTreeInfoMask)  // can't delete twice
		return fFalse;
	Bool fRet;
	m_riDatabase.Block();
	if (!(m_riTable.FindKey(m_iRow, m_Data)))  // leaves m_iRow at insert point if fails
	{
		m_iRow = 0;  // not pointing at a valid row, prevent update
		fRet = fFalse;
	}
	else
		fRet = m_riTable.DeleteRow(m_iRow);
	m_riDatabase.Unblock();
	return fRet;
}

IMsiRecord*  CMsiCursor::Validate(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor, int iCol)
{
	// Error record & column count
	// If there is an error, then the error record is created with cCol fields
	m_riDatabase.Block();  //!! probably don't need this, but one could have a multi-threaded authoring tool
	IMsiRecord* piRecord = 0;
	int cCol = m_riTable.GetColumnCount();
	int i = 0;

	// Check for invalid cursor state (row for delete, or cursor reset)
	// Cursor can be reset if validating new row or a field
	// An empty/null record represents some other *serious* error
	if ((m_iRow == 0 && iCol == 0) || (m_Data[0] & iTreeInfoMask) == iTreeInfoMask)
		return m_riDatabase.Unblock(), (piRecord = &(SetUpRecord(cCol)));
		
	
	// Check to see if row is a row of _Validation table
	// If yes, don't validate -- we don't validate ourselves
	if (IStrComp(MsiString(m_riTable.GetMsiStringValue()), sztblValidation) == 0)
		return m_riDatabase.Unblock(), 0;

	int vtcTable = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colTable));
	Assert(vtcTable);
	int vtcColumn = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colColumn));
	Assert(vtcColumn);
	
	// Validate pre-delete (see if any *explicit* foreign keys point to us)
	// *Explicit* foreign keys are those columns with 'our' table name in the KeyTable column
	// of some other column of a table
	// The delimited list of tables and possibility of value being referenced in a [#identifier]
	// type property, etc. are not evaluated/validated.
	if (iCol == -2)
	{
		int vtcKeyTable = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colKeyTable));
		Assert(vtcKeyTable);
		int vtcKeyColumn = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colKeyColumn));
		Assert(vtcKeyColumn);
		riValidationCursor.Reset();
		riValidationCursor.SetFilter(iColumnBit(vtcKeyTable));
		riValidationCursor.PutInteger(vtcKeyTable, m_riTable.GetTableName());
		while (riValidationCursor.Next())
		{
			// Someone could be pointing to us
			// Load table and see if they reference our primary key
			// Check value in 'KeyColumn' column to determine what column in us they point to
			int iKeyColumn = riValidationCursor.GetInteger(vtcKeyColumn);
			PMsiTable pRefTable(0);
			MsiString strRefTableName = riValidationCursor.GetString(vtcTable);
			IMsiRecord* piErrRec = m_riDatabase.LoadTable(*strRefTableName, 0, *&pRefTable);
			if (piErrRec)
			{
				//!! Should we report some error here??
				piErrRec->Release();
				continue;
			}
			// Create cursor on table
			PMsiCursor pRefCursor(pRefTable->CreateCursor(fFalse));
			Assert(pRefCursor);
			int ircRefColumn = pRefTable->GetColumnIndex(riValidationCursor.GetInteger(vtcColumn));
			Assert(ircRefColumn);
			
			pRefCursor->Reset();
			pRefCursor->SetFilter(iColumnBit(ircRefColumn));
			int iDelKeyData = m_pColumnDef[iKeyColumn] & icdObject ? m_Data[iKeyColumn] : m_Data[iKeyColumn] - iIntegerDataOffset;
			//!! Should we check for NULL?? --> iDelKeyData should never be NULL since it is supposed to be a primary key
			//!! BUT key columns can be null - chetanp
			pRefCursor->PutInteger(ircRefColumn, iDelKeyData);
			while (pRefCursor->Next())
			{
				// Possible match, must check primary key data if value in vtcKeyColumn > 1 to be sure
				if (iKeyColumn > 1)
				{
					Bool fMatch = fTrue;
					for (i = 1; i < iKeyColumn; i++)
					{
						iDelKeyData = m_pColumnDef[i] & icdObject ? m_Data[i] : m_Data[i] - iIntegerDataOffset;
						if (pRefCursor->GetInteger(i) != iDelKeyData)
							fMatch = fFalse;
					}
					if (!fMatch)
						continue; // while (pRefCursor->Next())
				}
				// Insert error, as this row is referenced by a field of a row in another table (or this table)
				if (piRecord == 0)
				{
					piRecord = &(SetUpRecord(cCol));
					Assert(piRecord);
				}
				for (i = 1; i <= iKeyColumn; i++)
					piRecord->SetInteger(1, (int)iveRequired); // required field, needed for foreign key validation to succeed
				piRecord->SetInteger(0, iKeyColumn); // set num errors to primary key columns
				return m_riDatabase.Unblock(), piRecord; // Error already found (note, numErrors could differ, but shouldn't)
			}// end while (pRefCursor->Next())
		} // end while (riValidationCursor.Next())
		return m_riDatabase.Unblock(), 0; // no match found
	}

	// Set up _Validation table and cursor for Insert/Update validation
	// Set the filter of the cursor on the _Validation table for the 'Table' & 'Column' columns
	// Initialize the foreign key mask (32-bits, bit set on if column is supposed to be a foreign key)
	// Intialize validation status to no error
	int iForeignKeyMask = 0;
	iveEnum iveStat = iveNoError;
	riValidationCursor.Reset();
	riValidationCursor.SetFilter(iColumnBit(vtcTable)|iColumnBit(vtcColumn));

	// Validate a single field of the row
	// If invalid, the invalid enum is placed in that column's corresponding field of the error record
	// The zeroeth field of the record contains the number of invalid entries
	// At the field level, no foreign key validation occurs
	// Also, no special row level validation (where the value of a column is dependent upon another
	// column in the row
	if (iCol != -1 && iCol != 0)
	{
		Assert(m_riTable.GetColumnName(iCol) != 0);
		iveStat = ValidateField(riValidationTable, riValidationCursor, iCol, iForeignKeyMask, fFalse /*fRow*/, vtcTable, vtcColumn);
		if (iveStat != iveNoError)
		{
			if (piRecord == 0)
			{
				piRecord = &(SetUpRecord(cCol));
				Assert(piRecord);
			}
			piRecord->SetInteger(iCol, (int)iveStat);
			piRecord->SetInteger(0, 1);
		}
		return m_riDatabase.Unblock(), piRecord;
	}

	// Validate entire row
	// If invalid, the record field corresponding to the column number is marked with the particular error enum
	// At row validation, foreign keys are validated as well as special *row* related (where one column's value
	// depends on another column in that row)
	// The zeroeth field of the record contains the number of columns with errors
	int iNumErrors = 0;
	for (i = 1; i <= cCol; i++) // Check each field
	{
		iveStat = ValidateField(riValidationTable, riValidationCursor, i, iForeignKeyMask, fTrue /*fRow*/, vtcTable, vtcColumn);
		if (iveStat != iveNoError)
		{
			if (piRecord == 0)
			{
				piRecord = &(SetUpRecord(cCol));
				Assert(piRecord);
			}
			piRecord->SetInteger(i, (int)iveStat);
			iNumErrors++;
		}
	}
	
	// Valiate the foreign keys according to the foreign key mask (bit would be set for that column)
	if (iForeignKeyMask != 0)
		CheckForeignKeys(riValidationTable, riValidationCursor, piRecord, iForeignKeyMask, iNumErrors);

	// Row is about to inserted, check for duplicate primary keys
	// Help prevent errors that would occur at Insert time
	if (iCol == -1)
		CheckDuplicateKeys(piRecord, iNumErrors);

	// Insert the number of columns with errors in the zeroeth field
	if (piRecord)
		piRecord->SetInteger(0, iNumErrors);
	return m_riDatabase.Unblock(), piRecord;
}

iveEnum CMsiCursor::ValidateField(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor, int iCol,
											 int& iForeignKeyMask, Bool fRow, int vtcTable, int vtcColumn)
{
	// Check for temporary column as don't validate temporary columns
	if (!(m_pColumnDef[iCol] & icdPersistent))
		return iveNoError;

	// Insert data into _Validation table cursor
	riValidationCursor.Reset();

#ifdef DEBUG
	MsiString strTable(m_riTable.GetMsiStringValue());
	MsiString strColumn(m_riDatabase.DecodeString(m_riTable.GetColumnName(iCol)));
#endif

	riValidationCursor.PutString(vtcTable, *MsiString(m_riTable.GetMsiStringValue()));
	riValidationCursor.PutString(vtcColumn, *MsiString(m_riDatabase.DecodeString(m_riTable.GetColumnName(iCol))));
	if (!riValidationCursor.Next())
		return iveMissingData;

	// Check for correct localize attributes for column
	// Only non-primary string columns may have the localizable attribute
	if ((m_pColumnDef[iCol] & icdLocalizable)
	 && (m_pColumnDef[iCol] & (icdShort | icdObject | icdPrimaryKey)) != (icdShort | icdObject))
		return iveBadLocalizeAttrib;

	// Check for null data
	int vtcNullable = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colNullable));
	Assert(vtcNullable);
	int iData = m_pColumnDef[iCol] & icdObject ? m_Data[iCol] : m_Data[iCol] - iIntegerDataOffset;
	int iDef = m_pColumnDef[iCol];
	if (((iDef & icdObject) && iData == 0) || (!(iDef & icdObject) && iData == iMsiNullInteger))
		return (IStrComp(MsiString(riValidationCursor.GetString(vtcNullable)), TEXT("Y")) == 0) ? iveNoError : iveRequired;
	//!! is this needed anymore since we don't support ODBC?? -- t-caroln
	else if ( (iDef & icdString) == icdString && IStrComp(MsiString(m_riDatabase.DecodeString(m_Data[iCol])), TEXT("@")) == 0)
	{
		if (IStrComp(MsiString(riValidationCursor.GetString(vtcNullable)), TEXT("@")) == 0)
			return iveNoError;
	}
	
	// Data not null, continue checks
	int vtcCategory = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colCategory));
	Assert(vtcCategory);
	switch (m_pColumnDef[iCol] & icdTypeMask)
	{
	case icdLong: // fall through
	case icdShort:	 return CheckIntegerValue(riValidationTable, riValidationCursor, iCol, iForeignKeyMask, fFalse /*fVersionString*/);
	case icdString: return CheckStringValue(riValidationTable, riValidationCursor, iCol, iForeignKeyMask, fRow);
	case icdObject:
		{
			if (m_pColumnDef[iCol] & icdPersistent)
				return (IStrComp(MsiString(riValidationCursor.GetString(vtcCategory)), szBinary) ==  0) ? iveNoError : iveBadCategory;
			return iveNoError;
		}
	default: Assert(0); // should never happen, unknown column type
	}
	return iveNoError;
}
	

void CMsiCursor::CheckDuplicateKeys(IMsiRecord*& rpiRecord, int& iNumErrors)
{
	// Create a new cursor for table
	PMsiCursor pDuplicateCheckCursor(m_riTable.CreateCursor(fFalse));
	Assert(pDuplicateCheckCursor);
	pDuplicateCheckCursor->Reset();

	// Get number of primary keys and determine filter for cursor
	int cPrimaryKey = m_riTable.GetPrimaryKeyCount();
	int i;
	int iFilter=1;
	for (i=0; i < cPrimaryKey; i++)
		iFilter |= (1 << i);				
	pDuplicateCheckCursor->SetFilter(iFilter);
	
	// Insert primary keys
	for (i = 1; i <= cPrimaryKey; i++)
	{
		if(rpiRecord != 0 && rpiRecord->GetInteger(i) != iMsiStringBadInteger && rpiRecord->GetInteger(i) != iveNoError)
			return; // invalid (from previous data check)
		int iData = m_pColumnDef[i] & icdObject ? m_Data[i] : m_Data[i] - iIntegerDataOffset;
		pDuplicateCheckCursor->PutInteger(i, iData);
	}
	if (pDuplicateCheckCursor->Next())
	{
		// ERROR: Row with those primary keys already exists
		if (rpiRecord == 0)
		{	
			rpiRecord = &(SetUpRecord(m_riTable.GetColumnCount()));
			Assert(rpiRecord);
		}
		for (i = 1; i <= cPrimaryKey; i++, iNumErrors++)
			rpiRecord->SetInteger(i, (int)iveDuplicateKey);
	}
}

void CMsiCursor::CheckForeignKeys(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor,
											 IMsiRecord*& rpiRecord, int iForeignKeyMask, int& iNumErrors)
{
	MsiString strForeignTableName;  // foreign table name
	MsiString strCategory;			  // category string
	int       iStat;                // validation status
	int       iForeignCol;  		  // foreign column
	
	// Obtain column indexes of certain columns in the _Validation table
	int cCol = m_riTable.GetColumnCount();
	int vtcTable = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colTable));
	Assert(vtcTable);
	int vtcColumn = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colColumn));
	Assert(vtcColumn);
	int vtcKeyTable = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colKeyTable));
	Assert(vtcKeyTable);
	int vtcKeyColumn = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colKeyColumn));
	Assert(vtcKeyColumn);
	int vtcCategory = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colCategory));
	Assert(vtcCategory);
	
	// Cycle through mask to find those columns that are marked as foreign key columns
	for (int i = 0; i < cCol; i++)
	{
		if ( (1 << i) & iForeignKeyMask )
		{
			if (rpiRecord != 0 && rpiRecord->GetInteger(i+1) != iMsiStringBadInteger && rpiRecord->GetInteger(i+1) != iveNoError)
				continue; // already invalid

			iStat = 1;
			
			// Insert data into Validation table cursor
			riValidationCursor.Reset();
			riValidationCursor.PutString(vtcTable, *MsiString(m_riTable.GetMsiStringValue()));
			riValidationCursor.PutString(vtcColumn, *MsiString(m_riDatabase.DecodeString(m_riTable.GetColumnName(i+1))));
			if (!riValidationCursor.Next())
			{
				// Should never get here...should be caught earlier
				if (rpiRecord == 0)
				{	
					rpiRecord = &(SetUpRecord(m_riTable.GetColumnCount()));
					Assert(rpiRecord);
				}
				rpiRecord->SetInteger(i+1, (int)iveMissingData);
				iNumErrors++;
				continue;
			}

			// Determine which table this column is a foreign key to
			strForeignTableName = riValidationCursor.GetString(vtcKeyTable);
			strCategory = riValidationCursor.GetString(vtcCategory);
			iForeignCol = riValidationCursor.GetInteger(vtcKeyColumn);

			if (strForeignTableName.Compare(iscWithin, TEXT(";")) == 0)
				iStat = SetupForeignKeyValidation(strForeignTableName, strCategory, i+1, iForeignCol);
			else // Delimited list of tables
			{
				while (strForeignTableName.TextSize())
				{
					MsiString strTable = (const ICHAR*)0;  // Table name
					strTable = strForeignTableName.Extract(iseUptoTrim, TEXT(';'));
					iStat = SetupForeignKeyValidation(strTable, strCategory, i+1, iForeignCol);
					if (!strForeignTableName.Remove(iseIncluding, TEXT(';')) || iStat == 1)
						break;
				}
			}
			if (iStat != 1)
			{
				// Invalid, enter invalid enum in field of record
				if (rpiRecord == 0)
				{	
					rpiRecord = &(SetUpRecord(m_riTable.GetColumnCount()));
					Assert(rpiRecord);
				}
				rpiRecord->SetInteger(i+1, (int)(iStat == 0 ? iveBadLink : iveBadKeyTable));
				iNumErrors++;
			}
		}
	}// end for
}

int CMsiCursor::SetupForeignKeyValidation(MsiString& rstrForeignTableName, MsiString& rstrCategory, int iCol, int iForeignCol)
/*-----------------------------------------------------------------------------------------------------------------------
CMsiCursor::SetupForeignKeyValidation -- Sets up foreign key validation by determining the foreign table
name as well as parsing keyformatted strings which can have multiple properties within the string that
are foreign keys.

Some instances of the foreign keys are *special* and the table names change as they are not explicitly
listed as the foreign key tables in the 'KeyTable' column of the '_Validation' table.  The particular table
and the data that is supposed to be the foreign key are determined here.

  Returns:
	int 1 (valid), 0 (invalid), -1 (foreign table error)
------------------------------------------------------------------------------------------------------------------------*/
{
	// If fSpecialKey is true, then the foreign key validation ignores the 'KeyColumn' column and uses 1 as the
	// value for the 'KeyColumn' column
	Bool fSpecialKey = fFalse;

	// Put foreign key data into cursor
	MsiString strData = (const ICHAR*)0;
	if (m_pColumnDef[iCol] & icdObject)
		strData = m_riDatabase.DecodeString(m_Data[iCol]);
	else
		strData = (int) (m_Data[iCol] - iIntegerDataOffset);
	
	// Determine whether string is a special property string.
	// [#identifier] is a foreign key to the 'File' table
	// [$identifier] is a foreign key to the 'Component' table
	// [!identifier] is a foreign key to the 'File' table
	if ((strData.Compare(iscWithin, TEXT("[#")) != 0) ||
		(strData.Compare(iscWithin, TEXT("[!")) != 0) ||
		(strData.Compare(iscWithin, TEXT("[$")) != 0) )
	{
		fSpecialKey = fTrue;
		const ICHAR* pch =  (const ICHAR*)strData;
		ICHAR szValue[MAX_PATH];
		ICHAR* pchOut = szValue;
		int iStat = ERROR_FUNCTION_FAILED;
		while ( *pch != 0 ) // Must loop because can have multiple instances of [#abc] & [$abc] in string
		{
			if (*pch == '[')
			{
				pch++; // for '['
				if (*pch != '#' && *pch != '$' && *pch != '!')
				{
					// just a plain property
					while (*pch != ']')
						pch = ICharNext(pch); // move to end of property
					pch++; // for ']'
					continue;
				}
				if ((*pch == '#') || (*pch == '!'))
					rstrForeignTableName = MsiString(sztblFile); // link to file table
				else // *pch == '$'
					rstrForeignTableName = MsiString(sztblComponent); // link to component table
				pch++; // for '#' or '$'

				// get the property
				while (*pch != ']')
				{
#ifdef UNICODE
					*pchOut++ = *pch++;
#else // !UNICODE
					const ICHAR* pchTemp = pch;
					*pchOut++ = *pch;
					pch = ICharNext(pch);
					if (pch == pchTemp + 2)
						*pchOut++ = *(pch - 1); // for DBCS char
#endif // UNICODE
				}
				*pchOut = '\0'; // null terminate
				pch++; // for ']'

				// validate the foreign key
				MsiString strKey(szValue);
				if ((iStat = ValidateForeignKey( rstrForeignTableName, strKey, fSpecialKey, iCol, iForeignCol )) != 1)
					return iStat;

				// re-init
				pchOut = szValue;
			}
			else
				pch = ICharNext(pch);
		} // end while (*pch != 0)
		return iStat;
	}
	// Determine whether string is in the 'Source' column of the 'CustomAction' table
	// The table that it is a foreign key to depends on the value in the 'Type' column of the 'CustomAction' table
	// Can be a foreign key to the 'Binary', 'Directory', 'File', or 'Property' table
	// The 'Property' table is not validated as properties can be added at run-time
	else if (IStrComp(rstrCategory, szCustomSource) == 0)
	{
		fSpecialKey = fTrue;
		int catcType = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(szcatcType));
		Assert(catcType);
		int icaFlags = int(m_Data[catcType]);
		switch (icaFlags & icaSourceMask)
		{
		case icaBinaryData: rstrForeignTableName = MsiString(sztblBinary);    break;
		case icaSourceFile: rstrForeignTableName = MsiString(sztblFile);      break;
		case icaDirectory:  rstrForeignTableName = MsiString(sztblDirectory); break;
		case icaProperty:   return 1;
		default:            return 0; // invalid (not a defined custom source type)
		}
	}
	// Determine whether string is in the 'Target' column of the 'Shortcut' table
	// Means that string does not contain properties (brackets)
	// String must be a foreign key to the 'Feature' table
	else if (IStrComp(rstrCategory, szShortcut) == 0)
	{
		fSpecialKey = fTrue;
		rstrForeignTableName = MsiString(sztblFeature);
	}
	return ValidateForeignKey( rstrForeignTableName, strData, fSpecialKey, iCol, iForeignCol );
}

int CMsiCursor::ValidateForeignKey(MsiString& rstrTableName, MsiString& rstrData, Bool fSpecialKey, int iCol, int iForeignCol)
/*----------------------------------------------------------------------------------------------------------------------
CMsiCursor::ValidateForeignKey -- Performs actual validation of foreign key by setting up foreign table and cursor and
attempting to find record in the foreign table.

  Returns:
	int 1 (valid), 0 (invalid), -1 (foreign table error)
-----------------------------------------------------------------------------------------------------------------------*/
{
	PMsiTable pForeignTable(0);		  // Foreign table
	PMsiCursor pForeignTableCursor(0); // Cursor on Foreign table
	IMsiRecord* piErrRecord;   		  // Error record holder
	int i;	    							  // Loop variable

	// Load foreign table
	if ((piErrRecord = m_riDatabase.LoadTable(*rstrTableName, 0, *&pForeignTable)) != 0)
	{
		piErrRecord->Release();
		return -1; // invalid (unable to load foreign table)
	}

	// Set up foreign table cursor
	pForeignTableCursor = pForeignTable->CreateCursor(fFalse);
	Assert(pForeignTableCursor);
	pForeignTableCursor->Reset();
	if (fSpecialKey)
		iForeignCol = 1; // automatic for [#abc], [$abc], Shortcut.Target and CustomSource data

	// Determine filter according to iForeignCol and set filter
	int iFilter=1;
	for (i=0; i < iForeignCol; i++)
		iFilter |= (1 << i);				
	pForeignTableCursor->SetFilter(iFilter);

	// Insert data into cursor
	// Use integers except in case of special key (and we know these are all strings)
	Bool fIntValue = fFalse;
	int iDataValue = 0;
	if (!fSpecialKey)
	{
		if (m_pColumnDef[iCol] & icdObject)
			iDataValue = m_Data[iCol];
		else
		{
			fIntValue = fTrue;
			iDataValue = m_Data[iCol] - iIntegerDataOffset;
		}
		pForeignTableCursor->PutInteger(iForeignCol, iDataValue);
	}
	else
		pForeignTableCursor->PutString(iForeignCol, *rstrData);
	
	if (iForeignCol != 1)
	{
		// More data needed for validation....primary key cols
		for (i = 1; i < iForeignCol; i++)
		{
			int iValue;
			if (m_pColumnDef[i] & icdObject)
				iValue = m_Data[i];
			else
				iValue = m_Data[i] - iIntegerDataOffset;
			pForeignTableCursor->PutInteger(i, iValue);
		}
	}
	if (pForeignTableCursor->Next())
		return 1;
	
	// check for possibility of self-joins
	PMsiTable pTable(&GetTable());
	MsiString strTableName(pTable->GetMsiStringValue());
	if (0 == IStrComp(rstrTableName, strTableName))
	{
		// foreign key table name and us match, self-join
		// compare column to iForeignCol value
		// we only need to compare that last of the primary key
		if (fIntValue)
		{
			// integer compare
			if (iDataValue == (m_Data[iForeignCol] - iIntegerDataOffset))
				return 1; // no error
		}
		else
		{
			// string compare
			if (0 == IStrComp(rstrData, MsiString(m_riDatabase.DecodeString(m_Data[iForeignCol]))))
				return 1; // no error
		}
	}
	return 0; // invalid
}

iveEnum CMsiCursor::CheckIntegerValue(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor, int iCol, int& iForeignKeyMask, Bool fVersionString)
/*-----------------------------------------------------------------------------------------------------------------------
CMsiCursor::CheckIntegerValue -- Checks the integer data for being between the acceptable limits of the MinValue and
MaxValue columns of the _Validation table. The integer data can also be a member of a set or be a foreign key.

  Returns:
	iveEnum -- iveNoError (valid)
					or iveOverflow or iveUnderflow for invalid data
------------------------------------------------------------------------------------------------------------------------*/
{
	int vtcMinValue = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colMinValue));
	Assert(vtcMinValue);
	int vtcMaxValue = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colMaxValue));
	Assert(vtcMaxValue);
	int vtcKeyTable = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colKeyTable));
	Assert(vtcKeyTable);
	int vtcSet = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colSet));
	Assert(vtcSet);
	
	int iData = m_pColumnDef[iCol] & icdObject ? m_Data[iCol] : m_Data[iCol] - iIntegerDataOffset;
	int iMaxValue = riValidationCursor.GetInteger(vtcMaxValue); // Max value allowed
	int iMinValue = riValidationCursor.GetInteger(vtcMinValue); // Min value allowed
	Bool fSet = (riValidationCursor.GetInteger(vtcSet) == 0 ? fFalse : fTrue);

	if (!fSet)
	{
		if (iMinValue != iMsiNullInteger && iMaxValue != iMsiNullInteger && iMinValue > iMaxValue)
			return iveBadMaxMinValues; // invalid (_Validation table max < min)
		else if (iMinValue == iMsiNullInteger && iMaxValue == iMsiNullInteger && !fSet)
				return iveNoError;
		else if (iMinValue == iMsiNullInteger && iData <= iMaxValue)
			return iveNoError;
		else if (iMaxValue == iMsiNullInteger && iData >= iMinValue)
			return iveNoError; 	
		else if (iData >= iMinValue && iData <= iMaxValue)
			return iveNoError;
	}
#ifdef DEBUG
	else
	{
		// cannot have both sets and ranges.
		Assert(iMsiNullInteger == iMinValue);
		Assert(iMsiNullInteger == iMaxValue);
	}
#endif

	
	// Data failed accepted values, check Set if possible
	if (fSet && CheckSet(MsiString(riValidationCursor.GetString(vtcSet)), MsiString(iData), fTrue /*fIntegerData*/))
		return iveNoError;
	
	// Data failed accepted values and set, check foreign key if possible
	if (riValidationCursor.GetInteger(vtcKeyTable) != 0 && !fVersionString)
	{	
		iForeignKeyMask |=  1 << (iCol - 1);
		return iveNoError;
	}

	// Return an informative error msg
	if (fSet)
		return iveNotInSet;
	return iData < iMinValue ? iveUnderFlow : iveOverFlow;
}
	
const ICHAR szScrollableTextControl[] = TEXT("ScrollableText");

iveEnum CMsiCursor::CheckStringValue(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor, int iCol, int& iForeignKeyMask, Bool fRow)
/*-----------------------------------------------------------------------------------------------------------------------
CMsiCursor::CheckStringValue -- validates string column of a row.  The strings can also be a member of a set, a particular
data category, or a foreign key.

  Returns:
	iveEnum -- iveNoError (valid)
					other iveEnums for invalid data
------------------------------------------------------------------------------------------------------------------------*/
{
	// Column numbers
	int vtcKeyTable = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colKeyTable));
	Assert(vtcKeyTable);
	int vtcCategory = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colCategory));
	Assert(vtcCategory);
	
	// Variables
	MsiString strCategory(riValidationCursor.GetString(vtcCategory)); // Category
	MsiString strData(m_riDatabase.DecodeString(m_Data[iCol]));			// Data
	
	// Check string length, 0 indicates infinite
	int iLen = m_pColumnDef[iCol] & 255;
	if (iLen != 0 && strData.TextSize() > iLen)
		return iveStringOverflow;
	
	MsiString strSet = (const ICHAR*)0;											// Set data
	iveEnum iveStat   = iveNoError;												// Status
	Bool fIntPossible = fFalse;													// Can be int
	Bool fKey         = fFalse;													// Could be foreign key
	Bool fVersionString = fFalse;													// Whether version string

	// See if can be foreign key
	if (riValidationCursor.GetInteger(vtcKeyTable) != 0)
		fKey = fTrue;
	if (IStrComp(strCategory, szIdentifier) == 0)	// Identifier string
	{
		if (fKey)
			iForeignKeyMask |= 1 << (iCol - 1);
		if (CheckIdentifier((const ICHAR*)strData))
			return iveNoError;
		iveStat = iveBadIdentifier;
	}
	// fKeyAllowed should always be TRUE now as Darwin does not distinguish.
	// Only difference is Template allows [1], [2] etc. whereas KeyFormatted and Formatted do not
	// KeyFormatted not removed for backwards compatibility sake
	else if (IStrComp(strCategory, szFormatted) == 0)	// Formatted string
	{
		// per bug 191416, check for special case of type 37 or 38 custom actions where the target column is
		// treated as literal script text rather than formatted text. note that if this is the CustomAction table
		// and the Target column, we must return success on Field level only validation since we do not have enough
		// information to determine otherwise (szCustomSource is similar...)

		MsiString strTable = m_riTable.GetMsiStringValue();
		
		// verify that this is the CustomAction.Target column ... if not, then default to original behavior
		if (IStrComp(strTable, sztblCustomAction) == 0
			&& m_riDatabase.EncodeStringSz(sztblCustomAction_colTarget) == m_riTable.GetColumnName(iCol))
		{
			if (fRow)
			{
				unsigned int iColCAType = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblCustomAction_colType));
				Assert(iColCAType);
				int iCATypeFlags = int(m_Data[iColCAType]) & icaTypeMask;
				int iCASourceFlags = int(m_Data[iColCAType]) & icaSourceMask;
				if ((icaVBScript == iCATypeFlags || icaJScript == iCATypeFlags) && (icaDirectory == iCASourceFlags))
				{
					// straight literal script text is stored in CustomAction.Target column
					return iveNoError;
				}
			}
			else // !fRow
			{
				// can't check the type at field level only since no other info exists
				// must simply return success ... similar to szCustomSource
				return iveNoError;
			}
		} // end special CustomAction.Target column validation
		
		if (IStrComp(strTable, sztblControl) == 0
			&& m_riDatabase.EncodeStringSz(sztblControl_colText) == m_riTable.GetColumnName(iCol))
		{
			if (fRow)
			{
				unsigned int iColCtrlType = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblControl_colType));
				Assert(iColCtrlType);
				MsiString strControlType(m_riDatabase.DecodeString(m_Data[iColCtrlType]));			// Data
				if (IStrComp(strControlType, szScrollableTextControl) == 0)
				{
					// RTF text is stored in Control.Text column when Control.Type='ScrollableText'
					return iveNoError;
				}
			}
			else // !fRow
			{
				// can't check the type at field level only since no other info exists
				// must simply return success
				return iveNoError;
			}
		} // end special Control.Text column validation for scrollable text controls that include RTF

		if (GetProperties((const ICHAR*)strData, fTrue /*fFormatted*/, fTrue /*fKeyAllowed*/, iCol, iForeignKeyMask))
			 return iveNoError;
		iveStat = iveBadFormatted;
	}
	else if (IStrComp(strCategory, szTemplate) == 0)	// Template string
	{
		if (GetProperties((const ICHAR*)strData, fFalse /*fFormatted*/, fTrue /*fKeyAllowed*/, iCol, iForeignKeyMask))
			 return iveNoError;
		iveStat = iveBadTemplate;
	}
	else if (IStrComp(strCategory, szKeyFormatted) == 0)	// KeyFormatted string
	{
		if (GetProperties((const ICHAR*)strData, fTrue /*fFormatted*/, fTrue /*fKeyAllowed*/, iCol, iForeignKeyMask))
			 return iveNoError;
		iveStat = iveBadFormatted;
	}
	else if (IStrComp(strCategory, szProperty) == 0)	// Property string
	{
		if (strData.Compare(iscStart, TEXT("%")) != 0)
			strData.Remove(iseFirst, 1);
		if (CheckIdentifier((const ICHAR*)strData))
			return iveNoError;
		iveStat = iveBadProperty;
	}
	else if (IStrComp(strCategory, szCondition) == 0)	// Conditional string
	{
		if (strData == 0)
			return iveNoError;
		CMsiValConditionParser Parser((const ICHAR*)strData);
		ivcpEnum ivcpStat = Parser.Evaluate(vtokEos);
		if (ivcpStat == ivcpNone || ivcpStat == ivcpValid)
			return iveNoError;
		iveStat = iveBadCondition;
	}
	else if (IStrComp(strCategory, szFilename) == 0)	// Filename
	{
		if (ParseFilename(strData, fFalse /*fAllowWildcards*/))
			return iveNoError;
		iveStat = iveBadFilename;
	}
	else if (IStrComp(strCategory, szGuid) == 0)	// Guid/ClassId string
	{
		// must be all UPPER CASE
		if (!CheckCase(strData, fTrue /*fUPPER*/))
			iveStat = iveBadGuid;
		else
		{
			// it may also be a foreign key
			LPCLSID pclsid = new CLSID;
#ifdef UNICODE
			HRESULT hres = OLE32::IIDFromString(const_cast<ICHAR*>((const ICHAR*)strData), pclsid);
#else
			CTempBuffer<WCHAR, cchMaxCLSID> wsz; /* Buffer for unicode string */
			int iReturn = WIN::MultiByteToWideChar(CP_ACP, 0, (const ICHAR*)strData, strData.TextSize() + 1, wsz, strData.TextSize() + 1);
			HRESULT hres = OLE32::IIDFromString(wsz, pclsid);
#endif
			if (pclsid)
				delete pclsid;
			if (hres == S_OK)
			{
				if (fKey)
					iForeignKeyMask |= 1 << (iCol - 1);
				return iveNoError;
			}
			iveStat = iveBadGuid;
		}
	}
	else if (IStrComp(strCategory, szRegPath) == 0)	// RegPath string
	{
		ICHAR rgDoubleSeps[] = {chRegSep, chRegSep, '\0'};

		if (strData.Compare(iscStart, szRegSep) || strData.Compare(iscEnd, szRegSep) ||
			strData.Compare(iscWithin, rgDoubleSeps))
			iveStat = iveBadRegPath; // cannot begin/end with a '\' and can't have 2 in a row
		else if (GetProperties((const ICHAR*)strData, fTrue /*fFormatted*/, fTrue /*fKeyAllowed*/, iCol, iForeignKeyMask))
			return iveNoError;
		iveStat = iveBadRegPath;
	}
	else if (IStrComp(strCategory, szLanguage) == 0)	// Language string
	{
		Bool fLangStat = fTrue;
		int iLangId;
		MsiString strLangId = (const ICHAR*)0;
		while (strData.TextSize())
		{
			strLangId = strData.Extract(iseUptoTrim, TEXT(','));
			if ((iLangId = int(strLangId)) == iMsiStringBadInteger || iLangId & iMask)
			{
				fLangStat = fFalse; // invalid (lang id bad)
				break; // short-circuit loop, we're already invalid
			}
			if (!strData.Remove(iseIncluding, TEXT(',')))
				break;
		}
		if (fLangStat)
			return iveNoError;
		iveStat = iveBadLanguage;
	}
	else if (IStrComp(strCategory, szAnyPath) == 0)	// AnyPath string
	{
		if (strData.Compare(iscWithin, TEXT("|")))
		{
			// only filenames (parent-relative paths) are supported with a pipe.
			MsiString strSFN = strData.Extract(iseUpto, '|');
			if (ifvsValid != CheckFilename(strSFN, fFalse /*fLFN*/))
				iveStat = iveBadPath;
			else
			{
				// validate LFN
				MsiString strLFN = strData.Extract(iseLast, strData.CharacterCount() - strSFN.CharacterCount() -1);
				if (ifvsValid != CheckFilename(strLFN, fTrue/*fLFN*/))
					iveStat = iveBadPath;
			}
		}
		else
		{
			if (!ParsePath(strData, true /*fRelative*/))
				iveStat = iveBadPath;
		}
	}
	else if (IStrComp(strCategory, szPaths) == 0)	// Delimited set of Paths string
	{
		Bool fPathsStat = fTrue;
		MsiString strPath = (const ICHAR*)0;
		while (strData.TextSize())
		{
			// Darwin supports SFN or LFN in the path data type. Only blatantly
			// bad things can be checked here, because darwin will often ignore
			// bogus paths or generate SFN versions
			strPath = strData.Extract(iseUptoTrim, ';');
			if (!ParsePath(strPath, false /*fRelative*/))
			{
				fPathsStat = fFalse; // invalid (bad path)
				break;
			}
			if (!strData.Remove(iseIncluding, ';'))
				break;
		}
		if (fPathsStat)
			return iveNoError;
		iveStat = iveBadPath;
	}
	else if (IStrComp(strCategory, szURL) == 0) // URL string
	{
		// is it URL syntax?
		if (!IsURL((const ICHAR*)strData, 0))
			iveStat = iveBadPath; // invalid
		else
		{
			// try and canonicalize it
			ICHAR szURL[MAX_PATH+1] = TEXT("");
			DWORD cchURL = MAX_PATH;
			if (!MsiCanonicalizeUrl((const ICHAR*)strData, szURL, &cchURL, ICU_NO_ENCODE))
				iveStat = iveBadPath; // invalid -- could not canonicalize it
			else
				return iveNoError;
		}
	}
	else if (IStrComp(strCategory, szDefaultDir) == 0)	// DefaultDir string
	{
		// DefaultDir: roots may be 'identifier' or '%identifier'
		//             non-roots may be 'filename', '[identifier]', or [%identifier]
		int dtcDirParent = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblDirectory_colDirectoryParent));
		int dtcDirectory;
		if (dtcDirParent == 0)
		{
			// Repack SourceDirectory table
			dtcDirParent = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(szsdtcSourceParentDir));
			dtcDirectory = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(szsdtcSourceDir));
		}
		else
			dtcDirectory = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblDirectory_colDirectory));
		Assert(dtcDirParent);
		Assert(dtcDirectory);
		// Know that DirParent and Directory cols are identifiers...no integers, no offset
		Bool fRoot = (m_Data[dtcDirParent] != 0 && m_Data[dtcDirParent] != m_Data[dtcDirectory]) ? fFalse : fTrue;	
		if(fRoot)
		{
			// may be identifier or %identifier
			// %identifier ?
			if (strData.Compare(iscStart, TEXT("%")) != 0)
				strData.Remove(iseFirst, 1);
			// identifier ?
			if (CheckIdentifier((const ICHAR*)strData))
				return iveNoError;
			iveStat = iveBadDefaultDir;
		}
		else
		{
			int c = strData.Compare(iscWithin,TEXT(":")) ? 2 : 1;
			Bool fBad = fFalse;
			for(int i = 1; i <= c; i++)
			{
				// filename ?
				MsiString strFileName = strData.Extract((i == 1 ? iseUpto : iseAfter), ':');
				
				// is it only a period?  (dir located in parent w/out subdir)
				if (strFileName.Compare(iscExact, TEXT(".")))
					continue;
				
				if (!ParseFilename(strFileName, fFalse /*allow wildcards*/))
				{
					fBad = fTrue;
					break;
				}
			}
			if(fBad)
				iveStat = iveBadDefaultDir;
			else
				return iveNoError;
		}
	}
	else if (IStrComp(strCategory, szVersion) == 0)	// Version string
	{
		// Per bug 8122, the requirement for having a language column is completely removed from the
		// "Version" data type. This check will be moved to an ICE. Thus we only check the
		// #####.#####.#####.##### format.
		const ICHAR* pchVersion = (const ICHAR*)strData;

		// can't have a '.' at the beginning
		if (*pchVersion == '.')
		{
			iveStat = iveBadVersion;
		}
		else
		{
			for (unsigned int ius = 0; ius < 4; ius++)
			{
				// convert the string of digits into a number
				long lVerNum = 0;
				int cChars = 0;
				while (*pchVersion != 0 && *pchVersion != '.')
				{
					if (!FIsdigit(*pchVersion) || (++cChars > 5))
					{
						iveStat = iveBadVersion;
						break;
					}
					
					lVerNum *= 10;
					lVerNum += *pchVersion-'0';					
					pchVersion = ICharNext(pchVersion);
				}
			
				// hit the end of the string, a period, or a bogus character.
				if (lVerNum > 65535)
				{
					iveStat = iveBadVersion;
					break;
				}

				// If we hit a period make sure the next character is also
				// not a period or null
				if (*pchVersion == '.')
				{
					pchVersion = ICharNext(pchVersion);
					if (*pchVersion == 0 || *pchVersion == '.')
					{
						iveStat = iveBadVersion;
						break;
					}
				}
				else
					break; // bad character or end of string
			}
			// should be at the end of the string
			if (*pchVersion != 0)
				iveStat = iveBadVersion;
		}
		if (iveStat == iveNoError)
			return iveNoError;
	}
	else if (IStrComp(strCategory, szCabinet) == 0) // Cabinet string
	{
		const ICHAR* pch = (const ICHAR*)strData;
		if (*pch == '#')
		{
			// cabinet in stream must be a valid identifer
			strData.Remove(iseFirst, 1);
			if (CheckIdentifier(strData))
				return iveNoError;
		}
		else
		{
			if (ifvsValid == CheckWildFilename(strData, fTrue /*fLFN*/, fFalse /*allow wildcards*/))
				return iveNoError;
		}
		iveStat = iveBadCabinet;
	}
	else if (IStrComp(strCategory, szShortcut) == 0) // Shortcut string
	{
		if (strData.Compare(iscWithin, TEXT("[")) == 0)
		{
			iForeignKeyMask |= 1 << (iCol - 1); // foreign key to feature table
			if (CheckIdentifier((const ICHAR*)strData))
				return iveNoError;
		}
		else
		{
			if (GetProperties((const ICHAR*)strData, fTrue /*fFormatted*/, fTrue /*fKeyAllowed*/, iCol, iForeignKeyMask))
				return iveNoError;
		}
		iveStat = iveBadShortcut;
	}
	else if (IStrComp(strCategory, szCustomSource) == 0)	// CustomSource string
	{
		if (fRow)
		{
			int catcType = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(szcatcType));
			Assert(catcType);
			int icaFlags = int(m_Data[catcType]);

			if ((icaFlags & icaTypeMask) == icaInstall) // special source handling for nested install
				return iveNoError;  // custom validators take care of nested installs
			iForeignKeyMask |= 1 << (iCol - 1);
			if (CheckIdentifier((const ICHAR*)strData))
				return iveNoError;
			iveStat = iveBadCustomSource;
			return iveNoError;
		}
		else
			return iveNoError; // only field level so we have no way of knowing what type of CA
	}
	else if (IStrComp(strCategory, szWildCardFilename) == 0)	// WildCardFilename
	{
		if (ParseFilename(strData, fTrue /*allow wildcards*/))
			return iveNoError;
		iveStat = iveBadWildCard;
	}
	else if (IStrComp(strCategory, szText) == 0)	// Any String allowed
		return iveNoError;
	else if (IStrComp(strCategory, szPath) == 0)	// Path string
	{
		// only blatantly bad things can be checked here. Bogus paths
		// on one system may be valid on another, and Darwin will
		// often ignore them. DrLocator for example.
		if (ParsePath(strData, false /*fRelative*/))
			return iveNoError;
		iveStat = iveBadPath;
	}
	else if (IStrComp(strCategory, szUpperCase) == 0)	// Upper-case
	{
		// if it's bad case, immediately kick out.  However,
		// it may also have foreign keys.
		if (!CheckCase(strData, fTrue /*fUpperCase*/))
			return iveBadCase;
	}
	else if (IStrComp(strCategory, szLowerCase) == 0)	// Lower-case
	{
		if (CheckCase(strData, fFalse /*fUpperCase*/))
			return iveNoError;
		iveStat = iveBadCase;
	}
	else if (IStrComp(strCategory, szBinary) == 0)	// Stream -- should never happen
		return iveBadCategory;
	else if (strCategory.TextSize() > 0)	// Unsupported category string
		return iveBadCategory;

	// Check to see if can be an integer value
	int vtcMinValue = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colMinValue));
	Assert(vtcMinValue);
	int vtcMaxValue = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colMaxValue));
	Assert(vtcMaxValue);
	if ((riValidationCursor.GetInteger(vtcMinValue) != iMsiNullInteger || riValidationCursor.GetInteger(vtcMaxValue) != iMsiNullInteger)
		&& (int)strData != iMsiStringBadInteger)
	{
		if (CheckIntegerValue(riValidationTable, riValidationCursor, iCol, iForeignKeyMask, fVersionString))
			return iveNoError;
	}
	
	// Check to see if it is a member of the set
	int vtcSet = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colSet));
	Assert(vtcSet);
	if (riValidationCursor.GetInteger(vtcSet) != 0)
	{
		if (iveStat == iveNoError)
			iveStat = iveNotInSet;
		if (CheckSet(MsiString(riValidationCursor.GetString(vtcSet)), strData, fFalse /*fIntegerData*/))
			return iveNoError;
	}

	// Check to see if is an identifier for a foreign key
	if (fKey)
	{
		iForeignKeyMask |= 1 << (iCol - 1);
		if (CheckIdentifier((const ICHAR*)strData))
			return iveNoError;
	}
	return iveStat;
}

Bool CMsiCursor::SetRowState(iraEnum ira, Bool fState)
{
	if ((unsigned)ira >= (unsigned)iraSettableCount)
		return fFalse;
	if (fState)
		m_Data[0] |= 1 << (iRowBitShift + ira);
	else
		m_Data[0] &= ~(1 << (iRowBitShift + ira));
	return fTrue;
}

Bool CMsiCursor::GetRowState(iraEnum ira)
{
	return m_Data[0] & (1 << (iRowBitShift + ira)) ? fTrue : fFalse;
}

// notification from table when any row is deleted
// Does not block the database because all callers block/unblock.
void CMsiCursor::RowDeleted(unsigned int iRow, unsigned int iPrevNode)
{
	if (iRow == 0)
		Reset();
	else if (iRow <= m_iRow)
	{
		if (iRow == m_iRow--) // position to previous record
		{
			if (m_fTree)
				m_iRow = iPrevNode;  // previous node if tree walk cursor
			int fDirty = m_fDirty;  // null out any non-dirty fields
			MsiColumnDef* pColumnDef = m_pColumnDef;
			MsiTableData* pData = m_Data;
			pData[0] = iTreeInfoMask;  // flag refresh to not fetch previous record
			for (int iCol = 1; pColumnDef++, pData++, iCol <= m_rcColumns; iCol++, fDirty >>= 1)
			{
				if (*pData != 0 && !(fDirty & 1))
				{
					if (*pColumnDef & icdObject)
					{
						if (*pColumnDef & icdShort)  // string
							m_riDatabase.UnbindStringIndex(*pData);
						else  // object
						{
							int iData = m_Data[iCol];
							ReleaseObjectData(iData);
						}
					}
					*pData = 0;
				}
			}
		}
	}
	if (m_piNextCursor)
		m_piNextCursor->RowDeleted(iRow, iPrevNode);
}

// notification from table when any row is inserted causing data movement

void CMsiCursor::RowInserted(unsigned int iRow)
{
	if (iRow <= m_iRow)
		m_iRow++;
	if (m_piNextCursor)
		m_piNextCursor->RowInserted(iRow);
}

// notification from database when strings are persisted

void CMsiCursor::DerefStrings()
{
	MsiColumnDef* pColumnDef = m_pColumnDef;
	MsiTableData* pData = m_Data;
	for (int cCol = m_rcColumns; pColumnDef++, pData++, cCol-- > 0; )
	{
		if ((*pColumnDef & (icdObject|icdShort)) == (icdObject|icdShort))
			m_riDatabase.DerefTemporaryString(*pData);
	}
	if (m_piNextCursor)
		m_piNextCursor->DerefStrings();  // notify all cursors
}

// creates a stream object from storage using table and primary key for name

IMsiStream* CMsiCursor::CreateInputStream(IMsiStorage* piInputStorage)
{
	MsiString istrName(m_riDatabase.ComputeStreamName(m_riDatabase.DecodeStringNoRef(
										m_riTable.GetTableName()), m_Data+1, m_pColumnDef+1));
	IMsiStorage* piStorage;
	if (piInputStorage)
		piStorage = piInputStorage;
	else
		piStorage = m_riTable.GetInputStorage();

	if (!piStorage)
		return 0;
	IMsiStream* piStream = 0;
	IMsiRecord* piError = piStorage->OpenStream(istrName, fFalse, piStream);
	if (piError)
		piError->Release();
	return piStream;
}

Bool CMsiCursor::CheckNonNullColumns()
{
	MsiColumnDef* pColumnDef = m_pColumnDef;
	MsiTableData* pData = m_Data;
	for (int cCol = m_rcColumns; pColumnDef++, pData++, cCol-- > 0; )
		if (*pData == 0 && (*pColumnDef & (icdNullable|icdInternalFlag)) == 0)
			return fFalse;
	return fTrue;
}

// returns unique identifier for row, using database's ComputeStreamName method which creates a name
// having table.key1.key2... format
const IMsiString& CMsiCursor::GetMoniker()
{
	return (m_riDatabase.ComputeStreamName(m_riDatabase.DecodeStringNoRef(m_riTable.GetTableName()), m_Data+1, m_pColumnDef+1));
}

//____________________________________________________________________________
//
// CMsiTextKeySortCursor implementation
//____________________________________________________________________________

CMsiTextKeySortCursor::CMsiTextKeySortCursor(CMsiTable& riTable, CMsiDatabase& riDatabase, int cRows, int* rgiIndex)
	: CMsiCursor(riTable, riDatabase, fFalse), m_iIndex(0), m_cIndex(cRows), m_rgiIndex(rgiIndex)
{
	m_idsUpdate = idsNone;  // read-only cursor, cannot maintain index on update
}

unsigned long CMsiTextKeySortCursor::Release()
{
	if (m_Ref.m_iRefCnt == 1)
		delete m_rgiIndex;
	return CMsiCursor::Release();
}

int CMsiTextKeySortCursor::Next()
{
	if (m_iIndex < m_cIndex)
	{
		m_riDatabase.Block();
		int iRet = m_riTable.FetchRow(m_rgiIndex[m_iIndex++], m_Data);
		m_riDatabase.Unblock();
		return iRet;
	}
	Reset();
	return 0;
}

void CMsiTextKeySortCursor::Reset()
{
	m_iIndex = 0;
	CMsiCursor::Reset();
}



vtokEnum CMsiValConditionParser::Lex()
{
	if (m_fAhead || m_vtok == vtokEos)
	{
		m_fAhead = fFalse;
		return m_vtok;
	}
	ICHAR ch;   // skip white space
	while ((ch = *m_pchInput) == ' ' || ch == '\t')
		m_pchInput++;
	if (ch == 0)  // end of expression
		return (m_vtok = vtokEos);

	if (ch == '(')   // start of parenthesized expression
	{
		++m_pchInput;
		m_iParenthesisLevel++;
		return (m_vtok = vtokLeftPar);
	}
	if (ch == ')')   // end of parenthesized expression
	{
		++m_pchInput;
		m_vtok = vtokRightPar;
		if (m_iParenthesisLevel-- == 0)
			m_vtok = vtokError;
		return m_vtok;
	}
	if (ch == '"')  // text literal
	{
		const ICHAR* pch = ++m_pchInput;
		Bool fDBCS = fFalse;
		while ((ch = *m_pchInput) != '"')
		{
			if (ch == 0)
				return (m_vtok = vtokError);
#ifdef UNICODE
			m_pchInput++;
#else // !UNICODE
			const ICHAR* pchTemp = m_pchInput;
			m_pchInput = INextChar(m_pchInput);
			if (m_pchInput == pchTemp + 2)
				fDBCS = fTrue;
#endif // UNICODE
		}
//		Assert((m_pchInput - pch) <= INT_MAX);	//--merced: 64-bit ptr subtraction may lead to values too big for cch.
		int cch = (int)(INT_PTR)(m_pchInput++ - pch);
		memcpy(m_istrToken.AllocateString(cch, fDBCS), pch, cch * sizeof(ICHAR));
		m_iToken = iMsiNullInteger; // prevent compare as an integer
	}
	else if (ch == '-' || ch >= '0' && ch <= '9')  // integer
	{
		m_iToken = ch - '0';
		int chFirst = ch;  // save 1st char in case minus sign
		if (ch == '-')
			m_iToken = iMsiNullInteger; // check for lone minus sign

		while ((ch = *(++m_pchInput)) >= '0' && ch <= '9')
			m_iToken = m_iToken * 10 + ch - '0';
		if (m_iToken < 0)  // integer overflow or '-' with no digits
			return (m_vtok = vtokError);
		if (chFirst == '-')
			m_iToken = -m_iToken;
		m_istrToken = (const ICHAR*)0;
	}
	else if ((ch == '_') || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'))
	{
		const ICHAR* pch = m_pchInput;
		while (((ch = *m_pchInput) >= '0' && ch <= '9')
			  || (ch == '_')  // allow underscore??
			  || (ch == '.')  // allow period??
			  || (ch >= 'A' && ch <= 'Z')
			  || (ch >= 'a' && ch <= 'z'))
			m_pchInput++;
//		Assert((m_pchInput - pch) <= INT_MAX);	//--merced: 64-bit ptr subtraction may lead to values too big for cch.
		int cch = (int)(INT_PTR)(m_pchInput - pch);
		if (cch <= 3)  // check for text operators
		{
			switch((pch[0] | pch[1]<<8 | (cch==3 ? pch[2]<<16 : 0)) & 0xDFDFDF)
			{
			case 'O' | 'R'<<8:           return (m_vtok = vtokOr);
			case 'A' | 'N'<<8 | 'D'<<16: return (m_vtok = vtokAnd);
			case 'N' | 'O'<<8 | 'T'<<16: return (m_vtok = vtokNot);
			case 'X' | 'O'<<8 | 'R'<<16: return (m_vtok = vtokXor);
			case 'E' | 'Q'<<8 | 'V'<<16: return (m_vtok = vtokEqv);
			case 'I' | 'M'<<8 | 'P'<<16: return (m_vtok = vtokImp);
			};
		}
		memcpy(m_istrToken.AllocateString(cch, fFalse), pch, cch * sizeof(ICHAR));
		m_istrToken = (const ICHAR*)0;
		m_iToken = m_istrToken;
	}
	else if ( ch == '%' || ch == '$' || ch == '&' || ch == '?' || ch == '!' )
	{
		const ICHAR* pch = m_pchInput;
		m_pchInput++;
		if ((ch = *m_pchInput) == '_' || (ch >= 'A' && ch <= 'Z') || (ch >='a' && ch <= 'z'))
		{
			m_pchInput++;
			while (((ch = *m_pchInput) >= '0' && ch <= '9')
					|| (ch == '_') // allow underscore??
					|| (ch == '.') // allow period??
					|| (ch >= 'A' && ch <= 'Z')
					|| (ch >= 'a' && ch <= 'z'))
				m_pchInput++;
			m_istrToken = (const ICHAR*)0;
		}
		else
			return (m_vtok = vtokError);
	}
	else // check for operators
	{
		ICHAR ch1 = *m_pchInput++;
		if (ch1 == '~')  // prefix for string operators
		{
			m_iscMode = iscExactI;
			ch1 = *m_pchInput++;
		}
		else
			m_iscMode = iscExact;

		if (ch1 == '=')
			return (m_vtok = vtokEQ);

		ICHAR ch2 = *m_pchInput;
		if (ch1 == '<')
		{
			if (ch2 == '=')
			{
				m_vtok = vtokLE;
				m_pchInput++;
			}
			else if (ch2 == '>')
			{
				m_vtok = vtokNE;
				m_pchInput++;
			}
			else if (ch2 == '<')
			{
				m_vtok = vtokLeft;
				m_iscMode = (iscEnum)(m_iscMode | iscStart);
				m_pchInput++;
			}
			else
				m_vtok = vtokLT;
		}
		else if (ch1 == '>')
		{
			if (ch2 == '=')
			{
				m_vtok = vtokGE;
				m_pchInput++;
			}
			else if (ch2 == '>')
			{
				m_vtok = vtokRight;
				m_iscMode = (iscEnum)(m_iscMode | iscEnd);
				m_pchInput++;
			}
			else if (ch2 == '<')
			{
				m_vtok = vtokMid;
				m_iscMode = (iscEnum)(m_iscMode | iscWithin);
				m_pchInput++;
			}
			else
				m_vtok = vtokGT;
		}
		else
			m_vtok = vtokError;

		return m_vtok;
	}
	return (m_vtok = vtokValue);
}



ivcpEnum CMsiValConditionParser::Evaluate(vtokEnum vtokPrecedence)
{
	ivcpEnum ivcStat = ivcpValid;
	if (Lex() == vtokEos || m_vtok == vtokRightPar)
	{
		UnLex();  // put back ')' in case of "()"
		return ivcpNone;
	}
	if (m_vtok == vtokNot) // only unary op valid here
	{
		switch(Evaluate(m_vtok))
		{
		case ivcpValid:  ivcStat = ivcpValid; break;
		default:       return ivcpInvalid;
		};
	}
	else if (m_vtok == vtokLeftPar)
	{
		ivcStat = Evaluate(vtokRightPar);
		if (Lex() != vtokRightPar) // parse off right parenthesis
			return ivcpInvalid;
		if (ivcStat == ivcpInvalid || ivcStat == ivcpNone)
			return ivcStat;
	}
	else
	{
		if (m_vtok != vtokValue)
			return ivcpInvalid;
		
		if (Lex() >= vtokValue)  // get next operator (or end)
			return ivcpInvalid;

		if (m_vtok <= vtokNot)  // logical op or end
		{
			UnLex();   // vtokNot is not allowed, caught below
			if (m_istrToken.TextSize() == 0
			&& (m_iToken == iMsiNullInteger || m_iToken == 0))
				ivcStat = ivcpValid;
		}
		else // comparison op
		{
			MsiString istrLeft = m_istrToken;
			int iLeft = m_iToken;
			vtokEnum vtok = m_vtok;
			iscEnum isc = m_iscMode;
			if (Lex() != vtokValue)  // get right operand
				return ivcpInvalid;
		}
	}
	for(;;)
	{
		vtokEnum vtok = Lex();
		if (vtok >= vtokNot)  // disallow NOT without op, comparison of terms
			return ivcpInvalid;

		if (vtok <= vtokPrecedence)  // stop at logical ops of <= precedence
		{
			UnLex();         // put back for next caller
			return ivcStat;  // return what we have so far
		}
		ivcpEnum ivcRight = Evaluate(vtok);
		if (ivcRight == ivcpNone || ivcRight == ivcpInvalid)
			return ivcpInvalid;
	}
}


//_______________________________________________________________________________________________________________________
//
// Validator functions
//_______________________________________________________________________________________________________________________

Bool CheckIdentifier(const ICHAR* szIdentifier)
/*-------------------------------------------------------------------------------------------
CheckIdentifer -- Evaluates the data in a column whose category in the _Validation
table is listed as Identifier.  A valid identifier can contain letters, digits, underbars,
or periods, but must begin with a letter or underbar.

  Returns:
	Bool fTrue (valid), fFalse (invalid)
--------------------------------------------------------------------------------------------*/
{
	if (szIdentifier == 0 || *szIdentifier == 0)
		return fFalse; // invalid (no string)

	if ((*szIdentifier >= 'A' && *szIdentifier <= 'Z') ||
		(*szIdentifier >= 'a' && *szIdentifier <= 'z') ||
		(*szIdentifier == '_'))
	{
		while (*szIdentifier != 0)
		{
			if ((*szIdentifier >= 'A' && *szIdentifier <= 'Z') ||
				(*szIdentifier >= 'a' && *szIdentifier<= 'z') ||
				(*szIdentifier >= '0' && *szIdentifier <= '9') ||
				(*szIdentifier == '_' || *szIdentifier == '.'))
				szIdentifier++; // okay to not use ICharNext, we know it's ASCII
			else
				return fFalse; // invalid (non-permitted char)
		}
		return fTrue;
	}
	return fFalse; // invalid (doesn't begin with a letter or underbar)
}



Bool CheckCase(MsiString& rstrData, Bool fUpperCase)
/*---------------------------------------------------------------------------------------------
CheckCase -- Evaluates data as to being of proper case.  The data must either be all upper-case
or all lower-case depending on the fUpperCase boolean.

  Returns:
	Bool fTrue (valid), fFalse (invalid)
------------------------------------------------------------------------------------------------*/
{
	MsiString strComparison = rstrData;
	if (fUpperCase)
		strComparison.UpperCase();
	else
		strComparison.LowerCase();
	return (IStrComp(rstrData, strComparison) == 0 ? fTrue : fFalse);
}

// Validation array of acceptable filename/folder characters
// This array is for the first 128 ASCII character codes.
// The first 32 are control character codes and are disallowed
// We set the bit if character is allowed
// First int is 32 control characters
// Second int is sp to ?
// Third int is @ to _
// Fourth int is ` to ASCII code 127 (Ctrl + BKSP)
const int rgiSFNValidChar[4] =
{
	0x00000000, // disallows control characters -- ^X, ^Z, etc.
	0x03ff63fa, // disallows sp " * + , / : ; < = > ?
	0xc7ffffff, // disallows [ \ ]
	0x6fffffff  // disallows | and ASCII code 127 (Ctrl + BKSP)
};

const int rgiLFNValidChar[4] =
{
	0x00000000, // disallows characters -- ^X, ^Z, etc.
	0x2bff7bfb, // disallows " * / : < > ?
	0xefffffff, // disallows backslash
	0x6fffffff  // disallows | and ASCII code 127 (Ctrl + BKSP)
};

const int cszReservedWords = 3;
// No DBCS characters can be in these reserved words in order for CheckFilename to work
const ICHAR *const pszReservedWords[cszReservedWords] = {TEXT("AUX"), TEXT("CON"), TEXT("PRN")};

// These are the Max and Min respectively of characters in the reserved words list above
// by checking against these, we can exit CheckFileName a bit faster.
const int cchMaxReservedWords = 3;
const int cchMinReservedWords = 3;

const int cchMaxShortFileName = 12;
const int cchMaxLongFileName = 255;
const int cchMaxSFNPreDotLength = 8;
const int cchMaxSFNPostDotLength = 3;
const int iValidChar = 127; // any char with ASCII code > 127 is valid in a filename

Bool ParseFilename(MsiString& strFile, Bool fWildCard)
/*-----------------------------------------------------------------------------------
ParseFilename -- parses a filename into particular short and long filenames dependent
 on whether SFN|LFN syntax specified.  If no '|', then assumes SFN only
 -------------------------------------------------------------------------------------*/
{
	ifvsEnum ifvs;
	if (strFile.Compare(iscWithin, TEXT("|")))
	{
		// SFN|LFN
		MsiString strFilename = strFile.Extract(iseUpto, '|');
		ifvs = CheckWildFilename(strFilename, fFalse /*fLFN*/, fWildCard);
		if (ifvsValid == ifvs)
		{
			strFilename = strFile.Extract(iseLast, strFile.CharacterCount()-strFilename.CharacterCount()-1);
			ifvs = CheckWildFilename(strFilename, fTrue /*fLFN*/, fWildCard);
		}
	}
	else  // no LFN specified
		ifvs = CheckWildFilename(strFile, fFalse /*fLFN*/, fWildCard);
	if (ifvsValid == ifvs)
		return fTrue;
	
	return fFalse;
}

// could be DBCS
ifvsEnum CheckFilename(const ICHAR* szFileName, Bool fLFN)
{
	return CheckWildFilename(szFileName, fLFN, fFalse /* fWildCard */);
}

// could be DBCS
ifvsEnum CheckWildFilename(const ICHAR* szFileName, Bool fLFN, Bool fWildCard)
/*----------------------------------------------------------------------------------
CheckWildFilename -- validates a particular filename (short)
 or long and returns an enum describing the error (or success)

  Returns one of ifvsEnum:
  ifvsValid --> valid, no error
  ifvsInvalidLength --> invalid length or not filename
  ifvsReservedWords --> filename has reserved words
  ifvsReservedChar --> filename has reserved char(s)
  ifvsSFNFormat --> invalid SFN format (8.3)
  ifvsLFNFormat --> invalid LFN format (all periods, must have one non-period char)
------------------------------------------------------------------------------------*/
{
	// variables
	const int* rgiValidChar;
	int cchMaxLen;

	// determine which to use...
	if (fLFN)
	{
		rgiValidChar = rgiLFNValidChar;
		cchMaxLen = cchMaxLongFileName;
	}
	else
	{
		rgiValidChar = rgiSFNValidChar;
		cchMaxLen = cchMaxShortFileName;
	}

	int cchName = 0;
	if (szFileName)
		cchName = CountChars(szFileName);
		
	//check length
	if (cchName < 1)
	{
		AssertSz(szFileName, "Null filename to CheckFileName");  //!! should we assert??
		return ifvsInvalidLength;
	}

	//check reserved words
	// We are making the assumption here that there are no DBCS characters in pszReservedWords
	// Thus if we find any in szFileName (cch != IStrLen in this case) we can skip this compare
	if (cchName == IStrLen(szFileName))
	{
		if (cchName <= cchMaxReservedWords && cchName >= cchMinReservedWords)
		{
			for (int csz=0; csz < cszReservedWords; csz++)
			{
				if (!IStrCompI(szFileName, pszReservedWords[csz]))
					return ifvsReservedWords;
			}
		}
	}

	//check invalid characters
	const ICHAR* pchFileName = szFileName;

	if (!fLFN && *pchFileName == '.') // leading dots are not allowed in SFN (are allowed in LFN)
		return ifvsReservedChar;

	int cch = 1;
	int cchPeriod = 0;
	Bool fNonPeriodChar = fFalse;
	int cWildCardCount[2] = {0, 0};

	do
	{
		// wildcards: For validation, ? must be a character, even if it is right before
		// the period in a SFN. We still allow for * to be 0
		if (fWildCard && (*pchFileName == '*'))
			// keep track of how many *'s we see.
			cWildCardCount[cchPeriod != 0]++;
		else if (fWildCard && (*pchFileName == '?'))
		{
			// eat char
		}
		else


		// Check for valid char
		// NOTE:  division finds location in rgiValidChar array and modulus finds particular bit
		if (((int)(*pchFileName)) < iValidChar && !(rgiValidChar[((int)(*pchFileName)) / (sizeof(int)*8)] & (1 << (((int)(*pchFileName)) % (sizeof(int)*8)))))
			return ifvsReservedChar;
		
		// Check here for too many periods
		if (fLFN == fFalse && *pchFileName == '.')
		{
			// If this is the first ., cchPeriod should be 0
			if (cchPeriod != 0)
			{
				// Otherwise, we have an error
				return ifvsSFNFormat;
			}
			cchPeriod = cch;
		}

		// LFN can't be all periods
		if (fLFN && !fNonPeriodChar && *pchFileName != '.')
			fNonPeriodChar = fTrue;

		cch++;
	}
	while ( *(pchFileName = ICharNext(pchFileName)) != 0);
	
	if (cchPeriod == 0)
		cchPeriod = cch;
	cch--;
	Assert(cch == cchName);

	if (fLFN && !fNonPeriodChar)
		return ifvsLFNFormat;

	if (fLFN == fFalse)
	{
		if((cchPeriod - cWildCardCount[0] - 1 > cchMaxSFNPreDotLength) ||
			(cch - cchPeriod - cWildCardCount[1] > cchMaxSFNPostDotLength))
			return ifvsSFNFormat;
	}

	// check for length limits
	if ( (fLFN == fTrue) &&
		 (cchName - cWildCardCount[0] - cWildCardCount[1] > cchMaxLen) )
		return ifvsInvalidLength;

	return ifvsValid;
}

Bool ParsePath(MsiString& rstrPath, bool fRelative)
/*--------------------------------------------------------------------------------
ParsePath -- Validates a path string.  Must be a full path.  Path can begin with
a drive letter [i.e. c:\], or a server/share specification [i.e. \\server\share],
or a drive property [i.e. [DRIVE]\].  The full path can end with a '\'  and
cannot contain '\' twice in a row [except at the beginning of a \\server\share
path]. All subpaths are validated as filenames/folders except for the server and
share, which are not validated because the rules are not universal (depend on
the network system). Properties must follow correct property syntax, and key
properties ($#!) are only allowed at the beginning of the path. URLs are NOT
allowed in this form of path.

  Returns:
	Bool fTrue (valid), fFalse (invalid)
----------------------------------------------------------------------------------*/
{
	const ICHAR *szDriveSep      = TEXT(":");
	const ICHAR *szOpenProperty  = TEXT("[");
	const ICHAR *szCloseProperty = TEXT("]");

	ICHAR rgDoubleSeps[3] = {chDirSep, chDirSep, '\0'};
	int iReqComponent = 0;

	MsiString strNewPath = rstrPath;
	if (strNewPath.Compare(iscStart, rgDoubleSeps) != 0)
	{
		// network syntax. Only remove the first '\' from the path. The other will be
		// ignored by the parser, but leaving it will cause the doublesep check to
		// catch things like "\\\server\share"
		strNewPath.Remove(iseFirst, 1);

		// A drive delimiter is now invalid and we must have at least
		// <something>\<something> before the path is considered valid. But as soon
		// as we hit a property, all bets are off.
		iReqComponent = 2;
	}

	if (strNewPath.Compare(iscWithin, rgDoubleSeps) != 0)
		return fFalse; // INVALID -- double seps

	if (strNewPath.Compare(iscEnd, szDirSep) != 0) // can end with a '\'
		strNewPath.Remove(iseLast, 1);
	
	if (iReqComponent == 0)
	{
		if (strNewPath.Compare(iscWithin, szDriveSep))
		{
			// we have a ':' somewhere. Its not valid for filenames, or properties,
			// so it must be the drive delimiter.
			MsiString strDrive = strNewPath.Extract(iseUptoTrim, *szDriveSep);
			strNewPath.Remove(iseIncluding, *szDriveSep);

			// after the ':' must be either nothing (path is c:), a dirsep (c:\...)
			// or a property (c:[myprop]). c:abc is not allowed (we are a path, not a
			// filename)
			if (strNewPath.TextSize() && !strNewPath.Compare(iscStart, szOpenProperty) &&
				!strNewPath.Compare(iscStart, szDirSep))
				return fFalse; // INVALID - bad stuff after drive letter

			// if the part before the ':' is more than one char, it has to be
			// a property or it is invalid
			if (strDrive.TextSize() > 1)
			{
				if (!strDrive.Compare(iscStart, szOpenProperty) ||
					!strDrive.Compare(iscEnd, szCloseProperty))
					return fFalse; // INVALID - bad drive letter
				strDrive.Remove(iseFirst, 1);
				strDrive.Remove(iseLast, 1);
				// Formatted determines whether [#] is valid. fKeyAllowed determines if $#!
				// is allowed. iCol and iForeignKeyMask are not needed.	Because we are before
				// the drive delimiter, a full path property is not valid, so we can eliminate
				// the $#! types.
				int iCol = 0;
				int iForeignKeyMask = 0;
				if (!ParseProperty(strDrive, fFalse /* fFormatted */, fFalse /* fKeyAllowed */, iCol, iForeignKeyMask))
					return fFalse; // INVALID - bad property
			}
			else
			{
				// part before the ':' is 0 or 1 chars.
				const ICHAR chDrive = *(const ICHAR *)strDrive;
				if (!((chDrive >= 'A' && chDrive <= 'Z') || (chDrive >= 'a' && chDrive <= 'z')))
					return fFalse; // INVALID - bad drive letter
			}
		}
		else
		{
			// not a network share or drive letter. If we don't allow relative paths
			// it must be a property (unless something goofy like A[ColonProperty]\temp, but
			// thats an extreme case.
			if (strNewPath.Compare(iscStart, szOpenProperty))
			{
				strNewPath.Remove(iseFirst, 1);
				if (!strNewPath.Compare(iscWithin, szCloseProperty))
					return fFalse;	// INVALID - not a property
				MsiString strProperty = strNewPath.Extract(iseUptoTrim, *szCloseProperty);
				strNewPath.Remove(iseIncluding, ']');
				// Formatted determines whether [#] is valid. fKeyAllowed determines if $#!
				// is allowed. iCol and iForeignKeyMask are not needed.	
				int iCol = 0;
				int iForeignKeyMask = 0;
				if (!ParseProperty(strProperty, fFalse /* fFormatted */, fTrue /* fKeyAllowed */, iCol, iForeignKeyMask))
					return fFalse; // INVALID -- bad property reference
			}
			else if (!fRelative)
				return fFalse; // INVALID - not a valid drive specification
		}
	}
		
	// the author can put properties anywhere, so all we can check are the validitiy
	// of property references and that none of the characters are bogus for
	// LFN filenames. If we do hit a property, all restrictions
	while (strNewPath.TextSize())
	{
		// if a dir separator, eat it and move on, we have already checked for double '\'
		if (strNewPath.Compare(iscStart, szDirSep))
		{
			strNewPath.Remove(iseFirst, 1);
			continue;
		}

		// unmatched brackets are left in the text. Only matched ones
		// define properties
		if (strNewPath.Compare(iscStart, szOpenProperty) && strNewPath.Compare(iscWithin, szCloseProperty))
		{
			// once we hit a property, anything that might have been required is not a requirement
			// anymore (because it could all be in the property)
			iReqComponent = 0;

			strNewPath.Remove(iseFirst, 1);
			MsiString strProperty = strNewPath.Extract(iseUptoTrim, *szCloseProperty);
			strNewPath.Remove(iseIncluding, ']');
			// Formatted determines whether [#] is valid. fKeyAllowed determines if $#!
			// is allowed. iCol and iForeignKeyMask are not needed.	$#! are not allowed
			// because we are not at the beginning of the path
			int iCol = 0;
			int iForeignKeyMask = 0;
			if (!ParseProperty(strProperty, fFalse /*fFormatted*/, fFalse /*fKeyAllowed*/, iCol, iForeignKeyMask))
				return fFalse;
			continue;
		}

		// can only validate up to the next property or dir sep char.
		int cchSep = 0;
		const ICHAR *pchCur = strNewPath;
		while ((*pchCur != chDirSep) && (*pchCur != *szOpenProperty) && (*pchCur))
		{
			pchCur = ICharNext(pchCur);
			cchSep++;
		}
		MsiString strSubPath;
		strSubPath = strNewPath.Extract(iseFirst, cchSep);
		strNewPath.Remove(iseFirst, cchSep);
	
		// string of chars. if we are currently requiring a server or share name, there's nothing
		// that we can validate, because the requirements are defined by the network service
		// provider
		if (iReqComponent)
		{
			iReqComponent--;
		}
		// otherwise, it can be anything that is a valid filename
		else if (ifvsValid != CheckFilename(strSubPath, fTrue /* fLFN */))
			return fFalse; // INVALID -- must be some bad chars
	}

	// unless we haven't satisfied the server\share requirement, this is valid
	return iReqComponent ? fFalse : fTrue;
}

Bool GetProperties(const ICHAR* szRecord, Bool fFormatted, Bool fKeyAllowed, int iCol, int& iForeignKeyMask)
/*-----------------------------------------------------------------------------------------------------------
GetProperties -- extracts properties from a data string.

  Returns:
	Bool fTrue (valid), fFalse (invalid)
	Updates iForeignKeyMask
-----------------------------------------------------------------------------------------------------------*/
{
	// Variables
	CTempBuffer<ICHAR,MAX_PATH> rgBuffer;
	int cBuffer = 0;
	ICHAR* pchOut = rgBuffer;
	const ICHAR* pchIn = szRecord;
	Bool fDoubleBrackets   = fFalse;          // whether [[variable]] setup
	Bool fFirstTime        = fTrue;           // first time in loop
	int cCurlyBrace        = 0;               // number of curly braces
	int cBracket           = 0;               // number of brackets


	// Count number of braces and brackets to make sure num left equal num right
	const ICHAR* pchPrev = 0;
	while (*pchIn != 0)
	{
		if (*pchIn == '{')
			cCurlyBrace++;
		else if (*pchIn == '}')
			cCurlyBrace--;
		else if (*pchIn == '[')
			cBracket++;
		else if (*pchIn == ']')
			cBracket--;
		else if (*pchIn == chDirSep)
		{
			if (pchPrev != 0 && *pchPrev == '[')
				pchIn = ICharNext(pchIn); // do a skip -- escape sequence, but we don't know what the escaped char is
		}
		pchPrev = pchIn;
		pchIn = ICharNext(pchIn);
	}
	if ((cCurlyBrace != 0) || (cBracket != 0))
		return fFalse; // INVALID -- brackets and braces don't match up

	// Reset pchIn
	pchIn = szRecord;

	// Grab out all properties in string and validate
	do
	{
		pchOut = rgBuffer;
		cBuffer = 0;

		if (fDoubleBrackets)
		{
			if (*pchIn != ']' && *pchIn != '[')
				return fFalse; // INVALID -- bad format [[variable]xx] or something similar
			if (*pchIn == ']')
			{	fDoubleBrackets = fFalse;
				++pchIn;
				continue;
			}
		}
		
		if (*pchIn != '[')
			pchIn = ICharNext(pchIn);
		else
		{
			pchIn++; // for '['
			while (*pchIn != 0 && *pchIn != ']')
			{
				// Check for double brackets
				if (fFirstTime && *pchIn == '[')
				{
					if (fDoubleBrackets)
						return fFalse; // INVALID -- bad property [[variable][[var] not allowed
					fDoubleBrackets = fTrue;
					pchIn++; // for '['
					
				}
				else if (*pchIn == '[')
					return fFalse; // brackets within brackets [xx[xxx]xx] or something similar
				else if (fFirstTime && *pchIn == chDirSep)
				{
#ifdef UNICODE
					if (cBuffer >= rgBuffer.GetSize()-2)
					{
						rgBuffer.Resize(rgBuffer.GetSize()*2);
						pchOut = static_cast<ICHAR *>(rgBuffer)+cBuffer;
					}
					*pchOut++ = *pchIn++;
					*pchOut++ = *pchIn++; // copy escape char
					cBuffer += 2;
#else // !UNICODE
					if (cBuffer >= rgBuffer.GetSize()-4)
					{
						rgBuffer.Resize(rgBuffer.GetSize()*2);
						pchOut = static_cast<ICHAR *>(rgBuffer)+cBuffer;
					}
					for (int i = 0; i < 2; i++)
					{
						const ICHAR* pchTemp = pchIn;
						*pchOut++ = *pchIn;
						cBuffer++;
						pchIn = ICharNext(pchIn);
						if (pchIn == pchTemp + 2)
						{
							cBuffer++;
							*pchOut++ = *(pchIn - 1); // for DBCS char
						}
					}
#endif // UNICODE
				}
				else
				{
#ifdef UNICODE
					if (cBuffer >= rgBuffer.GetSize()-1)
					{
						rgBuffer.Resize(rgBuffer.GetSize()*2);
						pchOut = static_cast<ICHAR *>(rgBuffer)+cBuffer;
					}
					*pchOut++ = *pchIn++;
					cBuffer++;
#else // !UNICODE
					if (cBuffer >= rgBuffer.GetSize()-2)
					{
						rgBuffer.Resize(rgBuffer.GetSize()*2);
						pchOut = static_cast<ICHAR *>(rgBuffer)+cBuffer;
					}

					const ICHAR* pchTemp = pchIn;
					*pchOut++ = *pchIn;
					pchIn = ICharNext(pchIn);
					if (pchIn == pchTemp + 2)
					{
						*pchOut++ = *(pchIn - 1); // for DBCS char
						cBuffer++;
					}
#endif // UNICODE
				}
				fFirstTime = fFalse;
			}

			if (*pchIn == 0)
				return fTrue; // No closing bracket, so valid.

			fFirstTime = fTrue; // reset
			*pchOut = '\0';
			pchIn++; // for ']'
			if (!ParseProperty(rgBuffer, fFormatted/*fFormatted*/, fKeyAllowed/*fKeyAllowed*/, iCol, iForeignKeyMask))
				return fFalse; // INVALID -- bad property
		}
	}
	while (*pchIn != 0);

	return fTrue; // VALID
}


Bool ParseProperty(const ICHAR* szProperty, Bool fFormatted, Bool fKeyAllowed, int iCol, int& iForeignKeyMask)
/*------------------------------------------------------------------------------------------------------------
ParseProperty -- validates property strings, [abc], [1], [#abc], [$abc]

  Returns:
	Bool fTrue (valid), fFalse (invalid)
	Updates iForeignKeyMask
-------------------------------------------------------------------------------------------------------------*/
{
	const ICHAR* pchProperty = szProperty;
	
	if (szProperty == 0 || *szProperty == 0)
		return fFalse; // INVALID -- no property

	if (*pchProperty == chFormatEscape) // Escape sequence prop
		return (IStrLen(szProperty) == 2) ? fTrue : fFalse;
	else if (*pchProperty == '$' || *pchProperty == '#' || *pchProperty == '!')
	{
		if (!fKeyAllowed)
			return fFalse; // INVALID -- not allowed in this property
		iForeignKeyMask |= 1 << (iCol -1);
	}
	
	if (*pchProperty == '%' || *pchProperty == '$' || *pchProperty == '#' || *pchProperty == '!')
	{
		MsiString strProperty(szProperty);
		strProperty.Remove(iseFirst, 1); // for '%'
		return CheckIdentifier((const ICHAR*)strProperty) ? fTrue : fFalse;
	}
	else if(*pchProperty == '~' && !*(pchProperty+1)) //!! multi_sz - we should create a new category
		return fTrue;
	else
	{
		// either identifier or integer prop (int only permitted w/ Template)
		MsiString strIdentifier(szProperty);
		if (int(strIdentifier) != iMsiStringBadInteger)
			return fFormatted ? fFalse : fTrue;
		return CheckIdentifier((const ICHAR*)strIdentifier) ? fTrue : fFalse;
	}
}



Bool CheckSet(MsiString& rstrSet, MsiString& rstrData, Bool fIntegerData)
/*------------------------------------------------------------------------------------
CheckSet -- checks to see if data string matches a value in the set string.

  Returns:
	Bool fTrue (valid -- match), fFalse (invalid -- no match)
-------------------------------------------------------------------------------------*/
{
	MsiString rstrSetValue = (const ICHAR*)0;
	while (rstrSet.TextSize())
	{
		rstrSetValue = rstrSet.Extract(iseUptoTrim, ';');
		if (fIntegerData && (int(rstrData) == int(rstrSetValue)))
				return fTrue;
		else if (!fIntegerData && (IStrComp(rstrSetValue, rstrData) == 0))
				return fTrue;
		if (!rstrSet.Remove(iseIncluding, ';'))
				break;
	}
	return fFalse;  // invalid (no match)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\diagnose.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       diagnose.cpp
//
//--------------------------------------------------------------------------

/* diagnose.cpp - diagnostic output facilities
____________________________________________________________________________*/

#include "precomp.h"
#include "_msiutil.h"
#include "_msinst.h"
#include "_assert.h"
#include "_diagnos.h"
#include "eventlog.h"
#include "_engine.h"

int g_dmDiagnosticMode         = -1; // -1 until set, then DEBUGMSG macro skips fn call if 0

extern scEnum g_scServerContext;
extern Bool   g_fCustomActionServer;
extern HINSTANCE        g_hInstance;     // Global:  Instance of DLL

const int cbOutputBuffer = 1100; // max size wsprintf supports (1025) + some extra (since we call wsprintf(szBuffer + XX))

void SetDiagnosticMode()
{
	g_dmDiagnosticMode = 0; // disable debugmsg's from GetIntegerPolicyValue
	int iDebugPolicy = GetIntegerPolicyValue(szDebugValueName, fTrue);
	if ( (iDebugPolicy & dpVerboseDebugOutput) == dpVerboseDebugOutput )
		g_dmDiagnosticMode = dmDebugOutput | dmVerboseDebugOutput; // iVerboseDebugOutput implies iDebugOutput
	else if ( (iDebugPolicy & dpDebugOutput) == dpDebugOutput )
		g_dmDiagnosticMode = dmDebugOutput;

	if(g_dwLogMode & INSTALLLOGMODE_VERBOSE || g_dwClientLogMode & INSTALLLOGMODE_VERBOSE)
		g_dmDiagnosticMode |= dmVerboseLogging;

	if(g_dmDiagnosticMode & dmVerboseLogging || g_dwLogMode & INSTALLLOGMODE_INFO ||
		g_dwClientLogMode & INSTALLLOGMODE_INFO)
		g_dmDiagnosticMode |= dmLogging;

	Assert((g_dmDiagnosticMode & dmDebugOutput) || !(g_dmDiagnosticMode & dmVerboseDebugOutput)); // verbose debugout => debugout
	Assert((g_dmDiagnosticMode & dmLogging) || !(g_dmDiagnosticMode & dmVerboseLogging));         // verbose logging => logging
}

bool FDiagnosticModeSet(int iMode)
{
	if(g_dmDiagnosticMode == -1)
		SetDiagnosticMode();
	return (g_dmDiagnosticMode & iMode) != 0;
}

const int cDebugStringArgs = 7; // number of argument strings to DebugString (including szMsg)

void DebugString(int iMode, WORD wEventType, int iEventLogTemplate,
					  LPCSTR szMsg, LPCSTR arg1, LPCSTR arg2, LPCSTR arg3, LPCSTR arg4, LPCSTR arg5, LPCSTR arg6)
{
	if(g_dmDiagnosticMode == -1)
	{
		SetDiagnosticMode();

		if(g_dmDiagnosticMode == 0)
			return;
	}

	if(((g_dmDiagnosticMode|dmEventLog) & iMode) == 0)
		return;

	static DWORD dwProcId = GetCurrentProcessId() & 0xFF;
	DWORD dwThreadId = GetCurrentThreadId() & 0xFF;
	DWORD dwEffectiveThreadId = MsiGetCurrentThreadId() & 0xFF;
	char szBuffer[cbOutputBuffer];

	const int cchPreMessage = 17; // "MSI (s) (##:##): "
	const char rgchServ[] = "MSI (s)";
	const char rgchCAServer[] = "MSI (a)";
	const char rgchClient[] = "MSI (c)";
	const char *pszContextString = NULL;
	switch (g_scServerContext)
	{
	case scService:
	case scServer:
		pszContextString = rgchServ;
		break;
	case scCustomActionServer:
		pszContextString = rgchCAServer;
		break;
	case scClient:
		pszContextString = rgchClient;
		break;
	}
	
	wsprintfA(szBuffer, "%s (%.2X%c%.2X): ",
				pszContextString, dwProcId, dwThreadId == dwEffectiveThreadId ? ':' : '!', dwEffectiveThreadId);

	if(iMode & dmEventLog)
	{
		const char* rgszArgs[cDebugStringArgs] = {szMsg, arg1, arg2, arg3, arg4, arg5, arg6};
		bool fEndLoop = false;
		WORD wLanguage = g_MessageContext.GetCurrentUILanguage();
		int iRetry = (wLanguage == 0) ? 1 : 0;
		while ( !fEndLoop )
		{
			if ( !MsiSwitchLanguage(iRetry, wLanguage) )
				fEndLoop = true;
			else
				fEndLoop = (0 != WIN::FormatMessageA(
											FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
											g_hInstance, iEventLogTemplate, wLanguage,
											szBuffer+cchPreMessage, (cbOutputBuffer-cchPreMessage),
											(va_list*)rgszArgs));
		}
	}
	else
	{
		wsprintfA(szBuffer+cchPreMessage, szMsg, arg1, arg2, arg3, arg4, arg5, arg6);
	}

	if(g_dmDiagnosticMode & (dmDebugOutput|dmVerboseDebugOutput) & iMode)
	{
		OutputDebugStringA(szBuffer);
		OutputDebugStringA("\r\n");
	}

	// only debug messages from the MainEngineThread or logged - to avoid hanging problems
	if((g_dmDiagnosticMode & (dmLogging|dmVerboseLogging) & iMode) &&
		 g_MessageContext.IsMainEngineThread())
	{
		int iOldMode = g_dmDiagnosticMode;
		g_dmDiagnosticMode = 0; // disable debugmsg's from Invoke
		g_MessageContext.LogDebugMessage(CApiConvertString(szBuffer));
		g_dmDiagnosticMode = iOldMode;
	}

	if(iMode & dmEventLog)
	{
		if (g_fWin9X)
			ReportToFakeEventLog(wEventType, CApiConvertString(szBuffer+cchPreMessage));
		else
			ReportToEventLog(wEventType,iEventLogTemplate,CApiConvertString(szMsg),CApiConvertString(arg1),CApiConvertString(arg2),CApiConvertString(arg3),CApiConvertString(arg4),CApiConvertString(arg5),CApiConvertString(arg6));
	}
}

void DebugString(int iMode, WORD wEventType, int iEventLogTemplate,
					  LPCWSTR szMsg, LPCWSTR arg1, LPCWSTR arg2, LPCWSTR arg3, LPCWSTR arg4, LPCWSTR arg5, LPCWSTR arg6)
{
	if(g_dmDiagnosticMode == -1)
	{
		SetDiagnosticMode();

		if(g_dmDiagnosticMode == 0)
			return;
	}

	if(((g_dmDiagnosticMode|dmEventLog) & iMode) == 0)
		return;

	static DWORD dwProcId = GetCurrentProcessId() & 0xFF;
	DWORD dwThreadId = GetCurrentThreadId() & 0xFF;
	DWORD dwEffectiveThreadId = MsiGetCurrentThreadId() & 0xFF;
	WCHAR szBuffer[cbOutputBuffer];
	
	const int cchPreMessage = 17; // "MSI (s) (##:##): "
	const WCHAR *pszContextString = NULL;
	const WCHAR rgchServ[] =     L"MSI (s)";
	const WCHAR rgchCAServer[] = L"MSI (a)";
	const WCHAR rgchClient[] =   L"MSI (c)";
	switch (g_scServerContext)
	{
	case scService:
	case scServer:
		pszContextString = rgchServ;
		break;
	case scCustomActionServer:
		pszContextString = rgchCAServer;
		break;
	case scClient:
		pszContextString = rgchClient;
		break;
	}
	
	wsprintfW(szBuffer, L"%s (%.2X%c%.2X): ",
				pszContextString, dwProcId, dwThreadId == dwEffectiveThreadId ? L':' : L'!', dwEffectiveThreadId);
	
	if(iMode & dmEventLog)
	{
		const WCHAR* rgszArgs[cDebugStringArgs] = {szMsg, arg1, arg2, arg3, arg4, arg5, arg6};
		bool fEndLoop = false;
		WORD wLanguage = g_MessageContext.GetCurrentUILanguage();
		int iRetry = (wLanguage == 0) ? 1 : 0;
		while ( !fEndLoop )
		{
			if ( !MsiSwitchLanguage(iRetry, wLanguage) )
				fEndLoop = true;
			else
				fEndLoop = (0 != WIN::FormatMessageW(
											FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
											g_hInstance, iEventLogTemplate, wLanguage,
											szBuffer+cchPreMessage,
											sizeof(szBuffer)/sizeof(WCHAR) - cchPreMessage,
											(va_list*)rgszArgs));
		}
	}
	else
	{
		wsprintfW(szBuffer+cchPreMessage, szMsg, arg1, arg2, arg3, arg4, arg5, arg6);
	}

	if(g_dmDiagnosticMode & (dmDebugOutput|dmVerboseDebugOutput) & iMode)
	{
		OutputDebugStringW(szBuffer);
		OutputDebugStringW(L"\r\n");
	}

	// only debug messages from the MainEngineThread or logged - to avoid hanging problems
	if((g_dmDiagnosticMode & (dmLogging|dmVerboseLogging) & iMode) &&
		 g_MessageContext.IsMainEngineThread())
	{
		int iOldMode = g_dmDiagnosticMode;
		g_dmDiagnosticMode = 0; // disable debugmsg's from Invoke
		g_MessageContext.LogDebugMessage(CApiConvertString(szBuffer));
		g_dmDiagnosticMode = iOldMode;
	}

	if(iMode & dmEventLog)
	{
		if (g_fWin9X)
			ReportToFakeEventLog(wEventType, CApiConvertString(szBuffer+cchPreMessage));
		else
			ReportToEventLog(wEventType,iEventLogTemplate,CApiConvertString(szMsg),CApiConvertString(arg1),CApiConvertString(arg2),CApiConvertString(arg3),CApiConvertString(arg4),CApiConvertString(arg5),CApiConvertString(arg6));
	}
}

const ICHAR* szFakeEventLog = TEXT("msievent.log");

HANDLE CreateFakeEventLog(bool fDeleteExisting=false)
{
	CAPITempBuffer<ICHAR, MAX_PATH> rgchTempDir;
	GetTempDirectory(rgchTempDir);
	rgchTempDir.Resize(rgchTempDir.GetSize() + sizeof(szFakeEventLog)/sizeof(ICHAR));
	IStrCat(rgchTempDir, szDirSep);
	IStrCat(rgchTempDir, szFakeEventLog);

	HANDLE hFile = CreateFile(rgchTempDir, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, 
									  0, fDeleteExisting ? CREATE_ALWAYS : OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (hFile == INVALID_HANDLE_VALUE)
		return INVALID_HANDLE_VALUE;

	if (WIN::SetFilePointer(hFile, 0, NULL, FILE_END) == 0xFFFFFFFF)
	{
		WIN::CloseHandle(hFile);
		return INVALID_HANDLE_VALUE;
	}
	return hFile;
}

const ICHAR rgchLFCR[2] = {'\r','\n'};

extern int LiveDate(ICHAR* rgchBuf, unsigned int cchBuf);
extern int LiveTime(ICHAR* rgchBuf, unsigned int cchBuf);

void ReportToFakeEventLog(WORD wEventType, const ICHAR* szBuffer)
{
	Assert(g_fWin9X);
	CHandle HLog = CreateFakeEventLog();
	if (HLog != INVALID_HANDLE_VALUE)
	{
		ICHAR rgchBuf[1025]; // max wsprintf supports

		const ICHAR* pchEvent;  // to keep the formatting pretty all the 'type' strings should be the same length
		switch (wEventType)
		{
		case EVENTLOG_SUCCESS:          pchEvent = TEXT("Success"); break;
		case EVENTLOG_ERROR_TYPE:       pchEvent = TEXT("Error  "); break;
		case EVENTLOG_WARNING_TYPE:     pchEvent = TEXT("Warning"); break;
		case EVENTLOG_INFORMATION_TYPE: pchEvent = TEXT("Info   "); break;
		default:                        pchEvent = TEXT("Unknown"); break;
		}

		int cchDate = LiveDate(rgchBuf, sizeof(rgchBuf)/sizeof(ICHAR));
		Assert(cchDate != 0xFFFFFFFF);
		
		rgchBuf[cchDate] = ' ';

		int cchTime = LiveTime((ICHAR*)rgchBuf+cchDate+1, sizeof(rgchBuf)/sizeof(ICHAR) - cchDate - 1);
		Assert(cchDate != 0xFFFFFFFF);

		wsprintf(rgchBuf + cchDate + 1 + cchTime, TEXT(" (%s) %s"), pchEvent, szBuffer);

		DWORD dwBytesWritten;
		for (int c = 0; c < 2; c++)
		{
			BOOL fResult = WIN::WriteFile(HLog, rgchBuf, lstrlen(rgchBuf)*sizeof(ICHAR), &dwBytesWritten, 0);
			if (fResult)
				fResult = WIN::WriteFile(HLog, rgchLFCR, sizeof(rgchLFCR), &dwBytesWritten, 0);

			if (!fResult)
			{
				HLog = CreateFakeEventLog(true);
				continue;
			}
			FlushFileBuffers(HLog);
			return;
		}
	}
}

void ReportToEventLog(WORD wEventType, int iEventLogTemplate, const ICHAR* szLogMessage, const ICHAR* szArg1, const ICHAR* szArg2, const ICHAR* szArg3, const ICHAR* szArg4, const ICHAR* szArg5, const ICHAR* szArg6)
{
	if (!g_fWin9X)
	{
		// Event log reporting is Windows NT only
		HANDLE hEventLog = RegisterEventSource(NULL,TEXT("MsiInstaller"));
		if (hEventLog)
		{
			const ICHAR* szLog[cDebugStringArgs] = {szLogMessage, szArg1, szArg2, szArg3, szArg4, szArg5, szArg6};
			ReportEvent(hEventLog,wEventType,0,iEventLogTemplate,NULL,cDebugStringArgs,0,(LPCTSTR*) szLog,0);
			DeregisterEventSource(hEventLog);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\except.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       except.cpp
//
//--------------------------------------------------------------------------

/* except.cpp - Exception handling implementation

Functions in this file support catching exceptions that are raised in 
our server. Most of this code comes from "Under the Hood" articles
by Matt Pietrek in the April and May 1997 issues of MSJ.
____________________________________________________________________________*/

#include "precomp.h" 
#include "_engine.h"
#include <eh.h>

#define _IMAGEHLP_SOURCE_  // prevent import def error
#include "imagehlp.h"

#ifndef NOEXCEPTIONS

void GenerateExceptionReport(EXCEPTION_RECORD* pExceptionRecord, CONTEXT* pCtx);
void GenerateExceptionReport(LPEXCEPTION_POINTERS pExceptionInfo);
int HandleException(LPEXCEPTION_POINTERS pExceptionInfo);
void ImagehlpStackWalk( PVOID lAddr, PCONTEXT pContext,ICHAR *pszBuf, int cchBuf );

typedef BOOL (__stdcall * STACKWALKPROC)
           ( DWORD, HANDLE, HANDLE, LPSTACKFRAME, LPVOID,
            PREAD_PROCESS_MEMORY_ROUTINE,PFUNCTION_TABLE_ACCESS_ROUTINE,
            PGET_MODULE_BASE_ROUTINE, PTRANSLATE_ADDRESS_ROUTINE );

typedef LPVOID (__stdcall *SYMFUNCTIONTABLEACCESSPROC)( HANDLE, DWORD );

typedef DWORD (__stdcall *SYMGETMODULEBASEPROC)( HANDLE, DWORD );

void GenerateExceptionReport(LPEXCEPTION_POINTERS pExceptionInfo)
{
        GenerateExceptionReport(pExceptionInfo->ExceptionRecord, pExceptionInfo->ContextRecord);
}

int HandleException(LPEXCEPTION_POINTERS /*pExceptionInfo*/)
{
        return EXCEPTION_CONTINUE_SEARCH;
}


//======================================================================
// Given an exception code, returns a pointer to a static string with a 
// description of the exception                                         
//======================================================================
LPTSTR GetExceptionString( DWORD dwCode )
{
    #define EXCEPTION( x ) case EXCEPTION_##x: return TEXT(#x);

    switch ( dwCode )
    {
        EXCEPTION( ACCESS_VIOLATION )
        EXCEPTION( DATATYPE_MISALIGNMENT )
        EXCEPTION( BREAKPOINT )
        EXCEPTION( SINGLE_STEP )
        EXCEPTION( ARRAY_BOUNDS_EXCEEDED )
        EXCEPTION( FLT_DENORMAL_OPERAND )
        EXCEPTION( FLT_DIVIDE_BY_ZERO )
        EXCEPTION( FLT_INEXACT_RESULT )
        EXCEPTION( FLT_INVALID_OPERATION )
        EXCEPTION( FLT_OVERFLOW )
        EXCEPTION( FLT_STACK_CHECK )
        EXCEPTION( FLT_UNDERFLOW )
        EXCEPTION( INT_DIVIDE_BY_ZERO )
        EXCEPTION( INT_OVERFLOW )
        EXCEPTION( PRIV_INSTRUCTION )
        EXCEPTION( IN_PAGE_ERROR )
        EXCEPTION( ILLEGAL_INSTRUCTION )
        EXCEPTION( NONCONTINUABLE_EXCEPTION )
        EXCEPTION( STACK_OVERFLOW )
        EXCEPTION( INVALID_DISPOSITION )
        EXCEPTION( GUARD_PAGE )
        EXCEPTION( INVALID_HANDLE )
    }

    // If not one of the "known" exceptions, try to get the string
    // from NTDLL.DLL's message table.

    static TCHAR szBuffer[512] = { 0 };

    FormatMessage(  FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                    GetModuleHandle( TEXT("NTDLL.DLL") ),
                    dwCode, 0, szBuffer, sizeof( szBuffer ), 0 );

    return szBuffer;
}


//==============================================================================
// Given a linear address, locates the module, section, and offset containing  
// that address.                                                               
//                                                                             
// Note: the szModule paramater buffer is an output buffer of length specified 
// by the len parameter (in characters!)                                       
//==============================================================================
BOOL GetLogicalAddress(
        PVOID addr, PTSTR szModule, DWORD len, DWORD& section, DWORD& offset )
{
    MEMORY_BASIC_INFORMATION mbi;

    if ( !VirtualQuery( addr, &mbi, sizeof(mbi) ) )
        return FALSE;

    UINT_PTR hMod = (UINT_PTR)mbi.AllocationBase;                               //--merced: changed DWORD to UINT_PTR, twice.
        
        if (!hMod)
                return FALSE;

    if ( !GetModuleFileName( (HMODULE)hMod, szModule, len ) )
        return FALSE;

    // Point to the DOS header in memory
    PIMAGE_DOS_HEADER pDosHdr = (PIMAGE_DOS_HEADER)hMod;

    // From the DOS header, find the NT (PE) header
    PIMAGE_NT_HEADERS pNtHdr = (PIMAGE_NT_HEADERS)(hMod + pDosHdr->e_lfanew);

    PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION( pNtHdr );

    UINT_PTR rva = (UINT_PTR)addr - hMod; // RVA is offset from module load address                             //--merced: changed DWORD to UINT_PTR, twice.

    // Iterate through the section table, looking for the one that encompasses
    // the linear address.
    for (   unsigned i = 0;
            i < pNtHdr->FileHeader.NumberOfSections;
            i++, pSection++ )
    {
        DWORD sectionStart = pSection->VirtualAddress;
        DWORD sectionEnd = sectionStart
                    + max(pSection->SizeOfRawData, pSection->Misc.VirtualSize);

        // Is the address in this section???
        if ( (rva >= (UINT_PTR)sectionStart) && (rva <= (UINT_PTR)sectionEnd) )         //--merced: added UINT_PTR, twice.
        {
            // Yes, address is in the section.  Calculate section and offset,
            // and store in the "section" & "offset" params, which were
            // passed by reference.
            section = i+1;
            offset = (unsigned long)(rva - (UINT_PTR)sectionStart);             //--merced: okay to convert. changed from <offset = rva - sectionStart;>
            return TRUE;
        }
    }

    return FALSE;   // Should never get here!
}

void GenerateExceptionReport(
    EXCEPTION_RECORD* pExceptionRecord, CONTEXT* pCtx)
{
        DEBUGMSG("Generating exception report.");
        ICHAR szDebugBuf[sizeof(g_MessageContext.m_rgchExceptionInfo)/sizeof(ICHAR)];
        ICHAR szShortBuf[255];
        
    // Start out with a banner
    IStrCopy(szDebugBuf, TEXT("=====================================================\r\n") );

    // First print information about the type of fault
    wsprintf(szShortBuf,   TEXT("Exception code: %08X %s\r\n"),
                pExceptionRecord->ExceptionCode,
                GetExceptionString(pExceptionRecord->ExceptionCode) );

        IStrCat(szDebugBuf, szShortBuf);

        // Now print the module

    ICHAR szFaultingModule[MAX_PATH];
    DWORD section, offset;
    if (GetLogicalAddress(  pExceptionRecord->ExceptionAddress,
                        szFaultingModule,
                        sizeof( szFaultingModule )/sizeof(ICHAR),
                        section, offset ))
        {
                wsprintf(szShortBuf, TEXT("Module: %s\r\n"), szFaultingModule );
                IStrCat(szDebugBuf, szShortBuf);
        }

        // Now print the function name

        IStrCat(szDebugBuf, TEXT("Function: "));

        Assert((LONG_PTR)pExceptionRecord->ExceptionAddress <= UINT_MAX);       //--merced: we typecast to long below, it better be in range
#ifdef DEBUG
        SzFromFunctionAddress(szShortBuf, (long)(LONG_PTR)(pExceptionRecord->ExceptionAddress));        //--merced: okay to typecast
#else // SHIP
        wsprintf(szShortBuf, TEXT("0x%x"), (long)(LONG_PTR)pExceptionRecord->ExceptionAddress);         //--merced: okay to typecast
#endif

        IStrCat(szDebugBuf, szShortBuf);
        IStrCat(szDebugBuf, TEXT("\r\n"));

        IStrCat(szDebugBuf, TEXT("=====================================================\r\n") );

    // Show the registers
    #ifdef _X86_  // Intel Only!
    wsprintf(szShortBuf,  TEXT("\r\nRegisters:\r\n") );
        IStrCat(szDebugBuf, szShortBuf);

    wsprintf(szShortBuf, TEXT("EAX:%08X  EBX:%08X  ECX:%08X  EDX:%08X  ESI:%08X  EDI:%08X\r\n"),
             pCtx->Eax, pCtx->Ebx, pCtx->Ecx, pCtx->Edx, pCtx->Esi, pCtx->Edi );
        IStrCat(szDebugBuf, szShortBuf);

    wsprintf(szShortBuf,  TEXT("CS:EIP:%04X:%08X "), pCtx->SegCs, pCtx->Eip );
        IStrCat(szDebugBuf, szShortBuf);
    wsprintf(szShortBuf,  TEXT("SS:ESP:%04X:%08X  EBP:%08X\r\n"),
              pCtx->SegSs, pCtx->Esp, pCtx->Ebp );
        IStrCat(szDebugBuf, szShortBuf);
    wsprintf(szShortBuf,  TEXT("DS:%04X  ES:%04X  FS:%04X  GS:%04X\r\n"),
              pCtx->SegDs, pCtx->SegEs, pCtx->SegFs, pCtx->SegGs );
        IStrCat(szDebugBuf, szShortBuf);
    wsprintf(szShortBuf,  TEXT("Flags:%08X\r\n"), pCtx->EFlags );
        IStrCat(szDebugBuf, szShortBuf);
    #endif

        ImagehlpStackWalk( pExceptionRecord->ExceptionAddress, pCtx, szDebugBuf + IStrLen(szDebugBuf), sizeof(szDebugBuf)/sizeof(ICHAR) - IStrLen(szDebugBuf));

        LogAssertMsg(szDebugBuf);
        IStrCopyLen(g_MessageContext.m_rgchExceptionInfo, szDebugBuf, sizeof(g_MessageContext.m_rgchExceptionInfo)/sizeof(ICHAR) - 1);
}

//============================================================
// Walks the stack, and returns the results in a string
// Mostly taken from Matt Pietrek's MSJ article
//============================================================
void ImagehlpStackWalk( PVOID lAddr, PCONTEXT pContext,ICHAR *pszBuf, int cchBuf )
{
        STACKWALKPROC   _StackWalk = 0;
        SYMFUNCTIONTABLEACCESSPROC      _SymFunctionTableAccess = 0;
        SYMGETMODULEBASEPROC    _SymGetModuleBase = 0;
        ICHAR szShortBuf[255];
        BOOL fQuit = 0;
        
        HMODULE hModImagehlp = LoadLibrary( TEXT("Imagehlp.dll"));
        if (hModImagehlp == 0)
                return;
                
        _StackWalk = (STACKWALKPROC)GetProcAddress( hModImagehlp, "StackWalk" );
        if ( !_StackWalk )
            return;

        _SymFunctionTableAccess = (SYMFUNCTIONTABLEACCESSPROC)
                            GetProcAddress( hModImagehlp, "SymFunctionTableAccess" );

        if ( !_SymFunctionTableAccess )
            return;

        _SymGetModuleBase=(SYMGETMODULEBASEPROC)GetProcAddress( hModImagehlp,
                                                                "SymGetModuleBase");
        if ( !_SymGetModuleBase )
            return;
            
    IStrCopy( pszBuf, TEXT("\r\nCall stack:\r\n") );

    IStrCat( pszBuf, TEXT("Address   Frame\r\n") );

        cchBuf -= IStrLen(pszBuf);
        
    // Could use SymSetOptions here to add the SYMOPT_DEFERRED_LOADS flag

    STACKFRAME sf;
    memset( &sf, 0, sizeof(sf) );

        Assert((UINT_PTR) lAddr < UINT_MAX);                                    //--merced: we typecast below to DWORD, lAddr better be in range
    // Initialize the STACKFRAME structure for the first call.  This is only
    // necessary for Intel CPUs, and isn't mentioned in the documentation.
    sf.AddrPC.Offset       = (DWORD)(UINT_PTR)lAddr;            //--merced: added (UINT_PTR). okay to typecast.
    sf.AddrPC.Mode         = AddrModeFlat;
#ifdef _X86_  // Intel Only!
    sf.AddrStack.Offset    = pContext->Esp;
    sf.AddrStack.Mode      = AddrModeFlat;
    sf.AddrFrame.Offset    = pContext->Ebp;
    sf.AddrFrame.Mode      = AddrModeFlat;
#elif _WIN64    //!!merced: tofix this.
#else
#pragma error("Only built for x86 and IA64");
#endif
    

    while ( !fQuit )
    {
        if ( ! _StackWalk(  
#ifdef _X86_
                                                IMAGE_FILE_MACHINE_I386,
#elif _ALPHA_
                                                        IMAGE_FILE_MACHINE_ALPHA,
#elif _WIN64    //!!merced: copied over i386 to get compilation going. tofix this.
                                                IMAGE_FILE_MACHINE_I386,
#else
#pragma error("Only built for Alpha and x86");
#endif
                            GetCurrentProcess(),
                            GetCurrentThread(),
                            &sf,
                            pContext,
                            0,
                            _SymFunctionTableAccess,
                            _SymGetModuleBase,
                            0 ) )
            break;

        if ( 0 == sf.AddrFrame.Offset ) // Basic sanity check to make sure
            break;                      // the frame is OK.  Bail if not.

        // IMAGEHLP is wacky, and requires you to pass in a pointer to an
        // IMAGEHLP_SYMBOL structure.  The problem is that this structure is
        // variable length.  That is, you determine how big the structure is
        // at runtime.  This means that you can't use sizeof(struct).
        // So...make a buffer that's big enough, and make a pointer
        // to the buffer.  We also need to initialize not one, but TWO
        // members of the structure before it can be used.

        BYTE symbolBuffer[ sizeof(IMAGEHLP_SYMBOL) + 512 ];
        PIMAGEHLP_SYMBOL pSymbol = (PIMAGEHLP_SYMBOL)symbolBuffer;
        pSymbol->SizeOfStruct = sizeof(symbolBuffer);
        pSymbol->MaxNameLength = 512;
        ICHAR szSymName[256];
                        
        DWORD symDisplacement = 0;  // Displacement of the input address,
                                    // relative to the start of the symbol

#ifdef DEBUG
        SzFromFunctionAddress(szSymName, sf.AddrPC.Offset);
#else // SHIP
                        wsprintf(szSymName, TEXT("0x%x"), sf.AddrPC.Offset);
#endif

        wsprintf(szShortBuf, TEXT("%08X  %08X %hs\r\n -- 0x%08X 0x%08X 0x%08X 0x%08X\r\n"), sf.AddrPC.Offset, sf.AddrFrame.Offset, szSymName,
                                                                                                                sf.Params[0], sf.Params[1], sf.Params[2], sf.Params[3]);

        if ((cchBuf -= IStrLen(szShortBuf)) < 0)
                return;

        IStrCat(pszBuf, szShortBuf);
    }

}


#endif // NOEXCEPTIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\engine.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       engine.cpp
//
//--------------------------------------------------------------------------

/* engine.cpp - IMsiEngine implementation

IMsiSelectionManager and IMsiDirectoryManager implemented as part of CMsiEngine
____________________________________________________________________________*/

#include "precomp.h"
#include "msi.h"
#include "msidefs.h"
#include "eventlog.h"
#ifdef CONFIGDB
#include "configdb.h"
#endif
#include "vertrust.h"
#define AUTOAPI  // temp. until autoapi.cpp fully integrated
#ifdef AUTOAPI   // merge OLE registration
#define DllRegisterServer   DllRegisterServerTest
#define DllUnregisterServer DllUnregisterServerTest
#define DllGetClassObject   DllGetClassObjectTest
#endif // AUTOAPI
#ifdef AUTOAPI
#endif // AUTOAPI
// definitions required for module.h, for entry points and registration
// array order: services, debug services, engine, debug engine
#if defined(DEBUG)
#define SERVICES_CLSID_MULTIPLE 2
#else
#define SERVICES_CLSID_MULTIPLE 1
#endif
#define  SERVICES_CLSID_COUNT 2  // IMsiServices + IMsiServicesAsService
#define    ENGINE_CLSID_COUNT 8  // IMsiEngine + IMsiConfigurationManager + IMsiMessage + IMsiExecute + IMsiServerProxy + IMsiConfigManagerAsServer + IMsiCustomAction + IMsiRemoteAPI
# ifdef DEBUG
#define     DEBUG_CLSID_COUNT 3  // IMsiEngineDebug + IMsiConfigManagerDebug + IMsiConfigMgrAsServerDebug
# else
#define     DEBUG_CLSID_COUNT 0
# endif
#ifdef CONFIGDB
# define CLSID_COUNT (1 + ENGINE_CLSID_COUNT + DEBUG_CLSID_COUNT + SERVICES_CLSID_COUNT * SERVICES_CLSID_MULTIPLE)
#else
# define CLSID_COUNT (ENGINE_CLSID_COUNT + DEBUG_CLSID_COUNT + SERVICES_CLSID_COUNT * SERVICES_CLSID_MULTIPLE)
#endif // CONFIGDB
#define PROFILE_OUTPUT      "msiengd.mea";
#define MODULE_CLSIDS       rgCLSID         // array of CLSIDs for module objects
#define MODULE_PROGIDS      rgszProgId      // ProgId array for this module
#define MODULE_DESCRIPTIONS rgszDescription // Registry description of objects
#define MODULE_FACTORIES    rgFactory       // factory functions for each CLSID
#define cmitObjects  9
#define IN_SERVICES
#define MEM_SERVICES

#define MODULE_TERMINATE  TerminateModule
#define MODULE_INITIALIZE InitializeModule

extern "C" HRESULT __stdcall ProxyDllGetClassObject(const GUID& clsid, const IID& iid, void** ppvRet);
#define PRE_CLASS_FACTORY_HANDLER       ProxyDllGetClassObject

#define ASSERT_HANDLING  // instantiate assert services once per module

#include "module.h"   // self-reg and assert functions, includes version.h

#include "_assert.h"

#include "_engine.h"
#include "_msinst.h"
#include "_msiutil.h"
#include "_srcmgmt.h"
#include "_fcache.h"
#include <srrestoreptapi.h>
#include "tables.h" // table and column name definitions
#include "fusion.h"
#include "_camgr.h"

const IMsiString& GetInstallerMessage(UINT iError);  // in action.cpp

INSTALLSTATE MapInternalInstallState(iisEnum iis);  // in msiquery.cpp

// MAINTAIN: compatibility with versions used to create database
// change project version by using SADMIN setpv MAJOR.minor
const int iVersionEngineMinimum = 30;            // 0.30
const int iVersionEngineMaximum = rmj*100 + rmm; // MAJOR.minor
const int iComponentCostWeight = 25;    // For the costing/script generation progress bar
const int iMinimumPackage64Schema = 150; // Intel64 packages must be minimum schema 150

// identifier prefix characters, else defaults to property name

const ICHAR ichFileTablePrefixSFN = TEXT('!');  // FormatText
const ICHAR ichFileTablePrefix = TEXT('#');  // FormatText
const ICHAR ichComponentPath   = TEXT('$');  // FormatText
const ICHAR ichComponentAction = TEXT('$');  // EvaluateCondition
const ICHAR ichComponentState  = TEXT('?');  // EvaluateCondition
const ICHAR ichFeatureAction   = TEXT('&');  // EvaluateCondition
const ICHAR ichFeatureState    = TEXT('!');  // EvaluateCondition
const ICHAR ichEnvirPrefix     = TEXT('%');  // FmtText, EvalCnd, Get/SetProperty
const ICHAR ichNullChar        = TEXT('~');  // FormatText

//____________________________________________________________________________

const GUID IID_IUnknown                 = GUID_IID_IUnknown;
const GUID IID_IClassFactory            = GUID_IID_IClassFactory;
const GUID IID_IMarshal                                 = GUID_IID_IMarshal;
const GUID IID_IMsiExecute = GUID_IID_IMsiExecute;
const GUID IID_IMsiServices             = GUID_IID_IMsiServices;
const GUID IID_IMsiServicesAsService    = GUID_IID_IMsiServicesAsService;
const GUID IID_IMsiMessage              = GUID_IID_IMsiMessage;
const GUID IID_IMsiSelectionManager     = GUID_IID_IMsiSelectionManager;
const GUID IID_IMsiDirectoryManager     = GUID_IID_IMsiDirectoryManager;
#ifdef CONFIGDB
const GUID IID_IMsiConfigurationDatabase= GUID_IID_IMsiConfigurationDatabase;
#endif // CONFIGDB
#ifdef DEBUG
const GUID IID_IMsiServicesDebug        = GUID_IID_IMsiServicesDebug;
const GUID IID_IMsiServicesAsServiceDebug=GUID_IID_IMsiServicesAsServiceDebug;
#endif //DEBUG

const GUID IID_IMsiServerUnmarshal              = GUID_IID_IMsiServerUnmarshal;

// Date formatting definitions
const int  rgcbDate[6] = { 7, 4, 5, 5, 6, 5 };  // bits for each date field
const char rgchDelim[6] = "// ::";

const int imtForceLogInfo     = imtInfo + imtIconError;      // forces info record to log, even if not logging info
const int imtDumpProperties   = imtInternalExit + imtYesNo;  // query for property dump log mode


const ICHAR szControlTypeEdit[]           = TEXT("Edit");

const ICHAR szPropertyDumpTemplate[]      = TEXT("Property(%c): [1] = [2]");

const ICHAR szTemporaryId[]               = TEXT("Temporary Id");
enum ircEnum
{
	ircFeatureClass,
	ircComponentClass,
	ircFileClass,
	ircNextEnum
};


const ICHAR * mpeftSz[ieftMax] =
{
	sztblFile_colFile,
	sztblFile_colComponent,
	sztblFile_colAttributes,
	sztblFile_colFileName
};

const ICHAR szFeatureSelection[]      = TEXT("_MSI_FEATURE_SELECTION");
const ICHAR szFeatureDoNothingValue[] = TEXT("_NONE_");

struct FeatureProperties
{
	const ICHAR* szFeatureActionProperty;
	ircEnum ircRequestClass;
	iisEnum iisFeatureRequest;
};

const FeatureProperties g_rgFeatures[] =
{
	IPROPNAME_FEATUREADDLOCAL,     ircFeatureClass,   iisLocal,
	IPROPNAME_FEATUREREMOVE,       ircFeatureClass,   iisAbsent,
	IPROPNAME_FEATUREADDSOURCE,    ircFeatureClass,   iisSource,
	IPROPNAME_FEATUREADDDEFAULT,   ircFeatureClass,   iisCurrent,
	IPROPNAME_REINSTALL,           ircFeatureClass,   iisReinstall,
	IPROPNAME_FEATUREADVERTISE,    ircFeatureClass,   iisAdvertise,
	IPROPNAME_COMPONENTADDLOCAL,   ircComponentClass, iisLocal,
	IPROPNAME_COMPONENTADDSOURCE,  ircComponentClass, iisSource,
	IPROPNAME_COMPONENTADDDEFAULT, ircComponentClass, iisLocal,
	IPROPNAME_FILEADDLOCAL,        ircFileClass,      iisLocal,
	IPROPNAME_FILEADDSOURCE,       ircFileClass,      iisSource,
	IPROPNAME_FILEADDDEFAULT,      ircFileClass,      iisLocal,
};

const int g_cFeatureProperties = sizeof(g_rgFeatures)/sizeof(FeatureProperties);

int		g_fSmartShell = -1;  // indicate unchecked as yet
bool	g_fRunScriptElevated = false; // This is exactly the same flag as
									  // CMsiEngine::m_fRunScriptElevated and
									  // CMsiExecute::m_fRunScriptElevated.
									  // It's needed by MsiGetDiskFreeSpace.
									  // It had to be set wherever m_fRunScriptElevated
									  // is set.

HINSTANCE g_hMsiMessage = 0;  // MSI message DLL, only if required
extern DWORD g_dwImpersonationSlot;
extern Bool IsTerminalServerInstalled();
extern bool LoadCurrentUserKey(bool fSystem);
IMsiRegKey* g_piSharedDllsRegKey    = 0;
IMsiRegKey* g_piSharedDllsRegKey32  = 0;	// initialized only on Win64 (to the redirected 32-bit key)
CWin64DualFolders g_Win64DualFolders;


#ifdef UNICODE
#define _ttoi64     _wtoi64
#define _i64tot     _i64tow
#else
#define _ttoi64     _atoi64
#define _i64tot     _i64toa
#endif // UNICODE


// components needed to be special cased for app compat fixes 350947 and 368867
const ICHAR TTSData_A95D6CE6_C572_42AA_AA7B_BA92AFE9EA24[]          = TEXT("{EAE142B2-F460-44AB-903B-C25D81FC566E}");
const ICHAR SapiCplHelpEng_0880F209_45FA_42C5_92AE_5E620033E8EC[]	= TEXT("{E1ABFC3B-9E84-4099-A79F-E51EDE5368E2}");
const ICHAR SapiCplHelpJpn_0880F209_45FA_42C5_92AE_5E620033E8EC[]	= TEXT("{0D6004A4-1C6F-4095-B989-87D0001E4767}");
const ICHAR SapiCplHelpChs_0880F209_45FA_42C5_92AE_5E620033E8EC[]	= TEXT("{5F1AAAD1-7FD5-4A91-8973-C08881C9B602}");

//____________________________________________________________________________
//
// COM objects produced by this module's class factories
//____________________________________________________________________________

const GUID rgCLSID[CLSID_COUNT] =
{
	GUID_IID_IMsiServices,
	GUID_IID_IMsiServicesAsService,
#ifdef DEBUG
	GUID_IID_IMsiServicesDebug,
	GUID_IID_IMsiServicesAsServiceDebug,
#endif
	GUID_IID_IMsiEngine
 , GUID_IID_IMsiConfigurationManager
 , GUID_IID_IMsiMessage
 , GUID_IID_IMsiExecute
 , GUID_IID_IMsiServerProxy
 , GUID_IID_IMsiConfigManagerAsServer
 , GUID_IID_IMsiCustomActionProxy
 , GUID_IID_IMsiRemoteAPIProxy
#ifdef CONFIGDB
 , GUID_IID_IMsiConfigurationDatabase
#endif // CONFIGDB
#ifdef DEBUG
 , GUID_IID_IMsiEngineDebug
 , GUID_IID_IMsiConfigManagerDebug
 , GUID_IID_IMsiConfigMgrAsServerDebug
#endif
//  , GUID_IID_IMsiMessageUnmarshal
};
const GUID& IID_IMsiEngineShip  = rgCLSID[SERVICES_CLSID_COUNT * SERVICES_CLSID_MULTIPLE];
#ifdef DEBUG
const GUID& IID_IMsiEngineDebug = rgCLSID[CLSID_COUNT - DEBUG_CLSID_COUNT];
#endif //DEBUG

const ICHAR* rgszProgId[CLSID_COUNT] =
{
	SZ_PROGID_IMsiServices,
	SZ_PROGID_IMsiServices,
#ifdef DEBUG
	SZ_PROGID_IMsiServicesDebug,
	SZ_PROGID_IMsiServicesDebug,
#endif
	SZ_PROGID_IMsiEngine
 , SZ_PROGID_IMsiConfiguration
 , SZ_PROGID_IMsiMessage
 , SZ_PROGID_IMsiExecute
 , 0
 , SZ_PROGID_IMsiConfiguration
 , 0
 , 0
#ifdef CONFIGDB
 , SZ_PROGID_IMsiConfigurationDatabase
#endif // CONFIGDB
#ifdef DEBUG
 , SZ_PROGID_IMsiEngineDebug
 , SZ_PROGID_IMsiConfigDebug
 , SZ_PROGID_IMsiConfigDebug
#endif
};

const ICHAR* rgszDescription[CLSID_COUNT] =
{
	SZ_DESC_IMsiServices,
	SZ_DESC_IMsiServices,
#ifdef DEBUG
	SZ_DESC_IMsiServicesDebug,
	SZ_DESC_IMsiServicesDebug,
#endif
	SZ_DESC_IMsiEngine
 , SZ_DESC_IMsiConfiguration
 , SZ_DESC_IMsiMessage
 , SZ_DESC_IMsiExecute
 , SZ_DESC_IMsiServer
 , SZ_DESC_IMsiConfiguration
 , SZ_DESC_IMsiCustomAction
 , SZ_DESC_IMsiRemoteAPI
#ifdef CONFIGDB
 , SZ_DESC_IMsiConfigurationDatabase
#endif // CONFIGDB
 #ifdef DEBUG
 , SZ_DESC_IMsiEngineDebug
 , SZ_DESC_IMsiConfigDebug
 , SZ_DESC_IMsiConfigDebug
#endif
};

IUnknown* CreateServicesAsService();

ModuleFactory rgFactory[CLSID_COUNT] =
{
	(ModuleFactory)CreateServices,
	CreateServicesAsService,
#ifdef DEBUG
	(ModuleFactory)CreateServices,
	CreateServicesAsService,
#endif
	ENG::CreateEngine
 , (ModuleFactory)ENG::CreateConfigurationManager
 , (ModuleFactory)ENG::CreateMessageHandler
 , (ModuleFactory)ENG::CreateExecutor
 , (ModuleFactory)ENG::CreateMsiServerProxy
 , (ModuleFactory)ENG::CreateConfigManagerAsServer
 , (ModuleFactory)ENG::CreateCustomAction
 , (ModuleFactory)ENG::CreateMsiRemoteAPI
#ifdef CONFIGDB
 , (ModuleFactory)ENG::CreateConfigurationDatabase
#endif // CONFIGDB
#ifdef DEBUG
 , ENG::CreateEngine
 , (ModuleFactory)ENG::CreateConfigurationManager
 , (ModuleFactory)ENG::CreateConfigManagerAsServer
#endif
};

//____________________________________________________________________________
//
// IMsiSummaryInfo Implementation for ODBC databases, current read-only
//____________________________________________________________________________

class CDatabaseSummaryInfo : public IMsiSummaryInfo
{
 public:
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	int           __stdcall GetPropertyCount();
	int           __stdcall GetPropertyType(int iPID); // returns VT_XXX
	const IMsiString&   __stdcall GetStringProperty(int iPID);
	Bool          __stdcall GetIntegerProperty(int iPID, int& iValue);
	Bool          __stdcall GetTimeProperty(int iPID, MsiDate& riDateTime);
	Bool          __stdcall RemoveProperty(int iPID);
	int           __stdcall SetStringProperty(int iPID, const IMsiString& riText);
	int           __stdcall SetIntegerProperty(int iPID, int iValue);
	int           __stdcall SetTimeProperty(int iPID, MsiDate iDateTime);
	Bool          __stdcall WritePropertyStream();
	Bool          __stdcall GetFileTimeProperty(int iPID, FILETIME& rftDateTime);
	int           __stdcall SetFileTimeProperty(int iPID, FILETIME& rftDateTime);
 public: // constructor
	static IMsiSummaryInfo* Create(IMsiDatabase& riDatabase);
	CDatabaseSummaryInfo(IMsiCursor& riCursor);
	void operator =(CDatabaseSummaryInfo&);
 protected:
  ~CDatabaseSummaryInfo(){} // protected to prevent creation on stack
 private:
	unsigned int m_iRefCnt;
	IMsiCursor&  m_riCursor;
};

IMsiSummaryInfo* CDatabaseSummaryInfo::Create(IMsiDatabase& riDatabase)
{
	PMsiTable pTable(0);
	PMsiRecord pError(riDatabase.LoadTable(*MsiString(* TEXT("_SummaryInformation")), 0, *&pTable));
	if (pError)
		return 0;
	IMsiCursor* piCursor = pTable->CreateCursor(fFalse);
	return piCursor ? new CDatabaseSummaryInfo(*piCursor) : 0;
}

CDatabaseSummaryInfo::CDatabaseSummaryInfo(IMsiCursor& riCursor)
	: m_riCursor(riCursor), m_iRefCnt(1)
{
	riCursor.SetFilter(1);  // always indexing by property ID
}

HRESULT CDatabaseSummaryInfo::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown))  // No GUID for this guy yet
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CDatabaseSummaryInfo::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CDatabaseSummaryInfo::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	m_riCursor.Release();
	delete this;
	return 0;
}

const IMsiString& CDatabaseSummaryInfo::GetStringProperty(int iPID)
{
	m_riCursor.PutInteger(1, iPID);
	m_riCursor.Next();
	const IMsiString& riString = m_riCursor.GetString(2);
	m_riCursor.Reset();
	return riString;
}

Bool CDatabaseSummaryInfo::GetIntegerProperty(int iPID, int& iValue)
{
	MsiString istr(GetStringProperty(iPID));
	return (iValue = istr) == iMsiNullInteger ? fFalse : fTrue;
}

const int rgiMaxDateField[6] = {2099, 12, 31, 23, 59, 59};
const ICHAR rgcgDateDelim[6] = TEXT("// ::"); // yyyy/mm/dd hh:mm:ss

Bool CDatabaseSummaryInfo::GetFileTimeProperty(int iPID, FILETIME& /*rftDateTime*/)
{
	m_riCursor.PutInteger(1, iPID);
	if (!m_riCursor.Next())
		return fFalse;
	return fFalse;
}

int CDatabaseSummaryInfo::SetFileTimeProperty(int iPID, FILETIME& /*rftDateTime*/)
{
	m_riCursor.PutInteger(1, iPID);
	if (!m_riCursor.Next())
		return fFalse;
	return 0;
}

Bool CDatabaseSummaryInfo::GetTimeProperty(int iPID, MsiDate& riDateTime)
{
	m_riCursor.PutInteger(1, iPID);
	if (!m_riCursor.Next())
		return fFalse;
	MsiString istr(m_riCursor.GetString(2));
	m_riCursor.Reset();
	if (istr.TextSize() == 0)
		return fFalse;
	int rgiDate[6] = {0,0,0,0,0,0};
	int iDateField = -1; // flag to indicate empty
	int cDateField = 0;
	const ICHAR* pch = istr;
	int ch;
	while (cDateField < 6)
	{
		ch = *pch++;
		if (ch == rgcgDateDelim[cDateField])
		{
			rgiDate[cDateField++] = iDateField;
			iDateField = -1;  // reinitialize
		}
		else if (ch >= TEXT('0') && ch <= TEXT('9'))
		{
			ch -= TEXT('0');
			if (iDateField < 0)
				iDateField = ch;
			else
			{
				iDateField = iDateField * 10 + ch;
				if (iDateField > rgiMaxDateField[cDateField])
					return fFalse;  // field overflow
			}
		}
		else if (ch == 0 && iDateField >= 0) // less than 6 fields
		{
			rgiDate[cDateField++] = iDateField;
			break;  // all done, successful
		}
		else
			return fFalse; // error, not a date
	}
	if (cDateField != 3 && cDateField != 6) // incomplete date
		return fFalse;
	riDateTime = MsiDate(((((((((((rgiDate[0] - 1980) << 4)
										  + rgiDate[1]) << 5)
										  + rgiDate[2]) << 5)
										  + rgiDate[3]) << 6)
										  + rgiDate[4]) << 5)
										  + rgiDate[5] / 2);
	return fTrue;
}

int  CDatabaseSummaryInfo::GetPropertyCount(){return 0;}  // not implemented
int  CDatabaseSummaryInfo::GetPropertyType(int /*iPID*/){return 0;} // not implemented
int  CDatabaseSummaryInfo::SetStringProperty(int /*iPID*/, const IMsiString& /*riText*/){return 0;}
int  CDatabaseSummaryInfo::SetTimeProperty(int /*iPID*/, MsiDate /*iDateTime*/){return 0;}
int  CDatabaseSummaryInfo::SetIntegerProperty(int /*iPID*/, int /*iValue*/){return 0;}
Bool CDatabaseSummaryInfo::RemoveProperty(int /*iPID*/){return fFalse;}
Bool CDatabaseSummaryInfo::WritePropertyStream(){return fFalse;}

//____________________________________________________________________________
//
// MsiServices and MsiServerProxy factories
//____________________________________________________________________________

// used by engine, config mgr, and handle mgr to share instance of services

IMsiServices* g_piSharedServices = 0;
static int           g_cSharedServices = 0;
static int           g_iSharedServicesLock = 0;

IMsiServices* LoadServices()
{
	while (TestAndSet(&g_iSharedServicesLock) == true)
	{
		Sleep(100);
	}

	if (g_piSharedServices == 0)
	{
		g_piSharedServices = CreateServices();
		if (g_piSharedServices == 0)  //!! what to do if this fails?
		{
			g_iSharedServicesLock = 0;
			return 0;
		}
	}
	g_cSharedServices++;
	g_iSharedServicesLock = 0;
	return g_piSharedServices;
}

int FreeServices()
{
	while (TestAndSet(&g_iSharedServicesLock) == true)
	{
		Sleep(100);
	}

	Assert(g_cSharedServices > 0);
	if (--g_cSharedServices == 0)
	{
		if (g_piSharedDllsRegKey != 0)
		{
			g_piSharedDllsRegKey->Release();
			g_piSharedDllsRegKey = 0;
		}
#ifdef _WIN64
		if (g_piSharedDllsRegKey32 != 0)
		{
			g_piSharedDllsRegKey32->Release();
			g_piSharedDllsRegKey32 = 0;
		}
#endif

		g_piSharedServices->ClearAllCaches();  // release cached volume objects
		g_piSharedServices->Release(), g_piSharedServices = 0;
	}

	g_iSharedServicesLock = 0;
	return g_cSharedServices;
}


IMsiServer* CreateMsiServerProxy()
{
	// We never will succeed on Win9x
	if (g_fWin9X)
		return 0;
		
	IMsiServer* piUnknown = NULL;
	HRESULT hRes = S_OK;
	
	hRes = OLE32::CoCreateInstance(IID_IMsiServer, 
								   NULL, 
								   CLSCTX_LOCAL_SERVER, 
								   IID_IUnknown,
								   (void**)&piUnknown);
	
	if (FAILED(hRes))
	{
		// if the service is not registered, CoCreateInstance will return REGDB_E_CLASSNOTREG.
		// In that scenario we can fail immediately. However if the service has timed out and
		// is shutting down, we might get back E_NOINTERFACE or CO_E_SERVER_STOPPING. In that
		// case, retry the create. Similarly, an rpc error is most likely caused by the rpcss 
		// server not having started yet - see bug 8258. Retry once every 100 ms for 30 seconds
		int cAttempts = 1;
		while( (hRes == HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) ||
				hRes == HRESULT_FROM_WIN32(RPC_S_UNKNOWN_IF) ||
				hRes == E_NOINTERFACE ||
				hRes == CO_E_SERVER_STOPPING) &&
				cAttempts++ < 300)
		{
			Sleep(100);
			
			hRes = OLE32::CoCreateInstance(IID_IMsiServer, 0, CLSCTX_LOCAL_SERVER, IID_IUnknown,
													 (void**)&piUnknown);
		}
 	}
	
	//
	// Explicitly set the proxy blanket so that we are not affected by the default DCOM settings
	// on the machine.
	//
	if (SUCCEEDED(hRes))
		hRes = SetMinProxyBlanketIfAnonymousImpLevel (piUnknown);
	
	CComPointer<IMsiServer> pDispatch(0);
	if (SUCCEEDED(hRes))
	{
		hRes = piUnknown->QueryInterface(IID_IMsiServer, (void**)&pDispatch);
	}
	
	IMsiServer* piServer = NULL;
	if (SUCCEEDED(hRes))
	{
		piServer = ENG::CreateMsiServerProxyFromRemote(*pDispatch);
		if (!piServer)
			hRes = E_FAIL;
	}
	
	if(FAILED(hRes))
	{
		ICHAR rgchBuf[100];
		wsprintf(rgchBuf, TEXT("0x%X"), hRes);
		DEBUGMSGE(EVENTLOG_WARNING_TYPE,
					  EVENTLOG_TEMPLATE_CANNOT_CONNECT_TO_SERVER,
					  rgchBuf);
	}
	
	// Cleanup
	if (piUnknown)
	{
		piUnknown->Release();
		piUnknown = NULL;
	}
	
	return piServer;
	
}

IMsiServer* CreateMsiServer(void)
{
    IMsiServer* piServer = 0;

    if (FIsUpdatingProcess())
    {
        // Run in-proc if we are on Win9x or if we are already in the service.
        piServer = ENG::CreateConfigurationManager();
    }
    else
    {
        // Note: this will return 0 if we are unable to connect to the service
        // for some reason. In that case the installation will fail.
        piServer = ENG::CreateMsiServerProxy();
    }

    return piServer;
}

//
// Do we have access to the installer key
// If we don't, it means the service has run on this machine and
// we need to continue running as a service
bool FCanAccessInstallerKey()
{
	HKEY hKey;
	
	DWORD dwResult = MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE, szMsiLocalInstallerKey, 0,
		KEY_WRITE, &hKey);

	if (dwResult == ERROR_SUCCESS || dwResult == ERROR_FILE_NOT_FOUND)
	{
		if (dwResult == ERROR_SUCCESS)
			RegCloseKey(hKey);
		return true;
	}

	Assert(dwResult == ERROR_ACCESS_DENIED);
	return false;
}

//____________________________________________________________________________
//
// CMsiEngine factory
//____________________________________________________________________________

// factory called from OLE class factory, either client or standalone instance, g_MessageContext not intialized
IUnknown* CreateEngine()
{
	//!!# should we set some UI level first?				  


	PMsiServer pServer(0);
	pServer = ENG::CreateMsiServer();
	if (NOERROR != g_MessageContext.Initialize(fTrue, (iuiEnum)iuiDefault))  // UI in child thread //?? Is iuiDefault correct?
		return 0;
	IMsiServices* piServices = ENG::LoadServices(); // must succeed if pServer valid
	IMsiEngine* piEngine = new CMsiEngine(*piServices, pServer, 0, 0, 0);
	if (!piEngine)
		ENG::FreeServices();
	return piEngine;
}

// factory called from MsiEnableUIPreview

IMsiEngine* CreateEngine(IMsiDatabase& riDatabase)
{
	PMsiServer pConfigManager(ENG::CreateConfigurationManager());
	if (!pConfigManager)
		return 0;  // should happen only if out of memory
	if (NOERROR != g_MessageContext.Initialize(fTrue, iuiNextEnum)) // special case for no Basic UI
		return 0;
	IMsiServices* piServices = ENG::LoadServices(); // must succeed if config mgr
	return new CMsiEngine(*piServices, pConfigManager, 0, &riDatabase, 0);
}

// factory called from RunEngine() - API layer or nested install action, g_MessageContext already initialized (?)
IMsiEngine*  CreateEngine(IMsiStorage* piStorage, IMsiDatabase* piDatabase, CMsiEngine* piParentEngine, BOOL fServiceRequired)
{
	PMsiServer pServer(0);
	pServer = ENG::CreateMsiServer();
	if (fServiceRequired && !pServer)
	    return 0;  // Must connect to the service (or be running as the service if fServiceRequired is TRUE.)
	IMsiServices* piServices = ENG::LoadServices(); // must succeed if proxy created
	CMsiEngine* piEngine = new CMsiEngine(*piServices, pServer,
														piStorage, piDatabase, piParentEngine);
	if (!piEngine)
		ENG::FreeServices();
	return (IMsiEngine*)piEngine;
}

//____________________________________________________________________________
//
// CMsiServerConnMgr implementation
//____________________________________________________________________________

CMsiServerConnMgr::CMsiServerConnMgr(CMsiEngine* pEngine)
{
    m_fOleInitialized = FALSE;
    m_fCreatedConnection = FALSE;
    m_fObtainedConfigManager = FALSE;
    m_ppServer = NULL;
    m_ppConfigManager = NULL;

    if (pEngine)
    {
    m_ppServer = &(pEngine->m_piServer);
    m_ppConfigManager = &(pEngine->m_piConfigManager);

    if (NULL == (*m_ppServer))
    {
        if (FALSE == m_fOleInitialized &&
        SUCCEEDED(OLE32::CoInitialize(NULL))
        )
        {
        m_fOleInitialized = TRUE;
        }

        *m_ppServer = ENG::CreateMsiServer();
        if (*m_ppServer)
        m_fCreatedConnection = TRUE;
    }

    if (*m_ppServer && NULL == *m_ppConfigManager)
    {
        if (FALSE == m_fOleInitialized &&
        SUCCEEDED(OLE32::CoInitialize(NULL))
        )
        {
        m_fOleInitialized = TRUE;
        }

        (*m_ppServer)->QueryInterface(IID_IMsiConfigurationManager,
                      (void **)m_ppConfigManager);
        if (*m_ppConfigManager)
        m_fObtainedConfigManager = TRUE;
    }
    }
}

CMsiServerConnMgr::~CMsiServerConnMgr()
{
    if (m_fObtainedConfigManager && *m_ppConfigManager)
    {
    (*m_ppConfigManager)->Release();
    *m_ppConfigManager = NULL;
    }

    if (m_fCreatedConnection && *m_ppServer)
    {
    (*m_ppServer)->Release();
    *m_ppServer = NULL;
    }

    if (m_fOleInitialized)
    {
    OLE32::CoUninitialize();
    }
}

//____________________________________________________________________________
//
// CMsiEngine implementation
//____________________________________________________________________________

CMsiEngine::CMsiEngine(IMsiServices& riServices, IMsiServer* piServer,
			      IMsiStorage* piStorage, IMsiDatabase* piDatabase,
			      CMsiEngine* piParentEngine)
    : m_piServer(piServer)
    , m_riServices(riServices)
    , m_piExternalStorage(piStorage)
    , m_piExternalDatabase(piDatabase)
    , m_piParentEngine(piParentEngine)
    , m_pCachedActionStart(0)
    , m_pActionStartLogRec(0)
    , m_pActionProgressRec(0)
    , m_pScriptProgressRec(0)
    , m_pCostingCursor(0)
    , m_pPatchCacheTable(0)
    , m_pPatchCacheCursor(0)
	, m_pFolderCacheTable(0)
	, m_pFolderCacheCursor(0)
    , m_iioOptions((iioEnum)0)
    , m_pcmsiFile(0)
    , m_fcmsiFileInUse(0)
    , m_iSourceType(-1)
    , m_fRunScriptElevated(false)
    , m_pCustomActionManager(NULL)
    , m_fAssemblyTableExists(true)
    , m_pViewFusion(0), m_pViewFusionNameName (0), m_pViewFusionName (0)
	 , m_pViewOldPatchFusionNameName (0), m_pViewOldPatchFusionName (0)
	 , m_pTempCostsCursor(0)
	 , m_pFileHashCursor(0)
	 , m_fRestrictedEngine(false)
	 , m_fRemapHKCUInCAServers(false)
	 , m_fCAShimsEnabled(false)
	 , m_fNewInstance(false)

{  // all  members zeroed by operator new
	// We don't hold a ref to services, we must call ENG::FreeServices() at end
	m_iRefCnt = 1;  // factory does not do QueryInterface, no aggregation
	
	if (m_piServer)
            m_piServer->AddRef();
	
	g_cInstances++;
	m_scmScriptMode = scmIdleScript;
	if (piStorage)
		piStorage->AddRef();
	if (piDatabase)
		piDatabase->AddRef();
	if (piParentEngine)
		piParentEngine->AddRef();
    
	memset(&m_guidAppCompatDB, 0, sizeof(m_guidAppCompatDB));
	memset(&m_guidAppCompatID, 0, sizeof(m_guidAppCompatID));

	InitializeCriticalSection(&m_csCreateProxy);
	AssertSz(g_MessageContext.IsInitialized(), "MessageContext not initialized");
}

CMsiEngine::~CMsiEngine()
{
	if (m_fInitialized)  // should never happen due to handler holding ref
	{
		// this can happen if no or basic UI, should never happen if system updated
		// will also happen in UI preview mode
//              AssertSz((m_iuiLevel == iuiNone || m_iuiLevel == iuiBasic) && (GetMode() & iefServerLocked) == 0,
//                                      "Engine not terminated");
		Terminate(iesNoAction); // if assert above doesn't fail, this is safe
	}

	DeleteCriticalSection(&m_csCreateProxy);

	if (m_piExternalStorage)
		m_piExternalStorage->Release();
	if (m_piExternalDatabase)
		m_piExternalDatabase->Release();
	if (m_piParentEngine)
		m_piParentEngine->Release();
	else if (g_MessageContext.ChildUIThreadExists())  // last one out turns off the lights
		g_MessageContext.Terminate(fFalse);  // if main engine in child thread, then called by UI thread
	g_cInstances--;
}

// Private function to clear member data, used by Terminate and Initialize failure

void CMsiEngine::ClearEngineData()
{
	for (int i = 0; i < cCachedHeaders; i++)
		if (m_rgpiMessageHeader[i])
		{
			m_rgpiMessageHeader[i]->Release();
			m_rgpiMessageHeader[i] = 0;
		}
	if (m_piProductKey)   m_piProductKey->Release(),     m_piProductKey = 0;
	if (m_pistrPlatform)  m_pistrPlatform->Release(),    m_pistrPlatform = 0;
	if (m_piPropertyCursor)
	{
		m_piPropertyCursor->Release(), m_piPropertyCursor = 0;
	}
	if (m_piActionTextCursor)
	{
		m_piActionTextCursor->Release(), m_piActionTextCursor = 0;
	}

	if (m_piActionDataFormat) m_piActionDataFormat->Release(), m_piActionDataFormat = 0;
	if (m_piActionDataLogFormat) m_piActionDataLogFormat->Release(), m_piActionDataLogFormat = 0;

	if (m_fSummaryInfo)
	{
		m_pistrSummaryComments->Release(), m_pistrSummaryComments = 0;
		m_pistrSummaryKeywords->Release(), m_pistrSummaryKeywords = 0;
		m_pistrSummaryTitle->Release(),    m_pistrSummaryTitle    = 0;
		m_pistrSummaryProduct->Release(),  m_pistrSummaryProduct  = 0;
		m_pistrSummaryPackageCode->Release(), m_pistrSummaryPackageCode = 0;
		m_fSummaryInfo = fFalse;
	}

	m_fRegistered = fFalse;
	m_fAdvertised = fFalse;
	m_fMode = 0;
	m_fCostingComplete = false;
	m_fSelManInitComplete = false;
	m_fForegroundCostingInProgress = false;
	m_fExclusiveComponentCost = fFalse;

	m_fSourceResolutionAttempted = false;
	
	m_fDisabledRollbackInScript = fFalse;

	if (m_pExecuteScript)  // execute script file left open, probably after a cancel
	{
		Assert(m_pistrExecuteScript);
		delete m_pExecuteScript, m_pExecuteScript = 0;
		WIN::DeleteFile(m_pistrExecuteScript->GetString());
	}
	if(m_pSaveScript)
	{
		delete m_pSaveScript;
		m_pSaveScript = 0;
	}
	m_scmScriptMode = scmIdleScript;

	if (m_pistrExecuteScript)
	{
		m_pistrExecuteScript->Release();
		m_pistrExecuteScript = 0;
	}
	if (m_pistrSaveScript)
	{
		m_pistrSaveScript->Release();
		m_pistrSaveScript = 0;
	}

	if (m_piRegistryActionTable)
	{
		m_piRegistryActionTable->Release();
		m_piRegistryActionTable = 0;
	}

	if (m_piFileActionTable)
	{
		m_piFileActionTable->Release();
		m_piFileActionTable = 0;
	}

	if(m_piDatabase)
		m_piDatabase->Release(), m_piDatabase = 0;

	m_iioOptions = (iioEnum)0;
	m_iSourceType = -1;

	Assert(!m_fcmsiFileInUse);
	if (m_pcmsiFile)
	{
		delete m_pcmsiFile;
		m_pcmsiFile = 0;
	}

	memset(&m_ptsState, 0, sizeof(m_ptsState));

	// reset appcompat data
	m_fCAShimsEnabled = false;
	memset(&m_guidAppCompatDB, 0, sizeof(m_guidAppCompatDB));
	memset(&m_guidAppCompatID, 0, sizeof(m_guidAppCompatID));

	// attempt to clean up any temp files that were created
	while (m_strTempFileCopyCleanupList.TextSize() != 0)
	{
		MsiString strFile = m_strTempFileCopyCleanupList.Extract(iseUpto, ';');

		if (strFile.TextSize() == 0)
			continue;

		if (g_scServerContext == scService)
		{
			CElevate elevate;
			DEBUGMSGV1(TEXT("Attempting to delete file %s"), strFile);
			if (!WIN::DeleteFile(strFile))
			{
				DEBUGMSGV1(TEXT("Unable to delete the file. LastError = %d"), (const ICHAR*)(INT_PTR)GetLastError());
			}
		}
		else
		{
			DEBUGMSGV1(TEXT("Attempting to delete file %s"), strFile);
			if (!WIN::DeleteFile(strFile))
			{
				DEBUGMSGV1(TEXT("Unable to delete the file. LastError = %d"), (const ICHAR*)(INT_PTR)GetLastError());
			}
		}

		if (!m_strTempFileCopyCleanupList.Remove(iseIncluding, ';'))
			break;
	}

	m_strTempFileCopyCleanupList = g_MsiStringNull;
}

HRESULT CMsiEngine::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_IMsiEngineShip))
		*ppvObj = (IMsiEngine*)this;
	else if (MsGuidEqual(riid, IID_IMsiMessage))
		*ppvObj = (IMsiMessage*)this;
#ifdef DEBUG
	else if (MsGuidEqual(riid, IID_IMsiEngineDebug))
		*ppvObj = (IMsiEngine*)this;
	else if (MsGuidEqual(riid, IID_IMsiDebug))
		*ppvObj = (IMsiDebug*)this;
#endif
	else if (MsGuidEqual(riid, IID_IMsiSelectionManager))
		*ppvObj = (IMsiSelectionManager*)this;
	else if (MsGuidEqual(riid, IID_IMsiDirectoryManager))
		*ppvObj = (IMsiDirectoryManager*)this;
	else
		return (*ppvObj = 0, E_NOINTERFACE);
	AddRef();
	return NOERROR;
}
unsigned long CMsiEngine::AddRef()
{
	return ++m_iRefCnt;
}
unsigned long CMsiEngine::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	
	if (m_piServer)
	    m_piServer->Release();
	
	if (m_piConfigManager)
		m_piConfigManager->Release();
	delete this;
	if (g_hMsiMessage)
		WIN::FreeLibrary(g_hMsiMessage), g_hMsiMessage = 0;
	ENG::FreeServices();
	return 0;
}

IMsiServices* CMsiEngine::GetServices()
{
	m_riServices.AddRef();
	return &m_riServices;
}

HRESULT CMsiEngine::SetLanguage(LANGID iLangId)
{
	m_iLangId = iLangId;
	return NOERROR;
}

LANGID CMsiEngine::GetLanguage()
{
	return m_iLangId;
}

IMsiServer* CMsiEngine::GetConfigurationServer()
{
    if (m_piServer)
	m_piServer->AddRef();
    
    return m_piServer;
}

IMsiDatabase* CMsiEngine::GetDatabase()
{
	if (m_piDatabase)
		m_piDatabase->AddRef();
	return m_piDatabase;
}

// computes a checksum for user properties
const ICHAR* s_rgszUserProperties[] = {
	IPROPNAME_USERNAME,
	IPROPNAME_COMPANYNAME,
	IPROPNAME_PRODUCTID,
	0 };
int CMsiEngine::ChecksumUserInfo()
{
	int iChecksum = 0;
	int iCheck = 117;
	MsiString istrInfo;
	const ICHAR** pszProperty = s_rgszUserProperties;
	while (*pszProperty)
	{
		istrInfo = GetPropertyFromSz(*pszProperty++);
		const ICHAR* pchInfo = istrInfo;
		unsigned int ch;
		while ((ch = *pchInfo++) != 0)
		{
			iChecksum ^= ((ch + iCheck) & 255) << iCheck % 25;
			iCheck += (ch * 19);
		}
	}
	return iChecksum;
}

// formats MsiDate to MsiString
const IMsiString& DateTimeToString(int iDateTime)
{
	MsiString istrText;
	int iValue;
	int rgiDate[6];

	for (iValue = 5; iValue >= 0; iValue--)
	{
		rgiDate[iValue] = iDateTime & (( 1 << rgcbDate[iValue]) - 1);
		iDateTime >>= rgcbDate[iValue];
	}
	iValue = (rgiDate[0] == 0 && rgiDate[1] == 0 ? 3 : 0);
	rgiDate[0] += 1980;
	rgiDate[5] *= 2;
	for (;;)
	{
		int i = rgiDate[iValue];
		if (i < 10)
			istrText += TEXT("0");
		istrText += MsiString(i);
		if (rgchDelim[iValue] == 0)
			break;
		istrText += MsiString(MsiChar(rgchDelim[iValue++]));
	}
	return istrText.Return();
}

/*															  
void DebugDumpTable(IMsiDatabase& riDatabase, const ICHAR* szTable)
{
	if (!FDiagnosticModeSet(dmVerboseDebugOutput|dmVerboseLogging))
		return;

	DEBUGMSG1(TEXT("Dumping table: %s"), szTable);

	PMsiRecord pError(0);
	
	PMsiTable pTable(0);
	pError = riDatabase.LoadTable(*MsiString(szTable),0,*&pTable);
	if(pError == 0)
	{
		PMsiCursor pCursor = pTable->CreateCursor(fFalse);

		while(pCursor->Next())
		{
			ICHAR rgchBuffer[1024];
			wsprintf(rgchBuffer, TEXT("[1]: %s (%d),\t[2]: %s (%d),\t[3]: %s (%d),\t[4]: %s (%d),\t[5]: %s (%d),\t[6]: %s (%d),\t[7]: %s (%d),\t[8]: %s (%d)"),
						(const ICHAR*)MsiString(pCursor->GetString(1)), pCursor->GetInteger(1),
						(const ICHAR*)MsiString(pCursor->GetString(2)), pCursor->GetInteger(2),
						(const ICHAR*)MsiString(pCursor->GetString(3)), pCursor->GetInteger(3),
						(const ICHAR*)MsiString(pCursor->GetString(4)), pCursor->GetInteger(4),
						(const ICHAR*)MsiString(pCursor->GetString(5)), pCursor->GetInteger(5),
						(const ICHAR*)MsiString(pCursor->GetString(6)), pCursor->GetInteger(6),
						(const ICHAR*)MsiString(pCursor->GetString(7)), pCursor->GetInteger(7),
						(const ICHAR*)MsiString(pCursor->GetString(8)), pCursor->GetInteger(8));

			DEBUGMSG1(TEXT("%s"), rgchBuffer);				  
		}
	}
}															  
*/

CMsiCustomActionManager *GetCustomActionManager(IMsiEngine *piEngine);
///////////////////////////////////////////////////////////////////////
// remaps the HKCU registry key to either HKCU (if not TS per machine)
// or HKU\.Default (if TS per machine). Also resets custom action server
bool PrepareHydraRegistryKeyMapping(bool fTSPerMachineInstall)
{
	if (g_fWin9X)
		return true;

	AssertSz(g_scServerContext == scService, "Wrong context for Registry Key Mapping");

	// close HKCU and reopen it as .Default. Without this, we'll actually use HKCU, and ODBC
	// will write to HKCU due to the preloaded key.
	LoadCurrentUserKey(/*fSystem=*/fTSPerMachineInstall);

	// ensure that the current custom action server state for mapped registry keys matches
	// what we expect
	CMsiCustomActionManager* pCustomActionManager = ::GetCustomActionManager(NULL);
	AssertSz(pCustomActionManager, "No custom action manager while preparing key mapping.");
	if (pCustomActionManager)
	{
		pCustomActionManager->EnsureHKCUKeyMappingState(/*fRemapHKCU=*/!fTSPerMachineInstall);
	}
	return true;
}

bool CMsiEngine::OpenHydraRegistryWindow(bool fNewTransaction)
{
	// If TS5 and installing per-machine, call the propogation API to notify Hydra that an
	// install is beginning, unless we're doing an Admin Install, or creating an advertise
	// script
	if (MinimumPlatformWindows2000() && IsTerminalServerInstalled())
	{
		if (!(GetMode() & (iefAdmin | iefAdvertise)) && MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize())
		{
			PrepareHydraRegistryKeyMapping(/*TSPerMachineInstall=*/true);
	
			// only open the actual registry window in a new transaction, not after reboot
			if (fNewTransaction)
			{
				// must call Hydra APIs as system					  
				CElevate elevate;
		
				Assert(!m_fInParentTransaction);
				DEBUGMSG("Opening Terminal Server registry propogation window.");
		
				NTSTATUS lResult = STATUS_SUCCESS;
				for(int iContinueRetry = 3; iContinueRetry--;)// try thrice, prevent possibly endless recursion
				{
					if (NT_SUCCESS(lResult = TSAPPCMP::TermServPrepareAppInstallDueMSI()))
						break;
					if (iContinueRetry && (lResult == STATUS_INSUFFICIENT_RESOURCES))
					{
						// Hydra couldn't create a ref copy of the registry tree because we were
						// out of registry space. Increase quota and try again.
						if (!IncreaseRegistryQuota())
							break;
					}
					else
					{
						DEBUGMSG1(TEXT("Failed to open Terminal Server registry window. Status code 0x%08X"), (const ICHAR*)(INT_PTR)lResult);
						break;
					}
				}
				return NT_SUCCESS(lResult);
			}
			return true;
		}
		else
		{
			// ensure that the current custom action server state for mapped registry keys matches
			// what we expect.
			PrepareHydraRegistryKeyMapping(/*TSPerMachineInstall=*/false);
		}
	}

	// don't need to call Hydra.
	return true;
}

bool CMsiEngine::CloseHydraRegistryWindow(bool bCommit)
{
	// If TS5 and installing per-machine, call the propogation API to notify Hydra that an
	// install is done or aborted, unless we're doing an Admin Install, or creating an advertise
	// script
	if (IsTerminalServerInstalled() && g_iMajorVersion >= 5 && !(GetMode() & (iefAdmin | iefAdvertise)) &&
		MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize())
	{														  
		// must call Hydra API from system context
		CElevate elevate;

		Assert(!m_fInParentTransaction);
		DEBUGMSG1("Closing Terminal Server registry propogation window. %s", bCommit ? "Saving Changes." : "Discarding Changes.");

		NTSTATUS lResult = STATUS_SUCCESS;
		if (bCommit)
		{
			for(int iContinueRetry = 3; iContinueRetry--;)// try thrice, prevent possibly endless recursion
			{
				if (NT_SUCCESS(lResult = TSAPPCMP::TermServProcessAppInstallDueMSI(!bCommit)))
					break;
				if (iContinueRetry && (lResult == STATUS_INSUFFICIENT_RESOURCES))
				{
					// Hydra couldn't propogate the new keys to its private hive due to registry
					// limits. Try again.
					if (!IncreaseRegistryQuota())
						break;
				}
				else
				{
					DEBUGMSG1(TEXT("Failed to close Terminal Server registry window. Status code 0x%08X."), (const ICHAR*)(INT_PTR)lResult);
					break;
				}											  
			}
		}

		// must always call Process() with cleanup TRUE. Cleanup = FALSE (i.e. save changes)
		// will not destroy hive. Nothing to do if we fail.	  
		TSAPPCMP::TermServProcessAppInstallDueMSI(TRUE);

		// if we were successful in propogating registry information to the TS hive, trigger an immediate
		// propogation to HKCU. This ensures that the shell (a TS-aware app) doesn't continually try to 
		// repair shortcuts that need to detect HKCU keypaths which have not yet been propogated.
		if (NT_SUCCESS(lResult))
		{
			// these APIs must be called while impersonated for the correct HKCU to be used.
			CImpersonate impersonate;

			// trigger an immediate propogation. No return value
			TSAPPCMP::TermsrvCheckNewIniFiles();

			// if a registry key already existed in both HKCU and the TS hive, the first propogation
			// merely deletes the old keys, expecting on-demand propogation to replace them with the
			// new values. However the shell is TS-aware and does not trigger the propogation on demand.
			// Thus we force a second propogation to copy the new keys.

			// don't use HKEY_CURRENT USER because it might be cached as .Default for TS propogation.
			// Instead, since we are impersonated here, we can use the RegOpenCurrentUser API to explicitly
			// get the true HKCU for the user.
			HKEY hCurrentUserKey = 0;
			if (ERROR_SUCCESS == ADVAPI32::RegOpenCurrentUser(KEY_READ, &hCurrentUserKey))
			{
				// delete the TS timestamp to force a second refresh.
				HKEY hKey = 0;
				DWORD dwResult = RegOpenKeyAPI(hCurrentUserKey, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"), 0, KEY_ALL_ACCESS, &hKey);
				if (ERROR_SUCCESS == dwResult)
				{
					RegDeleteValue(hKey, TEXT("LastUserIniSyncTime"));
					RegCloseKey(hKey);
				
					// timestamp was deleted, force a second propogation
					TSAPPCMP::TermsrvCheckNewIniFiles();
				}
				RegCloseKey(hCurrentUserKey);
			}
		}

		return NT_SUCCESS(lResult);
	}
	return true;
}


const ICHAR rgchSRAPIfailed[] = TEXT("The call to SRSetRestorePoint API failed. Returned status: %d. ")
										  TEXT("GetLastError() returned: %d");
const ICHAR rgchSRAPIdisabled[] = TEXT("The System Restore service is disabled. Returned status: %d. ")
										  TEXT("GetLastError() returned: %d");

const ICHAR rgchCallingSRAPI[] = TEXT("Calling SRSetRestorePoint API. dwRestorePtType: %d, dwEventType: %d, ")
										   TEXT("llSequenceNumber: %s, szDescription: \"%s\".");
const ICHAR rgchSRAPISuccess[] = TEXT("The call to SRSetRestorePoint API succeeded. Returned status: %d.");
const ICHAR rgchSRAPISuccessAndNo[] = TEXT("The call to SRSetRestorePoint API succeeded. Returned status: %d, llSequenceNumber: %s.");

// returns the current install's type (advertise, install, uninstall, maintenance, deploy)
// NOTE: if not called after InstallValidate, may not return "uninstall" during an uninstall
iitEnum CMsiEngine::GetInstallType()
{
	if ( m_iioOptions & iioCreatingAdvertiseScript )
	{
		// creating an advertise script
		return iitDeployment;
	}
	else if( m_fAdvertised )
	{
		// maintenance mode
		if( MsiString(GetPropertyFromSz(IPROPNAME_FEATUREREMOVE)).Compare(iscExactI, IPROPVALUE_FEATURE_ALL) )
		{
			return iitUninstall;
		}
		else
		{
			return (m_fRegistered) ? iitMaintenance : iitFirstInstallFromAdvertised;
		}
	}
	else
	{
		// first install/advertise
		if( GetMode() & iefAdvertise )
		{
			return iitAdvertise;
		}
		else
		{
			return iitFirstInstall;
		}
	}
}

void CMsiEngine::BeginSystemChange()
{
	m_i64PCHEalthSequenceNo = 0;

	if (MinimumPlatformMillennium() || MinimumPlatformWindowsNT51())
	{
		// we're running on Millenium or later 
		iuiEnum iui = (iuiEnum)GetPropertyInt(*MsiString(IPROPNAME_CLIENTUILEVEL));
		if (g_MessageContext.IsOEMInstall() || 
			((iuiNone == iui) || (iuiDefault == iui)) || 
			(GetMode() & iefAdmin) ||
			(GetIntegerPolicyValue(szLimitSystemRestoreCheckpoint, fTrue) > 0))
		{
			// no check points during OEM install, No-UI modes, 
			// when LimitSystemRestoreCheckpoint policy is set, or administrative installs.
			DEBUGMSGV(TEXT("SRSetRestorePoint skipped for this transaction."));
			return;

		}

		ICHAR rgchBuffer[64];

		RESTOREPOINTINFO strPtInfo;
		strPtInfo.dwRestorePtType = -1;
		MsiString strMessage;


		MsiString strProduct(GetPropertyFromSz(IPROPNAME_PRODUCTNAME));
		PMsiRecord piRec(0);
		iitEnum iitInstallType = GetInstallType();
		if ( iitInstallType == iitFirstInstall ||
			 iitInstallType == iitFirstInstallFromAdvertised )
		{
			// we're installing a new product
			strPtInfo.dwRestorePtType = APPLICATION_INSTALL;
			piRec = PostError(Imsg(imsgSRRestorePointInstall), *strProduct);
			piRec->SetMsiString(0, *MsiString(GetErrorTableString(imsgSRRestorePointInstall)));
			strMessage = MsiString(piRec->FormatText(fTrue));
		}
		else if ( iitInstallType == iitUninstall )
		{
			// we're removing a product
			strPtInfo.dwRestorePtType = APPLICATION_UNINSTALL;
			piRec = PostError(Imsg(imsgSRRestorePointRemove), *strProduct);
			piRec->SetMsiString(0, *MsiString(GetErrorTableString(imsgSRRestorePointRemove)));
			strMessage = MsiString(piRec->FormatText(fTrue));
		}
		else if ( (iitInstallType == iitDeployment)  || 
                          (iitInstallType == iitAdvertise)   ||
                          (iitInstallType == iitMaintenance)   )
		{
			// These scenarios should not invoke system restore
			DEBUGMSGV(TEXT("SRSetRestorePoint skipped for this transaction."));
			return;
		}
		else
		{
			Assert(0);
			return;
		}

		if ( strMessage.TextSize() && strPtInfo.dwRestorePtType != -1 )
		{
			// we have work to do.
			int nLen = sizeof(strPtInfo.szDescription) / sizeof(ICHAR);
			if ( strMessage.TextSize() >= nLen ) // don't forget the NULL termination
				// the string is too long
				strMessage = strMessage.Extract(iseFirst, nLen-1);
#ifdef UNICODE
			strPtInfo.dwEventType = BEGIN_NESTED_SYSTEM_CHANGE;
#else
			int newLen = nLen-1;
			while(strMessage.TextSize() >= nLen)
			{
				strMessage = strMessage.Extract(iseFirst, --newLen);
			}

			strPtInfo.dwEventType = BEGIN_SYSTEM_CHANGE;
#endif
			strPtInfo.llSequenceNumber = 0;
			IStrCopy(strPtInfo.szDescription, (const ICHAR *)strMessage);

			STATEMGRSTATUS strStatus;
			memset(&strStatus, 0, sizeof(strStatus));

			DEBUGMSG4(rgchCallingSRAPI,
						 (const ICHAR *)(INT_PTR)strPtInfo.dwRestorePtType,
						 (const ICHAR *)(INT_PTR)strPtInfo.dwEventType,
						 _i64tot(strPtInfo.llSequenceNumber, rgchBuffer, 10),
						 strPtInfo.szDescription);

			if ( !SYSTEMRESTORE::SRSetRestorePoint(&strPtInfo, &strStatus) )
			{
				DWORD dwError = WIN::GetLastError();
				const ICHAR const* pszSRAPIresult = (ERROR_SERVICE_DISABLED == strStatus.nStatus) ? rgchSRAPIdisabled : rgchSRAPIfailed;

				DEBUGMSG2(pszSRAPIresult,
							 (const ICHAR *)(INT_PTR)strStatus.nStatus,
							 (const ICHAR *)(INT_PTR)dwError);
				m_i64PCHEalthSequenceNo = 0;
			}
			else
			{
				DEBUGMSG2(rgchSRAPISuccessAndNo,
							 (const ICHAR *)(INT_PTR)strStatus.nStatus,
							 _i64tot(strStatus.llSequenceNumber, rgchBuffer, 10));
				//Assert(strStatus.llSequenceNumber != 0);
				// Assert(strStatus.nStatus == 0);
				m_i64PCHEalthSequenceNo = strStatus.llSequenceNumber;
			}
		}
	}
	return;
}

const ICHAR rgchNoSRSequence[] = TEXT("No System Restore sequence number for this installation.");

void CMsiEngine::EndSystemChange(bool fCommitChange, const ICHAR *szSequenceNo)
{
	if ( !(MinimumPlatformMillennium() || MinimumPlatformWindowsNT51()) || g_MessageContext.IsOEMInstall() )
		// we're not running on Millenium/Whistler or later or we're running in FASTOEM mode.
		return;
	else if ( !szSequenceNo || !*szSequenceNo )
	{
		DEBUGMSG(rgchNoSRSequence);
		return;
	}

	EndSystemChange(fCommitChange, _ttoi64(szSequenceNo));
}

void CMsiEngine::EndSystemChange(bool fCommitChange, INT64 iSequenceNo)
{
	if ( !(MinimumPlatformMillennium() || MinimumPlatformWindowsNT51())|| g_MessageContext.IsOEMInstall() )
		// we're not running on Millenium/Whistler or later or we're running in FASTOEM mode.
		return;
	else if ( iSequenceNo == 0 )
	{
		DEBUGMSG(rgchNoSRSequence);
		return;
	}

	ICHAR rgchBuffer[64];

	RESTOREPOINTINFO strPtInfo;
#ifdef UNICODE
	strPtInfo.dwEventType = END_NESTED_SYSTEM_CHANGE;
#else
	strPtInfo.dwEventType = END_SYSTEM_CHANGE;
#endif
	strPtInfo.llSequenceNumber = iSequenceNo;
	strPtInfo.dwRestorePtType = fCommitChange ? 0 : CANCELLED_OPERATION;
	*strPtInfo.szDescription = 0;

	STATEMGRSTATUS strStatus;
	memset(&strStatus, 0, sizeof(strStatus));

	DEBUGMSG4(rgchCallingSRAPI,
				 (const ICHAR *)(INT_PTR)strPtInfo.dwRestorePtType,
				 (const ICHAR *)(INT_PTR)strPtInfo.dwEventType,
				 _i64tot(strPtInfo.llSequenceNumber, rgchBuffer, 10),
				 strPtInfo.szDescription);
	if ( !SYSTEMRESTORE::SRSetRestorePoint(&strPtInfo, &strStatus) )
	{
		DWORD dwError = WIN::GetLastError();
		const ICHAR const* pszSRAPIresult = (ERROR_SERVICE_DISABLED == strStatus.nStatus) ? rgchSRAPIdisabled : rgchSRAPIfailed;

		DEBUGMSG2(pszSRAPIresult,
					 (const ICHAR *)(INT_PTR)strStatus.nStatus,
					 (const ICHAR *)(INT_PTR)dwError);
	}
	else
		DEBUGMSG1(rgchSRAPISuccess,
					(const ICHAR *)(INT_PTR)strStatus.nStatus);
}


/*------------------------------------------------------------------------------
CMsiEngine::Initialize - paired with Terminate method, determines initialized state
------------------------------------------------------------------------------*/
const int ieiReInitialize          = -1;  // private return from DoInitialize
const int ieiResolveSourceAndRetry = -2;  // private return from InitializeTransforms

ieiEnum CMsiEngine::Initialize(const ICHAR* szDatabase, iuiEnum iuiLevel,
										 const ICHAR* szCommandLine, const ICHAR* szProductCode,
										 iioEnum iioOptions)
{
	ieiEnum ieiStat = ieiSuccess;
	if (m_fInitialized)
		return ieiAlreadyInitialized; // can't happen from launcher
	m_piErrorInfo = &g_MsiStringNull;   // force non-null pointer for duration of this function

	// get local config manager, fails if we're a client connected to server

	if (!m_piConfigManager && m_piServer)
		m_piServer->QueryInterface(IID_IMsiConfigurationManager, (void**)&m_piConfigManager);

	if (ieiStat == ieiSuccess)
	{
		// attempt to use supplied database, switch to maintenance database if installed
		ieiStat = DoInitialize(szDatabase, iuiLevel, szCommandLine, szProductCode, iioOptions);
		if (ieiStat == ieiReInitialize)  // suspended install rolled back, re-initialize
		{
			ClearEngineData(); // reset state information - doesn't release handler
			ieiStat = DoInitialize(szDatabase, iuiLevel, szCommandLine, szProductCode, iioOptions);
		}
	}
	if (ieiStat != ieiSuccess)
	{
		PMsiRecord pRecord = &m_riServices.CreateRecord(3);
		UINT uiStat = MapInitializeReturnToUINT(ieiStat);
		pRecord->SetInteger(1, uiStat);
		pRecord->SetMsiString(3, *m_piErrorInfo);
		MsiString istrError = ENG::GetInstallerMessage(uiStat);
		pRecord->SetMsiString(2, *istrError);
		pRecord->SetString(0, istrError.TextSize() == 0 ? TEXT("Install error [1]. [3]") // should never happen
																			: TEXT("[2]{\r\n[3]}"));
		Message(imtInfo, *pRecord);
		ClearEngineData();  // else data cleared by Terminate()
		ReleaseHandler();
		m_fInitialized = fFalse; //!! is this OK?
	}
	m_piErrorInfo->Release(), m_piErrorInfo = 0;
	m_lTickNextProgress = GetTickCount();
	return ieiStat;
}

Bool CMsiEngine::CreatePropertyTable(IMsiDatabase& riDatabase, const ICHAR* szSourceTable,
												 Bool fLoadPersistent)
{
	PMsiTable pPropertyTable(0);
	PMsiRecord pError(0);
	if(fLoadPersistent)
	{
		if ((pError = riDatabase.LoadTable(*MsiString(szSourceTable), 0, *&pPropertyTable)))
			return fFalse; // no property table
	}
	else
	{
		if ((pError = riDatabase.CreateTable(*MsiString(*sztblPropertyLocal), 0, *&pPropertyTable)))
			return fFalse;
		pPropertyTable->CreateColumn(icdString + icdPrimaryKey, *MsiString(*TEXT("")));
		pPropertyTable->CreateColumn(icdString + icdNoNulls,    *MsiString(*TEXT("")));
	}

	if(m_piPropertyCursor)
		m_piPropertyCursor->Release();
	
	if ((m_piPropertyCursor = pPropertyTable->CreateCursor(fFalse)) == 0)
		return fFalse;
	m_piPropertyCursor->SetFilter(1);  // permanent setting

	if(fLoadPersistent == fFalse)
	{
		if (szSourceTable)
		{
			PMsiTable pSourceTable(0);
			PMsiCursor pSourceCursor(0);
			if ((pError = riDatabase.LoadTable(*MsiString(*szSourceTable), 0, *&pSourceTable)))
				return fTrue; // OK if Property table doesn't exist (but some properties need to be defined to install)
			if ((pSourceCursor = pSourceTable->CreateCursor(fFalse)) == 0)
				return fFalse;
			while (pSourceCursor->Next())
			{
				MsiString istrName  = pSourceCursor->GetString(1);
				MsiString istrValue = pSourceCursor->GetString(2);
				AssertNonZero(m_piPropertyCursor->PutString(1, *istrName));
				AssertNonZero(m_piPropertyCursor->PutString(2, *istrValue));
				if (m_piPropertyCursor->Insert() == fFalse)
					return fFalse;
			}
			m_piPropertyCursor->Reset();
		}
	}
	return fTrue;
}

Bool GetProductInfo(const ICHAR* szProductKey, const ICHAR* szProperty, CTempBufferRef<ICHAR>& rgchInfo)
{
	DWORD cchBuffer = rgchInfo.GetSize();

	UINT uiStat = MSI::MsiGetProductInfo(szProductKey, szProperty, rgchInfo, &cchBuffer);

	if (ERROR_MORE_DATA == uiStat)
	{
		cchBuffer++;
		rgchInfo.SetSize(cchBuffer);
		uiStat = MSI::MsiGetProductInfo(szProductKey, szProperty, rgchInfo, &cchBuffer);
	}

	Assert(ERROR_MORE_DATA != uiStat);

	return (ERROR_SUCCESS == uiStat) ? fTrue : fFalse;
}


Bool GetPatchInfo(const ICHAR* szPatchCode, const ICHAR* szProperty, CTempBufferRef<ICHAR>& rgchInfo)
{
	DWORD cchBuffer = rgchInfo.GetSize();

	UINT uiStat = MSI::MsiGetPatchInfo(szPatchCode, szProperty, rgchInfo, &cchBuffer);

	if (ERROR_MORE_DATA == uiStat)
	{
		rgchInfo.SetSize(cchBuffer+1);
		uiStat = MSI::MsiGetPatchInfo(szPatchCode, szProperty, rgchInfo, &cchBuffer);
	}

	return (ERROR_SUCCESS == uiStat) ? fTrue : fFalse;
}


void ExpandEnvironmentStrings(const ICHAR* szString, const IMsiString*& rpiExpandedString)
/*----------------------------------------------------------------------------
	Expands szString using WIN::ExpandEnvironmentStrings.
------------------------------------------------------------------------------*/
{
	CTempBuffer<ICHAR, MAX_PATH> rgchExpandedInfo;
	
	DWORD dwSize1 = WIN::ExpandEnvironmentStrings(szString, rgchExpandedInfo, rgchExpandedInfo.GetSize());
	if (dwSize1 > rgchExpandedInfo.GetSize())
	{
		// try again with the correct size
		rgchExpandedInfo.SetSize(dwSize1);
		dwSize1 = WIN::ExpandEnvironmentStrings(szString, (ICHAR*)rgchExpandedInfo, dwSize1);
	}
	Assert(dwSize1 && dwSize1 <= rgchExpandedInfo.GetSize());
	
	rpiExpandedString->SetString(rgchExpandedInfo, rpiExpandedString);
}

Bool GetExpandedProductInfo(const ICHAR* szProductCode, const ICHAR* szProperty,
										  CTempBufferRef<ICHAR>& rgchExpandedInfo, bool fPatch)
/*----------------------------------------------------------------------------
Gets an property value and expands the the value using ExpandEnvironmentStrings.

Arguments:
	szProductCode:          The product code of the product
	szProperty:                     The property to retrieve
	rgchExpandedInfo: The buffer for the expanded property value

Returns:        The error code returned from MsiGetProductInfo
------------------------------------------------------------------------------*/
{
	CTempBuffer<ICHAR, MAX_PATH> rgchUnexpandedInfo;
	if (fPatch)
	{
		if (!GetPatchInfo(szProductCode, szProperty, rgchUnexpandedInfo))
			return fFalse;
	}
	else
	{
		if (!GetProductInfo(szProductCode, szProperty, rgchUnexpandedInfo))
			return fFalse;
	}

	DWORD dwSize1 = WIN::ExpandEnvironmentStrings((const ICHAR*)rgchUnexpandedInfo,(ICHAR*)rgchExpandedInfo,rgchExpandedInfo.GetSize());
	if (dwSize1 > rgchExpandedInfo.GetSize())
	{
		// try again with the correct size
		rgchExpandedInfo.SetSize(dwSize1);
		dwSize1 = WIN::ExpandEnvironmentStrings(rgchUnexpandedInfo,(ICHAR*)rgchExpandedInfo, dwSize1);
	}
	Assert(dwSize1 && dwSize1 <= rgchExpandedInfo.GetSize());
	
	return fTrue;
}

bool CMsiEngine::TerminalServerInstallsAreAllowed(bool fAdminUser)
{
	bool fOnConsole = true;
	bool fCloseHandle = false;
	HANDLE hToken;
		
	if (ERROR_SUCCESS == GetCurrentUserToken(hToken, fCloseHandle))
	{
		fOnConsole = IsTokenOnTerminalServerConsole(hToken);
		if (fCloseHandle)
			WIN::CloseHandle(hToken);
	}

	if (!fOnConsole)
	{
		DEBUGMSG(TEXT("Running install from non-console Terminal Server session."));
		if (!fAdminUser || (GetIntegerPolicyValue(szEnableAdminTSRemote, fTrue) != 1))
		{
			DEBUGMSG(TEXT("Rejecting attempt to install from non-console Terminal Server Session"));
			return false;
		}
	}

	return true;
}


extern void CreateCustomActionManager(bool fRemapHKCU); // from execute.cpp

ieiEnum CMsiEngine::DoInitialize(const ICHAR* szOriginalDatabase,
											iuiEnum iuiLevel,
											const ICHAR* szCommandLine,
											const ICHAR* szProductCode,
											iioEnum iioOptions)
{
	PMsiRecord pError(0);
	MsiString istrLanguage;
	MsiString istrTransform;
	MsiString istrPatch;
	MsiString istrAction;
	MsiString istrProductKey;
	MsiString istrPackageKey;
	MsiString strCurrentDirectory;
	MsiString strNewInstance;
	MsiString strInstanceMst;
	Bool fAllUsers = (Bool)-1;

	// summary stream property values
	MsiString istrTemplate;
	MsiString istrPlatform;
//      int iUserChecksum = 0;

	ieiEnum ieiRet;
	Bool fUIPreviewMode = fFalse;
	if (iuiLevel == iuiNextEnum)  // next enum specifies a preview mode only
	{
		fUIPreviewMode = fTrue; // combination happens only with UI preview mode initialization
		iuiLevel = iuiFull;
	}

	// validate iuiLevel
	if (iuiLevel >= iuiNextEnum || iuiLevel < 0)
	{
		iuiLevel = iuiBasic;
		AssertSz(0, "Invalid iuiLevel");
	}

	// get database properties if MSI database
	PMsiDatabase pDatabase(0);
	PMsiStorage pStorage(0);
	
	m_iioOptions = iioOptions;

	if (m_iioOptions & iioRestrictedEngine)
		m_fRestrictedEngine = true;

	bool fIgnoreMachineState = IgnoreMachineState();

	DEBUGMSG1(TEXT("End dialog%s enabled"), m_iioOptions & iioEndDialog ? TEXT("") : TEXT(" not"));

	MsiSuppressTimeout();

	// We need to acquire a storage object if we're not in UI preview mode.

	if (!fUIPreviewMode)
	{
		if (m_piExternalDatabase)    // database supplied at constructor
		{
			pStorage = m_piExternalDatabase->GetStorage(1);
			Assert(m_piExternalStorage == 0);
		}
		else if (m_piExternalStorage) // storage supplied at constructor
		{
			m_piExternalStorage->AddRef();
			pStorage = m_piExternalStorage;
		}
		else
		{
			if (!szOriginalDatabase || !*szOriginalDatabase)  // no database given
			{
#ifdef DISALLOW_NO_DATABASE   //FUTURE: This seems to be test only code
				AssertSz(0, "No database was passed to Engine::Initialize, we have no storage, and we're not in UI Preview mode");
				return ieiDatabaseOpenFailed;
#endif
			}
			else
			{
				//FUTURE: This code seems to be for testing only. We should always be opening the storage on
				//FUTURE:  the outside if we're not in UI preview mode.  -- malcolmh
				if ((pError = m_riServices.CreateStorage(szOriginalDatabase, ismReadOnly, *&pStorage)) == 0)
				{
					// make sure this storage is an MSI storage
					if (!pStorage->ValidateStorageClass(ivscDatabase))
						return ieiDatabaseInvalid;
				}
				else // not IStorage
				{
					return ieiDatabaseOpenFailed;
				}
				//FUTURE:  End test-only code
			}
		}

		// look for command-line properties that we care about right now
		ProcessCommandLine(szCommandLine, &istrLanguage, &istrTransform, &istrPatch, &istrAction, 0, MsiString(*IPROPNAME_CURRENTDIRECTORY), &strCurrentDirectory, fTrue, &m_piErrorInfo,0);
		if((int)istrLanguage == LANG_NEUTRAL)// if the INSTALLPROPERTY_LANGUAGE property is passed on the command line but is 0 (LANG_NEUTRAL) then we let darwin choose the "best fit"
			istrLanguage = TEXT("");

		// check ACTION property - set appropriate mode bit
		if(istrAction.Compare(iscExactI,IACTIONNAME_ADMIN))
			SetMode(iefAdmin, fTrue);
		else if(istrAction.Compare(iscExactI,IACTIONNAME_ADVERTISE))
			SetMode(iefAdvertise, fTrue);
	}


	// By this time we're either in UI preview mode or we've gotten our hands on a storage object.
	
	MsiString istrOriginalDbPath = szOriginalDatabase;  // <-- i.e. the launched-from database, database on the source, or cached db (if we weren't launched from a db)
	MsiString istrRunningDbPath;                        // <-- either a temp file name (for removable) media, or the
																		 //     same as istrOriginalDbPath

	DEBUGMSG1(TEXT("Original package ==> %s"), istrOriginalDbPath);
	MsiString strSourceDir;
	MsiString strSourceDirProduct;
	Bool fRegistered = fFalse;
	Bool fAdvertised = fFalse;
	INSTALLSTATE iINSTALLSTATE = INSTALLSTATE_UNKNOWN; // used to set ProductState property

	if (m_piExternalDatabase)
		pDatabase = m_piExternalDatabase, m_piExternalDatabase->AddRef();

	if (fUIPreviewMode)
	{
		if (!CreatePropertyTable(*pDatabase, sztblProperty, fFalse))
			return ieiDatabaseInvalid;
		//!! get storage if available??

	}
#ifndef DISALLOW_NO_DATABASE   //FUTURE: This seems to be test only code
	else if ((!szOriginalDatabase || !*szOriginalDatabase) && m_piExternalDatabase == 0)  // no database given
	{
		if ((pError = m_riServices.CreateDatabase(0, idoCreate, *&pDatabase)))
			return ieiDatabaseOpenFailed;
		if (!CreatePropertyTable(*pDatabase, 0, fFalse))
			return ieiDatabaseOpenFailed;
	}
#endif
	else // !fUIPreviewMode
	{
		if ((pError = pStorage->GetName(*&istrRunningDbPath)) != 0)
			return PostInitializeError(pError, *istrRunningDbPath, ieiDatabaseOpenFailed);

		DEBUGMSG1(TEXT("Package we're running from ==> %s"), istrRunningDbPath);
		if(!istrOriginalDbPath.TextSize())
			istrOriginalDbPath = istrRunningDbPath;

		m_strPackagePath = istrRunningDbPath;
		
		if (m_piErrorInfo) m_piErrorInfo->Release();
		m_piErrorInfo = istrOriginalDbPath, m_piErrorInfo->AddRef();

		// summary info stuff
		PMsiSummaryInfo pSummary(0);
		m_idSummaryInstallDateTime = MsiDate(0);
		m_iDatabaseVersion = 0;

		if ((pError = pStorage->CreateSummaryInfo(0, *&pSummary)))
			return ieiDatabaseInvalid;

		CTempBuffer<ICHAR, 100> szBuffer;

		GetSummaryInfoProperties(*pSummary, *&istrTemplate, m_iCachedPackageSourceType);
		istrPackageKey = m_pistrSummaryPackageCode->Extract(iseFirst, 38);
		if(!istrPackageKey.TextSize())
			return ieiDatabaseInvalid;
		
		// check the engine and services versions against that required by database
		if (m_iDatabaseVersion < iVersionEngineMinimum || m_iDatabaseVersion > iVersionEngineMaximum
		 || !m_riServices.CheckMsiVersion(m_iDatabaseVersion))
			return ieiInstallerVersion;

		if (pDatabase == 0)
		{
			if ((pError = m_riServices.CreateDatabaseFromStorage(*pStorage, fTrue, *&pDatabase)))
				return PostInitializeError(pError, *istrRunningDbPath, ieiDatabaseInvalid);
		}
		
		// open persistent property table - used to grab properties before/during transform application
		Bool fPropertyTableExists = CreatePropertyTable(*pDatabase, sztblProperty, fTrue);

		// set product code and determine if this product is already registered
		if(szProductCode && *szProductCode)
		{
			istrProductKey = szProductCode;
			istrProductKey.UpperCase(); // make sure the product code is all upper case
		}
		else if(fPropertyTableExists)
		{
			// we weren't passed a product code but we may have a product code in the property table
			// this can happen if we have a new package for an existing product
			istrProductKey = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);
		}

		//
		// MULTIPLE INSTANCE SUPPORT:
		// (1) look for presence of MSINEWINSTANCE on the command line to see if this is a new instance install
		// (2) MSINEWINSTANCE indicates use of instance mst to generate a "new" product
		// (3) strInstanceMst is first transform in list (instance transform must always be first)
		// (4) fRegistered=fAdvertised=fFalse for new instance
		//

		ProcessCommandLine(szCommandLine,0,0,0,0,0,MsiString(IPROPNAME_MSINEWINSTANCE),&strNewInstance,fTrue,0,0);
		if (strNewInstance.TextSize())
		{
			m_fNewInstance = true; // MSINEWINSTANCE specified on command line
			Assert(istrTransform.TextSize() != 0);
			strInstanceMst = istrTransform.Extract(iseUpto, ';');
			Assert(strInstanceMst.TextSize() != 0);
		}

		// don't set iefMaintenance or m_fRegistered until after transforms applied
		// we don't care about the product state if we don't care about the machine state
		// - if this is a new instance, then we also don't care about the product state -- this was already validated
		//    as an unknown product
		if(istrProductKey.TextSize() && !fIgnoreMachineState && !m_fNewInstance)
		{
			iINSTALLSTATE = GetProductState(istrProductKey, fRegistered, fAdvertised);
		}

		MsiString strClientUILevel;
		ProcessCommandLine(szCommandLine,0,0,0,0,0,
								 MsiString(IPROPNAME_CLIENTUILEVEL),&strClientUILevel,
								 fTrue, 0, 0);
		iuiEnum iuiAppCompat = iuiNone;
		if(g_scServerContext == scClient)
		{
			iuiAppCompat = iuiLevel;
		}
		else if(strClientUILevel.TextSize())
		{
			iuiAppCompat = (iuiEnum)(int)strClientUILevel;
		}

		m_iacsShimFlags = (iacsAppCompatShimFlags)0;
		bool fDontInstallPackage = false;
		bool fQuiet = false;
		if (iuiAppCompat == iuiNone || g_scServerContext == scService)
			fQuiet = true; // use quiet mode if no UI or we are running in the service

		ApplyAppCompatTransforms(*pDatabase, *istrProductKey, *istrPackageKey, iacpBeforeTransforms, m_iacsShimFlags,
										 fQuiet, /*fProductCodeChanged = */ false, fDontInstallPackage); // ignore failure

		if(fDontInstallPackage)
		{
			MsiString strProductName = GetPropertyFromSz(IPROPNAME_PRODUCTNAME);
			if(!strProductName.TextSize())
				strProductName = istrOriginalDbPath;

			DEBUGMSGE(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_APPHELP_REJECTED_PACKAGE, strProductName);
			return PostInitializeError(0, *istrOriginalDbPath, ieiApphelpRejectedPackage);
		}

		//
		// MULTIPLE INSTANCE SUPPORT:
		//  Obtain name of instance transform as this must be applied prior to applying any patches. Otherwise
		//  wrong target of multi-target patch may be chosen or patch application may fail if patch is a major patch
		//  which changes the product code. The multi-instance mst will include ProductCode validation.
		//

		// get the advertised language and transforms, if any
		if(fAdvertised && !fIgnoreMachineState)
		{
			if (ENG::GetExpandedProductInfo(istrProductKey, INSTALLPROPERTY_TRANSFORMS, szBuffer))
				istrTransform = (const ICHAR*)szBuffer;

			if (ENG::GetProductInfo(istrProductKey, INSTALLPROPERTY_LANGUAGE, szBuffer))
				istrLanguage = (const ICHAR*)szBuffer;

			if (ENG::GetProductInfo(istrProductKey, INSTALLPROPERTY_INSTANCETYPE, szBuffer))
			{
				if (MsiString(*(ICHAR*)szBuffer) == 1)
				{
					// this is a multi-instance install using an instance transform
					// the instance transform is always the first transform in the list
					strInstanceMst = istrTransform.Extract(iseUpto, ';');
					Assert(strInstanceMst.TextSize() != 0);
				}
			}
		}

		if (strInstanceMst.TextSize())
		{
			DEBUGMSGV(TEXT("Detected that this product uses a multiple instance transform."));
		}

		// Set the default install overwrite modes
		SetMode(iefOverwriteOlderVersions,fTrue);
		SetMode(iefInstallMachineData,fTrue);
		SetMode(iefInstallUserData,fTrue);
		SetMode(iefInstallShortcuts,fTrue);

		// set source type mode flags
		if (m_iCachedPackageSourceType & msidbSumInfoSourceTypeSFN)
			SetMode(iefNoSourceLFN, fTrue);
		if (m_iCachedPackageSourceType & msidbSumInfoSourceTypeCompressed)
			SetMode(iefCabinet, fTrue);

		// process install options
		if(iioOptions & iioUpgrade)
		{
			Assert(m_piParentEngine);
			m_fBeingUpgraded = true;
		}
		if(iioOptions & iioChild)
		{
			Assert(m_piParentEngine);
			m_fChildInstall = true;
		}
		if(iioOptions & iioEndDialog)
			m_fEndDialog = true;

		// process platform and language
		istrPlatform = istrTemplate.Extract(iseUpto, ISUMMARY_DELIMITER);
		istrTemplate.Remove(iseIncluding, ISUMMARY_DELIMITER);

		// always call ProcessPlatform, since it sets some flags, but if iioDisablePlatformValidation is set
		// (as it is when creating an advertise script) we will ignore the return value
		ieiRet = ProcessPlatform(*istrPlatform, m_wPackagePlatform);
		AssertSz(m_wPackagePlatform == PROCESSOR_ARCHITECTURE_ALPHA ||
					m_wPackagePlatform == PROCESSOR_ARCHITECTURE_INTEL ||
					m_wPackagePlatform == PROCESSOR_ARCHITECTURE_IA64  ||
					m_wPackagePlatform == PROCESSOR_ARCHITECTURE_ALPHA64 ||
					m_wPackagePlatform == PROCESSOR_ARCHITECTURE_UNKNOWN /* mixed package */,
					TEXT("Invalid platform returned by ProcessPlatform!"));
		// mixed packages are not supported -- even if iioDisablePlatformValidation
		if (PROCESSOR_ARCHITECTURE_UNKNOWN == m_wPackagePlatform)
			return ieiDatabaseInvalid;

		// check for unsupported platform
		if(!(iioOptions & iioDisablePlatformValidation) && (ieiRet != ieiSuccess))
			return ieiRet;

		// enforce schema 150 with 64-bit packages
		if (PROCESSOR_ARCHITECTURE_IA64 == m_wPackagePlatform && m_iDatabaseVersion < iMinimumPackage64Schema)
			return ieiDatabaseInvalid;

		unsigned short iBaseLangId = 0; // to avoid warning
		
		if ((ieiRet = ProcessLanguage(*istrTemplate, *istrLanguage, iBaseLangId, /*(iuiLevel == iuiNone) ?*/ fTrue /*: fFalse*/, fIgnoreMachineState)) != ieiSuccess)
		{
			// per bug 195470, distinguish case where language differs from registered language
			if ((fAdvertised && !fIgnoreMachineState) && istrLanguage.TextSize() && ieiLanguageUnsupported == ieiRet)
			{
				// product has already been installed, but was registered with a language that isn't supported by this package
				// you can't change the language without including a package code/product code change
				ieiRet = ieiProductAlreadyInstalled;
			}
			return ieiRet;
		}

		tsEnum tsTransformsSecure = tsNo;
		
		MsiString strTransformsSecure;
		MsiString strTransformsAtSource;

		ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_TRANSFORMSSECURE),   &strTransformsSecure, fTrue, &m_piErrorInfo,0);
		ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_TRANSFORMSATSOURCE), &strTransformsAtSource, fTrue, &m_piErrorInfo,0);

		// There are three ways that a transform can be considered secure:
		// 1) a token at the front of the transforms list
		// 2) setting the TRANSFORMSSECURE or TRANSFORMSATSOURCE property
		// 3) setting the relevent policy value (only if we're not creating an advertise script and
		//    the product is not already advertised. once the product is advertised then whatever
		//    is registered in the transforms list is what we go with)
		
		if ((*(const ICHAR*)istrTransform == SECURE_RELATIVE_TOKEN))
		{
			tsTransformsSecure = tsRelative;
		}
		else if ((*(const ICHAR*)istrTransform == SECURE_ABSOLUTE_TOKEN))
		{
			tsTransformsSecure = tsAbsolute;
		}
		else if (!fAdvertised)
		{
			if ((GetPropertyInt(*MsiString(*IPROPNAME_TRANSFORMSSECURE))   == 1) ||
				(GetPropertyInt(*MsiString(*IPROPNAME_TRANSFORMSATSOURCE)) == 1) ||
				(strTransformsSecure   == 1) ||
				(strTransformsAtSource == 1) ||
				(!fIgnoreMachineState && GetIntegerPolicyValue(szTransformsSecureValueName, fTrue)) ||
				(!fIgnoreMachineState && GetIntegerPolicyValue(szTransformsAtSourceValueName, fFalse)))
			{
				tsTransformsSecure = tsUnknown;
			}
		}

		const IMsiString* pistrRecacheTransform = &g_MsiStringNull;
		const IMsiString* pistrProcessedTransforms = &g_MsiStringNull;
		
		int cTransformsProcessed = 0;

		//
		// MULTIPLE INSTANCE SUPPORT:
		//   Apply multiple instance transform first to ensure that subsequent patches target the correct product.
		//   Customization transforms are always applied after patches.  If the instance transform were not applied
		//   prior to the patch transforms, then a multi-target patch may choose an incorrect target since the
		//   basis of transform selection is dependent upon the current product code.
		//

		if (strInstanceMst.TextSize() != 0)
		{
			DEBUGMSGV1(TEXT("Applying multiple instance transform '%s'..."), strInstanceMst);
			for (int c=0; c<2; c++)
			{
				ieiRet = InitializeTransforms(*pDatabase, 0, *strInstanceMst, fTrue, 0, false, true, true, &cTransformsProcessed, strSourceDir, strCurrentDirectory, &pistrRecacheTransform, &tsTransformsSecure, &pistrProcessedTransforms);
				
				if (ieiSuccess == ieiRet)
				{
					break;
				}
				else if (ieiResolveSourceAndRetry == ieiRet)
				{
					PMsiRecord pError = ResolveSource(istrProductKey, false, istrOriginalDbPath, iuiLevel, fRegistered, &strSourceDir, &strSourceDirProduct);
					if (pError)
					{
						pistrRecacheTransform->Release();
						pistrProcessedTransforms->Release();
						return ieiSourceAbsent;
					}
					continue;
				}
				else
				{
					pistrRecacheTransform->Release();
					pistrProcessedTransforms->Release();
					return ieiRet;
				}
				Assert(0);
			}
		}

		// initialize patch - process new patch if there is one, apply existing and new transforms
		ieiRet = InitializePatch(*pDatabase, *istrPatch, istrProductKey, fAdvertised, strCurrentDirectory, iuiLevel); // OK if istrProductKey not set
		if(ieiRet != ieiSuccess)
			return ieiRet;

		if ((GetLanguage() != LANG_NEUTRAL) &&     // <- package is language neutral
			 (iBaseLangId != GetLanguage()))        // <- we're using the package's base language
		{
			if ((ieiRet = ApplyLanguageTransform(int(GetLanguage()), *pDatabase)) != ieiSuccess) // OK is istrProductKey not set
				return ieiRet;
		}

		// need to set language as early as possible for possible UI dialogs
		if (!m_piParentEngine)
		{
			PMsiRecord pDialogInfo(&ENG::CreateRecord(3));
			pDialogInfo->SetInteger(1, icmtLangId);
			pDialogInfo->SetInteger(2, GetLanguage());
			pDialogInfo->SetInteger(3, pDatabase->GetANSICodePage());
			g_MessageContext.Invoke(imtEnum(imtCommonData | imtSuppressLog), pDialogInfo); // will call again later for log
		}


		for (int c=0; c<2; c++)
		{
			ieiRet = InitializeTransforms(*pDatabase, 0, *istrTransform, fTrue, 0, false, false, fRegistered ? true: false, &cTransformsProcessed, strSourceDir, strCurrentDirectory, &pistrRecacheTransform, &tsTransformsSecure, &pistrProcessedTransforms);
			
			if (ieiSuccess == ieiRet)
			{
				break;
			}
			else if (ieiResolveSourceAndRetry == ieiRet)
			{
				PMsiRecord pError = ResolveSource(istrProductKey, false, istrOriginalDbPath, iuiLevel, fRegistered, &strSourceDir, &strSourceDirProduct);
				if (pError)
				{
					pistrRecacheTransform->Release();
					pistrProcessedTransforms->Release();
					return ieiSourceAbsent;
				}
				continue;
			}
			else
			{
				pistrRecacheTransform->Release();
				pistrProcessedTransforms->Release();
				return ieiRet;
			}
			Assert(0);
		}

		// scope variables
		bool fProductCodeChanged = false;
		MsiString istrTransformedProductKey = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);
		if (istrProductKey.Compare(iscExactI,istrTransformedProductKey) == 0)
			fProductCodeChanged = true;

		iacsAppCompatShimFlags iShimFlagsTemp = (iacsAppCompatShimFlags)0;
		ApplyAppCompatTransforms(*pDatabase, fProductCodeChanged ? *istrTransformedProductKey : *istrProductKey, *istrPackageKey, iacpAfterTransforms, iShimFlagsTemp,
										 fQuiet, fProductCodeChanged, fDontInstallPackage); // ignore failure
		m_iacsShimFlags = (iacsAppCompatShimFlags)(m_iacsShimFlags|iShimFlagsTemp);

		if(fDontInstallPackage)
		{
			MsiString strProductName = GetPropertyFromSz(IPROPNAME_PRODUCTNAME);
			if(!strProductName.TextSize())
				strProductName = istrOriginalDbPath;

			DEBUGMSGE(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_APPHELP_REJECTED_PACKAGE, strProductName);
			return PostInitializeError(0, *istrOriginalDbPath, ieiApphelpRejectedPackage);
		}

		Assert(tsTransformsSecure != tsUnknown);
		DEBUGMSG1(TEXT("Transforms are %s secure."), (tsTransformsSecure == tsNo) ? TEXT("not") : (tsTransformsSecure == tsAbsolute) ? TEXT("absolute") : (tsTransformsSecure == tsRelative) ? TEXT("relative") : TEXT("??"));

		if (!CreatePropertyTable(*pDatabase, sztblProperty, fFalse))  // load property table - lowest priority properties
			return ieiDatabaseInvalid;

		LogCommandLine(szCommandLine, *pDatabase);

		SetProperty(*MsiString(*IPROPNAME_PACKAGECODE),*istrPackageKey);
		SetProperty(*MsiString(*IPROPNAME_RECACHETRANSFORMS), *pistrRecacheTransform);
		SetProperty(*MsiString(*IPROPNAME_TRANSFORMS), *pistrProcessedTransforms);

		istrTransform = *pistrProcessedTransforms;
		pistrRecacheTransform->Release();

		// Now that we have a property table we can set the transforms properties

		if (tsTransformsSecure == tsAbsolute || tsTransformsSecure == tsRelative)
		{
			SetPropertyInt(*MsiString(*IPROPNAME_TRANSFORMSSECURE),   1);
			SetPropertyInt(*MsiString(*IPROPNAME_TRANSFORMSATSOURCE), 1);
		}
		else
		{
			SetProperty(*MsiString(*IPROPNAME_TRANSFORMSSECURE),      g_MsiStringNull);
			SetProperty(*MsiString(*IPROPNAME_TRANSFORMSATSOURCE), g_MsiStringNull);
		}

		MsiString istrProductKeyProperty = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);

		DEBUGMSG1(TEXT("Product Code passed to Engine.Initialize:           '%s'"),szProductCode ? szProductCode : TEXT("(none)"));
		DEBUGMSG1(TEXT("Product Code from property table before transforms: '%s'"),istrProductKey);
		DEBUGMSG1(TEXT("Product Code from property table after transforms:  '%s'"),istrProductKeyProperty);

		MsiString istrPatchedProductCode;
		if(istrProductKey.Compare(iscExactI,istrProductKeyProperty) == 0)
		{
			if(istrPatch.TextSize())
			{
				// during a patch we are changing the product code - need to migrate source settings from old product
				istrPatchedProductCode = istrProductKey;
				SetProperty(*MsiString(*IPROPNAME_MIGRATE),*istrProductKey);
				SetProperty(*MsiString(*IPROPNAME_PATCHEDPRODUCTCODE),*istrProductKey);
			}
			
			istrProductKey = istrProductKeyProperty;
			iINSTALLSTATE = GetProductState(istrProductKey, fRegistered, fAdvertised);
		}

		if (!fAdvertised)
		{
			MsiString strRemove;
			ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_FEATUREREMOVE), &strRemove, fTrue, &m_piErrorInfo,0);
			if (strRemove.Compare(iscExact, IPROPVALUE_FEATURE_ALL))
				return ieiProductUnknown;
		}

		if(fRegistered)
			DEBUGMSG(TEXT("Product registered: entering maintenance mode"));
		else
			DEBUGMSG(TEXT("Product not registered: beginning first-time install"));

		SetMode(iefMaintenance, fRegistered);
		m_fRegistered = fRegistered;
		m_fAdvertised = fAdvertised;
		
		Assert(iINSTALLSTATE != INSTALLSTATE_INVALIDARG && iINSTALLSTATE != INSTALLSTATE_BADCONFIG);
		SetPropertyInt(*MsiString(IPROPNAME_PRODUCTSTATE),iINSTALLSTATE);
		
		// set PRODUCTTOBEREGISTERED property.  used by ForceReboot
		if(fRegistered)
			SetPropertyInt(*MsiString(*IPROPNAME_PRODUCTTOBEREGISTERED),1);

		if (istrProductKey.TextSize())
		{
			if (m_piProductKey)
				m_piProductKey->Release();
			m_piProductKey = istrProductKey, m_piProductKey->AddRef();
		}

		MsiString strProductCode = GetProductKey();

		// verify that the source passed in to us is valid - there are several cases where it may not be
		// special cases:
		// 1) we are a child install (and have a parent engine): assume the parent has already validated
		//    the source location.  NOTE: you can't invoke a child install without going through the	
		//    parent - see bug 8263
		// 2) we are a normal install but this product was previously installed as a child install:
		//    in this case, the existing install doesn't have a sourcelist so we can't easily verify the
		//    source.  FSourceIsAllowed will fail.  this case was knowingly broken by the fix to bug 8285
		if(!m_fChildInstall)
		{
			if(!fAdvertised || !IsCachedPackage(*this, *istrOriginalDbPath))
			{
				PMsiPath pOriginalDbPath(0);
				MsiString strOriginalDbName;
				if ((pError = m_riServices.CreateFilePath(istrOriginalDbPath, *&pOriginalDbPath, *&strOriginalDbName)) != 0)
					return PostInitializeError(pError, *istrOriginalDbPath, ieiDatabaseOpenFailed); //?? is this the correct iei to use here?

				if(!FSourceIsAllowed(m_riServices, !fAdvertised, strProductCode, MsiString(pOriginalDbPath->GetPath()), fFalse))
				{
					// assume new source is disallowed by policy
					return PostInitializeError(pError, *istrOriginalDbPath, ieiPackageRejected);
				}
			}
		}

		CTempBuffer<ICHAR, 39> rgchRegisteredPackageCode;
		rgchRegisteredPackageCode[0] = 0;
		MsiString strPackageCode = GetPropertyFromSz(IPROPNAME_PACKAGECODE);
		GetProductInfo(strProductCode, TEXT("PackageCode"), rgchRegisteredPackageCode);
		if (strPackageCode.Compare(iscExactI, rgchRegisteredPackageCode) == 0)
			AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_PACKAGECODE_CHANGING), 1));

		// changing the package code w/o recaching the package is not allowed
		if(!(iioOptions & iioReinstallModePackage) &&
			!(GetMode() & iefAdvertise) &&
			!(GetMode() & iefAdmin) &&
			m_fRegistered &&
			MsiString(GetPropertyFromSz(IPROPNAME_PACKAGECODE_CHANGING)).TextSize() != 0)
		{
			return PostInitializeError(0, *strProductCode, ieiProductAlreadyInstalled);
		}

		// set m_strPackageName
		m_strPackageName = g_MsiStringNull;

		// first, check for embedded nested package
		if (*(const ICHAR*)istrOriginalDbPath == ':') // SubStorage
		{																								
			// substorage for nested install
			m_strPackageName = istrOriginalDbPath;  // whatever string was passed in
		}
		else
		{
			// if not an admin install, and not creating an advertise script, and name is in the registry, use it
			if(!(GetMode() & iefAdmin) && !fIgnoreMachineState && strProductCode.TextSize())
			{
				MsiString strProductCodeForPackageName;
				if(istrPatchedProductCode.TextSize())
				{
					// if patching, package name is package name from old product
					strProductCodeForPackageName = istrPatchedProductCode;
				}
				else
				{
					strProductCodeForPackageName = strProductCode;
				}

				if(GetProductInfo(strProductCodeForPackageName, INSTALLPROPERTY_PACKAGENAME, szBuffer) &&
					szBuffer[0] != 0)
				{
					m_strPackageName = (const ICHAR*)szBuffer;
					DEBUGMSG1(TEXT("Package name retrieved from configuration data: '%s'"), (const ICHAR*)m_strPackageName);
				}
			}
			
			// if not in the registry, or an admin install, or creating an advertise script
			// use the name of the package we started with
			if(!m_strPackageName.TextSize())
			{
				PMsiPath pOriginalDbPath(0);
				if ((pError = m_riServices.CreateFilePath(istrOriginalDbPath, *&pOriginalDbPath, *&m_strPackageName)) != 0)
					return PostInitializeError(pError, *istrRunningDbPath, ieiDatabaseOpenFailed); //?? is this the correct iei to use here?

				DEBUGMSG1(TEXT("Package name extracted from package path: '%s'"), (const ICHAR*)m_strPackageName);

				if (pOriginalDbPath->SupportsLFN() && (MinimumPlatform(true, 4, 10) || MinimumPlatform(false, 4, 00)))
				{
					CTempBuffer<ICHAR, 20> rgchLFN;
					if (DetermineLongFileNameOnly(istrOriginalDbPath, rgchLFN))
					{
						m_strPackageName = static_cast<const ICHAR *>(rgchLFN);
						DEBUGMSG1(TEXT("Package to be registered: '%s'"), m_strPackageName);
					}
				}
			}
		}
		
		Assert(m_strPackageName.TextSize());
		                                                                                      
		if((GetMode() & iefAdmin) && istrPatch.TextSize())
		{
			// patching an admin install
			
			// 1) set TARGETDIR to package path
			MsiString strTargetDir;
			if ((pError = SplitPath(istrOriginalDbPath, &strTargetDir, 0)) != 0)
				return PostInitializeError(pError, *istrRunningDbPath, ieiDatabaseOpenFailed); //?? is this the correct iei to use here?

			AssertNonZero(SetProperty(*MsiString(IPROPNAME_TARGETDIR),*strTargetDir));

			// 2) if patching an admin image that uses short names, set SHORTFILENAMES
			if(GetMode() & iefNoSourceLFN)
			{
				AssertNonZero(SetPropertyInt(*MsiString(IPROPNAME_SHORTFILENAMES), 1));
			}
		}

		// if this product is already installed, set ALLUSERS to appropriate value
		// OR if performing a major upgrade patch over an installed product, set ALLUSERS to reflect the old product's state
		if(GetProductInfo(istrProductKey, INSTALLPROPERTY_ASSIGNMENTTYPE, szBuffer) ||
			(istrPatchedProductCode.TextSize() && GetProductInfo(istrPatchedProductCode, INSTALLPROPERTY_ASSIGNMENTTYPE, szBuffer)))
		{
			// the product is already known
			fAllUsers = (MsiString(*(ICHAR* )szBuffer) == 1) ? fTrue: fFalse;
			
			DEBUGMSG1(TEXT("Determined that existing product (either this product or the product being upgraded with a patch) is installed per-%s."),
						 fAllUsers ? TEXT("machine") : TEXT("user"));
		}

		// load message headers from error table
		if ((ieiRet = LoadMessageHeaders(pDatabase)) != ieiSuccess)
			return ieiRet;
	
	} // !fUIPreviewMode
	
	// process properties from the admin stream.  Overrides database and userinfo properties.
	if (pStorage)
	{
		PMsiStream pAdminDataUNICODE(0);
		pError = pStorage->OpenStream(IPROPNAME_ADMIN_PROPERTIES, fFalse, *&pAdminDataUNICODE);
		if ((!pError) && pAdminDataUNICODE)
		{
			CTempBuffer<WCHAR, 1024> rgchBufferUNICODE;
			int cbRemaining = pAdminDataUNICODE->Remaining();
			if (cbRemaining > 1024*sizeof(WCHAR))
				rgchBufferUNICODE.SetSize(cbRemaining / sizeof(WCHAR));
			pAdminDataUNICODE->GetData((void*) rgchBufferUNICODE, cbRemaining);
	#ifdef UNICODE
			// This shouldn't be wrong, short of a corrupted database.
			AssertNonZero(ProcessCommandLine(rgchBufferUNICODE, 0, 0, 0, 0, 0, 0, 0,fFalse, &m_piErrorInfo, this));
	#else // !UNICODE
			CTempBuffer<ICHAR, 1024> rgchBufferANSI;
			int cchAnsi = WIN::WideCharToMultiByte(CP_ACP, 0, rgchBufferUNICODE, -1, 0, 0, 0, 0);
			if (cchAnsi > 1024)
				rgchBufferANSI.SetSize(cchAnsi);
			WIN::WideCharToMultiByte(CP_ACP, 0, rgchBufferUNICODE, -1, rgchBufferANSI, cchAnsi, 0, 0);
			// This shouldn't be wrong, short of a corrupted database.
			AssertNonZero(ProcessCommandLine(rgchBufferANSI, 0, 0, 0, 0, 0, 0, 0,fFalse, &m_piErrorInfo, this));
	#endif
		}
	}

	const IMsiString* pistrAllUsers = 0;
	ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_ALLUSERS), &pistrAllUsers, fTrue, &m_piErrorInfo,0);
	if (pistrAllUsers)
	{
		SetProperty(*MsiString(IPROPNAME_ALLUSERS), *pistrAllUsers);
		pistrAllUsers->Release();
	}

	bool fWin9XProfilesEnabled = false;
	if(g_fWin9X)
	{
		static const ICHAR szProfilesKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation");
		static const ICHAR szProfilesVal[] = TEXT("ProfileDirectory");

		PMsiRegKey pRoot = &m_riServices.GetRootKey(rrkCurrentUser);
		PMsiRegKey pKey = &pRoot->CreateChild(szProfilesKey);
		MsiString strProfilesDir;
		PMsiRecord pErr = pKey->GetValue(szProfilesVal, *&strProfilesDir);
		if(!pErr && strProfilesDir.TextSize())
		{
			fWin9XProfilesEnabled = true;
			SetPropertyInt(*MsiString(*IPROPNAME_WIN9XPROFILESENABLED), 1);
		}
	}


	// set hardware and operating system properties, overrides existing properties
	if((int)fAllUsers == -1)
	{
		if(!g_fWin9X)
		{
			if (GetPropertyInt(*MsiString(*IPROPNAME_ALLUSERS)) == 2)
			{
				if (IsAdmin())
				{
					fAllUsers = fTrue;
					SetPropertyInt(*MsiString(*IPROPNAME_ALLUSERS), 1);
				}
				else
				{
					fAllUsers = fFalse;
					SetProperty(*MsiString(*IPROPNAME_ALLUSERS), *MsiString(*TEXT(""))); // remove the property, if set
				}
			}
			else
			{
				fAllUsers = MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? fTrue : fFalse;
			}
		}
		else
		{
			// the assignment type is implicit on Win95 based on -
			// If Profiles are on and start menu is per-user - darwin goop to HKCU, transforms and icons to AppData
			// If Profiles are on and startmenu is shared - darwin goop to HKLM, transforms and icons to Windows folder
			// Profiles are not on (start menu is shared) - darwin goop to HKCU, transforms and icons to AppData

			bool fWin9XIndividualStartMenuEnabled = false;

			PMsiRecord pErr(0);
			static const ICHAR szStartMenuKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation\\Start Menu");

			PMsiRegKey pRoot = &m_riServices.GetRootKey(rrkCurrentUser);
			PMsiRegKey pKey = &pRoot->CreateChild(szStartMenuKey);
			Bool fKeyExists;
			pErr = pKey->Exists(fKeyExists);
			if(!pErr && fKeyExists)
				fWin9XIndividualStartMenuEnabled = true;

			if(fWin9XProfilesEnabled && !fWin9XIndividualStartMenuEnabled)
			{
				fAllUsers = fTrue;
				SetPropertyInt(*MsiString(*IPROPNAME_ALLUSERS), 1);
			}
			else
			{
				fAllUsers = fFalse; // write darwin goop to HKCU
				SetProperty(*MsiString(*IPROPNAME_ALLUSERS), *MsiString(*TEXT(""))); // remove the property, if set
			}
		}
	}
	else if(fAllUsers == fTrue)
		SetPropertyInt(*MsiString(*IPROPNAME_ALLUSERS), 1);
	else
		SetProperty(*MsiString(*IPROPNAME_ALLUSERS), *MsiString(*TEXT(""))); // remove the property, if set

	// for SourceList/Patch security, the elevation state is needed before this code is run
	// and/or without an engine. SafeForDangerousSourceAction (in msiutil.cpp) duplicates the
	// call to AcceptProduct using values obtained from the registry.
	apEnum ap = AcceptProduct(istrProductKey, fAdvertised?fTrue:fFalse, fAllUsers?true:false);
	switch (ap)
	{
	case apImpersonate:
		m_fRunScriptElevated = false;
		g_fRunScriptElevated = false;
		break;
	case apElevate:
		m_fRunScriptElevated = true;
		g_fRunScriptElevated = true;
		break;
	default:
		Assert(0);
	case apReject:
		return ieiPackageRejected;
	}

	// process properties from command line, overrides database, admin install and userinfo properties

	bool fRejectDisallowedProperties = false;
	if ( m_fRunScriptElevated &&
		 !g_fWin9X  &&
		 !IsAdmin() &&
		 !MsiString(GetPropertyFromSz(IPROPNAME_ENABLEUSERCONTROL)).TextSize() &&
		  GetIntegerPolicyValue(szAllowAllPublicProperties, fTrue) != 1)
	{
		SetPropertyInt(*MsiString(*IPROPNAME_RESTRICTEDUSERCONTROL), 1);
		fRejectDisallowedProperties = true;
	}

	if (!ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, 0, 0, fTrue, &m_piErrorInfo, this, fRejectDisallowedProperties))
		return ieiCommandLineOption;

	if (MsiString(GetPropertyFromSz(IPROPNAME_SECONDSEQUENCE)).TextSize())
	{
		DEBUGMSG("Engine has iefSecondSequence set to true.");
		SetMode(iefSecondSequence, fTrue);
	}

	// Override any command-line setting of ALLUSERS. We've already determine above
	// what we want ALLUSERS to be set to. This acommodates the command-line
	// if the product has not yet been advertised. Otherwise the command-line
	// is ignored.
	if (fAllUsers == fTrue)
		SetPropertyInt(*MsiString(*IPROPNAME_ALLUSERS), 1);
	else
		SetProperty(*MsiString(*IPROPNAME_ALLUSERS), *MsiString(*TEXT(""))); // remove the property, if set

	SetProperty(*MsiString(*IPROPNAME_TRANSFORMS), *istrTransform);
	DEBUGMSG1(TEXT("TRANSFORMS property is now: %s"), (const ICHAR*)MsiString(GetPropertyFromSz(IPROPNAME_TRANSFORMS)));
	SetProperty(*MsiString(*IPROPNAME_PRODUCTLANGUAGE), *istrLanguage);
	if (m_fChildInstall)
	{
		SetProperty(*MsiString(*IPROPNAME_PARENTPRODUCTCODE), *MsiString(m_piParentEngine->GetProductKey()));
		SetProperty(*MsiString(*IPROPNAME_PARENTORIGINALDATABASE), *MsiString(m_piParentEngine->GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE)));
	}

	SetProperty(*MsiString(*IPROPNAME_SOURCEDIR), *strSourceDir);
	SetProperty(*MsiString(*IPROPNAME_SOURCEDIROLD), *strSourceDir);

	SetProperty(*MsiString(*IPROPNAME_SOURCEDIRPRODUCT), *strSourceDirProduct);

	
	// set the database version property, if not already set (could be changed via transforms)
	if(GetPropertyInt(*MsiString(IPROPNAME_VERSIONDATABASE)) == iMsiStringBadInteger)
		AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_VERSIONDATABASE), m_iDatabaseVersion));


	isppEnum isppArchitecture = isppDefault;
	if (iioOptions & iioCreatingAdvertiseScript)
	{
		if ( (iioOptions & iioSimulateX86) && (iioOptions & iioSimulateIA64) )
		{
			// should not happend
			AssertSz(0, TEXT("Simulation of more than one architecture specified"));
		}
		if (iioOptions & iioSimulateX86)
			isppArchitecture = isppX86;
		else if (iioOptions & iioSimulateIA64)
			isppArchitecture = isppIA64;
		// else use isppDefault
	}

	// create FolderCache table
	AssertNonZero(CreateFolderCache(*pDatabase));

	if(!m_riServices.SetPlatformProperties(*PMsiTable(&m_piPropertyCursor->GetTable()),
	g_fWin9X ? fFalse : fAllUsers, isppArchitecture, m_pFolderCacheTable)) /* ALLUSERS for shell folders makes sense only on Win NT*/
			return ieiDatabaseInvalid;

	if ( g_fWinNT64 )
	{
		strFolderPairs rgstFolders[] =
			{strFolderPairs(IPROPNAME_SYSTEM64_FOLDER,       IPROPNAME_SYSTEM_FOLDER,       ieSwapForSharedDll),
			 strFolderPairs(IPROPNAME_PROGRAMFILES64_FOLDER, IPROPNAME_PROGRAMFILES_FOLDER),
			 strFolderPairs(IPROPNAME_COMMONFILES64_FOLDER,  IPROPNAME_COMMONFILES_FOLDER),
			 strFolderPairs(TEXT(""), TEXT(""))};
		for (int i=0; rgstFolders[i].str32bit.TextSize() && rgstFolders[i].str64bit.TextSize(); i++)
		{
			MsiString str64bit = GetProperty(*rgstFolders[i].str64bit);
			MsiString str32bit = GetProperty(*rgstFolders[i].str32bit);
			if ( !str64bit.TextSize() || !str32bit.TextSize() )
			{
				// something went wrong
				Assert(false);
			}
			else
			{
				rgstFolders[i].str64bit = str64bit;
				rgstFolders[i].str32bit = str32bit;
			}
		}
		CWin64DualFolders oTemp(m_wPackagePlatform == PROCESSOR_ARCHITECTURE_INTEL, rgstFolders);
		g_Win64DualFolders = oTemp;
	}

	bool fAdminUser = MsiString(GetPropertyFromSz(IPROPNAME_ADMINUSER)).TextSize() != 0;

	// Reject attempts to install on Terminal Server unless the user is either on the console
	// or is an admin with the EnableAdminRemote policy set.

	if (MsiString(GetPropertyFromSz(IPROPNAME_TERMSERVER)).TextSize())
	{
		if (fAdminUser && (fIgnoreMachineState || (m_fMode & iefAdmin)))
		{
			// If you're an admin and you're creating an advertise script or
			// doing an admin install then you aren't subject to any restriction.
			// The rationale is that the restriction of admins on client session
			// installs exists simply to protect the admin from unintended installs
			// triggered through faulting in of components; these installs could
			// reboot the server which might not make the admin happy. Advertise
			// script generation, and admin installs, however, are always safe for
			// the admin to do. Therefore, they don't need to set any policy to allow
			// themselves to do these.
		}
		else if (!TerminalServerInstallsAreAllowed(fAdminUser))
			return ieiTSRemoteInstallDisallowed;
	}
			
	if (m_fRunScriptElevated || fAdminUser)
		SetPropertyInt(*MsiString(*IPROPNAME_PRIVILEGED), 1);

	InitializeUserInfo(*istrProductKey);

	// set properties from summary stream
	if (m_fSummaryInfo)
	{
		m_pistrPlatform     = istrPlatform;    m_pistrPlatform->AddRef();
		if (m_fMode & iefMaintenance)
			SetProperty(*MsiString(*IPROPNAME_INSTALLED),
							*MsiString(DateTimeToString(m_idSummaryInstallDateTime)));
	}

	// update properties passed as arguments
	SetProperty(*MsiString(*IPROPNAME_DATABASE), *istrRunningDbPath);
	SetProperty(*MsiString(*IPROPNAME_ORIGINALDATABASE), *istrOriginalDbPath);

	m_piDatabase = pDatabase, m_piDatabase->AddRef(); // need to set before calling handler

	InitializeExtendedSystemFeatures(); // GPT support, extended shell, etc.

	// Initialize the UI after the properties and objects have been set
	m_iuiLevel = iuiLevel;
	if (m_piParentEngine)  // nested install
	{
		if (m_piParentEngine->InTransaction())  // can only check this at one point
		{
			m_fInParentTransaction = fTrue;
			m_fServerLocked = fTrue;

			if((iioOptions & iioUpgrade) == 0) // in all cases but upgrades, if in the parent transaction we will
														  // merge our install script with the parent's
			{
				m_fMergingScriptWithParent = fTrue;
			}
		}
		SetMode(iefLogEnabled, (m_piParentEngine->GetMode() & iefLogEnabled) ? fTrue : fFalse);  //!! always false now

		// if the child install is running in the same transaction as the parent, and the
		// elevation states differ, we can't run the nested install.
		if (!g_fWin9X && m_fMergingScriptWithParent && (m_piParentEngine->m_fRunScriptElevated != m_fRunScriptElevated))
		{
			DEBUGMSG("Child install has different elevation state than parent. Possible pre-existing install or machine/user conflict. Failing child install.");
			return ieiPackageRejected;
		}
	}
	else if (fUIPreviewMode)
	{
		if (LoadHandler() == imsError)
			return ieiHandlerInitFailed;
	}
	else
	{
		if ((ieiRet = InitializeUI(iuiLevel)) != ieiSuccess)
			return ieiRet;
		if ((ieiRet = InitializeLogging()) != ieiSuccess)
			return ieiRet;
	}

	// need to call after setting m_piDatabase
	AssertNonZero(SetPatchSourceProperties()); //!! error??

	// Set the Engine's LFN mode
	MsiString istrShortNameMode(GetPropertyFromSz(IPROPNAME_SHORTFILENAMES));
	SetMode(iefSuppressLFN,istrShortNameMode.TextSize() > 0 ? fTrue : fFalse);

	// set rollback flag - EnableRollback makes the proper checks against
	// the DisableRollback policy and the iioDisableRollback bit in m_iioOptions
	EnableRollback(fTrue);

	//!! what does child engine do here? should inherit from parent
	int iUILevel = GetPropertyInt(*MsiString(*IPROPNAME_CLIENTUILEVEL));
	if (iUILevel != iuiNone && MsiString(GetPropertyFromSz(IPROPNAME_LIMITUI)).TextSize())
		iUILevel = iuiBasic;             // doesn't always get set in InitializeUI
	else if (iUILevel == iMsiNullInteger)  // just incase we got here other than through CreateAndRunEngine
		iUILevel = m_iuiLevel;
	switch(iUILevel)  // map internal value to public value, same as in CMsiAPIMessage::SetInternalHandler
	{
	case iuiFull:    iUILevel = INSTALLUILEVEL_FULL;    break;
	case iuiReduced: iUILevel = INSTALLUILEVEL_REDUCED; break;
	case iuiBasic:   iUILevel = INSTALLUILEVEL_BASIC;   break;
	case iuiNone:    iUILevel = INSTALLUILEVEL_NONE;    break;
	default:         iUILevel = INSTALLUILEVEL_DEFAULT; break;  // should never hit this
	}
	AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_UILEVEL), iUILevel));// set UILevel property

	bool fOEMInstall = MsiString(GetPropertyFromSz(IPROPNAME_FASTOEMINSTALL)).TextSize() ? true : false;
	g_MessageContext.SetOEMInstall(fOEMInstall);
	if ( fOEMInstall )
	{
		ieiEnum iErrorReturn = ieiCommandLineOption;
		//  a couple of additional checks are required.

		if ( MsiString(GetPropertyFromSz(IPROPNAME_PATCH)).TextSize() )
		{
			DEBUGMSG(TEXT("OEM-mode installation does not support patching."));
			return iErrorReturn;
		}
		else if ( !g_fWin9X && !(fAdminUser && fAllUsers) )
		{
			DEBUGMSG(TEXT("OEM-mode installation supports only per machine installations."));
			return iErrorReturn;
		}
		else if ( MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTSTATE)) != -1 )
		{
			DEBUGMSG(TEXT("OEM-mode installation supports only first time installations."));
			return iErrorReturn;
		}
		else if ( fUIPreviewMode || iUILevel != INSTALLUILEVEL_NONE )
		{
			DEBUGMSG(TEXT("OEM-mode installation supports only UI-less installations."));
			return iErrorReturn;
		}
		MsiString strCurrentAction = GetPropertyFromSz(IPROPNAME_ACTION);
		if ( strCurrentAction.TextSize() && IStrComp(strCurrentAction, TEXT("INSTALL")) )
		{
			DEBUGMSG(TEXT("OEM-mode installation supports only INSTALL type of ACTION."));
			return iErrorReturn;
		}

		DEBUGMSG(TEXT("OEM-mode installation."));
	}

	// set QFEUpgrade property - indicates when this product is being upgraded
	// (an upgrade that doesn't change the product code)
	if(fAdvertised)
	{
		int iQFEUpgradeType = 0;
		// ideally we would only set QFEUpgrade when the package code is changing
		// but in Intellimirror upgrades, the package code is updated in the registry (via advertisement)
		// before the install happens, so we can't detect a qfe upgrade by a package code change
		if(iioOptions & iioReinstallModePackage)
		{
			iQFEUpgradeType = 1;
		}
		else if(MsiString(GetPropertyFromSz(IPROPNAME_PATCH)).TextSize())
		{
			iQFEUpgradeType = 2;
		}

		if(iQFEUpgradeType)
		{
			AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_QFEUPGRADE), iQFEUpgradeType));
		}
	}

	// Success, hold references to components within engine until terminate is called
	m_fInitialized = fTrue;

	// cache presence of particular tables in the current database
	if (m_piDatabase->GetTableState(sztblCustomAction, itsTableExists))
		m_fCustomActionTable = fTrue;

	// set caption and lang id for default UI handler
	// must call this after m_fInitialized is set since Message requires m_fInitialized is set
	if (!m_piParentEngine)
	{
		PMsiRecord pDialogInfo(&m_riServices.CreateRecord(3));
		// set lang id
		int iLangId = GetPropertyInt(*MsiString(IPROPNAME_INSTALLLANGUAGE)); // possibly changed by transform
		if (iLangId == iMsiNullInteger)   // product language not specified
			iLangId = m_iLangId;          // use language set by summaryinfo or transform
		pDialogInfo->SetInteger(1, icmtLangId);
		pDialogInfo->SetInteger(2, iLangId);
		pDialogInfo->SetInteger(3, pDatabase->GetANSICodePage());
		Message(imtCommonData, *pDialogInfo);
		pDialogInfo->SetNull(3);
		// set caption
		if (m_rgpiMessageHeader[imsgDialogCaption])
		{
			pDialogInfo->SetInteger(1, icmtCaption);
			pDialogInfo->SetMsiString(2, *m_rgpiMessageHeader[imsgDialogCaption]);
			Message(imtCommonData, *pDialogInfo);
		}
	}

	if ((ieiRet = ProcessPreselectedAndResumeInfo()) != ieiSuccess)
		return ieiRet;

	// go ahead and create the custom action manager with the appropriate re-mapped HKCU value
	// this is so that whether or not to remap HKCU (per bug 193684) is available at all times
	// for the elevated custom action servers.  On TS with per-machine installs, HKCU is not remapped
	// and remains .Default so that proper propogation occurs.  Note that while the CA Mgr is
	// created, no extra CA processes will be created until a CA server is needed

	if (g_scServerContext == scService)
	{
		m_fRemapHKCUInCAServers = true;
		if (MinimumPlatformWindows2000() && IsTerminalServerInstalled() && fAllUsers)
			m_fRemapHKCUInCAServers = false; // everything should go to .Default

		// if in service, create the custom action manager through the configuration manager
		CreateCustomActionManager(m_fRemapHKCUInCAServers);
	}

	MsiSuppressTimeout();
	

/*
	DebugDumpTable(*m_piDatabase, sztblMedia);
	DebugDumpTable(*m_piDatabase, sztblPatchPackage);
	DebugDumpTable(*m_piDatabase, sztblFile);
	DebugDumpTable(*m_piDatabase, sztblPatch);
*/
	return ieiSuccess;
}

ICHAR SkipWhiteSpace(const ICHAR*& rpch);

// parse property name, convert to upper case, advances pointer to next non-blank
const IMsiString& ParsePropertyName(const ICHAR*& rpch, Bool fUpperCase);

// parse property value, advance pointer past value, allows quotes, doubled to escape
const IMsiString& ParsePropertyValue(const ICHAR*& rpch);

// Name says it all, i.e. decides if szProperty is hidden or not.
//
// By definition, a property is hidden either if it is authored in the
// MsiHiddenProperties property or if it is associated with an Edit control
// that has the Password attribute set.
//
// If called w/ szHiddenProperties set to NULL,  it will get it from the
// database.

bool CMsiEngine::IsPropertyHidden(const ICHAR* szProperty,
											 const ICHAR* szHiddenProperties,
											 IMsiTable* piControlTable,
											 IMsiDatabase& riDatabase,
											 bool* pfError)
{
	if ( pfError )
		*pfError = false;

	if ( !szProperty || !*szProperty )
		// who wants to hide a non-named property?
		return false;

	MsiString strHiddenProperties;
	ICHAR* szPropertyList;
	if ( !szHiddenProperties )
	{
		strHiddenProperties = GetPropertyFromSz(IPROPNAME_HIDDEN_PROPERTIES);
		szPropertyList = const_cast<ICHAR*>(static_cast<const ICHAR*>(strHiddenProperties));
	}
	else
		szPropertyList = const_cast<ICHAR*>(szHiddenProperties);
	if ( *szPropertyList )
	{
		const ICHAR chDelimiter = TEXT(';');
		bool fForever = true;
		while ( fForever )
		{
			ICHAR* szWithin = IStrStr(szPropertyList, szProperty);
			if ( szWithin == NULL )
				// szProperty is not listed in the list of hidden properties.
				break;

			// I still need to check what surrounds szProperty in szPropertyList string.
			ICHAR chEnd = *(szWithin + IStrLen(szProperty));
			if ( chEnd && chEnd != chDelimiter )
				goto ContinueSearch;

			if ( szWithin != szPropertyList && *(szWithin - 1) != chDelimiter )
				goto ContinueSearch;
			else
				return true;

		ContinueSearch:
			szWithin += IStrLen(szProperty);
			szPropertyList = szWithin;
		}
	}

	// if we've got to this point, szProperty is not listed in the authored property.
	// we need to check the Control table.
	PMsiCursor pControlCursor(0);
	if ( piControlTable )
		pControlCursor = piControlTable->CreateCursor(fFalse);
	if ( pControlCursor )
	{
		//  hiding the properties of all Edit controls that have the Password attribute set
		int iTypeColumn = piControlTable->GetColumnIndex(riDatabase.EncodeStringSz(sztblControl_colType));
		int iAttrColumn = piControlTable->GetColumnIndex(riDatabase.EncodeStringSz(sztblControl_colAttributes));
		int iPropColumn = piControlTable->GetColumnIndex(riDatabase.EncodeStringSz(sztblControl_colProperty));
		if ( iTypeColumn && iAttrColumn && iPropColumn )
		{
			pControlCursor->SetFilter(iColumnBit(iTypeColumn)+iColumnBit(iPropColumn));
			AssertNonZero(pControlCursor->PutString(iTypeColumn, *MsiString(szControlTypeEdit)));
			AssertNonZero(pControlCursor->PutString(iPropColumn, *MsiString(szProperty)));
			while ( pControlCursor->Next() )
			{
				int iAttrib = pControlCursor->GetInteger(iAttrColumn);
				if ( (iAttrib & msidbControlAttributesPasswordInput) == msidbControlAttributesPasswordInput )
					return true;
			}
			return false;
		}
		else
		{
			Assert(0);
			if ( pfError )
				*pfError = true;
			return true; // it's safer this way
		}
	}

	return false;
}

void CMsiEngine::LogCommandLine(const ICHAR* szCommandLine, IMsiDatabase& riDatabase)
{
	if ( FDiagnosticModeSet(dmDebugOutput|dmVerboseLogging) )
	{
		if ( !szCommandLine || !*szCommandLine )
		{
			DEBUGMSG(TEXT("No Command Line."));
			return;
		}
		const ICHAR rgchCmdLineTemplate[] = TEXT("Command Line: %s");
		MsiString strHiddenProperties = GetPropertyFromSz(IPROPNAME_HIDDEN_PROPERTIES);
		PMsiTable pTable(0);
		PMsiRecord pError = riDatabase.LoadTable(*MsiString(*sztblControl), 0, *&pTable);
		if ( pError )
			pTable = 0;
		MsiString strStars(IPROPVALUE_HIDDEN_PROPERTY);
		MsiString strOutput;
		ICHAR* pchCmdLine = const_cast<ICHAR*>(szCommandLine);

		for(;;)
		{
			MsiString istrPropName;
			MsiString istrPropValue;
			ICHAR ch = SkipWhiteSpace(pchCmdLine);
			if (ch == 0)
				break;

			// process property=value pair
			istrPropName = ParsePropertyName(pchCmdLine, fFalse);
			if (!istrPropName.TextSize() || *pchCmdLine++ != '=')
				// an error might have occured
				break;
			istrPropValue = ParsePropertyValue(pchCmdLine);
			if ( IsPropertyHidden(istrPropName, strHiddenProperties, pTable, riDatabase, NULL) )
				// this property should be hidden
				istrPropValue = strStars;
			strOutput += istrPropName;
			strOutput += TEXT("=");
			strOutput += istrPropValue;
			strOutput += TEXT(" ");
		}
		DEBUGMSG1(rgchCmdLineTemplate, (const ICHAR*)strOutput);
	}
}

INSTALLSTATE CMsiEngine::GetProductState(const ICHAR* szProductKey, Bool& rfRegistered, Bool& rfAdvertised)
{
	INSTALLSTATE is = INSTALLSTATE_UNKNOWN;
	rfRegistered = rfAdvertised = fFalse;
	if(!(GetMode() & iefAdmin) && szProductKey && *szProductKey)
	{
		is = MSI::MsiQueryProductState(szProductKey);
		if(is == INSTALLSTATE_DEFAULT)
		{
			rfRegistered = rfAdvertised = fTrue;
		}
		else if(is == INSTALLSTATE_ADVERTISED)
		{
			rfAdvertised = fTrue;
		}
	}
	return is;
}

bool CMsiEngine::IgnoreMachineState()
{
	// machine state is ignored if we are either
	//  1. creating an advertise script
	//  2. running in a restricted engine
	if ((m_iioOptions & iioCreatingAdvertiseScript) || (m_iioOptions & iioRestrictedEngine))
		return true;
	
	return false;
}

bool CMsiEngine::IgnoreReboot()
{
	// reboot is ignored if we are either (1) creating an advertise script or
	// (2) running in a restricted engine because we aren't making any changes
	// to the machine.
	if ((m_iioOptions & iioCreatingAdvertiseScript) || (m_iioOptions & iioRestrictedEngine))
		return true;
	
	return false;
}

ieiEnum CMsiEngine::ProcessPreselectedAndResumeInfo()
{
	ieiEnum ieiRet;

	// check whether another install is in progress and set properties as appropriate
	if ((ieiRet = ProcessInProgressInstall()) != ieiSuccess)
		return ieiRet;

	// set Preselected property
	Bool fPreselected = fFalse;
	// check if any feature properties are set
	for(int i = 0; i < g_cFeatureProperties; i++)
	{
		if(MsiString(GetPropertyFromSz(g_rgFeatures[i].szFeatureActionProperty)).TextSize())
		{
			AssertNonZero(SetProperty(*MsiString(*IPROPNAME_PRESELECTED), *MsiString(TEXT("1"))));
			break;
		}
	}

	return ieiSuccess;
}
	
void CMsiEngine::InitializeExtendedSystemFeatures()
{
	// Determine support for extended shell path
	if (g_fSmartShell == -1)  // not determined yet
	{
		g_fSmartShell = IsDarwinDescriptorSupported(iddShell);
	}

	// Set the Engine's GPTSupport mode
	SetMode(iefGPTSupport,MsiString(GetPropertyFromSz(IPROPNAME_GPT_SUPPORT)).TextSize() > 0 ? fTrue:fFalse);
}

ieiEnum CMsiEngine::ApplyLanguageTransform(int iLanguage, IMsiDatabase& riDatabase)
{
	PMsiStorage pLangStorage(0);
	
	PMsiStorage pDbStorage(riDatabase.GetStorage(1));
	if (pDbStorage == 0)
		return ieiDatabaseInvalid;

	MsiString strTransformList = MsiChar(STORAGE_TOKEN);
	strTransformList += MsiString(iLanguage);
	
	return InitializeTransforms(riDatabase, 0, *strTransformList, fTrue, 0, false, false, false, 0);
}

void CMsiEngine::GetSummaryInfoProperties(IMsiSummaryInfo& riSummary, const IMsiString*& rpiTemplate, int &iSourceType)
{
	m_fSummaryInfo = fTrue;
	rpiTemplate            = &riSummary.GetStringProperty(PID_TEMPLATE);
	m_pistrSummaryProduct  = &riSummary.GetStringProperty(PID_SUBJECT);
	m_pistrSummaryComments = &riSummary.GetStringProperty(PID_COMMENTS);
	m_pistrSummaryTitle    = &riSummary.GetStringProperty(PID_TITLE);
	m_pistrSummaryKeywords = &riSummary.GetStringProperty(PID_KEYWORDS);
	m_pistrSummaryPackageCode = &riSummary.GetStringProperty(PID_REVNUMBER);
									  riSummary.GetIntegerProperty(PID_MSISOURCE, iSourceType);
									  riSummary.GetIntegerProperty(PID_CODEPAGE,  m_iCodePage);
									  riSummary.GetIntegerProperty(PID_PAGECOUNT, m_iDatabaseVersion);
									  riSummary.GetTimeProperty(PID_CREATE_DTM,   m_idSummaryCreateDateTime);
									  riSummary.GetTimeProperty(PID_LASTPRINTED,  m_idSummaryInstallDateTime);

}

ieiEnum CMsiEngine::InitializeUI(iuiEnum /*iuiLevel*/)
{
	// if Full or Reduced UI and LIMITUI property set, downgrade to Basic
	if(!g_MessageContext.IsHandlerLoaded() && (m_iuiLevel == iuiFull || m_iuiLevel == iuiReduced))
	{
		if(MsiString(GetPropertyFromSz(IPROPNAME_LIMITUI)).TextSize() ||
			MsiString(GetPropertyFromSz(TEXT("NOUI"))).TextSize()) //!!?? temp?
			m_iuiLevel = iuiBasic;
		else
		{
			// Determine whether our source is media. During maintenance mode we simply use LastUsedSource to determine this.
			Bool fMediaSource = fFalse;
			if (GetMode() & iefMaintenance)
				fMediaSource = LastUsedSourceIsMedia(m_riServices, MsiString(GetProductKey()));
			else // first-run
			{
				AssertNonZero(ResolveFolderProperty(*MsiString(*IPROPNAME_SOURCEDIR)));
				MsiString strSource = GetPropertyFromSz(IPROPNAME_SOURCEDIR);
				SetProperty(*MsiString(*IPROPNAME_SOURCEDIROLD), *strSource);
				
				PMsiPath pPath(0);
				PMsiRecord pError(0);
				if ((pError = CreatePathObject(*strSource, *&pPath)) == 0)
				{
					idtEnum idt = PMsiVolume(&pPath->GetVolume())->DriveType();
					switch (idt)
					{
						//case idtFloppy    = 2, //!!
						case idtRemovable:
						case idtCDROM:
							fMediaSource = fTrue;
					}
				}
			}

			if (fMediaSource)
				AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_MEDIASOURCEDIR), 1));

			imsEnum imsLoad = LoadHandler();
			if (imsLoad == imsError)
				return ieiHandlerInitFailed;  //!! use default UI?
			else if (imsLoad != imsOk)
				m_iuiLevel = iuiBasic;
		}
	}
	return ieiSuccess;
}

void CMsiEngine::InitializeUserInfo(const IMsiString& ristrProductKey)
{
	// get registered user information, if present
	ICHAR szUserName[100];
	ICHAR szOrgName[100];
	ICHAR szPID[32];
	DWORD cchUserName = sizeof(szUserName)/sizeof(ICHAR);
	DWORD cchOrgName  = sizeof(szOrgName)/sizeof(ICHAR);
	DWORD cchPID      = sizeof(szPID)/sizeof(ICHAR);
	MsiString istrUser;
	MsiString istrOrg;
	if (MSI::MsiGetUserInfo(ristrProductKey.GetString(), szUserName, &cchUserName, szOrgName,
									&cchOrgName, szPID, &cchPID) == USERINFOSTATE_PRESENT)
	{
		if (cchUserName) istrUser = szUserName;
		if (cchOrgName) istrOrg = szOrgName;
		if (cchPID) SetProperty(*MsiString(*IPROPNAME_PRODUCTID), *MsiString(szPID));
	}
	PMsiRegKey pLocalMachine(&m_riServices.GetRootKey(rrkLocalMachine));
	PMsiRegKey pCurrentUser (&m_riServices.GetRootKey(rrkCurrentUser));

	PMsiRegKey pSysKey      (&pLocalMachine->CreateChild(szSysUserKey));
	PMsiRegKey pSysKeyNT      (&pLocalMachine->CreateChild(szSysUserKeyNT));
	PMsiRegKey pAcmeKey     (&pCurrentUser ->CreateChild(szUserInfoKey));
	PMsiRecord pRecord(0);

	if (MsiString(GetPropertyFromSz(IPROPNAME_NOUSERNAME)).TextSize() == 0)
	{
		if (!istrUser.TextSize()) istrUser = GetPropertyFromSz(IPROPNAME_USERNAME);
		if (!istrUser.TextSize()) pRecord = pAcmeKey->GetValue(szDefName, *&istrUser);
		if (!istrUser.TextSize()) pRecord = pSysKey->GetValue(szSysUserName, *&istrUser);
		if (!istrUser.TextSize()) pRecord = pSysKeyNT->GetValue(szSysUserName, *&istrUser);
		if (istrUser.TextSize()) SetProperty(*MsiString(*IPROPNAME_USERNAME), *istrUser);
	}

	if (MsiString(GetPropertyFromSz(IPROPNAME_NOCOMPANYNAME)).TextSize() == 0)
	{
		if (!istrOrg.TextSize()) istrOrg = GetPropertyFromSz(IPROPNAME_COMPANYNAME);
		if (!istrOrg.TextSize()) pRecord = pAcmeKey->GetValue(szDefOrg,  *&istrOrg);
		if (!istrOrg .TextSize()) pRecord = pSysKey->GetValue(szSysOrgName,  *&istrOrg);
		if (!istrOrg .TextSize()) pRecord = pSysKeyNT->GetValue(szSysOrgName,  *&istrOrg);
		if (istrOrg.TextSize())  SetProperty(*MsiString(*IPROPNAME_COMPANYNAME), *istrOrg);
	}
}

void CMsiEngine::AddFileToCleanupList(const ICHAR* szFileToCleanup)
{
	if (m_strTempFileCopyCleanupList.TextSize() != 0)
		m_strTempFileCopyCleanupList += MsiChar(';');
	m_strTempFileCopyCleanupList += MsiString(szFileToCleanup);
}

ieiEnum CMsiEngine::LoadMessageHeaders(IMsiDatabase* piDatabase)
{
	Assert(piDatabase);
	PMsiTable pErrorTable(0);
	PMsiRecord pError(0);

	int imsg;
	ieiEnum ieiReturn = ieiSuccess;
	pError = piDatabase->LoadTable(*MsiString(*sztblError), 0, *&pErrorTable);
	if ( !pError )
	{
		PMsiCursor pErrorCursor(pErrorTable->CreateCursor(fFalse));
		if (!pErrorCursor)
			ieiReturn = ieiDatabaseInvalid;
		else
		{
			while (pErrorCursor->Next() && ((imsg = pErrorCursor->GetInteger(1))) < cMessageHeaders)
			{
				if (imsg < cCachedHeaders)
					m_rgpiMessageHeader[imsg] = &pErrorCursor->GetString(2); // AddRef done by GetString
				else if (!m_piParentEngine)
				{
					MsiString strHeader = FormatText(*MsiString(pErrorCursor->GetString(2)));
					g_MessageContext.m_szAction = strHeader;
					g_MessageContext.Invoke(imtEnum(imsg << imtShiftCount), 0);
				}
			}
		}
	}
	//  attempting to get from the international resource DLL the cached errors
	//  not found in the error table.
	for ( imsg = 0; imsg < cCachedHeaders; imsg++ )
	{
		if ( !m_rgpiMessageHeader[imsg] )
			m_rgpiMessageHeader[imsg] = &GetErrorTableString(imsg);
	}
	return ieiReturn;
}

ieiEnum CMsiEngine::LoadUpgradeUninstallMessageHeaders(IMsiDatabase* /* piDatabase */, bool fUninstallHeaders)
{
	if(m_piParentEngine)
		return ieiSuccess;  // don't change headers from child install

	int iTimeRemainingIndex = fUninstallHeaders ? (imtUpgradeRemoveTimeRemaining >> imtShiftCount) : (imtTimeRemaining >> imtShiftCount);
	int iScriptInProgressIndex = fUninstallHeaders ? (imtUpgradeRemoveScriptInProgress >> imtShiftCount) : (imtScriptInProgress >> imtShiftCount);
	MsiString strHeader = GetErrorTableString(iTimeRemainingIndex);
	if ( strHeader.TextSize() )
	{
		g_MessageContext.m_szAction = strHeader;
		g_MessageContext.Invoke(imtTimeRemaining, 0);
	}

	strHeader = GetErrorTableString(iScriptInProgressIndex);
	if ( strHeader.TextSize() )
	{
		g_MessageContext.m_szAction = strHeader;
		g_MessageContext.Invoke(imtScriptInProgress, 0);
	}
	return ieiSuccess;
}

ieiEnum CMsiEngine::InitializeLogging()
{
	m_fLogAction = fTrue;   // default in case LOGACTION not set and running on server
//      if (!m_piParentEngine) //!! do we want to do this for each engine in the sessions?
	//!! we may want to query message handler to see if we're really logging
	const IMsiString* piLogHeader = m_rgpiMessageHeader[imsgLogHeader];
	if (!(GetMode() & iefSecondSequence) && piLogHeader)
	{
		PMsiRecord pRecord = &ENG::CreateRecord(0);
		pRecord->SetMsiString(0, *piLogHeader);
		Message(imtEnum(imtForceLogInfo), *pRecord);  // use engine to format properties
	}
	// get LOGACTION value - determines which Actions to log
	m_istrLogActions = GetPropertyFromSz(IPROPNAME_LOGACTION);
	if (m_istrLogActions.TextSize())
		m_fLogAction = fFalse;   //!! initialize to false - seems unnecessary, as its set each ActionStart
	SetMode(iefLogEnabled, /*ENG::LoggingEnabled() ? fTrue :*/ fFalse);  //!! query for this?
	return ieiSuccess;
}

const ICHAR sqlPatchSourceProperties[] =
TEXT("SELECT `Media`.`Source`,`Media`.`_MSIOldSource`, `#_PatchCache`.`SourcePath`, `#_PatchCache`.`Unregister`")
TEXT("FROM `PatchPackage`, `#_PatchCache`, `Media`")
TEXT("WHERE `PatchPackage`.`PatchId` = `#_PatchCache`.`PatchId` AND `PatchPackage`.`Media_` = `Media`.`DiskId`");

enum ipspEnum
{
	ipspProp = 1,
	ipspOldProp,
	ipspPath,
	ipspUnregister,
};

Bool CMsiEngine::SetPatchSourceProperties()
{
	// must be called after Property table is initialized
	if(!m_pPatchCacheTable)
		// if not PatchCache table was created, there are no patch sources to register
		return fTrue;

	PMsiRecord pError(0);
	PMsiRecord pFetchRecord(0);
	PMsiView pView(0);
	if((pError = OpenView(sqlPatchSourceProperties, ivcFetch, *&pView)) == 0 &&
		(pError = pView->Execute(0)) == 0)
	{
		while(pFetchRecord = pView->Fetch())
		{
			if(pFetchRecord->GetInteger(ipspUnregister) != 1)
			{
				if(SetProperty(*MsiString(pFetchRecord->GetMsiString(ipspProp)),
									*MsiString(pFetchRecord->GetMsiString(ipspPath))) == fFalse)
					return fFalse;

				if(SetProperty(*MsiString(pFetchRecord->GetMsiString(ipspOldProp)),
									*MsiString(pFetchRecord->GetMsiString(ipspPath))) == fFalse)
					return fFalse;
			}
		}
	}
	else if(pError->GetInteger(1) != idbgDbQueryUnknownTable) // could have patchcache table without PatchPackage table
		return fFalse;
	
	return fTrue;
}

IMsiRecord* CMsiEngine::GetFolderCachePath(const int iFolderId, IMsiPath*& rpiPath)
{
	IMsiRecord* piError = 0;
	rpiPath = 0;

	if (!m_pFolderCacheTable)
		return PostError(Imsg(idbgTableDefinition), sztblFolderCache);

	m_pFolderCacheCursor->Reset();
	m_pFolderCacheCursor->SetFilter(iColumnBit(m_colFolderCacheFolderId));
	AssertNonZero(m_pFolderCacheCursor->PutInteger(m_colFolderCacheFolderId, iFolderId));
	if (m_pFolderCacheCursor->Next())
	{
		rpiPath = (IMsiPath*)m_pFolderCacheCursor->GetMsiData(m_colFolderCacheFolderPath);
		if (rpiPath == 0)
		{
			// create path object for the path and store in the table
			MsiString strFolder(m_pFolderCacheCursor->GetString(m_colFolderCacheFolder));
			if ((piError = CreatePathObject(*strFolder, rpiPath)) != 0)
				return piError;
			AssertNonZero(m_pFolderCacheCursor->PutMsiData(m_colFolderCacheFolderPath, rpiPath));
			AssertNonZero(m_pFolderCacheCursor->Update());
		}
	}
	else
	{
		// folderId wasn't found in the FolderCache table
		return PostError(Imsg(idbgCacheFolderPropertyNotDefined), iFolderId);
	}
	return 0;
}

bool CMsiEngine::CreateFolderCache(IMsiDatabase& riDatabase)
{
	PMsiRecord pError(0);
	if (!m_pFolderCacheTable)
	{
		if ((pError = riDatabase.CreateTable(*MsiString(*sztblFolderCache), 0, *&m_pFolderCacheTable)) != 0)
			return false;

		m_colFolderCacheFolderId   = m_pFolderCacheTable->CreateColumn(icdPrimaryKey + icdShort + icdTemporary,
																				*MsiString(*sztblFolderCache_colFolderId));
		m_colFolderCacheFolder     = m_pFolderCacheTable->CreateColumn(icdString + icdTemporary,
																				*MsiString(*sztblFolderCache_colFolderPath));
		m_colFolderCacheFolderPath = m_pFolderCacheTable->CreateColumn(icdObject + icdNullable + icdTemporary, g_MsiStringNull);

		if (!m_colFolderCacheFolderId || !m_colFolderCacheFolder || !m_colFolderCacheFolderPath)
			return false;

		m_pFolderCacheCursor = m_pFolderCacheTable->CreateCursor(fFalse);
		if (!m_pFolderCacheCursor)
			return false;
	}
	return true;
}

IMsiRecord* CMsiEngine::CachePatchInfo(IMsiDatabase& riDatabase, const IMsiString& ristrPatchCode,
													const IMsiString& ristrPackageName, const IMsiString& ristrSourceList,
													const IMsiString& ristrTransformList, const IMsiString& ristrLocalPackagePath,
													const IMsiString& ristrSourcePath, Bool fExisting, Bool fUnregister,
													int iSequence)
{
	// store information about patch in Patches table
	IMsiRecord* piError = 0;
	if(!m_pPatchCacheTable)
	{
		if ((piError = riDatabase.CreateTable(*MsiString(sztblPatchCache), 0, *&m_pPatchCacheTable)) != 0)
			return piError;
		m_colPatchCachePatchId     = m_pPatchCacheTable->CreateColumn(icdPrimaryKey + icdString + icdTemporary,
																								*MsiString(*sztblPatchCache_colPatchId));
		m_colPatchCachePackageName = m_pPatchCacheTable->CreateColumn(icdString + icdTemporary + icdNullable,
																								*MsiString(*sztblPatchCache_colPackageName));
		m_colPatchCacheSourceList  = m_pPatchCacheTable->CreateColumn(icdString + icdTemporary + icdNullable,
																								*MsiString(*sztblPatchCache_colSourceList));
		m_colPatchCacheTransformList = m_pPatchCacheTable->CreateColumn(icdString + icdTemporary + icdNullable,
																								*MsiString(*sztblPatchCache_colTransformList));
		m_colPatchCacheTempCopy = m_pPatchCacheTable->CreateColumn(icdString + icdTemporary + icdNullable,
																								*MsiString(*sztblPatchCache_colTempCopy));
		m_colPatchCacheSourcePath = m_pPatchCacheTable->CreateColumn(icdString + icdTemporary + icdNullable,
																								*MsiString(*sztblPatchCache_colSourcePath));
		m_colPatchCacheExisting = m_pPatchCacheTable->CreateColumn(icdShort + icdTemporary,
																								*MsiString(*sztblPatchCache_colExisting));
		m_colPatchCacheUnregister = m_pPatchCacheTable->CreateColumn(icdShort + icdTemporary,
																								*MsiString(*sztblPatchCache_colUnregister));
		m_colPatchCacheSequence = m_pPatchCacheTable->CreateColumn(icdLong + icdTemporary,
																								*MsiString(*sztblPatchCache_colSequence));
		if(!m_colPatchCachePatchId || !m_colPatchCachePackageName ||
			!m_colPatchCacheSourceList || !m_colPatchCacheTransformList || !m_colPatchCacheTempCopy ||
			!m_colPatchCacheSequence || !m_colPatchCacheUnregister || !m_colPatchCacheExisting ||
			!m_colPatchCacheSourcePath)
			return PostError(Imsg(idbgTableDefinition), sztblPatchCache);

		m_pPatchCacheCursor = m_pPatchCacheTable->CreateCursor(fFalse);
	}

	Bool fRecordExists = fTrue;
	m_pPatchCacheCursor->Reset();
	AssertNonZero(m_pPatchCacheCursor->PutString(m_colPatchCachePatchId,ristrPatchCode));
	AssertNonZero(m_pPatchCacheCursor->PutString(m_colPatchCachePackageName,ristrPackageName));
	AssertNonZero(m_pPatchCacheCursor->PutString(m_colPatchCacheSourceList,ristrSourceList));
	AssertNonZero(m_pPatchCacheCursor->PutString(m_colPatchCacheTransformList,ristrTransformList));
	AssertNonZero(m_pPatchCacheCursor->PutString(m_colPatchCacheTempCopy,ristrLocalPackagePath));
	AssertNonZero(m_pPatchCacheCursor->PutString(m_colPatchCacheSourcePath,ristrSourcePath));
	AssertNonZero(m_pPatchCacheCursor->PutInteger(m_colPatchCacheExisting,fExisting?1:0));
	AssertNonZero(m_pPatchCacheCursor->PutInteger(m_colPatchCacheUnregister,fUnregister?1:0));
	AssertNonZero(m_pPatchCacheCursor->PutInteger(m_colPatchCacheSequence,iSequence));
	AssertNonZero(m_pPatchCacheCursor->InsertTemporary());

	return 0;
}

ieiEnum IsValidPatchStorage(IMsiStorage& riStorage, IMsiSummaryInfo& riSummaryInfo)
{
	// check storage id
	if (riStorage.ValidateStorageClass(ivscPatch1))  //!! temporary compatibility with old patch files
	{
		IMsiStorage* piDummy;
		riStorage.OpenStorage(0, ismRawStreamNames, piDummy);
	}
	else if (!riStorage.ValidateStorageClass(ivscPatch2))
		return ieiPatchPackageInvalid;

	// check if patch type supported
	// 1.0 - 1.1 supports only type 1 (or blank)
	// 1.2 supports type 2 as well
	// 2.0 supports type 3 as well
	int iType = 0;
	riSummaryInfo.GetIntegerProperty(PID_WORDCOUNT, iType);
	if(iType == 0 || iType == 1 || iType == 2 || iType == 3)
		return ieiSuccess;
	else
		return ieiPatchPackageUnsupported;
}

ieiEnum CMsiEngine::PostInitializeError(IMsiRecord* piError, const IMsiString& ristrErrorInfo, ieiEnum ieiError)
{
	if(piError)
		Message(imtInfo,*piError);
	if(m_piErrorInfo) m_piErrorInfo->Release();
	m_piErrorInfo = &ristrErrorInfo; m_piErrorInfo->AddRef();
	return ieiError;
}

const ICHAR sqlDropPatchTable[] = TEXT("DROP TABLE `Patch`");
const ICHAR sqlAddPatchTable[] = TEXT("CREATE TABLE `Patch` ( `File_` CHAR(72) NOT NULL, `Sequence` INTEGER NOT NULL, `PatchSize` LONG NOT NULL, `Attributes` INTEGER NOT NULL, `Header` OBJECT, `StreamRef_` CHAR(72)  PRIMARY KEY `File_`, `Sequence` )");
const ICHAR sqlHoldPatchTable[] = TEXT("ALTER TABLE `Patch` HOLD");

IMsiRecord* CMsiEngine::CreateNewPatchTableSchema(IMsiDatabase& riDatabase)
{
	PMsiView pViewPatch(0);
	IMsiRecord* piError = 0;

	if (riDatabase.FindTable(*MsiString(*sztblPatch)) != itsUnknown)
	{
		if ((piError = riDatabase.OpenView(sqlDropPatchTable, ivcModify, *&pViewPatch)) != 0
			|| (piError = pViewPatch->Execute(0)) != 0)
		{
			return piError;
		}
	}
	if ((piError = riDatabase.OpenView(sqlAddPatchTable, ivcModify, *&pViewPatch)) != 0
			|| (piError = pViewPatch->Execute(0)) != 0
			|| (piError = riDatabase.OpenView(sqlHoldPatchTable, ivcModify, *&pViewPatch)) != 0
			|| (piError = pViewPatch->Execute(0)) != 0
			|| (piError = pViewPatch->Close()) != 0)
	{
		return piError;
	}

	return 0;
}

ieiEnum CMsiEngine::InitializePatch(IMsiDatabase& riDatabase, const IMsiString& ristrPatchPackage,
												const ICHAR* szProductKey, Bool fApplyExisting, const ICHAR* szCurrentDirectory, iuiEnum iuiLevel)
{
	PMsiRecord pError(0);
	Bool fAdmin = GetMode() & iefAdmin ? fTrue : fFalse;
	if(fAdmin)
		fApplyExisting = fFalse;

	// open patch package as storage
	PMsiStorage pNewPatchStorage(0);
	PMsiSummaryInfo pNewPatchSummary(0);
	MsiString strNewPatchId, strOldPatches, strPatchTempCopy;
	ieiEnum ieiStat = ieiSuccess;

	// per Whistler bug 381320, we need to handle conflicting Patch table schemas. To guarantee that the new one always wins, we drop the Patch table
	// from the database if it was there.  We also always create a new Patch table. This is done BEFORE any patch transforms are applied
	bool fCreatedNewPatchTableSchema = false;


	if(ristrPatchPackage.TextSize())
	{
		// attempting to apply new patch - only allowed if DisablePatch policy is not set and
		// either admin user, not elevated, AllowLockdownPatch machine policy set.
		// Ideally we would check m_fRunScriptElevated, but it has not been set yet.
		if (GetIntegerPolicyValue(szDisablePatchValueName, fTrue) == 1 ||
			!(GetIntegerPolicyValue(szAllowLockdownPatchValueName, fTrue) == 1 ||
			  SafeForDangerousSourceActions(szProductKey)))
		{
			// patching disabled
			return ieiPackageRejected;
		}

		Bool fURL = IsURL(ristrPatchPackage.GetString(), NULL);
		if (!fURL)
		{
			// patch is at source -- need to create a temp copy to run from
			MsiString strVolume;
			Bool fRemovable = fFalse;
			DWORD dwStat = CopyTempDatabase(ristrPatchPackage.GetString(), *&strPatchTempCopy, fRemovable, *&strVolume, m_riServices, stPatch);
			if (ERROR_SUCCESS == dwStat)
			{
				// patch was copied
				DEBUGMSGV1(TEXT("Original patch ==> %s"), ristrPatchPackage.GetString());
				DEBUGMSGV1(TEXT("Patch we're running from ==> %s"), strPatchTempCopy);

				AddFileToCleanupList(strPatchTempCopy);
			}
			else
			{
				strPatchTempCopy = ristrPatchPackage;
				ristrPatchPackage.AddRef();
				DEBUGMSGV1(TEXT("Unable to create a temp copy of patch '%s'."), ristrPatchPackage.GetString());
			}
		}

		// must perform SAFER check on patch
		SAFER_LEVEL_HANDLE hSaferLevel = 0;
		pError = OpenAndValidateMsiStorageRec(fURL ? ristrPatchPackage.GetString() : strPatchTempCopy, stPatch, m_riServices, *&pNewPatchStorage, /* fCallSAFER = */ true, /* szFriendlyName = */ ristrPatchPackage.GetString(), /* phSaferLevel = */ &hSaferLevel);
		if (pError != 0)
		{
			ieiEnum ieiInitError = MapStorageErrorToInitializeReturn(pError);
			return PostInitializeError(pError,ristrPatchPackage,ieiInitError);
		}

		if (fURL)
		{
			// retrieve the storage path used when downloading the URL file
			AssertRecord(pNewPatchStorage->GetName(*&strPatchTempCopy));
		}

		// get summary information of package
		if ((pError = pNewPatchStorage->CreateSummaryInfo(0, *&pNewPatchSummary)))
		{
			// could not open summary info
			return PostInitializeError(pError,ristrPatchPackage,ieiPatchPackageInvalid);
		}

		ieiStat = IsValidPatchStorage(*pNewPatchStorage, *pNewPatchSummary);
		if(ieiStat != ieiSuccess)
		{
			pError = PostError(Imsg(idbgNotPatchStorage),ristrPatchPackage);
			return PostInitializeError(pError,ristrPatchPackage,ieiStat);
		}

		if (!fCreatedNewPatchTableSchema)
		{
			// ensure new Patch table schema is used
			if ((pError = CreateNewPatchTableSchema(riDatabase)) != 0)
			{
				DEBUGMSG(TEXT("Unable to create new patch table schema"));
				return PostInitializeError(pError, ristrPatchPackage, ieiPatchPackageInvalid);
			}
			fCreatedNewPatchTableSchema = true;
		}
		
		strOldPatches = pNewPatchSummary->GetStringProperty(PID_REVNUMBER);
		strNewPatchId = strOldPatches.Extract(iseFirst,38);
		strOldPatches.Remove(iseFirst,38);
	}

	int iPatchSequence = 1;
	Bool fApplyNewPatch = fTrue;
	
	if(fApplyExisting)
	{
		Assert(szProductKey && *szProductKey);
		
		// apply all existing patches first
		int iIndex = 0;
		CTempBuffer<ICHAR,39> rgchPatchBuf;
		CTempBuffer<ICHAR,100> rgchTransformsBuf;
		DWORD cchTransformsBuf = 100;
		for(;;)
		{
			DWORD lResult = MsiEnumPatches(szProductKey,iIndex,rgchPatchBuf,rgchTransformsBuf,&cchTransformsBuf);
			if(lResult == ERROR_MORE_DATA)
			{
				// resize buffer to returned size + 1
				cchTransformsBuf++;
				rgchTransformsBuf.SetSize(cchTransformsBuf);
				lResult = MsiEnumPatches(szProductKey,iIndex,rgchPatchBuf,rgchTransformsBuf,&cchTransformsBuf);
			}
			iIndex++;

			if(lResult == ERROR_SUCCESS)
			{
				if(strOldPatches.Compare(iscWithinI,rgchPatchBuf))
				{
					// obsolete patch, need to unregister
					if((pError = CachePatchInfo(riDatabase,*MsiString((const ICHAR*)rgchPatchBuf),g_MsiStringNull,
														 g_MsiStringNull,g_MsiStringNull,
														 g_MsiStringNull, g_MsiStringNull,
														 fTrue, fTrue, iPatchSequence++)) != 0)
					{
						return PostInitializeError(pError,g_MsiStringNull,ieiPatchPackageInvalid);
					}
				}
				else
				{
					// get local path
					CTempBuffer<ICHAR,MAX_PATH> rgchLocalPackage;
					if (!GetPatchInfo(rgchPatchBuf, INSTALLPROPERTY_LOCALPACKAGE,rgchLocalPackage))
					{
						// couldn't get local path for whatever reason (could be corrupt config data, or a roaming user)
						// will try to recache patch from its original source
						rgchLocalPackage[0] = 0;
					}
					
					// open patch package as storage
					PMsiStorage pExistingPatchStorage(0);
					PMsiSummaryInfo pExistingPatchSummaryInfo(0);

					MsiString strPatchPackage = (const ICHAR*)rgchLocalPackage;

					MsiString strTempCopy;

					bool fPatchAtSource = false;

					for (int c = 0; c < 2 ; c++)
					{
						DEBUGMSG1(TEXT("Opening existing patch '%s'."), strPatchPackage);

						if(strPatchPackage.TextSize())
						{
							Bool fURL = IsURL(strPatchPackage, NULL);
							if (fPatchAtSource && !fURL)
							{
								// patch is at source -- need to create a temp copy to run from
								MsiString strVolume;
								Bool fRemovable = fFalse;
								DWORD dwStat = CopyTempDatabase(strPatchPackage, *&strTempCopy, fRemovable, *&strVolume, m_riServices, stPatch);
								if (ERROR_SUCCESS == dwStat)
								{
									// patch was copied
									DEBUGMSGV1(TEXT("Original patch ==> %s"), strPatchPackage);
									DEBUGMSGV1(TEXT("Patch we're running from ==> %s"), strTempCopy);

									AddFileToCleanupList(strTempCopy);
								}
								else
								{
									strTempCopy = strPatchPackage;
									DEBUGMSGV1(TEXT("Unable to create a temp copy of patch '%s'."), strPatchPackage);
								}
							}

							// a SAFER check on the patch is only required if we go back up to 							// the source to get the patch
							// a locally cached patch does not require a SAFER check
							SAFER_LEVEL_HANDLE hSaferLevel = 0;
							pError = OpenAndValidateMsiStorageRec(fPatchAtSource ? strTempCopy : strPatchPackage, stPatch, m_riServices, *&pExistingPatchStorage, /* fCallSAFER = */ fPatchAtSource, /* szFriendlyName = */ strPatchPackage, /* phSaferLevel = */ fPatchAtSource ? &hSaferLevel : NULL);

							if (fPatchAtSource && fURL)
							{
								// retrieve the storage path used when downloading the URL file
								AssertRecord(pExistingPatchStorage->GetName(*&strTempCopy));
							}
						}
						
						if (strPatchPackage.TextSize() == 0 || pError != 0)
						{
							if (c == 0)
							{
								DEBUGMSG1(TEXT("Couldn't find local patch '%s'. Looking for it at its source."), strPatchPackage);

								MsiString strPatchSource;
								MsiString strDummy;
								pError = ResolveSource(rgchPatchBuf, true, 0, iuiLevel, fTrue, &strPatchSource, &strDummy);
								if (pError)
									return ieiSourceAbsent;

								fPatchAtSource = true;

								CTempBuffer<ICHAR, MAX_PATH> rgchPatchPackageName;
								AssertNonZero(GetPatchInfo(rgchPatchBuf, TEXT("PackageName"), rgchPatchPackageName));
												
								strPatchPackage = strPatchSource;
								strPatchPackage += rgchPatchPackageName;
								strTempCopy = strPatchPackage;
								continue;

							}
							else
							{
								// pError may be 0
								return PostInitializeError(pError, *strPatchPackage, ieiPatchPackageOpenFailed);
							}
						}
						break;
					}

					// get summary information of package
					if ((pError = pExistingPatchStorage->CreateSummaryInfo(0, *&pExistingPatchSummaryInfo)))
					{
						// could not open summary info
						return PostInitializeError(pError,*strPatchPackage,ieiPatchPackageInvalid);
					}

					ieiEnum ieiStat = IsValidPatchStorage(*pExistingPatchStorage, *pExistingPatchSummaryInfo);
					if(ieiStat != ieiSuccess)
					{
						pError = PostError(Imsg(idbgNotPatchStorage),*strPatchPackage);
						return PostInitializeError(pError,*strPatchPackage,ieiStat);
					}
				
					if (!fCreatedNewPatchTableSchema)
					{
						// ensure new Patch table schema is used
						if ((pError = CreateNewPatchTableSchema(riDatabase)) != 0)
						{
							DEBUGMSG(TEXT("Unable to create new patch table schema"));
							return PostInitializeError(pError, *strPatchPackage, ieiPatchPackageInvalid);
						}
						fCreatedNewPatchTableSchema = true;
					}

					MsiString strValidTransforms;
					// InitializeTransforms will perform a digital signature check on transforms if it determines
					// that the check is warranted.  We already check patches via OpenAndValidateMsiStorage so
					// we cancel the trust check for transforms stored in the patch
					if(ieiSuccess == InitializeTransforms(riDatabase,pExistingPatchStorage,
																	  *MsiString((const ICHAR*)rgchTransformsBuf),
																	  fTrue,&strValidTransforms, true, false, true, 0, szCurrentDirectory,0,0,0,0) &&
																	  strValidTransforms.TextSize())
					{
						// cache source path
						if((pError = CachePatchInfo(riDatabase,*MsiString((const ICHAR*)rgchPatchBuf),g_MsiStringNull,
															 g_MsiStringNull,*MsiString((const ICHAR*)rgchTransformsBuf),
															 *strTempCopy, *strPatchPackage,
															 fTrue, fFalse, iPatchSequence++)) != 0)
						{
							return PostInitializeError(pError,*strPatchPackage,ieiPatchPackageInvalid);
						}
					}
					else
					{
						// obsolete patch, need to unregister
						if((pError = CachePatchInfo(riDatabase,*MsiString((const ICHAR*)rgchPatchBuf),g_MsiStringNull,
															 g_MsiStringNull,g_MsiStringNull,
															 g_MsiStringNull, g_MsiStringNull,
															 fTrue, fTrue, iPatchSequence++)) != 0)
						{
							return PostInitializeError(pError,*strPatchPackage,ieiPatchPackageInvalid);
						}
					}

					if(strNewPatchId.Compare(iscExactI, (const ICHAR*)rgchPatchBuf))
						// new patch already applied, don't need to apply again
						fApplyNewPatch = fFalse;
				}
				
				//!! if we need to recache database, call CachePatchInfo with temp path
			}
			else if(lResult == ERROR_NO_MORE_ITEMS)
				break;
			else
				break; //!! ?? error
		}
	}
	
	if(fApplyNewPatch && ristrPatchPackage.TextSize())
	{
		Assert(pNewPatchStorage);
		Assert(pNewPatchSummary);

		MsiString strNewTransforms = pNewPatchSummary->GetStringProperty(PID_LASTAUTHOR);
		MsiString strValidTransforms;
		// InitializeTransforms will perform a digital signature check on transforms if it determines
		// that the check is warranted.  We already check patches via OpenAndValidateMsiStorage so
		// we cancel the trust check for transforms stored in the patch
		ieiStat = InitializeTransforms(riDatabase,pNewPatchStorage,*strNewTransforms, fFalse, &strValidTransforms,true,false,true,0,szCurrentDirectory,0,0,0,0);
		if(ieiStat != ieiSuccess)
		{
			pError = PostError(Imsg(idbgInvalidPatchTransform));
			return PostInitializeError(pError,ristrPatchPackage,ieiPatchPackageInvalid);
		}

		if(!strValidTransforms.TextSize())
		{
			return PostInitializeError(pError,ristrPatchPackage,ieiNotValidPatchTarget);
		}
		
		PMsiPath pPackagePath(0);
		MsiString strPackageName;
		if((pError = m_riServices.CreateFilePath(ristrPatchPackage.GetString(),*&pPackagePath,*&strPackageName)) != 0)
		{
			return PostInitializeError(pError,ristrPatchPackage,ieiPatchPackageOpenFailed);
		}

		// set up patch registration record - will be dispatched by PublishProduct
		MsiString strSourceList = pNewPatchSummary->GetStringProperty(PID_KEYWORDS);

		if((pError = CachePatchInfo(riDatabase,*strNewPatchId,*strPackageName,*strSourceList,*strValidTransforms,
											 *strPatchTempCopy, ristrPatchPackage, fFalse, fFalse, iPatchSequence++)) != 0)
		{
			return PostInitializeError(pError,ristrPatchPackage,ieiPatchPackageInvalid);
		}
	}
	
	return ieiSuccess;
}

ieiEnum CMsiEngine::ProcessLanguage(const IMsiString& riAvailableLanguages, const IMsiString& riLanguage, unsigned short& iBaseLangId, Bool fNoUI, bool fIgnoreCurrentMachineLanguage)
{
	const ICHAR* pchLangIds = riAvailableLanguages.GetString();
	unsigned cLangIds = 0;
	unsigned short iBestLangId = 0;
	isliEnum isliBestMatch = isliNotSupported;
	unsigned short iLangId = 0;
	iBaseLangId = 0;


	for(;;) // language processing loop
	{
		int ch = *pchLangIds++;
		if (ch == ILANGUAGE_DELIMITER || ch == 0)
		{
			if (iLangId == 0)  // empty lang field or LANG_NEUTRAL specified
			{
				SetLanguage(0);
				return ieiSuccess;
			}
			
			if (cLangIds == 0) //first one
			{
				iBaseLangId = iLangId;
			}
			cLangIds++;

			if(riLanguage.TextSize()) // langid specified on command-line
			{
				if(riLanguage.GetIntegerValue() == iLangId)
					break;
			}
			else // no langid specified
			{
				if (fIgnoreCurrentMachineLanguage) // use the first lang id supported by the package, regardless of the machine's support
				{
					iBestLangId = iLangId;
					isliBestMatch = isliExactMatch;
					break;
				}
				else
				{
					isliEnum isliNewMatch = m_riServices.SupportLanguageId(iLangId, fFalse);
					if (isliNewMatch > isliBestMatch)
					{
						iBestLangId = iLangId;
						isliBestMatch = isliNewMatch;
					}
					if (isliBestMatch == isliExactMatch) // stop at 1st exact match
						break;
				}
			}

			iLangId = 0;  // reset for next language
			if (ch == 0)
				break;
		}
		else if (iLangId >= 0)
		{
			if (ch == TEXT(' '))
				continue;
			ch -= TEXT('0');
			if ((unsigned)ch > 9)
				return ieiLanguageUnsupported;

			iLangId = (unsigned short) (iLangId * 10 + ch);
		}
	}

	if(riLanguage.TextSize())
	{
		if(iLangId == 0)// langid specified on command-line but not supported
			return ieiLanguageUnsupported;
		else
			SetLanguage(iLangId);
	}
	else
	{
		if (isliBestMatch >= isliDialectMismatch)
		{
			SetLanguage(iBestLangId);
		}
		else if (isliBestMatch == isliLanguageMismatch)
		{

			if (cLangIds == 1) // we only support 1 language; no choice
				SetLanguage(iBaseLangId);
			else
			{
				int iRes = fNoUI ? 1 : SelectLanguage(riAvailableLanguages.GetString(), g_MessageContext.GetWindowCaption());
				if (iRes)
				{
					pchLangIds = riAvailableLanguages.GetString();
					Assert(iRes <= cLangIds);
					iRes--;
					while (iRes)
					{
						if ((*pchLangIds == 0) || (*pchLangIds == ILANGUAGE_DELIMITER))
							iRes--;
						pchLangIds++;
					}
					unsigned short iLangId = 0;
					while ((*pchLangIds != ILANGUAGE_DELIMITER) && (*pchLangIds != 0))
					{
						iLangId = (unsigned short)((10*iLangId)+(*pchLangIds - TEXT('0')));
						pchLangIds++;
					}
					SetLanguage(iLangId);
				}
				else // syntax error in string
				{
					return ieiDatabaseInvalid; //!! TEMP: should return a different code?
				}
			}
		}
		else // isliBestMatch == isliNotSupported
		{
			return ieiLanguageUnsupported;
		}
	}

	return ieiSuccess;
}


ieiEnum CMsiEngine::ProcessPlatform(const IMsiString& riAvailablePlatforms, WORD& wChosenPlatform)
{
	_SYSTEM_INFO sinf;
	WIN::GetSystemInfo(&sinf);

	MsiString strAvailablePlatforms (riAvailablePlatforms); // to keep the Alpha compiler happy
#ifdef _ALPHA_
	// we accept anything on Alpha
	wChosenPlatform = sinf.wProcessorArchitecture;
	return ieiSuccess;
#else
	// on Intel we accept only Intel or Intel64
	riAvailablePlatforms.AddRef();
	MsiString strPlatform;
	if (strAvailablePlatforms.TextSize() == 0) // empty list means platform-independent
	{
		wChosenPlatform = (WORD)PROCESSOR_ARCHITECTURE_INTEL;
		return ieiSuccess;
	}

	bool fIntel = false;
	bool fIntel64 = false;
	for (;;)
	{
		strPlatform = strAvailablePlatforms.Extract(iseUpto, IPLATFORM_DELIMITER);
		if (strPlatform.Compare(iscExact, IPROPNAME_INTEL))
			fIntel = true;
		else if (strPlatform.Compare(iscExact, IPROPNAME_INTEL64))
			fIntel64 = true;

		if (!strAvailablePlatforms.Remove(iseIncluding, IPLATFORM_DELIMITER))
			break;
	}

	// mixed packages (support for both Intel and Intel64) are not supported
	if ( fIntel64 && fIntel )
	{
		wChosenPlatform = (WORD)PROCESSOR_ARCHITECTURE_UNKNOWN; // use unknown to represent mixed
		return ieiPlatformUnsupported;
	}

	if ( fIntel64 )
	{
		wChosenPlatform = (WORD)PROCESSOR_ARCHITECTURE_IA64;
		if ( !g_fWinNT64 )
			// we do not allow 64-bit packages to run on a 32-bit OS
			return ieiPlatformUnsupported;
		else
			return ieiSuccess;
	}
	else if ( fIntel )
	{
		wChosenPlatform = (WORD)PROCESSOR_ARCHITECTURE_INTEL;
		return ieiSuccess;
	}
	else
	{
		wChosenPlatform = sinf.wProcessorArchitecture;
		return ieiPlatformUnsupported;
	}
#endif // ALPHA
}

ipitEnum CMsiEngine::InProgressInstallType(IMsiRecord& riInProgressInfo)
{
	ipitEnum ipitRet = ipitSameConfig;
	
	MsiString strCurrentLogon = GetPropertyFromSz(IPROPNAME_LOGONUSER);
	if(!(strCurrentLogon.Compare(iscExactI,MsiString(riInProgressInfo.GetMsiString(ipiLogonUser)))))
	{
		DEBUGMSG(TEXT("Checking in-progress install: install performed by different user."));
		ipitRet = ipitEnum(ipitRet | ipitDiffUser);
	}

	if(!(m_piProductKey->Compare(iscExactI, MsiString(riInProgressInfo.GetMsiString(ipiProductKey)))))
	{
		DEBUGMSG(TEXT("Checking in-progress install: install for different product."));
		ipitRet = ipitEnum(ipitRet | ipitDiffProduct);
	}

	// determine if same configuration or not
	// compare in-progress property values with those on the command line - command line
	// may not override any in-progress properties
	
	// comparison is fairly weak here - currently we only check the action to make sure it is the same
	// other things to check in the future: selections, folders, random properties

	MsiString strCurrentAction, strInProgressAction;
	strCurrentAction = GetPropertyFromSz(IPROPNAME_ACTION);
	
	MsiString strProperties = riInProgressInfo.GetMsiString(ipiProperties);
	ProcessCommandLine(strProperties, 0, 0, 0, &strInProgressAction, 0, 0, 0, fTrue, 0, 0);

	Assert(strInProgressAction.TextSize());

	// same config if actions are identical, or current action not specified and inprogress using default action
	if(strCurrentAction.Compare(iscExactI,strInProgressAction) ||
		(strCurrentAction.TextSize() == 0 && strInProgressAction.Compare(iscExactI, szDefaultAction)))
	{
		MsiString strSelections = riInProgressInfo.GetMsiString(ipiSelections);
		MsiString strValue;
		AssertNonZero(ProcessCommandLine(strSelections, 0, 0, 0, 0, 0,
													MsiString(IPROPNAME_FEATUREREMOVE), &strValue,
													fTrue, 0, 0));
		if ( strValue.Compare(iscExactI, TEXT("ALL")) )
		{
				//  fix to bug # 8785: we do not attempt to resume an interrupted RemoveAll.
			DEBUGMSG(TEXT("Checking in-progress install: install for an uninstall."));
			ipitRet = ipitEnum(ipitRet | ipitDiffConfig);
		}
		else
			DEBUGMSG(TEXT("Checking in-progress install: install for same configuration."));
	}
	else
	{
		DEBUGMSG(TEXT("Checking in-progress install: install for different configuration."));
		ipitRet = ipitEnum(ipitRet | ipitDiffConfig);
	}

	return ipitRet;
}

ieiEnum CMsiEngine::ProcessInProgressInstall()
{
	if(!m_piProductKey)
		return ieiSuccess;
	
	iuiEnum iui = g_scServerContext == scClient ? m_iuiLevel :
					  (iuiEnum)GetPropertyInt(*MsiString(IPROPNAME_CLIENTUILEVEL));
					
	if((GetMode() & iefSecondSequence) ||             // in-progress install already processed on client side
		((iui == iuiFull || iui == iuiReduced) && FMutexExists(szMsiExecuteMutex)))
																	  // on client side and mutex already exists -
																	 //  assume currently running install is in-progress install
																	 //  or will handle in-progress install
																	 // NOTE: condition will cause in-progress install to be processed
																	 //  twice when LIMITUI set on NT
	{
		return ieiSuccess;
	}
	
	PMsiRecord pInProgressInfo(0);
	bool fRes = GetInProgressInfo(*&pInProgressInfo);
	Assert(fRes);
	if(fRes && pInProgressInfo && pInProgressInfo->GetFieldCount())
	{
		// we have an in-progress install
		ipitEnum ipit = InProgressInstallType(*pInProgressInfo);

		// if the RUNONCEENTRY property is set, it means that the current install was launched from the RunOnce key
		// and that in-progress install must be the install that is being resumed
		if((ipit & ipitDiffUser) && MsiString(GetPropertyFromSz(IPROPNAME_RUNONCEENTRY)).TextSize())
		{
			Assert((ipit & ipitDiffProduct) == 0);
			
			// need to know if install was per-machine or not - parse ALLUSERS prop from command line
			MsiString strProperties = pInProgressInfo->GetMsiString(ipiProperties);
			MsiString strAllUsers;
			AssertNonZero(ProcessCommandLine(strProperties,0,0,0,0,0,
														MsiString(IPROPNAME_ALLUSERS),&strAllUsers,
														fTrue, 0, 0));
			
			
			// different user starting install after reboot
			if(strAllUsers.TextSize())
			{
				// suspended install is per-machine - we let the current user continue the install
				Assert(strAllUsers.Compare(iscExact,TEXT("1")));
				ipit = ipitSameConfig;
			}
			else if(g_fWin9X)
			{
				// if profiles are not enabled a different user can continue the install
				// note that we must make sure we thought profiles were disabled for the suspended install
				// AND the current install.  there are some cases where it looks as if profiles are not
				// enabled when they really are (when you cancel the login prompt)
				MsiString strInProgressProfilesEnabled, strCurrentProfilesEnabled;
				AssertNonZero(ProcessCommandLine(strProperties,0,0,0,0,0,
															MsiString(IPROPNAME_WIN9XPROFILESENABLED),
															&strInProgressProfilesEnabled, fTrue, 0, 0));

				strCurrentProfilesEnabled = GetPropertyFromSz(IPROPNAME_WIN9XPROFILESENABLED);

				if(!strInProgressProfilesEnabled.TextSize() && !strCurrentProfilesEnabled.TextSize())
				{
					ipit = ipitSameConfig;
				}
			}

			if(ipit != ipitSameConfig)
			{
				// suspended install is per-user
				// user can't continue, so we warn the user and end the install
				PMsiRecord pError = PostError(Imsg(imsgDiffUserInstallInProgressAfterReboot),
														*MsiString(pInProgressInfo->GetMsiString(ipiLogonUser)),
														*MsiString(pInProgressInfo->GetMsiString(ipiProductName)));

				Message(imtUser,*pError);
				return ieiDiffUserAfterReboot;
			}
		}
		
		if(ipit == ipitSameConfig)
		{
			// resuming suspended install

			// if REBOOT=FORCE is in the InProgress info, and we are resuming a ForceReboot install, unset that property now
			MsiString strRebootPropBeforeInProgress = GetPropertyFromSz(IPROPNAME_REBOOT);

			DEBUGMSG(TEXT("Suspended install detected. Resuming."));
			MsiString strSelections = pInProgressInfo->GetMsiString(ipiSelections);
			MsiString strFolders    = pInProgressInfo->GetMsiString(ipiFolders);
			MsiString strProperties = pInProgressInfo->GetMsiString(ipiProperties);
			MsiString strAfterRebootProperties = pInProgressInfo->GetMsiString(ipiAfterReboot);
			AssertNonZero(ProcessCommandLine(strSelections,0,0,0,0,0,0,0,fFalse, &m_piErrorInfo,this));
			AssertNonZero(ProcessCommandLine(strFolders,   0,0,0,0,0,0,0,fFalse, &m_piErrorInfo,this));
			AssertNonZero(ProcessCommandLine(strProperties,0,0,0,0,0,0,0,fFalse, &m_piErrorInfo,this));
			AssertNonZero(ProcessCommandLine(strAfterRebootProperties,0,0,0,0,0,0,0,fFalse, &m_piErrorInfo,this));

			MsiString strRebootPropAfterInProgress = GetPropertyFromSz(IPROPNAME_REBOOT);

			if(((((const ICHAR*) strRebootPropBeforeInProgress)[0] & 0xDF) != TEXT('F')) && // REBOOT <> FORCE before processing InProgress info
			   ((((const ICHAR*) strRebootPropAfterInProgress )[0] & 0xDF) == TEXT('F')) && // REBOOT == FORCE in InProgress info
				MsiString(GetPropertyFromSz(IPROPNAME_AFTERREBOOT)).TextSize())              // we are after a ForceReboot
			{
				// unset REBOOT property because most likely the user doesn't want to reboot again
				DEBUGMSG1(TEXT("%s property set to 'F' after a ForceReboot.  Resetting property to NULL."), IPROPNAME_REBOOT);
				AssertNonZero(SetProperty(*MsiString(*IPROPNAME_REBOOT), g_MsiStringNull));
			}

			// set Resume and UpdateStarted properties
			AssertNonZero(SetProperty(*MsiString(*IPROPNAME_RESUME), *MsiString(TEXT("1"))));
			AssertNonZero(SetProperty(*MsiString(*IPROPNAME_RESUMEOLD), *MsiString(TEXT("1"))));
			AssertNonZero(SetProperty(*MsiString(*IPROPNAME_UPDATESTARTED), *MsiString(TEXT("1"))));
		}
	}

	return ieiSuccess;
}

iesEnum CMsiEngine::Terminate(iesEnum iesState)
// If we are a child install or we are the server side of a client side install then we return
// iesReboot or iesRebootNow if a reboot is required (but don't prompt the user to reboot)
// Otherwise, we return iesCallerReboot if we require a reboot and the user said to reboot (or there is no UI)
{
	MsiSuppressTimeout();
	
	if (!m_fInitialized)
		return iesFailure;
	ENG::WaitForCustomActionThreads(this, fTrue, *this);  // wait for icaContinue async custom actions, except if EXE

	// if in the client and the parent engine, we can kill the custom action server. In the service, the script
	// will kill the CA server when finished.
	if (g_scServerContext == scClient && !m_piParentEngine)
		ShutdownCustomActionServer();
	
	MsiString strProductName = GetPropertyFromSz(IPROPNAME_PRODUCTNAME);
	if(!strProductName.TextSize())
		strProductName = TEXT("Unknown Product");

	bool fPropagateReboot = false;
	bool fQuietReboot = false;
	bool fDependents = ((m_iioOptions & iioClientEngine) != 0) || m_piParentEngine || ((GetMode() & iefSecondSequence) && (g_scServerContext != scClient));

	if(GetMode() & iefRebootNow)
		SetMode(iefReboot, fTrue); // make sure both are set
	
	if (!IgnoreReboot() && (iesState == iesSuccess || iesState == iesNoAction || (iesState == iesSuspend && (GetMode() & iefRebootNow))))
	{
		// successful completion - determine if reboot should happen
		MsiString strReboot = GetPropertyFromSz(IPROPNAME_REBOOT);
		MsiString strRebootPrompt = GetPropertyFromSz(IPROPNAME_REBOOTPROMPT);

		fQuietReboot = (((const ICHAR*) strRebootPrompt)[0] & 0xDF) == TEXT('S');

		switch(((const ICHAR*)strReboot)[0] & 0xDF)
		{
		case TEXT('S'):
			// REBOOT=SUPPRESS: suppress end-of-install reboots
			if(GetMode() & iefRebootNow)
				break;
			// fall through
		case TEXT('R'):
			// REBOOT=REALLYSUPPRESS: suppress end-of-install and ForceReboot reboots
			if(GetMode() & iefReboot)
				SetMode(iefRebootRejected, fTrue);

			SetMode(iefReboot, fFalse);
			SetMode(iefRebootNow, fFalse);
			break;
		case TEXT('F'):
			// REBOOT=FORCE: force reboot
			SetMode(iefReboot, fTrue);
			break;
		};

	
		if (fDependents) // parent or client-side engine will do the actual reboot if necessary
		{
			fPropagateReboot = true;
		}
		else
		{
			if (GetMode() & iefReboot)
			{
				PMsiRecord piRecord = PostError(GetMode() & iefRebootNow ? Imsg(imsgRebootNow) : Imsg(imsgRebootAtEnd), *strProductName);
				imtEnum imtOutput = (fQuietReboot) ? imtInfo : imtEnum(imtUser | imtYesNo);
				
				imsEnum imsReturn = Message(imtOutput, *piRecord);
				switch (imsReturn)
				{
				case imsYes:
				case imsNone:
				case imsOk:
					break;
				case imsNo:
					SetMode(iefRebootRejected, fTrue);
					SetMode(iefReboot, fFalse);
					SetMode(iefRebootNow, fFalse);
					break;
				default:
					AssertSz(false, "Invalid return from message");
					break;
				}
			}
		}
	}
	else
	{
		// failure, user cancelled, restricted engine, or creating advertise script - clear reboot flags in case they'd been set previously
		if (IgnoreReboot() && ((GetMode() & iefReboot) || (GetMode() & iefRebootNow)))
		{
			DEBUGMSG(TEXT("Reboot has been ignored because we are in a restricted engine or we are creating an advertise script."));
		}
		SetMode(iefReboot, fFalse);
		SetMode(iefRebootNow, fFalse);
		SetMode(iefRebootRejected, fFalse);
	}

#ifdef DEBUG
	if(m_fServerLocked && !m_fInParentTransaction && iesState == iesSuccess)
		AssertSz(0,"Server still locked in Engine.Terminate.");
#endif //DEBUG

	if (g_MessageContext.ChildUIThreadExists())
	{
		// See if the thread is still running, if it isn't we want to terminate
		if (!g_MessageContext.ChildUIThreadRunning())
		{
			g_MessageContext.Terminate(fFalse);
		}
	}

	if (g_MessageContext.Invoke(imtEnum(imtDumpProperties), 0) == imsYes && m_piPropertyCursor)
	{
		PMsiTable pTable(0);
		PMsiRecord pError = m_piDatabase->LoadTable(*MsiString(*sztblControl), 0, *&pTable);
		if ( pError )
			pTable = 0;
		MsiString strHiddenProperties = GetPropertyFromSz(IPROPNAME_HIDDEN_PROPERTIES);
		MsiString strStars(IPROPVALUE_HIDDEN_PROPERTY);

		// use new cursor - m_piPropertyCursor used within FormatLog
		PMsiTable pPropertyTable = &m_piPropertyCursor->GetTable();
		PMsiCursor pPropertyCursor = pPropertyTable->CreateCursor(fFalse);
		PMsiRecord pRecord(&ENG::CreateRecord(2));
		ICHAR rgchBuf[sizeof(szPropertyDumpTemplate)/sizeof(ICHAR)]; // substitute a single character
		int chEngine = 'C';
		if (m_piParentEngine)
			chEngine = 'N';
		else if (g_scServerContext != scClient)
			chEngine = 'S';
		wsprintf(rgchBuf, szPropertyDumpTemplate, chEngine);
		pRecord->SetString(0, rgchBuf);
		while (pPropertyCursor->Next())
		{
			MsiString strProperty(pPropertyCursor->GetString(1));
			pRecord->SetMsiString(1,*strProperty);
			if ( IsPropertyHidden(strProperty, strHiddenProperties, pTable, *m_piDatabase, NULL) )
				pRecord->SetMsiString(2,*strStars);
			else
				pRecord->SetMsiString(2,*MsiString(pPropertyCursor->GetString(2)));
			g_MessageContext.Invoke(imtEnum(imtForceLogInfo), pRecord);
		}
	}

	if (!fDependents)
	{
		ReleaseHandler();

		// terminate log

		const IMsiString* piLogTrailer = m_rgpiMessageHeader[imsgLogTrailer];
		if (piLogTrailer)
		{
			PMsiRecord pRecord = &ENG::CreateRecord(0);
			pRecord->SetMsiString(0, *piLogTrailer);
			Message(imtEnum(imtForceLogInfo), *pRecord);  // use engine to format properties
		}
	}

	FreeDirectoryTable();    // release path objects held by table
	FreeSelectionTables();
	
	int iefMode = GetMode(); // grab this before we clear the engine data

	// If not already logged by a call to FatalError, send install result to Event log
	if (!fDependents && !m_fResultEventLogged &&
		 (iesState == iesSuccess || iesState == iesFailure))
	{
		int iErrorIndex = 0;
		IErrorCode iErrorCode = 0;

		switch(GetInstallType())
		{
		case iitFirstInstall:
			if(iesState == iesSuccess)
			{
				iErrorIndex =      imsgEventLogInstallSuccess;
				iErrorCode  = Imsg(imsgEventLogInstallSuccess);
			}
			else
			{
				iErrorIndex =      imsgEventLogInstallFailed;
				iErrorCode  = Imsg(imsgEventLogInstallFailed);
			}
			break;

		case iitMaintenance:
			if(iesState == iesSuccess)
			{
				iErrorIndex =      imsgEventLogConfigurationSuccess;
				iErrorCode  = Imsg(imsgEventLogConfigurationSuccess);
			}
			else
			{
				iErrorIndex =      imsgEventLogConfigurationFailed;
				iErrorCode  = Imsg(imsgEventLogConfigurationFailed);
			}
			break;

		case iitUninstall:
			if(iesState == iesSuccess)
			{
				iErrorIndex =      imsgEventLogUninstallSuccess;
				iErrorCode  = Imsg(imsgEventLogUninstallSuccess);
			}
			else
			{
				iErrorIndex =      imsgEventLogUninstallFailed;
				iErrorCode  = Imsg(imsgEventLogUninstallFailed);
			}
			break;

		case iitAdvertise:
			if(iesState == iesSuccess)
			{
				iErrorIndex =      imsgEventLogAdvertiseSuccess;
				iErrorCode  = Imsg(imsgEventLogAdvertiseSuccess);
			}
			else
			{
				iErrorIndex =      imsgEventLogAdvertiseFailed;
				iErrorCode  = Imsg(imsgEventLogAdvertiseFailed);
			}
			break;
		};

		if(iErrorIndex)
		{
			PMsiRecord pError = PostError(iErrorCode);
			AssertNonZero(pError->SetMsiString(0, *MsiString(GetErrorTableString(iErrorIndex))));
			ReportToEventLog(EVENTLOG_INFORMATION_TYPE,
								  EVENTLOG_ERROR_OFFSET + pError->GetInteger(1),
								  *pError);
		}
	}

	ClearEngineData();
	m_fInitialized = fFalse; // can't run again without initializing

	// reboot handling
	if (iefMode & iefRebootNow) // reboot triggered by ForceReboot
	{
		if(fPropagateReboot) // pass to client engine
		{
			DEBUGMSG("Propagated RebootNow to the client/parent install.");
			iesState = (iesEnum)iesRebootNow; // client will change return back to ERROR_INSTALL_SUSPEND
		}
		else
			iesState = (iesEnum)iesCallerReboot; // caller will reboot for us

		if (m_piConfigManager)
			m_piConfigManager->EnableReboot(m_fRunScriptElevated, *strProductName);
	}
	else if (iefMode & iefReboot) // normal end-of-install reboot
	{
		if(fPropagateReboot) // pass to client engine
		{
			DEBUGMSG("Propagated Reboot to the client/parent install.");
			iesState = (iesEnum)iesReboot;
		}
		else
			iesState = (iesEnum)iesCallerReboot; // caller will reboot for us
			
		if (m_piConfigManager)
			m_piConfigManager->EnableReboot(m_fRunScriptElevated, *strProductName);
	}
	else if (iefMode & iefRebootRejected && iesState != iesSuspend) // if ForceReboot reboot rejected, we still
																						 // want to return ERROR_INSTALL_SUSPEND
	{
		iesState = (iesEnum)iesRebootRejected; // reboot required but rejected by user or REBOOT=S/R
	}

	MsiSuppressTimeout();
	UnbindLibraries();
	g_Win64DualFolders.Clear();
	return iesState;
}

const IMsiString& CMsiEngine::GetRootParentProductKey()  // recurses up nested install hierarchy
{
	if (!(m_fChildInstall && m_piParentEngine))
		return GetProductKey();
	return m_piParentEngine->GetRootParentProductKey();
}

Bool CMsiEngine::InTransaction()
{
	if (m_fServerLocked)
		return fTrue;
#ifdef DEBUG
	if(m_piParentEngine)
		Assert(m_piParentEngine->InTransaction() == fFalse);
#endif //DEBUG
	return fFalse;
}

HRESULT CMsiClientMessage::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_IMsiMessage))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CMsiClientMessage::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiClientMessage::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;

	if (m_fMessageContextInitialized == true)
		g_MessageContext.Terminate(fFalse);
	delete this;
	g_cInstances--;
	return 0;
}

extern IMsiRecord* g_piNullRecord;

imsEnum CMsiClientMessage::MessageNoRecord(imtEnum imt)
{
	return Message(imt, *g_piNullRecord);
}

imsEnum CMsiClientMessage::Message(imtEnum imt, IMsiRecord& riRecord)
{
	if (((imt & ~iInternalFlags) & imtTypeMask) > imtCommonData)  //!! move to action.cpp and use mask, or put limit in engine.h
	{
		g_MessageContext.m_szAction = riRecord.GetString(0);
		return g_MessageContext.Invoke(imt, 0);
	}
	return g_MessageContext.Invoke(imt, &riRecord);
}

iesEnum CMsiEngine::RunExecutionPhase(const ICHAR* szActionOrSequence, bool fSequence)
{
	Assert(szActionOrSequence && *szActionOrSequence);

	// running on the server side is not permitted in a SAFE engine
	if (m_fRestrictedEngine)
	{
		DEBUGMSG2(TEXT("Running server side execution of %s %s is not permitted in a restricted engine"), fSequence ? TEXT("sequence") : TEXT("action"), szActionOrSequence);
		return iesNoAction;
	}

	// Smart connection manager object which creates a connection to the
	// service if there isn't one already and cleans up after itself
	// upon destruction.
	CMsiServerConnMgr MsiSrvConnMgrObject (this);
    	
	CMutex hExecuteMutex; // will release when out of scope
	bool fSetPowerdown = false;
	
	m_cExecutionPhaseSequenceLevel = m_cSequenceLevels;
	
	// if client-side or running an install from a custom action, grab the execution mutex as we are about to run the execution phase
	// in some cases, this thread already has the mutex but it won't hurt to grab it again.
	if((g_scServerContext == scClient || g_scServerContext == scCustomActionServer) && !m_piParentEngine)
	{
		// the convention is that with basic UI we don't prompt the user to retry when another install
		// is running. For example, when the server is registered and basic UI, we grab the mutex in
		// CreateAndRunEngine, before we have any UI to prompt the user with.  We need extra logic here
		// to achieve the same behaviour - thus we pass 0 for the message object when the UI level is
		// less than reduced
		int iError = GrabExecuteMutex(hExecuteMutex,
												(m_iuiLevel == iuiBasic || m_iuiLevel == iuiNone) ? 0 : this);
		switch(iError)
		{
		case ERROR_SUCCESS:                              break;
		case ERROR_INSTALL_USEREXIT:     return iesUserExit;
		case ERROR_INSTALL_ALREADY_RUNNING: return iesInstallRunning;
		default:                       // fall through
			Assert(0);
		case ERROR_INSTALL_FAILURE:    return iesFailure;
		}

		fSetPowerdown = true;
		m_riServices.SetNoOSInterruptions();
	}
	
	if (FIsUpdatingProcess())
	{
		iesEnum iesRet;
		DEBUGMSG1("Not switching to server: %s", (g_scServerContext != scClient) ? "we're in the server" : "we're not connected to the server" );
		if(fSequence)
			iesRet = Sequence(szActionOrSequence);
		else
			iesRet = DoAction(szActionOrSequence);

		if (fSetPowerdown)
			m_riServices.ClearNoOSInterruptions();
		return iesRet;
	}
	else if (!m_piServer)
	{
	    iesEnum iesRet;
	    PMsiRecord pError = PostError (Imsg(imsgServiceConnectionFailure));
	    Message(imtEnum(imtError + imtOk), *pError);
	    iesRet = FatalError (*pError);
	    
	    if (fSetPowerdown)
			m_riServices.ClearNoOSInterruptions();
	    return iesRet;
	}

	Assert(!fSequence);
	Assert(m_piServer);

	MsiString strPropertyList, strLoggedPropertyList;
	MsiString strSelections;
	AssertRecord(GetCurrentSelectState(*&strSelections, *&strPropertyList, &strLoggedPropertyList, 0, fTrue));
	strPropertyList += *TEXT(" ");
	strPropertyList += strSelections;
	strPropertyList += *TEXT(" ");
	strLoggedPropertyList += *TEXT(" ");
	strLoggedPropertyList += strSelections;
	strLoggedPropertyList += *TEXT(" ");

	MsiString strDatabase = GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE); //?? there might be some optimization we can do to avoid having to cache the temp database twice, but there are security considerations...

	DEBUGMSG1(TEXT("Switching to server: %s"), strLoggedPropertyList);

	MsiString strHomeVars;
	GetHomeEnvironmentVariables(*&strHomeVars);

	strPropertyList += strHomeVars;

	int iError;
	iesEnum iesReturn = iesSuccess;

	iioEnum iioOptions = m_iioOptions;
	if((GetMode() & iefRollbackEnabled) == 0)
		iioOptions = (iioEnum)(iioOptions | iioDisableRollback);

	if (g_scServerContext == scClient)
		iioOptions = (iioEnum)(iioOptions | iioClientEngine);

	for (;;)
	{
		PMsiMessage pMessage = new CMsiClientMessage();
		
                iError = m_piServer->DoInstall(irePackagePath, strDatabase, szActionOrSequence, strPropertyList,g_szLogFile,g_dwLogMode, g_fFlushEachLine, *pMessage,iioOptions);

		switch(iError)
		{
		
		// for this group of returns we don't need to alert the user. either the user has
		// already seen the error dialog, or she doesn't need to see one, or the dialog
		// will be displayed in the near future

		case ERROR_SUCCESS:                              break;
		case ERROR_INSTALL_SUSPEND:      iesReturn = iesSuspend;  break;
		case ERROR_INSTALL_USEREXIT:     iesReturn = iesUserExit; break;
		case ERROR_INSTALL_ALREADY_RUNNING: iesReturn = iesInstallRunning; break;
		case ERROR_INSTALL_REBOOT_NOW: iesReturn = iesSuspend;  SetMode(iefRebootNow, fTrue); // fall through
		case ERROR_INSTALL_REBOOT:               SetMode(iefReboot, fTrue); break;
		case ERROR_SUCCESS_REBOOT_REQUIRED: SetMode(iefRebootRejected, fTrue); break;
		case ERROR_INSTALL_FAILURE:    iesReturn = iesFailure; break;

		// the most likely cause of this group of errors is a network failure. we'll give
		// the user a chance to retry if we see any of these

		case ERROR_FILE_NOT_FOUND:                                              // fall through
		case ERROR_INSTALL_PACKAGE_OPEN_FAILED:
		case ERROR_INSTALL_PACKAGE_INVALID:
		case ERROR_PATCH_PACKAGE_OPEN_FAILED:
		case ERROR_PATCH_PACKAGE_INVALID:
			{
				PMsiRecord pError = PostError(Imsg(imsgErrorReadingFromFile), *strDatabase, GetLastError());
				switch(Message(imtEnum(imtError+imtRetryCancel),*pError))
				{
				case imsRetry:
					continue;
				default:
					iesReturn = iesFailure;
				};
			}
			break;

		// any other error we get is unexpected, so we'll put up a debug error

		default:
#ifdef DEBUG
			ICHAR rgchMsg[1025];

			wsprintf(rgchMsg, TEXT("Unexpexcted return code %d.\n"), iError);
			AssertSz(fFalse, rgchMsg);
#endif //DEBUG
			iesReturn = iesFailure;    // fall through
			{
				PMsiRecord pError = PostError(Imsg(idbgUnexpectedServerReturn), iError, strDatabase);
				iesReturn = FatalError(*pError);
			}
		}

		break;
	}

	m_fJustGotBackFromServer = fTrue;
	DEBUGMSG1(TEXT("Back from server. Return value: %d"), (const ICHAR*)(INT_PTR)iError);

	if (fSetPowerdown)
		m_riServices.ClearNoOSInterruptions();
	return iesReturn;
}

Bool CMsiEngine::UnlockInstallServer(Bool fSuspend)
{
	DEBUGMSG(TEXT("Unlocking Server"));
	
	if(fSuspend == fFalse) // not suspending install - remove InProgressKey
	{
		return ClearInProgressInformation(m_riServices) ? fTrue : fFalse;
	}
	return fTrue;
}

bool CMsiEngine::GetInProgressInfo(IMsiRecord*& rpiCurrentInProgressInfo)
{
	//!! need to have a mutex around this so we aren't writing and reading key at same time?
	PMsiRecord pError = GetInProgressInstallInfo(m_riServices, rpiCurrentInProgressInfo);
	return pError == 0;
}

IMsiRecord* CMsiEngine::LockInstallServer(IMsiRecord* piSetInProgressInfo,       // InProgress info to set
													IMsiRecord*& rpiCurrentInProgressInfo) // current InProgress info if any
{
	Assert(m_fServerLocked == fFalse);

	IMsiRecord* piError = 0;

	PMsiRecord pInProgressInfo(0);
	if((piError = GetInProgressInstallInfo(m_riServices, *&pInProgressInfo)) != 0)
		return piError;

	if(pInProgressInfo && pInProgressInfo->GetFieldCount())
	{
		MsiString strInProgressProductKey = pInProgressInfo->GetMsiString(ipiProductKey);
		rpiCurrentInProgressInfo = pInProgressInfo;
		rpiCurrentInProgressInfo->AddRef();

		// not running - need to roll back or resume
		DEBUGMSG1(TEXT("Server Locked: Install is suspended for product %s"),(const ICHAR*)strInProgressProductKey);
		return 0;
	}
	else if(piSetInProgressInfo)
	{
		MsiString strProductKey = GetProductKey();

		DEBUGMSG1(TEXT("Server not locked: locking for product %s"),(const ICHAR*)strProductKey);

		return SetInProgressInstallInfo(m_riServices, *piSetInProgressInfo);
	}
	else
		return 0;
}

iesEnum CMsiEngine::RollbackSuspendedInstall(IMsiRecord& riInProgressParams, Bool fPrompt,
															Bool& fRollbackAttempted, Bool fUserChangedDuringInstall)
// prompt user and rollback in-progress install
// assumes a mutex is created for this install
{
	// Smart connection manager object which creates a connection to the
	// service if there isn't one already and cleans up after itself
	// upon destruction.
	CMsiServerConnMgr MsiSrvConnMgrObject (this);

	if (NULL == m_piServer)
	{
	    PMsiRecord pError = PostError (Imsg(imsgServiceConnectionFailure));
	    return FatalError(*pError);
	}
	
	MsiString strProductKey = riInProgressParams.GetMsiString(ipiProductKey);
	Bool fSameProduct = ToBool(strProductKey.Compare(iscExactI,MsiString(GetProductKey())));
	IErrorCode imsg = fSameProduct ? Imsg(imsgResumeWithDifferentOptions) : Imsg(imsgOtherInstallSuspended);
	MsiString strProductName = riInProgressParams.GetMsiString(ipiProductName);

	if(fPrompt)
	{
		PMsiRecord pError = PostError(imsg,*strProductName);
		if(Message(imtEnum(imtError|imtYesNo), *pError) == imsNo)
		{
			fRollbackAttempted = fFalse;
			return iesFailure;
		}
	}

	// need to use basic UI for rollback progress
	fRollbackAttempted = fTrue;
	iesEnum iesRet = m_piServer->InstallFinalize(iesFailure,*this, fUserChangedDuringInstall);
	if(iesRet == iesSuspend)
	{
		// rollback requires a reboot to complete
		// when rolling back a suspended install, we treat it like a "reboot before continuing" reboot
		SetMode(iefReboot, fTrue);
		SetMode(iefRebootNow, fTrue);
		// will return iesSuspend below, causing install to stop
	}

	CloseHydraRegistryWindow(/*Commit=*/false);
	EndSystemChange(/*fCommitChange=*/false, riInProgressParams.GetString(ipiSRSequence));
	AssertNonZero(UnlockInstallServer(fFalse));
	return iesRet;
}

//FN: writes msistring into stream as unicode text
void ConvertMsiStringToStream(const IMsiString& riString, IMsiStream& riStream)
{
	const WCHAR* pwch;
	unsigned long cbWrite;
#ifdef UNICODE
	pwch = riString.GetString();
	cbWrite = riString.TextSize()* sizeof(ICHAR);
#else
	CTempBuffer<WCHAR, 1024> rgchBuf;
	int cch = WIN::MultiByteToWideChar(CP_ACP, 0, riString.GetString(), -1, 0, 0);
	rgchBuf.SetSize(cch);
	AssertNonZero(WIN::MultiByteToWideChar(CP_ACP, 0, riString.GetString(), -1, rgchBuf, cch));
	pwch = rgchBuf;
	cbWrite = (cch - 1)* sizeof(WCHAR);
#endif
	riStream.PutData(pwch, cbWrite);
}

//FN: reads stream as unicode text into msistring 
const IMsiString& ConvertStreamToMsiString(IMsiStream& riStream)
{
	const IMsiString* piString;
	unsigned long cbRead;
	unsigned long cbLength = riStream.Remaining();
	const WCHAR* pwch;
	if(!cbLength)
		return SRV::CreateString();
#ifdef UNICODE
	pwch = SRV::AllocateString(cbLength/sizeof(ICHAR), fFalse, piString);
	if (!pwch)
		return SRV::CreateString();
	cbRead = riStream.GetData((void*)pwch, cbLength);
	if (cbRead != cbLength)
	{
		piString->Release();
		return SRV::CreateString();
	}
#else
	CTempBuffer<WCHAR, 1024> rgchBuf;
	rgchBuf.SetSize(cbLength/sizeof(WCHAR) + 1);
	pwch = rgchBuf;
	cbRead = riStream.GetData((void*)pwch, cbLength);
	if (cbRead != cbLength)
	{
		return SRV::CreateString();
	}
	// null terminate
	rgchBuf[(unsigned int)(cbLength/sizeof(WCHAR))] = (WCHAR)0;
	int cch = WIN::WideCharToMultiByte(CP_ACP, 0, pwch, -1, 0, 0, 0, 0);
	ICHAR* pch = SRV::AllocateString(cch - 1, fTrue, piString); // don't include the null
	if (!pch)
		return SRV::CreateString();
	WIN::WideCharToMultiByte(CP_ACP, 0, pwch, -1, pch, cch, 0, 0);
#endif
	return *piString;
}

// structure that defines the inprogress info
struct CInProgressInfo{
	ICHAR* szInProgressFieldName; int iOutputRecordField; bool fRequired;
};

const CInProgressInfo rgInProgressInfo[] =
{
	szMsiInProgressProductCodeValue, ipiProductKey,  true,
	szMsiInProgressProductNameValue, ipiProductName, true,
	szMsiInProgressLogonUserValue,	 ipiLogonUser,   false,
	szMsiInProgressSelectionsValue,  ipiSelections,  false,
	szMsiInProgressFoldersValue,     ipiFolders,     false,
	szMsiInProgressPropertiesValue,  ipiProperties,  false,
	szMsiInProgressTimeStampValue,   ipiTimeStamp,   true,
	szMsiInProgressDatabasePathValue,ipiDatabasePath,false,
	szMsiInProgressDiskPromptValue,  ipiDiskPrompt,  false,
	szMsiInProgressDiskSerialValue,  ipiDiskSerial,  false,
	szMsiInProgressSRSequence,       ipiSRSequence,  false,
	szMsiInProgressAfterRebootValue, ipiAfterReboot,  false,
};

const int cInProgressInfo = sizeof(rgInProgressInfo)/sizeof(CInProgressInfo);

IMsiRecord* GetInProgressInstallInfo(IMsiServices& riServices, IMsiRecord*& rpiRec)
{
	PMsiRecord pError(0); // used to catch errors - don't return
	PMsiRegKey pLocalMachine = &riServices.GetRootKey(rrkLocalMachine);
	PMsiRegKey pInProgressKey = &pLocalMachine->CreateChild(szMsiInProgressKey);
	Bool fExists = fFalse;

	MsiString strInProgressFileName;
	PMsiStorage pStorage(0);
	PMsiRecord pRec(0);

	int cIndex = 0;

	if(	((pError = pInProgressKey->Exists(fExists)) == 0) &&
		fExists == fTrue &&
		((pError = pInProgressKey->GetValue(0, *&strInProgressFileName)) == 0) && // filename containing inprogress info
		((pError = riServices.CreateStorage(strInProgressFileName, ismReadOnly, *&pStorage)) == 0)) // create storage
	{
		pRec = &riServices.CreateRecord(ipiEnumCount);

		// get the inprogress info from the storage file
		// each inprogress entity is stored as a stream
		do
		{
			PMsiStream pStream(0);
			if((pError = pStorage->OpenStream(rgInProgressInfo[cIndex].szInProgressFieldName, fFalse, *&pStream)) == 0)
			{
				// read the stream into the record field
				pRec->SetMsiString(rgInProgressInfo[cIndex].iOutputRecordField, *MsiString(ConvertStreamToMsiString(*pStream)));
			}
		}while( (!rgInProgressInfo[cIndex].fRequired || (!pError && MsiString(pRec->GetMsiString(rgInProgressInfo[cIndex].iOutputRecordField)).TextSize())) && // check if we are missing a mandatory field
				(++cIndex < cInProgressInfo));
	}

	if(cIndex != cInProgressInfo) // we do not have progress info
		pRec = &riServices.CreateRecord(0);

	pRec->AddRef();
	rpiRec = pRec;// return the record
	return 0;
}

IMsiRecord* SetInProgressInstallInfo(IMsiServices& riServices, IMsiRecord& riRec)
{
    PMsiRegKey pLocalMachine = &riServices.GetRootKey(rrkLocalMachine);
    PMsiRegKey pInProgressKey = &pLocalMachine->CreateChild(szMsiInProgressKey);
    Bool fExists = fFalse;
    PMsiRecord pError(0);
    if(((pError = pInProgressKey->Exists(fExists)) == 0) && fExists == fTrue)
    {
        // we've gotten this far without failing by checking the execute mutex - just nuke the key
        CElevate elevate;
        AssertRecord(pInProgressKey->Remove());
    }

    {
        IMsiRecord* piError = 0;
        CElevate elevate;

		// create the file for storing the inprogress info
		// Generate a unique name for inprogress file, create and secure the file.
		MsiString strMsiDir = ENG::GetMsiDirectory();

		// set dest path and file name
		MsiString strInProgressFileName;
		static const ICHAR szInprogressExtension[]  = TEXT("ipi");

		PMsiPath pDestPath(0);

		if (((piError = riServices.CreatePath(strMsiDir, *&pDestPath)) != 0) ||
			((piError = pDestPath->EnsureExists(0)) != 0) ||
			((piError = pDestPath->TempFileName(0, szInprogressExtension, fTrue, *&strInProgressFileName, &CSecurityDescription(true, false))) != 0) ||
			((piError = pDestPath->SetAllFileAttributes(0,FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM)) != 0))
			return piError;

		MsiString strInProgressFullFilePath = pDestPath->GetPath();
		strInProgressFullFilePath += strInProgressFileName;

		PMsiStorage pStorage(0);
		piError = riServices.CreateStorage(strInProgressFullFilePath, ismCreate, *&pStorage);

		if(piError)
			return piError;

		// write the individual inprogress fields as streams
		int cIndex = 0;
		do
		{
			PMsiStream pStream(0);
			if((pError = pStorage->OpenStream(rgInProgressInfo[cIndex].szInProgressFieldName, fTrue, *&pStream)) == 0)
			{
				// write the stream from the record field
				ConvertMsiStringToStream(*MsiString(riRec.GetMsiString(rgInProgressInfo[cIndex].iOutputRecordField)), *pStream);
			}
		}while(++cIndex < cInProgressInfo);

		// now attempt to commit the Inprogress file
		pError = pStorage->Commit();

		if(piError)
			return piError;


        piError = pInProgressKey->Create();
		if(!piError)
			piError = pInProgressKey->SetValue(0, *strInProgressFullFilePath);
        if(piError)
        {
            // cleanup in case key is half-written
			AssertNonZero(WIN::DeleteFile(strInProgressFullFilePath));
            AssertRecord(pInProgressKey->Remove());
            
            if(piError->GetInteger(2) == ERROR_ACCESS_DENIED) // assumes system error is in 2nd field
            {
                DEBUGMSG(MsiString(piError->FormatText(fTrue)));
                piError->Release();
                return PostError(Imsg(imsgErrorAccessingSecuredData));
            }
            else
                return piError;
        }
    }
    RegFlushKey(HKEY_LOCAL_MACHINE);
    return 0;
}

IMsiRecord* UpdateInProgressInstallInfo(IMsiServices& riServices, IMsiRecord& riRec)
{
	IMsiRecord* piError = 0;
	PMsiRegKey pLocalMachine = &riServices.GetRootKey(rrkLocalMachine);
	PMsiRegKey pInProgressKey = &pLocalMachine->CreateChild(szMsiInProgressKey);
	Bool fExists = fFalse;

	MsiString strInProgressFileName;
	PMsiStorage pStorage(0);
	PMsiRecord pRec(0);

	if((piError = pInProgressKey->Exists(fExists)) != 0)
		return piError;

	if(fExists == fFalse)
	{
		AssertSz(0, TEXT("No InProgress info to update"));
		return 0;
	}

	if((piError = pInProgressKey->GetValue(0, *&strInProgressFileName)) != 0 ||
		(piError = riServices.CreateStorage(strInProgressFileName, ismTransact, *&pStorage)) != 0)
	{
		return piError;
	}
	
	// write the individual inprogress fields as streams
	int cIndex = 0;
	do
	{
		PMsiStream pStream(0);
		if(!riRec.IsNull(rgInProgressInfo[cIndex].iOutputRecordField))
		{
			if((piError = pStorage->OpenStream(rgInProgressInfo[cIndex].szInProgressFieldName, fTrue, *&pStream)) != 0)
				return piError;
			
			// write the stream from the record field
			ConvertMsiStringToStream(*MsiString(riRec.GetMsiString(rgInProgressInfo[cIndex].iOutputRecordField)), *pStream);
		}
	}while(++cIndex < cInProgressInfo);

	// now attempt to commit the Inprogress file
	if((piError = pStorage->Commit()) != 0)
		return piError;

	return 0;
}

bool ClearInProgressInformation(IMsiServices& riServices)
{
	CElevate elevate;
	PMsiRegKey pLocalMachine = &riServices.GetRootKey(rrkLocalMachine);
	PMsiRegKey pInProgressKey = &pLocalMachine->CreateChild(szMsiInProgressKey);
	// read the default value which would point to the file 
	MsiString strInProgressFileName;
	PMsiRecord pError = pInProgressKey->GetValue(0, *&strInProgressFileName);
	AssertRecordNR(pError);
	if(!pError && strInProgressFileName.TextSize())
	{
		// delete the inprogress file
		AssertNonZero(WIN::DeleteFile((const ICHAR*)strInProgressFileName));
	}
	pError = pInProgressKey->Remove();
	AssertRecordNR(pError);
	return pError ? false : true;
}

IMsiRecord* CMsiEngine::GetCurrentSelectState(const IMsiString*& rpistrSelections,
															 const IMsiString*& rpistrProperties,
															 const IMsiString** ppistrLoggedProperties,
															 const IMsiString** ppistrFolders,
															 Bool /*fReturnPresetSelections*/)
{
	PMsiCursor pDirectoryCursor(0);
	PMsiCursor pFeatureCursor(0);

	if(m_piDirTable)
		pDirectoryCursor = m_piDirTable->CreateCursor(fFalse);

	if(m_piFeatureTable)
		pFeatureCursor = m_piFeatureTable->CreateCursor(fFalse);

	bool fGrabbedFeatureProps = false;
	
	if(pFeatureCursor)
	{
		MsiString strSelections;

		// in general if costing has been performed, we don't trust the existing values of the
		// feature properties.  it is possible that the feature properties don't contain the full
		// list of features and their requested states.  for example, ADDLOCAL=Child may actually
		// turn on the Child feature and its parent, if the parent hasn't yet been installed.

		// the exception to this rule is that we do respect REMOVE=ALL. InstallValidate explicitely
		// sets REMOVE=ALL when appropriate, and we don't want to overwrite that with the entire list
		// of properties.

		// NOTE: there is no chance of a preexisting property like ADDDEFAULT sneaking in among our
		// list of properties since we skip all feature properties below when compiling a list
		// of properties
		
		MsiString strRemoveValue = GetPropertyFromSz(IPROPNAME_FEATUREREMOVE);
		if (strRemoveValue.Compare(iscExact, IPROPVALUE_FEATURE_ALL))
		{
			strSelections = IPROPNAME_FEATUREREMOVE TEXT("=") IPROPVALUE_FEATURE_ALL;
		}
		else
		{
			MsiString strAddLocal, strAddSource, strRemove, strReinstall, strAdvertise, strFeature;
			while(pFeatureCursor->Next())
			{
				iisEnum iis = (iisEnum)pFeatureCursor->GetInteger(m_colFeatureActionRequested);
				strFeature = pFeatureCursor->GetString(m_colFeatureKey);
				strFeature += TEXT(",");
				switch(iis)
				{
					case iisAbsent:
						strRemove += strFeature;
						break;
					case iisLocal:
						strAddLocal += strFeature;
						break;
					case iisSource:
						strAddSource += strFeature;
						break;
					case iisReinstall:
						strReinstall += strFeature;
						break;
					case iisAdvertise:
						strAdvertise += strFeature;
						break;
				};
			}

			if(strAddLocal.Compare(iscEnd,TEXT(",")))
				strAddLocal.Remove(iseEnd,1);
			if(strAddSource.Compare(iscEnd,TEXT(",")))
				strAddSource.Remove(iseEnd,1);
			if(strRemove.Compare(iscEnd,TEXT(",")))
				strRemove.Remove(iseEnd,1);
			if(strReinstall.Compare(iscEnd,TEXT(",")))
				strReinstall.Remove(iseEnd,1);
			if(strAdvertise.Compare(iscEnd,TEXT(",")))
				strAdvertise.Remove(iseEnd,1);
			if(strAddLocal.TextSize())
			{
				strSelections += IPROPNAME_FEATUREADDLOCAL;
				strSelections += TEXT("=");
				strSelections += strAddLocal;
				strSelections += TEXT(" ");
			}
			if(strAddSource.TextSize())
			{
				strSelections += IPROPNAME_FEATUREADDSOURCE;
				strSelections += TEXT("=");
				strSelections += strAddSource;
				strSelections += TEXT(" ");
			}
			if(strRemove.TextSize())
			{
				strSelections += IPROPNAME_FEATUREREMOVE;
				strSelections += TEXT("=");
				strSelections += strRemove;
				strSelections += TEXT(" ");
			}
			if(strReinstall.TextSize())
			{
				strSelections += IPROPNAME_REINSTALL;
				strSelections += TEXT("=");
				strSelections += strReinstall;
				strSelections += TEXT(" ");
			}
			if(strAdvertise.TextSize())
			{
				strSelections += IPROPNAME_FEATUREADVERTISE;
				strSelections += TEXT("=");
				strSelections += strAdvertise;
			}
			if (!strSelections.TextSize())
			{
				// no properties were set, but we want to tell the server that to ensure it doesn't attempt to install anything
				// this is an undocumented property value used for communication between client and server
				strSelections += szFeatureSelection;
				strSelections += TEXT("=");
				strSelections += szFeatureDoNothingValue;
			}
		}

		strSelections.ReturnArg(rpistrSelections);
		fGrabbedFeatureProps = true;
	}

	if (ppistrFolders && pDirectoryCursor && pFeatureCursor)
	{
		MsiString strFolders, strFolder;
		pFeatureCursor->Reset();
		pFeatureCursor->SetFilter(iColumnBit(m_colFeatureConfigurableDir));
		// add locations of configurable folders - either ALL CAPS key names, or declared configurable
		// in Feature table
		while(pDirectoryCursor->Next())
		{
			MsiString strDirKey = pDirectoryCursor->GetString(m_colDirKey);
			Assert(strDirKey);
			Bool fConfigurableDir = fFalse;
			// check if a feature has marked this folder as configurable
			AssertNonZero(pFeatureCursor->PutString(m_colFeatureConfigurableDir,*strDirKey));
			if(pFeatureCursor->Next())
			{
				fConfigurableDir = fTrue;
			}
			pFeatureCursor->Reset();
			if(!fConfigurableDir)
			{
				// check if this directory key is all uppercase (can be set on command-line)
				MsiString strTemp = strDirKey;
				strTemp.UpperCase();
				if(strDirKey.Compare(iscExact,strTemp)) //!! is there a better way of doing this?
				{
					fConfigurableDir = fTrue;
				}
			}
			if(fConfigurableDir)
			{
				strFolders += strDirKey;
				strFolders += TEXT("=\"");
				strFolders += MsiString(GetProperty(*strDirKey));
				strFolders += TEXT("\" ");
			}
			// if root, add source property and value
			MsiString strSourceDir, strParentDir = pDirectoryCursor->GetString(m_colDirParent);
			if(strParentDir.TextSize() == 0 || strParentDir.Compare(iscExact,strDirKey))
			{
				strSourceDir = pDirectoryCursor->GetString(m_colDirSubPath);
				strFolders += strSourceDir;
				strFolders += TEXT("=\"");
				strFolders += MsiString(GetProperty(*strSourceDir));
				strFolders += TEXT("\" ");
			}
		}
		
		if(strFolders.Compare(iscEnd,TEXT(",")))
			strFolders.Remove(iseEnd,1);
		strFolders.ReturnArg(*ppistrFolders);
	}

	Assert(m_piPropertyCursor);
	
	// use new cursor - m_piPropertyCursor used within FormatLog
	PMsiTable  pPropertyTable  = &m_piPropertyCursor->GetTable();
	PMsiCursor pPropertyCursor = pPropertyTable->CreateCursor(fFalse);
	PMsiTable  pStaticPropertyTable(0);
	PMsiCursor pStaticPropertyCursor(0);

	PMsiDatabase pDatabase = GetDatabase();
	AssertRecord(pDatabase->LoadTable(*MsiString(*sztblProperty), 0, *&pStaticPropertyTable));
	if (pStaticPropertyTable)
	{
		pStaticPropertyCursor = pStaticPropertyTable->CreateCursor(fFalse);
		pStaticPropertyCursor->SetFilter(iColumnBit(1));
	}

	MsiStringId rgPropertiesToSkip[g_cFeatureProperties + 2]; // feature properties + 2 database properties
	unsigned int cPropertiesToSkip = 2;
	rgPropertiesToSkip[0] = pDatabase->EncodeStringSz(IPROPNAME_DATABASE);
	rgPropertiesToSkip[1] = pDatabase->EncodeStringSz(IPROPNAME_ORIGINALDATABASE);

	if(fGrabbedFeatureProps) // if we got the feature properties above, skip them here
	{
		for(int i = 0; i < g_cFeatureProperties; i++)
		{
			rgPropertiesToSkip[cPropertiesToSkip] = pDatabase->EncodeStringSz(g_rgFeatures[i].szFeatureActionProperty);
			if (rgPropertiesToSkip[cPropertiesToSkip])
				cPropertiesToSkip++;
		}
	}

	MsiString strPropertyList;
	MsiString strLoggedPropertyList;
	MsiString strHiddenProperties;
	MsiString strStars(IPROPVALUE_HIDDEN_PROPERTY);
	PMsiTable pControlTable(0);
	if ( ppistrLoggedProperties )
	{
		strHiddenProperties = GetPropertyFromSz(IPROPNAME_HIDDEN_PROPERTIES);
		PMsiRecord pError(pDatabase->LoadTable(*MsiString(*sztblControl), 0, *&pControlTable));
	}
	while (pPropertyCursor->Next())
	{
		MsiStringId iProperty = pPropertyCursor->GetInteger(1);

		for (int i = 0; (i < cPropertiesToSkip) && (iProperty != rgPropertiesToSkip[i]); i++)
			;

		if (i != cPropertiesToSkip)
			continue;

		MsiString strProperty = pDatabase->DecodeString(iProperty);
		if(strProperty.TextSize() == 0)
		{
			AssertSz(0, TEXT("NULL property name in GetCurrentSelectState."));
			continue;
		}
		
		const ICHAR* pch = strProperty;

		while (*pch && !WIN::IsCharLower(*pch))
			pch++;

		if (!*pch)
		{
			MsiString strPropertyValue = pPropertyCursor->GetString(2);
			if (pStaticPropertyCursor)
			{
				pStaticPropertyCursor->PutString(1, *strProperty);
				if (pStaticPropertyCursor->Next())
				{
					MsiString strStaticValue = pStaticPropertyCursor->GetString(2);
					pStaticPropertyCursor->Reset();

					if (strStaticValue.Compare(iscExact, strPropertyValue)) // don't bother passing values that haven't changed
						continue;
				}
			}
			
			MsiString strEscapedPropertyValue;
			while (strPropertyValue.TextSize()) // Escape quotes. Change all instances of " to ""
			{
				MsiString strSegment = strPropertyValue.Extract(iseIncluding, '\"');
				strEscapedPropertyValue += strSegment;
				if (!strPropertyValue.Remove(iseIncluding, '\"'))
					break;
				strEscapedPropertyValue += TEXT("\"");
			}

			//!! handle embedding quotes
			strPropertyList += strProperty;
			strPropertyList += *TEXT("=\"");
			strPropertyList += strEscapedPropertyValue;
			strPropertyList += *TEXT("\" ");
			if ( ppistrLoggedProperties )
			{
				strLoggedPropertyList += strProperty;
				if ( IsPropertyHidden(strProperty, strHiddenProperties,
											 pControlTable, *pDatabase, NULL) )
				{
					strLoggedPropertyList += *TEXT("=");
					strLoggedPropertyList += strStars;
					strLoggedPropertyList += *TEXT(" ");
				}
				else
				{
					strLoggedPropertyList += *TEXT("=\"");
					strLoggedPropertyList += strEscapedPropertyValue;
					strLoggedPropertyList += *TEXT("\" ");
				}
			}
		}
	}

	// Now look for public properties that exists in the static property table but
	// not in the dynamic table. We'll have to pass those across as
	// PROPERTY="".

	if (pStaticPropertyCursor)
	{
		pStaticPropertyCursor->Reset();
		pStaticPropertyCursor->SetFilter(0);

		pPropertyCursor->Reset();
		pPropertyCursor->SetFilter(iColumnBit(1));

		while (pStaticPropertyCursor->Next())
		{
			MsiString strStaticProperty = pStaticPropertyCursor->GetString(1);
			
			const ICHAR* pch = strStaticProperty;

			while (*pch && !WIN::IsCharLower(*pch))
				pch++;

			if (!*pch)
			{
				pPropertyCursor->PutString(1, *strStaticProperty);
				if (!pPropertyCursor->Next())
				{
					strPropertyList += strStaticProperty;
					strPropertyList += *TEXT("=\"\" ");
					if ( ppistrLoggedProperties )
					{
						strLoggedPropertyList += strStaticProperty;
						if ( IsPropertyHidden(strStaticProperty, strHiddenProperties,
													 pControlTable, *pDatabase, NULL) )
						{
							strLoggedPropertyList += *TEXT("=");
							strLoggedPropertyList += strStars;
							strLoggedPropertyList += *TEXT(" ");
						}
						else
							strLoggedPropertyList += *TEXT("=\"\" ");
					}
				}
			}
		}
	}

	strPropertyList.ReturnArg(rpistrProperties);
	if ( ppistrLoggedProperties )
		strLoggedPropertyList.ReturnArg(*ppistrLoggedProperties);

	return 0;
}

bool CMsiEngine::WriteExecuteScriptRecord(ixoEnum ixoOpCode, IMsiRecord& riParams)
{
	return WriteScriptRecord(m_pExecuteScript, ixoOpCode, riParams, false, *this);
}

bool CMsiEngine::WriteSaveScriptRecord(ixoEnum ixoOpCode, IMsiRecord& riParams)
{
	return WriteScriptRecord(m_pSaveScript, ixoOpCode, riParams, false, *this);
}


iesEnum CMsiEngine::ExecuteRecord(ixoEnum ixoOpCode, IMsiRecord& riParams)
{
	iesEnum iesRet = iesSuccess;
	PMsiRecord pError(0);

	if(!m_fServerLocked)
	{
		pError = PostError(Imsg(idbgErrorWritingScriptRecord));
		return FatalError(*pError);
	}

	g_MessageContext.SuppressTimeout();  // keep from timing out for lengthy actions (such as an obscene number of reg keys)

	Assert(m_issSegment == issScriptGeneration);

	if (m_fMergingScriptWithParent)
	{
		if (!(m_fMode & iefOperations))  // if first script record, output new product info
		{
			SetMode(iefOperations, fTrue);
			PMsiRecord pProductInfo(0);
			if((iesRet = CreateProductInfoRec(*&pProductInfo)) != iesSuccess)
				return iesRet;
			if((iesRet = m_piParentEngine->ExecuteRecord(ixoProductInfo, *pProductInfo)) != iesSuccess)
				return iesRet;
		}
		return m_piParentEngine->ExecuteRecord(ixoOpCode, riParams); // merge with main script
	}

	if(ixoOpCode == ixoActionStart && m_fInExecuteRecord == fFalse)
	{
		// should never do this in normal course of operation
		// but the ability to pass ixoActionStart to ExecuteRecord is needed for automation testing
		m_pCachedActionStart = &m_riServices.CreateRecord(3);
		AssertNonZero(m_pCachedActionStart->SetMsiString(1,*MsiString(riParams.GetMsiString(1))));
		AssertNonZero(m_pCachedActionStart->SetMsiString(2,*MsiString(riParams.GetMsiString(2))));
		AssertNonZero(m_pCachedActionStart->SetMsiString(3,*MsiString(riParams.GetMsiString(3))));
		return iesSuccess;
	}

	if(m_fExecutedActionStart == fFalse && m_fInExecuteRecord == fFalse && m_pCachedActionStart)
	{
		// need to dispatch cached ActionStart operation before this one
		Assert(ixoOpCode != ixoActionStart);
		m_fInExecuteRecord = fTrue;   // call recursively
		iesRet = ExecuteRecord(::ixoActionStart, *m_pCachedActionStart);
		m_fInExecuteRecord = fFalse;
		m_fExecutedActionStart = fTrue;
		if(iesRet != iesSuccess)
			return iesRet;
	}

	if(!(GetMode() & iefOperations))
	{
		// haven't start spooling or executing script operations yet
		// execute initialization ops and initialize script if applicable

		// determine execution mode - default is ixmScript
		MsiString strExecuteMode(GetPropertyFromSz(IPROPNAME_EXECUTEMODE));
		if(strExecuteMode.TextSize())
		{
			switch(((const ICHAR*)strExecuteMode)[0] & 0xDF)
			{
			case TEXT('S'): m_ixmExecuteMode = ixmScript; break;
			case TEXT('N'): m_ixmExecuteMode = ixmNone;   break;
			};
		}

		// set script file name - this script file isn't used for execution, only for saving all operations
		if(m_pistrSaveScript)
			m_pistrSaveScript->Release();
		m_pistrSaveScript = &GetPropertyFromSz(IPROPNAME_SCRIPTFILE);

		SetMode(iefOperations, fTrue);
		m_iProgressTotal = 0;

		// setup ixoProductInfo record
		PMsiRecord pProductInfo(0);
		if((iesRet = CreateProductInfoRec(*&pProductInfo)) != iesSuccess)
			return iesRet;

		// setup ixoDialogInfo records
		PMsiRecord pDialogLangIdInfo = &m_riServices.CreateRecord(IxoDialogInfo::Args + 1);
		AssertNonZero(pDialogLangIdInfo->SetInteger(IxoDialogInfo::Type, icmtLangId));
		AssertNonZero(pDialogLangIdInfo->SetInteger(IxoDialogInfo::Argument, m_iLangId));
		AssertNonZero(pDialogLangIdInfo->SetInteger(IxoDialogInfo::Argument + 1, m_piDatabase->GetANSICodePage()));
		
		PMsiRecord pDialogCaptionInfo(0);
		if (m_rgpiMessageHeader[imsgDialogCaption])
		{
			pDialogCaptionInfo = &m_riServices.CreateRecord(IxoDialogInfo::Args);
			AssertNonZero(pDialogCaptionInfo->SetInteger(IxoDialogInfo::Type, icmtCaption));
			AssertNonZero(pDialogCaptionInfo->SetMsiString(IxoDialogInfo::Argument,
																		  *MsiString(FormatText(*m_rgpiMessageHeader[imsgDialogCaption]))));
		}

		// setup ixoRollbackInfo record
		PMsiRecord pRollbackInfo = &m_riServices.CreateRecord(IxoRollbackInfo::Args);
		MsiString strDescription, strTemplate;
		AssertNonZero(pRollbackInfo->SetString(IxoRollbackInfo::RollbackAction,TEXT("Rollback")));
		if(GetActionText(TEXT("Rollback"), *&strDescription, *&strTemplate))
		{
			AssertNonZero(pRollbackInfo->SetMsiString(IxoRollbackInfo::RollbackDescription,*strDescription));
			AssertNonZero(pRollbackInfo->SetMsiString(IxoRollbackInfo::RollbackTemplate,*strTemplate));
		}
		AssertNonZero(pRollbackInfo->SetString(IxoRollbackInfo::CleanupAction,TEXT("RollbackCleanup")));
		if(GetActionText(TEXT("RollbackCleanup"), *&strDescription, *&strTemplate))
		{
			AssertNonZero(pRollbackInfo->SetMsiString(IxoRollbackInfo::CleanupDescription,*strDescription));
			AssertNonZero(pRollbackInfo->SetMsiString(IxoRollbackInfo::CleanupTemplate,*strTemplate));
		}
		
		MsiString strIsPostAdmin = GetPropertyFromSz(IPROPNAME_ISADMINPACKAGE);
		istEnum istScriptType;
		if (m_fMode & iefAdvertise)
			istScriptType = istAdvertise;
		else if (strIsPostAdmin.TextSize())
			istScriptType = istPostAdminInstall;
		else if (m_fMode & iefAdmin)
			istScriptType = istAdminInstall;
		else
			istScriptType = istInstall;

		PMsiStream pStream(0);
		if(m_ixmExecuteMode == ixmScript)
		{
			// need to open execute script and dispatch initialization ops
			Assert(m_scmScriptMode != scmWriteScript);

			// open execute script
			AssertSz(m_pExecuteScript == 0,"Script still open");
			AssertSz(m_pistrExecuteScript == 0,"Execute script name not released");
			if(m_pistrExecuteScript)
			{
				m_pistrExecuteScript->Release();
				m_pistrExecuteScript = 0;
			}
			// generate name for execute script
			{
				CElevate elevate;
				ICHAR rgchPath[MAX_PATH];

				HANDLE hTempFile = OpenSecuredTempFile(false, rgchPath);
				if (INVALID_HANDLE_VALUE == hTempFile)
				{
					pError = PostError(Imsg(imsgErrorCreatingTempFileName),GetLastError(),rgchPath);
					return FatalError(*pError);
				}
				else
					WIN::CloseHandle(hTempFile);

				// file still exists, but it is now secured.
				MsiString strTemp(rgchPath);
				m_pistrExecuteScript = strTemp;
				m_pistrExecuteScript->AddRef();

				// create execute script
				pError = m_riServices.CreateFileStream(m_pistrExecuteScript->GetString(),
																	fTrue, *&pStream);
				if (pError)
				{
					Message(imtError, *pError);  //!! check imsg code, allow retry?
					return iesFailure;
				}
			}

			DWORD dwScriptAttributes = m_fRunScriptElevated ? isaElevate : isaEnum(0);

			// if the TS registry is being used (per-machine TS install), mark this fact
			// in the script headers to ensure rollback after a suspended install
			// correctly remaps the keys.
			if (IsTerminalServerInstalled() && MinimumPlatformWindows2000() && !(GetMode() & (iefAdmin | iefAdvertise)) &&
				MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize())
			{
				dwScriptAttributes |= isaUseTSRegistry;
			}

			m_pExecuteScript = new CScriptGenerate(*pStream, m_iLangId, GetCurrentDateTime(),
				istScriptType, static_cast<isaEnum>(dwScriptAttributes), m_riServices);
			if (!m_pExecuteScript)
				return iesFailure; //!! need bad command line msg

			AssertSz(m_wPackagePlatform == PROCESSOR_ARCHITECTURE_ALPHA ||
						m_wPackagePlatform == PROCESSOR_ARCHITECTURE_INTEL ||
						m_wPackagePlatform == PROCESSOR_ARCHITECTURE_IA64  ||
						m_wPackagePlatform == PROCESSOR_ARCHITECTURE_ALPHA64,
						TEXT("Invalid platform!"));
			while (m_pExecuteScript->InitializeScript(m_wPackagePlatform) == false)
			{
				if (PostScriptWriteError(*this) == fFalse)
					return iesFailure;
			}
			// write init ops
			Assert(pProductInfo && pRollbackInfo); // should always be set
			if(pProductInfo && !WriteExecuteScriptRecord(ixoProductInfo, *pProductInfo))
				return iesFailure;
			if(pDialogLangIdInfo && !WriteExecuteScriptRecord(ixoDialogInfo, *pDialogLangIdInfo))
				return iesFailure;
			if(pDialogCaptionInfo && !WriteExecuteScriptRecord(ixoDialogInfo, *pDialogCaptionInfo))
				return iesFailure;
			if(pRollbackInfo &&!WriteExecuteScriptRecord(ixoRollbackInfo, *pRollbackInfo))
				return iesFailure;
		}

		if(m_pistrSaveScript && m_pistrSaveScript->TextSize())
		{
			// create saved script if it hasn't been opened yet
			if(m_pSaveScript == 0)
			{
				// haven't opened saved script yet
				// ensure that m_pistrSaveScript is full path to file
				Assert(m_scmScriptMode != scmWriteScript);
				CAPITempBuffer<ICHAR,MAX_PATH> rgchScriptPath;
				AssertNonZero(ExpandPath(m_pistrSaveScript->GetString(),rgchScriptPath));
				m_pistrSaveScript->SetString(rgchScriptPath, m_pistrSaveScript);
				AssertNonZero(SetProperty(*MsiString(*IPROPNAME_SCRIPTFILE), *m_pistrSaveScript));
				pError = m_riServices.CreateFileStream(m_pistrSaveScript->GetString(),
																	fTrue, *&pStream);
				if (pError)
				{
					Message(imtError, *pError);  //!! check imsg code, allow retry?
					return iesFailure;
				}
				
				// don't set isaElevate flag in saved scripts - they can only be run in-proc anyway, so
				// this is just by convention
				m_pSaveScript = new CScriptGenerate(*pStream, m_iLangId, GetCurrentDateTime(),
																istScriptType, isaEnum(0), m_riServices);
				if (!m_pSaveScript)
					return iesFailure; //!! need bad command line msg

				AssertSz(m_wPackagePlatform == PROCESSOR_ARCHITECTURE_ALPHA ||
							m_wPackagePlatform == PROCESSOR_ARCHITECTURE_INTEL ||
							m_wPackagePlatform == PROCESSOR_ARCHITECTURE_IA64  ||
							m_wPackagePlatform == PROCESSOR_ARCHITECTURE_ALPHA64,
							TEXT("Invalid platform!"));
				while (m_pSaveScript->InitializeScript(m_wPackagePlatform) == false)
				{
					if (PostScriptWriteError(*this) == fFalse)
						return iesFailure;
				}
				Assert(pProductInfo && pRollbackInfo); // should always be set
				if(pProductInfo && !WriteSaveScriptRecord(ixoProductInfo, *pProductInfo))
					return iesFailure;
				if(pDialogLangIdInfo && !WriteSaveScriptRecord(ixoDialogInfo, *pDialogLangIdInfo))
					return iesFailure;
				if(pDialogCaptionInfo && !WriteSaveScriptRecord(ixoDialogInfo, *pDialogCaptionInfo))
					return iesFailure;
				if(pRollbackInfo && !WriteSaveScriptRecord(ixoRollbackInfo, *pRollbackInfo))
					return iesFailure;
			}
		}
	}

	// execute or spool operation - may need to do both if direct mode and saving a script
	if(m_pExecuteScript || m_pSaveScript)
	{
		if(m_scmScriptMode != scmWriteScript)
		{
			// need to start up GenerateScript action
			m_scmScriptMode = scmWriteScript;
			PMsiRecord pGenerateScriptRec = &m_riServices.CreateRecord(3);
			MsiString strDescription, strTemplate;
			AssertNonZero(pGenerateScriptRec->SetString(1, TEXT("GenerateScript")));
			if(GetActionText(TEXT("GenerateScript"), *&strDescription, *&strTemplate))
			{
				AssertNonZero(pGenerateScriptRec->SetMsiString(2, *strDescription));
				AssertNonZero(pGenerateScriptRec->SetMsiString(3, *strTemplate));
			}
			m_fInExecuteRecord = fTrue;
			if(Message(imtActionStart, *pGenerateScriptRec) == imsCancel)
				return iesUserExit;
			m_fInExecuteRecord = fFalse;
			m_fDispatchedActionStart = fFalse; // action needs to re-send action start with a progress message
		}

		if (ixoOpCode == ixoProgressTotal)
		{
			int iTotalEvents = riParams.GetInteger(IxoProgressTotal::Total);
			int iByteEquivalent = riParams.GetInteger(IxoProgressTotal::ByteEquivalent);
			m_iProgressTotal += iTotalEvents * iByteEquivalent;
		}

		if(ixoOpCode == ixoActionStart)
		{
			// log ActionStart as ActionData for GenerateScript action
			PMsiRecord pActionData = &m_riServices.CreateRecord(1);
			MsiString strDescription = riParams.GetMsiString(2);
			if(strDescription.TextSize())
				AssertNonZero(pActionData->SetMsiString(1, *strDescription));
			else
				AssertNonZero(pActionData->SetMsiString(1, *MsiString(riParams.GetMsiString(1))));
			m_fInExecuteRecord = fTrue;
			if (Message(imtActionData, *pActionData) == imsCancel)
				return iesUserExit;
			m_fInExecuteRecord = fFalse;
		}

		if (m_pScriptProgressRec)
		{
			using namespace ProgressData;
			AssertNonZero(m_pScriptProgressRec->SetInteger(imdSubclass, iscProgressReport));
			AssertNonZero(m_pScriptProgressRec->SetInteger(imdIncrement, 1));
			if(Message(imtProgress, *m_pScriptProgressRec) == imsCancel)
				return iesUserExit;
		}

		if(m_pExecuteScript && !WriteExecuteScriptRecord(ixoOpCode, riParams))
			return iesFailure;
		if(m_pSaveScript && !WriteSaveScriptRecord(ixoOpCode, riParams))
			return iesFailure;
	}

	return iesSuccess;
}


void CMsiEngine::ReportToEventLog(WORD wEventType, int iEventLogTemplate, IMsiRecord& riRecord)
{
		MsiString strMessage = riRecord.FormatText(fTrue);
		PMsiRecord pLogRecord = &CreateRecord(3);
		AssertNonZero(pLogRecord->SetMsiString(0, *MsiString(GetErrorTableString(imsgEventLogTemplate))));
		AssertNonZero(pLogRecord->SetMsiString(2, *MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTNAME))));
		AssertNonZero(pLogRecord->SetMsiString(3, *strMessage));
		MsiString strLog = pLogRecord->FormatText(fFalse);
		DEBUGMSGE(wEventType, iEventLogTemplate, strLog);
}

iesEnum CMsiEngine::FatalError(IMsiRecord& riRecord)
{
	if (riRecord.GetInteger(1) == imsgUser)
	{
		return iesUserExit;
	}
	else
	{
		Message(imtEnum(imtError | imtSendToEventLog), riRecord); // should only be called with no user options
		m_fResultEventLogged = fTrue;
		return iesFailure;            // record released by caller
	}
}


void CMsiEngine::SetMode(int fMask, Bool fMode)
{
	if (fMode)
		m_fMode |= fMask;
	else
		m_fMode &= ~fMask;
}

int CMsiEngine::GetMode()
{
	return m_fMode;
}

const IMsiString& CMsiEngine::FormatText(const IMsiString& riTextString)
{
	return ::FormatText(riTextString,fFalse,fFalse,CMsiEngine::FormatTextCallback,(IUnknown*)(IMsiEngine*)this);
}

// following fns are called with special callback that looks at the requested state for a component
// if the action state is null
const IMsiString& FormatTextEx(const IMsiString& riTextString, IMsiEngine& riEngine, bool fUseRequestedComponentState)
{
	if(fUseRequestedComponentState)
		return ::FormatText(riTextString,fFalse,fFalse,CMsiEngine::FormatTextCallbackEx,(IUnknown*)&riEngine);
	else
		return ::FormatText(riTextString,fFalse,fFalse,CMsiEngine::FormatTextCallback,(IUnknown*)&riEngine);
}

const IMsiString& FormatTextSFN(const IMsiString& riTextString, IMsiEngine& riEngine, int rgiSFNPos[][2], int& riSFNPos, bool fUseRequestedComponentState)
{
	riSFNPos = 0;
	if(fUseRequestedComponentState)
		return ::FormatText(riTextString,fFalse,fFalse,CMsiEngine::FormatTextCallbackEx,(IUnknown*)&riEngine, rgiSFNPos, &riSFNPos);
	else
		return ::FormatText(riTextString,fFalse,fFalse,CMsiEngine::FormatTextCallback,(IUnknown*)&riEngine, rgiSFNPos, &riSFNPos);

}


int CMsiEngine::FormatTextCallback(const ICHAR *pch, int cch, CTempBufferRef<ICHAR>&rgchOut,
																 Bool& fPropMissing,
																 Bool& fPropUnresolved,
																 Bool& fSFN,
																 IUnknown* piContext)
{
	return FormatTextCallbackCore(pch, cch, rgchOut, fPropMissing, fPropUnresolved, fSFN, piContext, false);
}

int CMsiEngine::FormatTextCallbackEx(const ICHAR *pch, int cch, CTempBufferRef<ICHAR>&rgchOut,
																 Bool& fPropMissing,
																 Bool& fPropUnresolved,
																 Bool& fSFN,
																 IUnknown* piContext)
{
	return FormatTextCallbackCore(pch, cch, rgchOut, fPropMissing, fPropUnresolved, fSFN, piContext, true);
}

// Queries used in FormatTextCallbackCore
static const ICHAR* szSqlDirectoryQuery =       TEXT("SELECT `Directory_`, `Action`, `ActionRequest` FROM ")
											TEXT("`Component` WHERE ")
											TEXT("`Component` = ?");

int CMsiEngine::FormatTextCallbackCore(const ICHAR *pch, int cch, CTempBufferRef<ICHAR>&rgchOut,
																 Bool& fPropMissing,
																 Bool& fPropUnresolved,
																 Bool& fSFN,
																 IUnknown* piContext,
																 bool fUseRequestedComponentState)
{
	CTempBuffer<ICHAR, 20> rgchString;
	// 1 for the null
	rgchString.SetSize(cch+1);
	if ( ! (ICHAR *) rgchString )
		return 0;
	memcpy(rgchString, pch, cch * sizeof(ICHAR));
	rgchString[cch] = 0;
	rgchOut[0] = 0;
	int iField = GetIntegerValue(rgchString, 0);  // check if integer value
	if (iField >= 0)  // positive integer, leave for record formatting
	{
		rgchOut.SetSize(cch + 3);
		if ( ! (ICHAR *) rgchOut )
			return 0;
		memcpy(&rgchOut[1], &rgchString[0], cch * sizeof(ICHAR));
		rgchOut[0] = TEXT('[');
		rgchOut[cch + 1] = TEXT(']');
		rgchOut[cch + 2] = 0;
		fPropUnresolved = fTrue;
		return cch + 2;
	}
	CMsiEngine* piEngine = (CMsiEngine*)(IMsiEngine*)piContext;

	MsiString istrOut((ICHAR *)rgchString);
	fPropUnresolved = fFalse;
	ICHAR chFirst = *(const ICHAR*)istrOut;
	if (chFirst == TEXT('\\')) // we have an escaped character
	{
		if (istrOut.TextSize() > 1)
		{
			istrOut.Remove(iseFirst, 1);
			istrOut.Remove(iseLast, istrOut.CharacterCount() - 1);
		}
		else
		{
			return 0;
		}
	}
	else if (chFirst == ichFileTablePrefix || chFirst == ichFileTablePrefixSFN) // we have File table key
	{
		MsiString strFile = istrOut.Extract(iseLast,istrOut.CharacterCount()-1);
		PMsiRecord pError(0);

		if ((!piEngine->m_fSourceResolved && piEngine->m_fSourceResolutionAttempted) ||
			(pError = piEngine->GetFileInstalledLocation(*strFile,*&istrOut, fUseRequestedComponentState, &(piEngine->m_fSourceResolutionAttempted))))
		{
			fPropMissing = fTrue;
			return 0;
		}

		if(chFirst == ichFileTablePrefixSFN)
			fSFN = fTrue;
	}
	else if (chFirst == ichComponentPath) // we have Component table key
	{
		PMsiServices pServices = piEngine->GetServices();
		PMsiDatabase pDatabase = piEngine->GetDatabase();
		
		PMsiDirectoryManager pDirectoryManager(*(IMsiEngine*)piEngine, IID_IMsiDirectoryManager);
		istrOut.Remove(iseFirst, 1);
		ICHAR* Buffer = 0; // avoid warning

		PMsiView piView(0);
		PMsiRecord pError(pDatabase->OpenView(szSqlDirectoryQuery, ivcFetch, *&piView));
		Assert(pError == 0);
		if(pError)
		{
			fPropMissing = fTrue;
			return 0;
		}
		PMsiRecord piRec (&pServices->CreateRecord(1));
		piRec->SetMsiString(1, *istrOut);
		pError = piView->Execute(piRec);
		Assert(pError == 0);
		if(pError)
		{
			fPropMissing = fTrue;
			return 0;
		}
		piRec = piView->Fetch();
		if(piRec == 0)
		{
			fPropMissing = fTrue;
			return 0;
		}
		enum iftFileInfo{
			iftDirectory=1,
			iftAction,
			iftActionRequest,
		};
		PMsiPath piPath(0);
		int iAction = piRec->GetInteger(iftAction);
		if(iAction == iMsiNullInteger && fUseRequestedComponentState)
			iAction = piRec->GetInteger(iftActionRequest);
		if((iAction == iisAbsent)||(iAction == iMsiNullInteger))
		{
			fPropMissing = fTrue;
			return 0;
		}
		else if(iAction == iisSource)
		{
			if (piEngine->m_fSourceResolved || !piEngine->m_fSourceResolutionAttempted)
			{
				pError = pDirectoryManager->GetSourcePath(*MsiString(piRec->GetMsiString(iftDirectory)),
										*&piPath);

				piEngine->m_fSourceResolutionAttempted = true;
			}
			else
			{
				fPropMissing = fTrue;
				return 0;
			}
		}
		else
		{
			pError = pDirectoryManager->GetTargetPath(*MsiString(piRec->GetMsiString(iftDirectory)),
									*&piPath);
		}
		if(pError)
		{
			fPropMissing = fTrue;
			return 0;
		}

		istrOut = piPath->GetPath();
		//?? do we drop the last "\"
		if(pError)
		{
			fPropMissing = fTrue;
			return 0;
		}
	}
	else if ((chFirst == ichNullChar) && (cch == 1))// we have null character
	{
		istrOut = MsiString(MsiChar(0));
	}
	else // we have to evaluate a property
	{
		istrOut = piEngine->GetProperty(*istrOut);
		if (istrOut.TextSize() == 0) // property is undefined
			fPropMissing = fTrue;
	}

	rgchOut.SetSize((cch = istrOut.TextSize()) + 1);
	if ( ! (ICHAR *) rgchOut )
		return 0;
	memcpy(rgchOut, (const ICHAR *)istrOut, (cch + 1) * sizeof(ICHAR));
	return cch;
}

IMsiRecord* CMsiEngine::OpenView(const ICHAR* szSql, ivcEnum ivcIntent,
												IMsiView*& rpiView)
{
	if(!m_piDatabase)
		return PostError(Imsg(idbgEngineNotInitialized));
	return m_piDatabase->OpenView(szSql, ivcIntent, rpiView);
}

//!! This function is only used in one place -- to determine the SOURCEDIR
//!! Resolving the SOURCEDIR relative to the database path is no longer
//!! the right thing to do. We'll be OK for now because the SOURCEDIR
//!! is fully specified by Engine::DoInitialize. In Beta 2, however,
//!! when the SourceList spec is implemented we should probably eliminate
//!! this function.
Bool CMsiEngine::ResolveFolderProperty(const IMsiString& riPropertyString)
{
	MsiString istrPropValue = GetProperty(riPropertyString);
	if(PathType(istrPropValue) == iptFull)
		return fTrue;
	MsiString istrPath = GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE);
	Assert(PathType(istrPath) == iptFull);
	
	PMsiPath pPath(0);
	MsiString strFileName;
	AssertRecord(m_riServices.CreateFilePath(istrPath, *&pPath, *&strFileName));

	istrPath.Remove(iseLast,strFileName.CharacterCount());
	istrPath += istrPropValue;

	SetProperty(riPropertyString, *istrPath);
	return (istrPath.TextSize() == 0) ? fFalse : fTrue;
}

//____________________________________________________________________________
//
// Condition evaluator implementation
//____________________________________________________________________________

// table for parsing identifiers

const int rgiIdentifierValidChar[8] =
{
	0x00000000,
	0x03ff4000, // digits, period
	0x87fffffe, // upper case letters, underscore
	0x07fffffe, // lower case letters
	0x00000000, 0x00000000, 0x00000000, 0x00000000  // extended chars
};

inline int IsValidIdentifierChar(ICHAR ch) // return non-zero if valid
{
  return (rgiIdentifierValidChar[(char)ch/32] & (1 << ch % 32));
}

const int ivchNumber     = 1;
const int ivchProperty   = 4;  // can't begin with a digit
const int ivchComponent  = 8;
const int ivchFeature    = 16;
const int ivchEnvir      = 32;
const int ivchOperator   = 0;
const int ivchAnyIdentifier = ivchProperty + ivchComponent + ivchFeature + ivchEnvir;

enum tokEnum  // token parsed by Lex, operators from low to high precedence
{
	tokEos,         // end of string
	tokRightPar, // right parenthesis
	tokImp,
	tokEqv,
	tokXor,
	tokOr,
	tokAnd,
	tokNot,  // unaray, between logical and comparison ops
	tokEQ, tokNE, tokGT, tokLT, tokGE, tokLE, tokLeft, tokMid, tokRight,
	tokValue,
	tokLeftPar,  // left parenthesis
	tokError,
};

struct CMsiParser   // non-recursive Lex state structure
{
	CMsiParser(IMsiEngine& riEngine, const ICHAR* szExpression);
  ~CMsiParser();
	tokEnum Lex();
	void UnLex();   // cache current token for next Lex call
	iecEnum Evaluate(tokEnum tokPrecedence);  // recursive evaluator
 private: // result of Lex()
	tokEnum   m_tok;       // current token type
	iscEnum   m_iscMode;   // string compare mode flags
	MsiString m_istrToken; // string value of token if tok==tokValue
	int       m_iToken;    // integer value if obtainable, else iMsiNullInteger
 private: // to Lex
	int           m_iParenthesisLevel;
	const ICHAR*  m_pchInput;
	IMsiEngine&   m_riEngine;
	Bool          m_fAhead;
 private: // eliminate warning
	void operator =(const CMsiParser&){}
};
inline CMsiParser::CMsiParser(IMsiEngine& riEngine, const ICHAR* szExpression)
	: m_pchInput(szExpression), m_iParenthesisLevel(0), m_fAhead(fFalse),
	  m_tok(tokError), m_riEngine(riEngine) {}
inline CMsiParser::~CMsiParser() {}
inline void CMsiParser::UnLex() { Assert(m_fAhead==fFalse); m_fAhead = fTrue; }

iecEnum CMsiEngine::EvaluateCondition(const ICHAR* szCondition)

{
	if (szCondition == 0 || *szCondition == 0)
		return iecNone;
	CMsiParser Parser(*this, szCondition);
	iecEnum iecStat = Parser.Evaluate(tokEos);
	return iecStat;
}

// Lex next token for input stream
// sets m_tok to token type, and returns that value

tokEnum CMsiParser::Lex()
{
	if (m_fAhead || m_tok == tokEos)
	{
		m_fAhead = fFalse;
		return m_tok;
	}
	ICHAR ch;   // skip white space
	while ((ch = *m_pchInput) == TEXT(' ') || ch == TEXT('\t'))
		m_pchInput++;
	if (ch == 0)  // end of expression
		return (m_tok = tokEos);

	if (ch == TEXT('('))   // start of parenthesized expression
	{
		++m_pchInput;
		m_iParenthesisLevel++;
		return (m_tok = tokLeftPar);
	}
	if (ch == TEXT(')'))   // end of parenthesized expression
	{
		++m_pchInput;
		m_tok = tokRightPar;
		if (m_iParenthesisLevel-- == 0)
			m_tok = tokError;
		return m_tok;
	}
	if (ch == TEXT('"'))  // text literal
	{
		const ICHAR* pch = ++m_pchInput;
		Bool fDBCS = fFalse;
		while ((ch = *m_pchInput) != TEXT('"'))
		{
			if (ch == 0)
				return (m_tok = tokError);
#ifdef UNICODE
			m_pchInput++;
#else // !UNICODE
			const ICHAR* pchTemp = m_pchInput;
			m_pchInput = INextChar(m_pchInput);
			if (m_pchInput == pchTemp + 2)
				fDBCS = fTrue;
#endif // UNICODE
		}
		int cch = m_pchInput++ - pch;
		memcpy(m_istrToken.AllocateString(cch, fDBCS), pch, cch * sizeof(ICHAR));
		m_iToken = iMsiNullInteger; // prevent compare as an integer
	}
	else if (ch == TEXT('-') || ch >= TEXT('0') && ch <= TEXT('9'))  // integer
	{
		m_iToken = ch - TEXT('0');
		int chFirst = ch;  // save 1st char in case minus sign
		if (ch == TEXT('-'))
			m_iToken = iMsiNullInteger; // check for lone minus sign

		while ((ch = *(++m_pchInput)) >= TEXT('0') && ch <= TEXT('9'))
			m_iToken = m_iToken * 10 + ch - TEXT('0');
		if (m_iToken < 0)  // integer overflow or '-' witn no digits
			return (m_tok = tokError);
		if (chFirst == TEXT('-'))
			m_iToken = -m_iToken;
		m_istrToken = (const ICHAR*)0;
	}
	else if (ENG::IsValidIdentifierChar(ch) || ch == ichEnvirPrefix)
	{
		const ICHAR* pch = m_pchInput;
		do
			m_pchInput++;
		while (ENG::IsValidIdentifierChar(*m_pchInput));
		int cch = m_pchInput - pch;
		if (cch <= 3)  // check for text operators
		{
			switch((pch[0] | pch[1]<<8 | (cch==3 ? pch[2]<<16 : 0)) & 0xDFDFDF)
			{
			case 'O' | 'R'<<8:           return (m_tok = tokOr);
			case 'A' | 'N'<<8 | 'D'<<16: return (m_tok = tokAnd);
			case 'N' | 'O'<<8 | 'T'<<16: return (m_tok = tokNot);
			case 'X' | 'O'<<8 | 'R'<<16: return (m_tok = tokXor);
			case 'E' | 'Q'<<8 | 'V'<<16: return (m_tok = tokEqv);
			case 'I' | 'M'<<8 | 'P'<<16: return (m_tok = tokImp);
			};
		}
		memcpy(m_istrToken.AllocateString(cch, fFalse), pch, cch * sizeof(ICHAR));
		m_istrToken = m_riEngine.GetProperty(*m_istrToken);
		m_iToken = m_istrToken;
	}
	else if (ch == ichComponentAction || ch == ichComponentState
			|| ch == ichFeatureAction || ch == ichFeatureState)
	{
		m_iToken = iMsiNullInteger;
		const ICHAR* pch = ++m_pchInput;
		while (ENG::IsValidIdentifierChar(*m_pchInput))
			m_pchInput++;
		int cch = m_pchInput - pch;
		PMsiSelectionManager piSelMgr(0);
		m_riEngine.QueryInterface(IID_IMsiSelectionManager, (void**)&piSelMgr);
		PMsiTable pTable = (ch == ichComponentState || ch == ichComponentAction)
								? piSelMgr->GetComponentTable()
								: piSelMgr->GetFeatureTable();
		if (pTable != 0)   // component/feature table open
		{
			PMsiCursor pCursor = pTable->CreateCursor(fFalse);
			memcpy(m_istrToken.AllocateString(cch, fFalse), pch, cch * sizeof(ICHAR));
			pCursor->SetFilter(1);
			pCursor->PutString(1, *m_istrToken);
			PMsiDatabase pDatabase = m_riEngine.GetDatabase();
			const ICHAR* szColumn = NULL;
			switch(ch)
			{
			case ichComponentState:  szColumn = sztblComponent_colInstalled;     break;
			case ichComponentAction: szColumn = sztblComponent_colAction;        break;
			case ichFeatureState:    szColumn = sztblFeature_colInstalled;       break;
			case ichFeatureAction:   szColumn = sztblFeature_colAction;          break;
			}
			int iCol = pTable->GetColumnIndex(pDatabase->EncodeStringSz(szColumn));
			if (pCursor->Next() != 0)
			{
				//!! FIX IF/WHEN iisEnum fixed to track INSTALLSTATE -> m_iToken = pCursor->GetInteger(iCol);
				m_iToken = MapInternalInstallState(iisEnum(pCursor->GetInteger(iCol)));
			}
		}
		m_istrToken = (const ICHAR*)0;
	}
	else // check for operators
	{
		ICHAR ch1 = *m_pchInput++;
		if (ch1 == '~')  // prefix for string operators
		{
			m_iscMode = iscExactI;
			ch1 = *m_pchInput++;
		}
		else
			m_iscMode = iscExact;

		if (ch1 == '=')
			return (m_tok = tokEQ);

		ICHAR ch2 = *m_pchInput;
		if (ch1 == '<')
		{
			if (ch2 == '=')
			{
				m_tok = tokLE;
				m_pchInput++;
			}
			else if (ch2 == '>')
			{
				m_tok = tokNE;
				m_pchInput++;
			}
			else if (ch2 == '<')
			{
				m_tok = tokLeft;
				m_iscMode = (iscEnum)(m_iscMode | iscStart);
				m_pchInput++;
			}
			else
				m_tok = tokLT;
		}
		else if (ch1 == '>')
		{
			if (ch2 == '=')
			{
				m_tok = tokGE;
				m_pchInput++;
			}
			else if (ch2 == '>')
			{
				m_tok = tokRight;
				m_iscMode = (iscEnum)(m_iscMode | iscEnd);
				m_pchInput++;
			}
			else if (ch2 == '<')
			{
				m_tok = tokMid;
				m_iscMode = (iscEnum)(m_iscMode | iscWithin);
				m_pchInput++;
			}
			else
				m_tok = tokGT;
		}
		else
			m_tok = tokError;

		return m_tok;
	}
	return (m_tok = tokValue);
}

// evaluate expression up to operator of lower precedence

iecEnum CMsiParser::Evaluate(tokEnum tokPrecedence)
{
	iecEnum iecStat = iecTrue;
	if (Lex() == tokEos || m_tok == tokRightPar)
	{
		UnLex();  // put back ')' in case of "()"
		return iecNone;
	}
	if (m_tok == tokNot) // only unary op valid here
	{
		switch(Evaluate(m_tok))
		{
		case iecTrue:  iecStat = iecFalse; break;
		case iecFalse: break;
		default:       return iecError;
		};
	}
	else if (m_tok == tokLeftPar)
	{
		iecStat = Evaluate(tokRightPar);
		if (Lex() != tokRightPar) // parse off right parenthesis
			return iecError;
		if (iecStat == iecError || iecStat == iecNone)
			return iecStat;
	}
	else
	{
		if (m_tok != tokValue)
			return iecError;
		
		if (Lex() >= tokValue)  // get next operator (or end)
			return iecError;

		if (m_tok <= tokNot)  // logical op or end
		{
			UnLex();   // tokNot is not allowed, caught below
			if (m_istrToken.TextSize() == 0
			&& (m_iToken == iMsiNullInteger || m_iToken == 0))
				iecStat = iecFalse;
		}
		else // comparison op
		{
			MsiString istrLeft = m_istrToken;
			int iLeft = m_iToken;
			tokEnum tok = m_tok;
			iscEnum isc = m_iscMode;
			if (Lex() != tokValue)  // get right operand
				return iecError;
			int iRight = m_iToken;
			if (m_iToken == iMsiNullInteger || iLeft == iMsiNullInteger)
			{  // not an integer to integer compare
				if (iRight != iMsiNullInteger && m_istrToken.TextSize() == 0
				  || iLeft != iMsiNullInteger && istrLeft.TextSize() == 0)
				{   // integer to string, all tests false except <>
					if (tok != tokNE)
						iecStat = iecFalse;
				}
				else  // string to string compare
				{
					iRight = 0;
					if (isc == iscExact)
					{
						iLeft = IStrComp(istrLeft, m_istrToken);
					}
					else if (isc == iscExactI)
					{
						iLeft = IStrCompI(istrLeft, m_istrToken);
					}
					else
					{
						iLeft = istrLeft.Compare(isc, m_istrToken);
						tok = tokNE;
					}
				}
			}
			switch (tok)
			{
			case tokEQ:   if   (iLeft != iRight)  iecStat = iecFalse; break;
			case tokNE:   if   (iLeft == iRight)  iecStat = iecFalse; break;
			case tokGT:   if   (iLeft <= iRight)  iecStat = iecFalse; break;
			case tokLT:   if   (iLeft >= iRight)  iecStat = iecFalse; break;
			case tokGE:   if   (iLeft <  iRight)  iecStat = iecFalse; break;
			case tokLE:   if   (iLeft >  iRight)  iecStat = iecFalse; break;
			case tokMid:  if (!(iLeft &  iRight)) iecStat = iecFalse; break;
			case tokLeft: if  ((iLeft >> 16)    != iRight) iecStat = iecFalse; break;
			case tokRight:if  ((iLeft & 0xFFFF) != iRight) iecStat = iecFalse; break;
			default: Assert(0);
			};
		}
	}
	for(;;)
	{
		tokEnum tok = Lex();
		if (tok >= tokNot)  // disallow NOT without op, comparison of terms
			return iecError;

		if (tok <= tokPrecedence)  // stop at logical ops of <= precedence
		{
			UnLex();         // put back for next caller
			return iecStat;  // return what we have so far
		}
		iecEnum iecRight = Evaluate(tok);
		if (iecRight == iecNone || iecRight == iecError)
			return iecError;
		switch(tok)
		{
		case tokAnd: iecStat = iecEnum(iecStat & iecRight); break;
		case tokOr:  iecStat = iecEnum(iecStat | iecRight); break;
		case tokXor: iecStat = iecEnum(iecStat ^ iecRight); break;
		case tokEqv: iecStat = iecEnum(iecStat ^ 1 ^ iecRight); break;
		case tokImp: iecStat = iecEnum(iecStat ^ 1 | iecRight); break;
		default: Assert(0);
		};
	}
}

//____________________________________________________________________________
//
// Property handling implementation
//____________________________________________________________________________

Bool CMsiEngine::SetProperty(const IMsiString& riProperty, const IMsiString& riData)
{
	if (riProperty.GetString()[0] == ichEnvirPrefix) // environment variable
		return WIN::SetEnvironmentVariable(riProperty.GetString()+1, riData.GetString())
									? fTrue : fFalse;
	if (!m_piPropertyCursor)
		return fFalse;
	Bool fStat;
	m_piPropertyCursor->PutString(1, riProperty);
	if (riData.TextSize() == 0)
	{
		if (m_piPropertyCursor->Next())
			fStat = m_piPropertyCursor->Delete();
		else
			fStat = fTrue;
	}
	else
	{
		m_piPropertyCursor->PutString(2, riData);
		fStat = m_piPropertyCursor->Assign();  // either updates or inserts
	}
	m_piPropertyCursor->Reset();
	return fStat;
}

Bool CMsiEngine::SetPropertyInt(const IMsiString& riPropertyString, int iData)
{
	ICHAR buf[12];
	wsprintf(buf,TEXT("%i"),iData);
	return SetProperty(riPropertyString, *MsiString(buf));
}

const int cchEnvirBuffer = 1024;

const IMsiString& CMsiEngine::GetEnvironmentVariable(const ICHAR* szEnvVar)
{
	const IMsiString* pistr = &g_MsiStringNull;
	ICHAR rgchEnvirBuffer[cchEnvirBuffer];
	rgchEnvirBuffer[0] = 0;  // in case variable doesn't exist, needed?
	int cb = WIN::GetEnvironmentVariable(szEnvVar, rgchEnvirBuffer, cchEnvirBuffer);
	rgchEnvirBuffer[cchEnvirBuffer-1] = 0;  // terminate in case overflow
#ifdef _WIN64
	if ( g_Win64DualFolders.ShouldCheckFolders() )
	{
		ieSwappedFolder iRes;
		ICHAR szSubstitutePath[MAX_PATH+1];
		iRes = g_Win64DualFolders.SwapFolder(ie64to32,
														 rgchEnvirBuffer,
														 szSubstitutePath);
		if ( iRes == iesrSwapped )
		{
			if ( IStrLen(szSubstitutePath)+1 <= cchEnvirBuffer )
				IStrCopy(rgchEnvirBuffer, szSubstitutePath);
			else
				Assert(0);
		}
		else
			Assert(iRes != iesrError && iRes != iesrNotInitialized);
	}
#endif // _WIN64
	Assert (cb < cchEnvirBuffer);  // hard to have an environment vaiable > 1000 chars
	pistr->SetString(rgchEnvirBuffer, pistr);
	return *pistr;
}

const IMsiString& CMsiEngine::GetProperty(const IMsiString& riProperty)
{
	if (riProperty.GetString()[0] == ichEnvirPrefix) // environment variable
	{
		return GetEnvironmentVariable(riProperty.GetString()+1);
	}
	if (!m_piPropertyCursor)   // should never happen
	{
		Assert(0);
		riProperty.AddRef();
		return riProperty;
	}
	m_piPropertyCursor->PutString(1, riProperty);
	m_piPropertyCursor->Next();  // cursor reset if fails to find
	const IMsiString& riStr = m_piPropertyCursor->GetString(2);
	m_piPropertyCursor->Reset();
	return riStr;
}

const IMsiString& CMsiEngine::GetPropertyFromSz(const ICHAR* szProperty)
{
	if (szProperty[0] == ichEnvirPrefix) // environment variable
	{
		return GetEnvironmentVariable(&szProperty[1]);
	}
	if (!m_piPropertyCursor)   // should never happen
	{
		Assert(0);
		MsiString istr(szProperty);
		return istr.Return();
	}
	MsiStringId idProp;
	
	if (m_piDatabase == 0)
	{
		PMsiTable piTable(&m_piPropertyCursor->GetTable());
		PMsiDatabase piDatabase(&piTable->GetDatabase());
		idProp = piDatabase->EncodeStringSz(szProperty);
	}
	else
		idProp = m_piDatabase->EncodeStringSz(szProperty);
	if (idProp == 0)
		return g_MsiStringNull;
	m_piPropertyCursor->PutInteger(1, idProp);
	m_piPropertyCursor->Next();  // cursor reset if fails to find
	const IMsiString& riStr = m_piPropertyCursor->GetString(2);
	m_piPropertyCursor->Reset();
	return riStr;
}

int CMsiEngine::GetPropertyInt(const IMsiString& riProperty)
{
	const IMsiString& ristr = CMsiEngine::GetProperty(riProperty);
	int i = ristr.GetIntegerValue();
	ristr.Release();
	return i;
}

int CMsiEngine::GetPropertyLen(const IMsiString& riProperty)
{
	if (riProperty.GetString()[0] == ichEnvirPrefix) // environment variable
	{
		int cb = WIN::GetEnvironmentVariable(riProperty.GetString()+1, 0, 0);
		if (cb)
			cb--;
		return cb;
	}
	if (m_piPropertyCursor)
	{
		m_piPropertyCursor->PutString(1, riProperty);
		if (m_piPropertyCursor->Next())
		{
			MsiString istr(m_piPropertyCursor->GetString(2));
			m_piPropertyCursor->Reset();
			return istr.TextSize();
		}
	}
	return 0;
}

bool CMsiEngine::SafeSetProperty(const IMsiString& ristrProperty, const IMsiString& ristrData)
{
	if (ristrProperty.GetString()[0] == ichEnvirPrefix) // environment variable
		return CMsiEngine::SetProperty(ristrProperty, ristrData) ? true : false;
	Assert(m_piPropertyCursor);
	PMsiCursor pCursor = PMsiTable(&m_piPropertyCursor->GetTable())->CreateCursor(fFalse);
	pCursor->PutString(1, ristrProperty);
	if (ristrData.TextSize() == 0)
	{
		pCursor->SetFilter(1);
		return pCursor->Next() ? (pCursor->Delete() == fTrue) : true;
	}
	else
	{
		pCursor->PutString(2, ristrData);
		return pCursor->Assign() == fTrue;  // either updates or inserts
	}
}

const IMsiString& CMsiEngine::SafeGetProperty(const IMsiString& ristrProperty)
{
	if (ristrProperty.GetString()[0] == ichEnvirPrefix) // environment variable
		return CMsiEngine::GetProperty(ristrProperty);
	Assert(m_piPropertyCursor);
	PMsiCursor pCursor = PMsiTable(&m_piPropertyCursor->GetTable())->CreateCursor(fFalse);
	pCursor->SetFilter(1);
	pCursor->PutString(1, ristrProperty);
	if (pCursor->Next())
		return pCursor->GetString(2);
	else
		return g_MsiStringNull;
//!! This doesn't seem to work... malcolmh 2/5/98       return pCursor->Next() ? pCursor->GetString(2) : g_MsiStringNull;
}

//____________________________________________________________________________
//
// Internal engine utility functions
//____________________________________________________________________________

IMsiRecord* CMsiEngine::ComposeDescriptor(const IMsiString& riFeature, const IMsiString& riComponent,
														IMsiRecord& riRecord, unsigned int iField)
{
	//!! FIX to use GUID compression
	MsiString istrMsiDesc = GetProductKey();
	//!! FIX to eliminate feature if one one feature in product
	istrMsiDesc += riFeature;
	//!! FIX to use Ascii delimiter character
	istrMsiDesc += MsiChar(chFeatureIdTerminator);
	//!! FIX to eliminate feature if one one feature in product
	istrMsiDesc += riComponent;
	riRecord.SetMsiString(iField, *istrMsiDesc);
	return 0;
}

Bool CMsiEngine::GetFeatureInfo(const IMsiString& riFeature, const IMsiString*& rpiTitle,
										  const IMsiString*& rpiHelp, int& riAttributes)
{
	PMsiRecord pError(0);
	if (!m_piFeatureCursor)
	{
		if (pError = LoadFeatureTable())
			return fFalse;

		Assert(m_piFeatureCursor);
	}

	m_piFeatureCursor->Reset();
	m_piFeatureCursor->SetFilter(iColumnBit(m_colFeatureKey));
	m_piFeatureCursor->PutString(m_colFeatureKey, riFeature);
	if (m_piFeatureCursor->Next())
	{
		rpiTitle = &m_piFeatureCursor->GetString(m_colFeatureTitle);
		rpiHelp  = &m_piFeatureCursor->GetString(m_colFeatureDescription);

		// Try the runtime attributes column first.  If it hasn't been initialized,
		// try the authored attributes column.  If that fails as well, default to
		// FavorLocal.
		int iAttributesInternal = m_piFeatureCursor->GetInteger(m_colFeatureAttributes);
		if(iAttributesInternal == iMsiNullInteger)
		{
			iAttributesInternal = m_piFeatureCursor->GetInteger(m_colFeatureAuthoredAttributes);
			if (iAttributesInternal == iMsiNullInteger)
				iAttributesInternal = ifeaFavorLocal;
		}
		switch(iAttributesInternal & ifeaInstallMask)
		{
		case ifeaFavorLocal:
			riAttributes = INSTALLFEATUREATTRIBUTE_FAVORLOCAL;
			break;
		case ifeaFavorSource:
			riAttributes = INSTALLFEATUREATTRIBUTE_FAVORSOURCE;
			break;
		case ifeaFollowParent:
			riAttributes = INSTALLFEATUREATTRIBUTE_FOLLOWPARENT;
			break;
		default:
			AssertSz(0, "Unknown Attributes setting");
			riAttributes = 0;
			break;
		}

		if(iAttributesInternal & ifeaFavorAdvertise)
			riAttributes |= INSTALLFEATUREATTRIBUTE_FAVORADVERTISE;

		if(iAttributesInternal & ifeaDisallowAdvertise)
			riAttributes |= INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE;

		if (iAttributesInternal & ifeaNoUnsupportedAdvertise)
			riAttributes |= INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE;

		// Since ifeaUIDisallowAbsent state is UI status only, it's utility
		// to the caller is questionable, and is not returned.
		return fTrue;
	}
	else
	{
		return fFalse;
	}
}

ieiEnum MapStorageErrorToInitializeReturn(IMsiRecord* piError)
{
    if (!piError)
        return ieiSuccess;

    switch (piError->GetInteger(1))
    {
    case idbgInvalidMsiStorage:             return ieiPatchPackageInvalid;
    case imsgMsiFileRejected:               return ieiPatchPackageRejected;
    default:
        {
            switch (piError->GetInteger(3))
            {
            case STG_E_FILENOTFOUND:        // fall through
            case STG_E_PATHNOTFOUND:        // ...
            case STG_E_ACCESSDENIED:        // ...
            case STG_E_SHAREVIOLATION:      return ieiPatchPackageOpenFailed;
            case STG_E_INVALIDNAME:         // fall through
            default:                        return ieiPatchPackageInvalid;
            }
        }
    }
}

UINT MapInitializeReturnToUINT(ieiEnum iei)
{
	switch (iei)
	{
	case ieiSuccess            : return ERROR_SUCCESS; // initialization complete
	case ieiAlreadyInitialized : return ERROR_ALREADY_INITIALIZED; // this engine object is already initialized
	case ieiCommandLineOption  : return ERROR_INVALID_COMMAND_LINE; // invalid command line syntax %1
	case ieiDatabaseOpenFailed : return ERROR_INSTALL_PACKAGE_OPEN_FAILED; // database could not be opened
	case ieiDatabaseInvalid    : return ERROR_INSTALL_PACKAGE_INVALID; // incompatible database
	case ieiInstallerVersion   : return ERROR_INSTALL_PACKAGE_VERSION; // installer version does not support database format
	case ieiSourceAbsent       : return ERROR_INSTALL_SOURCE_ABSENT; // could not resolve a source
	case ieiHandlerInitFailed  : return ERROR_INSTALL_UI_FAILURE; // could not initialize handler interface
	case ieiLogOpenFailure     : return ERROR_INSTALL_LOG_FAILURE; // could not open logfile in requested mode
	case ieiLanguageUnsupported: return ERROR_INSTALL_LANGUAGE_UNSUPPORTED; // no acceptable language could be found
	case ieiPlatformUnsupported: return ERROR_INSTALL_PLATFORM_UNSUPPORTED; // no acceptable platform could be found
	case ieiTransformFailed    : return ERROR_INSTALL_TRANSFORM_FAILURE; // database transform failed to merge
	case ieiSignatureRejected  : return ERROR_INSTALL_PACKAGE_REJECTED; // digital signature rejected.
	case ieiDatabaseCopyFailed : return ERROR_INSTALL_TEMP_UNWRITABLE; // could not copy db to temp dir
	case ieiPatchPackageOpenFailed : return ERROR_PATCH_PACKAGE_OPEN_FAILED; // could not open patch package
	case ieiPatchPackageInvalid : return ERROR_PATCH_PACKAGE_INVALID; // patch package invalid
	case ieiPatchPackageUnsupported: return ERROR_PATCH_PACKAGE_UNSUPPORTED; // patch package unsupported (wrong patching engine?)
	case ieiTransformNotFound  : return ERROR_INSTALL_TRANSFORM_FAILURE; // transform file not found
	case ieiPackageRejected    : return ERROR_INSTALL_PACKAGE_REJECTED;  // package cannot be run because of security reasons
	case ieiProductUnknown     : return ERROR_UNKNOWN_PRODUCT; // attempt to uninstall a product you haven't installed
	case ieiDiffUserAfterReboot: return ERROR_INSTALL_USEREXIT; // different user attempting to complete install after reboot
	case ieiProductAlreadyInstalled: return ERROR_PRODUCT_VERSION;
	case ieiTSRemoteInstallDisallowed : return ERROR_INSTALL_REMOTE_DISALLOWED;
	case ieiNotValidPatchTarget: return ERROR_PATCH_TARGET_NOT_FOUND;
	case ieiPatchPackageRejected: return ERROR_PATCH_PACKAGE_REJECTED; // patch rejected by policy
	case ieiTransformRejected: return ERROR_INSTALL_TRANSFORM_REJECTED; // transform rejected by policy
	case ieiPerUserInstallMode: return ERROR_INSTALL_FAILURE;
	case ieiApphelpRejectedPackage: return ERROR_APPHELP_BLOCK;
	default: AssertSz(0, "Unknown ieiEnum"); return ERROR_NOT_SUPPORTED;
	};
};

bool __stdcall FIsUpdatingProcess (void) 
{
	return (g_fWin9X || scService == g_scServerContext);
}

//____________________________________________________________________________
//
// Command line option translation table
// If value appears on command line, specify property name only: "Name"
// Else supply name and value as: "Name=PropertyValue"
// If value contains spaces, use: "Name=""Propery Value" (no ending extra quote)
//____________________________________________________________________________

//!! does anything use this anymore??? - bench
ICHAR* rgszOptionTable[26] = {
/*A*/ TEXT("ACTION=Admin"),
/*B*/ 0,
/*C*/ 0,
/*D*/ TEXT("DATABASE"),
/*E*/ 0,
/*F*/ 0,
/*G*/ TEXT("LOGFILE"),
/*H*/ 0,
/*I*/ TEXT("ROOTDRIVE"),
/*J*/ 0,
/*K*/ 0,
/*L*/ 0,
/*M*/ TEXT("LOGMODE"),
/*N*/ TEXT("USERNAME"),
/*O*/ TEXT("COMPANYNAME"),
/*P*/ TEXT("PRODUCTID"),
/*Q*/ TEXT("UI=N"),
/*R*/ TEXT("ACTION=Reinstall"),
/*S*/ TEXT("SOURCEDIR"),
/*T*/ TEXT("DATABASE"),
/*U*/ TEXT("REMOVE=All"),
/*V*/ TEXT("TRANSFORMS"),
/*W*/ 0,
/*X*/ 0,
/*Y*/ 0,
/*Z*/ 0,
};

//____________________________________________________________________________
//
// Command line parsing
//____________________________________________________________________________

ICHAR SkipWhiteSpace(const ICHAR*& rpch)
{
	ICHAR ch;
	for (; (ch = *rpch) == ' ' || ch == '\t'; rpch++)
		;
	return ch;
}

// parse property name, convert to upper case, advances pointer to next non-blank

const IMsiString& ParsePropertyName(const ICHAR*& rpch, Bool fUpperCase)
{
	MsiString istrName;
	ICHAR ch;
	const ICHAR* pchStart = rpch;
	while ((ch=*rpch) != 0 && ch != '=' && ch != ' ' && ch != '\t')
		rpch++;
	int cchName = rpch - pchStart;
	if (cchName)
	{
		// property names will not contain DBCS characters -- they are required to follow
		// our identifier rules
		memcpy(istrName.AllocateString(cchName, /*fDBCS=*/fFalse), pchStart, cchName * sizeof(ICHAR));
		if(fUpperCase)
			istrName.UpperCase();
	}
	SkipWhiteSpace(rpch);
	return istrName.Return();
}

// parse property value, advance pointer past value, allows quotes, doubled to escape

const IMsiString& ParsePropertyValue(const ICHAR*& rpch)
{
	MsiString istrValue;
	MsiString istrSection;
	Bool fDBCS = fFalse;
	if (SkipWhiteSpace(rpch) != 0)
	{
		ICHAR ch;
		do
		{
			const ICHAR* pchStart = rpch;
			int cchValue = 0;
			if (*rpch == '"')           // opening quote
			{
				pchStart++;
				rpch++;
				while ((ch=*rpch) != 0)
				{
#ifdef UNICODE
					rpch++;
#else // !UNICODE
					const ICHAR* pchTmp = rpch;
					rpch = ICharNext(rpch);
					if (rpch == pchTmp + 2)
					{
						fDBCS = fTrue;
						cchValue++; // add 1 for trail byte
					}
#endif // UNICODE
					if (ch == '"')      // closing quote or escaped quote
					{
						ch = *rpch;     // check following char
						if (ch == '"')  // if doubled quote
							cchValue++; // include a quote in string
						break;
					}
					cchValue++;
				}
			}
			else
			{
				while ((ch=*rpch) != 0 && ch != ' ' && ch != '\t')
				{
#ifdef UNICODE
					rpch++;
#else // !UNICODE
					const ICHAR* pchTmp = rpch;
					rpch = ICharNext(rpch);
					if (rpch == pchTmp + 2)
					{
						fDBCS = fTrue;
						cchValue++; // add 1 for trail byte
					}
#endif // UNICODE
					cchValue++;
				}
			}
			if (cchValue)
			{
				memcpy(istrSection.AllocateString(cchValue, fDBCS), pchStart, cchValue * sizeof(ICHAR));
				istrValue += istrSection;
			}
		} while (ch == '"'); // loop if escaped double quote
	}
	return istrValue.Return();
}

const ICHAR* rgszAllowedProperties[] =
{
	IPROPNAME_FILEADDLOCAL,
	IPROPNAME_COMPONENTADDLOCAL,
	IPROPNAME_COMPONENTADDSOURCE,
	IPROPNAME_COMPONENTADDDEFAULT,
	IPROPNAME_ALLUSERS,
	IPROPNAME_SCRIPTFILE,
	IPROPNAME_EXECUTEMODE,
	IPROPNAME_PRODUCTLANGUAGE,
	IPROPNAME_TRANSFORMS,
	IPROPNAME_REINSTALLMODE,
	IPROPNAME_RUNONCEENTRY,
	IPROPNAME_CURRENTDIRECTORY,
	IPROPNAME_CLIENTUILEVEL,
	IPROPNAME_CLIENTPROCESSID,
	IPROPNAME_ACTION,
	IPROPNAME_CURRENTMEDIAVOLUMELABEL,
	IPROPNAME_INSTALLLEVEL,
	IPROPNAME_REINSTALL,
	IPROPNAME_FEATUREREMOVE,
	IPROPNAME_FEATUREADDLOCAL,
	IPROPNAME_FEATUREADDSOURCE,
	IPROPNAME_FEATUREADDDEFAULT,
	IPROPNAME_FEATUREADVERTISE,
	IPROPNAME_PATCH,
	IPROPNAME_SECONDSEQUENCE,
	IPROPNAME_TRANSFORMSATSOURCE,
	IPROPNAME_TRANSFORMSSECURE,
	IPROPNAME_CURRENTDIRECTORY,
	IPROPNAME_MIGRATE,
	IPROPNAME_LIMITUI,
	IPROPNAME_LOGACTION,
	IPROPNAME_UPGRADINGPRODUCTCODE,
	IPROPNAME_REBOOT,
	IPROPNAME_SEQUENCE,
	IPROPNAME_NOCOMPANYNAME,
	IPROPNAME_NOUSERNAME,
	IPROPNAME_RESUME,
	IPROPNAME_PRIMARYFOLDER,
	IPROPNAME_SHORTFILENAMES,
	IPROPNAME_INSTALLLEVEL,
	IPROPNAME_MEDIAPACKAGEPATH,
	IPROPNAME_PROMPTROLLBACKCOST,
	IPROPNAME_ODBCREINSTALL,
	IPROPNAME_FILEADDSOURCE,
	IPROPNAME_FILEADDDEFAULT,
	IPROPNAME_AFTERREBOOT,
	IPROPNAME_EXECUTEACTION,
	IPROPNAME_REBOOTPROMPT,
	IPROPNAME_MSINODISABLEMEDIA,
	IPROPNAME_CHECKCRCS,
	IPROPNAME_FASTOEMINSTALL,
	IPROPNAME_MSINEWINSTANCE,
	IPROPNAME_MSIINSTANCEGUID,
0
};

#ifdef UNICODE
bool PropertyIsAllowed(const ICHAR* szProperty, const ICHAR* szAllowedProperties)
#else
bool PropertyIsAllowed(const ICHAR*, const ICHAR*)
#endif
{
#ifdef UNICODE
	MsiString strProperty = *szProperty;
	strProperty.UpperCase();

	// check whether this is one of our hardcoded allowed properties

	for (const ICHAR** pszAllowed = rgszAllowedProperties; *pszAllowed; pszAllowed++)
	{
		if (strProperty.Compare(iscExact, *pszAllowed))
			return true;
	}

	// check whether this is an author-defined allowed property

	if (szAllowedProperties && *szAllowedProperties)
	{
		const ICHAR* pchAllowedPropEnd = szAllowedProperties;

		for (;;)
		{
			if (*pchAllowedPropEnd == 0 || *pchAllowedPropEnd == ';')
			{
				unsigned cchToCompare = pchAllowedPropEnd - szAllowedProperties;
				// property must have length >= 1
				// list containing ";;" or ending in ";" is valid, but ';' has no meaning w.r.t. a property name
				if (cchToCompare != 0 && 0 == memcmp(szProperty, szAllowedProperties, cchToCompare*sizeof(ICHAR)))
					return true;
				
				if (*pchAllowedPropEnd == 0)
					break;

				szAllowedProperties = pchAllowedPropEnd + 1;
			}

			pchAllowedPropEnd++;
		}
	}

	if (szProperty)
		DEBUGMSGL1(TEXT("Ignoring disallowed property %s"), szProperty);

	return false;
#else
	return true;
#endif
}

// parse properties from command line, assumes module name stripped off

Bool ProcessCommandLine(const ICHAR* szCommandLine,
								const IMsiString** ppistrLanguage, const IMsiString** ppistrTransforms,
								const IMsiString** ppistrPatch, const IMsiString** ppistrAction,
								const IMsiString** ppistrDatabase,
								const IMsiString* pistrOtherProp, const IMsiString** ppistrOtherPropValue,
								Bool fUpperCasePropNames, const IMsiString** ppistrErrorInfo,
								IMsiEngine* piEngine,
								bool fRejectDisallowedProperties)
{
	if (!szCommandLine)
		return fTrue;

	MsiString strAuthoredAllowedProperties;
	if (fRejectDisallowedProperties && piEngine)
	{
		strAuthoredAllowedProperties = piEngine->GetPropertyFromSz(IPROPNAME_ALLOWEDPROPERTIES);
	}

	const ICHAR* pchCmdLine = szCommandLine;
	for(;;)
	{
		MsiString istrPropName;
		MsiString istrPropValue;
		ICHAR ch = SkipWhiteSpace(pchCmdLine);
		const ICHAR* szCmdOption = pchCmdLine;  // keep start for error message
		if (ch == 0)
			break;

		// process property=value pair
		istrPropName = ParsePropertyName(pchCmdLine, fUpperCasePropNames);
		if (!istrPropName.TextSize() || *pchCmdLine++ != '=')
		{
			if (ppistrErrorInfo)
			{
				(*ppistrErrorInfo)->Release();
				istrPropName.ReturnArg(*ppistrErrorInfo);
			}
			return fFalse;
		}
		istrPropValue = ParsePropertyValue(pchCmdLine);

		if ((ppistrLanguage) || (ppistrTransforms) || (ppistrPatch) || (ppistrAction) || (ppistrDatabase) ||
			 (pistrOtherProp && ppistrOtherPropValue))
		{
			if ((ppistrLanguage) && (istrPropName.Compare(iscExact, IPROPNAME_PRODUCTLANGUAGE) == 1))
			{
				if(*ppistrLanguage)
					(*ppistrLanguage)->Release();
				*ppistrLanguage= istrPropValue;
				(*ppistrLanguage)->AddRef();
			}
			else if ((ppistrTransforms) && (istrPropName.Compare(iscExact, IPROPNAME_TRANSFORMS) == 1))
			{
				while (istrPropValue.Compare(iscStart, TEXT(" "))) // remove leading spaces
					istrPropValue.Remove(iseFirst, 1);

				if(*ppistrTransforms)
					(*ppistrTransforms)->Release();
				*ppistrTransforms = istrPropValue;
				(*ppistrTransforms)->AddRef();
			}
			else if ((ppistrPatch) && (istrPropName.Compare(iscExact, IPROPNAME_PATCH) == 1))
			{
				if(*ppistrPatch)
					(*ppistrPatch)->Release();
				*ppistrPatch = istrPropValue;
				(*ppistrPatch)->AddRef();
			}
			else if ((ppistrAction) && (istrPropName.Compare(iscExact, IPROPNAME_ACTION) == 1))
			{
				if(*ppistrAction)
					(*ppistrAction)->Release();
				*ppistrAction = istrPropValue;
				(*ppistrAction)->AddRef();
			}
			else if ((ppistrDatabase) && (istrPropName.Compare(iscExact, IPROPNAME_DATABASE) == 1))
			{
				if(*ppistrDatabase)
					(*ppistrDatabase)->Release();
				*ppistrDatabase = istrPropValue;
				(*ppistrDatabase)->AddRef();
			}
			else if ((pistrOtherProp) && (ppistrOtherPropValue) &&
						(istrPropName.Compare(iscExact, pistrOtherProp->GetString()) == 1))
			{
				if(*ppistrOtherPropValue)
					(*ppistrOtherPropValue)->Release();
				*ppistrOtherPropValue = istrPropValue;
				(*ppistrOtherPropValue)->AddRef();
			}
		}
		else if (piEngine && (!fRejectDisallowedProperties || PropertyIsAllowed(istrPropName, strAuthoredAllowedProperties)))
		{
			piEngine->SetProperty(*istrPropName, *istrPropValue);
		}
	}
	return fTrue;
}

void CMsiEngine::FormatLog(IMsiRecord& riRecord)
{
	if((m_fMode & iefLogEnabled) && m_fLogAction)  //!! always false now
	{
//#define NOMEMLOG
#if defined(DEBUG) && defined(NOMEMLOG)
		IMsiDebugMalloc *piDbgMalloc;
		int flags;
		extern IMsiMalloc *piMalloc;
		
		if (piMalloc->QueryInterface(IID_IMsiDebugMalloc, (void**)&piDbgMalloc) == NOERROR)
		{
			 flags = piDbgMalloc->GetDebugFlags();
			 piDbgMalloc->SetDebugFlags(flags & ~bfLogAllocs);
		}
#endif //DEBUG
		MsiString istrLogText(riRecord.FormatText(fTrue));
		ENG::WriteLog(MsiString(FormatText(*istrLogText)));
#if defined(DEBUG) && defined(NOMEMLOG)
		 piDbgMalloc->SetDebugFlags(flags);
		 piDbgMalloc->Release();
#endif //DEBUG

	}
}


Bool CMsiEngine::CheckInProgressProperties(const IMsiString& ristrInProgressProperties, ippEnum ippType)
{
	//!! REVIEW: need to make sure this is catching all of the good cases and rejecting all of the bad ones
	const ICHAR* pchCmdLine = ristrInProgressProperties.GetString();
	
	Bool rgfCheckedFeatureProp[g_cFeatureProperties];
	memset(rgfCheckedFeatureProp,0,g_cFeatureProperties);

	MsiString strPropName, strIPPropValue, strCurrentPropValue;
	for(;;)
	{
		ICHAR ch = SkipWhiteSpace(pchCmdLine);
		const ICHAR* szCmdOption = pchCmdLine;  // keep start for error message
		if (ch == 0)
			break;

		strPropName = ParsePropertyName(pchCmdLine, fTrue);
		Assert(*pchCmdLine++ == '=');
		strIPPropValue = ParsePropertyValue(pchCmdLine);
//              Assert(strIPPropValue.TextSize()); // already validated the command line

		strCurrentPropValue = GetProperty(*strPropName);
		iscEnum iscCompareType = (ippType != ippSelection ? iscExact : iscExactI);
		if(strCurrentPropValue.TextSize() && strCurrentPropValue.Compare(iscCompareType, strIPPropValue) == 0)
		{
			if(ippType == ippFolder && !strCurrentPropValue.Compare(iscEnd,szDirSep))
			{
				strCurrentPropValue += szDirSep;
				if(strCurrentPropValue.Compare(iscCompareType, strIPPropValue))
					continue;
			}
			return fFalse;
		}
		if(ippType == ippSelection)
		{
			// just checked a "selection" property - mark that we have done so
			for(int i = 0; i < g_cFeatureProperties; i++)
			{
				if(IStrComp(strPropName,g_rgFeatures[i].szFeatureActionProperty) == 0)
				{
					rgfCheckedFeatureProp[i] = fTrue;
					break;
				}
			}
		}
	}
	if(ippType == ippSelection)
	{
		// now make sure there are no "selection" properties defined that weren't in the in-progress value
		for(int i = 0; i < g_cFeatureProperties; i++)
		{
			if(rgfCheckedFeatureProp[i] == fFalse &&
				MsiString(GetPropertyFromSz(g_rgFeatures[i].szFeatureActionProperty)).TextSize())
				return fFalse;
		}
	}
	return fTrue;
}

//____________________________________________________________________________
//
// Product registration methods
//____________________________________________________________________________

iesEnum CMsiEngine::CreateProductInfoRec(IMsiRecord*& rpiRec)
{
	using namespace IxoProductInfo;
	
	PMsiRecord pError(0);
	rpiRec = &m_riServices.CreateRecord(Args);
	MsiString strProductKey = GetProductKey();

	DWORD dwVersion = ProductVersion();

	//!! if properties not set in Property table, should we use the summary properties? or just fail?
	AssertNonZero(rpiRec->SetMsiString(ProductKey, *strProductKey));
	AssertNonZero(rpiRec->SetMsiString(ProductName, *MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTNAME))));
	AssertNonZero(rpiRec->SetMsiString(PackageName, *m_strPackageName));
	AssertNonZero(rpiRec->SetInteger(Language, (int)GetLanguage()));
	AssertNonZero(rpiRec->SetInteger(Version, (int)dwVersion));
	AssertNonZero(rpiRec->SetInteger(Assignment, MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? 1 : 0));
	AssertNonZero(rpiRec->SetInteger(ObsoleteArg, 0)); // this used to be set on the execute side; we don't any longer,
																		// but old Darwins do, so we continue to reserve the spot
	AssertNonZero(rpiRec->SetMsiString(ProductIcon, *MsiString(GetPropertyFromSz(IPROPNAME_ARPPRODUCTICON))));
	AssertNonZero(rpiRec->SetMsiString(PackageCode, *MsiString(GetPropertyFromSz(IPROPNAME_PACKAGECODE))));
	AssertNonZero(rpiRec->SetInteger(InstanceType, m_fNewInstance ? 1 : 0));
	
	// save off AppCompat information for custom actions if enabled for this install
	if (m_fCAShimsEnabled)
	{
		PMsiStream piDBGuid(0);
		char* pbBuffer = m_riServices.AllocateMemoryStream(sizeof(m_guidAppCompatDB), *&piDBGuid);
		if (!pbBuffer)
			return iesFailure;
		memcpy(pbBuffer, &m_guidAppCompatDB, sizeof(m_guidAppCompatDB));
		AssertNonZero(rpiRec->SetMsiData(AppCompatDB, piDBGuid));
	
	
		PMsiStream piIDGuid(0);
		pbBuffer = m_riServices.AllocateMemoryStream(sizeof(m_guidAppCompatID), *&piIDGuid);
		if (!pbBuffer)
			return iesFailure;
		memcpy(pbBuffer, &m_guidAppCompatID, sizeof(m_guidAppCompatID));
		AssertNonZero(rpiRec->SetMsiData(AppCompatID, piIDGuid));
	}

	if (!m_fAdvertised)
	{
		// if not already advertised mode, we'll to deduce the media relative path if installing from media,
		// or grab it from the admin properties stream if possible
		iesEnum iesResult = iesSuccess;

		PMsiPath pPath(0);
		PMsiRecord pError(0);
		if ((pError = GetSourcedir(*this, *&pPath)) != 0)
			return FatalError(*pError);

		MsiString strMediaRelativePath;

		idtEnum idt = PMsiVolume(&pPath->GetVolume())->DriveType();
		if (idt == idtCDROM || idt == idtFloppy || idt == idtRemovable)
		{
			strMediaRelativePath = pPath->GetRelativePath();
		}
		else
		{
			strMediaRelativePath = GetPropertyFromSz(IPROPNAME_MEDIAPACKAGEPATH);
		}

		AssertNonZero(rpiRec->SetMsiString(PackageMediaPath, *strMediaRelativePath));
	}
	else
	{
		// if in maintenance mode, get the relative path from the registered source list
		CRegHandle hSourceListKey;
		if (ERROR_SUCCESS == OpenSourceListKey(strProductKey, /*fPatch=*/fFalse, hSourceListKey, /*fWrite=*/fFalse, false))
		{
			PMsiRegKey pSourceListKey = &m_riServices.GetRootKey((rrkEnum)(int)hSourceListKey);
			PMsiRegKey pMediaKey = &pSourceListKey->CreateChild(szSourceListMediaSubKey, 0);

			MsiString strPackagePath;
			PMsiRecord pError(0);
			if ((pError = pMediaKey->GetValue(szMediaPackagePathValueName, *&strPackagePath)) == 0)
			{
				AssertNonZero(rpiRec->SetMsiString(PackageMediaPath, *strPackagePath));
			}
		}
	}

	return iesSuccess;
}

unsigned int CMsiEngine::ProductVersion()
{
	return ProductVersionStringToInt(MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTVERSION)));
}

unsigned int ProductVersionStringToInt(const ICHAR* szVersion)
{
	MsiString strVersion(szVersion);
	MsiString strField;
	DWORD dwVersion = 0;

	// Given a version A.B.C.D the integer representation is (A << 24) | (B << 16) | C
	// Assumes that A, B <= 0xFF and C <= 0xFFFF

	// FUTURE davidmck - No need to do the extraction
	for(int i = 0,iShift=24; i < 3; i++, iShift-= i*8)// first shift 24, then 16 then 0
	{
		strField = strVersion.Extract(iseUpto, '.');
		dwVersion |= (int)strField << iShift;
		if(!strVersion.Remove(iseIncluding, '.'))
			break; // insufficient fields
	}
	return dwVersion;
}

// stuff from fileactn.cpp
extern iesEnum ExecuteChangeMedia(IMsiEngine& riEngine, IMsiRecord& riMediaRec, IMsiRecord& riParamsRec,
								  const IMsiString& ristrTemplate, unsigned int cbPerTick, const IMsiString& ristrFirstVolLabel);
extern IMsiRecord* OpenMediaView(IMsiEngine& riEngine, IMsiView*& rpiView, const IMsiString*& rpistrFirstVolLabel);

IMsiRecord* GetSourcedir(IMsiDirectoryManager& riDirManager, IMsiPath*& rpiPath)
{
	IMsiRecord* piError;
	if ((piError = riDirManager.GetSourcePath(*MsiString(*IPROPNAME_SOURCEDIR), rpiPath)) != 0)
	{
		if (piError->GetInteger(1) == idbgSourcePathsNotCreated)
		{
			piError->Release();
			piError = riDirManager.GetSourcePath(*MsiString(*IPROPNAME_SOURCEDIROLD), rpiPath);
		}
	}
	return piError;
}

IMsiRecord* GetSourcedir(IMsiDirectoryManager& riDirManager, const IMsiString*& rpiValue)
{
	IMsiRecord* piError;
	PMsiPath pPath(0);
	if ((piError = GetSourcedir(riDirManager, *&pPath)) != 0)
		return piError;

	MsiString(pPath->GetPath()).ReturnArg(rpiValue);
	return 0;
}

iesEnum CMsiEngine::CacheDatabaseIfNecessary()
{
	using namespace IxoDatabaseCopy;

	MsiString strOriginalDatabasePath = GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE);
	MsiString strDatabasePath         = GetPropertyFromSz(IPROPNAME_DATABASE);

	// cached DB if first-run OR maintenance-mode & our package isn't the cached package
	if (*(const ICHAR*)strOriginalDatabasePath != ':'  // not a SubStorage
	  && (!(GetMode() & iefMaintenance) || (!IsCachedPackage(*this, *strDatabasePath))))
	{
		{
			using namespace IxoChangeMedia;
			
			// if we have a media table entry dispatch an IxoChangeMedia operation for the cache database copy
			PMsiView pView(0);
			iesEnum iesRet;
			PMsiRecord piError(0);
			MsiString strFirstVolumeLabel;
			if((piError = OpenMediaView(*this,*&pView,*&strFirstVolumeLabel)) != 0)
				return FatalError(*piError);
			
			if((piError = pView->Execute(0)) != 0)
				return FatalError(*piError);
			PMsiRecord pMediaFetch = pView->Fetch(); // only want first one
			if(pMediaFetch)
			{
				PMsiRecord pExecuteMedia = &m_riServices.CreateRecord(IxoChangeMedia::Args);
				iesRet = ExecuteChangeMedia(*this,*pMediaFetch,*pExecuteMedia,*MsiString(GetErrorTableString(imsgPromptForDisk)),0,*strFirstVolumeLabel);
				if(iesRet != iesSuccess && iesRet != iesNoAction)
					return iesRet;
			}
		}

		MsiString strStreams;
		CreateCabinetStreamList(*this, *&strStreams);

		PMsiRecord pCacheDatabaseInfo(&m_riServices.CreateRecord(IxoDatabaseCopy::Args));
		// for nested installs the currently running msi (strDatabasePath) may be gone when we
		// run the script for merged nested installs so we always copy the source package for nested
		// installed. for non-nested installs, however, the currently running msi will still be around
		// so we copy that.

		if (m_fChildInstall)
			pCacheDatabaseInfo->SetMsiString(DatabasePath, *strOriginalDatabasePath);
		else
			pCacheDatabaseInfo->SetMsiString(DatabasePath, *strDatabasePath);

		pCacheDatabaseInfo->SetMsiString(ProductCode, *MsiString(GetProductKey()));
		pCacheDatabaseInfo->SetMsiString(CabinetStreams, *strStreams);

		return ExecuteRecord(IxoDatabaseCopy::Op, *pCacheDatabaseInfo);
	}
	return iesSuccess;
}

iesEnum CMsiEngine::RegisterProduct()
{
	PMsiRecord pError(0);

	if (!m_piProductKey)
	{
		pError = PostError(Imsg(idbgEngineNotInitialized),TEXT(""));
		return FatalError(*pError);
	}
	
	iesEnum iesRet = iesSuccess;
	if (FFeaturesInstalled(*this) == fFalse)
		return iesRet;  // nothing selected


	if ((iesRet = CacheDatabaseIfNecessary()) != iesSuccess)
		return iesRet;

	// register product if
	// a) haven't registered this product code before
	// b) are installing a new package with the same product code
	MsiString strQFEUpgrade = GetPropertyFromSz(IPROPNAME_QFEUPGRADE);
	int iQFEUpgradeType = 0;
	if(strQFEUpgrade.TextSize())
	{
		iQFEUpgradeType = strQFEUpgrade;
		if(iQFEUpgradeType == iMsiNullInteger)
		{
			Assert(0);
			iQFEUpgradeType = 0;
		}
	}

	if (!m_fRegistered || iQFEUpgradeType)
	{
		if(iQFEUpgradeType)
			DEBUGMSG(TEXT("Re-registering product - performing upgrade of existing installation."));
		
		using namespace IxoProductRegister;
		PMsiRecord pProductInfo(&m_riServices.CreateRecord(Args));
		pProductInfo->SetMsiString(AuthorizedCDFPrefix, *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPAUTHORIZEDCDFPREFIX))));
		pProductInfo->SetMsiString(Comments,        *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPCOMMENTS))));
		pProductInfo->SetMsiString(Contact,         *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPCONTACT))));
		// ARPPRODUCTICON is set during advertisement.

		// (DisplayName is in the ixoProductInfo op)
		// (DisplayVersion is in the ixoProductInfo op)

		pProductInfo->SetMsiString(HelpLink,        *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPHELPLINK))));
		pProductInfo->SetMsiString(HelpTelephone,   *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPHELPTELEPHONE))));

		// (InstallDate is determined on the execute side)
		
		pProductInfo->SetMsiString(InstallLocation, *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPINSTALLLOCATION))));

		// only register source during initial install
		// or QFE non-patch upgrade
		// if patching, use existing value
		if(!m_fRegistered || iQFEUpgradeType == 1)
		{
			MsiString strSourceDir;
			if ((pError = ENG::GetSourcedir(*this, *&strSourceDir)) != 0)
			{
				if (pError->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return FatalError(*pError);
			}

			pProductInfo->SetMsiString(InstallSource,   *strSourceDir);
		}
		else if (iQFEUpgradeType == 2)
		{
			// QFEUpgrade via patch -- use existing InstallSource value from the initial install (don't blank it)
			CTempBuffer<ICHAR, MAX_PATH> rgchInstallSource;
			if (ENG::GetProductInfo(m_piProductKey->GetString(), INSTALLPROPERTY_INSTALLSOURCE, rgchInstallSource))
			{
				pProductInfo->SetString(InstallSource, rgchInstallSource);
			}
		}

		// (LocalPackage is written by ixoDatabaseCopy)
		// (ModifyPath is determined on the execute side)
		if (MsiString(GetProperty(*MsiString(*IPROPNAME_ARPNOMODIFY))).TextSize())
			pProductInfo->SetInteger(NoModify, 1);

		if (MsiString(GetProperty(*MsiString(*IPROPNAME_ARPNOREMOVE))).TextSize())
			pProductInfo->SetInteger(NoRemove, 1);

		if (MsiString(GetProperty(*MsiString(*IPROPNAME_ARPNOREPAIR))).TextSize())
			pProductInfo->SetInteger(NoRepair, 1);

		// (ProductId is in the ixoUserRegister op)

		pProductInfo->SetMsiString(Publisher,       *MsiString(GetProperty(*MsiString(*IPROPNAME_MANUFACTURER))));
		pProductInfo->SetMsiString(Readme,          *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPREADME))));

		// (RegCompany is in the ixoUserRegister op)
		// (RegOwner is in the ixoUserRegister op)

		pProductInfo->SetMsiString(Size,            *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPSIZE))));

		MsiString istrEstimatedSize = GetEstimatedInstallSize();
		pProductInfo->SetMsiString(EstimatedSize, *istrEstimatedSize);

		pProductInfo->SetMsiString(SystemComponent, *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPSYSTEMCOMPONENT))));
		
		// (UninstallString is determined on the execute side)
		
		pProductInfo->SetMsiString(UpgradeCode,     *MsiString(GetProperty(*MsiString(*IPROPNAME_UPGRADECODE))));
		pProductInfo->SetMsiString(URLInfoAbout,    *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPURLINFOABOUT))));
		pProductInfo->SetMsiString(URLUpdateInfo,   *MsiString(GetProperty(*MsiString(*IPROPNAME_ARPURLUPDATEINFO))));
		pProductInfo->SetMsiString(VersionString,   *MsiString(GetProperty(*MsiString(*IPROPNAME_PRODUCTVERSION))));
		
		// (WindowsInstaller is determined on the execute side)
		
		iesRet = ExecuteRecord(Op, *pProductInfo);
		if(iesRet != iesSuccess)
			return iesRet;

		// will register the product, so set the PRODUCTTOBEREGISTERED property
		SetPropertyInt(*MsiString(*IPROPNAME_PRODUCTTOBEREGISTERED),1);
	}
	else
	{
		// Maintenance mode - just update the EstimatedSize

		using namespace IxoUpdateEstimatedSize;
		PMsiRecord pSizeInfo(&m_riServices.CreateRecord(Args));
		MsiString istrEstimatedSize = GetEstimatedInstallSize();
		pSizeInfo->SetMsiString(EstimatedSize, *istrEstimatedSize);
		iesRet = ExecuteRecord(Op, *pSizeInfo);
		if(iesRet != iesSuccess)
			return iesRet;
	}
	
	// do the product name registration, if being installed as a standalone ap
	if (!m_fChildInstall && FFeaturesInstalled(*this, fFalse))
	{
		using namespace IxoProductCPDisplayInfoRegister;
		PMsiRecord pParam(&m_riServices.CreateRecord(Args));
		iesRet = ExecuteRecord(Op, *pParam);
	}
	return iesRet;
}


const IMsiString& CMsiEngine::GetEstimatedInstallSize()
{
	// For EstimatedSize, get total cost across all volumes, and convert from units of 512 to KB
	// If in maintenance mode, always use non-rollback cost to inc/dec current value; otherwise
	// always use rollback cost.
	bool fMaint = GetMode() & iefMaintenance ? true : false;
	int iTotalCost = GetTotalCostAcrossVolumes(fMaint ? false : true, /* fARPCost = */ true) / 2;

	// Subtract off the fixed engine overhead costs
	int iEngineCost, iEngineNoRbCost;
	PMsiRecord pError = DetermineEngineCost(&iEngineCost, &iEngineNoRbCost);
	if (!pError)
		iTotalCost -= fMaint ? iEngineNoRbCost / 2 : iEngineCost / 2;
	MsiString istrTotalCost = iTotalCost;
	return istrTotalCost.Return();
}


iesEnum CMsiEngine::RegisterUser(bool fDirect)
{
	// two modes of operation:
	// fDirect = true:  call server directly to register user, used by MsiCollectUserInfo
	// fDirect = false: dispatch script operation to register user, used by RegisterUser action
	
	PMsiRecord piError(0);

	// Smart connection manager object which creates a connection to the
	// service if there isn't one already and cleans up after itself
	// upon destruction.
	CMsiServerConnMgr MsiSrvConnMgrObject (this);
	
	if (!m_piProductKey)
	{
		piError = PostError(Imsg(idbgEngineNotInitialized),TEXT(""));
		return FatalError(*piError);
	}

	MsiString strUserName  = GetPropertyFromSz(IPROPNAME_USERNAME);
	MsiString strCompany   = GetPropertyFromSz(IPROPNAME_COMPANYNAME);
	MsiString strProductID = GetPropertyFromSz(IPROPNAME_PRODUCTID);
		
	if(fDirect)
	{
		if (NULL == m_piServer)
		{
		    piError = PostError (Imsg(imsgServiceConnectionFailure));
		    return FatalError (*piError);
		}

		piError = m_piServer->RegisterUser(m_piProductKey->GetString(),strUserName,strCompany,strProductID);
		if(piError)
			return FatalError(*piError);
		else
			return iesSuccess;
	}
	else
	{
		using namespace IxoUserRegister;

		if ((m_fRegistered) || (FFeaturesInstalled(*this) == fFalse))
			return iesSuccess;  // already be registered, maintenance mode, nothing selected or we we called before

		if (!m_piProductKey)
		{
			piError = PostError(Imsg(idbgEngineNotInitialized),TEXT(""));
			return FatalError(*piError);
		}

		if(!strProductID.TextSize())
			return iesSuccess; // PID not valid, but allow install to continue anyway
		
		PMsiRecord pUserInfo(&m_riServices.CreateRecord(Args));
		pUserInfo->SetMsiString(Owner,     *strUserName);
		pUserInfo->SetMsiString(Company,   *strCompany);
		pUserInfo->SetMsiString(ProductId, *strProductID);
		
		return ExecuteRecord(ixoUserRegister, *pUserInfo);
	}
}

const IMsiString& CMsiEngine::GetProductKey()
{
	if (!m_piProductKey)
	{
		MsiString istrProductKey = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);
		if (istrProductKey.TextSize())
			m_piProductKey = istrProductKey, m_piProductKey->AddRef();
		else
			return g_MsiStringNull;
	}
	m_piProductKey->AddRef();
	return *m_piProductKey;
}

//!! temp - remove when UnpublishAction is removed
iesEnum UnpublishProduct(IMsiEngine& riEngine);
//!! end temp

//!! currently calls the UnpublishProduct from coreactn
iesEnum CMsiEngine::UnregisterProduct()
{
	iesEnum iesRet = iesNoAction;
	if (!m_piProductKey)
		return iesRet;
	if(m_fRegistered)
	{
		if(!FFeaturesInstalled(*this))
		{
			using namespace IxoProductUnregister;
			PMsiRecord piRecord(&(m_riServices.CreateRecord(Args)));
			AssertNonZero(piRecord->SetMsiString(UpgradeCode,
															 *MsiString(GetPropertyFromSz(IPROPNAME_UPGRADECODE))));
			iesRet = ExecuteRecord(Op, *piRecord);
			if (iesRet != iesSuccess)
				return iesRet;

			// will register the product, so set the PRODUCTTOBEREGISTERED property
			SetProperty(*MsiString(*IPROPNAME_PRODUCTTOBEREGISTERED),g_MsiStringNull);
		}

		if(!m_fChildInstall && !FFeaturesInstalled(*this, fFalse))
		{
			using namespace IxoProductCPDisplayInfoUnregister;
			PMsiRecord piRecord(&(m_riServices.CreateRecord(Args)));
			iesRet = ExecuteRecord(Op, *piRecord);
			if (iesRet != iesSuccess)
				return iesRet;
		}
	}
	iesRet = ::UnpublishProduct(*this); //!! we shouldn't have an UnpublishProduct action - the code in that
											  //!! action should really be here.  This should be fixed in Beta 2
	return iesRet;
}

iesEnum CMsiEngine::BeginTransaction()
{
	PMsiRecord pError(0);
	
	if(!FMutexExists(szMsiExecuteMutex))
	{
		pError = PostError(Imsg(idbgErrorBeginningTransaction));
		return FatalError(*pError);
	}

	if (!m_fServerLocked)
	{
		DEBUGMSG("BeginTransaction: Locking Server");
		MsiString strSelections, strFolders, strProperties;
		//!! some properties may be duplicated in these strings, should reduce as much of this as possible
		pError = GetCurrentSelectState(*&strSelections, *&strProperties, 0, &strFolders, fTrue);
		if(pError)
		{
			return FatalError(*pError); //!!
		}

		PMsiRecord pSetInProgressInfo = &m_riServices.CreateRecord(ipiEnumCount);
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiProductKey,
																  *MsiString(GetProductKey())));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiProductName,
																  *MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTNAME))));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiLogonUser,
																  *MsiString(GetPropertyFromSz(IPROPNAME_LOGONUSER))));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiSelections, *strSelections));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiFolders, *strFolders));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiProperties, *strProperties));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiDatabasePath,
																  *MsiString(GetPropertyFromSz(IPROPNAME_DATABASE))));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiDiskPrompt,
																  *MsiString(GetPropertyFromSz(IPROPNAME_DISKPROMPT))));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiDiskSerial,
																  *MsiString(GetPropertyFromSz(IPROPNAME_DISKSERIAL))));
		AssertNonZero(pSetInProgressInfo->SetMsiString(ipiTimeStamp,
																  *MsiString(ENG::GetCurrentDateTime())));

		PMsiRecord pCurrentInProgressInfo(0);	
		for(;;)
		{
			pCurrentInProgressInfo = 0;

			if (MinimumPlatformMillennium() || MinimumPlatformWindowsNT51())
			{
				// Millennium/Whistler only
				if((pError = GetInProgressInstallInfo(m_riServices, *&pCurrentInProgressInfo)) != 0)
					return FatalError(*pError);
				if( !pCurrentInProgressInfo || !pCurrentInProgressInfo->GetFieldCount() )
					BeginSystemChange();
				pCurrentInProgressInfo = 0;
				
				ICHAR rgchBuffer[64];
				_i64tot(m_i64PCHEalthSequenceNo, rgchBuffer, 10);
				AssertNonZero(pSetInProgressInfo->SetMsiString(ipiSRSequence, *MsiString(rgchBuffer)));
			}

			pError = LockInstallServer(pSetInProgressInfo,*&pCurrentInProgressInfo);
			if(pError)
				return FatalError(*pError);
			else if(pCurrentInProgressInfo)
			{

				INT64 iSRSequence = pCurrentInProgressInfo->GetString(ipiSRSequence) ?
										  _ttoi64(pCurrentInProgressInfo->GetString(ipiSRSequence)) : 0;
				// suspended install detected
				if(MsiString(GetPropertyFromSz(IPROPNAME_RESUME)).TextSize())
				{
					// already checked in-progress install
					m_fServerLocked = fTrue;
					m_i64PCHEalthSequenceNo = iSRSequence;
					break;
				}
				
				ipitEnum ipitType = InProgressInstallType(*pCurrentInProgressInfo);
				if(ipitType == ipitSameConfig)
				{
					// resume this install
					m_fServerLocked = fTrue;
					m_i64PCHEalthSequenceNo = iSRSequence;

					// since there is a suspended install, we need to resume the terminal server
					// transaction by remapping the HKCU key as necessary. If the suspended install
					// is just a continuation, the transaction will be closed after the install 
					// finishes.
					OpenHydraRegistryWindow(/*fNewTransaction=*/false);
					break;
				}
				else
				{
					Bool fUserChangedDuringInstall = fFalse;
					if(ipitType & ipitDiffUser)
					{
						// communicate to this process, and the service that the user has changed.
						// don't rollback if different user started original install

						fUserChangedDuringInstall = fTrue;

						pError = PostError(Imsg(imsgDiffUserInstallInProgress),
											 *MsiString(pCurrentInProgressInfo->GetMsiString(ipiLogonUser)),
											 *MsiString(pCurrentInProgressInfo->GetMsiString(ipiProductName)));

						Message(imtUser,*pError); // no options, don't need to check return.
					}

					// each rollback script is responsible for ensuring its own registry/CA state
					// for per-machine TS installs. 
					Bool fRollbackAttempted = fFalse;
					iesEnum iesResult = RollbackSuspendedInstall(*pCurrentInProgressInfo,fTrue,
																				fRollbackAttempted, fUserChangedDuringInstall);
					if(iesResult == iesSuspend)
						// reboot required
						return iesResult;
					
					if(fRollbackAttempted == fFalse)
						return iesUserExit;
					
					//!! else ?? check return status
					continue;
				}
			}
			else
			{
				OpenHydraRegistryWindow(/*fNewTransaction=*/true);
				m_fServerLocked = fTrue;
				break;
			}
		}
	}
#ifdef DEBUG
	else
	{
		DEBUGMSG(TEXT("BeginTransaction: Server already locked"));
		Assert(m_fInParentTransaction);
	}
#endif //DEBUG

	m_issSegment = issScriptGeneration;

	if(!(GetMode() & (iefAdmin | iefAdvertise)))
	{
		iesEnum iesStatus = UnregisterProduct(); // unadvertises, unregisters the product if nothing installed
		if (iesStatus != iesSuccess && iesStatus != iesNoAction)
			return iesStatus;   //!! need to call FatalError?
	}
	return iesSuccess;
}

iesEnum CMsiEngine::EndTransaction(iesEnum iesState)
{
	iesEnum iesReturn = iesSuccess;

	// Smart connection manager object which creates a connection to the
	// service if there isn't one already and cleans up after itself
	// upon destruction.
	CMsiServerConnMgr MsiSrvConnMgrObject (this);
	
	MsiString strProductCode = GetProductKey();
	
	bool fUpdateStarted = MsiString(GetPropertyFromSz(IPROPNAME_UPDATESTARTED)).TextSize() != 0;

	if(m_fServerLocked && !m_fInParentTransaction)
	{
#ifdef DEBUG
		if(MsiString(GetPropertyFromSz(TEXT("ROLLBACKTEST"))).TextSize())
			iesState = iesFailure; // force rollback
#endif // DEBUG

		bool fAllowSuspend = MsiString(GetPropertyFromSz(IPROPNAME_ALLOWSUSPEND)).TextSize() != 0;

		if((GetMode() & iefRollbackEnabled) && fAllowSuspend && fUpdateStarted &&
			iesState != iesFinished && iesState != iesSuccess &&
			iesState != iesNoAction && iesState != iesSuspend)
		{
			//!! check if rollback always
			PMsiRecord pError = PostError(Imsg(imsgRestoreOrContinue));
			switch(Message(imtEnum(imtUser+imtYesNo+imtIconQuestion+imtDefault1),*pError))
			{
			case imsNo:
				iesState = iesSuspend;
				break;
			default:
				AssertSz(fTrue, "Invalid return from message");
			case imsYes:
			case imsNone:
				break;
			}
		}
		
		//!! check return for reboot
		if (m_piServer)
		{
		    iesReturn = m_piServer->InstallFinalize(iesState, *this, fFalse /*fUserChangedDuringInstall*/);
		}
		else
		{
		    PMsiRecord pError = PostError (Imsg(imsgServiceConnectionFailure));
		    iesReturn = FatalError (*pError);
		}
		
		if(iesReturn == iesFinished  || /*!!*/ iesReturn == iesSuspend)
			iesReturn = iesSuccess;

		// if we're on TS5, installing per machine, and aren't doing an admin image or
		// creating an advertise script, plus we aren't going to continue after a
		// reboot, we should notify TS that the install is complete
		switch (iesState)
		{
		case iesUserExit: // fall through
		case iesFailure:
			// for user cancel or failure, don't commit changes.
			CloseHydraRegistryWindow(/*Commit=*/false);
			EndSystemChange(/*fCommitChange=*/false, m_i64PCHEalthSequenceNo);
			break;
		case iesSuspend:
			// no action, leave window open, after reboot will close
			break;
		case iesSuccess:
		default:
			CloseHydraRegistryWindow(/*Commit=*/true);
			EndSystemChange(/*fCommitChange=*/true, m_i64PCHEalthSequenceNo);
			break;
		}

		Bool fRes = UnlockInstallServer((iesState == iesSuspend) ? fTrue : fFalse); //!! error
		m_fServerLocked = fFalse;

	}
	
	// reset Resume and UpdateStarted properties
	AssertNonZero(SetProperty(*MsiString(*IPROPNAME_RESUME),g_MsiStringNull));
	AssertNonZero(SetProperty(*MsiString(*IPROPNAME_RESUMEOLD),g_MsiStringNull));
	AssertNonZero(SetProperty(*MsiString(*IPROPNAME_UPDATESTARTED),g_MsiStringNull));

	m_issSegment = issPostExecution;
	return iesReturn;
}


urtEnum g_urtLoadFromURTTemp = urtSystem; // global, to remember where to load mscoree from

iesEnum CMsiEngine::RunScript(bool fForceIfMergedChild)
{
	// runs any spooled script operations
	if(m_fServerLocked == fFalse)
	{
		PMsiRecord pError = PostError(Imsg(idbgErrorRunningScript));
		return FatalError(*pError);
	}

	iesEnum iesState = iesSuccess;

	// drop fusion and mscoree, if loaded
	// this will allow us to reload these dlls from the temp folder, if present, the next time we need them (in the executor)
	FUSION::Unbind();
	MSCOREE::Unbind();

	MsiString strCarryingNDP = GetPropertyFromSz(IPROPNAME_CARRYINGNDP);
	if(strCarryingNDP.Compare(iscExactI, IPROPVALUE__CARRYINGNDP_URTREINSTALL))
		g_urtLoadFromURTTemp = urtPreferURTTemp;
	else if(strCarryingNDP.Compare(iscExactI, IPROPVALUE__CARRYINGNDP_URTUPGRADE))
		g_urtLoadFromURTTemp = urtRequireURTTemp;
	else g_urtLoadFromURTTemp = urtSystem;


	if(m_pExecuteScript)
	{
		Assert(m_ixmExecuteMode == ixmScript);
		Assert(m_pistrExecuteScript);
		Assert(!m_fMergingScriptWithParent);
		DEBUGMSG1(TEXT("Running Script: %s"),m_pistrExecuteScript->GetString());
		//!! do we really have to set iefOperations false here, or can be do it below?
		SetMode(iefOperations,fFalse); // not processing operations anymore
		SetProperty(*MsiString(*IPROPNAME_UPDATESTARTED), *MsiString(*TEXT("1")));
		m_pExecuteScript->SetProgressTotal(m_iProgressTotal);
		delete m_pExecuteScript, m_pExecuteScript = 0;
		m_scmScriptMode = scmRunScript;
		
		// Reset script progress record to prevent further progress ticks should
		// another script be generated later
		m_pScriptProgressRec = 0;

		AssertSz(m_piConfigManager, "Attempt to call RunScript from the client side of a client-server connection.");

		// if rollback was disabled in the middle of script generation iefRollbackEnabled is currently unset
		// but we still need to enable rollback for the start of script execution
		// ixoDisableRollback will then turn off rollback in the middle of the script
		Bool fRollbackEnabled = ToBool(m_fDisabledRollbackInScript || GetMode() & iefRollbackEnabled);
		m_fDisabledRollbackInScript = fFalse;
		
		iesState = m_piConfigManager->RunScript(m_pistrExecuteScript->GetString(), *this, this, fRollbackEnabled);
		if(iesState == iesFinished)
			iesState = iesSuccess;  // we may not really be finished yet
		if (iesState == iesSuspend)
		{
			AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_REPLACEDINUSEFILES),1));
			SetMode(iefReboot, fTrue);
			iesState = iesSuccess;
		}
		BOOL fRes = FALSE;
		{
			CElevate elevate;
			fRes = WIN::DeleteFile(m_pistrExecuteScript->GetString());
		}
#ifdef DEBUG
		if(!fRes)
		{
			ICHAR rgchDebug[256];
			wsprintf(rgchDebug, TEXT("Could not delete install script %s. Server probably crashed. Please save install script and .rbs files in \\config.msi for debugging."),
						m_pistrExecuteScript->GetString());
			AssertSz(0,rgchDebug);
		}
#endif //DEBUG
		m_pistrExecuteScript->Release();
		m_pistrExecuteScript = 0;
		m_scmScriptMode = scmIdleScript;
	}
	else if (m_fMergingScriptWithParent && (GetMode() & iefOperations))
	{
		// send null productinfo record to switch back to parent info in the script
		PMsiRecord precNull = &m_riServices.CreateRecord(0); //!! use global null record
		iesState = ExecuteRecord(ixoProductInfo, *precNull);  // can't set iefOperations false until after this

		// script execution could be forced within a merged child install
		if((iesState == iesSuccess || iesState == iesNoAction) && fForceIfMergedChild && m_piParentEngine)
		{
			iesState = m_piParentEngine->RunScript(fForceIfMergedChild);
		}
	}
	SetMode(iefOperations,fFalse); // no more spooled operations
	
	g_urtLoadFromURTTemp = urtSystem; // must reset before returning from this function
	return iesState;
}

// ValidateProductID: should only be called through ValidateProductID action or Control Event
Bool CMsiEngine::ValidateProductID(bool fForce)
{
	if (MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTID)).TextSize())
	{
		if(fForce)
			// forcing validation - reset ProductID
			SetProperty(*MsiString(*IPROPNAME_PRODUCTID),g_MsiStringNull);
		else
			// not forcing validation, and pid already validated, so just return
			return fTrue;
	}

	MsiString strTemplate(GetPropertyFromSz(IPROPNAME_PIDTEMPLATE));
	MsiString strOut;
	MsiString strFirst;
	if (strTemplate.Compare(iscWithin, TEXT("<")))
	{
		strFirst = strTemplate.Extract(iseUpto, '<');
		if (strFirst.TextSize())
			strFirst += MsiString(*TEXT("-"));
		strTemplate.Remove(iseIncluding, '<');
	}
	MsiString strLast;
	if (strTemplate.Compare(iscWithin, TEXT(">")))
	{
		strLast = strTemplate.Extract(iseAfter, '>');
		if (strLast.TextSize())
			strLast = MsiString(*TEXT("-")) + strLast;
		strTemplate.Remove(iseFrom, '>');
	}
	MsiString strBack;
	if (strFirst.TextSize())
	{
		strBack = ValidatePIDSegment(*strFirst, fFalse);
		if (strBack.TextSize())
			strOut += strBack;
		else
			return fFalse;
	}
	strBack = ValidatePIDSegment(*strTemplate, fTrue);
	if (strBack.TextSize())
		strOut += strBack;
	else
		return fFalse;
	if (strLast.TextSize())
	{
		strBack = ValidatePIDSegment(*strLast, fFalse);
		if (strBack.TextSize())
			strOut += strBack;
		else
			return fFalse;
	}
	MsiString strNull;
	AssertNonZero(SetProperty(*MsiString(*IPROPNAME_PRODUCTID), *strOut));
	return fTrue;
}

const IMsiString& CMsiEngine::ValidatePIDSegment(const IMsiString& ristrSegment, Bool fUser)
{
	MsiString strNull;
	MsiString strOut;
	ristrSegment.AddRef();
	MsiString strIn;
	if (fUser)
		strIn = GetPropertyFromSz(IPROPNAME_PIDKEY);
	MsiString strTemplate(ristrSegment);
	MsiString strCurrentTemplate;
	MsiString strCurrentIn;
	MsiString strCheckSum;
	Bool fUpdateFound =  fFalse;
	int iRandomMask = 1;
	Bool fNeedUserEntry = ToBool(strTemplate.Compare(iscWithin, TEXT("#")) || strTemplate.Compare(iscWithin, TEXT("%")) ||
		strTemplate.Compare(iscWithin, TEXT("=")) || strTemplate.Compare(iscWithin, TEXT("^")) ||
		strTemplate.Compare(iscWithin, TEXT("&")) || strTemplate.Compare(iscWithin, TEXT("?")));
	if (fUser && fNeedUserEntry && strIn.TextSize() != strTemplate.TextSize())
		strTemplate = strNull;
	while (strTemplate.TextSize())
	{
		strCurrentTemplate = strTemplate.Extract(iseFirst, 1);
		strTemplate.Remove(iseFirst, 1);
		strCurrentIn = strIn.Extract(iseFirst, 1);
		strIn.Remove(iseFirst, 1);
		if (MsiString(*TEXT("#%")).Compare(iscWithin, strCurrentTemplate))
		{
			if (!fUser) // can occur only in the user visible part
			{
				strOut = strNull;
				break;
			}
			int iCurrent = strCurrentIn;
			if (iCurrent == iMsiNullInteger) // not an integer
			{
				strOut = strNull;
				break;
			}
			strOut += strCurrentIn;
			if (MsiString(*TEXT("%")).Compare(iscExact, strCurrentTemplate))
				strCheckSum += strCurrentIn;
		}
		else if (MsiString(*TEXT("@")).Compare(iscExact, strCurrentTemplate))
		{
			if (fUser && fNeedUserEntry)  // should not be in the user visible part
			{
				strOut = strNull;
				break;
			}
			unsigned int uiTick = WIN::GetTickCount();
			uiTick /= iRandomMask;
			iRandomMask *= 10;
			strOut += MsiString(int(uiTick) % 10);
		}
		else if (MsiString(*TEXT("=")).Compare(iscExact, strCurrentTemplate))
		{
			if (!fUser || fUpdateFound) // can occur only in the user visible part and only once
			{
				strOut = strNull;
				break;
			}
			fUpdateFound = fTrue;
			AssertNonZero(SetProperty(*MsiString(*IPROPNAME_CCPTRIGGER), *strCurrentIn));
			strOut += MsiString(*TEXT("-"));
		}
		else if (MsiString(*TEXT("^&")).Compare(iscWithin, strCurrentTemplate))
		{
			if (!fUser) // can appear only in the user visible part
			{
				strOut = strNull;
				break;
			}
			ICHAR ch = ((const ICHAR *)strCurrentIn)[0];
			if (!(('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')))
			{
				strOut = strNull;
				break;
			}
			if (MsiString(*TEXT("^")).Compare(iscExact, strCurrentTemplate))
				strCurrentIn.UpperCase();
			strOut += strCurrentIn;
		}
		else if (MsiString(*TEXT("?")).Compare(iscExact, strCurrentTemplate))
		{
			strOut += strCurrentIn;

		}
		else if (MsiString(*TEXT("<>")).Compare(iscWithin, strCurrentTemplate))
			// should not be any more of these left in the string
		{
			strOut = strNull;
			break;
		}
		else
		{
			if (!fUser || !fNeedUserEntry || strCurrentTemplate.Compare(iscExact, strCurrentIn)) // literal constant should match exactly
			{
				strOut += strCurrentTemplate;
			}
			else
			{
				strOut += strNull;
				break;
			}
		}
	}
	if (fUser && strCheckSum.TextSize() && !PIDCheckSum(*strCheckSum))
	{
		strOut = strNull;
	}
	const IMsiString* piStr = strOut;
	piStr->AddRef();
	return *piStr;
}

Bool CMsiEngine::PIDCheckSum(const IMsiString& ristrDigits)
{
	int iDigit = 0;
	int iSum = 0;
	const ICHAR* pch;
	pch = ristrDigits.GetString();
	while (*pch)
	{
		iDigit = *pch - '0';
		iSum += iDigit;
		pch++;
	}
	return ToBool(!(iSum % 7));
}

CMsiFile* CMsiEngine::GetSharedCMsiFile()
{
	if (TestAndSet(&m_fcmsiFileInUse))
	{
		AssertSz(fFalse, "Two users of the shared CMsiFile");
		return 0;
	}

	if (m_pcmsiFile == 0)
	{
		m_pcmsiFile = new CMsiFile(*this);
	}

	return m_pcmsiFile;


}

void CMsiEngine::ReleaseSharedCMsiFile()
{

	m_fcmsiFileInUse = 0;

}

//____________________________________________________________________________
//
// SelectLanguage handler
//____________________________________________________________________________

BOOL CALLBACK
SelectProc(HWND pWnd, unsigned int msg, WPARAM wParam, LPARAM lParam)
{
	if (msg == WM_CLOSE)
	{
		::PostQuitMessage(islUserExit);
		return TRUE;
	}
	else if (msg == WM_COMMAND)
	{
		::PostQuitMessage(LOWORD(wParam));  // control ID == language index
		return TRUE;
	}
	else if (msg == WM_SETFOCUS)
	{
#ifdef _WIN64
		WIN::SetFocus((HWND)WIN::GetWindowLongPtr(pWnd, GWLP_USERDATA));
#else                   //!!merced: win-32. The following should be removed with the 64-bit windows.h is #included.
		WIN::SetFocus((HWND)WIN::GetWindowLong(pWnd, GWL_USERDATA));
#endif
		return 0;
	}
	else if (msg == WM_CTLCOLORSTATIC)  // prevent gray background

#ifdef _WIN64
		return (BOOL)PtrToLong(::GetStockObject(HOLLOW_BRUSH));
#else                   //!!merced: win-32. This should be removed with the 64-bit windows.h is #included.
		return (BOOL)::GetStockObject(HOLLOW_BRUSH);
#endif

	return ::DefWindowProc(pWnd, msg, wParam, lParam);
}

const int   cMaxLanguages = 10;
const ICHAR szClassName[] = TEXT("MsiSelectLanguage");

int CMsiEngine::SelectLanguage(const ICHAR* szLangList, const ICHAR* szCaption)
{
	if (!szLangList)
		return islSyntaxError;

	WNDCLASS wc;
	wc.style         = 0;
	wc.lpfnWndProc   = (WNDPROC)SelectProc;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = g_hInstance;
	wc.hIcon         = 0; //LoadIcon (hInstRes, MAKEINTRESOURCE (IDR_?));
	wc.hCursor       = LoadCursor (0, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
	wc.lpszMenuName  = 0;
	wc.lpszClassName = szClassName;
	if (!WIN::RegisterClass(&wc))
		return islSystemError;

	int cXPixels = WIN::GetSystemMetrics(SM_CXSCREEN);
	int cYPixels = WIN::GetSystemMetrics(SM_CYSCREEN);
	int iWindowStyle = szCaption ? WS_POPUP | WS_VISIBLE | WS_CAPTION
										  : WS_POPUP | WS_VISIBLE | WS_DLGFRAME;
	HWND pWnd = WIN::CreateWindow(szClassName, szCaption, iWindowStyle,
							cXPixels/2, cYPixels/2, 0, 0, g_MessageContext.GetCurrentWindow(), 0, g_hInstance, 0);  // no size initially
	if (pWnd == 0)
		return islSystemError;

	islEnum islReturn = islNoneSupported;
	int cLang = 0;      // number of valid languages
	int iMaxNative = 0;
	int iMaxLocal  = 0;
	int iMaxHeight = 0;
	int iXMargin, iYMargin;
	ICHAR rgchLangInfo[80];
	int iLangId = 0;
	int rgiLangId[cMaxLanguages];
	HWND rghButton[cMaxLanguages];
	HFONT rghFont[cMaxLanguages];
	HFONT hfontLocal;
	SIZE size;
	HDC hDC = WIN::GetDC(pWnd);
	while (cLang < cMaxLanguages)
	{
		int cb;
		int ch = *szLangList++;
		if (ch == ILANGUAGE_DELIMITER || ch == 0)
		{
			if (iLangId == 0)  // empty lang field
			{
				islReturn = islSyntaxError;
				cLang = 0;
				break;
			}
			if (iLangId >= 0
			 && (cb = WIN::GetLocaleInfo(iLangId, LOCALE_SNATIVELANGNAME, rgchLangInfo, sizeof(rgchLangInfo))) > 0)
			{
				rgiLangId[cLang++] = iLangId;  // add to list if supported
				if (!WIN::GetTextExtentPoint32(hDC, rgchLangInfo, cb, &size))
					return islSystemError;  // should never happen
				if (size.cx > iMaxNative) iMaxNative = size.cx;
				if (size.cy > iMaxHeight) iMaxHeight = size.cy;
				cb = WIN::GetLocaleInfo(iLangId, LOCALE_SLANGUAGE, rgchLangInfo, sizeof(rgchLangInfo));
				WIN::GetTextExtentPoint32(hDC, rgchLangInfo, cb, &size);
				if (size.cx > iMaxLocal) iMaxLocal = size.cx;
			}
			iLangId = 0;  // reset for next language
			if (ch == 0)
				break;
		}
		else if (iLangId >= 0)
		{
			if (ch == ' ')
				continue;
			ch -= '0';
			if ((unsigned)ch > 9)
			{
				islReturn = islSyntaxError;
				cLang = 0;
				break;
			}
			iLangId = iLangId * 10 + ch;
		}
	}
	WIN::GetTextExtentPoint32(hDC, TEXT("XX"), 2, &size);
	iXMargin = size.cx;
	WIN::ReleaseDC(pWnd, hDC);
	if (cLang > 0)  // some valid languages, else return code already set
	{
		int iButtonWidth = iMaxNative + iXMargin;
		int iButtonHeight = (iMaxHeight * 7) / 4;
		iYMargin = iButtonHeight/4;
		int iWindowWidth = iButtonWidth + iMaxLocal + iXMargin * 3;
		int iWindowHeight = (iButtonHeight + iYMargin) * cLang + iYMargin;
		if (szCaption)
		{
			iWindowWidth  += WIN::GetSystemMetrics(SM_CXBORDER) * 2;
			iWindowHeight += WIN::GetSystemMetrics(SM_CYBORDER) + WIN::GetSystemMetrics(SM_CYCAPTION);
		}
		else
		{
			iWindowWidth  += WIN::GetSystemMetrics(SM_CXDLGFRAME) * 2;
			iWindowHeight += WIN::GetSystemMetrics(SM_CYDLGFRAME) * 2;
		}
		WIN::MoveWindow(pWnd, (cXPixels - iWindowWidth) / 2, (cYPixels - iWindowHeight) / 2,
						 iWindowWidth, iWindowHeight, TRUE);
		int iButtonStyle = WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON;
		hfontLocal = MsiCreateFont(WIN::GetACP());   // for strings in local language, need to set font for Win9X
		for (INT_PTR iButton = 0; iButton < cLang; iButton++)                           //--merced: changed int to INT_PTR to get rid of warning. To Fix this.
		{
			WIN::GetLocaleInfo(rgiLangId[iButton], LOCALE_SNATIVELANGNAME, rgchLangInfo, sizeof(rgchLangInfo));
			if ((rghButton[iButton] = WIN::CreateWindow(TEXT("BUTTON"), rgchLangInfo, iButtonStyle,
													iXMargin, (iButtonHeight + iYMargin) * iButton + iYMargin,
													iButtonWidth, iButtonHeight, pWnd,
													(HMENU)(iButton + 1), g_hInstance, 0)) == 0)
				return islSystemError;  // should never happen
			WIN::GetLocaleInfo(rgiLangId[iButton], LOCALE_SLANGUAGE, rgchLangInfo, sizeof(rgchLangInfo));
			HWND hwnd = WIN::CreateWindowEx(WS_EX_TRANSPARENT,TEXT("STATIC"), rgchLangInfo, WS_CHILD | WS_VISIBLE,
								iXMargin * 2 + iButtonWidth, (iButtonHeight + iYMargin) * iButton + iButtonHeight/2,
								iMaxLocal, iButtonHeight, pWnd, (HMENU)-1, g_hInstance, 0);
			if (hfontLocal)
				WIN::SendMessage(hwnd, WM_SETFONT, (WPARAM)hfontLocal, MAKELPARAM(TRUE, 0));
			unsigned int iCodepage = MsiGetCodepage(rgiLangId[iButton]);
			if (iCodepage && (rghFont[iButton] = MsiCreateFont(iCodepage)) != 0)
				WIN::SendDlgItemMessage(pWnd, iButton+1, WM_SETFONT, (WPARAM)rghFont[iButton], MAKELPARAM(TRUE, 0));
		}
		MSG msg;
		int iFocus = -1;  // incremented to set initial focus to 1st language
		msg.message = WM_KEYDOWN;  // force message to set initial focus
		msg.hwnd = 0;    // not a real message
		msg.wParam = 0;
		g_MessageContext.DisableTimeout();
		do
	   {
//                      if (msg.pwnd)
//                              WIN::TranslateMessage(&msg); // needed only to support other windows
			if (msg.message == WM_KEYUP && msg.wParam == VK_ESCAPE)
			{
				msg.hwnd = 0;
			}
			if (msg.message == WM_KEYDOWN)
			{
				int iNext = 0;
				switch (msg.wParam)
				{
				case 0:
				case VK_DOWN:
					iNext = 1;
					break;
				case VK_UP:
					iNext = cLang - 1;
					break;
				case VK_TAB:
					iNext = WIN::GetKeyState(VK_SHIFT) < 0 ? cLang - 1 : 1;
					break;
				case VK_ESCAPE:
					WIN::SendMessage(pWnd, WM_CLOSE, 0, 0);
					msg.hwnd = 0;  // prevent dispatch to VBA //!! still causes program break!
					break;
				case VK_RETURN:
					WIN::SendMessage(pWnd, WM_COMMAND, iFocus + 1, 0);
					break;
				};
				if (iNext)
				{
					iFocus += iNext;
					if (iFocus >= cLang)
						iFocus -= cLang;
#ifdef _WIN64
					HWND pWndPrev = (HWND)WIN::GetWindowLongPtr(pWnd, GWLP_USERDATA);
#else                   //!!merced: win-32. This should be removed with the 64-bit windows.h is #included.
					HWND pWndPrev = (HWND)WIN::GetWindowLong(pWnd, GWL_USERDATA);
#endif
					if (pWndPrev)
						WIN::SendMessage(pWndPrev, BM_SETSTYLE, BS_PUSHBUTTON, TRUE);
					WIN::SetFocus(rghButton[iFocus]);
#ifdef _WIN64
					WIN::SetWindowLong(pWnd, GWLP_USERDATA, (LONG_PTR)rghButton[iFocus]);
#else                   //!!merced: win-32. This should be removed with the 64-bit windows.h is #included.
					WIN::SetWindowLong(pWnd, GWL_USERDATA, (LONG)rghButton[iFocus]);
#endif
					WIN::SendMessage(rghButton[iFocus], BM_SETSTYLE, BS_DEFPUSHBUTTON, TRUE);

				}
			}
			if (msg.hwnd) //!! test not necessary, as ::DispatchMessage ignore if no pWnd
				WIN::DispatchMessage(&msg);
	   } while (WIN::GetMessage(&msg, 0, 0, 0));
		islReturn = (islEnum)msg.wParam; // arg from ::PostQuitMessage
		g_MessageContext.EnableTimeout();
	}
	MsiDestroyFont(hfontLocal);
	for (INT_PTR iButton = 0; iButton < cLang; iButton++)                           //--merced: changed int to INT_PTR to get rid of warning. To Fix this.
		MsiDestroyFont(rghFont[iButton]);
	WIN::DestroyWindow(pWnd);
	WIN::UnregisterClass(szClassName, g_hInstance);  // optional, will happen at app exit
	return islReturn;
}

//____________________________________________________________________________
//
// Internal engine methods
//____________________________________________________________________________

/*----------------------------------------------------------------------------
CMsiEngine::ValidateTransform - Returns ievtTransformValie if the given transform is a
storage, and the database meets all requirements that the transform specifies
(version, language, product, etc.)  iTransErrors will be set to conditions
specified by the transform to be treated as errors. (iteXXXX flags)

  if fCallSAFER is true, performs a SaferIdentifyLevel call on the transform;
   - tranform must pass SAFER check to return fTrue
------------------------------------------------------------------------------*/
ievtEnum CMsiEngine::ValidateTransform(IMsiStorage& riStorage, const ICHAR* szProductKey,
											  const ICHAR* szProductVersion, const ICHAR* szUpgradeCode,
											  int& iTransErrorConditions, bool fCallSAFER, const ICHAR* szFriendlyName, bool fSkipValidation,
											  int* piTransValidationConditions)
{
	PMsiRecord pError(0);
	int iTransRestrictions = 0;

	if (piTransValidationConditions)
		*piTransValidationConditions = 0;

	MsiString strTransform;
	AssertRecord(riStorage.GetName(*&strTransform));

	PMsiSummaryInfo pTransSummary(0);
	if ((pError = riStorage.CreateSummaryInfo(0, *&pTransSummary)))
	{
		pError = PostError(Imsg(idbgTransformCreateSumInfoFailed), *strTransform);
		Message(imtInfo,*pError);
		return ievtTransformFailed;
	}

	// check that the storage is actually an MSI transform
	if (!riStorage.ValidateStorageClass(ivscTransform))
		return ievtTransformFailed;
	

	// perform SAFER policy check
	if (fCallSAFER)
	{
		SAFER_LEVEL_HANDLE hSaferLevel = 0;
		if (!VerifyMsiObjectAgainstSAFER(m_riServices, &riStorage, strTransform, /* szFriendlyName = */ szFriendlyName, stTransform, /* phSaferLevel = */ &hSaferLevel))
			return ievtTransformRejected;
		AssertNonZero(UpdateSaferLevelInMessageContext(hSaferLevel));
	}


	int iTransMsiVersion = 0;
	
	MsiString istrTransTemplate(pTransSummary->GetStringProperty(PID_TEMPLATE));
	MsiString istrTransRevNumber(pTransSummary->GetStringProperty(PID_REVNUMBER));
	iTransRestrictions = 0;
	pTransSummary->GetIntegerProperty(PID_CHARCOUNT, iTransRestrictions);
	
	if (pTransSummary->GetIntegerProperty(PID_PAGECOUNT, iTransMsiVersion) == fFalse)
	{
		pError = PostError(Imsg(idbgTransformLacksMSIVersion), *strTransform);
		Message(imtInfo,*pError);
		return ievtTransformFailed;
	}
	
	// check the engine and services versions against that required by transform
	if (iTransMsiVersion < iVersionEngineMinimum || iTransMsiVersion > iVersionEngineMaximum)
	{
		pError = PostError(Imsg(idbgTransformIncompatibleVersion), *strTransform, *MsiString(iTransMsiVersion),
							iVersionEngineMinimum, iVersionEngineMaximum);
		Message(imtInfo,*pError);
		return ievtTransformFailed;
	}

	int iTransValidation = (0xFFFF0000 & iTransRestrictions) >> 16;
	if (piTransValidationConditions)
		*piTransValidationConditions = iTransValidation;

	iTransErrorConditions = iTransRestrictions & 0xFFFF;

	if(fSkipValidation)
	{
		DEBUGMSG1(TEXT("Skipping transform validation for '%s'"), strTransform);
		return ievtTransformValid;
	}

	ICHAR rgchBits[9];
	wsprintf(rgchBits,TEXT("%#x"),iTransValidation);
	DEBUGMSG2(TEXT("Validating transform '%s' with validation bits %s"),strTransform,rgchBits);

	if (iTransValidation & itvLanguage)
	{
		MsiString istrTransLanguage = istrTransTemplate.Extract(iseAfter, ISUMMARY_DELIMITER);
		if ((int)istrTransLanguage != GetLanguage())
		{
			pError = PostError(Imsg(idbgTransformInvalidLanguage),*strTransform,*m_strPackagePath,
									 (int)istrTransLanguage,GetLanguage());
			DEBUGMSG(MsiString(pError->FormatText(fTrue)));
			Message(imtInfo,*pError);
			return ievtTransformFailed;
		}
	}
	if (iTransValidation & itvProduct)
	{
		MsiString istrTransProductCode(istrTransRevNumber.Extract(iseFirst, 38));
		if (istrTransProductCode.Compare(iscExactI, szProductKey) == fFalse)
		{
			pError = PostError(Imsg(idbgTransformInvalidProduct),*strTransform,*m_strPackagePath,
									 *istrTransProductCode,*MsiString(szProductKey));
			DEBUGMSG(MsiString(pError->FormatText(fTrue)));
			Message(imtInfo,*pError);
			return ievtTransformFailed;
		}
	}

	if (iTransValidation & itvUpgradeCode)
	{
		MsiString istrUpgradeCode = istrTransRevNumber;
		istrUpgradeCode.Remove(iseIncluding, ';'); // remove old product code & version
		unsigned int cch = istrUpgradeCode.TextSize();
		istrUpgradeCode.Remove(iseIncluding, ';'); // remove new product code & version
		
		if (istrUpgradeCode.TextSize() != cch)
		{
			if (istrUpgradeCode.Compare(iscExactI, szUpgradeCode) == fFalse)
			{
				pError = PostError(Imsg(idbgTransformInvalidUpgradeCode),*strTransform,*m_strPackagePath,
										 *istrUpgradeCode,*MsiString(szUpgradeCode));
				DEBUGMSG(MsiString(pError->FormatText(fTrue)));
				Message(imtInfo,*pError);
				return ievtTransformFailed;
			}
		}
		// else there was no 2nd ';' and therefore no upgrade code
	}

#if 0 //!! malcolmh
	if (iTransValidation & itvPlatform)
	{
		MsiString istrTransPlatform = istrTransTemplate.Extract(iseUpto, ISUMMARY_DELIMITER);
		if (GetPropertyInt(istrTransPlatform) == iMsiNullInteger)
		{
			wsprintf(rgchLogMessage, szInvalidPlatform, (const ICHAR*)istrTransPlatform);
			DEBUGMSG(rgchLogMessage);
			ENG::WriteLog(rgchLogMessage);
			return ievtTransformFailed;
		}
	}
#endif
	if ((iTransValidation & (itvMajVer|itvMinVer|itvUpdVer)) != 0)
	{
		MsiString istr  = istrTransRevNumber;
		istr.Remove(iseFirst, 38); // remove old product code
		MsiString istrTransAppVersion = istr.Extract(iseUpto, ';');

		unsigned int iAppVersion      = ProductVersionStringToInt(szProductVersion);
		unsigned int iTransAppVersion = ProductVersionStringToInt(istrTransAppVersion);

		if(iTransValidation & itvMajVer)
		{
			iAppVersion &= 0xFF000000;
			iTransAppVersion &= 0xFF000000;
		}
		else if(iTransValidation & itvMinVer)
		{
			iAppVersion &= 0xFFFF0000;
			iTransAppVersion &= 0xFFFF0000;
		}
		// else itvUpdVer: don't need to mask off bits

		if (iTransValidation & itvLess)
		{
			if (!(iAppVersion < iTransAppVersion))
			{
				pError = PostError(Imsg(idbgTransformInvalidLTVersion),*strTransform,*m_strPackagePath,
										 *istrTransAppVersion,*MsiString(szProductVersion));
				DEBUGMSG(MsiString(pError->FormatText(fTrue)));
				Message(imtInfo,*pError);
				return ievtTransformFailed;
			}
		}
		else if (iTransValidation & itvLessOrEqual)
		{
			if (!(iAppVersion <= iTransAppVersion))
			{
				pError = PostError(Imsg(idbgTransformInvalidLEVersion),*strTransform,*m_strPackagePath,
										 *istrTransAppVersion,*MsiString(szProductVersion));
				DEBUGMSG(MsiString(pError->FormatText(fTrue)));
				Message(imtInfo,*pError);
				return ievtTransformFailed;
			}
		}
		else if (iTransValidation & itvEqual)
		{
			if (!(iAppVersion == iTransAppVersion))
			{
				pError = PostError(Imsg(idbgTransformInvalidEQVersion),*strTransform,*m_strPackagePath,
										 *istrTransAppVersion,*MsiString(szProductVersion));
				DEBUGMSG(MsiString(pError->FormatText(fTrue)));
				Message(imtInfo,*pError);
				return ievtTransformFailed;
			}
		}
		if (iTransValidation & itvGreaterOrEqual)
		{
			if (!(iAppVersion >= iTransAppVersion))
			{
				pError = PostError(Imsg(idbgTransformInvalidGEVersion),*strTransform,*m_strPackagePath,
										 *istrTransAppVersion,*MsiString(szProductVersion));
				DEBUGMSG(MsiString(pError->FormatText(fTrue)));
				Message(imtInfo,*pError);
				return ievtTransformFailed;
			}
		}
		else if (iTransValidation & itvGreater)
		{
			if (!(iAppVersion > iTransAppVersion))
			{
				pError = PostError(Imsg(idbgTransformInvalidGTVersion),*strTransform,*m_strPackagePath,
										 *istrTransAppVersion,*MsiString(szProductVersion));
				DEBUGMSG(MsiString(pError->FormatText(fTrue)));
				Message(imtInfo,*pError);
				return ievtTransformFailed;
			}
		}
	}
	DEBUGMSG1(TEXT("Transform '%s' is valid."), strTransform);
	return ievtTransformValid;
}

#ifndef UNICODE
// from execute.cpp
extern IMsiRecord* GetSecureTransformCachePath(IMsiServices& riServices, 
										const IMsiString& riProductKey, 
										IMsiPath*& rpiPath);

IMsiRecord* GetSecureTransformPath(const IMsiString& riTransformName, 
								   const IMsiString& riProductKey, 
								   const IMsiString*& rpiSecurePath, IMsiServices& riServices)
{
	IMsiRecord* piError = 0; 
	
	PMsiPath pSecureTransformCachePath(0);
	if ((piError = GetSecureTransformCachePath(riServices, 
		riProductKey, 
		*&pSecureTransformCachePath)) != 0)
		return piError;

	MsiString strSecurePath = pSecureTransformCachePath->GetPath();
	strSecurePath += riTransformName;

	strSecurePath.ReturnArg(rpiSecurePath);
	return 0;
}
#endif

IMsiRecord* ExpandShellFolderTransformPath(const IMsiString& riOriginalPath, const IMsiString*& riExpandedPath, IMsiServices& riServices)
{
	IMsiRecord* piError = 0;
	MsiString strExpandedPath = riOriginalPath;
	riOriginalPath.AddRef();
	
	strExpandedPath.Remove(iseFirst, 1);
	MsiString strCSIDL = strExpandedPath.Extract(iseUpto, MsiChar(SHELLFOLDER_TOKEN));
	strExpandedPath.Remove(iseIncluding, MsiChar(SHELLFOLDER_TOKEN));

	Assert((int)strCSIDL != iMsiStringBadInteger);
	MsiString strShellFolderPath;
	if ((piError = riServices.GetShellFolderPath(strCSIDL, false, *&strShellFolderPath)) != 0)
		return piError;

	Assert(strShellFolderPath.TextSize());
	strShellFolderPath += strExpandedPath;
	strExpandedPath = strShellFolderPath;
	strExpandedPath.ReturnArg(riExpandedPath);
	return piError;
}

/*----------------------------------------------------------------------------
CMsiEngine::InitializeTransforms - Parses the TRANSFORMS property, setting
each transform.
------------------------------------------------------------------------------*/
ieiEnum CMsiEngine::InitializeTransforms(IMsiDatabase& riDatabase, IMsiStorage* piStorage,
												  const IMsiString& riTransforms,
												  Bool fValidateAll, const IMsiString** ppistrValidTransforms,
												  bool fTransformsFromPatch,
												  bool fProcessingInstanceMst,
#ifdef UNICODE
												  bool fUseLocalCacheForSecureTransforms,
#else
												  bool, // unused on Win9X
#endif
												  int *pcTransformsProcessed,
												  const ICHAR* szSourceDir,
												  const ICHAR* szCurrentDirectory,
												  const IMsiString** ppistrRecacheTransforms,
												  tsEnum *ptsTransformsSecure,
												  const IMsiString **ppistrProcessedTransformsList)


	// piStorage:
	//    if set, it contains transform substorages, otherwise transforms are in riDatabase
	// pcTransformsProcessed:
	//    the count of how many transforms in the list have been processed so far
	// ppistrProcessedTransformsList:
	//    We might munge the transform list as we're processing it. For example if we're
	//    given a full path but the TransformsAtSource policy is set then we'll chop off
	//    everything but the file name. If we're given just the file name but the
	//    transforms secure policy is set then we'll prepend the source directory.
	//    After we're done pistrProcessedTransformsList will contain the processed
	//    (or munged) version of the transform list. The list will reflect any chopping
	//    of paths or prepending of paths.
	//
{

	// whether or not a SAFER check is performed on transform (via ValidateTransform)
	// turned off if transform is cached or is a substorage
	bool fCallSAFER = true;


	MsiString strProcessedTransformsList;

	// In case this function was called for the second time we'll start our
	// list with whatever we had the last time this function was called.
	// IMPORTANT NOTE: because ppistrProcessedTransformsList is an output
	// argument, it also has an external refcount.  Using strProcessedTransformsList
	// inherits this refcount so a release on the outside would be a double-free.
	// Therefore, we need to always use:
	//			if (ppistrProcessedTransformsList)
	//				strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
	// wherever we have a return from this function so that we ensure that the refcount
	// is accurate

	if (ppistrProcessedTransformsList)
		strProcessedTransformsList = **ppistrProcessedTransformsList;

	MsiString istrTransformList(riTransforms); riTransforms.AddRef();
	if (istrTransformList.TextSize() != 0)
	{
		const ICHAR* pchTransformList = istrTransformList;
		MsiString istrTransform(*TEXT(""));
		CTempBuffer<ICHAR, 100> cBuffer;
		cBuffer.SetSize(istrTransformList.TextSize() + 1);
		if ( ! (ICHAR *) cBuffer )
		{
			if (ppistrProcessedTransformsList)
				strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
			return ieiTransformFailed;
		}
		ICHAR *pchTransform = cBuffer;
		PMsiRecord pError(0);
		
		MsiString strCurrentDirectory = szCurrentDirectory;

		bool fEmbeddedTransform = false;
		bool fCachedTransform = false;
		ievtEnum ievt = ievtTransformValid;
		int cTransforms = 0;
		bool fSmallUpdatePatch = false;
		bool fMissingVersionValidationMinorUpdatePatch = false;
		for (;;)
		{
			// Find the next transform to process. If pcTransformProcessed is set then
			// *pcTransformProcessed is the number of transforms we already processed
			// during the last call to this function. We'll skip those transforms
			// this time around.
			do {
				ICHAR *pch = pchTransform;
				*pch = 0;
				while (*pchTransformList == ' ') // eat spaces
					pchTransformList++;

				while ( (*pchTransformList != 0) && (*pchTransformList != ';') )
					*pch++ = *pchTransformList++;

				if (*pchTransformList == ';')
					pchTransformList++;

				*pch = 0; // null terminate
			} while (pcTransformsProcessed != 0 && cTransforms++ < *pcTransformsProcessed);

			MsiString strCurrentProcessTransform;
	
			if (*pchTransform != 0)
			{
				PMsiStorage pTransStorage(0);
				MsiString strTransform;

				// Skip the secure token, if present. We'll rely soly on
				// ptsTransformsSecure to determine whether or not we have
				// secure transforms.
				if (*pchTransform == SECURE_RELATIVE_TOKEN || *pchTransform == SECURE_ABSOLUTE_TOKEN)
				{
					// Skip the secure token
					pchTransform++;
				}

				// Next we need to actually open the transform storage. For
				// storage transforms this is easy -- we simply attempt
				// to open a child storage. For other types of transforms we
				// have to do a bit more work.

				bool fPatchTransform = false;

				if (*pchTransform == STORAGE_TOKEN) // child storage
				{
					// need to turn off digital signature check below
					fEmbeddedTransform = true;

					// Storage transforms are added to the processed list
					// with their STORAGE_TOKEN intact

					if (strProcessedTransformsList.TextSize() > 1)
						strProcessedTransformsList += MsiChar(';');
					strProcessedTransformsList += pchTransform;

					strTransform = pchTransform+1; // skip the storage token
					DEBUGMSG1(TEXT("Looking for storage transform: %s"), strTransform);

					if(*((const ICHAR*)strTransform) == PATCHONLY_TOKEN)
						fPatchTransform = true;

					PMsiStorage pDbStorage(0);
					if(piStorage)
					{
						pDbStorage = piStorage;
						piStorage->AddRef();
					}
					else
						pDbStorage = riDatabase.GetStorage(1);

					if (pDbStorage == 0)
						pError = PostError(Imsg(idbgNoTransformAsChild),*strTransform,*m_strPackagePath);
					else
						pError = pDbStorage->OpenStorage(strTransform, ismReadOnly, *&pTransStorage);

					if(pError)
					{
						if (ppistrProcessedTransformsList)
							strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
						return PostInitializeError(pError,*strTransform,ieiTransformFailed);
					}
					Assert(pTransStorage);
				}
				else // transform is in a file either locally or at the source
				{
					MsiString strFileTransform = pchTransform;

					// We potentially go through this loop twice to accomodate
					// missing transforms. This first time through we'll look
					// in the expected location for the transform, i.e. cached
					// somewhere on the user's machine. If we can't find the
					// transform on the user's machine then we'll go through
					// a second time and we'll look at the original location
					// of the transform.
					for (int cAttempt=0; cAttempt<2; cAttempt++)
					{
						if (*(const ICHAR*)strFileTransform == SHELLFOLDER_TOKEN) // transform is cached
						{
							// Shell-folder cached transfoms are easy. All we need to
							// do is expand the *26*... format into a full path.

							// transform is cached on machine, so no SAFER check is needed
							fCachedTransform = true;

							strCurrentProcessTransform = strFileTransform;

							if ((pError = ExpandShellFolderTransformPath(*strFileTransform, *&strTransform, m_riServices)))
							{
								if (ppistrProcessedTransformsList)
									strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
								return PostInitializeError(pError, *strFileTransform, ieiTransformNotFound);
							}

							DEBUGMSG1(TEXT("Looking for file transform in shell folder: %s"), (const ICHAR*)strTransform);
						}
						else if (ptsTransformsSecure && (*ptsTransformsSecure != tsNo)) // we have some type of secure transform
						{
							// First time around we look for the secure transform on the
							// user's machine in the secure transform cache.
							if (cAttempt == 0)
							{
								// We know that we have a secure transform of some form.
								// If the form is unknown we'll determine it now, based
								// on what type of path the transform has. Otherwise
								// we'll simply ensure that the path-type of our
								// transform matches the form of secure transforms
								// that we're using.
								iptEnum iptTransform = PathType(strFileTransform);
								switch (*ptsTransformsSecure)
								{
								case tsUnknown:
									if (iptTransform == iptFull)
										*ptsTransformsSecure = tsAbsolute;
									else
										*ptsTransformsSecure = tsRelative;
									break;
								case tsRelative:
									if (iptTransform != iptRelative)
									{
										if (ppistrProcessedTransformsList)
											strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
										return PostInitializeError(0, *strTransform, ieiTransformFailed);
									}
									break;
								case tsAbsolute:
									if (iptTransform != iptFull)
									{
										if (ppistrProcessedTransformsList)
											strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
										return PostInitializeError(0, *strTransform, ieiTransformFailed);
									}
									break;
								default:
									AssertSz(0, TEXT("Unknown secure transform type"));
								}
								
								// We register the transform as-is (with either a full
								// or relative path).
								strCurrentProcessTransform = strFileTransform;
#ifdef UNICODE
								if(fUseLocalCacheForSecureTransforms)
								{
									// check to see if the transform is cached locally
									// check for the transform registration and path
									MsiString strCurrentProductCode = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);
									CRegHandle HKey;
									DWORD dwResult = OpenInstalledProductTransformsKey(strCurrentProductCode, HKey, false);
									if (ERROR_SUCCESS == dwResult)
									{
										// check for the appropriate registration
										CAPITempBuffer<ICHAR, MAX_PATH> szCachedTransform;
										if (ERROR_SUCCESS == MsiRegQueryValueEx(HKey, strFileTransform, 0, 0, szCachedTransform, 0))
										{
											// use the cached transform filename
											MsiString strCachePath = GetMsiDirectory();
											Assert(strCachePath.TextSize());
											PMsiPath pTransformPath(0);
											if((pError = m_riServices.CreatePath(strCachePath,*&pTransformPath)) != 0)
											{
												if (ppistrProcessedTransformsList)
													strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
												return PostInitializeError(pError, *strTransform, ieiTransformFailed);
											}
											if((pError = pTransformPath->GetFullFilePath(szCachedTransform,*&strTransform)))
											{
												if (ppistrProcessedTransformsList)
													strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
												return PostInitializeError(pError, *strTransform, ieiTransformFailed);
											}
	
											fCachedTransform = true;
										}
									}
								}
#else
								// While we register the full path if we have it, to
								// _find_ the transform this time around we only need
								// the file name. This is because the first time
								// around we're looking in the cache so the transforms
								// location is CACHEPATH\filename.mst
								MsiString strFileName = strFileTransform;
								if (iptTransform == iptFull)
								{
									// strip the full path off
									MsiString strDummy;
									MsiString strTemp = strFileName;
									if ((pError = SplitPath(strTemp, &strDummy, &strFileName)) != 0)
									{
										if (ppistrProcessedTransformsList)
											strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
										return PostInitializeError(pError, *strFileTransform, ieiTransformNotFound);
									}
								}

								// Now all that's left is to tack the file name onto
								// the path to the secure transforms directory for
								// this product. GetSecureTransformPath() will do this
								// for us.
								MsiString strCurrentProductCode  = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);
								if ((pError = GetSecureTransformPath(*strFileName, *strCurrentProductCode, *&strTransform, m_riServices)) != 0)
								{
									if (ppistrProcessedTransformsList)
										strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
									return PostInitializeError(pError, *strTransform, ieiTransformNotFound);
								}

								fCachedTransform = true;                        

#endif
							}
							else // cAttempt == 1 (second time around)
							{
								// If we're going around for a second time then we
								// didn't find the transforms on the user's machine.
								// We need to now look to the original location of
								// the transform. strFileTransform should have
								// already been set to the correct location by
								// the code down below so we'll simply use it as-is.

								// because it wasn't found on the machine, the SAFER check will have to be performed on the transform
								fCachedTransform = false;
								strTransform = strFileTransform;
							}

							DEBUGMSG1(TEXT("Looking for secure file transform: %s"), strTransform);
						}
						else // transform is a file transform to be cached
						{
							// The only processing we need to do on standard
							// file transforms is to make sure that they're
							// fully pathed.

							// SAFER check is required as this transform isn't cached on the machine
							fCachedTransform = false;

							CAPITempBuffer<ICHAR,MAX_PATH> rgchTransform;
							AssertNonZero(ExpandPath(strFileTransform, rgchTransform, strCurrentDirectory));
							strTransform = (const ICHAR*)rgchTransform;
							strCurrentProcessTransform = strTransform;

							DEBUGMSG1(TEXT("Looking for file transform: %s"), strTransform);
						}
						
						// We've finally reached the point where we can actually open
						// the transform! -- SAFER check is false here because we explicitly validate
						// the transform against SAFER policy down below
						// szFriendlyName is NULL because it is only needed when performing SAFER check
						// phSaferLevel is NULL because it is only needed when performing a SAFER check

						// copy the transform locally for usage if it is not from our cache location,
						// so that we don't suffer from network outages. If the transform is at a URL,
						// then it is automatically downloaded to a temp location in OpenAndValidateMsiStorageRec

						MsiString strOpenTransform = strTransform;
						if (!fCachedTransform && !IsURL(strOpenTransform, NULL))
						{
							// copy transform to temp location
							MsiString strVolume;
							Bool fRemovable = fFalse;
							DWORD dwStat = CopyTempDatabase(strTransform, *&strOpenTransform, fRemovable, *&strVolume, m_riServices, stTransform);
							if (ERROR_SUCCESS == dwStat)
							{
								// transform was copied
								DEBUGMSGV1(TEXT("Original transform ==> %s"), strTransform);
								DEBUGMSGV1(TEXT("Transform we're running from ==> %s"), strOpenTransform);

								AddFileToCleanupList(strOpenTransform);
							}
							else
							{
								strOpenTransform = strTransform;
								DEBUGMSGV1(TEXT("Unable to create a temp copy of transform '%s'."), strTransform);
							}
						}

						pError = OpenAndValidateMsiStorageRec(strOpenTransform, stTransform, m_riServices, *&pTransStorage, /* fCallSAFER = */ false, /* szFriendlyName = */ NULL, /* phSaferLevel = */ NULL);

						if (pError)
						{
							// Uh-oh. Something went wrong in opening the transform.
							if ((cAttempt == 0) &&
								  (pError->GetInteger(3) == STG_E_FILENOTFOUND ||
								   pError->GetInteger(3) == STG_E_PATHNOTFOUND))
							{
								// It's our first attempt at finding the transform and
								// the error was just that we couldn't find it. We'll
								// determine where the original location of the
								// transform is, set strFileTransform to that location,
								// and go around for a second attempt at opening
								// the transform.
								
								if (*(const ICHAR*)strFileTransform != STORAGE_TOKEN)
								{
									Assert(ptsTransformsSecure);
									if (ptsTransformsSecure)
									{
										DEBUGMSG2(TEXT("Couldn't find cached transform %s. Looking for it at the %s."), strTransform, (*ptsTransformsSecure == tsAbsolute) ? TEXT("original location") : TEXT("source"));

										// Absolutely pathed secure transforms are
										// already fully pathed. For relatively
										// pathed secure transforms, and for
										// non-secure transforms, we need to prepend
										// SOURCEDIR to the name of the transform.

										if (*ptsTransformsSecure == tsRelative ||
											 *ptsTransformsSecure == tsNo)
										{
											MsiString strSourceDir;
											if (szSourceDir && *szSourceDir)
											{
												strSourceDir = szSourceDir;
											}
											else
											{
												// Source-dir wasn't passed into this
												// function. We'll need to remedy that
												// by returning the special value
												// ieiResolveSourceAndRetry. This will
												// trigger to call us again, passing
												// in SOURCEDIR. Eventually we'll
												// end up just above here, with
												// szSourceDir set.
											
												if (ppistrProcessedTransformsList)
													strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);

												return (ieiEnum)ieiResolveSourceAndRetry;
											}
											
											PMsiPath pPath(0);
											MsiString strFileName;
											if (*ptsTransformsSecure == tsRelative)
											{
												// use the original filename NOT the temp path
												strFileName = strFileTransform;
											}
											else
											{
												if ((pError = m_riServices.CreateFilePath(strTransform, *&pPath, *&strFileName)))
												{
													if (ppistrProcessedTransformsList)
														strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
													return PostInitializeError(pError, *strTransform, ieiTransformNotFound);
												}
											}

											strFileTransform = strSourceDir;
											strFileTransform += strFileName;
										}
										else
										{
											Assert(*ptsTransformsSecure == tsAbsolute);
										}

										// let's try again
										continue;
									}
								}

								if (ppistrProcessedTransformsList)
									strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
								return PostInitializeError(pError, *strTransform, ieiTransformNotFound);
							}
							else // (cAttempt == 1) || (some error other than not finding the transform occurred)
							{
								if (ppistrProcessedTransformsList)
									strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);

								return PostInitializeError(pError, *strTransform, ieiTransformFailed);
							}
						}
						else  // pError == 0
						{
							// We've successfully opened the trasnform so we'll add
							// it to our "processed" list.
							if (strProcessedTransformsList.TextSize() > 1)
								strProcessedTransformsList += MsiChar(';');
							strProcessedTransformsList += strCurrentProcessTransform;
							strCurrentProcessTransform = *TEXT("");

							if (cAttempt==1 && ((m_iioOptions & iioCreatingAdvertiseScript) == 0))
							{
								// This was our second time around. This means that
								// we failed to find the transform on the user's machine
								// and we were forced to resort to looking to the
								// transform's original location. This implies that we
								// need to recache the trasnform, so we'll add it to
								// our re-cache list.

								Assert(ppistrRecacheTransforms);
								if (ppistrRecacheTransforms)
								{
									MsiString strRecache = **ppistrRecacheTransforms;
									
									if (strRecache.TextSize())
										strRecache += TEXT(";");

									strRecache += strTransform;
									strRecache.ReturnArg(*ppistrRecacheTransforms);

									DEBUGMSG1(TEXT("Found missing cached transform %s. Adding it to re-cache list."), strTransform);
								}
							}
						}
						break;
					}
				}
				
				// By this point we have opened the transform. We now need to
				// validate that this transform can be applied to this
				// database.

				MsiString strCurrentProductCode    = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);
				MsiString strCurrentProductVersion = GetPropertyFromSz(IPROPNAME_PRODUCTVERSION);
				MsiString strUpgradeCode           = GetPropertyFromSz(IPROPNAME_UPGRADECODE);
				if(strCurrentProductCode.TextSize() == 0 || strCurrentProductVersion.TextSize() == 0)
				{
					//!! log error
					if (ppistrProcessedTransformsList)
						strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);

					return ieiDatabaseInvalid;
				}
	
				if (pcTransformsProcessed)
					(*pcTransformsProcessed)++;

				int iTransErrorConditions = 0;
				int iTransValidationConditions = 0;

				// SAFER:
				//  -- if fCallSAFER has already been set to false, we won't perform SAFER check
				//  -- however, if fCallSAFER is true, we'll still evaluate whether or not trust check is warranted
				//  -- no trust check is warranted if at least one of the following conditions is true
				//        1. transform is an embedded transform (covered by package)
				//        2. transform is already cached securely on machine
				if (fCallSAFER)
				{
					// determine whether SAFER check still warranted
					if (fEmbeddedTransform)
						fCallSAFER = false; // turn off for transform as substorage
					if (fCachedTransform)
						fCallSAFER = false; // turn off for cached transform
				}

				if(fPatchTransform)
				{
					// don't validate patch transforms - they are accepted whenever the preceding transform is accepted
					if(ievt == ievtTransformValid)
					{
						//
						// SAFER -- no safer check is performed on patch transforms since the SAFER check is performed on the patch itself
						//          and patch transforms are embedded inside the patch (this should actually already be covered by
						//          fEmbeddedTransform, but just to drive this home...)
						//

						// only call to pull out error conditions
						ValidateTransform(*pTransStorage, strCurrentProductCode,
													 strCurrentProductVersion, strUpgradeCode,
													 iTransErrorConditions, /* fCallSAFER = */ false, /* szFriendlyName = */ strTransform, true, &iTransValidationConditions);

						DEBUGMSG1(TEXT("Skipping validation for patch transform %s.  Will apply because previous transform was valid"),
									 strTransform);
					}
					else
					{
						iTransErrorConditions = 0; // to appease the compiler - won't actually be used below

						DEBUGMSG1(TEXT("Skipping validation for patch transform %s.  Will not apply because previous transform was invalid"),
									 strTransform);
					}
				}
				else
				{
					//
					// SAFER -- regardless of whether we will call SAFER, go ahead and set the friendly name to strTransform
					//          This ensures that we get proper URL coverage since this may have been a transform at a URL location
					//

					ievt = ValidateTransform(*pTransStorage, strCurrentProductCode,
												 strCurrentProductVersion, strUpgradeCode,
												 iTransErrorConditions, fCallSAFER, /* szFriendlyName = */ strTransform, false, &iTransValidationConditions);
				}

				if(ievtTransformValid == ievt)
				{
					if ((pError = ApplyTransform(riDatabase, *pTransStorage, iTransErrorConditions, fPatchTransform, &m_ptsState)) != 0)
					{
						if (ppistrProcessedTransformsList)
							strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);

						return PostInitializeError(pError,*strTransform,ieiTransformFailed);
					}
					if(ppistrValidTransforms)
					{
						if((*ppistrValidTransforms)->TextSize())
							(*ppistrValidTransforms)->AppendString(TEXT(";"), *ppistrValidTransforms);
						(*ppistrValidTransforms)->AppendString(pchTransform, *ppistrValidTransforms);
					}

					// detect when we are applying a small update patch
					// when we are, we want to only apply the first set of transforms and then stop
					// in other words, if we are applying a patch, and we detect that one of the non-patch transforms
					// didn't change the ProductCode or ProductVersion, then we will apply the second in the set of transforms
					// (the transform where fPatchTransform == true) and then quit.
					// see Whistler bug 339781 for more info

					// detect when the transform didn't specify a check for the ProductVersion in the transform validation conditions
					// if so, and the patch transform isn't changing the product code (small update or minor update), then skip the
					// remaining set of transforms.  see Whistler bug 363989 for more info

					if(fTransformsFromPatch)
					{
						if(false == fPatchTransform)
						{
							MsiString strNewProductCode    = GetPropertyFromSz(IPROPNAME_PRODUCTCODE);
							MsiString strNewProductVersion = GetPropertyFromSz(IPROPNAME_PRODUCTVERSION);
							
							if(strNewProductCode.Compare(iscExactI, strCurrentProductCode))
							{
								MsiString strNewProductVersion = GetPropertyFromSz(IPROPNAME_PRODUCTVERSION);
								unsigned int iOldVersion = ProductVersionStringToInt(strCurrentProductVersion);
								unsigned int iNewVersion = ProductVersionStringToInt(strNewProductVersion);

								if(iOldVersion == iNewVersion)
								{
									fSmallUpdatePatch = true;
								}
								else
								{
									// check transform validation conditions and see if this is bogus minor update patch
									// that does not include version check information
									if (!(iTransValidationConditions & (itvMajVer|itvMinVer|itvUpdVer))
										|| ((iTransValidationConditions & (itvMajVer|itvMinVer|itvUpdVer))
										&& !(iTransValidationConditions & (itvLess|itvLessOrEqual|itvEqual|itvGreaterOrEqual|itvGreater))))
									{
										fMissingVersionValidationMinorUpdatePatch = true;
									}
								}
							}
						}
						else if(fSmallUpdatePatch)
						{
							DEBUGMSG("Detected that this is a 'Small Update' patch.  Any remaining transforms in the patch will be skipped.");
							break; // done processing transforms
						}
						else if (fMissingVersionValidationMinorUpdatePatch)
						{
							DEBUGMSG("Detected that this patch is a 'Minor Update' patch without product version validation. Any remaining transforms in the patch will be skipped.");
							break; // done processing transforms
						}				
					}
				}
				else if(fValidateAll)
				{
					if (ppistrProcessedTransformsList)
						strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
					return PostInitializeError(0,*strTransform, (ievtTransformFailed == ievt) ? ieiTransformFailed : ieiTransformRejected);
				}
				// else just continue on

				fEmbeddedTransform = false; // reset
				fCachedTransform = false; // reset

			}

			if (*pchTransformList == 0)
				break;
		}
	}

	// if the secure transforms type is still tsUnknown then we don't
	// actually have any secure transforms in our list.
	// We only care about this if we have completed our processing of the transforms list
	// For the multi-instance transform, our processing isn't done yet, so we can't quite make
	// this determination
	if (!fProcessingInstanceMst && (ptsTransformsSecure && (*ptsTransformsSecure == tsUnknown)))
		*ptsTransformsSecure = tsNo;

	if (ppistrProcessedTransformsList)
	{
		// We need to mark the front of the processed transforms list with
		// the appropriate token if necessary.

		if (strProcessedTransformsList.TextSize())
		{
			if (ptsTransformsSecure && (*ptsTransformsSecure == tsRelative) &&
				(*(const ICHAR*)strProcessedTransformsList != SECURE_RELATIVE_TOKEN))
			{
				strProcessedTransformsList = MsiString(MsiChar(SECURE_RELATIVE_TOKEN)) + strProcessedTransformsList;
			}
			else if (ptsTransformsSecure && (*ptsTransformsSecure == tsAbsolute) &&
				(*(const ICHAR*)strProcessedTransformsList != SECURE_ABSOLUTE_TOKEN))
			{
				strProcessedTransformsList = MsiString(MsiChar(SECURE_ABSOLUTE_TOKEN)) + strProcessedTransformsList;
			}
		}

		strProcessedTransformsList.ReturnArg(*ppistrProcessedTransformsList);
	}

	return ieiSuccess;
}

//____________________________________________________________________________
//
// IMsiDirectoryManager implementation
//____________________________________________________________________________

IMsiRecord* CMsiEngine::CreatePathObject(const IMsiString& riPathString,IMsiPath*& rpiPath)
// --------------------------------------
{
	IMsiRecord* piError = 0;
	IMsiRecord* piError2 = 0;
	for(;;)
	{
		// CreatePathObject: dispatches error message if CreatePath fails
		if((piError = m_riServices.CreatePath(riPathString.GetString(),rpiPath)) != 0)
		{
			int imsg = piError->GetInteger(1);
			switch(imsg)
			{
			case idbgErrorGettingVolInfo:
			case imsgPathNotAccessible:
				piError->Release();
				piError2 = PostError(Imsg(imsgErrorCreateNetPath), riPathString);
				switch(Message(imtEnum(imtError+imtRetryCancel),*piError2))
				{
				case imsRetry:
					piError2->Release();
					continue;
				default:
					piError2->Release(); //!! should return piError2
					return PostError(Imsg(imsgErrorCreateNetPath), riPathString); //!! Message prepends header every time // imsCancel, imsNone
				};
			default:
				return piError;
			};
		}
		else
			return 0;
	}
}

IMsiRecord* CMsiEngine::LoadDirectoryTable(const ICHAR* szTableName)
// ------------------------------------------------------------------
// szTableName may be left null to use default Directory table name
// ------------------------------------------------------------------
{
	m_fDirectoryManagerInitialized = fFalse;
	m_fSourceResolved = false;
	m_fSourcePathsCreated = false;
	m_fSourceSubPathsResolved = false;

	IMsiRecord* piError;
	if(szTableName == 0)
		szTableName = sztblDirectory;
	if ((piError = m_piDatabase->LoadTable(*MsiString(*szTableName), 4, m_piDirTable)))
	{
		if(piError->GetInteger(1) == idbgDbTableUndefined)
		{
			piError->Release();
			m_fDirectoryManagerInitialized = fTrue;
			return 0; // no directory table is OK
		}
		else
			return piError;
	}

	// authored columns
	m_colDirKey = m_piDirTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblDirectory_colDirectory));
	m_colDirParent = m_piDirTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblDirectory_colDirectoryParent));
	m_colDirSubPath = m_piDirTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblDirectory_colDefaultDir));
	if(!m_colDirKey || !m_colDirParent || !m_colDirSubPath)
		return PostError(Imsg(idbgTableDefinition), szTableName);

	// temporary columns
		
	// target path object
	m_colDirTarget = m_piDirTable->CreateColumn(icdObject + icdNullable, g_MsiStringNull);
	Assert(m_colDirTarget != 0);
	
	// source path object
	m_colDirSource = m_piDirTable->CreateColumn(icdObject + icdNullable, g_MsiStringNull);
	Assert(m_colDirSource != 0);
	
	// configurable flag
	m_colDirNonConfigurable = m_piDirTable->CreateColumn(icdShort + icdNullable, g_MsiStringNull);
	Assert(m_colDirNonConfigurable != 0);
	
	// preconfigured flag
	m_colDirPreconfigured = m_piDirTable->CreateColumn(icdLong + icdNullable, g_MsiStringNull);
	Assert(m_colDirPreconfigured != 0);

	// source sub-path (long names)
	m_colDirLongSourceSubPath = m_piDirTable->CreateColumn(icdString + icdNullable, g_MsiStringNull);
	Assert(m_colDirLongSourceSubPath != 0);
		
	// source sub-path (short names)
	m_colDirShortSourceSubPath = m_piDirTable->CreateColumn(icdString + icdNullable, g_MsiStringNull);
	Assert(m_colDirShortSourceSubPath != 0);
		
	// link tree for tree-walking cursors
	if(m_piDirTable->LinkTree(m_colDirParent) == -1)
		return PostError(Imsg(idbgLinkTable), szTableName);
	m_fDirectoryManagerInitialized = fTrue;
	return 0;
}

IMsiTable* CMsiEngine::GetDirectoryTable()
//--------------------------------------
{
	if (m_piDirTable)
		m_piDirTable->AddRef();
	return m_piDirTable;
}

void CMsiEngine::FreeDirectoryTable()
//---------------------------------
{
	if (m_piDirTable)
	{
		m_piDirTable->Release(); // releases all path objects
		m_piDirTable = 0;
	}
	m_fDirectoryManagerInitialized = fFalse;
	m_fSourceResolved = false;
	m_fSourcePathsCreated = false;
	m_fSourceSubPathsResolved = false;
}

const IMsiString& CMsiEngine::GetDefaultDir(const IMsiString& ristrValue, bool fSource)
{
	if(ristrValue.Compare(iscWithin,TEXT(":")))
	{
		return MsiString(ristrValue.Extract((fSource ? iseAfter : iseUpto),':')).Return();
	}
	else
	{
		ristrValue.AddRef();
		return ristrValue;
	}
}

void DebugDumpDirectoryTable(IMsiTable& riDirTable, bool fSource, int colKey, int colObject, int colLongSource, int colShortSource)
{
	if (!FDiagnosticModeSet(dmVerboseDebugOutput|dmVerboseLogging))
		return;

	DEBUGMSG1("%s path resolution complete. Dumping Directory table...",
				fSource ? "Source" : "Target");

	if(!fSource)
	{
		DEBUGMSG("Note: target paths subject to change (via custom actions or browsing)");
	}

	PMsiCursor pDumpCursor = riDirTable.CreateCursor(fTrue);

	while(pDumpCursor->Next())
	{
		PMsiPath pPath = (IMsiPath*)pDumpCursor->GetMsiData(colObject);
		MsiString strPath = TEXT("NULL");
		if(pPath)
			strPath = pPath->GetPath();

		if(fSource)
		{
			DEBUGMSG4(TEXT("Dir (source): Key: %s\t, Object: %s\t, LongSubPath: %s\t, ShortSubPath: %s"),
					 (const ICHAR*)MsiString(pDumpCursor->GetString(colKey)),
					 (const ICHAR*)strPath,
					 (const ICHAR*)MsiString(pDumpCursor->GetString(colLongSource)),
					 (const ICHAR*)MsiString(pDumpCursor->GetString(colShortSource)));
		}
		else
		{
			DEBUGMSG2(TEXT("Dir (target): Key: %s\t, Object: %s"),
					 (const ICHAR*)MsiString(pDumpCursor->GetString(colKey)),
					 (const ICHAR*)strPath);
		}
	}
}

IMsiRecord* CMsiEngine::CreateSourcePaths()
//---------------------------------------
{
	IMsiRecord* piError = 0;

	if (!m_fDirectoryManagerInitialized || !m_fSourceSubPathsResolved)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return 0; // no directory table, no paths to create

	PMsiPath pSourceRoot(0);
	int iSourceType = 0;
	if((piError = GetSourceRootAndType(*&pSourceRoot, iSourceType)) != 0)
		return piError;
	
	PMsiPath pPath(0);

	PMsiCursor pDirCursor = m_piDirTable->CreateCursor(fTrue); // tree-walking cursor - depth-first

	PMsiPath pRootPath(0);
	while(pDirCursor->Next())
	{
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		MsiString istrName(pDirCursor->GetString(m_colDirKey));
		MsiString istrParent(pDirCursor->GetString(m_colDirParent));
		MsiString istrSubPath(GetDefaultDir(*MsiString(pDirCursor->GetString(m_colDirSubPath)),fTrue));
		MsiString istrPath;

		PMsiPath pFullPath(0);
		
		Bool fRoot = (!istrParent.TextSize() || istrName.Compare(iscExact, istrParent)) ? fTrue : fFalse;
		if(fRoot) // source root - DefaultDir is property defining path
		{
			MsiString istrRootPath;
			
			// COMPAT FIX
			// when running against a pre-1.5 package that is marked compressed, use SourceDir instead of the 
			// authored root property

			if(FPerformAppcompatFix(iacsAcceptInvalidDirectoryRootProps))
			{
				istrRootPath = GetPropertyFromSz(IPROPNAME_SOURCEDIR);
			}
			else
			{
				if(!istrSubPath.TextSize())
					return PostError(Imsg(idbgNoRootSourcePropertyName), (const ICHAR *)istrName);
				istrRootPath = GetProperty(*istrSubPath);
			}
			if(!istrRootPath.TextSize())
			{
				return PostError(Imsg(idbgNoRootProperty), (const ICHAR *)istrSubPath);
			}

			if((piError = CreatePathObject(*istrRootPath, *&pRootPath)) != 0)
				return piError;  //!! use idbgDatabaseValueError

			if((piError = pRootPath->ClonePath(*&pFullPath)) != 0)
				return piError;
		}
		else // grab already-resolve sub-path, and tack onto root path
		{
			if(!pRootPath)
				return PostError(Imsg(idbgDatabaseTableError));

			if((piError = pRootPath->ClonePath(*&pFullPath)) != 0)
				return piError;

			// append sub-path if global source type is uncompressed (meaning look in the tree, not at the root)
			if((!(iSourceType & msidbSumInfoSourceTypeCompressed) ||
				  (iSourceType & msidbSumInfoSourceTypeAdminImage)))
			{
				Bool fLFN = ToBool(FSourceIsLFN(iSourceType, *pRootPath));
					
				// short path is in short column, or if short and long are the same, in the long column
				MsiString strSubPath;
				if(!fLFN)
				{
					strSubPath = pDirCursor->GetString(m_colDirShortSourceSubPath);
				}

				if(!strSubPath.TextSize())
				{
					strSubPath = pDirCursor->GetString(m_colDirLongSourceSubPath);
				}

				if((piError = pFullPath->AppendPiece(*strSubPath)) != 0)
					return piError;
			}
		}

	
		AssertNonZero(pDirCursor->PutMsiData(m_colDirSource, pFullPath));
		AssertNonZero(pDirCursor->Update());
		AssertNonZero(pDirCursor->PutNull(m_colDirSource)); // reset object field
	}

	m_fSourcePathsCreated = true;
	
	DebugDumpDirectoryTable(*m_piDirTable, true, m_colDirKey, m_colDirSource,
									m_colDirLongSourceSubPath, m_colDirShortSourceSubPath);

	return 0;
}

IMsiRecord* CMsiEngine::ResolveSourceSubPaths()
//---------------------------------------
{
	IMsiRecord* piError = 0;

	if (!m_fDirectoryManagerInitialized)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return 0; // no directory table, no paths to create

	PMsiCursor pDirCursor = m_piDirTable->CreateCursor(fTrue);
	PMsiCursor pParentDirCursor = m_piDirTable->CreateCursor(fFalse);
	pParentDirCursor->SetFilter(iColumnBit(m_colDirKey));  // permanent setting

	// tree walk is depth first
	while(pDirCursor->Next())
	{
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		MsiString strName(pDirCursor->GetString(m_colDirKey));
		MsiString strParent(pDirCursor->GetString(m_colDirParent));
		MsiString strSubPath(GetDefaultDir(*MsiString(pDirCursor->GetString(m_colDirSubPath)),fTrue));

		// for root entries, reset path string, and skip entry itself
		if(!strParent.TextSize() || strName.Compare(iscExact, strParent))
		{
			continue;
		}

		// find parent entry
		pParentDirCursor->Reset();
		AssertNonZero(pParentDirCursor->PutString(m_colDirKey, *strParent));
		AssertNonZero(pParentDirCursor->Next());

		MsiString strLongSubPath =  pParentDirCursor->GetString(m_colDirLongSourceSubPath);
		MsiString strShortSubPath = pParentDirCursor->GetString(m_colDirShortSourceSubPath);

		if (strSubPath.Compare(iscExact, TEXT("?")) == 0 &&
			 strSubPath.Compare(iscExact,TEXT(".")) == 0)
		{
			// make sure default sub path doesn't contain chDirSep
			if(strSubPath.Compare(iscWithin, szDirSep) ||
				strSubPath.Compare(iscWithin, szURLSep))
			{
				return PostError(Imsg(idbgInvalidDefaultFolder), *strSubPath);
			}
			
			MsiString strLongName, strShortName;
			
			// should always be able to extract long name
			if((piError = m_riServices.ExtractFileName(strSubPath,fTrue,*&strLongName)) != 0)
				return piError;

			// poorly authored packages may only supply long name, but that worked in 1.0 so we have
			// to accept it (by ignoring any errors from ExtractFileName)
			PMsiRecord(m_riServices.ExtractFileName(strSubPath,fFalse,*&strShortName));
		
			if(!strLongName.TextSize())
				return PostError(Imsg(idbgDatabaseValueError), sztblDirectory,
											  strName, sztblDirectory_colDefaultDir);

			// if short and long names are different (and short is non-empty),
			// need to start storing subpaths separately
			if(strShortSubPath.TextSize() || // parent sub-path already different than long path
				strShortName.TextSize() &&	strLongName.Compare(iscExact, strShortName) == 0) // current short|long names are different
			{
				if(!strShortSubPath.TextSize())
				{
					strShortSubPath = strLongSubPath; // differences start here, so need to start with parent's long path
				}
				
				strShortSubPath += strShortName;
				strShortSubPath += szDirSep; //!! need to fix path object to fix up dir seps for URL paths
			}

			strLongSubPath += strLongName;
			strLongSubPath += szDirSep;
		}
		// else this directory is identical to its parent

		AssertNonZero(pDirCursor->PutString(m_colDirLongSourceSubPath, *strLongSubPath));
		if(strShortSubPath.TextSize())
		{
			AssertNonZero(pDirCursor->PutString(m_colDirShortSourceSubPath, *strShortSubPath));
		}

		AssertNonZero(pDirCursor->Update());
		
		// reset cursor fields
		AssertNonZero(pDirCursor->PutString(m_colDirLongSourceSubPath, g_MsiStringNull));
		AssertNonZero(pDirCursor->PutString(m_colDirShortSourceSubPath, g_MsiStringNull));
	}
	
	m_fSourceSubPathsResolved = true;
	return 0;
}

IMsiRecord* CMsiEngine::CreateTargetPaths()
//---------------------------------------
{
	IMsiRecord* piError = CreateTargetPathsCore(0);
	if(piError == 0 && m_piDirTable)
	{
		DebugDumpDirectoryTable(*m_piDirTable, false, m_colDirKey, m_colDirTarget,
										m_colDirLongSourceSubPath, m_colDirShortSourceSubPath);
	}
	return piError;
}

IMsiRecord* CMsiEngine::CreateTargetPathsCore(const IMsiString* piDirKey)
{
	IMsiRecord* piError = 0;

	if (!m_fDirectoryManagerInitialized)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return 0; // no directory table, no paths to create

	PMsiCursor pDirCursor = m_piDirTable->CreateCursor(fTrue);
	PMsiCursor pTempCursor = m_piDirTable->CreateCursor(fFalse); // used to find parent
	Assert(pTempCursor);
	pTempCursor->SetFilter(iColumnBit(m_colDirKey));  // permanent setting
	Bool fShortNames = GetMode() & iefSuppressLFN ? fTrue : fFalse;
	bool fAdmin = GetMode() & iefAdmin ? true : false;
	MsiString istrRootDrive = GetPropertyFromSz(IPROPNAME_ROOTDRIVE);
	while(pDirCursor->Next())
	{
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		PMsiPath pPath(0);
		MsiString istrName(pDirCursor->GetString(m_colDirKey));
		MsiString istrParent(pDirCursor->GetString(m_colDirParent));
		MsiString istrSubPath(GetDefaultDir(*MsiString(pDirCursor->GetString(m_colDirSubPath)),fAdmin));
		bool fPreconfigured = pDirCursor->GetInteger(m_colDirPreconfigured) == iMsiNullInteger ? false : true;
		MsiString istrPath;

		// The piDirKey parameter and the DirPreconfigured column of the Directory table are used to allow
		// the Directory table paths to be re-initialized, if necessary.  Calling CreateTargetPathsCore with piDirKey
		// set to a key in the Directory table tells CreateTargetPathsCore to reinitialize all paths to the default
		// authored values, ignoring the current Property value set for the path, EXCEPT for the piDirKey
		// path itself, and any directories that were preconfigured via property the first time the
		// Directory table paths were initialized.  To initialize the directory paths normally, call
		// CreateTargetPathsCore with NULL for piDirKey.
		if (!piDirKey || fPreconfigured || istrName.Compare(iscExact, piDirKey->GetString()))
			istrPath = GetProperty(*istrName);

		Bool fRoot = (!istrParent.TextSize() || istrName.Compare(iscExact, istrParent)) ? fTrue : fFalse;
		if(fRoot && istrPath.TextSize() == 0) // target root and no property defined
		{
			if(!istrRootDrive.TextSize()) // error - ROOTDRIVE not set
				return PostError(Imsg(idbgNoRootProperty), *istrRootDrive);
			else
			{
				if((piError = CreatePathObject(*istrRootDrive, *&pPath)) != 0)
					return piError;
			}
		}
		else if ((fAdmin && fRoot) || (!fAdmin && istrPath.TextSize())) // set path with property value
		{
			if((piError = CreatePathObject(*istrPath, *&pPath)) != 0)
				return piError;
			if (!fPreconfigured && !piDirKey)
			{
				AssertNonZero(pDirCursor->PutInteger(m_colDirPreconfigured, true));
				AssertNonZero(pDirCursor->Update());
			}
		}
		else // set path with default value
		{
			if (istrSubPath.Compare(iscExact, TEXT("?")) == 0)
			{
				// get parent path object and append default dir name to it
				pTempCursor->Reset();
				AssertNonZero(pTempCursor->PutString(m_colDirKey, *istrParent));
				AssertNonZero(pTempCursor->Next());
				PMsiPath pTempPath = (IMsiPath*)pTempCursor->GetMsiData(m_colDirTarget);
				Assert(pTempPath);
				if((piError = pTempPath->ClonePath(*&pPath)) != 0)
					return piError;

				Assert(pPath);

				if(istrSubPath.Compare(iscExact,TEXT(".")) == 0)
				{
					// extract appropriate name from short|long pair
					Bool fLFN = (fShortNames == fFalse && pTempPath->SupportsLFN()) ? fTrue : fFalse;
					MsiString strSubPathName;
					

						if((piError = m_riServices.ExtractFileName(istrSubPath,fLFN,*&strSubPathName)) != 0)
							return piError;
					
						if(!strSubPathName.TextSize())
							return PostError(Imsg(idbgDatabaseValueError), sztblDirectory,
														  istrName, sztblDirectory_colDefaultDir);

						// make sure default sub path doesn't contain chDirSep
						if(strSubPathName.Compare(iscWithin, szDirSep))
							return PostError(Imsg(idbgInvalidDefaultFolder), *strSubPathName);

						if((piError = pPath->AppendPiece(*strSubPathName)) != 0)
							return piError;

				}
				// else this directory is identical to its parent
			}
		}
		if ( pPath && g_fWinNT64 && g_Win64DualFolders.ShouldCheckFolders() )
		{
			ICHAR szSubstitutePath[MAX_PATH+1];
			ieSwappedFolder iRes;
			iRes = g_Win64DualFolders.SwapFolder(ie64to32,
															 MsiString(pPath->GetPath()),
															 szSubstitutePath);
			if ( iRes == iesrSwapped )
				piError = pPath->SetPath(szSubstitutePath);
			else
				Assert(iRes != iesrError && iRes != iesrNotInitialized);
		}
		AssertNonZero(pDirCursor->PutMsiData(m_colDirTarget, pPath));
		AssertNonZero(pDirCursor->Update());
		AssertNonZero(pDirCursor->PutMsiData(m_colDirTarget, 0)); // reset search field
		// set property - ensure that property values have trailing '\'
		if(pPath)
			AssertNonZero(SetProperty(*istrName, *MsiString(pPath->GetPath())));
	}
	return 0;
}


IMsiRecord* CMsiEngine::GetTargetPath(const IMsiString& riDirKey,IMsiPath*& rpiPath)
//-----------------------------------
{
	if (!m_fDirectoryManagerInitialized)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return PostError(Imsg(idbgUnknownDirectory), riDirKey); // no Directory table, so this directory must not exist

	PMsiCursor pDirCursor(m_piDirTable->CreateCursor(fFalse));

	pDirCursor->SetFilter(iColumnBit(m_colDirKey));
	pDirCursor->PutString(m_colDirKey, riDirKey);
	if (pDirCursor->Next())
	{
		rpiPath = (IMsiPath*)pDirCursor->GetMsiData(m_colDirTarget);
		if(rpiPath == 0)
		{
			MsiString strSubPath = pDirCursor->GetString(m_colDirSubPath);

			// Question marks are inserted in the subPath column when the
			// RegisterComponentDirectory inserts a new entry into the
			// Directory table.  If a path for that directory was never
			// defined, we know we've got an error.
			if (strSubPath.Compare(iscExact,TEXT("?")))
			{
				return PostError(Imsg(idbgDirPropertyUndefined), riDirKey);
			}
			else
			{
				return PostError(Imsg(idbgTargetPathsNotCreated), riDirKey);
			}
		}
	}
	else
	{
		rpiPath = 0;
		return PostError(Imsg(idbgUnknownDirectory), riDirKey);
	}
	return 0;
}

IMsiRecord* CMsiEngine::IsPathWritable(IMsiPath& riPath, Bool& fWritable)
{
	// check for folder writability only if we will attempt to write to the folder with client privs
	// this is true when running as a client or if the folder is remote
	// otherwise, we assume the folder is writable by the server (if its not, the server must handle
	// the error)
	//!! we are making the assumption here that if g_fWin9X or m_piConfigManager are set that we
	//!! are running under client mode. However, this doesn't catch the case when we are running as an
	//!! OLE server on NT.  We don't do this currently but we could in the future. This will need to be
	//!! fixed to detect that case.
	IMsiRecord* piErr = 0;
	fWritable = fTrue;
	idtEnum idtDrivetype = PMsiVolume(&riPath.GetVolume())->DriveType();
	if((FIsUpdatingProcess() || idtDrivetype == idtRemote || idtDrivetype == idtCDROM))
		piErr = riPath.Writable(fWritable);
	return piErr;
}


IMsiRecord* CMsiEngine::SetTargetPath(const IMsiString& riDestString, const ICHAR* szPath, Bool fWriteCheck)
//-----------------------------------
{
	if (!m_fDirectoryManagerInitialized)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return PostError(Imsg(idbgUnknownDirectory), riDestString); // no Directory table, so this directory must not exist

	IMsiRecord* piError = 0;
	PMsiPath pPath(0);
	Bool fSuppressLFN = GetMode() & iefSuppressLFN ? fTrue : fFalse;
	bool fAdmin = GetMode() & iefAdmin ? true : false;
	CTempBuffer<const IMsiString*,10> rgOldDirKeys; // holds keys of changed paths in case we need to revert to them
	CTempBuffer<IMsiPath*,10> rgOldPaths; // holds changed paths in case we need to revert to them
	int iOldPathsIndex = 0;

	PMsiCursor pDirCursor = m_piDirTable->CreateCursor(fTrue);
	pDirCursor->SetFilter(iColumnBit(m_colDirKey));
	pDirCursor->PutString(m_colDirKey, riDestString);

	// get current path object
	int iDirLevel = pDirCursor->Next();
	if(iDirLevel != 0)
	{
		pPath = (IMsiPath*)pDirCursor->GetMsiData(m_colDirTarget);
		if (!pPath)
			return PostError(Imsg(idbgTargetPathsNotCreated), riDestString);
	}
	else
	{
		return PostError(Imsg(idbgUnknownDirectory), riDestString);
	}
	
#ifdef _WIN64
	// if we are asked to change the path to a 64-bit folder when the package is marked 32-bit,
	// we need to remap the path to the 32-bit folder
	ICHAR szSubstitutePath[MAX_PATH+1];
	if ( szPath && g_Win64DualFolders.ShouldCheckFolders() )
	{
		ieSwappedFolder iRes;
		iRes = g_Win64DualFolders.SwapFolder(ie64to32,
														 szPath,
														 szSubstitutePath);
		if ( iRes == iesrSwapped )
		{
			DEBUGMSG2(TEXT("In SetTargetPath, re-mapping '%s' to '%s' because this is a 32-bit package being installed on Win64."), szPath, szSubstitutePath);
			szPath = szSubstitutePath;
		}
		else
			Assert(iRes != iesrError && iRes != iesrNotInitialized);
	}
#endif // _WIN64

	// New path object
	PMsiPath pNewPathObj(0);

	if ((piError = CreatePathObject(*MsiString(szPath), *&pNewPathObj)) != 0)
		return piError;

	// hold old path
	PMsiPath pOldPath(0);
	if((piError = pPath->ClonePath(*&pOldPath)) != 0)
		return piError;

	ipcEnum ipc;

	// If the paths are identical, we have no work to do
	pOldPath->Compare(*pNewPathObj, ipc);
	if (ipc == ipcEqual)
		return 0;
		
	Assert(pOldPath);

	// scan all other directories for child paths and update them
	bool fShortNameError = false;
	pDirCursor->SetFilter(0);
	MsiString istrChild, strDefaultFolder, strCurrentFolder;
	do
	{
#ifdef DEBUG
		MsiString strDebug = pDirCursor->GetString(m_colDirKey);
#endif //DEBUG
		piError = 0;
		PMsiPath pOldChildPath(0); // path to pass to RecostDirectory
		PMsiPath pChildPath = (IMsiPath*)pDirCursor->GetMsiData(m_colDirTarget);
		if(pChildPath && (((IMsiPath*)pChildPath == (IMsiPath*)pPath) ||
			((piError = pChildPath->Child(*pOldPath, *&istrChild)) == 0)))
		{
			if((piError = pChildPath->ClonePath(*&pOldChildPath)) != 0)
				break;
			if((piError = pChildPath->SetPathToPath(*pNewPathObj)) != 0)
				break;

			if(istrChild.TextSize())
			{
				// child of path being changed
				
				// if the last folder of istrChild is one of the default folder names in
				// the directory table, use the default value instead

				// strDefaultFolder caches the DefaultDir value for the current path or the closest parent
				// that doesn't have '.' as the DefaultDir
				// since we are tree-walking this happens automatically
				//!! doesn't work in some cases - strDefaultFolder may not always be value of parent
				MsiString strTemp(GetDefaultDir(*MsiString(pDirCursor->GetString(m_colDirSubPath)),fAdmin));
				if(strTemp.Compare(iscExact,TEXT(".")) == 0)
					strDefaultFolder = strTemp;

				strCurrentFolder = pOldChildPath->GetEndSubPath();

				// extract appropriate name from short|long pair
				Bool fLFN = (fSuppressLFN == fFalse && pChildPath->SupportsLFN()) ? fTrue : fFalse;
				MsiString strSubPathName;
				if((piError = m_riServices.ExtractFileName(strDefaultFolder,fLFN,*&strSubPathName)) != 0)
					return piError;
			
				// make sure default sub path doesn't contain chDirSep
				if(strDefaultFolder.Compare(iscWithin, szDirSep))
				{
					piError = PostError(Imsg(idbgInvalidDefaultFolder),
											  *strDefaultFolder);
					break;
				}
				if(strDefaultFolder.Compare(iscExactI, strCurrentFolder) || // exact match OR
					(strDefaultFolder.Compare(iscWithin, TEXT("|")) && // short|long combo AND
					(strDefaultFolder.Compare(iscStart, strCurrentFolder) || // matches short name OR
					strDefaultFolder.Compare(iscEnd, strCurrentFolder)))) // matches long name
				{
					istrChild.Remove(iseEnd, strCurrentFolder.CharacterCount()+1);
					istrChild += strSubPathName;
				}
			}

			if((piError = pChildPath->AppendPiece(*istrChild)) != 0)
			{
				// If a filename length error occured, we must be trying
				// to change from a LongFileName to ShortFileName volume.
				// We've got to bail out, and fix things up below...
				int iErr = piError->GetInteger(1);
				if (iErr == imsgErrorFileNameLength || iErr == imsgInvalidShortFileNameFormat)
				{
					fShortNameError = true;
					break;
				}

				// couldn't append child, set path back to old path
				// other paths will be fixed below
				AssertRecord(pChildPath->SetPathToPath(*pOldChildPath));
				break;
			}
			istrChild = TEXT("");

			if(fWriteCheck)
			{
				Bool fWritable;
				if ((piError = IsPathWritable(*pChildPath, fWritable)) != 0 || fWritable == fFalse)
				{
					// Can't write to this directory; throw an error, and set path back to old path.
					// Other paths will be fixed below.
					if (!piError && !fWritable)
						piError = PostError(Imsg(imsgDirectoryNotWritable), (const ICHAR*) MsiString(pChildPath->GetPath()));

					AssertRecord(pChildPath->SetPathToPath(*pOldChildPath));
					break;
				}
			}

			MsiString strDirKey = pDirCursor->GetString(m_colDirKey);
			if((piError = RecostDirectory(*strDirKey, *pOldChildPath)) != 0)
			{
				// couldn't RecostDirectory, set path back to old path
				// other paths will be fixed below
				AssertRecord(pChildPath->SetPathToPath(*pOldChildPath));
				break;
			}
			AssertNonZero(SetProperty(*strDirKey, *MsiString(pChildPath->GetPath())));

			// everything worked for this path
			// add path to list of old paths
			if(iOldPathsIndex >= rgOldPaths.GetSize())
			{
				rgOldPaths.Resize(iOldPathsIndex + 10);
				rgOldDirKeys.Resize(iOldPathsIndex + 10);
			}
			rgOldDirKeys[iOldPathsIndex] = (const IMsiString*)strDirKey;
			rgOldDirKeys[iOldPathsIndex]->AddRef();
			rgOldPaths[iOldPathsIndex] = (IMsiPath*)pOldChildPath;
			rgOldPaths[iOldPathsIndex]->AddRef();
			iOldPathsIndex++;
		}
		else if(piError)
		{
			piError->Release();
			piError = 0;
		}
	}
	while(pDirCursor->Next() > iDirLevel);

	for(int i=0; i<iOldPathsIndex; i++)
	{
		if(piError)
		{
			// need to revert changed paths to their old values
			pDirCursor->Reset();
			pDirCursor->SetFilter(iColumnBit(m_colDirKey));
			AssertNonZero(pDirCursor->PutString(m_colDirKey, *(rgOldDirKeys[i])));
			AssertNonZero(pDirCursor->Next());
			// set old path
			PMsiPath pNewPath = (IMsiPath*)pDirCursor->GetMsiData(m_colDirTarget);
			AssertNonZero(pDirCursor->PutMsiData(m_colDirTarget, rgOldPaths[i]));
			AssertNonZero(pDirCursor->Update());
			// recost old directory
			AssertRecord(RecostDirectory(*(rgOldDirKeys[i]),*pNewPath));
			// set old property
			AssertNonZero(SetProperty(*(rgOldDirKeys[i]),*MsiString(rgOldPaths[i]->GetPath())));
		}
		if((const IMsiString*)rgOldDirKeys[i])
			rgOldDirKeys[i]->Release();
		if((const IMsiString*)rgOldPaths[i])
			rgOldPaths[i]->Release();
	}
	pDirCursor->Reset();
	pDirCursor->SetFilter(0);
	if (fShortNameError)
	{
		// Switched from a LFN to SFN volume; potentially all paths in the
		// directory table are wrong, so we've got to create them again,
		// this time with short names.  Then no choice but to reset and
		// recompute the disk cost for all components.
		Assert(piError);
		piError->Release();
		AssertNonZero(SetProperty(riDestString, *MsiString(szPath)));
		if ((piError = CreateTargetPathsCore(&riDestString)) != 0)
			return piError;
		return InitializeDynamicCost(/* fReinitialize = */ fTrue);
	}
	else
	{
		if(!piError)
			DetermineOutOfDiskSpace(NULL, NULL);
		return piError;
	}
}

IMsiRecord* CMsiEngine::SetDirectoryNonConfigurable(const IMsiString& ristrDirKey)
//-----------------------------------
{
	if (!m_fDirectoryManagerInitialized)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return PostError(Imsg(idbgUnknownDirectory), ristrDirKey); // no Directory table, so this directory must not exist

	PMsiCursor pDirCursor = m_piDirTable->CreateCursor(fFalse);
	pDirCursor->PutString(m_colDirKey, ristrDirKey);
	pDirCursor->SetFilter(iColumnBit(m_colDirKey));
	if (pDirCursor->Next())
	{
		AssertNonZero(pDirCursor->PutInteger(m_colDirNonConfigurable, 1));
		AssertNonZero(pDirCursor->Update());
		return 0;
	}
	else
		return PostError(Imsg(idbgUnknownDirectory), ristrDirKey);
}

IMsiRecord* CMsiEngine::ResolveSource(const ICHAR* szProductKey, bool fPatch, const ICHAR* szOriginalDatabasePath, iuiEnum iuiLevel, Bool fMaintenanceMode, const IMsiString** ppiSourceDir, const IMsiString** ppiSourceDirProduct)
{
	Assert(!ppiSourceDirProduct == !ppiSourceDir); // either both 0 or both set

	if (m_fSourceResolved)
		return 0;

	DEBUGMSG("Resolving source.");


	// If we're not running from the cached database (always true for first-run)
	// then we must've been launched from a valid source (this needs to be determined up front,
	// before we even let the install begin). We'll use this source as
	// it's obviously available if we were launched from it. Otherwise
	// if we're running from the cached database then we attempt to resolve
	// a source.

	MsiString strPatchedProductKey = GetPropertyFromSz(IPROPNAME_PATCHEDPRODUCTCODE);
	
	MsiString strProductKey;
	if (szProductKey)
		strProductKey = szProductKey;
	else if(strPatchedProductKey.TextSize())
		strProductKey = strPatchedProductKey;
	else
		strProductKey = GetProductKey();

	MsiString strPackage;
	if (szOriginalDatabasePath)
		strPackage    = szOriginalDatabasePath;
	else
		strPackage    = GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE);

	if (fMaintenanceMode == -1)
		fMaintenanceMode = (GetMode() & iefMaintenance) != 0 ? fTrue : fFalse;

	IMsiRecord* piError = 0;
	MsiString strSource;
	MsiString strSourceProduct = GetRootParentProductKey();
	if (*(const ICHAR*)strPackage == ':') // SubStorage
	{
		Assert(m_piParentEngine);
		if ((piError = GetSourcedir(*m_piParentEngine, *&strSource)) != 0)
			return piError;
	}
	else
	{
		if (GetMode() & iefAdmin ||
			 (strPatchedProductKey.TextSize() == 0 &&
			  !fPatch &&
			 (!fMaintenanceMode || !IsCachedPackage(*this, *strPackage, fFalse, strProductKey))))
		{
			DEBUGMSG("Resolving source to launched-from source.");
			DEBUGMSG("Setting launched-from source as last-used.");

			strSource = strPackage;
			Assert(PathType(strSource) == iptFull);

			PMsiPath pPath(0);
			MsiString strFileName;
			// FUTURE: Perhaps could use split path here
			AssertRecord(m_riServices.CreateFilePath(strSource, *&pPath, *&strFileName));
			strSource.Remove(iseLast,strFileName.CharacterCount());
		}
		else // running from cached database; need to resolve the source
		{
			AssertSz(!m_fRestrictedEngine, TEXT("Full source resolution is not allowed in a restricted engine"));
			iuiEnum iuiSource = iuiLevel != -1 ? iuiLevel : m_iuiLevel;

			// when attempting to resolve the source from the engine, we're really asking for disk 1 (which has the package
			// patches, and transforms). Other disks are only requested via the script or a GetComponentPath call.
			if ((piError = ::ResolveSource(&m_riServices, strProductKey, /*uiDisk=*/ 1, *&strSource, *&strSourceProduct, fFalse, 0 /*not needed*/, fPatch)) == 0)
			{
				Assert(strSource.Compare(iscEnd, MsiString(MsiChar(chDirSep))) ||
						 strSource.Compare(iscEnd, MsiString(MsiChar(chURLSep))));
			}
			else
			{
				return piError;
			}
		}

#ifdef DEBUG
		MsiString strMsiDirectory(GetMsiDirectory());
		strMsiDirectory += chDirSep;

		// No assert if the path is actually a sub-directory.  Only concerned about things resolving
		// directly to the Msi Directory.
		AssertSz(strSource.Compare(iscExactI,strMsiDirectory) == 0, "Resolved source to cached msi folder");
#endif 

	}
	if (ppiSourceDir)
	{
		strSource.ReturnArg(*ppiSourceDir);
		strSourceProduct.ReturnArg(*ppiSourceDirProduct);
	}
	else
	{
		SetProperty(*MsiString(IPROPNAME_SOURCEDIR), *strSource);
		SetProperty(*MsiString(*IPROPNAME_SOURCEDIROLD), *strSource);
		SetProperty(*MsiString(IPROPNAME_SOURCEDIRPRODUCT), *strSourceProduct);
	}

	m_fSourceResolved = true;

	DEBUGMSG1(TEXT("SOURCEDIR ==> %s"), strSource);
	DEBUGMSG1(TEXT("SOURCEDIR product ==> %s"), strSourceProduct);
	return 0;
}

IMsiRecord* CMsiEngine::GetSourcePath(const IMsiString& riDirKey,IMsiPath*& rpiPath)
//-----------------------------------
{
	if (!m_fDirectoryManagerInitialized)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return PostError(Imsg(idbgUnknownDirectory), riDirKey); // no Directory table, so this directory must not exist

	
	IMsiRecord* piErrRec = NULL;

	if (!m_fSourceResolved)
	{
		if ((piErrRec = ResolveSource()) != 0)
		{
			if (piErrRec->GetInteger(1) == imsgSourceResolutionFailed)
				piErrRec->SetMsiString(2, *MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTNAME)));
			return piErrRec; //!! Reformat error?
		}
	}

	if(!m_fSourcePathsCreated)
	{
		if ((piErrRec = CreateSourcePaths()) != 0)
		{
			m_fSourceResolved = false;
			return piErrRec;
		}
	}

	rpiPath = 0;

	// COMPAT FIX
	// for packages older than 150, need to handle Directory tables that have no root rows with DefaultDir of
	// either SOURCEDIR or SourceDir
	if (FPerformAppcompatFix(iacsAcceptInvalidDirectoryRootProps) &&
		 (riDirKey.Compare(iscExact, IPROPNAME_SOURCEDIR) || riDirKey.Compare(iscExact, IPROPNAME_SOURCEDIROLD)))
	{
		return CreatePathObject(*MsiString(GetPropertyFromSz(IPROPNAME_SOURCEDIR)), rpiPath);
	}

	PMsiCursor pDirCursor(m_piDirTable->CreateCursor(fFalse));
	pDirCursor->SetFilter(iColumnBit(m_colDirKey));
	pDirCursor->PutString(m_colDirKey, riDirKey);
	if (pDirCursor->Next())
	{
		rpiPath = (IMsiPath*)pDirCursor->GetMsiData(m_colDirSource);
		piErrRec = 0;
	}
	else
	{
		// look for source properties (e.g. SOURCEDIR, etc.)
		PMsiCursor pDirTreeCursor(m_piDirTable->CreateCursor(fTrue));
		pDirTreeCursor->SetFilter(iColumnBit(m_colDirSubPath));
		pDirTreeCursor->PutString(m_colDirSubPath, riDirKey);

		int iLevel;
		while ((iLevel = pDirTreeCursor->Next()) != 0)
		{
			if (iLevel == 1) // root
			{
				rpiPath = (IMsiPath*)pDirTreeCursor->GetMsiData(m_colDirSource);
				piErrRec = 0;
				break;
			}
		}
	}
	if (!rpiPath)
		piErrRec = PostError(Imsg(idbgSourcePathsNotCreated), riDirKey);
	return piErrRec;
}

// GetSourceSubPath: returns the already-resolved SubPath for this Directory key
//                   requires ResolveSourceSubPaths to have been called (CostInitialize calls that)
//                   unlike GetSourcePath, this fn doesn't accept "SOURCEDIR" or "SourceDir" as an arg
//                   if fPrependSourceDirToken is true, returned string starts with token for use in
//                   ixoSetSourceFolder op
IMsiRecord* CMsiEngine::GetSourceSubPath(const IMsiString& riDirKey, bool fPrependSourceDirToken,
													  const IMsiString*& rpistrSubPath)
//-----------------------------------
{
	if (!m_fDirectoryManagerInitialized || !m_fSourceSubPathsResolved)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	if(!m_piDirTable)
		return PostError(Imsg(idbgUnknownDirectory), riDirKey); // no Directory table, so this directory must not exist

	MsiString strSubPath;
	if(fPrependSourceDirToken)
	{
		strSubPath = szUnresolvedSourceRootTokenWithBS;
	}
	
	PMsiCursor pDirCursor(m_piDirTable->CreateCursor(fFalse));
	pDirCursor->SetFilter(iColumnBit(m_colDirKey));
	pDirCursor->PutString(m_colDirKey, riDirKey);
	if (pDirCursor->Next())
	{
		// string is [short path|][long path] - the correct path will be used once the source type is known
		MsiString strShortSubPath = pDirCursor->GetString(m_colDirShortSourceSubPath);
		MsiString strLongSubPath  = pDirCursor->GetString(m_colDirLongSourceSubPath);

		if(strShortSubPath.TextSize())
		{
			strSubPath += strShortSubPath;
			strSubPath += MsiChar(chFileNameSeparator);
		}
		strSubPath += strLongSubPath;

		strSubPath.ReturnArg(rpistrSubPath);
		return 0;
	}
	else
	{
		// not a perfect error, because paths may have been created, but good enough
		return PostError(Imsg(idbgSourcePathsNotCreated), riDirKey);
	}
}

IMsiRecord* GetSourceTypeFromPackage(IMsiServices& riServices, IMsiPath& riSourceRoot,
												 const IMsiString& ristrPackageName,
												 const ICHAR* rgchProductCode, IMsiDatabase* piDatabase, int &iSourceType)
{
	DEBUGMSGV(TEXT("Determining source type"));

	IMsiRecord* piError = 0;

	PMsiStorage pStorage(0);
	PMsiSummaryInfo pSummary(0);
	if (PMsiVolume(&riSourceRoot.GetVolume())->IsURLServer())
	{
		DEBUGMSGV(TEXT("URL source provided. . ."));

		// try to determine if we already have a source type registered; otherwise we have to download the package
		CRegHandle HSourceListKey;
		HKEY hURLSourceKey = 0;
		int iURLSourceType;
		DWORD cbURLSourceType = sizeof(iURLSourceType);
		DWORD dwType;
		if (ERROR_SUCCESS == OpenSourceListKey(rgchProductCode, /* fPatch */ fFalse, HSourceListKey, /* fWrite */ fFalse, /* fSetKeyString */ false)
			&& ERROR_SUCCESS == MsiRegOpen64bitKey(HSourceListKey, szSourceListURLSubKey, 0, g_samRead, &hURLSourceKey)
			&& ERROR_SUCCESS == RegQueryValueEx(hURLSourceKey, szURLSourceTypeValueName, 0, &dwType, (LPBYTE)&iURLSourceType, &cbURLSourceType)
			&& dwType == REG_DWORD)
		{
			// found a source type registered for URLs for this product -- use it!
			iSourceType = iURLSourceType;
			DEBUGMSGV2(TEXT("Source type from package '%s': %d"),ristrPackageName.GetString(),(const ICHAR*)(INT_PTR)iSourceType);

			RegCloseKey(hURLSourceKey);

			return 0;
		}
		if (hURLSourceKey)
		{
			RegCloseKey(hURLSourceKey);
			hURLSourceKey = 0;
		}
	}

	MsiString strPackageFullPath;
	if((piError = riSourceRoot.GetFullFilePath(ristrPackageName.GetString(), *&strPackageFullPath)) != 0)
		return piError;

	// SAFER check is not warranted here.  All we want to do is open up the package to read its source type.
	// we will have already opened the source package prior to this; therefore szFriendlyName and phSaferLevel is NULL
	if((piError = OpenAndValidateMsiStorageRec(strPackageFullPath, stDatabase, riServices, *&pStorage, /* fCallSAFER = */ false, /* szFriendlyName = */ NULL, /* phSaferLevel = */ NULL)) != 0)
	{
		piError->Release();
		piError = 0;

		// cannot open source storage file
		// if we have a database pointer to try, use it
		if(piDatabase)
		{
			pStorage = piDatabase->GetStorage(1);
		}
		else
		{
			return PostError(Imsg(imsgNetErrorReadingFromFile), *strPackageFullPath);
		}
	}

	Assert(pStorage);
		
	if ((piError = pStorage->CreateSummaryInfo(0, *&pSummary)) != 0)
		return piError;

	pSummary->GetIntegerProperty(PID_MSISOURCE, iSourceType);

	DEBUGMSGV2(TEXT("Source type from package '%s': %d"),ristrPackageName.GetString(),(const ICHAR*)(INT_PTR)iSourceType);

	return 0;
}

int CMsiEngine::GetDeterminedPackageSourceType()
{
	return m_iSourceType;
}

// GetSourceRootAndType: 
// returns the source type from the SOURCE package, which may be different than
// the source type of the CACHED package
IMsiRecord* CMsiEngine::GetSourceRootAndType(IMsiPath*& rpiSourceRoot, int& iSourceType)
{
	IMsiRecord* piError = 0;
	
	// the source for an embedded nested install is its parent's source
	if(*(const ICHAR*)m_strPackageName == ':' && m_piParentEngine)
	{
		// for child installs, we'll use the sourcetype of the package we are running from to determine
		// LFN/SFN and compressed/uncompressed
		// we use the parent package to determine admin/non-admin
		// there is really no good reason for this inconsistency, but its the logic used in MSI 1.1
		// and it isn't worth changing this behaviour for nested installs
		
		int iSourceTypeTemp = 0;
		if((piError = m_piParentEngine->GetSourceRootAndType(rpiSourceRoot, iSourceTypeTemp)) != 0)
			return piError;

		iSourceType = m_iCachedPackageSourceType & (~msidbSumInfoSourceTypeAdminImage);
		if(iSourceTypeTemp & msidbSumInfoSourceTypeAdminImage)
			iSourceType |= msidbSumInfoSourceTypeAdminImage;
	}
	else
	{
		if (!m_fSourceResolved)
		{
			if ((piError = ResolveSource()) != 0)
			{
				if (piError->GetInteger(1) == imsgSourceResolutionFailed)
					piError->SetMsiString(2, *MsiString(GetPropertyFromSz(IPROPNAME_PRODUCTNAME)));
				return piError; //!! Reformat error?
			}
		}

		if((piError = CreatePathObject(*MsiString(GetPropertyFromSz(IPROPNAME_SOURCEDIR)), rpiSourceRoot)) != 0)
			return piError;

		if(m_iSourceType == -1)
		{
			MsiString strProductKey = GetProductKey();
			if((piError = GetSourceTypeFromPackage(m_riServices, *rpiSourceRoot,
																*m_strPackageName, (const ICHAR*)strProductKey, m_piExternalDatabase,
																m_iSourceType)) != 0)
				return piError;
		
		}

		iSourceType = m_iSourceType;
	}
	
	return 0;
}

#ifdef DEBUG
void CMsiEngine::SetAssertFlag(Bool fShowAsserts)
{
	g_fNoAsserts = fShowAsserts;
}

void CMsiEngine::SetDBCSSimulation(char /*chLeadByte*/)
{
}

Bool CMsiEngine::WriteLog(const ICHAR *)
{
	return fFalse;
}

void CMsiEngine::AssertNoObjects()
{
}

void  CMsiEngine::SetRefTracking(long iid, Bool fTrack)
{

	::SetFTrackFlag(iid, fTrack);

}



#endif //DEBUG


IMsiRecord* CMsiEngine::LoadSelectionTables()
//-----------------------------------------
{
	// AFTERREBOOT or Resume properties set indicate that we are installing over a partial install
	// set flag to force reinstall of components
	if(MsiString(GetPropertyFromSz(IPROPNAME_RESUME)).TextSize() ||
		MsiString(GetPropertyFromSz(IPROPNAME_RESUMEOLD)).TextSize() ||
		MsiString(GetPropertyFromSz(IPROPNAME_AFTERREBOOT)).TextSize())
		m_fForceRequestedState = fTrue;

	SetCostingComplete(fFalse);
	IMsiRecord* piError = LoadFeatureTable();
	if (piError)
		return piError;

	return LoadComponentTable();
}


//____________________________________________________________________________
//
// IMsiSelectionManager implementation
//____________________________________________________________________________

IMsiRecord* CMsiEngine::LoadFeatureTable()
//----------------------------------------
{
	Assert(m_piDatabase);
	IMsiRecord* piError;
	m_piFeatureCursor = 0;
	m_piFeatureTable = 0;
	if ((piError = m_piDatabase->LoadTable(*MsiString(*sztblFeature),3,m_piFeatureTable)))
		return piError;

	m_colFeatureKey    = GetFeatureColumnIndex(sztblFeature_colFeature);
	m_colFeatureParent = GetFeatureColumnIndex(sztblFeature_colFeatureParent);
	m_colFeatureAuthoredLevel  = GetFeatureColumnIndex(sztblFeature_colAuthoredLevel);

	m_colFeatureAuthoredAttributes = GetFeatureColumnIndex(sztblFeature_colAuthoredAttributes);

	m_colFeatureConfigurableDir = GetFeatureColumnIndex(sztblFeature_colDirectory);
	m_colFeatureTitle = GetFeatureColumnIndex(sztblFeature_colTitle);
	m_colFeatureDescription = GetFeatureColumnIndex(sztblFeature_colDescription);
	m_colFeatureDisplay = GetFeatureColumnIndex(sztblFeature_colDisplay);

	m_colFeatureLevel = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colLevel));
	m_colFeatureAttributes = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colAttributes));
	m_colFeatureSelect = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colSelect));
	m_colFeatureAction = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colAction));
	m_colFeatureActionRequested = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colActionRequested));
	m_colFeatureInstalled = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colInstalled));
	m_colFeatureHandle = m_piFeatureTable->CreateColumn(IcdObjectPool() + icdNullable, *MsiString(*sztblFeature_colHandle));
	m_colFeatureRuntimeFlags = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colRuntimeFlags));
	m_colFeatureDefaultSelect = m_piFeatureTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeature_colDefaultSelect));
	if(!m_colFeatureKey || !m_colFeatureParent || !m_colFeatureConfigurableDir)
		return PostError(Imsg(idbgTableDefinition), sztblFeature);
	if (m_piFeatureTable->LinkTree(m_colFeatureParent) == -1)
		return PostError(Imsg(idbgLinkTable), sztblFeature);

	m_piFeatureCursor = m_piFeatureTable->CreateCursor(fTrue);
	if (!m_piFeatureCursor->Next())
	{
		m_piFeatureTable->Release();
		m_piFeatureTable = 0;

		m_piFeatureCursor->Release();
		m_piFeatureCursor = 0;
		return 0;
	}
	else
	{
		m_piFeatureCursor->Reset();
	}


	if ((piError = m_piDatabase->LoadTable(*MsiString(*sztblFeatureComponents),1,m_piFeatureComponentsTable)))
		return piError;

	m_colFeatureComponentsFeature = GetFeatureComponentsColumnIndex(sztblFeatureComponents_colFeature);
	m_colFeatureComponentsComponent = GetFeatureComponentsColumnIndex(sztblFeatureComponents_colComponent);
	m_colFeatureComponentsRuntimeFlags = m_piFeatureComponentsTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblFeatureComponents_colRuntimeFlags));
	if(!m_colFeatureComponentsFeature || !m_colFeatureComponentsComponent)
		return PostError(Imsg(idbgTableDefinition), sztblFeatureComponents);
		
	m_piFeatureComponentsCursor = m_piFeatureComponentsTable->CreateCursor(fFalse);
	
	SetProductAlienClientsFlag();
	return 0;
}

int CMsiEngine::GetFeatureColumnIndex(const ICHAR* szColumnName)
{
	return m_piFeatureTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szColumnName));
}


int CMsiEngine::GetFeatureComponentsColumnIndex(const ICHAR* szColumnName)
{
	return m_piFeatureComponentsTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szColumnName));
}


IMsiRecord* CMsiEngine::LoadComponentTable()
//----------------------------------------
{
	Assert(m_piDatabase);
	m_piComponentCursor = 0;
	IMsiRecord* piError = m_piDatabase->LoadTable(*MsiString(*sztblComponent),
													14,
													 m_piComponentTable);
	if (piError)
		return piError;

	m_colComponentKey       = GetComponentColumnIndex(sztblComponent_colComponent);
	m_colComponentDir       = GetComponentColumnIndex(sztblComponent_colDirectory);

	m_colComponentAttributes = GetComponentColumnIndex(sztblComponent_colAttributes);

	m_colComponentCondition = GetComponentColumnIndex(sztblComponent_colCondition);
	m_colComponentID = GetComponentColumnIndex(sztblComponent_colComponentId);
	m_colComponentKeyPath = GetComponentColumnIndex(sztblComponent_colKeyPath);

	// ComponentParent column is created for internal cost use only
	m_colComponentParent = m_piComponentTable->CreateColumn(icdString + icdNullable,*MsiString(*sztblComponent_colComponentParent));
	if(!m_colComponentKey || !m_colComponentParent || !m_colComponentAttributes)
		return PostError(Imsg(idbgTableDefinition), sztblComponent);

	m_colComponentInstalled = m_piComponentTable->CreateColumn(icdLong + icdNullable,*MsiString(*sztblComponent_colInstalled));
	m_colComponentAction     = m_piComponentTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblComponent_colAction));
	m_colComponentActionRequest = m_piComponentTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblComponent_colActionRequest));
	m_colComponentLocalCost  = m_piComponentTable->CreateColumn(icdLong + icdNullable,  *MsiString(*sztblComponent_colLocalCost));
	m_colComponentNoRbLocalCost  = m_piComponentTable->CreateColumn(icdLong + icdNullable,  *MsiString(*sztblComponent_colNoRbLocalCost));
	m_colComponentSourceCost= m_piComponentTable->CreateColumn(icdLong + icdNullable,  *MsiString(*sztblComponent_colSourceCost));
	m_colComponentRemoveCost= m_piComponentTable->CreateColumn(icdLong + icdNullable,  *MsiString(*sztblComponent_colRemoveCost));
	m_colComponentNoRbRemoveCost= m_piComponentTable->CreateColumn(icdLong + icdNullable,  *MsiString(*sztblComponent_colNoRbRemoveCost));
	m_colComponentNoRbSourceCost= m_piComponentTable->CreateColumn(icdLong + icdNullable,  *MsiString(*sztblComponent_colNoRbSourceCost));
	m_colComponentARPLocalCost = m_piComponentTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblComponent_colARPLocalCost));
	m_colComponentNoRbARPLocalCost = m_piComponentTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblComponent_colNoRbARPLocalCost));
	m_colComponentRuntimeFlags = m_piComponentTable->CreateColumn(icdLong + icdNullable,  *MsiString(*sztblComponent_colRuntimeFlags));
	m_colComponentForceLocalFiles = m_piComponentTable->CreateColumn(icdLong + icdNullable,*MsiString(*sztblComponent_colForceLocalFiles));
	m_colComponentLegacyFileExisted = m_piComponentTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblComponent_colLegacyFileExisted));
	m_colComponentTrueInstallState = m_piComponentTable->CreateColumn(icdLong + icdNullable, *MsiString(*sztblComponent_colTrueInstallSt));
	
	if (m_piComponentTable->LinkTree(m_colComponentParent) == -1)
		return PostError(Imsg(idbgLinkTable), sztblComponent);

	m_piComponentCursor = m_piComponentTable->CreateCursor(fTrue);
	if (!m_piComponentCursor)
		return PostError(Imsg(imsgOutOfMemory));

	if (!m_piComponentCursor->Next())
	{
		m_piComponentTable->Release();
		m_piComponentTable = 0;
		
		m_piComponentCursor->Release();
		m_piComponentCursor = 0;
		return 0;
	}
	else
	{
		m_piComponentCursor->Reset();
	}

	return 0;
}


int CMsiEngine::GetComponentColumnIndex(const ICHAR* szTableName)
{
	return m_piComponentTable ? m_piComponentTable->GetColumnIndex(m_piDatabase->EncodeStringSz(szTableName)) : 0;
}


IMsiTable* CMsiEngine::GetComponentTable()
//--------------------------------------
{
	if (m_piComponentTable)
		m_piComponentTable->AddRef();
	return m_piComponentTable;
}


IMsiTable* CMsiEngine::GetFeatureTable()
//--------------------------------------
{
	if (m_piFeatureTable)
		m_piFeatureTable->AddRef();
	return m_piFeatureTable;
}

IMsiTable* CMsiEngine::GetFeatureComponentsTable()
{
	if (m_piFeatureComponentsTable)
		m_piFeatureComponentsTable->AddRef();
	return m_piFeatureComponentsTable;
}

IMsiRecord* GetProductClients(IMsiServices& riServices, const ICHAR* szProduct, const IMsiString*& rpistrClients)
{
	CRegHandle HKey;
	DWORD dwResult = OpenAdvertisedProductKey(szProduct, HKey, false, 0);
	if (ERROR_SUCCESS != dwResult)
		return 0;

	PMsiRegKey pProductKey    = &riServices.GetRootKey((rrkEnum)(int)HKey, ibtCommon);
	
	AssertRecord(pProductKey->GetValue(szClientsValueName, *&rpistrClients));
	return 0;
}

Bool FFeaturesInstalled(IMsiEngine& riEngine, Bool fAllClients)
/*-------------------------------------------------------
Local function that returns fTrue if there is at least
one Feature in the Feature Table that is in the
installed (iisLocal or iisSource) state.
if fAllClients is set to false the "requested" features states
(for this particular invokation context of the product) is used
--------------------------------------------------------*/
{
	PMsiRecord pError(0);
	PMsiTable pFeatureTable(0);
	PMsiDatabase pDatabase = riEngine.GetDatabase();
	Assert(pDatabase);
	Bool fFeaturesInstalled = fFalse;

	pError = pDatabase->LoadTable(*MsiString(*sztblFeature), 1, *&pFeatureTable);
	if (pError)
	{
		if (pError->GetInteger(1) == idbgDbTableUndefined)
			pError = 0;
	}
	else
	{
		const ICHAR* szCol = (fAllClients) ? sztblFeature_colAction : sztblFeature_colActionRequested;

		int icolFeatureAction =    pFeatureTable->GetColumnIndex(pDatabase->EncodeString(*MsiString(*szCol)));
		int icolFeatureInstalled = pFeatureTable->GetColumnIndex(pDatabase->EncodeString(*MsiString(*sztblFeature_colInstalled)));
		if(icolFeatureAction && icolFeatureInstalled)
		{

			PMsiCursor pFeatureCursor(pFeatureTable->CreateCursor(fFalse));
			while ((fFeaturesInstalled == fFalse) && (pFeatureCursor->Next()))
			{
				iisEnum iisAction = (iisEnum) pFeatureCursor->GetInteger(icolFeatureAction);
				iisEnum iisInstalled = (iisEnum) pFeatureCursor->GetInteger(icolFeatureInstalled);
				if (iisAction != iMsiNullInteger)
					iisInstalled = iisAction;
				if (iisInstalled != iMsiNullInteger && iisInstalled != iisAbsent)
					fFeaturesInstalled = fTrue;
			}
		}
		else
		{
			// temp columns not added, assume this means costing wasn't performed
			// probably doing a simple task like MsiCollectUserInfo - return true so product is not unregistered
			fFeaturesInstalled = fTrue;
		}
	}
	AssertRecord(pError);//!!
	return fFeaturesInstalled;
}

Bool CMsiEngine::FreeSelectionTables()
//----------------------------------
{
	Bool fInstalledSelections = fFalse;
	if (m_piComponentTable && m_colComponentAction && m_colComponentInstalled)
	{
		PMsiCursor pComponentCursor(m_piComponentTable->CreateCursor(fFalse));
		while (pComponentCursor->Next())
		{
			iisEnum iisAction = (iisEnum) pComponentCursor->GetInteger(m_colComponentAction);
			iisEnum iisInstalled = (iisEnum) pComponentCursor->GetInteger(m_colComponentInstalled);
			if (iisAction != iMsiNullInteger)
			{
				iisInstalled = iisAction;
				AssertNonZero(pComponentCursor->PutInteger(m_colComponentInstalled,iisInstalled));
				AssertNonZero(pComponentCursor->Update());
			}
			if (iisInstalled != iMsiNullInteger && iisInstalled != iisAbsent)
				fInstalledSelections = fTrue;
		}
	}
	if (m_piFeatureCursor)
	{
		m_piFeatureCursor->Release();
		m_piFeatureCursor = 0;
	}
	if (m_piFeatureTable)
	{
		m_piFeatureTable->Release();
		m_piFeatureTable = 0;
	}

	if (m_piFeatureComponentsCursor)
	{
		m_piFeatureComponentsCursor->Release();
		m_piFeatureComponentsCursor = 0;
	}
	
	if (m_piFeatureComponentsTable)
	{
		m_piFeatureComponentsTable->Release();
		m_piFeatureComponentsTable = 0;
	}
	if (m_piComponentCursor)
	{
		m_piComponentCursor->Release();
		m_piComponentCursor = 0;
	}
	if (m_piComponentTable)
	{
		m_piComponentTable->Release();
		m_piComponentTable = 0;
	}
	if (m_piCostAdjusterTable)
	{
		m_piCostAdjusterTable->Release();
		m_piCostAdjusterTable = 0;
	}
	if (m_piVolumeCostTable)
	{
		m_piVolumeCostTable->Release();
		m_piVolumeCostTable = 0;
	}
	if (m_piCostLinkTable)
	{
		m_piCostLinkTable->Release();
		m_piCostLinkTable = 0;
	}
	if (m_piFeatureCostLinkTable)
	{
		m_piFeatureCostLinkTable->Release();
		m_piFeatureCostLinkTable = 0;
	}
	return fInstalledSelections;
}


IMsiRecord* CMsiEngine::ProcessPropertyFeatureRequests(int* iRequestCountParam, Bool fCountOnly)
/*---------------------------------------------------------------------------
Examines these properties:

ADDLOCAL,ADDSOURCE,ADDDEFAULT,REMOVE,REINSTALL, REINSTALLMODE
COMPADDLOCAL,COMPADDSOURCE,COMPADDDEFAULT
FILEADDLOCAL,FILEADDSOURCE,FILEADDDEFAULT

and appropriately configures the installation state of the specified features
(if any).  If iRequestCountParam, is nonzero, the count of feature
configuration requests (not the total count of features being configured)
will be returned.  If fCountOnly is fTrue, ONLY the request count will be
returned - no feature configuration states will actually be changed.
---------------------------------------------------------------------------*/
{
	IMsiRecord* piErrRec;

	if (!fCountOnly)
	{
		MsiString strReinstallMode(GetPropertyFromSz(IPROPNAME_REINSTALLMODE));
		if (strReinstallMode.TextSize() != 0)
		{
			piErrRec = SetReinstallMode(*strReinstallMode);
			if (piErrRec)
				return piErrRec;
		}
	}

	// check to see if we have nothing to do
	bool fNoActionToPerform = false;
	MsiString strNoAction(GetPropertyFromSz(szFeatureSelection));
	if (strNoAction.TextSize())
	{
		Assert(0 != strNoAction.Compare(iscExact, szFeatureDoNothingValue));
		fNoActionToPerform = true;
		if (!fCountOnly)
		{
			// on 1st install, the only selections made were to to turn everything off -- in essence, do nothing
			// we want to ensure that we do not install anything since we've already turned them off on the client
			if ((piErrRec = ConfigureAllFeatures((iisEnum)iMsiNullInteger)) != 0)
				return piErrRec;
		}
	}

	int cCount = 0;
	int iRequestCount = 0;
	for(cCount = 0; cCount < g_cFeatureProperties; cCount++)
	{
		MsiString strFeatureInfo(GetPropertyFromSz(g_rgFeatures[cCount].szFeatureActionProperty));
		strFeatureInfo += TEXT(","); // helps our loop
		while(strFeatureInfo.TextSize())
		{
			MsiString strFeature = strFeatureInfo.Extract(iseUpto, ',');
			if(strFeature.TextSize())
			{
				iRequestCount++;
				if (!fCountOnly)
				{
					switch (g_rgFeatures[cCount].ircRequestClass)
					{
						case ircFeatureClass:
						{
							piErrRec = ConfigureThisFeature(*strFeature,g_rgFeatures[cCount].iisFeatureRequest, /* fThisOnly=*/ fTrue);
							if (piErrRec)
								return piErrRec;
							break;
						}
						case ircComponentClass:
						{
							MsiString strComponent;
							if ((piErrRec = ComponentIDToComponent(*strFeature, *&strComponent)) != 0)
								return piErrRec;
							if ((piErrRec = ConfigureComponent(*strComponent,g_rgFeatures[cCount].iisFeatureRequest)) != 0)
							if (piErrRec)
								return piErrRec;
							break;
						}
						case ircFileClass:
						{
							piErrRec = ConfigureFile(*strFeature,g_rgFeatures[cCount].iisFeatureRequest);
							if (piErrRec)
								return piErrRec;
							break;
						}
						default:
						{
							Assert(0);
							break;
						}
					}
				}
			}
			strFeatureInfo.Remove(iseIncluding, ',');
		}
	}
	if (fNoActionToPerform)
	{
		Assert(iRequestCount == 0);
	}

	if (iRequestCountParam)
		*iRequestCountParam = fNoActionToPerform ? 1 : iRequestCount;
	return 0;
}

IMsiRecord* CMsiEngine::ComponentIDToComponent(const IMsiString& riIDString,
											   const IMsiString*& rpiComponentString)
/*--------------------------------------------------------------------------
Local routine that accepts a ComponentID string, and returns the associated
Component's key name.  If the ComponentID is unknown, and error record will
be returned instead.
--------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	CreateSharedCursor(piComponentCursor, m_piComponentCursor);
	m_piComponentCursor->SetFilter(iColumnBit(m_colComponentID));
	m_piComponentCursor->PutString(m_colComponentID,riIDString);
	if (m_piComponentCursor->Next())
	{
		rpiComponentString = &m_piComponentCursor->GetString(m_colComponentKey);
	}
	else
		return PostError(Imsg(idbgBadComponent),riIDString);

	return 0;

}

IMsiRecord* CMsiEngine::SetReinstallMode(const IMsiString& riModeString)
//--------------------------------------
{
	const ICHAR* pchModeChars = szReinstallMode;
	const ICHAR* pchMode = riModeString.GetString();
	m_fMode &= 0x0000FFFF; // Clear all install overwrite bits
	ICHAR ch;
	while ((ch = *pchMode++) != 0)
	{
		if (ch == ' ')
			continue;
		if (ch >= 'A' && ch <= 'Z')
			ch += ('a' - 'A');
		for (const ICHAR* pch = pchModeChars; *pch != ch; pch++)
		{
			if (*pch == 0)
				return PostError(Imsg(idbgBadReinstallMode),pch);
		}
		m_fMode |= (1 << (16 + pch - pchModeChars));
	}
	AssertNonZero(SetProperty(*MsiString(IPROPNAME_REINSTALLMODE), riModeString));
	return 0;
}

IMsiRecord* CMsiEngine::ConfigureFile(const IMsiString& riFileString,iisEnum iisActionRequest)
/*-------------------------------------------------------------------
Examines every feature linked to the component that owns riFileString
(via the File table), and calls ConfigureFeature on the feature that
would incur the smallest disk cost to install.
---------------------------------------------------------------------*/
{
	const ICHAR szSqlFile[] =
	TEXT("SELECT `Component_` FROM `File` WHERE `File`=?");

	enum ifqEnum
	{
		ifqComponent = 1,
		ifqNextEnum
	};
	PMsiView pFileView(0);
	IMsiRecord* piErrRec;
	piErrRec = OpenView(szSqlFile, ivcFetch, *&pFileView);
	if (piErrRec)
		return piErrRec;

	PMsiServices pServices(GetServices());
	PMsiRecord pExecRec(&pServices->CreateRecord(1));
	pExecRec->SetMsiString(1, riFileString);
	if ((piErrRec = pFileView->Execute(pExecRec)) != 0)
		return piErrRec;
	
	 PMsiRecord pFileRec(pFileView->Fetch());
	 if (pFileRec == 0)
		 return PostError(Imsg(idbgBadFile),riFileString);

	 if ((piErrRec = ConfigureComponent(*MsiString(pFileRec->GetMsiString(ifqComponent)),iisActionRequest)) != 0)
		 return piErrRec;

	 return 0;
}



IMsiRecord* CMsiEngine::ConfigureComponent(const IMsiString& riComponentString,iisEnum iisActionRequest)
/*-------------------------------------------------------------------
Examines every feature linked to riComponentString, and calls
ConfigureFeature on the feature that would incur the smallest disk
cost to install.
---------------------------------------------------------------------*/
{
	CreateSharedCursor(pFeatureComponentsCursor,m_piFeatureComponentsCursor);
	Assert(m_piFeatureComponentsCursor);
	m_piFeatureComponentsCursor->SetFilter(iColumnBit(m_colFeatureComponentsComponent));
	m_piFeatureComponentsCursor->PutString(m_colFeatureComponentsComponent,riComponentString);
	IMsiRecord* piErrRec;

	MsiString strCheapestFeature;
	int iCheapestCost = 2147483647; // Init to largest possible cost
	while (m_piFeatureComponentsCursor->Next())
	{
		int iFeatureCost;
		MsiString strFeature = m_piFeatureComponentsCursor->GetString(m_colFeatureComponentsFeature);
		if ((piErrRec = GetAncestryFeatureCost(*strFeature,iisActionRequest,iFeatureCost)) != 0)
			return piErrRec;

		if (iFeatureCost < iCheapestCost)
		{
			strCheapestFeature = strFeature;
			iCheapestCost = iFeatureCost;
		}
	}
	if (strCheapestFeature.TextSize() > 0)
		return ConfigureThisFeature(*strCheapestFeature,iisActionRequest, /* fThisOnly= */ fTrue);
	else
		return PostError(Imsg(idbgBadComponent),riComponentString);
}


IMsiRecord* CMsiEngine::ConfigureFeature(const IMsiString& riFeatureString,iisEnum iisActionRequest)
//--------------------------------------
{
	return ConfigureThisFeature(riFeatureString, iisActionRequest, /* fThisOnly= */ fFalse);
}


IMsiRecord* CMsiEngine::ConfigureThisFeature(const IMsiString& riFeatureString,iisEnum iisActionRequest, Bool fThisOnly)
//---------------------------------------------------------------------------------------
// If fThisOnly is true, only the specified feature will be configured, without affecting
// any child features.
//---------------------------------------------------------------------------------------
{
	IMsiRecord *piErrRec;
	
	Bool fArgAll = riFeatureString.Compare(iscExactI, IPROPVALUE_FEATURE_ALL) ? fTrue : fFalse;
	if (fArgAll)
	{
		// Before we used to call SetCostingComplete(false) -- but this was wrong.  This was
		// made under the assumption that specification of ALL would only occur on the command line.
		// However, this is not the case as a custom action can call MsiSetFeatureState("ALL") during
		// an install in order to force all features to go to one state. SetCostingComplete(false)
		// is expensive as it results in re-initialization of all dynamic costing.  This is already taken
		// care of when the install starts via SetInstallLevel which is called by the CostFinalize action.
		// All we really want here is to simply update the cost based upon the changing action states of
		// the components
		piErrRec = ConfigureAllFeatures(iisActionRequest);
		if (piErrRec)
			return piErrRec;

		if (!fThisOnly)
		{
			if ((piErrRec = UpdateFeatureActionState(0,/* fTrackParent = */ fFalse)) != 0)
				return piErrRec;
			if ((piErrRec = UpdateFeatureComponents(0)) != 0)
				return piErrRec;
		}
	}
	else if (fThisOnly)
	{
		piErrRec = SetThisFeature(riFeatureString,iisActionRequest, /* fSettingAll = */ fFalse);
		if (piErrRec)
			return piErrRec;
	}
	else
	{
		piErrRec = SetFeature(riFeatureString,iisActionRequest);
		if (piErrRec)
			return piErrRec;
	}


	return DetermineEngineCostOODS();

}


IMsiRecord* CMsiEngine::ConfigureAllFeatures(iisEnum iisActionRequest)
/*------------------------------------------------------------
Internal function that sets all non-disabled features to the
requested state.
--------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pFeatureCursor(m_piFeatureTable->CreateCursor(fFalse));
	pFeatureCursor->SetFilter(0);
	IMsiRecord* piErrRec;
	while (pFeatureCursor->Next() > 0)
	{
		MsiString istrFeature = pFeatureCursor->GetString(m_colFeatureKey);
		piErrRec = SetThisFeature(*istrFeature, iisActionRequest, /* fSettingAll= */ fTrue);
		if (piErrRec)
			return piErrRec;
	}
	return 0;
}


IMsiRecord* CMsiEngine::ProcessConditionTable()
//-------------------------------------------
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	bool fAdmin = GetMode() & iefAdmin;
	
	PMsiTable pConditionTable(0);
	IMsiRecord* piError;
	if ((piError = m_piDatabase->LoadTable(*MsiString(*sztblCondition), 0, *&pConditionTable)))
	{       // Not a problem if Condition table not found
		if (piError->GetInteger(1) == idbgDbTableUndefined)
		{
			piError->Release();
			return 0;
		}
		else
			return piError;
	}

	int colFeature = pConditionTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblCondition_colFeature));
	int colCondition = pConditionTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblCondition_colCondition));
	int colLevel     = pConditionTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblCondition_colLevel));
	PMsiCursor pCursor(pConditionTable->CreateCursor(fFalse));
	Assert(pCursor);
	if (!colFeature || !colCondition || !colLevel)
		return PostError(Imsg(idbgTableDefinition),sztblCondition);

	PMsiCursor pFeatureCursor(m_piFeatureTable->CreateCursor(fFalse));
	pFeatureCursor->SetFilter(1);
	while (pCursor->Next())
	{
		pFeatureCursor->Reset();
		MsiString istrConditionFeature(pCursor->GetString(colFeature));
		pFeatureCursor->PutString(m_colFeatureKey, *istrConditionFeature);
		if (pFeatureCursor->Next())
		{
#ifdef DEBUG
			const ICHAR* szFeature = MsiString(pCursor->GetString(colFeature));
#endif
			if (fAdmin || EvaluateCondition(MsiString(pCursor->GetString(colCondition))) == iecTrue)
			{
				pFeatureCursor->PutInteger(m_colFeatureLevel, pCursor->GetInteger(colLevel));
				AssertNonZero(pFeatureCursor->Update());
			}
		}
		else
			return PostError(Imsg(idbgBadForeignKey),
				*MsiString(m_piDatabase->DecodeString(pCursor->GetInteger(colFeature))),
				*MsiString(*sztblCondition_colFeature),*MsiString(*sztblCondition));
	}
	return 0;
}

IMsiRecord* CMsiEngine::SetInstallLevel(int iInstallLevel)
//-------------------------------------
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	// determine the client state for the product

	// If called with iInstallLevel == 0, indicates caller doesn't want to
	// change the current installLevel; just wants to update all features
	if (iInstallLevel > 0)
		AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_INSTALLLEVEL),iInstallLevel));
	else
		iInstallLevel = GetPropertyInt(*MsiString(*IPROPNAME_INSTALLLEVEL));

	// If the install level has never been set, default to 1
	if (iInstallLevel == iMsiNullInteger)
	{
		iInstallLevel = 1;
		AssertNonZero(SetPropertyInt(*MsiString(*IPROPNAME_INSTALLLEVEL),iInstallLevel));
	}

	IMsiRecord* piErrRec = 0;
	int iPropertyFeatureRequestCount = 0;
	if(!(m_fMode & iefAdvertise))
	{
		// If any Feature selection requests are pending via a property such as ADDLOCAL, ADDSOURCE, etc,
		// then only those requests shall be honored.  We won't select ON any features here in SetInstallLevel.
		piErrRec = ProcessPropertyFeatureRequests(&iPropertyFeatureRequestCount,/* fCountOnly = */ fTrue);
		if (piErrRec)
			return piErrRec;
	}

	PMsiCursor pFeatureCursor(m_piFeatureTable->CreateCursor(fTrue));
	pFeatureCursor->Reset();
	pFeatureCursor->SetFilter(0);
	int iTreeLevel;

	iisEnum iisParInstalled[MAX_COMPONENT_TREE_DEPTH + 1];

	PMsiCursor pFeatureComponentsCursor(m_piFeatureComponentsTable->CreateCursor(fFalse));
	pFeatureComponentsCursor->SetFilter(1);

	PMsiCursor pFeatureCursorTemp(m_piFeatureTable->CreateCursor(fTrue));
	
	while ((iTreeLevel = pFeatureCursor->Next()) > 0)
	{
		if (iTreeLevel > MAX_COMPONENT_TREE_DEPTH)
			return PostError(Imsg(idbgIllegalTreeDepth),MAX_COMPONENT_TREE_DEPTH);
		
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		MsiStringId idFeature = pFeatureCursor->GetInteger(m_colFeatureKey);
#ifdef DEBUG
		ICHAR rgchFeature[256];
		MsiString stFeature(m_piDatabase->DecodeString(idFeature));
		stFeature.CopyToBuf(rgchFeature,255);
#endif

		iisParInstalled[iTreeLevel] = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureInstalled);
		Bool fMaint = GetMode() & iefMaintenance ? fTrue : fFalse;
		Bool fParInstalled = (iTreeLevel == 1 || (iisParInstalled[iTreeLevel  - 1] != iMsiNullInteger &&
					  iisParInstalled[iTreeLevel - 1] != iisAbsent &&
							  iisParInstalled[iTreeLevel - 1] != iisAdvertise)) ?
								fTrue : fFalse;

		// m_colFeatureLevel and m_colFeatureAttributes are temporary runtime versions
		// of the authored columns - temporary so that they can be altered at runtime.
		// If a value hasn't been set yet, copy over the authored values from the
		// permanent columns.
		int iFeatureLevel = pFeatureCursor->GetInteger(m_colFeatureLevel);
		if (iFeatureLevel == iMsiNullInteger)
		{
			iFeatureLevel = pFeatureCursor->GetInteger(m_colFeatureAuthoredLevel);
			AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureLevel,iFeatureLevel));
			AssertNonZero(pFeatureCursor->Update());
		}
		int ifeaAttributes = pFeatureCursor->GetInteger(m_colFeatureAttributes);
		if (ifeaAttributes == iMsiNullInteger)
		{
			ifeaAttributes = pFeatureCursor->GetInteger(m_colFeatureAuthoredAttributes);
			AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureAttributes,ifeaAttributes));
			AssertNonZero(pFeatureCursor->Update());
		}

#ifdef DEBUG
		if (iFeatureLevel == iMsiNullInteger)
			return PostError(Imsg(idbgNullInNonNullableColumn),stFeature,sztblFeature_colLevel,sztblFeature);
#endif

		// Determine the default Select state for the feature, and store it for
		// future use in the 'DefaultSelect' column.
		int iValidStates;
		piErrRec = GetFeatureValidStates(idFeature,iValidStates, pFeatureComponentsCursor, pFeatureCursorTemp);
		if (piErrRec)
			return piErrRec;
		
		iisEnum iisFeatureSelect = (iisEnum) iMsiNullInteger;
		if (((ifeaAttributes & ifeaInstallMask) == ifeaFavorSource) && (iValidStates & icaBitSource))
			iisFeatureSelect = iisSource;
		else if (iValidStates & icaBitLocal)
			iisFeatureSelect = iisLocal;
		else if (iValidStates & icaBitSource)
			iisFeatureSelect = iisSource;

		int iRuntimeFlags = iValidStates & icaBitPatchable ? bfFeaturePatchable : 0;
		iRuntimeFlags |= (iValidStates & icaBitCompressable ? bfFeatureCompressable : 0);
		AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureRuntimeFlags, iRuntimeFlags));
		AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureDefaultSelect,iisFeatureSelect));
		AssertNonZero(pFeatureCursor->Update());

		// No features will be selected ON if either in maintenance, or if property feature
		// requests are pending.
		Bool fFeatureSelectable =
			((m_fMode & iefAdvertise) || ((fMaint == fFalse || fParInstalled == fFalse) && iPropertyFeatureRequestCount == 0)) ? fTrue : fFalse;

		if (fFeatureSelectable && iFeatureLevel > 0 && iFeatureLevel <= iInstallLevel)
		{
			if(!(m_fMode & iefAdvertise))
			{
				AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureSelect,
					  (ifeaAttributes & ifeaFavorAdvertise) && (iValidStates & icaBitAdvertise) ? iisAdvertise : iisFeatureSelect));
			}
			else
			{
				AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureSelect,
							  (iValidStates & icaBitAdvertise) ? iisAdvertise : iisAbsent));
			}
		}
		else
		{
			AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureSelect, iMsiNullInteger));
		}
		AssertNonZero(pFeatureCursor->Update());

	}
	if ((piErrRec = ProcessPropertyFeatureRequests(0,/* fCountOnly = */ fFalse)) != 0)
		return piErrRec;
	if ((piErrRec = UpdateFeatureActionState(0,/* fTrackParent = */ fFalse, pFeatureComponentsCursor, pFeatureCursorTemp)) != 0)
		return piErrRec;
	if ((piErrRec = UpdateFeatureComponents(0)) != 0)
		return piErrRec;
		
	if ((piErrRec = DetermineEngineCostOODS()) != 0)
		return piErrRec;

	if (m_fCostingComplete == fFalse && m_iuiLevel == iuiFull)
	{
		if ((piErrRec = InitializeDynamicCost(/* fReinitialize = */ fFalse)) != 0)
			return piErrRec;
	}
	m_fSelManInitComplete = true;
	return 0;
}

IMsiRecord* CMsiEngine::SetAllFeaturesLocal()
//-------------------------------------
{
	IMsiRecord* piErrRec = 0;
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pFeatureCursor(m_piFeatureTable->CreateCursor(fFalse));
	while (pFeatureCursor->Next())
	{
#ifdef DEBUG
		MsiString strFeature = pFeatureCursor->GetString(m_colFeatureKey);
		ICHAR rgchFeature[256];
		strFeature.CopyToBuf(rgchFeature,255);
#endif

		AssertNonZero(pFeatureCursor->PutInteger(m_colFeatureSelect,iisLocal));
		AssertNonZero(pFeatureCursor->Update());
	}
	if ((piErrRec = UpdateFeatureActionState(0,/* fTrackParent = */ fFalse)) != 0)
		return piErrRec;
	if ((piErrRec = UpdateFeatureComponents(0)) != 0)
		return piErrRec;
		
	if ((piErrRec = DetermineEngineCostOODS()) != 0)
		return piErrRec;

	if (m_fCostingComplete == fFalse)
	{
		if ((piErrRec = InitializeDynamicCost(/* fReinitialize = */ fFalse)) != 0)
			return piErrRec;
	}
	return 0;
}



IMsiRecord* CMsiEngine::SetThisFeature(const IMsiString& riFeatureString, iisEnum iisRequestedState, Bool fSettingAll)
//--------------------------------------------------------------------------------
/* Sets the specified feature to the specified select state, without affecting any
   child features.  As an optimization, pass fSettingAll as true if SetThisFeature
   will be called for every feature in the product.
---------------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	IMsiRecord* piErrRec;
	MsiString strFeature(riFeatureString.GetString());
	PMsiCursor pFeatureCursor(m_piFeatureTable->CreateCursor(fFalse));
	pFeatureCursor->SetFilter(iColumnBit(m_colFeatureKey));
	pFeatureCursor->Reset();
	pFeatureCursor->PutString(m_colFeatureKey, *strFeature);
	if (!pFeatureCursor->Next())
		return PostError(Imsg(idbgBadFeature),(const ICHAR*) strFeature);

	// if Level == 0, the feature is permanently disabled
	if (pFeatureCursor->GetInteger(m_colFeatureLevel) == 0)
		return 0;

	// A requested state of iisCurrent denotes a request for the 'default' authored install state
	if (iisRequestedState == iisCurrent)
		iisRequestedState = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureDefaultSelect);

	iisEnum iisInstalled = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureInstalled);

	// bug 7468 - prevent ABSENT -> ABSENT always and !! in the future prevent <state X> -> <state X> in all cases except reinstall
	if((iisInstalled == iMsiNullInteger || iisInstalled == iisAbsent) && (iisRequestedState == iisAbsent || iisRequestedState == iisReinstall)) // || (iisInstalled == iisRequestedState))
		iisRequestedState = (iisEnum)iMsiNullInteger;

	iisEnum iisSelect;
	piErrRec = ValidateFeatureSelectState(riFeatureString,iisRequestedState,iisSelect);
	if (piErrRec)
		return piErrRec;

	pFeatureCursor->PutInteger(m_colFeatureSelect,iisSelect);
	pFeatureCursor->Update();
	iisEnum iisFinalState = iisSelect == iMsiNullInteger ? iisInstalled : iisSelect;

	// If the request is to install the feature, we must also make sure that
	// all parent features get installed (if they are not already selected)
	// Also, if fSettingAll is true, we know we don't need to bother turning
	// on parent, because the caller has (or will) initialize every feature
	// in the product to the desired state.
	if (!fSettingAll && iisSelect != iisAbsent && iisSelect != iMsiNullInteger)
	{
		MsiString strFeatureParent = pFeatureCursor->GetString(m_colFeatureParent);
		while (strFeatureParent.TextSize() && !strFeatureParent.Compare(iscExact,strFeature))
		{
			pFeatureCursor->Reset();
			pFeatureCursor->PutString(m_colFeatureKey, *strFeatureParent);
			if (!pFeatureCursor->Next())
				return PostError(Imsg(idbgBadFeature),(const ICHAR*) strFeatureParent);

			iisEnum iParInstalled = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureInstalled);
			iisEnum iParSelect = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureSelect);
			iisEnum iParFinalState = iParSelect == iMsiNullInteger ? iParInstalled : iParSelect;
			
			// if the parent's final state is to be installed, we don't need to
			// change anything, and we can stop walking up the parent tree, since
			// we therefore know that all parents up to the root must also be "ON"
			if (iParFinalState != iisAbsent && iParFinalState != iMsiNullInteger && iParFinalState != iisAdvertise)
				break;

			// We'll try to set the parent to the install state that the child was set to, but if
			// that state isn't valid for the parent, ValidateFeatureSelectState will change it to
			// a valid state for us.
			iisEnum iisParSelect = iParInstalled == iisFinalState ? (iisEnum) iMsiNullInteger : iisFinalState;

			iisEnum iisValidState;
			piErrRec = ValidateFeatureSelectState(*strFeatureParent,iisParSelect,iisValidState);
			if (piErrRec)
				return piErrRec;
			if (iisValidState == iParInstalled)
				iisValidState = (iisEnum) iMsiNullInteger;

			pFeatureCursor->PutInteger(m_colFeatureSelect,iisValidState);
			pFeatureCursor->Update();
			strFeature = strFeatureParent;
			strFeatureParent = pFeatureCursor->GetString(m_colFeatureParent);
		}
	}
	return 0;
}


IMsiRecord* CMsiEngine::SetFeatureAttributes(const IMsiString& ristrFeature, int iAttributes)
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	// Must be called before SetInstallLevel has been called
	if (m_fSelManInitComplete)
		return PostError(Imsg(idbgBadActionData), 0);

	PMsiCursor pFeatureCursor(m_piFeatureTable->CreateCursor(fFalse));
	pFeatureCursor->SetFilter(iColumnBit(m_colFeatureKey));
	pFeatureCursor->Reset();
	pFeatureCursor->PutString(m_colFeatureKey, ristrFeature);
	if (!pFeatureCursor->Next())
		return PostError(Imsg(idbgBadFeature), ristrFeature.GetString());

	int iAttributesToSet = (iAttributes & INSTALLFEATUREATTRIBUTE_FAVORLOCAL) ? msidbFeatureAttributesFavorLocal : 0;
	iAttributesToSet |= (iAttributes & INSTALLFEATUREATTRIBUTE_FAVORSOURCE) ? msidbFeatureAttributesFavorSource : 0;
	iAttributesToSet |= (iAttributes & INSTALLFEATUREATTRIBUTE_FOLLOWPARENT) ? msidbFeatureAttributesFollowParent : 0;
	iAttributesToSet |= (iAttributes & INSTALLFEATUREATTRIBUTE_FAVORADVERTISE) ? msidbFeatureAttributesFavorAdvertise : 0;
	iAttributesToSet |= (iAttributes & INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE) ? msidbFeatureAttributesDisallowAdvertise : 0;
	iAttributesToSet |= (iAttributes & INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE) ? msidbFeatureAttributesNoUnsupportedAdvertise : 0;

	pFeatureCursor->PutInteger(m_colFeatureAttributes,iAttributesToSet);
	pFeatureCursor->Update();
	return 0;
}


IMsiRecord* CMsiEngine::SetFeature(const IMsiString& riFeatureString, iisEnum iisRequestedState)
//--------------------------------
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	bool fSetAll = false;
	IMsiRecord* piErrRec;
	if (iisRequestedState == iisLocalAll || iisRequestedState == iisSourceAll)
	{
		fSetAll = true;
		iisRequestedState = iisRequestedState == iisLocalAll ? iisLocal : iisSource;
		piErrRec = SetFeatureChildren(riFeatureString, iisRequestedState);
		if (piErrRec)
			return piErrRec;
	}

	MsiString strFeature(riFeatureString.GetString());
	PMsiCursor pFeatureCursor(m_piFeatureTable->CreateCursor(fFalse));
	pFeatureCursor->SetFilter(iColumnBit(m_colFeatureKey));
	pFeatureCursor->Reset();
	pFeatureCursor->PutString(m_colFeatureKey, *strFeature);
	if (!pFeatureCursor->Next())
		return PostError(Imsg(idbgBadFeature),(const ICHAR*) strFeature);

	// if Level == 0, the feature is permanently disabled
	if (pFeatureCursor->GetInteger(m_colFeatureLevel) == 0)
		return 0;

	// A requested state of iisCurrent denotes a request for the 'default' authored install state
	if (iisRequestedState == iisCurrent)
		iisRequestedState = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureDefaultSelect);

	iisEnum iisSelect;
	piErrRec = ValidateFeatureSelectState(riFeatureString,iisRequestedState,iisSelect);
	if (piErrRec)
		return piErrRec;

	pFeatureCursor->PutInteger(m_colFeatureSelect,iisSelect);
	pFeatureCursor->Update();
	iisEnum iisInstalled = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureInstalled);
	iisEnum iisFinalState = iisSelect == iMsiNullInteger ? iisInstalled : iisSelect;

	// If the request is to install the feature, we must also make sure that
	// all parent features get installed (if they are not already selected)
	if (iisFinalState != iisAbsent && iisFinalState != iMsiNullInteger)
	{
		MsiString strFeatureParent = pFeatureCursor->GetString(m_colFeatureParent);
		while (strFeatureParent.TextSize() && !strFeatureParent.Compare(iscExact,strFeature))
		{
			pFeatureCursor->Reset();
			pFeatureCursor->PutString(m_colFeatureKey, *strFeatureParent);
			if (!pFeatureCursor->Next())
				return PostError(Imsg(idbgBadFeature),(const ICHAR*) strFeatureParent);

			iisEnum iParInstalled = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureInstalled);
			iisEnum iParAction = (iisEnum) pFeatureCursor->GetInteger(m_colFeatureAction);
			iisEnum iParFinalState = iParAction == iMsiNullInteger ? iParInstalled : iParAction;
			
			// if the parent's final state is to be installed, we don't need to
			// change anything, and we can stop walking up the parent tree, since
			// we therefore know that all parents up to the root must also be "ON"
			if (iParFinalState != iisAbsent && iParFinalState != iMsiNullInteger && iParFinalState != iisAdvertise)
				break;

			// We'll try to set the parent to the install state that the child was set to, but if
			// that state isn't valid for the parent, ValidateFeatureSelectState will change it to
			// a valid state for us.
			iisEnum iisParSelect = iParInstalled == iisFinalState ? (iisEnum) iMsiNullInteger : iisFinalState;

			iisEnum iisValidState;
			piErrRec = ValidateFeatureSelectState(*strFeatureParent,iisParSelect,iisValidState);
			if (piErrRec)
				return piErrRec;
			if (iisValidState == iParInstalled)
				iisValidState = (iisEnum) iMsiNullInteger;

			pFeatureCursor->PutInteger(m_colFeatureSelect,iisValidState);
			pFeatureCursor->PutInteger(m_colFeatureRuntimeFlags,pFeatureCursor->GetInteger(m_colFeatureRuntimeFlags) | bfFeatureMark);
			pFeatureCursor->Update();
			strFeature = strFeatureParent;
			strFeatureParent = pFeatureCursor->GetString(m_colFeatureParent);
		}
	}

	// If we had to turn on one or more parent features above to get riFeatureString installed,
	// we've got some work to do.  In the above code, we 'marked' the parent features we
	// turned on, and below we'll 'mark' riFeatureString and all its children.  Then we can
	// turn off every feature below the topmost parent we had to turn on, specifically
	// excepting the 'marked' children (that's what the second call to MarkOrResetFeatureTree
	// does, you'll be happy to note).
	Bool fTrackParent = fTrue;

	if (!strFeature.Compare(iscExact,riFeatureString.GetString()))
	{
		fTrackParent = fFalse;
		piErrRec = MarkOrResetFeatureTree(riFeatureString, /* Mark */ fTrue);
		if (piErrRec)
			return piErrRec;
		piErrRec = MarkOrResetFeatureTree(*strFeature, /* Reset */ fFalse);
		if (piErrRec)
			return piErrRec;
	}


	// we do not want to track parent in case of reinstall or if we're setting all children
	if(iisFinalState == iisReinstall || fSetAll == true)
		fTrackParent = fFalse;

	// Also note that if we are updating the feature tree starting from some parent
	// of riFeatureString that we had to turn on, it would be bad to allow
	// UpdateFeatureActionState to do its usual work of flipping children
	// under strFeature to match strFeature's Attributes state.  We disable that
	// by setting fTrackParent to fFalse.
	piErrRec = UpdateFeatureActionState(strFeature,fTrackParent);
	if (piErrRec)
		return piErrRec;
	return UpdateFeatureComponents(strFeature);
}


IMsiRecord* CMsiEngine::ValidateFeatureSelectState(const IMsiString& riFeatureString,iisEnum iisRequestedState,
												   iisEnum& iisValidState)
/*----------------------------------------------------------------------------
Internal function that accepts a string specifying a feature, and a proposed
Select state.  In the iisValidState parameter, a valid state that is as 'close'
as possible to the proposed state is returned.
------------------------------------------------------------------------------*/
{
	int iValidStates;
	MsiStringId idFeatureString = m_piDatabase->EncodeString(riFeatureString);
	IMsiRecord* piErrRec = GetFeatureValidStates(idFeatureString,iValidStates);
	if (piErrRec)
		return piErrRec;
	
	if (iisRequestedState != iisSource && iisRequestedState != iisLocal && (iisRequestedState != iisAdvertise || (iValidStates & icaBitAdvertise)))
		iisValidState = iisRequestedState;
	else if(iisRequestedState == iisAdvertise && (iValidStates & icaBitAbsent))
		iisValidState = iisAbsent;
	else if (iisRequestedState == iisSource && (iValidStates & icaBitSource))
		iisValidState = iisSource;
	else if (iisRequestedState == iisLocal && (iValidStates & icaBitLocal))
		iisValidState = iisLocal;
	else if (iValidStates & icaBitSource)
		iisValidState = iisSource;
	else if (iValidStates & icaBitLocal)
		iisValidState = iisLocal;
	else
		iisValidState = (iisEnum) iMsiNullInteger;
	return 0;
}


IMsiRecord* CMsiEngine::SetFeatureChildren(const IMsiString& riFeatureString, iisEnum iisRequestedState)
/*----------------------------------------------------------------------------*/
{
	int iParentLevel = 0;
	int iTreeLevel = 0;
	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));

	// Set up the tree-walking cursor for all riFeatureString's children
	pCursor->SetFilter(1);
	pCursor->PutString(m_colFeatureKey,riFeatureString);
	if ((iTreeLevel = pCursor->Next()) == 0)
		return PostError(Imsg(idbgBadFeature),riFeatureString.GetString());
	iParentLevel = iTreeLevel;
	pCursor->SetFilter(0);
	IMsiRecord* piErrRec;
	do
	{
		MsiString strChildFeature(pCursor->GetString(m_colFeatureKey));
#ifdef DEBUG
		ICHAR rgchFeature[256];
		strChildFeature.CopyToBuf(rgchFeature,255);
#endif
		iisEnum iisSelect;
		piErrRec = ValidateFeatureSelectState(*strChildFeature,iisRequestedState,iisSelect);
		if (piErrRec)
			return piErrRec;
		pCursor->PutInteger(m_colFeatureSelect,iisSelect);
		pCursor->Update();
	}while ((iTreeLevel = pCursor->Next()) > iParentLevel);
	return 0;
}


IMsiRecord* CMsiEngine::CheckFeatureTreeGrayState(const IMsiString& riFeatureString, bool& rfIsGray)
/*----------------------------------------------------------------------------*/
{
	rfIsGray = false;
	int iParentLevel = 0;
	int iTreeLevel = 0;
	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));

	// Set up the tree-walking cursor for all riFeatureString's children
	pCursor->SetFilter(1);
	pCursor->PutString(m_colFeatureKey,riFeatureString);
	if ((iTreeLevel = pCursor->Next()) == 0)
		return PostError(Imsg(idbgBadFeature),riFeatureString.GetString());

	iisEnum iisParentState = (iisEnum) pCursor->GetInteger(m_colFeatureAction);
	if (iisParentState == iMsiNullInteger)
		iisParentState = (iisEnum) pCursor->GetInteger(m_colFeatureInstalled);
	iParentLevel = iTreeLevel;
	pCursor->SetFilter(0);

	while ((iTreeLevel = pCursor->Next()) > iParentLevel)
	{
		MsiString strChildFeature(pCursor->GetString(m_colFeatureKey));
#ifdef DEBUG
		ICHAR rgchFeature[256];
		strChildFeature.CopyToBuf(rgchFeature,255);
#endif
		// If level is zero, feature is disabled, and doesn't affect gray state
		if (pCursor->GetInteger(m_colFeatureLevel) == 0)
			continue;

		// If feature is hidden, doesn't affect gray state either
		int iDisplay = pCursor->GetInteger(m_colFeatureDisplay);
		if (iDisplay == 0 || iDisplay == iMsiNullInteger)
			continue;

		iisEnum iisChildState = (iisEnum) pCursor->GetInteger(m_colFeatureAction);
		if (iisChildState == iMsiNullInteger)
			iisChildState = (iisEnum) pCursor->GetInteger(m_colFeatureInstalled);

		if (iisChildState != iisParentState)
		{
				rfIsGray = true;
				return 0;
		}
	}
	return 0;
}



IMsiRecord* CMsiEngine::MarkOrResetFeatureTree(const IMsiString& riFeatureString, Bool fMark)
/*----------------------------------------------------------------------------*/
{
	int iParentLevel = 0;
	int iTreeLevel = 0;
	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));

	// Set up the tree-walking cursor for all riFeatureString's children
	pCursor->SetFilter(1);
	pCursor->PutString(m_colFeatureKey,riFeatureString);
	if ((iTreeLevel = pCursor->Next()) == 0)
		return PostError(Imsg(idbgBadFeature),riFeatureString.GetString());
	iParentLevel = iTreeLevel;
	pCursor->SetFilter(0);
	do
	{
#ifdef DEBUG
		MsiString pstrFeature(pCursor->GetString(m_colFeatureKey));
		ICHAR rgchFeature[256];
		pstrFeature.CopyToBuf(rgchFeature,255);
#endif
		int iRuntimeFlags = pCursor->GetInteger(m_colFeatureRuntimeFlags);
		if (fMark)
			pCursor->PutInteger(m_colFeatureRuntimeFlags, iRuntimeFlags | bfFeatureMark);
		else
		{
			if (iRuntimeFlags & bfFeatureMark)
				pCursor->PutInteger(m_colFeatureRuntimeFlags, iRuntimeFlags & !bfFeatureMark);
			else
			{
				iisEnum iisAction = (iisEnum) pCursor->GetInteger(m_colFeatureAction);
				pCursor->PutInteger(m_colFeatureSelect,iisAction);
			}
		}
		pCursor->Update();
	}while ((iTreeLevel = pCursor->Next()) > iParentLevel);
	return 0;
}

IMsiRecord* CMsiEngine::UpdateFeatureActionState(const IMsiString* piFeatureString, Bool fTrackParent, IMsiCursor* piFeatureComponentCursor, IMsiCursor* piFeatureCursor)
/*----------------------------------------------------------------------------
Internal function which walks the Feature table tree that includes the
piFeatureString and all its children, updating the iisAction state of all the
components owned by each feature.  Unless fTrackParent is fFalse, all child
features of piFeatureString will be flipped (if selected for install) to match
the Attributes state of piFeatureString.  However, If Null is passed for
piFeatureString, the entire feature tree will be updated, and NO 'flipping'
will be performed.

Returns: An error record if an invalid condition was requested for the feature,
or if the feature is not found in the Feature Table.
------------------------------------------------------------------------------*/
{
	int iParentLevel = 0;
	int iTreeLevel = 0;
	iisEnum iParInstalled[MAX_COMPONENT_TREE_DEPTH + 1];
	iisEnum iParAction[MAX_COMPONENT_TREE_DEPTH + 1];
	iisEnum iParSelect[MAX_COMPONENT_TREE_DEPTH + 1];
	int     iParLevel[MAX_COMPONENT_TREE_DEPTH + 1];
	Bool fTrackParentAttributes = fFalse;

	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));
	if (piFeatureString)
	{
		// Set up the tree-walking cursor for all piFeatureString's children
		pCursor->SetFilter(1);
		pCursor->PutString(m_colFeatureKey,*piFeatureString);
		if ((iTreeLevel = pCursor->Next()) == 0)
			return PostError(Imsg(idbgBadFeature),*piFeatureString);
		iParentLevel = iTreeLevel;
		pCursor->SetFilter(0);

		// Get piFeatureString's parent
		PMsiCursor pParCursor(m_piFeatureTable->CreateCursor(fFalse));
		pParCursor->SetFilter(1);
		pParCursor->PutString(m_colFeatureKey,*MsiString(pCursor->GetString(m_colFeatureParent)));
		int iParentParentLevel;
		if ((iParentParentLevel = pParCursor->Next()) != 0)
		{
			iParInstalled[iParentParentLevel] = (iisEnum) pParCursor->GetInteger(m_colFeatureInstalled);
			iParAction[iParentParentLevel] = (iisEnum) pParCursor->GetInteger(m_colFeatureAction);
			iParSelect[iParentParentLevel] = (iisEnum) pParCursor->GetInteger(m_colFeatureSelect);
			iParLevel[iParentParentLevel] = pParCursor->GetInteger(m_colFeatureLevel);
		}
	}
	else
	{
		pCursor->SetFilter(0);
		if ((iTreeLevel = pCursor->Next()) == 0)
			return PostError(Imsg(idbgBadFeature),TEXT(""));
	}

	do
	{
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		MsiStringId idFeature = pCursor->GetInteger(m_colFeatureKey);
		MsiString strFeature(m_piDatabase->DecodeString(idFeature));
#ifdef DEBUG
		ICHAR rgchFeature[256];
		strFeature.CopyToBuf(rgchFeature,255);
#endif
		if (fTrackParent && piFeatureString && !strFeature.Compare(iscExact,piFeatureString->GetString()))
			fTrackParentAttributes = fTrue;

		iisEnum iisSelect = (iisEnum) pCursor->GetInteger(m_colFeatureSelect);
		iisEnum iisInstalled = (iisEnum) pCursor->GetInteger(m_colFeatureInstalled);
		Bool fInstalled = (iisInstalled == iMsiNullInteger || iisInstalled == iisAbsent) ? fFalse : fTrue;

		// Action determination rules
		iisEnum iisOldAction = (iisEnum) pCursor->GetInteger(m_colFeatureAction);
		iisEnum iisAction = (iisEnum) iMsiNullInteger;

		int iValidStates;
		IMsiRecord* piErrRec = GetFeatureValidStates(idFeature,iValidStates, piFeatureComponentCursor, piFeatureCursor);
		if (piErrRec)
			return piErrRec;

		// Determine whether the parent will be in an installed state after termination of setup
		if (iTreeLevel > 1)
		{
			iisEnum iisParentFinalStateInstalled = ((iParAction[iTreeLevel -1] != iMsiNullInteger) &&
				(iParAction[iTreeLevel -1] != iisReinstall)) ? iParAction[iTreeLevel -1] : iParInstalled[iTreeLevel - 1];
			// we have an active selection
			if((iisSelect != iMsiNullInteger) &&
				((iisSelect == iisAbsent ||
				  iisParentFinalStateInstalled == iisLocal ||
				  iisParentFinalStateInstalled == iisSource) ||
				 ((iisSelect == iisAdvertise || (iisSelect == iisReinstall && iisInstalled == iisAdvertise)) && iisParentFinalStateInstalled == iisAdvertise)))
			{
				iisAction = iisSelect; // the selection is okay
			}
			else if (iisParentFinalStateInstalled != iisLocal && iisParentFinalStateInstalled != iisSource &&
				(fInstalled  || iisSelect != iMsiNullInteger))
			{
				// parent is either absent or advertised, we may need to tweak the selection of the child
				if(iisParentFinalStateInstalled == iisAdvertise && (iValidStates & icaBitAdvertise))
					iisAction = (iisInstalled == iisAdvertise) ? (iisEnum) iMsiNullInteger : iisAdvertise;
				else
					iisAction = (fInstalled) ? iisAbsent : (iisEnum) iMsiNullInteger;
			}
		}
		else
		{
			// This selection has no parent
			iisAction = iisSelect;
		}


		// All ifeaFollowParent features must track the parent's UseSource status
		int iFeatureAttributes = pCursor->GetInteger(m_colFeatureAttributes);
		if (iFeatureAttributes == iMsiNullInteger)
			iFeatureAttributes = 0;

		if(iTreeLevel > 1)
		{
			// the iParFinalState should be used only if iTreeLevel > 1
			iisEnum iParFinalState = (iParAction[iTreeLevel - 1] == iMsiNullInteger || iParAction[iTreeLevel - 1] == iisReinstall) ? iParInstalled[iTreeLevel - 1] : iParAction[iTreeLevel - 1];
			iisEnum iFinalState = iisAction == iMsiNullInteger ? iisInstalled : iisAction;
			if((iFeatureAttributes & ifeaUIDisallowAbsent) && !(iFeatureAttributes & ifeaDisallowAdvertise) &&
				iParFinalState == iisAdvertise)
			{
				iisAction = (iisInstalled == iisAdvertise) ? (iisEnum) iMsiNullInteger : iisAdvertise;
			}
			else if ((iFeatureAttributes & ifeaUIDisallowAbsent) && (iParFinalState == iisLocal || iParFinalState == iisSource) &&
				iFinalState == iisAbsent)
			{
				if (iParFinalState == iisLocal)
				{
					if (iValidStates & icaBitLocal)
						iisAction = iisSelect = (iisInstalled == iisLocal) ? (iisEnum) iMsiNullInteger : iisLocal;
					else
						iisAction = iisSelect = (iisInstalled == iisSource) ? (iisEnum) iMsiNullInteger : iisSource;
				}
				else
				{
					if (iValidStates & icaBitSource)
						iisAction = iisSelect = (iisInstalled == iisSource) ? (iisEnum) iMsiNullInteger : iisSource;
					else
						iisAction = iisSelect = (iisInstalled == iisLocal) ? (iisEnum) iMsiNullInteger : iisLocal;
				}
			}
			else if (fTrackParentAttributes || ((iFeatureAttributes & ifeaInstallMask) == ifeaFollowParent))
			{
				if (iParFinalState == iisLocal && iFinalState == iisSource && (iValidStates & icaBitLocal))
					iisAction = iisSelect = (iisInstalled == iisLocal) ? (iisEnum) iMsiNullInteger : iisLocal;
				else if (iParFinalState == iisSource && iFinalState == iisLocal && (iValidStates & icaBitSource))
					iisAction = iisSelect = (iisInstalled == iisSource) ? (iisEnum) iMsiNullInteger : iisSource;
				else if (iParFinalState == iisSource && iFinalState == iisAdvertise && (iValidStates & icaBitSource))
					iisAction = (iisInstalled == iisSource) ? (iisEnum) iMsiNullInteger : iisSource;
			}
		}

		// Features that are currently installed RunFromSource might have components that subsequently need
		// to be patched.  We can't leave it RunFromSource so we set them local.  But, if we are uninstalling
		// the feature, there is no need to patch it.
		int iRuntimeFlags = pCursor->GetInteger(m_colFeatureRuntimeFlags);
		if (((iRuntimeFlags & bfFeaturePatchable) || (iRuntimeFlags & bfFeatureCompressable)) && iisInstalled == iisSource && iisAction != iisLocal && iisAction != iisAbsent)
			iisAction = iisSelect = iisLocal;

		// If this feature's parent is disabled (install level is 0), disable all
		// children as well.  Note that in Admin mode, we disable only those features that
		// have specifically been authored with a 0 in the Level column.
		Bool fAdmin = GetMode() & iefAdmin ? fTrue : fFalse;
		int iInstallLevel = pCursor->GetInteger(fAdmin ? m_colFeatureAuthoredLevel : m_colFeatureLevel);
		if (iTreeLevel > 1 && iParLevel[iTreeLevel - 1] == 0)
		{
			iInstallLevel = 0;
			AssertNonZero(pCursor->PutInteger(m_colFeatureLevel,0));
		}

		// And, of course, disabled features can't be selected or acted upon
		if (iInstallLevel == 0)
			iisAction = iisSelect = (iisEnum) iMsiNullInteger;

		iParLevel[iTreeLevel] = iInstallLevel;
		iParInstalled[iTreeLevel] = iisInstalled;
		iParAction[iTreeLevel] = iisAction;
		iParSelect[iTreeLevel] = iisSelect;


		AssertNonZero(pCursor->PutInteger(m_colFeatureActionRequested, iisAction));
		AssertNonZero(pCursor->PutInteger(m_colFeatureSelect, iisSelect));
		if(iisAction == iisAbsent && m_fAlienClients) // there are other clients to the product
			iisAction = (iisEnum)iMsiNullInteger;
		pCursor->PutInteger(m_colFeatureAction, iisAction);
		AssertNonZero(pCursor->Update());
		if (m_fCostingComplete && iisAction != iisOldAction)
		{
			IMsiRecord* piErrRec;
			if ((piErrRec = RecostFeatureLinkedComponents(*strFeature)) != 0)
				return piErrRec;
		}

	}while ((iTreeLevel = pCursor->Next()) > iParentLevel);
	return 0;
}


IMsiRecord* CMsiEngine::RecostFeatureLinkedComponents(const IMsiString& riFeatureString)
/*----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	// No recosting needed during initialization
	if (m_fCostingComplete == fFalse)
		return 0;

	// Recost every component that is explicitly linked to riComponentString
	if (m_piFeatureCostLinkTable)
	{
		PMsiCursor pCursor(0);
		AssertNonZero(pCursor = m_piFeatureCostLinkTable->CreateCursor(fFalse));
		pCursor->Reset();
		pCursor->SetFilter(iColumnBit(m_colFeatureCostLinkFeature));
		pCursor->PutString(m_colFeatureCostLinkFeature,riFeatureString);
		while (pCursor->Next())
		{
			IMsiRecord* piErrRec;
			if ((piErrRec = RecostComponent(pCursor->GetInteger(m_colFeatureCostLinkComponent),/*fCostLinked = */true)) != 0)
				return piErrRec;
		}
	}
	return 0;
}



IMsiRecord* CMsiEngine::UpdateFeatureComponents(const IMsiString* piFeatureString)
/*-----------------------------------------------------------------------
Internal function that sets the installed state of all the components
associated with the given feature, such that the components match the
installed state of the feature.  If piFeatureString is passed as NULL,
then the components of ALL features will be updated.
------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	if (!m_piComponentTable)
		return 0; // no components to update

	IMsiRecord* piErrRec;
	
	if (piFeatureString == 0)
	{
		PMsiCursor pComponentCursor = m_piComponentTable->CreateCursor(fTrue);
		MsiStringId idTempId;

		// It's possible that this would be 0 if no temporary Id items
		// are in the table. That's ok, since we'll get back 0
		// and that won't compare with any of the real ids
		idTempId = m_piDatabase->EncodeStringSz(szTemporaryId);

		PMsiTable pCompFeatureTable(0);
		piErrRec = CreateComponentFeatureTable(*&pCompFeatureTable);

		if (piErrRec)
			return piErrRec;
			
		PMsiCursor pCursor(pCompFeatureTable->CreateCursor(fFalse));
		
		int colComponent = pCompFeatureTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFeatureComponents_colComponent));
		int colFeature = pCompFeatureTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFeatureComponents_colFeature));

		pCursor->SetFilter(iColumnBit(colComponent));
		iisEnum iisComponentInstalled;
		MsiStringId idComponent;

		while (pComponentCursor->Next())
		{
			if (idTempId && pComponentCursor->GetInteger(m_colComponentID) == idTempId)
				continue;

			iisComponentInstalled = (iisEnum) pComponentCursor->GetInteger(m_colComponentInstalled);
			idComponent = pComponentCursor->GetInteger(m_colComponentKey);
			pCursor->Reset();
			pCursor->PutInteger(colComponent,idComponent);
			piErrRec = SetComponentState(pCursor, colFeature, idComponent, iisComponentInstalled);
			if (piErrRec)
				return piErrRec;
		}

		return 0;
	
	}
	
	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));
	int iParentLevel;
	pCursor->SetFilter(1);
	pCursor->PutString(m_colFeatureKey,*piFeatureString);
	iParentLevel = pCursor->Next();
	pCursor->SetFilter(0);

	if (piFeatureString && iParentLevel == 0)
		return PostError(Imsg(idbgBadFeature),*piFeatureString);

	int iTreeLevel;
	do
	{
		MsiStringId idChildFeature = pCursor->GetInteger(m_colFeatureKey);
		piErrRec = SetFeatureComponents(idChildFeature);
		if (piErrRec)
			return piErrRec;
		iTreeLevel = pCursor->Next();
	}while (iTreeLevel > iParentLevel);

	return 0;
}


IMsiRecord* CMsiEngine::SetFeatureComponents(const MsiStringId idFeatureString)
/*-----------------------------------------------------------------------
Internal function that sets the installed state of all the components
associated with the given feature, such that the components match the
installed state of the feature.  This function actually walks through
the FeatureComponents table, and for each Component mapped to the
given feature, calls SetComponent on that component.
------------------------------------------------------------------------*/
{
	CreateSharedCursor(pFeatureComponentsCursor, m_piFeatureComponentsCursor);
	Assert(m_piFeatureComponentsCursor);

	m_piFeatureComponentsCursor->SetFilter(1);
	m_piFeatureComponentsCursor->PutInteger(m_colFeatureComponentsFeature,idFeatureString);
	
	IMsiRecord* piErrRec;
#ifdef DEBUG
	ICHAR rgchFeature[256];
	MsiString(m_piDatabase->DecodeString(idFeatureString)).CopyToBuf(rgchFeature,255);
#endif

	while (m_piFeatureComponentsCursor->Next())
	{
		MsiStringId idComponent = m_piFeatureComponentsCursor->GetInteger(m_colFeatureComponentsComponent);
#ifdef DEBUG
		ICHAR rgchComponent[256];
		MsiString(m_piDatabase->DecodeString(idComponent)).CopyToBuf(rgchComponent,255);
#endif
		
		PMsiCursor pCursor(m_piFeatureComponentsTable->CreateCursor(fFalse));
		pCursor->SetFilter(iColumnBit(m_colFeatureComponentsComponent));
		
		// is the component currently installed?
		if (!m_piComponentCursor)
			return PostError(Imsg(idbgSelMgrNotInitialized),0);

		iisEnum iisComponentInstalled;

		{
			CreateSharedCursor(piComponentCursor, m_piComponentCursor);
			m_piComponentCursor->SetFilter(1);
			m_piComponentCursor->PutInteger(m_colComponentKey,idComponent);

			int iParentLevel = m_piComponentCursor->Next();
			if (iParentLevel == 0)
				return PostError(Imsg(idbgBadComponent), (const ICHAR*)MsiString(m_piDatabase->DecodeString(idComponent)));

			iisComponentInstalled = (iisEnum) m_piComponentCursor->GetInteger(m_colComponentInstalled);
		}

		pCursor->PutInteger(m_colFeatureComponentsComponent,idComponent);
		piErrRec = SetComponentState(pCursor, m_colFeatureComponentsFeature, idComponent, iisComponentInstalled);
		if (piErrRec)
			return piErrRec;
	}
	return 0;
}

//
// This routine will look at each feature for this component and see what are the valid
// states for it. Parameters
// piCursor - a cursor to a table which is filtered by component
// colFeature - the feature column in piCursor
// idComponent - The component id being looked at
// iisComponentInstalled - the current state of the component
IMsiRecord* CMsiEngine::SetComponentState(IMsiCursor *piCursor, int colFeature, const MsiStringId idComponent, iisEnum iisComponentInstalled)
{
	int iReinstallLocalCount = 0;
	int iReinstallSourceCount = 0;
	int iLocalCount = 0;
	int iSourceCount = 0;
	int iAbsentCount = 0;

	IMsiRecord* piErrRec;

	bool fFeatureSelected = false;
	
	while (piCursor->Next())
	{
		iisEnum iisFeatureAction, iisFeatureInstalled;
		MsiStringId idFeature = piCursor->GetInteger(colFeature);
		piErrRec = GetFeatureStates(idFeature,&iisFeatureInstalled,&iisFeatureAction);
		if (piErrRec)
			return piErrRec;

		int iFeatureRuntimeFlags=0;
		piErrRec = GetFeatureRuntimeFlags(idFeature,&iFeatureRuntimeFlags);
		if (piErrRec)
			return piErrRec;

		// to determine the final component action state we need to also take into consideration the current installed states of features
		// that use that component but are not currently actively selected.
		// however, if no feature that uses that component is currently selected, we want to set the component's action state to null (darwin bug 7300)
		// this is achieved by using the fFeatureSelected flag
		if(iisFeatureAction != iMsiNullInteger)
			fFeatureSelected = true;
		else if(iisFeatureInstalled != iisAbsent && iisFeatureInstalled != iisAdvertise)
			iisFeatureAction = iisComponentInstalled;       // we do not want to switch states if the component is currently
														// installed and the feature is not actively selected
		if (iisFeatureAction == iisReinstall)
		{
			if (iisFeatureInstalled == iisLocal)
				iReinstallLocalCount++;
			else if (iisFeatureInstalled == iisSource)
				iReinstallSourceCount++;
		}
		else if (iisFeatureAction == iisLocal)
		{
			// need to handle case where feature is transitioning from source to local because it has a patchable component
			// and this component was already installed locally
			if (iisFeatureInstalled == iisSource && iisComponentInstalled == iisLocal && ((iFeatureRuntimeFlags & bfFeaturePatchable) || (iFeatureRuntimeFlags & bfFeatureCompressable)))
			{
				// component must be reinstalled since its feature is being patched (and therefore reinstalled)
				iReinstallLocalCount++;
			}
			else
				iLocalCount++;
		}
		else if (iisFeatureAction == iisSource)
			iSourceCount++;
		else if (((iisFeatureAction == iisAbsent) || (iisFeatureAction == iisAdvertise)) && ((iisFeatureInstalled != iisAbsent) && (iisFeatureInstalled != iisAdvertise))) // bug 7207 - feature absent <-> advt transitions does not affect component state
			iAbsentCount++;
	}

	// need to handle case where we reinstall some features and addlocal other features (originally absent or source)
	// particularly if the features share a component originally installed source.  we don't want the component to
	// stay source if at least one feature wants it to go local
	iisEnum iisCompositeAction = (iisEnum) iMsiNullInteger;
	if (iReinstallLocalCount > 0)
		iisCompositeAction = iisReinstallLocal;
	else if (iReinstallSourceCount > 0)
	{
		// if someone has an ADDLOCAL on us, we should adhere to it and force us local, but must
		// ensure that the component is re-evaluated (for transitive components)
		if (iLocalCount > 0)
			iisCompositeAction = iisReinstallLocal;
		else
			iisCompositeAction = iisReinstallSource;
	}
	else if (iLocalCount > 0)
		iisCompositeAction = iisLocal;
	else if (iSourceCount > 0)
		iisCompositeAction = iisSource;
	else if (iAbsentCount > 0)
		iisCompositeAction = iisAbsent;

	return SetComponent(idComponent,fFeatureSelected?iisCompositeAction:(iisEnum)iMsiNullInteger);
}

IMsiRecord* CMsiEngine::SetFileComponentStates(IMsiCursor* piComponentCursor, IMsiCursor* piFileCursor, IMsiCursor* piPatchCursor)
/*-----------------------------------------------------------------------
Internal function to check if a component contains either compressed
files or patched files
We look at each file in the file table, and then check it's corresponding component
------------------------------------------------------------------------*/
{
	
	IMsiRecord* piError = 0;
	
	if(!piFileCursor && !piPatchCursor)
		return 0;

	bool fCompressed, fPatched;

	int colFileKey = m_mpeftCol[ieftKey];
	int colFileComponent = m_mpeftCol[ieftComponent];
	int colFileAttributes = m_mpeftCol[ieftAttributes];

	AssertSz(piFileCursor != 0, "CheckComponentState passed null file cursor");
	
	if (piPatchCursor != 0)
	{
		piPatchCursor->SetFilter(iColumnBit(m_colPatchKey));
	}

	piFileCursor->SetFilter(0);
	piComponentCursor->SetFilter(iColumnBit(m_colComponentKey));

	while(piFileCursor->Next())
	{
		fCompressed = false;
		fPatched = false;
#ifdef DEBUG
		MsiString strFileName = piFileCursor->GetString(3);
#endif //DEBUG

		// determine if file is compressed using file attributes and source type
		// NOTE: we are using the source type from the cached package here, because we
		// don't want to resolve the source yet, and the cached package is our best guess
		// at the source type
		fCompressed = FFileIsCompressed(m_iCachedPackageSourceType,
												  piFileCursor->GetInteger(colFileAttributes));
		
		if(piPatchCursor)
		{
			piPatchCursor->Reset();
			AssertNonZero(piPatchCursor->PutInteger(m_colPatchKey,piFileCursor->GetInteger(colFileKey)));
			if(piPatchCursor->Next() && !(piPatchCursor->GetInteger(m_colPatchAttributes) & msidbPatchAttributesNonVital))
			{
				fPatched = true;
			}
		}
		if (fPatched || fCompressed)
		{
			int iRuntimeFlags;
			MsiStringId idComponent = piFileCursor->GetInteger(colFileComponent);

			piComponentCursor->Reset();
			piComponentCursor->PutInteger(m_colComponentKey, idComponent);
			if (piComponentCursor->Next())
			{
				iRuntimeFlags = piComponentCursor->GetInteger(m_colComponentRuntimeFlags);
				if (fCompressed) iRuntimeFlags |= bfComponentCompressed;
				if (fPatched) iRuntimeFlags |= bfComponentPatchable;
				piComponentCursor->PutInteger(m_colComponentRuntimeFlags, iRuntimeFlags);
				AssertNonZero(piComponentCursor->Update());
			}
			else
				AssertSz(fFalse, "Missing Component from File Table");
		}
	}


	piFileCursor->Reset();
	piComponentCursor->Reset();

	if (piPatchCursor)
		piPatchCursor->Reset();
	return 0;
}

extern idtEnum MsiGetPathDriveType(const ICHAR *szPath, bool fReturnUnknownAsNetwork);

IMsiRecord* CMsiEngine::DetermineComponentInstalledStates()
/*-----------------------------------------------------------------------
Internal function called at initialize time to determine the installed
state of all components, based both on registration with the configuration
manager, and the actual presence of the "key file" associated with the
component.
------------------------------------------------------------------------*/
{
	if(m_fMode & iefAdvertise) // skip if in advertise mode
		return 0;

	// what type of an install are we attempting
	Bool fAllUsers = MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? fTrue : fFalse;
	iaaAppAssignment iaaAsgnType = fAllUsers ? iaaMachineAssign : iaaUserAssign;

	if (!m_piComponentTable)
		return 0; // no components ~ no work

	PMsiCursor piCursor = m_piComponentTable->CreateCursor(fFalse);
	while(piCursor->Next())
	{
		if((piCursor->GetInteger(m_colComponentParent) == 0) || (piCursor->GetInteger(m_colComponentParent) == piCursor->GetInteger(m_colComponentKey)))
		{
			if(ActionProgress() == imsCancel)
				return PostError(Imsg(imsgUser));

			MsiString strComponent = piCursor->GetString(m_colComponentKey);
			MsiString istrComponentID = piCursor->GetString(m_colComponentID);
			if (istrComponentID.TextSize() == 0)  // unregistered component
			{
//                              iisInstalled = iisAbsent; //!! necessary if we're not registering component?
				continue;
			}
			MsiString strFile;
			INSTALLSTATE iClientState = INSTALLSTATE_UNKNOWN;
			INSTALLSTATE iClientStateStatic = INSTALLSTATE_UNKNOWN;
			iisEnum iisInstalled;
			// Use the registration on the machine only if we have installed before.
			// In the event this is a per user managed install and the user is an admin
			// we honour previous per user (non-managed) component installations as well.
			if(m_fRegistered) 
			{
				PMsiRecord pRec(0);
	
				IMsiRecord* piErrRec = GetComponentPath(m_riServices, 0, *MsiString(GetProductKey()), *istrComponentID, *&pRec, &iaaAsgnType);
				if (piErrRec)
					return piErrRec;
	
				iClientState = (INSTALLSTATE)pRec->GetInteger(icmlcrINSTALLSTATE);
				iClientStateStatic = (INSTALLSTATE)pRec->GetInteger(icmlcrINSTALLSTATE_Static);
				strFile = pRec->GetMsiString(icmlcrFile);

				if(iClientStateStatic == INSTALLSTATE_LOCAL)
				{
					// do we have a fusion component  
					iatAssemblyType iatAT;
					MsiString strAssemblyName;
					piErrRec = GetAssemblyInfo(*strComponent, iatAT, &strAssemblyName, 0);
					if (piErrRec)
						return piErrRec;
	
					// set the target for local installs to the currently installed location
					// dont attempt to use the path for assembly components
					if(iatAT != iatURTAssembly && iatAT != iatWin32Assembly && strFile.TextSize() && MsiString(strFile.Extract(iseUpto, TEXT(':'))) == iMsiStringBadInteger)
					{
						// is the file installed in a location accessible to the current user?
						if((iClientState == INSTALLSTATE_ABSENT || iClientState == INSTALLSTATE_BROKEN) && pRec->GetInteger(icmlcrLastErrorOnFileDetect) == ERROR_ACCESS_DENIED)
							iClientState = INSTALLSTATE_UNKNOWN;
						else
						{
							const IMsiString* pistrPath = 0;
	
							piErrRec = SplitPath(strFile, &pistrPath);
							if (piErrRec)
								return piErrRec;
							
							
							if (MsiGetPathDriveType(pistrPath->GetString(),false) == idtUnknown)
							{
								iClientState = INSTALLSTATE_UNKNOWN;
								pistrPath->Release();
								pistrPath = 0;
							}
							else
							{
								// ugly, is directory manager initialised
								if((m_fDirectoryManagerInitialized) && (m_piComponentCursor))
								{
									// directory manager initialised
									AssertNonZero(SetProperty(*MsiString(piCursor->GetString(m_colComponentDir)), *pistrPath));
									piErrRec = SetDirectoryNonConfigurable(*MsiString(piCursor->GetString(m_colComponentDir)));
									pistrPath->Release();
									pistrPath = 0;
									if (piErrRec)
										return piErrRec;
								}
								else
								{
									SetProperty(*MsiString(piCursor->GetString(m_colComponentDir)), *pistrPath); //!! should we not do this?
									pistrPath->Release();
									pistrPath = 0;
								}
							}
						}
					}
				}
			}


			// set the component state to what the user desired when he/she selected the feature(s)
			switch(iClientStateStatic)
			{
			case INSTALLSTATE_LOCAL:
			case INSTALLSTATE_ABSENT:
			// we treat INSTALLSTATE_NOTUSED as local for the sake for register and unregister components
			// this sets the Installed column to local, however the Action column will always be null
			// since the component is disabled
			case INSTALLSTATE_NOTUSED:
			{
				iisInstalled = iisLocal;
				break;
			}
			case INSTALLSTATE_SOURCE:
			case INSTALLSTATE_SOURCEABSENT:
				iisInstalled = iisSource;
				break;
			default:
				iisInstalled = iisAbsent;
				break;
			}
			// update the installed state
			AssertNonZero(piCursor->PutInteger(m_colComponentInstalled, iisInstalled));
			AssertNonZero(piCursor->PutInteger(m_colComponentTrueInstallState, iClientState));
			AssertNonZero(piCursor->Update());
		}
	}
	return 0;
}


IMsiRecord* CMsiEngine::DetermineFeatureInstalledStates()
/*------------------------------------------------------------------------------------
Internal function that walks through all features, and sets the installed state for
each, based on the composite installed state of the feature's components. For features
that don't have components, the installed state is determined by the composite state
of that feature's children. The calculated iisEnum state is written into the
m_colFeatureInstalled column.
--------------------------------------------------------------------------------------*/
{
	// Feature conditions must be evaluated before determining installed states
	IMsiRecord* piErrRec = ProcessConditionTable();
	if (piErrRec)
		return piErrRec;

	// First calculate the installed state of each feature, based on the states
	// of each component linked to the feature.
	piErrRec = CalculateFeatureInstalledStates();
	if (piErrRec)
		return piErrRec;

	// Those features that end up with an installed state of iMsiNullInteger have
	// no linked components.  We'll determine the state of these features as a
	// composite of the feature children.
	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));
	int iTreeLevel;
	while ((iTreeLevel = pCursor->Next()) > 0)
	{
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		iisEnum iisInstalled = (iisEnum) pCursor->GetInteger(m_colFeatureInstalled);
		if (iisInstalled == iMsiNullInteger)
		{
			MsiString strFeature = pCursor->GetString(m_colFeatureKey);
			piErrRec = GetFeatureCompositeInstalledState(*strFeature,iisInstalled);
			if (piErrRec)
				return piErrRec;

			pCursor->PutInteger(m_colFeatureInstalled,iisInstalled);
			pCursor->Update();
		}
	}
	return 0;
}

IMsiRecord* CMsiEngine::GetFeatureCompositeInstalledState(const IMsiString& riFeatureString, iisEnum& riisInstalled)
/*------------------------------------------------------------------------------------
Internal function that returns the current 'Installed' state of the specified feature,
as a composite of the installed state of the specified feature and all its children.

This is intended to be called only for those features that are not linked to any
components.  The general rules are that if any of the child features have an installed
state of iisSource, the parent's installed state is set to iisSource.  Otherwise, if
any child is iisLocal, the parent is set to iisLocal.  One special rule is that if any
of the children are marked with the FollowParent attribute, and that child is installed
iisLocal or iisSource, the parent is set to that same state.
--------------------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));
	pCursor->SetFilter(1);
	pCursor->PutString(m_colFeatureKey,riFeatureString);
	int iParentLevel = pCursor->Next();
	if (iParentLevel == 0)
		return PostError(Imsg(idbgBadFeature),riFeatureString);
	pCursor->SetFilter(0);
	int iTreeLevel;
	int iLocalCount = 0;
	int iSourceCount = 0;
	int iAbsentCount = 0;
	int iAdvertiseCount = 0;
	int iLocalFollowParentCount = 0;
	int iSourceFollowParentCount = 0;
	do
	{
#ifdef DEBUG
		const ICHAR* szFeature = MsiString(pCursor->GetString(m_colFeatureKey));
#endif
		iisEnum iisInstalled = (iisEnum) pCursor->GetInteger(m_colFeatureInstalled);
		int ifeaAttributes = pCursor->GetInteger(m_colFeatureAttributes);
		if(ifeaAttributes == iMsiNullInteger)
			ifeaAttributes = 0;
		if ((ifeaAttributes & ifeaInstallMask) == ifeaFollowParent && (iisInstalled == iisLocal || iisInstalled == iisSource))
		{
			if (iisInstalled == iisLocal)
				iLocalFollowParentCount++;
			else if (iisInstalled == iisSource)
				iSourceFollowParentCount++;
		}
		else if (iisInstalled == iisLocal)
			iLocalCount++;
		else if (iisInstalled == iisSource)
			iSourceCount++;
		else if (iisInstalled == iisAbsent)
			iAbsentCount++;
		else if (iisInstalled == iisAdvertise)
			iAdvertiseCount++;
		iTreeLevel = pCursor->Next();
	}while (iTreeLevel > iParentLevel);
	if (iSourceFollowParentCount > 0)
	{
		Assert(iLocalFollowParentCount == 0);
		return (riisInstalled = iisSource, 0);
	}
	else if (iLocalFollowParentCount > 0)
	{
		Assert(iSourceFollowParentCount == 0);
		return (riisInstalled = iisLocal, 0);
	}
	else if (iSourceCount > 0)
		return (riisInstalled = iisSource, 0);
	else if (iLocalCount > 0)
		return (riisInstalled = iisLocal, 0);
	else if (iAdvertiseCount > 0)
		return (riisInstalled = iisAdvertise, 0);
	else if (iAbsentCount > 0)
		return (riisInstalled = iisAbsent, 0);
	else
		return (riisInstalled = (iisEnum) iMsiNullInteger, 0);
}


IMsiRecord* CMsiEngine::CalculateFeatureInstalledStates()
/*------------------------------------------------------------------------------------
Internal function that walks through all features, and sets the installed state for
each, based on the composite installed state of the feature's components.  The
calculated iisEnum state is written into the m_colFeatureInstalled column.  For
features that don't have components, the installed state will be iMsiNullInteger.
--------------------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	Bool fAdvertised = fFalse;
	Bool fRegistered = fFalse;

	MsiString strProduct = GetProperty(*MsiString(*IPROPNAME_PRODUCTCODE));
	INSTALLSTATE is = GetProductState(strProduct, fRegistered, fAdvertised);

	bool fQFEUpgrade = false;
	MsiString strQFEUpgrade = GetPropertyFromSz(IPROPNAME_QFEUPGRADE);
	if(strQFEUpgrade.TextSize())
		fQFEUpgrade = true;

	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));
	int iTreeLevel = 0;
	iisEnum iParInstalled[MAX_COMPONENT_TREE_DEPTH + 1];
	while ((iTreeLevel = pCursor->Next()) > 0)
	{
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		MsiString strFeature(pCursor->GetString(m_colFeatureKey));
		int iLevel = pCursor->GetInteger(m_colFeatureLevel);
		iisEnum iisInstalled = iisAbsent;
		if (!(m_fMode & iefAdvertise) && iLevel && fAdvertised) // we are not in advertise mode and feature is not disabled and product is known
		{
			// Get Feature-Component mapping
			DWORD dwType;
			CAPITempBuffer<ICHAR, cchExpectedMaxFeatureComponentList> szComponentList;
			CRegHandle HProductKey;
			if((OpenAdvertisedSubKey(szGPTFeaturesKey, strProduct, HProductKey, false, -1, 0) == ERROR_SUCCESS) && 
				(ERROR_SUCCESS == MsiRegQueryValueEx(HProductKey, strFeature, 0, &dwType, szComponentList, 0)) && 
				(*szComponentList != chAbsentToken))
			{
				iisInstalled = iisAdvertise;
				// check if the feature is truly installed to the local machine
				if(	fRegistered && 
					(ERROR_SUCCESS == OpenInstalledFeatureKey(strProduct, HProductKey, false)) && 
					(ERROR_SUCCESS == WIN::RegQueryValueEx(HProductKey, strFeature, 0, 0, 0, 0)))
				{
					MsiStringId idFeature = pCursor->GetInteger(m_colFeatureKey);
					int cComponents = 0;
					iisInstalled = GetFeatureComponentsInstalledState(idFeature, /* fIgnoreAddedComponents = */ false, cComponents);

					// we are only concerned about cases where the install state changes from the original state to a new state
					// when adding components to an existing features, the only times an install state will change are
					//		iisSource ->> iisAdvertise (an absent component was added)
					//      iisLocal  ->> iisAdvertise (an absent component was added)
					//      iisLocal  ->> iisSource    (a source component was added)
					
					if (fQFEUpgrade && (iisInstalled == iisAdvertise || iisInstalled == iisSource) && cComponents > 0)
					{
						// need to determine if this was caused by new component(s)
						int cRegisteredComponents = GetFeatureRegisteredComponentTotal(*strProduct, *strFeature);
						if (cComponents == cRegisteredComponents)
						{
							// nothing required
						}
						else if (-1 == cRegisteredComponents)
						{
							// is there anything we can do to help this feature?
							DEBUGMSG2(TEXT("SELMGR: The feature-component mapping registration is broken for feature '%s' of product '%s'"), strFeature, strProduct);
						}
						else if (0 == cRegisteredComponents)
						{
							// a new component was added to a feature that originally had no components
							// it's install state is therefore iMsiNullInteger in order to preserve the feature's original install state
							DEBUGMSG1(TEXT("SELMGR: New components have been added to feature '%s'"), strFeature);
							iisInstalled = (iisEnum) iMsiNullInteger;
						}
						else if (cComponents > cRegisteredComponents)
						{
							// Feature has new components
							DEBUGMSG1(TEXT("SELMGR: New components have been added to feature '%s'"), strFeature);

							// (1) Recalculate feature installed state by ignoring the "new" components (unregistered)
							// (2) The "new" components (unregistered) need to be installed to match the feature installed state
							iisInstalled = GetFeatureComponentsInstalledState(idFeature, /* fIgnoreAddedComponents = */ true, cComponents);
						}
						else if (cComponents < cRegisteredComponents)
						{
							DEBUGMSG(TEXT("SELMGR: Removal of a component from a feature is not supported"));
							AssertSz(0, TEXT("Removal of a component from a feature is not permitted during minor updates"));
						}
					}

					//!! the following seems obselete since we are already weeding out the
					//!! parent absent/advertised scenarios by the time we are here
					if (iTreeLevel > 1 && iisInstalled != iMsiNullInteger)
					{
						for (int x = iTreeLevel - 1;x > 0;x--)
						{
							if (iParInstalled[x] == iisAbsent || iParInstalled[x] == iisAdvertise)
							{
								iisInstalled = iParInstalled[x];
								break;
							}
						}
					}
				}
			}
		}

		pCursor->PutInteger(m_colFeatureInstalled,iisInstalled);
		pCursor->Update();
		iParInstalled[iTreeLevel] = iisInstalled;
	}
	return 0;
}


iisEnum CMsiEngine::GetFeatureComponentsInstalledState(const MsiStringId idFeatureString, bool fIgnoreAddedComponents, int& cComponents)
/*-----------------------------------------------------------------------
Internal function that returns the current 'Installed' state of the
specified feature, based only on the composite state of the components
assigned to the feature.

  cComponents:
	stores the count of components in the feature idFeatureString

  fIgnoreAddedComponents:
	added components are not included in the feature install
	state determination
------------------------------------------------------------------------*/
{
	CreateSharedCursor(pFeatureComponentsCursor, m_piFeatureComponentsCursor);

	if (!m_piComponentTable)
		return (iisEnum) iMsiNullInteger; // no components

	PMsiCursor pComponentCursor(m_piComponentTable->CreateCursor(fFalse));
	Assert(m_piFeatureComponentsCursor);
	m_piFeatureComponentsCursor->SetFilter(1);
	m_piFeatureComponentsCursor->PutInteger(m_colFeatureComponentsFeature,idFeatureString);
	int iLocalCount = 0;
	int iSourceCount = 0;
	int iAbsentCount = 0;
	int iNullCount = 0;
	int iComponentCount = 0;
	while (m_piFeatureComponentsCursor->Next())
	{
		iComponentCount++;
		MsiString istrComponent = m_piFeatureComponentsCursor->GetString(m_colFeatureComponentsComponent);
		pComponentCursor->SetFilter(1);
		pComponentCursor->PutString(m_colComponentKey,*istrComponent);
		if (pComponentCursor->Next())
		{
			// (1) Ignore added components (not marked as registered) if fIgnoreAddedComponents is true
			// (2) Feature install state is therefore only determined by registered components
			// (3) Component is considered registered if present in the feature-component mapping registration
			
			int iComponentRegistrationState = m_piFeatureComponentsCursor->GetInteger(m_colFeatureComponentsRuntimeFlags);
			if (fIgnoreAddedComponents && (iComponentRegistrationState == iMsiNullInteger || !(iComponentRegistrationState & bfComponentRegistered)))
			{
				DEBUGMSGV2(TEXT("SELMGR: Component '%s' is a new component added to feature '%s'"), istrComponent, MsiString(m_piFeatureComponentsCursor->GetString(m_colFeatureComponentsFeature)));
				continue;
			}

			Assert(!fIgnoreAddedComponents || (iComponentRegistrationState & bfComponentRegistered));

			iisEnum iisInstalled = (iisEnum) pComponentCursor->GetInteger(m_colComponentInstalled);
			if (iisInstalled == iisLocal)
				iLocalCount++;
			else if (iisInstalled == iisSource)
				iSourceCount++;
			else if (iisInstalled == iisAbsent)
				iAbsentCount++;
			else if (iisInstalled == iMsiNullInteger)
				iNullCount++;
		}
	}

	cComponents = iComponentCount;

	if (iComponentCount == 0)
		return (iisEnum) iMsiNullInteger;
	if (iAbsentCount > 0)
		return iisAdvertise;
	else if (iSourceCount > 0)
		return iisSource;
	else if (iLocalCount > 0)
		return iisLocal;
	else
	{
		Assert(iNullCount > 0);
		return (iisEnum) iMsiNullInteger;
	}
}

int CMsiEngine::GetFeatureRegisteredComponentTotal(const IMsiString& riProductString, const IMsiString& riFeatureString)
/*----------------------------------------------------------------------------------------------------------------------
Internal function that calculates the number of components registered to feature riFeatureString of
 product riProductString.  Calculation is based upon the global feature-component mapping registration

  riProductString -- name of product
  riFeatureString -- name of feature

  Returns -1 if failure, otherwise the number of components registered in the feature-component mapping
------------------------------------------------------------------------------------------------------------------------*/
{
	CRegHandle HProductKey;
	if (ERROR_SUCCESS != OpenInstalledFeatureKey(riProductString.GetString(), HProductKey, false))
		return -1; // failure! -- bad configuration data

	DWORD dwType = 0;
	CAPITempBuffer<ICHAR, cchExpectedMaxFeatureComponentList> szComponentList;
	if (ERROR_SUCCESS != MsiRegQueryValueEx(HProductKey, riFeatureString.GetString(), 0, &dwType, szComponentList, 0))
		return -1; // failure! -- bad configuration data

	// at this point, we expect the feature to have a component, but we'll check anyway
	ICHAR *pchComponentList = szComponentList;
	if (/* root feature */*pchComponentList == 0
		|| lstrlen(pchComponentList) < cchComponentIdCompressed
		|| /* child feature, no components */ *pchComponentList == chFeatureIdTerminator)
		return 0; // no registered components for this feature

	ICHAR szComponent[cchComponentId + 1];
	if (!UnpackGUID(pchComponentList, szComponent, ipgCompressed))
		return -1; // failure! -- bad configuration data

	// loop for each component in the feature and mark as registered in the FeatureComponents table
	ICHAR *pchBeginComponentId = 0;
	int cRegisteredComponents = 0;

	pchBeginComponentId = pchComponentList;
	int cchComponentId = cchComponentIdCompressed;
	int cchComponentListLen = lstrlen(pchBeginComponentId);

	PMsiCursor pComponentCursor(m_piComponentTable->CreateCursor(fFalse));
	Assert(pComponentCursor);

	PMsiCursor pFeatureComponentsCursor(m_piFeatureComponentsTable->CreateCursor(fFalse));
	Assert(pFeatureComponentsCursor);

	while (*pchBeginComponentId != 0)
	{
		if (*pchBeginComponentId == chFeatureIdTerminator)
		{
			// no more components
			break;
		}
		else
		{
			if(cchComponentListLen < cchComponentId)
				return -1; // failure! -- bad configuration data

			ICHAR szComponentIdSQUID[cchComponentIdPacked+1];
			if (cchComponentId == cchComponentIdPacked)
			{
				memcpy((ICHAR*)szComponentIdSQUID, pchBeginComponentId, cchComponentIdPacked*sizeof(ICHAR));
				szComponentIdSQUID[cchComponentId] = 0;
			}
			else if (!UnpackGUID(pchBeginComponentId, szComponentIdSQUID, ipgPartial))
				return -1; // failure! -- bad configuration data

			ICHAR szComponentId[cchGUID+1]	= {0};
			if (!UnpackGUID(szComponentIdSQUID, szComponentId, ipgPacked))
				return -1; // failure! -- unable to convert to normal GUID

			// look for component name matching this componentId
			pComponentCursor->Reset();
			pComponentCursor->SetFilter(iColumnBit(m_colComponentID));
			pComponentCursor->PutString(m_colComponentID,*MsiString(szComponentId));
			if (!pComponentCursor->Next())
			{
				// component is registered to feature, but is not present in the Component table
				// - component has been removed from the feature -- this is not supported!!
				DEBUGMSG2(TEXT("SELMGR: ComponentId '%s' is registered to feature '%s', but is not present in the Component table.  Removal of components from a feature is not supported!"), szComponentId, riFeatureString.GetString());
				return -1;
			}
			MsiString strComponent(pComponentCursor->GetString(m_colComponentKey));

			// SELMGR: Component '%s' is registered to feature '%s', strComponent, riFeatureString.GetString()

			// find feature-component mapping and update as registered
			pFeatureComponentsCursor->Reset();
			pFeatureComponentsCursor->SetFilter(iColumnBit(m_colFeatureComponentsFeature) | iColumnBit(m_colFeatureComponentsComponent));
			pFeatureComponentsCursor->PutString(m_colFeatureComponentsFeature, riFeatureString);
			pFeatureComponentsCursor->PutString(m_colFeatureComponentsComponent, *strComponent);
			if (!pFeatureComponentsCursor->Next())
			{
				// component is registered to feature, but is not present in the FeatureComponents table
				// - component has been removed from the feature -- this is not supported!!
				DEBUGMSG2(TEXT("SELMGR: Component '%s' is registered to feature '%s', but is not present in the FeatureComponents table.  Removal of components from a feature is not supported!"), strComponent, riFeatureString.GetString());
				return -1;
			}
			int iFeatureComponentRuntimeFlags = pFeatureComponentsCursor->GetInteger(m_colFeatureComponentsRuntimeFlags);
			if (iFeatureComponentRuntimeFlags == iMsiNullInteger)
				iFeatureComponentRuntimeFlags = 0;
			iFeatureComponentRuntimeFlags |= bfComponentRegistered;
			pFeatureComponentsCursor->PutInteger(m_colFeatureComponentsRuntimeFlags, iFeatureComponentRuntimeFlags);
			AssertNonZero(pFeatureComponentsCursor->Update());

			cRegisteredComponents++;

			pchBeginComponentId += cchComponentId;
			cchComponentListLen -= cchComponentId;
		}
	}

	return cRegisteredComponents;
}

IMsiRecord* CMsiEngine::GetFeatureValidStatesSz(const ICHAR *szFeatureName,int& iValidStates)
{
	MsiStringId idFeature;
	
	idFeature = m_piDatabase->EncodeStringSz(szFeatureName);
	if (idFeature == 0)
	{
		return PostError(Imsg(idbgBadFeature),szFeatureName);
	}

	return GetFeatureValidStates(idFeature, iValidStates);
}
IMsiRecord* CMsiEngine::GetFeatureValidStates(MsiStringId idFeatureName, int& iValidStates)
{
	return GetFeatureValidStates(idFeatureName, iValidStates, (IMsiCursor* )0, (IMsiCursor*) 0);
}

IMsiRecord* CMsiEngine::GetFeatureValidStates(MsiStringId idFeatureName,int& iValidStates, IMsiCursor* piFeatureComponentsCursor, IMsiCursor* piFeatureCursor)
//-------------------------------------------
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

#ifdef DEBUG
	ICHAR rgchFeature[256];
	{
	MsiString stFeatureString(m_piDatabase->DecodeString(idFeatureName));
	stFeatureString.CopyToBuf(rgchFeature,255);
	}
#endif
	int iStateBits = 0;

	int iLocalCount = 0;
	int iSourceCount = 0;
	int iComponentCount = 0;
	int iPatchableCount = 0;
	int iCompressableCount = 0;
	bool fAdvertiseAllowed = true;

	if (m_piComponentTable)
	{
		PMsiCursor pComponentCursor(m_piComponentTable->CreateCursor(fFalse));
		PMsiCursor pFeatureComponentsCursor(0);
		if (piFeatureComponentsCursor == 0)
		{
			pFeatureComponentsCursor = m_piFeatureComponentsTable->CreateCursor(fFalse);
			pFeatureComponentsCursor->SetFilter(1);
			piFeatureComponentsCursor = pFeatureComponentsCursor;
		}
		else
			piFeatureComponentsCursor->Reset();
		
		Assert(piFeatureComponentsCursor);
		piFeatureComponentsCursor->PutInteger(m_colFeatureComponentsFeature,idFeatureName);

		// The RunFromSource state is disallowed if any component tied to the feature
		// contains patchable or compressed files.  The Advertise state is disallowed
		// for a child feature that is FollowParent, if the parent is in the source state.
		while (piFeatureComponentsCursor->Next())
		{
			iComponentCount++;
			MsiStringId idComponent = piFeatureComponentsCursor->GetInteger(m_colFeatureComponentsComponent);
			pComponentCursor->SetFilter(1);
			pComponentCursor->PutInteger(m_colComponentKey,idComponent);
			if (pComponentCursor->Next())
			{
				iisEnum iisInstalled = (iisEnum) pComponentCursor->GetInteger(m_colComponentInstalled);
				icaEnum icaAttributes = (icaEnum) (pComponentCursor->GetInteger(m_colComponentAttributes) & icaInstallMask);
				int iRuntimeFlags = pComponentCursor->GetInteger(m_colComponentRuntimeFlags);
				if ((iRuntimeFlags & bfComponentPatchable) || (iRuntimeFlags & bfComponentCompressed))
					icaAttributes = icaLocalOnly;

				if (iRuntimeFlags & bfComponentPatchable)
					iPatchableCount++;

				if (iRuntimeFlags & bfComponentCompressed)
					iCompressableCount++;

				if (icaAttributes == icaOptional)
				{
					iLocalCount++;
					iSourceCount++;
				}
				else if (icaAttributes == icaLocalOnly)
					iLocalCount++;
				else if (icaAttributes == icaSourceOnly)
				{
					iSourceCount++;
				}
			}
		}
	}

	PMsiCursor pFeatureCursor(0);

	if (piFeatureCursor == 0)
	{
		pFeatureCursor = m_piFeatureTable->CreateCursor(fTrue);
		piFeatureCursor = pFeatureCursor;
	}
	else
		piFeatureCursor->Reset();
		
	piFeatureCursor->SetFilter(1);
	piFeatureCursor->PutInteger(m_colFeatureKey,idFeatureName);
	if (!piFeatureCursor->Next())
		return PostError(Imsg(idbgBadFeature),*MsiString(m_piDatabase->DecodeString(idFeatureName)));
		
	if (iComponentCount == 0)
	{
		iStateBits = icaBitLocal | icaBitSource;
	}
	else
	{
		if (iLocalCount > 0)
			iStateBits |= icaBitLocal;
		if (iSourceCount > 0 && iPatchableCount == 0 && iCompressableCount == 0)
			iStateBits |= icaBitSource;
		if (iPatchableCount > 0)
			iStateBits |= icaBitPatchable;
		if (iCompressableCount > 0)
			iStateBits |= icaBitCompressable;

	}
	
	int ifeaAttributes = piFeatureCursor->GetInteger(m_colFeatureAttributes);
	if(ifeaAttributes == iMsiNullInteger)
		ifeaAttributes = 0;
	// Now check to see if this feature should follow its parent
	// (as far as possible).
	int iParentLevel;
	
	if ((iStateBits & icaBitLocal) && (iStateBits & icaBitSource))
	{
		if ((ifeaAttributes & ifeaInstallMask) ==  ifeaFollowParent)
		{
			iStateBits = 0;
			// Find our root parent (i.e. a parent that is not ifeaFollowParent)
			do
			{
				MsiStringId idParent = piFeatureCursor->GetInteger(m_colFeatureParent);
				piFeatureCursor->Reset();
				piFeatureCursor->SetFilter(1);
				piFeatureCursor->PutInteger(m_colFeatureKey,idParent);
				iParentLevel = piFeatureCursor->Next();
			}while ((piFeatureCursor->GetInteger(m_colFeatureAttributes) & ifeaInstallMask) == ifeaFollowParent);
			
			iisEnum iParAction = (iisEnum) piFeatureCursor->GetInteger(m_colFeatureAction);
			iisEnum iParInstalled = (iisEnum) piFeatureCursor->GetInteger(m_colFeatureInstalled);
			iisEnum iParFinalState = iParAction == iMsiNullInteger ? iParInstalled : iParAction;

			if (iParFinalState == iisLocal)
				iStateBits = icaBitLocal;
			else if (iParFinalState == iisSource)
			{
				iStateBits = icaBitSource;
				fAdvertiseAllowed = false;
			}
			else
			{
				MsiStringId idParent = piFeatureCursor->GetInteger(m_colFeatureKey);
				IMsiRecord* piErrRec = GetFeatureValidStates(idParent,iStateBits, 0, 0);
				if (piErrRec)
					return piErrRec;

				// Per bug 7307, we must clear the Advertise bit if the followParent
				// child doesn't allow advertising.
				if (ifeaAttributes & ifeaDisallowAdvertise)
					iStateBits &= (~icaBitAdvertise);
			}
		}
	}

	// do we allow the advertise and absent states
	if(fAdvertiseAllowed && !(ifeaAttributes & ifeaDisallowAdvertise)
		&& (g_fSmartShell || !(ifeaAttributes & ifeaNoUnsupportedAdvertise)))
		iStateBits |= icaBitAdvertise;

	if(!(ifeaAttributes & ifeaUIDisallowAbsent))
		iStateBits |= icaBitAbsent;

	iValidStates = iStateBits;
	return 0;
}


IMsiRecord* CMsiEngine::GetDescendentFeatureCost(const IMsiString& riFeatureString, iisEnum iisAction, int& iCost)
//-----------------------------------------------
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));
	pCursor->SetFilter(1);
	pCursor->PutString(m_colFeatureKey,riFeatureString);
	int iParentLevel = pCursor->Next();
	if (iParentLevel == 0)
		return PostError(Imsg(idbgBadFeature),riFeatureString);
	pCursor->SetFilter(0);
	int iTreeLevel;
	iCost = 0;
	ResetComponentCostMarkers();
	m_fExclusiveComponentCost = fTrue;
	do
	{
		int iFeatureCost;
		MsiString istrChildFeature = pCursor->GetString(m_colFeatureKey);
		IMsiRecord* piErrRec = GetFeatureCost(*istrChildFeature,iisAction,iFeatureCost);
		if (piErrRec)
			return piErrRec;
		iCost += iFeatureCost;
		iTreeLevel = pCursor->Next();
	}while (iTreeLevel > iParentLevel);
	m_fExclusiveComponentCost = fFalse;
	return 0;

}

IMsiRecord* CMsiEngine::EnumEngineCostsPerVolume(const DWORD dwIndex,
																 IMsiVolume*& rpiVolume,
																 int& iCost, int& iTempCost)
{
	iCost = iTempCost = 0;
	rpiVolume = 0;

	if ( !IsCostingComplete() )
		return PostError(Imsg(idbgOpOutOfSequence),0);
	
	if ( !m_pTempCostsCursor )
	{
		PMsiRecord pError(0);
		PMsiTable pTable(0);
		pError = m_piDatabase->CreateTable(*MsiString(*sztblEngineTempCosts), 0, *&pTable);
		if ( pError )
			return pError;

		m_colTempCostsVolume = pTable->CreateColumn(icdObject + icdNullable + icdPrimaryKey + icdTemporary,
																*MsiString(*sztblEngineTempCosts_colVolume));
		m_colTempCostsTempCost = pTable->CreateColumn(icdLong + icdNoNulls + icdTemporary,
																*MsiString(*sztblEngineTempCosts_colTempCost));
		Assert(m_colTempCostsVolume && m_colTempCostsTempCost);

		m_pTempCostsCursor = pTable->CreateCursor(fFalse);
		Assert(m_pTempCostsCursor);

		m_pTempCostsCursor->SetFilter(iColumnBit(m_colTempCostsVolume));
		Bool fValidEnum = fTrue;
		for ( int iIndex = 0; fValidEnum; iIndex++ )
		{
			int iCost = 0;
			int iNoRbCost = 0;
			PMsiPath pPath(0);
			PMsiRecord pError(0);
			pError = EnumEngineCosts(iIndex, /* fRecalc= */ fTrue,
											 /* fExact = */ fTrue, fValidEnum, *&pPath,
											 iCost, iNoRbCost, NULL);
			if ( pError )
			{
				m_pTempCostsCursor = 0;
				return pError;
			}
			if ( !fValidEnum )
				break;

			PMsiVolume pVolume = &pPath->GetVolume();
			m_pTempCostsCursor->Reset();
			m_pTempCostsCursor->PutMsiData(m_colTempCostsVolume, pVolume);
			if (!m_pTempCostsCursor->Next())
			{
				AssertNonZero(m_pTempCostsCursor->PutMsiData(m_colTempCostsVolume, pVolume));
				AssertNonZero(m_pTempCostsCursor->PutInteger(m_colTempCostsTempCost, 0));
				AssertNonZero(m_pTempCostsCursor->Insert());
			}
			int iRecCost = m_pTempCostsCursor->GetInteger(m_colTempCostsTempCost) + iCost;
			AssertNonZero(m_pTempCostsCursor->PutInteger(m_colTempCostsTempCost, iRecCost));
			AssertNonZero(m_pTempCostsCursor->Update());
		}
		m_pTempCostsCursor->SetFilter(0);
	}

	m_pTempCostsCursor->Reset();
	int iRes = 0;
	// I look for the dwIndex-th entry in the temporary table.
	for ( int i=0; i <= dwIndex && (iRes = m_pTempCostsCursor->Next()) != 0; i++ )
		;

	if ( !iRes )
		return PostError(Imsg(idbgNoMoreData));

	rpiVolume = (IMsiVolume*)m_pTempCostsCursor->GetMsiData(m_colTempCostsVolume);
	iCost = 0;
	iTempCost = m_pTempCostsCursor->GetInteger(m_colTempCostsTempCost);
	return 0;
}

IMsiRecord* CMsiEngine::EnumComponentCosts(const IMsiString& riComponentName,
														 const iisEnum iisAction,
														 const DWORD dwIndex,
														 IMsiVolume*& rpiVolume,
														 int& iCost, int& iTempCost)
{
	iCost = iTempCost = 0;
	rpiVolume = 0;

	if ( !m_piComponentTable || !m_colComponentParent )
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	if ( !IsCostingComplete() )
		return PostError(Imsg(idbgOpOutOfSequence),0);

	PMsiCursor pComponentsCursor(m_piComponentTable->CreateCursor(fFalse));
	Assert(pComponentsCursor);
	pComponentsCursor->SetFilter(iColumnBit(m_colComponentKey));
	pComponentsCursor->PutString(m_colComponentKey, riComponentName);

	// temporary array that holds the serial numbers of the volumes
	// encountered.  We add elements into it as long as we haven't
	// encountered the dwIndex-th volume.
	CTempBuffer<int, 20> rgiVolumes;
	// the number of volumes in rgiVolumes
	int cVolumes = 0;
	// the serial number of the dwIndex-th volume
	int iTheVolume = 0;
	bool fDoingComponent = true;
	bool fComponentDisabled = false;

	// this loop cumulates the cost for the particular component (and any
	// subcomponents it might have) when the volume that the component's
	// directory belongs to is on the volume at the dwIndex-th position
	for ( int iRes; (iRes = pComponentsCursor->Next()) != 0 || fDoingComponent; )
	{
		if (iRes && fDoingComponent)
		{
			// we're right on the component
			if (pComponentsCursor->GetInteger(m_colComponentRuntimeFlags) & bfComponentDisabled)
				fComponentDisabled = true;
		}
		if ( !iRes )
		{
			// we check the component first and then its child components
			// (the component table is layed-out as having child components
			// created on the fly for components that write to more directories
			// than the authored one).
			fDoingComponent = false;
			pComponentsCursor->Reset();
			pComponentsCursor->SetFilter(iColumnBit(m_colComponentParent));
			pComponentsCursor->PutString(m_colComponentParent, riComponentName);
			continue;
		}
		// getting the current volume's serial number
		MsiString strComponentDir = pComponentsCursor->GetString(m_colComponentDir);
		PMsiPath pPath(0);
		PMsiRecord piError = GetTargetPath(*strComponentDir, *&pPath);
		if ( piError )
			return piError;
		PMsiVolume pVolume = &pPath->GetVolume();
		int iVolume = pVolume->SerialNum();
		if ( iTheVolume == 0 )
		{
			// we haven't encountered the dwIndex-th volume yet

			// we look up the current volume in the array
			for ( int i=0; i < cVolumes; i++ )
				if ( iVolume == rgiVolumes[i] )
					break;
			if ( i == cVolumes )
			{
				// we haven't encountered this volume yet
				if ( i == dwIndex )
				{
					// this is the dwIndex-th volume.
					iTheVolume = iVolume;
					rpiVolume = pVolume;
					pVolume->AddRef();
				}
				else
				{
					// we add the new volume into the array
					if ( cVolumes == rgiVolumes.GetSize() )
						rgiVolumes.Resize(cVolumes+10);
					rgiVolumes[cVolumes++] = iVolume;
				}
			}
		}
		if ( iTheVolume && iVolume == iTheVolume && !fComponentDisabled )
		{
			int iCompCost, iNoRbCost, iARPCost, iNoRbARPCost;
			piError = GetComponentActionCost(pComponentsCursor, iisAction, iCompCost, iNoRbCost, iARPCost, iNoRbARPCost);
			if ( piError )
				return piError;
			iCost += iNoRbCost;
			iTempCost += iCompCost - iNoRbCost;
		}
	}

	if ( iTheVolume )
		// the dwIndex-th volume was found; life is good
		return 0;
	else
		return PostError(cVolumes ? Imsg(idbgNoMoreData) : Imsg(idbgBadComponent),
							  riComponentName);
}

IMsiRecord* CMsiEngine::GetFeatureCost(const IMsiString& riFeatureString, iisEnum iisAction, int& iCost)
/*-------------------------------------------------------------------------
Returns the cost attributable to all components linked directly to the given
feature.  The cost value based on the specified action state, not on the
current action state of each component.
---------------------------------------------------------------------------*/
{
	if (!m_piFeatureComponentsTable || !m_piComponentTable || !m_piFeatureTable)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pFeatureComponentsCursor(m_piFeatureComponentsTable->CreateCursor(fFalse));
	PMsiCursor pComponentCursor(m_piComponentTable->CreateCursor(fFalse));
	Assert(pFeatureComponentsCursor);
	pFeatureComponentsCursor->SetFilter(1);
	pFeatureComponentsCursor->PutString(m_colFeatureComponentsFeature,riFeatureString);
	iCost = 0;
	int iComponentCount = 0;
	while (pFeatureComponentsCursor->Next())
	{
		int iComponentCost, iNoRbComponentCost;
		MsiString strComponent = pFeatureComponentsCursor->GetString(m_colFeatureComponentsComponent);
		IMsiRecord* piErrRec = GetTotalSubComponentActionCost(*strComponent,
			iisAction == iisAdvertise ? (iisEnum) iMsiNullInteger : iisAction, iComponentCost, iNoRbComponentCost);
		if (piErrRec)
			return piErrRec;
		iCost += iNoRbComponentCost;
		iComponentCount++;
	}
	if (iComponentCount == 0)
	{
		PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fTrue));
		pCursor->SetFilter(1);
		pCursor->PutString(m_colFeatureKey,riFeatureString);
		if (!pCursor->Next())
			return PostError(Imsg(idbgBadFeature),riFeatureString);
	}
	return 0;
}


IMsiRecord* CMsiEngine::GetAncestryFeatureCost(const IMsiString& riFeatureString, iisEnum iisAction, int& iCost)
/*-------------------------------------------------------------------------
Returns the cost attributable to the specified feature (excluding cost of
any children), plus the cost of all the feature's ancestors.
---------------------------------------------------------------------------*/
{
	iCost = 0;
	MsiString strAncestor(riFeatureString.GetString());
	while (strAncestor.TextSize() > 0)
	{
		int iFeatureCost;
		IMsiRecord* piErrRec = GetFeatureCost(*strAncestor,iisAction,iFeatureCost);
		if (piErrRec)
			return piErrRec;

		iCost += iFeatureCost;
		MsiString strFeature = strAncestor;
		if ((piErrRec = GetFeatureParent(*strFeature, *&strAncestor)) != 0)
			return piErrRec;
	}
	return 0;
}

IMsiRecord* CMsiEngine::GetFeatureParent(const IMsiString& riFeatureString,const IMsiString*& rpiParentString)
/*------------------------------------------------------------------------
Returns the name of the feature to which riFeatureString is parented.  If
riFeatureString has no parent, a NULL string will be returned in
rpiParentString.
--------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	m_piFeatureCursor->Reset();
	m_piFeatureCursor->SetFilter(1);
	m_piFeatureCursor->PutString(m_colFeatureKey,riFeatureString);
	if (m_piFeatureCursor->Next())
		rpiParentString = &m_piFeatureCursor->GetString(m_colFeatureParent);
	else
		return PostError(Imsg(idbgBadFeature),riFeatureString);

	return 0;
}

IMsiRecord* CMsiEngine::GetFeatureStates(const IMsiString& riFeatureString,iisEnum* iisInstalled, iisEnum* iisAction)
{
	MsiStringId idFeatureString;

	idFeatureString = m_piDatabase->EncodeString(riFeatureString);
	if (idFeatureString == iTableNullString)
	{
		return PostError(Imsg(idbgBadFeature),riFeatureString);
	}

	return GetFeatureStates(idFeatureString, iisInstalled, iisAction);
}

IMsiRecord* CMsiEngine::GetFeatureStates(const MsiStringId idFeatureString,iisEnum* iisInstalled, iisEnum* iisAction)
/*------------------------------------------------------------------------
Returns the installed and current action state for the specified feature.
Null can be passed for either iisEnum argument if the caller doesn't need
that value.  Note: the returned states are not valid until after
InitializeComponents has been called.
--------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	m_piFeatureCursor->Reset();
	m_piFeatureCursor->SetFilter(1);
	m_piFeatureCursor->PutInteger(m_colFeatureKey,idFeatureString);
	if (m_piFeatureCursor->Next())
	{
		if (iisInstalled) *iisInstalled = (iisEnum) m_piFeatureCursor->GetInteger(m_colFeatureInstalled);
		if (iisAction) *iisAction = (iisEnum) m_piFeatureCursor->GetInteger(m_colFeatureAction);
	}
	else
		return PostError(Imsg(idbgBadFeature),*MsiString(m_piDatabase->DecodeString(idFeatureString)));

	return 0;
}

IMsiRecord* CMsiEngine::GetFeatureRuntimeFlags(const MsiStringId idFeatureString, int* piRuntimeFlags)
/*------------------------------------------------------------------------
Returns the runtime flags for the specified feature.
Note: the returned states are not valid until after
InitializeComponents has been called.
--------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	m_piFeatureCursor->Reset();
	m_piFeatureCursor->SetFilter(1);
	m_piFeatureCursor->PutInteger(m_colFeatureKey,idFeatureString);
	if (m_piFeatureCursor->Next())
	{
		if (piRuntimeFlags) *piRuntimeFlags = m_piFeatureCursor->GetInteger(m_colFeatureRuntimeFlags);
	}
	else
		return PostError(Imsg(idbgBadFeature),*MsiString(m_piDatabase->DecodeString(idFeatureString)));

	return 0;
}

IMsiRecord* CMsiEngine::GetFeatureConfigurableDirectory(const IMsiString& riFeatureString, const IMsiString*& rpiDirKey)
/*------------------------------------------------------------------------
Returns the key for the directory marked as configurable by this feature.
If the feature does designate a directory as configurable, the
Directory table is checked to see if the directory has been marked as
non-configurable (for instance, if it contains in installed component)
--------------------------------------------------------------------------*/
{
	if (!m_piFeatureCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	if (!m_fDirectoryManagerInitialized)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	m_piFeatureCursor->Reset();
	m_piFeatureCursor->SetFilter(m_colFeatureKey);
	m_piFeatureCursor->PutString(m_colFeatureKey,riFeatureString);
	if (!m_piFeatureCursor->Next())
		return PostError(Imsg(idbgBadFeature),riFeatureString);

	MsiString strConfigDirKey = m_piFeatureCursor->GetString(m_colFeatureConfigurableDir);

#ifdef DEBUG // make sure dir key is all UPPERCASE
	MsiString strTemp = strConfigDirKey;
	strTemp.UpperCase();
	if(strTemp.Compare(iscExact,strConfigDirKey) == 0)
	{
		ICHAR szDebug[256];
		wsprintf(szDebug,TEXT("Configurable directory '%s' not public property (not ALL CAPS)"),(const ICHAR*)strConfigDirKey);
		AssertSz(0,szDebug);
	}
#endif //DEBUG

	if(strConfigDirKey.TextSize())
	{
		// no Directory table so this directory key doesn't exist
		if (!m_piDirTable)
			return PostError(Imsg(idbgUnknownDirectory),*strConfigDirKey);

		PMsiCursor pDirCursor = m_piDirTable->CreateCursor(fTrue);
		pDirCursor->Reset();
		pDirCursor->SetFilter(m_colDirKey);
		pDirCursor->PutString(m_colDirKey,*strConfigDirKey);
		if (!pDirCursor->Next())
			return PostError(Imsg(idbgUnknownDirectory),*strConfigDirKey);

		int i = pDirCursor->GetInteger(m_colDirNonConfigurable);
		if(i != 0 && i != iMsiStringBadInteger)
			strConfigDirKey = TEXT(""); // not really configurable
	}

	strConfigDirKey.ReturnArg(rpiDirKey);
	return 0;
}

IMsiRecord* CMsiEngine::GetComponentStates(const IMsiString& riComponentString,iisEnum* iisInstalled, iisEnum* iisAction)
/*------------------------------------------------------------------------
Returns the installed and current action state for the specified component.
Null can be passed for either iisEnum argument if the caller doesn't need
that value.  Note: the returned states are not valid until after
InitializeComponents has been called.
--------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	CreateSharedCursor(piComponentCursor, m_piComponentCursor);
	m_piComponentCursor->SetFilter(1);
	m_piComponentCursor->PutString(m_colComponentKey,riComponentString);
	if (m_piComponentCursor->Next())
	{
		if (iisInstalled) *iisInstalled = (iisEnum) m_piComponentCursor->GetInteger(m_colComponentInstalled);
		if (iisAction) *iisAction = (iisEnum) m_piComponentCursor->GetInteger(m_colComponentAction);
	}
	else
		return PostError(Imsg(idbgBadFeature),riComponentString);

	return 0;
}


void CMsiEngine::SetProductAlienClientsFlag()
{
	// the m_fAlienClients flag is set to prevent any features from being uninstalled
	m_fAlienClients = fFalse;
	
	if(m_fBeingUpgraded)
		return; // when we are being upgraded, the new product will take our place - it is safe to remove ourselves

	MsiString strParent = GetPropertyFromSz(IPROPNAME_PARENTPRODUCTCODE);
	if(!strParent.TextSize())
		strParent = *szSelfClientToken;

	MsiString strClients;
	AssertRecord(GetProductClients(m_riServices, MsiString(GetProductKey()), *&strClients));
	while (strClients.TextSize())
	{
		if(*(const ICHAR*)strClients)
		{
			MsiString strProduct = strClients.Extract(iseUpto, ';');

			if(!strProduct.Compare(iscExactI, strParent))
			{
				m_fAlienClients = fTrue;
				return;
			}
		}
		if (!strClients.Remove(iseIncluding, '\0'))
			break;
	}
}

IMsiRecord* CMsiEngine::InitializeComponents()
//------------------------------------------
{
	Bool fCompressed = fFalse;
	Bool fPatchable = fFalse;
	Bool *pfPatchable = 0;

	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	SetPropertyInt(*MsiString(*IPROPNAME_OUTOFDISKSPACE),fFalse);
	SetPropertyInt(*MsiString(*IPROPNAME_OUTOFNORBDISKSPACE),fFalse);
	SetPropertyInt(*MsiString(*IPROPNAME_PRIMARYFOLDER_SPACEAVAILABLE), 0);
	SetPropertyInt(*MsiString(*IPROPNAME_PRIMARYFOLDER_SPACEREQUIRED), 0);
	SetPropertyInt(*MsiString(*IPROPNAME_PRIMARYFOLDER_SPACEREMAINING), 0);
	m_fForegroundCostingInProgress = false;
	IMsiRecord* piErrRec = 0;
	bool fAdmin = GetMode() & iefAdmin;

	if(!fAdmin)
	{
		piErrRec = DetermineComponentInstalledStates();
		if (piErrRec)
			return piErrRec;
	}


	PMsiCursor pComponentCursor(m_piComponentTable->CreateCursor(fTrue));
	pComponentCursor->Reset();
	pComponentCursor->SetFilter(0);
	int iTreeLevel;
	int iKillLevel = 0;  // highest level that is inactive

	//
	// Load the File table and Patch table
	PMsiTable pFileTable(0);
	PMsiCursor pFileCursor(0);
	PMsiTable pPatchTable(0);
	PMsiCursor pPatchCursor(0);
	if ((piErrRec = LoadFileTable(0,*&pFileTable)) != 0)
	{
		if (piErrRec->GetInteger(1) == idbgDbTableUndefined)
		{
			piErrRec->Release();
		}
		else
			return piErrRec;
	}
	else
	{
		pFileCursor = pFileTable->CreateCursor(fFalse);

		if((piErrRec = m_piDatabase->LoadTable(*MsiString(sztblPatch),0,*&pPatchTable)) != 0)
		{
			if (piErrRec->GetInteger(1) == idbgDbTableUndefined)
			{
				piErrRec->Release();
			}
			else
				return piErrRec;
		}
		else
		{
			m_colPatchKey = pPatchTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblPatch_colFile));
			m_colPatchAttributes = pPatchTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblPatch_colAttributes));
			if (pPatchTable->GetRowCount() != 0)
			{
				pfPatchable = &fPatchable;
				pPatchCursor = pPatchTable->CreateCursor(fFalse);
			}
		}
	}
	
	while ((iTreeLevel = pComponentCursor->Next()) > 0)
	{
		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		if (iTreeLevel > MAX_COMPONENT_TREE_DEPTH)
			return PostError(Imsg(idbgIllegalTreeDepth),MAX_COMPONENT_TREE_DEPTH);
		
		MsiStringId idComponent = pComponentCursor->GetInteger(m_colComponentKey);
#ifdef DEBUG
		ICHAR rgchComponent[256];
		MsiString(m_piDatabase->DecodeString(idComponent)).CopyToBuf(rgchComponent,255);
#endif


		Bool fComponentDisabled = fFalse;
		if(!fAdmin)
		{
			iisEnum iisInstalled = (iisEnum) pComponentCursor->GetInteger(m_colComponentInstalled);
			INSTALLSTATE iClientState = (INSTALLSTATE) pComponentCursor->GetInteger(m_colComponentTrueInstallState);

			Assert(iisInstalled == iMsiNullInteger || (iisInstalled >= iisAbsent && iisInstalled < iisNextEnum));

			if (iKillLevel > 0 && iTreeLevel > iKillLevel)
			{
				fComponentDisabled = fTrue;
			}
			else
			{
				if(iClientState == INSTALLSTATE_NOTUSED)
				{
					// component, once installed disabled always remain disabled (unless marked transitive and we are reinstalling
					iKillLevel = iTreeLevel;
					fComponentDisabled = fTrue;
				}
				else if((iisInstalled == iMsiNullInteger || iisInstalled == iisAbsent) && m_colComponentCondition > 0 &&
					EvaluateCondition(MsiString(pComponentCursor->GetString(m_colComponentCondition))) == iecFalse)
				{
					// component has not been installed, is disabled
					iKillLevel = iTreeLevel;
					fComponentDisabled = fTrue;
				}
				else
				{
					// component has been installed (enabled) or has not been installed and the condition on the component is enabled
					iKillLevel = 0;
				}
			}
		}

		int iRuntimeFlags = pComponentCursor->GetInteger(m_colComponentRuntimeFlags);
		if (iRuntimeFlags == iMsiNullInteger)
			iRuntimeFlags = 0;

		if (fComponentDisabled) iRuntimeFlags |= bfComponentDisabled;
		pComponentCursor->PutInteger(m_colComponentRuntimeFlags, iRuntimeFlags);

		AssertNonZero(pComponentCursor->Update());
	}

	if ((piErrRec = SetFileComponentStates(pComponentCursor, pFileCursor, pPatchCursor)) != 0)
		return piErrRec;
		
	return DetermineFeatureInstalledStates();
}


Bool CMsiEngine::SetFeatureHandle(const IMsiString& riFeatureString, INT_PTR iHandle)
//------------------------
{
	PMsiCursor pCursor(m_piFeatureTable->CreateCursor(fFalse));
	pCursor->SetFilter(1);
	pCursor->PutString(m_colFeatureKey,riFeatureString);
	if (pCursor->Next())
	{
		if (!PutHandleData(pCursor, m_colFeatureHandle, iHandle))
			return fFalse;
		if (!pCursor->Update())
			return fFalse;

		return fTrue;
	}
	else
	{
		return fFalse;
	}
}

IMsiRecord* CMsiEngine::SetComponentSz(const ICHAR * szComponentString, iisEnum iRequestedSelectState)
{
	MsiStringId idComponent;

	idComponent = m_piDatabase->EncodeStringSz(szComponentString);

	if (idComponent == 0)
		return PostError(Imsg(idbgBadComponent),szComponentString);

	IMsiRecord *piErrRec;

	if ((piErrRec = SetComponent(idComponent, iRequestedSelectState)) != 0)
		return piErrRec;
		
	if (m_fCostingComplete)
	{
		if ((piErrRec = DetermineEngineCost(NULL, NULL)) != 0)
			return piErrRec;
	}

	return 0;
}

IMsiRecord* CMsiEngine::SetComponent(const MsiStringId idComponentString, iisEnum iRequestedSelectState)
//----------------------------------
{
	IMsiRecord* piErrRec = 0;
	iisEnum iisAction, iisOldAction, iisOldRequestedSelectState;
	bool fComponentEnabled;

	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	{  // Force Cursor to go out of scope before UpdateComponentActionStates
		CreateSharedCursor(piComponentCursor, m_piComponentCursor);
		m_piComponentCursor->SetFilter(1);
		m_piComponentCursor->PutInteger(m_colComponentKey,idComponentString);

		int iParentLevel = m_piComponentCursor->Next();
		if (iParentLevel == 0)
			return PostError(Imsg(idbgBadComponent),*MsiString(m_piDatabase->DecodeString(idComponentString)));

#ifdef DEBUG
			ICHAR rgchComponent[256];
			MsiString istrComponent(m_piComponentCursor->GetString(m_colComponentKey));
			istrComponent.CopyToBuf(rgchComponent,255);
#endif

		bool fSkipSharedTransitionProcessing = false;
		iisEnum iisInstalled = (iisEnum) m_piComponentCursor->GetInteger(m_colComponentInstalled);
		iisOldAction = (iisEnum) m_piComponentCursor->GetInteger(m_colComponentAction);
		iisOldRequestedSelectState = (iisEnum) m_piComponentCursor->GetInteger(m_colComponentActionRequest);
		INSTALLSTATE iClientState = (INSTALLSTATE) m_piComponentCursor->GetInteger(m_colComponentTrueInstallState);
		int iRuntimeFlags = m_piComponentCursor->GetInteger(m_colComponentRuntimeFlags);
		icaEnum icaAttributes = (icaEnum) (m_piComponentCursor->GetInteger(m_colComponentAttributes));
		MsiString strComponentId = m_piComponentCursor->GetString(m_colComponentID);
		fComponentEnabled = (iRuntimeFlags & bfComponentDisabled) ? false : true;
		bool fComponentTransitive = (icaAttributes & icaTransitive) ? true : false;
		bool fNullActionRequired = false;

		// what type of an install are we attempting
		Bool fAllUsers = MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? fTrue : fFalse;
		iaaAppAssignment iaaAsgnType = fAllUsers ? iaaMachineAssign : iaaUserAssign;
		
		iisAction = (iisEnum) iMsiNullInteger;
		// handle reinstall
		if (iRequestedSelectState == iisReinstallLocal || iRequestedSelectState == iisReinstallSource)
		{
			// app compat fix 350947
			// fix for component TTSData.A95D6CE6_C572_42AA_AA7B_BA92AFE9EA24, marked transitive
			// from the merge module Sp5TTInt.msm
			// this component has its key file Mary.sdf not SFP'd in Whistler
			// however a non-key file sam.sdf is SFP'd. Hence we would have ordinarily 
			// remove all registration for the component while leaving the SFP'd file
			// alone during a reinstall on Whistler (after upgrade from Win2k). However this busts the component.
			// hence we check the component id of the component and effectively treat it
			// as permanant and non-transitive on Whistler and above

			// app comat fix 368867
			// help files for SAPI product being removed on Whistler even though they are installed as part of the OS
			// similar issue as above

			if(fComponentTransitive == true && MinimumPlatformWindowsNT51() && 
			   (strComponentId.Compare(iscExact, TTSData_A95D6CE6_C572_42AA_AA7B_BA92AFE9EA24) ||
				strComponentId.Compare(iscExact, SapiCplHelpEng_0880F209_45FA_42C5_92AE_5E620033E8EC) || 
				strComponentId.Compare(iscExact, SapiCplHelpJpn_0880F209_45FA_42C5_92AE_5E620033E8EC) || 
				strComponentId.Compare(iscExact, SapiCplHelpChs_0880F209_45FA_42C5_92AE_5E620033E8EC)))
			{
				DEBUGMSG1(TEXT("APPCOMPAT: treating component: %s as non-transitive"), strComponentId);
				fComponentTransitive = false; // work as if the component is not marked transitive
			}

			if (fComponentTransitive)
			{
				// find the "true" condition on the component
				fComponentEnabled = (EvaluateCondition(MsiString(m_piComponentCursor->GetString(m_colComponentCondition))) == iecFalse)?fFalse:fTrue;



				// If a previously disabled transitive component is now enabled, install it.
				if (iClientState == INSTALLSTATE_NOTUSED && fComponentEnabled == true)
					iRequestedSelectState = (iRequestedSelectState == iisReinstallLocal) ? iisLocal : iisSource;

				// If previously installed transitive component has gone disabled, remove it.
				else if (iClientState != INSTALLSTATE_NOTUSED && (iisInstalled == iisLocal || iisInstalled == iisSource))
				{
					// The requested state remains local or source, even if iisAction is going to iisAbsent,
					// so that ProcessComponents will know to register the component as INSTALLSTATE_NOTUSED.
					iRequestedSelectState  = iisInstalled;
					iisAction = fComponentEnabled ? iisInstalled : iisAbsent;

					// In this case, we want to forcibly remove this component without regard to client list
					// or 'permanent' bit considerations.
					if (iisAction == iisAbsent)
					{
						PMsiRecord pRec(0);
						if ((piErrRec = GetComponentPath(m_riServices, 0, *MsiString(GetProductKey()), *strComponentId, *&pRec, &iaaAsgnType)) != 0)
							return piErrRec;
	
						//
						// If the key path is SFP protected, we don't want to delete any of the registrations for this component
						// since the keypath is never going to go away so it is best to leave the registrations around.
						// Note: The specific case that this affects is bug # 409400 where speech components in Office packages
						// are installed on Win2K and lower platforms where they are not part of the system but not on WinXP and higher
						// where they are part of the system and hence SFP'ed. If a Win2K system with O2K is upgraded
						// to WinXP and a reinstall of Office is performed, we don't want the speech registrations to go away.
						//
						MsiString strKeyFullPath = pRec->GetMsiString(icmlcrFile);
						BOOL fProtected = fFalse;
						if ( g_MessageContext.m_hSfcHandle )
							fProtected = SFC::SfcIsFileProtected(g_MessageContext.m_hSfcHandle, CConvertString(strKeyFullPath));
						if (fProtected)
						{
							DEBUGMSG2(TEXT("Disallowing uninstallation of component: %s since key file %s is under SFP"), strComponentId, strKeyFullPath);
							iisAction = (iisEnum)iMsiNullInteger;
							fNullActionRequired = true;
						}

						fSkipSharedTransitionProcessing = true;
					}
				}

				// If new component, install it
				else if (iClientState == INSTALLSTATE_UNKNOWN)
					iRequestedSelectState = (iRequestedSelectState == iisReinstallLocal) ? iisLocal : iisSource;
				else
					iRequestedSelectState = (iisEnum) iMsiNullInteger;
			}
			else
			{
				// Standard reinstall -- we can't just set to iisInstalled because our reinstall request might also include a request for the component to go local if it's shared
				if ((iClientState != INSTALLSTATE_NOTUSED && (iisInstalled == iisLocal || iisInstalled == iisSource)) // existing component
					|| (iClientState == INSTALLSTATE_UNKNOWN && (iisInstalled == iisAbsent || (iisInstalled == (iisEnum) iMsiNullInteger && strComponentId.TextSize() == 0 /* unregistered */)))) // new component
					iRequestedSelectState = (iRequestedSelectState == iisReinstallLocal) ? iisLocal : iisSource;
				else
					iRequestedSelectState = (iisEnum) iMsiNullInteger;
			}
		}
		else if (!m_fForceRequestedState && iRequestedSelectState == iisInstalled)
		{
			// the component is already in the requested state
			iRequestedSelectState = (iisEnum) iMsiNullInteger;
		}

		if(ActionProgress() == imsCancel)
			return PostError(Imsg(imsgUser));

		// if the component is disabled and is set to be isolated to another component then we need to remove the 
		// files that we added to the other component
		if(!fComponentEnabled)
		{
			if ((piErrRec = RemoveIsolateEntriesForDisabledComponent(*this, MsiString(m_piComponentCursor->GetString(m_colComponentKey)))) != 0)
				return piErrRec;
		}

		// Action determination rules
		icaEnum icaInstallMode = icaEnum(icaAttributes & icaInstallMask);

		// Components with patchable or compressed files can't be RunFromSource
		if ((iRuntimeFlags & bfComponentPatchable) || (iRuntimeFlags & bfComponentCompressed))
			icaInstallMode = icaLocalOnly;

		if(!(GetMode() & iefAdmin))
		{
			if (iRequestedSelectState == iisLocal && icaInstallMode == icaSourceOnly)
				iRequestedSelectState = iisSource;
			else if (iRequestedSelectState == iisSource && icaInstallMode == icaLocalOnly)
				iRequestedSelectState = iisLocal;
		}

		if (iisAction == iMsiNullInteger && !fNullActionRequired)
			iisAction = iRequestedSelectState;

		MsiString istrComponentID = m_piComponentCursor->GetString(m_colComponentID);
		PMsiRecord pRec(0);
		if (istrComponentID.TextSize() == 0)  // unregistered component
		{
			iisAction = (fComponentEnabled && (iRequestedSelectState != iisAbsent)) ? iRequestedSelectState : (iisEnum) iMsiNullInteger;
			// Normally the PMsiSharedCursor implementation will do this when the shared cursor
			// goes out of scope. Here, we are going out of scope, but it doesn't look
			// that way to the compiler, so we'll reset the cursor by hand. This does
			// mean that the cursor will get reset twice in the case where it's not registered.
			m_piComponentCursor->Reset();
			return  UpdateComponentActionStates(idComponentString,iisAction, iRequestedSelectState, fComponentEnabled);
		}

		if ((iisInstalled == iMsiNullInteger || iisInstalled == iisAbsent || iClientState == INSTALLSTATE_NOTUSED)
			&& fComponentEnabled == false)
		{
			iisAction = (iisEnum) iMsiNullInteger;
		}
		else if (!fSkipSharedTransitionProcessing)
		{  // Force Cursor to go out of scope before UpdateComponentActionStates
			switch(iisAction)
			{

		//--------------------------------------------------------------------------
			case iMsiNullInteger:
				switch(iisInstalled)
				{
				case iisLocal:
				case iisSource:
				{
					// need to shift to local if
					// 1. The installation state is absent/ (broken)
					if(iClientState == INSTALLSTATE_ABSENT && (!fComponentTransitive || (EvaluateCondition(MsiString(m_piComponentCursor->GetString(m_colComponentCondition))) != iecFalse)))
						iisAction = iisInstalled;
					break;
				}
				default:
					break;
				}
				break;

		//--------------------------------------------------------------------------
			case iisAbsent:
				switch(iisInstalled)
				{
				case iisSource:
				case iisLocal:
				{
					if (pRec == 0)
					{
						if ((piErrRec = GetComponentPath(m_riServices, 0, *MsiString(GetProductKey()), *istrComponentID, *&pRec, &iaaAsgnType)) != 0)
							return piErrRec;
					}
					if ((piErrRec = DoStateTransitionForSharedUninstalls(iisAction, *pRec)) != 0)
						return piErrRec;
					break;
				}
				default:
					break;
				}
				break;

		//--------------------------------------------------------------------------

			case iisSource:
				switch(iisInstalled)
				{
				case iisLocal:
				{
					if (pRec == 0)
					{
						if ((piErrRec = GetComponentPath(m_riServices, 0, *MsiString(GetProductKey()), *istrComponentID, *&pRec, &iaaAsgnType)) != 0)
							return piErrRec;
					}
					if ((piErrRec = DoStateTransitionForSharedUninstalls(iisAction, *pRec)) != 0)
						return piErrRec;
					break;
				}
				case iMsiNullInteger:
				case iisAbsent:
				{
					// prevent installation of "dont stomp" components if key path is regkey
					if((m_piComponentCursor->GetInteger(m_colComponentAttributes) & (icaNeverOverwrite | icaRegistryKeyPath)) == (icaNeverOverwrite | icaRegistryKeyPath))
					{
						if ((piErrRec = CheckNeverOverwriteForRegKeypath(idComponentString, iisAction)) != 0)
							return piErrRec;
					}
					break;
				}
				default:
					break;
				}
				break;

		//--------------------------------------------------------------------------
			case iisLocal:
				// prevent installation of older components, check for legacy installs
				if ((piErrRec = DoStateTransitionForSharedInstalls(idComponentString, iisAction)) != 0)
					return piErrRec;
				break;

		//--------------------------------------------------------------------------
			default:
				// unknown requested state
				return PostError(Imsg(idbgIllegalSetComponentRequest),0);
			}
		}
	}  // Force Cursor to go out of scope before UpdateComponentActionStates

	if(iisAction == iisOldAction && iRequestedSelectState == iisOldRequestedSelectState)
		return 0; // nothing to do

	return UpdateComponentActionStates(idComponentString,iisAction, iRequestedSelectState, fComponentEnabled);
}


// fn that checks if a particular GUID represents that used to mark permanant components
bool IsSystemClient(const IMsiString& riProduct)
{
	ICHAR rgchSystemProductKeyPacked[cchProductCode  + 1];
	AssertNonZero(PackGUID(szSystemProductKey,    rgchSystemProductKeyPacked));
	ICHAR rgchProductKeyPacked[cchProductCode  + 1];
	AssertNonZero(PackGUID(riProduct.GetString(), rgchProductKeyPacked));
	return !IStrCompI(rgchSystemProductKeyPacked + 2, rgchProductKeyPacked + 2); // system guid will have all characters except first 2 as "0"
}

IMsiRecord* CMsiEngine::DoStateTransitionForSharedUninstalls(iisEnum& riisAction, const IMsiRecord& riComponentPathRec)
{
	// if we are going from local to source or local to absent
		// we may need to switch to fileabsent state if there are other installs
		// but none in the same location
	
		// or null state if there are other installs in the same location

	// if we are going from source to absent
		// we may need to switch to null state  if there are other installs

	//NOTE: the riisAction variable is selectively modified AND is expected to be set to the default by the callee
	//NOTE: we assume that the m_piComponentCursor is set to the required component key
	//NOTE: we assume that the riComponentPathRec is a valid record returned by GetComponentPath

	Assert(m_piComponentCursor);

	MsiString strComponentId = m_piComponentCursor->GetString(m_colComponentID);
	INSTALLSTATE iClientState = (INSTALLSTATE)riComponentPathRec.GetInteger(icmlcrINSTALLSTATE);
	MsiString strFile = riComponentPathRec.GetMsiString(icmlcrFile);

	// what type of an install are we attempting
	Bool fAllUsers = MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? fTrue : fFalse;
	iaaAppAssignment iaaAsgnType = fAllUsers ? iaaMachineAssign : iaaUserAssign;

    CClientEnumToken ctokProductIndex;
    ICHAR szProductBuf[cchProductCode + 1];
    Bool fLocalNonFusionPath = fFalse;
	enum cetEnumType cetET = cetVisibleToUser; // enumerate those hives that are visible to this user
    IMsiRecord* piErrRec = 0;
	int iHive = MsiString(strFile.Extract(iseUpto, TEXT(':')));
    // all fusion installs go to the same location, hence we should treat them as if they are non file key paths (we dont want to check the install location)
    if(((iClientState == INSTALLSTATE_LOCAL) || (iClientState == INSTALLSTATE_ABSENT)) && (strFile.TextSize()) 
    && *(const ICHAR*)strFile != chTokenFusionComponent && *(const ICHAR*)strFile != chTokenWin32Component &&
    (iHive == iMsiStringBadInteger))
    {
		// we have a local install and the key path is a file/ folder
		fLocalNonFusionPath = fTrue;
    }

	MsiString strUserId;
	MsiString strProduct;
	MsiString strCurrentUser;

	// get current user sid based on the assignment type
	// we need this to skip our own registration when determining other clients of the installation
	if(!g_fWin9X)
	{
		switch(iaaAsgnType)
		{
			case iaaUserAssign:
			case iaaUserAssignNonManaged:
			{
				DWORD dwResult = GetCurrentUserStringSID(*&strCurrentUser);
				if (ERROR_SUCCESS != dwResult)
					return PostError(Imsg(idbgOpGetUserSID));
				break;
			}

			case iaaMachineAssign:
				strCurrentUser = szLocalSystemSID;
				break;
		}
	}


	CEnumUsers cUsers(cetET);

	// set inital state to absent (everything to be removed)
	bool fCanRemoveFiles = true; //files
	bool fCanRemoveHKCR  = true; //hkcr registry data
	bool fCanRemoveOther = true; //other installation entities

	while((cUsers.Next(*&strUserId) == ERROR_SUCCESS))
    {
		CEnumComponentClients cClients(*strUserId, *strComponentId);
		while(cClients.Next(*&strProduct) == ERROR_SUCCESS)
		{
			if(!MsiString(GetProductKey()).Compare(iscExactI, strProduct))// not us 
			{
				// is this client in the same location
				INSTALLSTATE iAlienClientState;
				MsiString strAlienFile;
				PMsiRecord pRec(0);

				if ((piErrRec = GetComponentPath(m_riServices, strUserId, *strProduct, *strComponentId, *&pRec, 0)) != 0)
					return piErrRec;

				if((INSTALLSTATE)pRec->GetInteger(icmlcrINSTALLSTATE_Static) == INSTALLSTATE_NOTUSED)
					continue; // this client has installed this component as disabled, hence does not count

				iAlienClientState = (INSTALLSTATE)pRec->GetInteger(icmlcrINSTALLSTATE);
				strAlienFile = pRec->GetMsiString(icmlcrFile);



				if(!fLocalNonFusionPath ||
					(((iAlienClientState == INSTALLSTATE_LOCAL)  || (iAlienClientState == INSTALLSTATE_ABSENT)) && (strAlienFile.TextSize()) && (MsiString(strAlienFile.Extract(iseUpto, TEXT(':'))) == iMsiStringBadInteger) && strAlienFile.Compare(iscExactI, strFile)))
				{
					// non-file path, OR path matches to same location
					DEBUGMSG1(TEXT("Disallowing uninstallation of component: %s since another client exists"), strComponentId);
					// does the other client have a different assignment type than this product
					// then, we might still need to clean up the app. HKCR hive if on Win2k or greater
					// unless the component is marked as permanent
					if(g_fWin9X || fFalse == IsDarwinDescriptorSupported(iddOLE) || IsSystemClient(*strProduct) || strUserId.Compare(iscExact, strCurrentUser))
					{
						// < Win9x or NT4 or permanent component or this client is of the same assignment type
						// nothing gets removed
						fCanRemoveFiles = false;
						fCanRemoveHKCR  = false;
						fCanRemoveOther = false;
					}
					else
					{
						// >= Win2k and assignment types dont match
						// could still remove the hkcr data, if not already decided not to
						fCanRemoveFiles = false;
						fCanRemoveOther = false;
					}
				}
				else
				{
					// local path, but locations don't match
					if(g_fWin9X || fFalse == IsDarwinDescriptorSupported(iddOLE) || strUserId.Compare(iscExact, strCurrentUser))
					{
						// < Win9x or NT4 or this client is of the same assignment type
						// could still remove the files, if not already decided not to
						fCanRemoveHKCR  = false;
						fCanRemoveOther = false;
					}
					else
					{
						// >= Win2k and assignment types dont match
						// could still remove the files and hkcr, if not already decided not to
						fCanRemoveOther = false;
					}
				}
			}
		}
    }

	// translate the decision regarding the files, hkcr data and other installation entities into action states
	if(riisAction == iisAbsent)
	{
		if(!fCanRemoveFiles && !fCanRemoveHKCR && !fCanRemoveOther)
			riisAction = (iisEnum)iMsiNullInteger;
		else if(fCanRemoveFiles && !fCanRemoveHKCR && !fCanRemoveOther)
			riisAction = iisFileAbsent;
		else if(fCanRemoveFiles && fCanRemoveHKCR && !fCanRemoveOther)
			riisAction = iisHKCRFileAbsent;
		else if(!fCanRemoveFiles && fCanRemoveHKCR && !fCanRemoveOther)
			riisAction = iisHKCRAbsent;
		else
			Assert(fCanRemoveFiles && fCanRemoveHKCR && fCanRemoveOther);
	}
	else
	{
		Assert(riisAction == iisSource);
		// we shouldn't allow the state to be source if the files need to stay around
		if(!fCanRemoveFiles)
			riisAction = (iisEnum)iMsiNullInteger;
	}



    if((riisAction != iMsiNullInteger) && fLocalNonFusionPath) // we are still planning to remove the component/files AND (client state local AND key path is file)
    {
		// check the Shared DLL refcount
		return CheckLegacyAppsForSharedUninstalls(*strComponentId, riisAction, riComponentPathRec);
    }
    return 0;
}

// FN: GetSharedDLLCountForMsiRegistrations
// iterates through the registrations for all users for the component riComponentId
// that is installed to the same location as riKeyFullPath and are marked as being refcounted
// in the Shared Dll registry and returns the count of the same
IMsiRecord* GetSharedDLLCountForMsiRegistrations(IMsiServices& riServices, const IMsiString& riComponentId, const IMsiString& riKeyFullPath, int& riMsiDllCount)
{
	CEnumUsers cUsers(cetAll);// enumerate though the component registration of all users
	MsiString strUserId;
	MsiString strProduct;


	riMsiDllCount = 0;

    while(cUsers.Next(*&strUserId) == ERROR_SUCCESS)
    {
		CEnumComponentClients cClients(*strUserId, riComponentId);
		while(cClients.Next(*&strProduct) == ERROR_SUCCESS)
		{
			INSTALLSTATE iAlienClientState;
			MsiString strAlienFile;
			PMsiRecord pRec(0);

			IMsiRecord* piErrRec = 0;
			if ((piErrRec = GetComponentPath(riServices, strUserId, *strProduct, riComponentId, *&pRec, 0)) != 0)
				return piErrRec;

			if((INSTALLSTATE)pRec->GetInteger(icmlcrINSTALLSTATE_Static) == INSTALLSTATE_NOTUSED)
				continue; // this client has installed this component as disabled, hence does not count

			iAlienClientState = (INSTALLSTATE)pRec->GetInteger(icmlcrINSTALLSTATE);
			strAlienFile = pRec->GetMsiString(icmlcrFile);

			// is this client installed local
			if(((iAlienClientState == INSTALLSTATE_LOCAL)  || (iAlienClientState == INSTALLSTATE_ABSENT)) && (strAlienFile.TextSize()) && (MsiString(strAlienFile.Extract(iseUpto, TEXT(':'))) == iMsiStringBadInteger))
			{
				// is it in the same location and is it refcounted
				if((strAlienFile.Compare(iscExactI, riKeyFullPath.GetString())) && (pRec->GetInteger(icmlcrSharedDllCount) == fTrue))
					riMsiDllCount++;
			}
		}
	}
	return 0;
}

IMsiRecord* CMsiEngine::CheckLegacyAppsForSharedUninstalls(const IMsiString& riComponentId, iisEnum& riisAction, const IMsiRecord& riComponentPathRec)
{
	// check the Shared Dll count for sharing with legacy apps
	// for components that are not installed in the system folder
	//    we simply check the  ref count of the key file
	// else
	//    we check the ref count of all the files in the component

	//NOTE: the riisAction variable is selectively modified AND is expected to be set to the default by the callee
	//NOTE: we assume that the m_piComponentCursor is set to the required component key
	//NOTE: we assume that the riComponentPathRec is a valid record returned by GetComponentPath

	MsiString strKeyFullPath = riComponentPathRec.GetMsiString(icmlcrFile);

	// check the registry for shared dll count
	MsiString strCount;

	Assert(m_piComponentCursor);

	const int iAttrib = m_piComponentCursor->GetInteger(m_colComponentAttributes);
	const ibtBinaryType iType = 
		(iAttrib & msidbComponentAttributes64bit) == msidbComponentAttributes64bit ? ibt64bit : ibt32bit;

	// check the key file for all components
	IMsiRecord* piErrRec = GetSharedDLLCount(m_riServices, strKeyFullPath, iType, *&strCount);
	if (piErrRec)
		return piErrRec;
	strCount.Remove(iseFirst, 1);
	// get the shared dll count that is attributable to msi registration
	int iMsiDllCount = 0;
	piErrRec = GetSharedDLLCountForMsiRegistrations(m_riServices, riComponentId, *strKeyFullPath, iMsiDllCount);
	if (piErrRec)
		return piErrRec;
	if((strCount != iMsiStringBadInteger) && (strCount > iMsiDllCount))
	{
		riisAction = (iisEnum)iMsiNullInteger; // externally shared dll
		return 0;
	}

	MsiString strOldKeyPath = riComponentPathRec.GetMsiString(icmlcrRawFile);

	bool fAssembly = FALSE;
	if(	*(const ICHAR* )strOldKeyPath == chTokenFusionComponent || 
		*(const ICHAR* )strOldKeyPath == chTokenWin32Component)
	{
		fAssembly = TRUE;
	}

	// If the keyfile is protected by SFP, always treat as permanent

	AssertSz(!(!g_fWin9X && g_iMajorVersion >= 5) || g_MessageContext.m_hSfcHandle,
				g_szNoSFCMessage);
	
	if (!fAssembly)
	{
		BOOL fProtected = fFalse;
		if ( g_MessageContext.m_hSfcHandle )
			fProtected = SFC::SfcIsFileProtected(g_MessageContext.m_hSfcHandle, CConvertString(strKeyFullPath));
		if (fProtected)
		{
			DEBUGMSG2(TEXT("Disallowing uninstallation of component: %s since key file %s is under SFP"), riComponentId.GetString(), strKeyFullPath);
			riisAction = (iisEnum)iMsiNullInteger;
			return 0;
		}
	}

	// app compat fix 350947
	// fix for component TTSData.A95D6CE6_C572_42AA_AA7B_BA92AFE9EA24 
	// from the merge module Sp5TTInt.msm
	// this component has its key file Mary.sdf not SFP'd in Whistler
	// however a non-key file sam.sdf is SFP'd. Hence we would have ordinarily 
	// remove all registration for the component while leaving the SFP'd file
	// alone. However this busts the component.
	// hence we check the component id of the component and effectively treat it
	// as permanant on Whistler and above

	// app comat fix 368867
	// help files for SAPI product being removed on Whistler even though they are installed as part of the OS

	if(MinimumPlatformWindowsNT51() && 
		(riComponentId.Compare(iscExact, TTSData_A95D6CE6_C572_42AA_AA7B_BA92AFE9EA24) ||
		riComponentId.Compare(iscExact, SapiCplHelpEng_0880F209_45FA_42C5_92AE_5E620033E8EC) || 
		riComponentId.Compare(iscExact, SapiCplHelpJpn_0880F209_45FA_42C5_92AE_5E620033E8EC) || 
		riComponentId.Compare(iscExact, SapiCplHelpChs_0880F209_45FA_42C5_92AE_5E620033E8EC)))
	{
		DEBUGMSG1(TEXT("APPCOMPAT: Disallowing uninstallation of component: %s"), riComponentId.GetString());
		riisAction = (iisEnum)iMsiNullInteger;
		return 0;
	}

	// if we are installed in the systems folder we check the reg key count for all files

	// is this the system folder
	// First we do a quick check
	MsiString strSystemFolder = GetPropertyFromSz(IPROPNAME_SYSTEM_FOLDER);
	if(!strKeyFullPath.Compare(iscStartI, strSystemFolder))
		return 0;
	MsiString strSystem64Folder;
	if ( g_fWinNT64 )
	{
		strSystem64Folder = GetPropertyFromSz(IPROPNAME_SYSTEM64_FOLDER);
		if ( !strKeyFullPath.Compare(iscStartI, strSystem64Folder) )
			return 0;
	}

	PMsiPath pPath(0);
	MsiString strComponentDir = m_piComponentCursor->GetString(m_colComponentDir);
	if ((piErrRec = GetTargetPath(*strComponentDir, *&pPath)) != 0)
		return piErrRec;

	MsiString strPath = pPath->GetPath();
	if(!strPath.Compare(iscExactI, strSystemFolder)
		|| (g_fWinNT64 && !strPath.Compare(iscExactI, strSystem64Folder)) )
		return 0;

	PMsiTable pFileTable(0);
	if ((piErrRec = LoadFileTable(3,*&pFileTable)) != 0)
	{
		if (piErrRec->GetInteger(1) == idbgDbTableUndefined)
		{
			piErrRec->Release();
			return 0;
		}
		else
			return piErrRec;
	}


	PMsiCursor pFileCursor(pFileTable->CreateCursor(fFalse));
	Bool fLFN = ((GetMode() & iefSuppressLFN) == 0 && pPath->SupportsLFN()) ? fTrue : fFalse;

	int iColComponent = m_mpeftCol[ieftComponent];
	int iColFileName  = m_mpeftCol[ieftName];

	MsiStringId idComponent    = m_piComponentCursor->GetInteger(m_colComponentKey);

	pFileCursor->SetFilter(iColumnBit(iColComponent));
	pFileCursor->PutInteger(iColComponent, idComponent);
	while(pFileCursor->Next())
	{
		MsiString strFileName;
		MsiString strFullFilePath;

		if ((piErrRec = m_riServices.ExtractFileName(MsiString(pFileCursor->GetString(iColFileName)),fLFN,*&strFileName)) != 0)
			return piErrRec;
		if ((piErrRec = pPath->GetFullFilePath(strFileName, *&strFullFilePath)) != 0)
			return piErrRec;
		if ((piErrRec = GetSharedDLLCount(m_riServices, strFullFilePath, iType, *&strCount)) != 0)
			return piErrRec;
		strCount.Remove(iseFirst, 1);
		if((strCount != iMsiStringBadInteger) && (strCount > iMsiDllCount))
		{
			riisAction = (iisEnum)iMsiNullInteger; // externally shared dll
			break;
		}
	}
	return 0;
}


IMsiRecord* CMsiEngine::CheckNeverOverwriteForRegKeypath(const MsiStringId idComponentString, iisEnum& riisAction)
{
	MsiString strComponent(m_piDatabase->DecodeString(idComponentString));
	IMsiRecord* piErrRec = 0;

	// check if the key path exists
	PMsiView pView(0);
	static const ICHAR* szKeyRegistrySQL    =   TEXT(" SELECT `Root`,`Key`,`Name`,`Value`")
												TEXT(" FROM `Registry`,`Component`")
												TEXT(" WHERE `Registry`.`Registry` = `Component`.`KeyPath` AND `Component`.`Component` = ?");

	PMsiRecord pRec = &m_riServices.CreateRecord(1);
	pRec->SetMsiString(1, *strComponent);
	if((piErrRec = OpenView(szKeyRegistrySQL, ivcFetch, *&pView)) != 0)
		return piErrRec;
	if((piErrRec = pView->Execute(pRec)) != 0)
		return piErrRec;
	pRec = pView->Fetch();
	if(!pRec)
	{
#if DEBUG
		ICHAR szError[256];
		wsprintf(szError, TEXT("Error registering component %s. Possible cause: Component.KeyPath may not be valid"), *strComponent);
		AssertSz(0, szError);
#endif
		return PostError(Imsg(idbgBadComponent),(const ICHAR*)strComponent);
	}

	enum {
		irrRoot=1,
		irrKey,
		irrName,
		irrValue
	};

	rrkEnum rrkCurrentRootKey;
	MsiString strSubKey;
	Bool fAllUsers = MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? fTrue : fFalse;
	switch(pRec->GetInteger(irrRoot))
	{
	case 0:
		if(fAllUsers || IsDarwinDescriptorSupported(iddOLE) == fFalse)
		{
			rrkCurrentRootKey =  (rrkEnum)rrkLocalMachine;
			strSubKey = szClassInfoSubKey;
		}
		else
		{
			rrkCurrentRootKey =  (rrkEnum)rrkUsers;
			AssertNonZero(GetCurrentUserStringSID(*&strSubKey) == ERROR_SUCCESS);
			strSubKey += MsiString(TEXT("\\"));
			strSubKey += szClassInfoSubKey;
		}
		break;
	case 1:
		rrkCurrentRootKey =  (rrkEnum)rrkCurrentUser;
		break;
	case 2:
		rrkCurrentRootKey =  (rrkEnum)rrkLocalMachine;
		break;
	case 3:
		rrkCurrentRootKey =  (rrkEnum)rrkUsers;
		break;
	case -1:
		rrkCurrentRootKey =  (rrkEnum)rrkUserOrMachineRoot; // do HKLM or HKCU based on ALLUSERS
		break;
	default:
		rrkCurrentRootKey =  (rrkEnum)(pRec->GetInteger(irrRoot) + (int)rrkClassesRoot);
		break;
	}

	MsiString strKey = FormatText(*MsiString(pRec->GetMsiString(irrKey)));
	PMsiRegKey pRegKeyRoot = &m_riServices.GetRootKey(rrkCurrentRootKey);
	if(strSubKey)
		pRegKeyRoot = &(pRegKeyRoot->CreateChild(strSubKey));
	PMsiRegKey pRegKey = &(pRegKeyRoot->CreateChild(strKey));

	MsiString strName = FormatText(*MsiString(pRec->GetMsiString(irrName)));

	MsiString strValue = FormatText(*MsiString(pRec->GetMsiString(irrValue)));
	Bool fExists;

	extern const ICHAR* REGKEY_CREATE;
	extern const ICHAR* REGKEY_DELETE;
	extern const ICHAR* REGKEY_CREATEDELETE;

	if(strValue.TextSize() ||
		(!strName.Compare(iscExact, REGKEY_CREATE) && !strName.Compare(iscExact, REGKEY_CREATEDELETE) && !strName.Compare(iscExact, REGKEY_DELETE)))
	{
		// check that the key + name exists
		piErrRec = pRegKey->ValueExists(strName, fExists);
	}
	else
	{
		// check that the key exists
		piErrRec = pRegKey->Exists(fExists);
	}
	if(piErrRec)
		return piErrRec;
	if(fExists)
	{
		riisAction = (iisEnum)iMsiNullInteger; // disallow installation, "dont stomp" component
		DEBUGMSG1(TEXT("Disallowing installation of component: %s since the registry keypath exists and the component is marked to never overwrite existing installations"), strComponent);
	}
	return 0;

}

IMsiRecord* CMsiEngine::GetAssemblyInfo(const IMsiString& rstrComponent, iatAssemblyType& riatAssemblyType, const IMsiString** ppistrAssemblyName, const IMsiString** ppistrManifestFileKey)
{
	static const ICHAR* szFusionComponentSQL =  TEXT(" SELECT `MsiAssembly`.`Attributes`, `MsiAssembly`.`File_Application`, `MsiAssembly`.`File_Manifest`,  `Component`.`KeyPath` FROM `MsiAssembly`, `Component` WHERE  `MsiAssembly`.`Component_` = `Component`.`Component` AND `MsiAssembly`.`Component_` = ?");

	riatAssemblyType = iatNone; // initialize to none

	if((GetMode() & iefAdmin) || !m_fAssemblyTableExists)
		return 0;// doing admin install OR no assembly table, return

	IMsiRecord* piError = 0;
	if(!m_pViewFusion)
	{
		piError = OpenView(szFusionComponentSQL, ivcFetch, *&m_pViewFusion);
		if(piError)
		{
			if(piError->GetInteger(1) == idbgDbQueryUnknownTable) // okay to not have the Assembly table
			{
				piError->Release();
				m_fAssemblyTableExists = false;
				return 0;
			}
			// else error
			return piError;
		}
	}
	PMsiRecord pParam = &m_riServices.CreateRecord(1);
	pParam->SetMsiString(1, rstrComponent);
	piError = m_pViewFusion->Execute(pParam);
	if(piError)
		return piError;

	PMsiRecord pRec = m_pViewFusion->Fetch();
	if(pRec)
	{
		// the component is an assembly, check which type
		enum {
			atAttributes = 1,
			atAppCtx,
			atManifest,
			atKeyFile,
		};
		if((pRec->GetInteger(atAttributes) & msidbAssemblyAttributesWin32) == msidbAssemblyAttributesWin32)
		{
			// if system does not SXS, ignore Win32 assemblies
			if(!MsiString(GetPropertyFromSz(IPROPNAME_WIN32ASSEMBLYSUPPORT)).TextSize())
				return 0;

			if(pRec->IsNull(atAppCtx))
				riatAssemblyType = iatWin32Assembly;
			else
				riatAssemblyType = iatWin32AssemblyPvt;
		}
		else
		{
			if(pRec->IsNull(atAppCtx))
				riatAssemblyType = iatURTAssembly;
			else
				riatAssemblyType = iatURTAssemblyPvt;

		}
		// get the assembly name
		if(ppistrAssemblyName)
		{
			piError = GetAssemblyNameSz(rstrComponent, riatAssemblyType, false, *ppistrAssemblyName);
			if(piError)
				return piError;
		}
		// get the mainfest file key
		if(ppistrManifestFileKey)
		{
			MsiString strManifest = pRec->GetMsiString(atManifest);
			if(!strManifest.TextSize()) // use the key file as the manifest
				strManifest = pRec->GetMsiString(atKeyFile);
			strManifest.ReturnArg(*ppistrManifestFileKey);
		}

	}
	return 0;
}


IMsiRecord* CMsiEngine::GetAssemblyNameSz(const IMsiString& rstrComponent, iatAssemblyType /*iatAT*/, bool fOldPatchAssembly, const IMsiString*& rpistrAssemblyName)
{
	static const ICHAR* szAssemblyNameNameSQL         = TEXT(" SELECT `Value` FROM `MsiAssemblyName` WHERE `Component_` = ? AND (`Name` = 'Name' OR `Name` = 'NAME' OR `Name` = 'name')");
	static const ICHAR* szAssemblyNameSQL             = TEXT(" SELECT `Name`, `Value` FROM `MsiAssemblyName` WHERE `Component_` = ? AND (`Name` <> 'Name' AND `Name` <> 'NAME' AND `Name` <> 'name')");

	static const ICHAR* szPatchOldAssemblyNameNameSQL = TEXT(" SELECT `Value` FROM `MsiPatchOldAssemblyName` WHERE `Assembly` = ? AND (`Name` = 'Name' OR `Name` = 'NAME' OR `Name` = 'name')");
	static const ICHAR* szPatchOldAssemblyNameSQL     = TEXT(" SELECT `Name`, `Value` FROM `MsiPatchOldAssemblyName` WHERE `Assembly` = ? AND (`Name` <> 'Name' AND `Name` <> 'NAME' AND `Name` <> 'name')");

	MsiString strName;
	IMsiRecord* piError = 0;

	IMsiView* piViewAssemblyNameName = 0;
	IMsiView* piViewAssemblyName     = 0;

	if(false == fOldPatchAssembly)
	{
		if(!m_pViewFusionNameName)
		{
			piError = OpenView(szAssemblyNameNameSQL, ivcFetch, *&m_pViewFusionNameName);
			if(piError)
				return piError;
		}

		piViewAssemblyNameName = m_pViewFusionNameName;
	}
	else
	{
		if(!m_pViewOldPatchFusionNameName)
		{
			piError = OpenView(szPatchOldAssemblyNameNameSQL, ivcFetch, *&m_pViewOldPatchFusionNameName);
			if(piError)
				return piError;
		}

		piViewAssemblyNameName = m_pViewOldPatchFusionNameName;
	}

	PMsiRecord pParam = &m_riServices.CreateRecord(1);
	pParam->SetMsiString(1, rstrComponent);
	piError = piViewAssemblyNameName->Execute(pParam);
	if(piError)
		return piError;
	PMsiRecord pRec = piViewAssemblyNameName->Fetch();
	if(!pRec)
	{
		//authoring error
		return PostError(Imsg(idbgBadAssemblyName),rstrComponent); //!! change error for oldpatch case
	}
	strName = pRec->GetString(1);

	// now get the rest of the name
	// first get the name part of the assembly name

	if(false == fOldPatchAssembly)
	{
		if(!m_pViewFusionName)
		{
			piError = OpenView(szAssemblyNameSQL, ivcFetch, *&m_pViewFusionName);
			if(piError)
				return piError;
		}

		piViewAssemblyName = m_pViewFusionName;
	}
	else
	{
		if(!m_pViewOldPatchFusionName)
		{
			piError = OpenView(szPatchOldAssemblyNameSQL, ivcFetch, *&m_pViewOldPatchFusionName);
			if(piError)
				return piError;
		}

		piViewAssemblyName = m_pViewOldPatchFusionName;
	}

	piError = piViewAssemblyName->Execute(pParam);
	if(piError)
		return piError;

	while(pRec = piViewAssemblyName->Fetch())
	{
		// construct [,name="value"] pairs
		strName	+= MsiString(MsiChar(','));
		strName	+= MsiString(pRec->GetString(1));
		strName	+= MsiString(MsiChar('='));
		strName	+= MsiString(MsiChar('\"'));
		strName	+= MsiString(pRec->GetString(2));
		strName	+= MsiString(MsiChar('\"'));
	}
	strName.ReturnArg(rpistrAssemblyName);
	return 0;
}


IMsiRecord* CMsiEngine::DoStateTransitionForSharedInstalls(const MsiStringId idComponentString, iisEnum& riisAction)
{
	Assert(riisAction == iisLocal); // expected to be called for local installs only
#ifdef DEBUG
	{
		MsiString strComponentTemp(m_piDatabase->DecodeString(idComponentString));
		ICHAR rgchComponent[256];
		strComponentTemp.CopyToBuf(rgchComponent,255);
	}
#endif
	
	if (!m_piComponentTable)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	IMsiRecord* piErrRec = 0;
	PMsiCursor pCursor(m_piComponentTable->CreateCursor(fFalse));
	pCursor->SetFilter(1);
	pCursor->PutInteger(m_colComponentKey,idComponentString);
	if(!pCursor->Next())
		return PostError(Imsg(idbgBadComponent),*MsiString(m_piDatabase->DecodeString(idComponentString)));

	int icaAttributes = pCursor->GetInteger(m_colComponentAttributes);
	// first check if the key path is a file
	MsiStringId idFileKey = pCursor->GetInteger(m_colComponentKeyPath);
	if(idFileKey == iTableNullString || (icaAttributes & icaODBCDataSource)) // not file or Regkey
		return 0;

	if(icaAttributes & icaRegistryKeyPath)
	{
		// if the component is marked with the "dont stomp" attribute, we should disallow the installation
		if(icaAttributes & icaNeverOverwrite)
			return CheckNeverOverwriteForRegKeypath(idComponentString, riisAction);
		return 0;
	}

    // do we have a fusion component  
    iatAssemblyType iatAT;
    MsiString strComponent = m_piDatabase->DecodeString(idComponentString);
    MsiString strComponentId = pCursor->GetString(m_colComponentID);

	MsiString strAssemblyName;
	piErrRec = GetAssemblyInfo(*strComponent, iatAT, &strAssemblyName, 0);
	if (piErrRec)
		return piErrRec;

	if(iatAT == iatURTAssembly || iatAT == iatWin32Assembly)
	{
		// if we have been asked to force reinstall simply return
		if(GetMode() & iefOverwriteAllFiles)
			return 0; // allow the reinstall

		// check the health of the installation, if any on the machine
		HRESULT hr;
		PAssemblyCache pCache(0);
		if(iatAT == iatURTAssembly)
			hr = FUSION::CreateAssemblyCache(&pCache, 0);
		else
		{
			Assert(iatAT == iatWin32Assembly);
			hr = SXS::CreateAssemblyCache(&pCache, 0);
		}
		if(!SUCCEEDED(hr))
		{
			if(iatAT == iatURTAssembly) // if cannot find fusion, assume we are bootstrapping, hence assume no assembly installed
			{
				PMsiRecord(PostAssemblyError(strComponentId, hr, TEXT(""), TEXT("CreateAssemblyCache"), strAssemblyName, iatAT)); // log error
				DEBUGMSG(TEXT("ignoring fusion interface error, assuming we are bootstrapping"));
				return 0;
			}
			else
				return PostAssemblyError(strComponentId, hr, TEXT(""), TEXT("CreateAssemblyCache"), strAssemblyName, iatAT);
		}


		LPCOLESTR szAssemblyName;
#ifndef UNICODE
		CTempBuffer<WCHAR, 1024>  rgchAssemblyNameUNICODE;
		ConvertMultiSzToWideChar(*strAssemblyName, rgchAssemblyNameUNICODE);
		szAssemblyName = rgchAssemblyNameUNICODE;
#else
		szAssemblyName = strAssemblyName;
#endif
		//pass the right flags in
		DWORD dwFlags = GetMode() & iefOverwriteCorruptedFiles ? QUERYASMINFO_FLAG_VALIDATE : 0;

	    hr = pCache->QueryAssemblyInfo(dwFlags, szAssemblyName, NULL);

		//if okay or simply not refcounted via darwin then dont reinstall
		if(SUCCEEDED(hr)) // the flags we pass match the state of the assembly
		{
			riisAction = (iisEnum)iMsiNullInteger; // already installed
			DEBUGMSG1(TEXT("skipping installation of assembly component: %s since the assembly already exists"), strComponentId);
		}
		return 0;
	}

    // we have a file as the key path

	if(pCursor->GetInteger(m_colComponentLegacyFileExisted) != iMsiNullInteger)
	{
		// reset the legacyfileexisted column
		pCursor->PutNull(m_colComponentLegacyFileExisted);
		pCursor->Update();
	}

	GetSharedEngineCMsiFile(pobjFile, *this);
	piErrRec = pobjFile->FetchFile(*MsiString(m_piDatabase->DecodeString(idFileKey)));
	if (piErrRec)
		return piErrRec;

	PMsiRecord pFileInfoRec(pobjFile->GetFileRecord());

	if(!pFileInfoRec)
		 return PostError(Imsg(idbgBadFile),(const ICHAR*)MsiString(m_piDatabase->DecodeString(idFileKey)));


	PMsiPath pPath(0);
	MsiString strFileName;
	piErrRec = GetTargetPath(*MsiString(pFileInfoRec->GetMsiString(CMsiFile::ifqDirectory)),*&pPath);
	if (piErrRec)
		return piErrRec;

	Bool fLFN = ((GetMode() & iefSuppressLFN) == 0 && pPath->SupportsLFN()) ? fTrue : fFalse;
	if ((piErrRec = m_riServices.ExtractFileName(MsiString(pFileInfoRec->GetString(CMsiFile::ifqFileName)),fLFN,*&strFileName)))
		return piErrRec;

	// put back in pFileRec
	AssertNonZero(pFileInfoRec->SetMsiString(CMsiFile::ifqFileName,*strFileName));

	// check if the file exists
	Bool fExists;
	if ((piErrRec = pPath->FileExists(strFileName, fExists)) != 0)
		return piErrRec;

	if(!fExists)
		return 0;

	// if the component is marked with the "dont stomp" attribute, we should disallow the installation
	int iRuntimeFlags = pCursor->GetInteger(m_colComponentRuntimeFlags);
	if ((icaAttributes & icaNeverOverwrite) || (iRuntimeFlags & bfComponentNeverOverwrite))  // authored flag or internally generated flag
	{
		riisAction = (iisEnum)iMsiNullInteger; // disallow installation, "dont stomp" component
		DEBUGMSG1(TEXT("Disallowing installation of component: %s since the keyfile exists and the component is marked to never overwrite existing installations"), strComponentId);
	}
	else
	{
		// prevent installation of possibly older component

		// OR in iefOverwriteEqualVersions flag temporarily so that we allow for -
		// 1. Installing a component where the version of the key file
		//    has remained the same but an auxiliary file has been updated
		// 2. Turning on the component, if not file reinstall is selected
		//    but other reinstalls have been.

		MsiString strFullPath;
		if ((piErrRec = pPath->GetFullFilePath(strFileName, *&strFullPath)) != 0)
			return piErrRec;
		
		// If keyfile is protected, the component should be disabled if existing protected
		// file is same version as the keyfile.
		AssertSz(!(!g_fWin9X && g_iMajorVersion >= 5) || g_MessageContext.m_hSfcHandle,
					g_szNoSFCMessage);
		BOOL fProtected = fFalse;
		if ( g_MessageContext.m_hSfcHandle )
			fProtected = SFC::SfcIsFileProtected(g_MessageContext.m_hSfcHandle, CConvertString(strFullPath));
		bool fExistingMode = (fProtected || (GetMode() & iefOverwriteEqualVersions)) ? true:false;
		if(!fExistingMode)
			SetMode(iefOverwriteEqualVersions, fTrue);
		ifsEnum ifsState;
		int fBitVersioning = 0;
		piErrRec = ENG::GetFileInstallState(*this,*pFileInfoRec,0,0,0,&ifsState,
														/* fIgnoreCompanionParentAction=*/ true,
														/* fIncludeHashCheck=*/ false, &fBitVersioning);
		if(!fExistingMode)
			SetMode(iefOverwriteEqualVersions, fFalse);
		if (piErrRec)
			return piErrRec;
		if(!pFileInfoRec->GetInteger(CMsiFile::ifqState))
		{
			iisEnum iisOrigAction = riisAction;
			riisAction = (iisEnum)iMsiNullInteger; // disallow installation, "lesser" component
			if (fProtected && ifsState == ifsExistingEqualVersion)
				DEBUGMSG1(TEXT("Disallowing installation of component: %s since an equal version of its keyfile exists, and is protected by Windows"), strComponentId);
			else if (!(fBitVersioning & ifBitExistingModified))
				DEBUGMSG1(TEXT("Disallowing installation of component: %s since the same component with higher versioned keyfile exists"), strComponentId);
			else
			{
				// per bug 146316 (10630), we do not disable a component if the keypath is an unversioned file and the version on the machine is modified
				DEBUGMSG1(TEXT("Allowing installation of component: %s even though a modified unversioned keyfile exists and file versioning rules would disable the component"), strComponentId);
				riisAction = iisOrigAction;
			}
		}
	}

	MsiString strFullFilePath;
	if ((piErrRec = pPath->GetFullFilePath(strFileName, *&strFullFilePath)) != 0)
		return piErrRec;

	bool fDarwinInstalledComponentExists = false;

	// what type of an install are we attempting
	Bool fAllUsers = MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? fTrue : fFalse;
	iaaAppAssignment iaaAsgnType = fAllUsers ? iaaMachineAssign : iaaUserAssign;

	CClientEnumToken ctokProductIndex;
	MsiString strProduct;
	MsiString strUserId;

	// enumerate through all the clients of the component
	CEnumUsers cUsers(cetAll);
	while(cUsers.Next(*&strUserId) == ERROR_SUCCESS)
	{
		CEnumComponentClients cClients(*strUserId, *strComponentId);
		while(cClients.Next(*&strProduct) == ERROR_SUCCESS)
		{
			INSTALLSTATE iAlienClientState;
			MsiString strAlienFile;
			PMsiRecord pRec(0);

			// get the client state for the product

			if ((piErrRec = GetComponentPath(m_riServices, strUserId, *strProduct, *strComponentId, *&pRec, 0)) != 0)
				return piErrRec;

			iAlienClientState = (INSTALLSTATE)pRec->GetInteger(icmlcrINSTALLSTATE);
			strAlienFile = pRec->GetMsiString(icmlcrFile);

			// making sure the client is local and not registry path
			if((iAlienClientState == INSTALLSTATE_LOCAL) && (strAlienFile.TextSize()) && (MsiString(strAlienFile.Extract(iseUpto, TEXT(':'))) == iMsiStringBadInteger))
			{
				// is this client in the same location

				// is the file path the same
				//!! we can assume that because of the VolumePref, we can get away with
				// a string compare. However this will not work when the other product
				// installs with a LFN preference different from ours.
				if(strFullFilePath.Compare(iscExactI, strAlienFile))
				{
					fDarwinInstalledComponentExists = true;
					break;
				}
			}
		}
	}

	if(!fDarwinInstalledComponentExists)
	{
		// if the key file exists on the machine w/o having been installed via darwin - legacy apps
		pCursor->PutInteger(m_colComponentLegacyFileExisted, 1);
		pCursor->Update();
	}
	return 0;
}

IMsiRecord*     CMsiEngine::LoadFileTable(int cAddColumns, IMsiTable*& pFileTable)
{
	IMsiRecord* piRec = 0;

	// First try to load the table
	if ((piRec = m_piDatabase->LoadTable(*MsiString(*sztblFile),cAddColumns,pFileTable)) != 0)
		return piRec;

	// Next see if the column indexes are set
	if (m_mpeftCol[0] == 0)
	{
		int i;
		for (i = 0 ; i < ieftMax ; i++)
			m_mpeftCol[i] = pFileTable->GetColumnIndex(m_piDatabase->EncodeStringSz(mpeftSz[i]));
	}

	return 0;

}

IMsiRecord* CMsiEngine::UpdateComponentActionStates(const MsiStringId idComponent, iisEnum iisAction, iisEnum iActionRequestState, bool fComponentEnabled)
/*----------------------------------------------------------------------------
Internal Engine function which walks the Component table tree that includes the
specified component and all its children, updating the iisAction state of each
component record.  If Null is passed for pistrComponent, the entire component
tree will be updated.

Returns: False if an invalid condition was requested for the component, or if
the component is not found in the Component Table.
------------------------------------------------------------------------------*/
{
	if (!m_piComponentTable)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pCursor(m_piComponentTable->CreateCursor(fTrue));

	// Set up the tree-walking cursor for all pistrComponent's children
	pCursor->SetFilter(1);
	pCursor->PutInteger(m_colComponentKey,idComponent);
	if (pCursor->Next() != 1)
		return PostError(Imsg(idbgBadComponent),*MsiString(m_piDatabase->DecodeString(idComponent)));
	pCursor->SetFilter(0);

	do
	{
#ifdef DEBUG
		MsiString strComponentTemp(pCursor->GetString(m_colComponentKey));
		ICHAR rgchComponent[256];
		strComponentTemp.CopyToBuf(rgchComponent,255);
#endif
		// Keep track of old action state for use in dynamic cost updating below
		iisEnum iisOldAction = (iisEnum) pCursor->GetInteger(m_colComponentAction);

		// All components must track the parent's UseSource status
		AssertNonZero(pCursor->PutInteger(m_colComponentAction, iisAction));
		AssertNonZero(pCursor->PutInteger(m_colComponentActionRequest, iActionRequestState));

		// we may be switching the component enable bit for transitive components reinstall
		int iRuntimeFlags = pCursor->GetInteger(m_colComponentRuntimeFlags);
		if (fComponentEnabled)
			iRuntimeFlags &= ~bfComponentDisabled;
		else
			iRuntimeFlags |= bfComponentDisabled;

		AssertNonZero(pCursor->PutInteger(m_colComponentRuntimeFlags, iRuntimeFlags));
		AssertNonZero(pCursor->Update());

		// If the action state has changed, the dynamic costs attributed to
		// volumes in the VolumeCost table may need to be updated.
		if (m_fCostingComplete && iisAction != iisOldAction)
		{
			IMsiRecord* piErrRec;
			if ((piErrRec = RecostComponentActionChange(pCursor,iisOldAction)) != 0)
				return piErrRec;
		}
	}while (pCursor->Next() > 1);
	return 0;
}

IMsiTable* CMsiEngine::GetVolumeCostTable()
//---------------------------------------
{
	if (m_piVolumeCostTable)
		m_piVolumeCostTable->AddRef();
	return m_piVolumeCostTable;
}


IMsiRecord* CMsiEngine::InitializeDynamicCost(bool fReinitialize)
//-------------------------------------------
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	if (m_piVolumeCostTable && m_fCostingComplete)
	{
		// initialize volume cost to 0 for each volume
		PMsiDatabase pDatabase(GetDatabase());
		PMsiCursor pVolCursor = m_piVolumeCostTable->CreateCursor(fFalse);
		Assert (pVolCursor);
		int iColSelVolumeCost = m_piVolumeCostTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblVolumeCost_colVolumeCost));
		int iColSelNoRbVolumeCost = m_piVolumeCostTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblVolumeCost_colNoRbVolumeCost));
		Assert(iColSelVolumeCost > 0);
		Assert(iColSelNoRbVolumeCost > 0);
		while (pVolCursor->Next())
		{
			AssertNonZero(pVolCursor->PutInteger(iColSelVolumeCost,0));
			AssertNonZero(pVolCursor->PutInteger(iColSelNoRbVolumeCost,0));
			AssertNonZero(pVolCursor->Update());
		}
	}
	
	IMsiRecord* piErrRec = 0;
	SetCostingComplete(fFalse);
	SetPropertyInt(*MsiString(*IPROPNAME_OUTOFDISKSPACE),fFalse);
	SetPropertyInt(*MsiString(*IPROPNAME_OUTOFNORBDISKSPACE),fFalse);
	m_pCostingCursor = m_piComponentTable->CreateCursor(fFalse);
	m_fReinitializeComponentCost = fReinitialize;

	// Reset all cost adjusters
	if (m_piCostAdjusterTable)
	{
		PMsiCursor pCostCursor(m_piCostAdjusterTable->CreateCursor(fFalse));
		pCostCursor->Reset();
		while (pCostCursor->Next())
		{
			PMsiCostAdjuster pCostAdjuster = (IMsiCostAdjuster*) pCostCursor->GetMsiData(m_colCostAdjuster);
			if (pCostAdjuster)
			{
				if ((piErrRec = pCostAdjuster->Reset()) != 0)
					return piErrRec;
			}
		}
	}

	return 0;
}


bool CMsiEngine::IsBackgroundCostingEnabled()
//--------------------------------
{
	return (m_fCostingComplete == false) && (m_fForegroundCostingInProgress == false);
}


bool CMsiEngine::IsCostingComplete()
//--------------------------------
{
	return m_fCostingComplete;
}



void CMsiEngine::SetCostingComplete(bool fCostingComplete)
//---------------------------------
{
	m_fCostingComplete = fCostingComplete;
	SetPropertyInt(*MsiString(*IPROPNAME_COSTINGCOMPLETE),m_fCostingComplete);
}



IMsiRecord* CMsiEngine::RecostAllComponents(Bool& fCancel)
/*--------------------------------------------------------
Reinitializes and re-calculates the cost of all components
in the Component table.
--------------------------------------------------------*/
{
	using namespace ProgressData;
	int iScriptEvents;
	fCancel = fFalse;
	IMsiRecord* piErrRec = GetScriptCost(0, &iScriptEvents, fFalse, &fCancel);
	if (piErrRec)
		return piErrRec;

	if (fCancel)
		return 0;

	if (!m_pScriptProgressRec)
		m_pScriptProgressRec = &m_riServices.CreateRecord(ProgressData::imdNextEnum);

	AssertNonZero(m_pScriptProgressRec->SetInteger(imdSubclass, iscMasterReset));
	AssertNonZero(m_pScriptProgressRec->SetInteger(imdProgressTotal, iScriptEvents));
	AssertNonZero(m_pScriptProgressRec->SetInteger(imdDirection, ipdForward));
	AssertNonZero(m_pScriptProgressRec->SetInteger(imdEventType, ietScriptInProgress));
	if(Message(imtProgress, *m_pScriptProgressRec) == imsCancel)
	{
		fCancel = fTrue;
		return 0;
	}


	m_fForegroundCostingInProgress = true;
	if ((piErrRec = InitializeDynamicCost(/* fReinitialize = */ fTrue)) != 0)
	{
		m_fForegroundCostingInProgress = false;
		// If Selection mgr not active, there's simply no costing to do
		if (piErrRec->GetInteger(1) != idbgSelMgrNotInitialized)
			return piErrRec;
		else
		{
			piErrRec->Release();
			return 0;
		}
	}

	MsiString strNull;
	while (!m_fCostingComplete)
	{
		if ((piErrRec = CostOneComponent(*strNull)) != 0)
		{
			m_fForegroundCostingInProgress = false;
			return piErrRec;
		}

		AssertNonZero(m_pScriptProgressRec->SetInteger(imdSubclass, iscProgressReport));
		AssertNonZero(m_pScriptProgressRec->SetInteger(imdIncrement, iComponentCostWeight));
		if(Message(imtProgress, *m_pScriptProgressRec) == imsCancel)
		{
			m_fForegroundCostingInProgress = false;
			fCancel = fTrue;
			return 0;
		}
	}
	m_fForegroundCostingInProgress = false;
	return 0;

}

IMsiRecord* CMsiEngine::CostOneComponent(const IMsiString& riComponentString)
/*-------------------------------------------------------------------------
If riComponentString is a null string, and CostOneComponent has not
been called since the last call to InitializeDynamicCost, a call to
CostOneComponent will calculate the disk cost for the first component
in the Component table.  On subsequent calls (with riComponentString still
a null string), the next component in the table will be costed, and so on.
If riComponentString names a specific component, that component will be
costed (if it hasn't already been initialized).  If all components have
been initialized, any subsequent call to CostOneComponent will return
immmediately with no error.

Returns: error record if InitializeDynamicCost has never been called, or
if the specified component is not found in the Component table.
---------------------------------------------------------------------------*/

{
	if (m_fCostingComplete == fTrue)
		return 0;

	if (!m_pCostingCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	Bool fNamedComponent = fFalse;
	if (riComponentString.TextSize() > 0)
	{
		fNamedComponent = fTrue;
		m_pCostingCursor->Reset();
		m_pCostingCursor->SetFilter(1);
		m_pCostingCursor->PutString(m_colComponentKey,riComponentString);
	}

	Bool fFoundOne = fFalse;
	IMsiRecord* piErrRec = 0;
	while (fFoundOne == fFalse)
	{
		if (m_pCostingCursor->Next())
		{
			if (m_fReinitializeComponentCost || m_pCostingCursor->GetInteger(m_colComponentLocalCost) == iMsiNullInteger)
			{
				fFoundOne = fTrue;
				// Initialize dynamic cost to 0 for each component
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentLocalCost,0));
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentSourceCost,0));
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentRemoveCost,0));
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentARPLocalCost,0));
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentNoRbLocalCost,0));
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentNoRbRemoveCost,0));
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentNoRbSourceCost,0));
				AssertNonZero(m_pCostingCursor->PutInteger(m_colComponentNoRbARPLocalCost,0));
				AssertNonZero(m_pCostingCursor->Update());

				if ((piErrRec = RecostComponentDirectoryChange(m_pCostingCursor,0, /*fCostLinked = */false)) != 0)
					return piErrRec;
			}

			if (fNamedComponent)
			{
				m_pCostingCursor->Reset();
				m_pCostingCursor->SetFilter(0);
			}

		}
		else
		{
			if (fNamedComponent)
				return PostError(Imsg(idbgBadComponent), riComponentString.GetString());
			else
			{
				ResetEngineCosts();
				SetCostingComplete(fTrue);
				
				if ((piErrRec = DetermineEngineCostOODS()) != 0)
					return piErrRec;

				return 0;
			}
		}
	}
	return 0;
}



IMsiRecord* CMsiEngine::RegisterFeatureCostLinkedComponent(const IMsiString& riFeatureString,
													const IMsiString& riComponentString)
/*---------------------------------------------------------------------
Registers a component that must be recosted when a specified feature's
action state changes.
-----------------------------------------------------------------------*/
{
	if (m_piFeatureCostLinkTable == 0)
	{
		const int iInitialRows = 2;
		IMsiRecord* piErrRec = m_piDatabase->CreateTable(*MsiString(*sztblFeatureCostLink),iInitialRows,
			m_piFeatureCostLinkTable);
		if (piErrRec)
			return piErrRec;

		AssertNonZero(m_colFeatureCostLinkFeature = m_piFeatureCostLinkTable->CreateColumn(icdString + icdPrimaryKey,
			*MsiString(*sztblFeatureCostLink_colFeature)));
		AssertNonZero(m_colFeatureCostLinkComponent = m_piFeatureCostLinkTable->CreateColumn(icdString + icdPrimaryKey,
			*MsiString(*sztblFeatureCostLink_colComponent)));
	}

	PMsiCursor pCursor(0);
	AssertNonZero(pCursor = m_piFeatureCostLinkTable->CreateCursor(fFalse));
	pCursor->Reset();
	pCursor->SetFilter(iColumnBit(m_colFeatureCostLinkFeature) | iColumnBit(m_colFeatureCostLinkComponent));
	pCursor->PutString(m_colFeatureCostLinkFeature,riFeatureString);
	pCursor->PutString(m_colFeatureCostLinkComponent,riComponentString);
	if (!pCursor->Next())
	{
		pCursor->PutString(m_colFeatureCostLinkFeature,riFeatureString);
		pCursor->PutString(m_colFeatureCostLinkComponent,riComponentString);
		AssertNonZero(pCursor->Insert());
	}
	return 0;
}



IMsiRecord* CMsiEngine::RegisterCostLinkedComponent(const IMsiString& riComponentString,
													const IMsiString& riRecostComponentString)
/*-------------------------------------------------------------------------
Links the two specified components together, such that if riComponentString
needs to be dynamically recosted at any time, riRecostComponentString will
also be recosted.
--------------------------------------------------------------------------*/
{
	if (m_piCostLinkTable == 0)
	{
		const int iInitialRows = 2;
		IMsiRecord* piErrRec = m_piDatabase->CreateTable(*MsiString(*sztblCostLink),iInitialRows,m_piCostLinkTable);
		if (piErrRec)
			return piErrRec;

		AssertNonZero(m_colCostLinkComponent = m_piCostLinkTable->CreateColumn(icdString + icdPrimaryKey,
			*MsiString(*sztblCostLink_colComponent)));
		AssertNonZero(m_colCostLinkRecostComponent = m_piCostLinkTable->CreateColumn(icdString + icdPrimaryKey,
			*MsiString(*sztblCostLink_colRecostComponent)));
	}

	PMsiCursor pCursor(0);
	AssertNonZero(pCursor = m_piCostLinkTable->CreateCursor(fFalse));
	pCursor->Reset();
	pCursor->SetFilter(iColumnBit(m_colCostLinkComponent) | iColumnBit(m_colCostLinkRecostComponent));
	pCursor->PutString(m_colCostLinkComponent,riComponentString);
	pCursor->PutString(m_colCostLinkRecostComponent,riRecostComponentString);
	if (!pCursor->Next())
	{
		pCursor->PutString(m_colCostLinkComponent,riComponentString);
		pCursor->PutString(m_colCostLinkRecostComponent,riRecostComponentString);
		AssertNonZero(pCursor->Insert());
	}
	return 0;
}


IMsiRecord* CMsiEngine::RegisterComponentDirectory(const IMsiString& riComponentString,
												   const IMsiString& riDirectoryString)
{
	MsiStringId idComponentString, idDirectoryString;

	idComponentString = m_piDatabase->EncodeString(riComponentString);
	Assert(idComponentString);
	idDirectoryString = m_piDatabase->EncodeString(riDirectoryString);
	Assert(idDirectoryString);
	return RegisterComponentDirectoryId(idComponentString, idDirectoryString);

}

IMsiRecord* CMsiEngine::RegisterComponentDirectoryId(const MsiStringId idComponentString,
												   const MsiStringId idDirectoryString)
/*---------------------------------------------------------------------------
Registers a specified directory property with a specified component, ensuring
that if the path associated with the directory changes, the component will
be re-costed.  This is used for components that may write files, etc. to
locations other than the directory named in the Component table.
----------------------------------------------------------------------------*/
{
	if (!m_piComponentTable)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	if (!m_piDirTable)
		return PostError(Imsg(idbgDirMgrNotInitialized),0);

	int iParentLevel = 0;
	int iTreeLevel = 0;
	int iChildCount = 0;
	int iParentAttributes = 0;

	CreateSharedCursor(piComponentCursor, m_piComponentCursor);
	m_piComponentCursor->SetFilter(1);
	m_piComponentCursor->PutInteger(m_colComponentKey,idComponentString);
	while ((iTreeLevel = m_piComponentCursor->Next()) > iParentLevel)
	{
		if (iParentLevel == 0)
		{
			m_piComponentCursor->SetFilter(0);
			iParentLevel = iTreeLevel;
			iParentAttributes = m_piComponentCursor->GetInteger(m_colComponentAttributes);
		}
		else
			iChildCount++;

		if (idDirectoryString == m_piComponentCursor->GetInteger(m_colComponentDir))
			return 0; // Directory already registered, so we're done
	}

	MsiString strComponent(m_piDatabase->DecodeString(idComponentString));
	if (iParentLevel == 0)
		return PostError(Imsg(idbgBadComponent),*strComponent);

	// Create a child component tied to riComponentString - this child component
	// will maintain the linked directory cost. If the name we invent for the
	// child is already taken, keep trying until we find an unused name.
	int iMaxTries = 100;
	int iSuffix = iChildCount + 65;
	const int cchMaxComponentTemp=40;
	int cchT;
	do
	{
		// Max size is 2 chars for __, cchMaxComponentTemp and 11 chars for max
		// int and trailing null
		ICHAR rgch[2+cchMaxComponentTemp+11];

		IStrCopy(rgch, TEXT("__"));
		memcpy(&rgch[2], (const ICHAR *)strComponent, (cchT = min(strComponent.TextSize(), cchMaxComponentTemp)) * sizeof(ICHAR));
		ltostr(&rgch[2 + cchT], iSuffix++);
		MsiString strSubcomponent(rgch);
		m_piComponentCursor->Reset();
		m_piComponentCursor->PutString(m_colComponentKey,*strSubcomponent);
		m_piComponentCursor->PutInteger(m_colComponentParent,idComponentString);
		m_piComponentCursor->PutInteger(m_colComponentDir,idDirectoryString);
		m_piComponentCursor->PutInteger(m_colComponentAttributes,iParentAttributes);
		m_piComponentCursor->PutInteger(m_colComponentLocalCost,  iMsiNullInteger);
		m_piComponentCursor->PutInteger(m_colComponentSourceCost, iMsiNullInteger);
		m_piComponentCursor->PutInteger(m_colComponentRemoveCost, iMsiNullInteger);
		m_piComponentCursor->PutInteger(m_colComponentARPLocalCost, iMsiNullInteger);
		// Temporary value in the component id, isn't used anywhere.
		// This would actually be an error to see this in a persistent database.
		m_piComponentCursor->PutString(m_colComponentID,*MsiString(*szTemporaryId));
		iMaxTries--;
	}while (m_piComponentCursor->InsertTemporary() == fFalse && iMaxTries > 0);
	if (iMaxTries == 0)
		return PostError(Imsg(idbgBadSubcomponentName),*strComponent);

	// Try to insert the given directory name into the directory table, if
	// it's not already there. If the Insert call fails, fine; it just means
	// we've already got this directory in the table.
	PMsiCursor pDirCursor(m_piDirTable->CreateCursor(fFalse));
	pDirCursor->PutInteger(m_colDirKey,idDirectoryString);
	pDirCursor->PutString(m_colDirParent,*MsiString(*IPROPNAME_TARGETDIR));
	pDirCursor->PutString(m_colDirSubPath,*MsiString(*TEXT("?"))); // We can check for the presence of this
																   // question mark later if a path for this
									   // directory never gets defined.
	pDirCursor->InsertTemporary();
	return 0;
}



IMsiRecord* CMsiEngine::RecostDirectory(const IMsiString& riDirectoryString, IMsiPath& riOldPath)
/*----------------------------------------------------------------------------------------
Internal SelectionManager function that updates the VolumeCost table based on a directory
that has changed from the path given in riOldPath.
-----------------------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	IMsiRecord* piErrRec;
	PMsiCursor pComponentCursor(0);
	AssertNonZero(pComponentCursor = m_piComponentTable->CreateCursor(fFalse));

	// Recost every component that references the given destination directory name
	pComponentCursor->SetFilter(iColumnBit(m_colComponentDir));
	pComponentCursor->PutString(m_colComponentDir,riDirectoryString);
	MsiStringId idTempId = m_piDatabase->EncodeStringSz(szTemporaryId);
	while (pComponentCursor->Next())
	{
		// Bug 7566: If costing is not yet complete, don't need to Recost, but we
		// still need to call SetComponent below
		if (m_fCostingComplete)
		{
#ifdef LOG_COSTING
			ICHAR rgch[300];
			MsiString strComponent(pComponentCursor->GetString(m_colComponentKey));
			wsprintf(rgch,TEXT("Recosting component: %s, due to change in directory: %s"),(const ICHAR*) strComponent,
				riDirectoryString.GetString());
			DEBUGMSG(rgch);
#endif
			if ((piErrRec = RecostComponentDirectoryChange(pComponentCursor,&riOldPath, /*fCostLinked = */false)) != 0)
				return piErrRec;
		}

		// if selected to be installed locally, we need to reevaluate whether we should
		// be installing this component based on existing component version
		iisEnum iisRequestedAction = (iisEnum)pComponentCursor->GetInteger(m_colComponentActionRequest);
		if(iisRequestedAction == iisLocal)
		{
			// Bug 7200 - we don't want to re-evaluate our temporary costing subcomponents
			if (idTempId && pComponentCursor->GetInteger(m_colComponentID) != idTempId)
			{
				if ((piErrRec = SetComponent(pComponentCursor->GetInteger(m_colComponentKey), iisRequestedAction)) != 0)
					return piErrRec;
			}
		}

	}

	// No further recosting needed during initialization
	if (m_fCostingComplete == fFalse)
		return 0;

	// Finally, recost any components explicitly linked to the ones we just recosted.
	pComponentCursor->Reset();
	pComponentCursor->SetFilter(iColumnBit(m_colComponentDir));
	pComponentCursor->PutString(m_colComponentDir,riDirectoryString);
	while (pComponentCursor->Next())
	{
		if ((piErrRec = RecostLinkedComponents(*MsiString(pComponentCursor->GetString(m_colComponentKey)))) != 0)
			return piErrRec;
	}

	return 0;
}


IMsiRecord* CMsiEngine::RecostComponentDirectoryChange(IMsiCursor* piCursor, IMsiPath* piOldPath, bool fCostLinked)
/*----------------------------------------------------------------------------------------
Internal SelectionManager function that updates the dynamic cost of the component
referenced by the Component Table cursor given in piCursor.  This function should always
be called whenever the directory mapped to the component changes.  The path in piOldPath
represents the directory path as it existed BEFORE the change.  If the cost is being
initialized, pass piOldPath as NULL.
-----------------------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	Assert(piCursor);
	IMsiRecord* piErrRec;

#ifdef DEBUG
	const ICHAR* szComponent = MsiString(piCursor->GetString(m_colComponentKey));
	const ICHAR* szDirectory = MsiString(piCursor->GetString(m_colComponentDir));
#endif
	// in the case of cost-linked components, we explicitly want to re-cost them
	// no matter what their current action state is.
	iisEnum iisAction = (iisEnum) piCursor->GetInteger(m_colComponentAction);
	if (iisAction == iMsiNullInteger && !fCostLinked)
		return 0;

	MsiString strDirectory(piCursor->GetString(m_colComponentDir));
	PMsiPath pDestPath(0);
	if ((piErrRec = GetTargetPath(*strDirectory,*&pDestPath)) != 0)
	{
		if (piErrRec->GetInteger(1) == idbgDirPropertyUndefined)
		{
			piErrRec->Release();
			return 0;
		}
		else
		{
			return piErrRec;
		}
	}


	// Get the current total cost...
	int iOldTotalCost, iOldNoRbTotalCost, iOldARPTotalCost, iOldNoRbARPTotalCost;
	if ((piErrRec = GetComponentCost(piCursor, iOldTotalCost, iOldNoRbTotalCost, iOldARPTotalCost, iOldNoRbARPTotalCost)) != 0)
		return piErrRec;

	// ...and if we've got a good oldPath pointer (i.e. this component has been
	// costed previously), remove old cost from the old destination's volume...
	if (piOldPath && (iOldTotalCost || iOldNoRbTotalCost || iOldARPTotalCost || iOldNoRbARPTotalCost))
	{
#ifdef LOG_COSTING
		ICHAR rgch[300];
		MsiString strDestPath(piOldPath->GetPath());
		MsiString strActualComponent(piCursor->GetString(m_colComponentKey));
		wsprintf(rgch,TEXT("Removing old cost: Component: %s, path: %s, Cost: %li"),(const ICHAR*) strActualComponent,
			(const ICHAR*) strDestPath,iOldTotalCost * 512);
		DEBUGMSG(rgch);
#endif
		if ((piErrRec = AddCostToVolumeTable(piOldPath, -iOldTotalCost, -iOldNoRbTotalCost, -iOldARPTotalCost, -iOldNoRbARPTotalCost)) != 0)
			return piErrRec;
	}


	// Subcomponents have dummy names derived from the parent - all files
	// and such are linked to parent components, so we must pass the
	// parent component name to GetDynamicCost.
	Bool fSubcomponent = fTrue;
	MsiString strComponent(piCursor->GetString(m_colComponentParent));
	if (strComponent.TextSize() == 0)
	{
		strComponent = piCursor->GetString(m_colComponentKey);
		fSubcomponent = fFalse;
	}

	// Calculate the new dynamic cost, and attribute to the component's volume.
	// But, if no one registered a CostAdjuster Object, then we've got nothing to do.
	int iLocalCost = 0;
	int iSourceCost = 0;
	int iRemoveCost = 0;
	int iARPLocalCost = 0;
	int iNoRbLocalCost = 0;
	int iNoRbRemoveCost = 0;
	int iNoRbSourceCost = 0;
	int iNoRbARPLocalCost = 0;
	if (m_piCostAdjusterTable)
	{
		// Otherwise, we'll send a GetDynamicCost message to each cost object
		PMsiCursor pCostCursor(m_piCostAdjusterTable->CreateCursor(fFalse));
		pCostCursor->Reset();
		while (pCostCursor->Next())
		{
			PMsiCostAdjuster pCostAdjuster = (IMsiCostAdjuster*) pCostCursor->GetMsiData(m_colCostAdjuster);
			if (pCostAdjuster)
			{
				MsiDisableTimeout();
				int iThisLocalCost,iThisNoRbLocalCost, iThisSourceCost,iThisRemoveCost,iThisNoRbRemoveCost,iThisNoRbSourceCost,iThisARPLocalCost,iThisNoRbARPLocalCost;
				piErrRec = pCostAdjuster->GetDynamicCost(*strComponent, *strDirectory,
																((GetMode() & iefCompileFilesInUse) ? fTrue : fFalse),
																iThisRemoveCost, iThisNoRbRemoveCost, iThisLocalCost,
																iThisNoRbLocalCost, iThisSourceCost, iThisNoRbSourceCost, iThisARPLocalCost, iThisNoRbARPLocalCost);
				MsiEnableTimeout();
				if (piErrRec)
					return piErrRec;

				iLocalCost += iThisLocalCost;
				iSourceCost += iThisSourceCost;
				iRemoveCost += iThisRemoveCost;
				iARPLocalCost += iThisARPLocalCost;
				iNoRbRemoveCost += iThisNoRbRemoveCost;
				iNoRbLocalCost += iThisNoRbLocalCost;
				iNoRbSourceCost += iThisNoRbSourceCost;
				iNoRbARPLocalCost += iThisNoRbARPLocalCost;
			}
		}
	}
	int iRuntimeFlags = piCursor->GetInteger(m_colComponentRuntimeFlags) | bfComponentCostInitialized;
	AssertNonZero(piCursor->PutInteger(m_colComponentRuntimeFlags,iRuntimeFlags));
	AssertNonZero(piCursor->PutInteger(m_colComponentLocalCost,iLocalCost));
	AssertNonZero(piCursor->PutInteger(m_colComponentSourceCost,iSourceCost));
	AssertNonZero(piCursor->PutInteger(m_colComponentRemoveCost,iRemoveCost));
	AssertNonZero(piCursor->PutInteger(m_colComponentARPLocalCost,iARPLocalCost));
	AssertNonZero(piCursor->PutInteger(m_colComponentNoRbLocalCost,iNoRbLocalCost));
	AssertNonZero(piCursor->PutInteger(m_colComponentNoRbRemoveCost,iNoRbRemoveCost));
	AssertNonZero(piCursor->PutInteger(m_colComponentNoRbSourceCost,iNoRbSourceCost));
	AssertNonZero(piCursor->PutInteger(m_colComponentNoRbARPLocalCost,iNoRbARPLocalCost));
	AssertNonZero(piCursor->Update());

	// add to the new destination's volume
	int iNewTotalCost, iNewNoRbTotalCost, iNewARPTotalCost, iNewNoRbARPTotalCost;
	if ((piErrRec = GetComponentCost(piCursor,iNewTotalCost, iNewNoRbTotalCost, iNewARPTotalCost, iNewNoRbARPTotalCost)) != 0)
		return piErrRec;

	if (iNewTotalCost || iNewNoRbTotalCost || iNewARPTotalCost || iNewNoRbARPTotalCost)
	{
		if ((piErrRec = AddCostToVolumeTable(pDestPath, iNewTotalCost, iNewNoRbTotalCost, iNewARPTotalCost, iNewNoRbARPTotalCost)) != 0)
			return piErrRec;

#ifdef LOG_COSTING
		ICHAR rgch[300];
		MsiString strDestPath(pDestPath->GetPath());
		MsiString strActualComponent(piCursor->GetString(m_colComponentKey));
		wsprintf(rgch,TEXT("Adding cost: Component: %s, path: %s, Cost: %li, NoRbCost: %li"),(const ICHAR*) strActualComponent,
			(const ICHAR*) strDestPath,iNewTotalCost * 512, iNewNoRbTotalCost * 512);
		DEBUGMSG(rgch);
#endif
	}

	return 0;
}


IMsiRecord* CMsiEngine::RecostComponentActionChange(IMsiCursor* piCursor, iisEnum iisOldAction)
/*----------------------------------------------------------------------------------------
Internal SelectionManager function that updates the dynamic cost of the component
referenced by the Component Table cursor given in piCursor.  This function should always
be called whenever the directory mapped to the component changes, or when the component
state itself changes.  The path in piOldPath represents the directory path as it existed
BEFORE the change; if the component directory hasn't changed, piOldPath should contain
the current directory.
-----------------------------------------------------------------------------------------*/
{
	Assert(piCursor);
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	IMsiRecord* piErrRec;
	PMsiPath pDestPath(0);
	if ((piErrRec = GetTargetPath(*MsiString(piCursor->GetString(m_colComponentDir)),*&pDestPath)) != 0)
	{
		if (piErrRec->GetInteger(1) == idbgDirPropertyUndefined)
		{
			piErrRec->Release();
			return 0;
		}
		else
		{
			return piErrRec;
		}
	}

#ifdef DEBUG
	const ICHAR* szComponent = MsiString(piCursor->GetString(m_colComponentKey));
#endif

	// If the component has never been costed before, initialize its cost now, and we're done
	int iRuntimeFlags = piCursor->GetInteger(m_colComponentRuntimeFlags);
	if (!(iRuntimeFlags & bfComponentCostInitialized))
	{
		if ((piErrRec = RecostComponentDirectoryChange(piCursor,pDestPath,/*fCostLinked =*/false)) != 0)
			return piErrRec;
	}
	else
	{
		// Get the old cost, based on the old action state
		int iOldCost, iOldNoRbCost, iOldARPCost, iOldNoRbARPCost;
		if ((piErrRec = GetComponentActionCost(piCursor, iisOldAction, iOldCost, iOldNoRbCost, iOldARPCost, iOldNoRbARPCost)) != 0)
			return piErrRec;

		// ...Remove old cost from the our destination's volume...
		if (pDestPath && (iOldCost || iOldNoRbCost || iOldARPCost || iOldNoRbARPCost))
		{
			if ((piErrRec = AddCostToVolumeTable(pDestPath, -iOldCost, -iOldNoRbCost, -iOldARPCost, -iOldNoRbARPCost)) != 0)
				return piErrRec;
		}

		// ...and add the new cost, based on the new action state, back in.
		int iNewCost, iNewNoRbCost, iNewARPCost, iNewNoRbARPCost;
		if ((piErrRec = GetComponentCost(piCursor,iNewCost, iNewNoRbCost, iNewARPCost, iNewNoRbARPCost)) != 0)
			return piErrRec;

		if (pDestPath && (iNewCost || iNewNoRbCost || iNewARPCost || iNewNoRbARPCost))
		{
			if ((piErrRec = AddCostToVolumeTable(pDestPath, iNewCost, iNewNoRbCost, iNewARPCost, iNewNoRbARPCost)) != 0)
				return piErrRec;
		}
	}

	// Finally, recost any components explicitly linked to the one we just recosted.
	MsiString strComponent(piCursor->GetString(m_colComponentKey));
	if ((piErrRec = RecostLinkedComponents(*strComponent)) != 0)
		return piErrRec;

	return 0;
}


IMsiRecord* CMsiEngine::RecostLinkedComponents(const IMsiString& riComponentString)
/*----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	// No recosting needed during initialization
	if (m_fCostingComplete == fFalse)
		return 0;

	// Recost every component that is explicitly linked to riComponentString
	if (m_piCostLinkTable)
	{
		PMsiCursor pCursor(0);
		AssertNonZero(pCursor = m_piCostLinkTable->CreateCursor(fFalse));
		pCursor->Reset();
		pCursor->SetFilter(iColumnBit(m_colCostLinkComponent));
		pCursor->PutString(m_colCostLinkComponent,riComponentString);
		while (pCursor->Next())
		{
#ifdef LOG_COSTING
			ICHAR rgch[300];
			MsiString strLinkedComponent(pCursor->GetString(m_colCostLinkRecostComponent));
			wsprintf(rgch,TEXT("Recosting component: %s, due to recosting of %s"),(const ICHAR*) strLinkedComponent,
				riComponentString.GetString());
			DEBUGMSG(rgch);
#endif

			IMsiRecord* piErrRec;
			if ((piErrRec = RecostComponent(pCursor->GetInteger(m_colCostLinkRecostComponent),/*fCostLinked =*/true)) != 0)
				return piErrRec;
		}
	}
	return 0;
}


IMsiRecord* CMsiEngine::RecostComponent(const MsiStringId idComponentString, bool fCostLinked)
//---------------------------------------------
{
	if (!m_piComponentTable)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	IMsiRecord* piErrRec;


	// Recost this component and all of it's subcomponents
	PMsiCursor pCursor(m_piComponentTable->CreateCursor(fTrue));
	pCursor->SetFilter(1);
	pCursor->PutInteger(m_colComponentKey,idComponentString);
	int iParentLevel = pCursor->Next();
	if (iParentLevel == 0)
		return PostError(Imsg(idbgBadComponent),*MsiString(m_piDatabase->DecodeString(idComponentString)));
	pCursor->SetFilter(0);
	int iTreeLevel;
	do
	{
		PMsiPath pDestPath(0);
		if ((piErrRec = GetTargetPath(*MsiString(pCursor->GetString(m_colComponentDir)),*&pDestPath)) != 0)
		{
			if ( piErrRec->GetInteger(1) == idbgDirPropertyUndefined )
				piErrRec->Release();
			else
				return piErrRec;
		}
		else if ((piErrRec = RecostComponentDirectoryChange(pCursor,pDestPath,fCostLinked)) != 0)
			return piErrRec;
		iTreeLevel = pCursor->Next();
	}while (iTreeLevel > iParentLevel);
	return 0;
}


IMsiRecord* CMsiEngine::RegisterCostAdjuster(IMsiCostAdjuster& riCostAdjuster)
//------------------------------------------
{
	IMsiRecord* piErrRec;
	if (m_piCostAdjusterTable == 0)
	{
		piErrRec = m_piDatabase->CreateTable(*MsiString(sztblCostAdjuster),5,m_piCostAdjusterTable);
		if (piErrRec)
			return piErrRec;

		m_colCostAdjuster = m_piCostAdjusterTable->CreateColumn(icdObject + icdPrimaryKey + icdNullable, g_MsiStringNull);
	}

	// !!We might want to see if riCostAdjuster is already in the CostAdjuster table, and throw
	// an error if so
	Assert(m_piCostAdjusterTable);
	PMsiCursor pCostCursor = m_piCostAdjusterTable->CreateCursor(fFalse);
	Assert(pCostCursor);
	pCostCursor->Reset();
	AssertNonZero(pCostCursor->PutMsiData(m_colCostAdjuster,&riCostAdjuster));
	AssertNonZero(pCostCursor->Insert());

	piErrRec = riCostAdjuster.Initialize();
	if (piErrRec)
		return piErrRec;
	return 0;
}


IMsiRecord* CMsiEngine::GetComponentCost(IMsiCursor* piCursor, int& iTotalCost, int& iNoRbTotalCost, int& iARPTotalCost, int& iNoRbARPTotalCost)
/*----------------------------------------------------------------------------------------
Internal SelectionManager function that returns the total cost attributable to the
specified component, based on the component's current action state.
-----------------------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	Assert(piCursor);
	iisEnum iisAction = (iisEnum) piCursor->GetInteger(m_colComponentAction);
	return GetComponentActionCost(piCursor,iisAction,iTotalCost,iNoRbTotalCost,iARPTotalCost,iNoRbARPTotalCost);
}


IMsiRecord* CMsiEngine::GetComponentActionCost(IMsiCursor* piCursor, iisEnum iisAction, int& iActionCost, int& iNoRbActionCost, int& iARPActionCost, int& iNoRbARPActionCost)
/*--------------------------------------------------------------------------------
Internal SelectionManager function that returns the total cost attributable to the
specified component, based on the action specified in iisAction.  If iisAction
is specified as iisCurrent, the cost will be based on the component's current
action state.
----------------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	if (iisAction == iisCurrent)
		iisAction = (iisEnum) piCursor->GetInteger(m_colComponentAction);

	Assert(piCursor);
	switch (iisAction)
	{
		case iisAbsent:
			iActionCost = piCursor->GetInteger(m_colComponentRemoveCost);
			iNoRbActionCost = piCursor->GetInteger(m_colComponentNoRbRemoveCost);
			iARPActionCost = iActionCost;
			iNoRbARPActionCost = iNoRbActionCost;
			break;
		case iisLocal:
			iActionCost = piCursor->GetInteger(m_colComponentLocalCost);
			iNoRbActionCost = piCursor->GetInteger(m_colComponentNoRbLocalCost);
			iARPActionCost = piCursor->GetInteger(m_colComponentARPLocalCost);
			iNoRbARPActionCost = piCursor->GetInteger(m_colComponentNoRbARPLocalCost);
			break;
		case iisSource:
			iActionCost = piCursor->GetInteger(m_colComponentSourceCost);
			iNoRbActionCost = piCursor->GetInteger(m_colComponentNoRbSourceCost);
			iARPActionCost = iActionCost;
			iNoRbARPActionCost = iNoRbActionCost;
			break;
		case iMsiNullInteger:
		default:
			iActionCost = 0;
			iNoRbActionCost = 0;
			iARPActionCost = 0;
			iNoRbARPActionCost = 0;
			break;
	}

	return 0;

}


IMsiRecord* CMsiEngine::GetTotalSubComponentActionCost(const IMsiString& riComponentString, iisEnum iisAction,
													   int& iTotalCost, int& iNoRbTotalCost)
/*----------------------------------------------------------------------------------------
Internal SelectionManager function that returns the total cost attributable to the
specified component, and all its children, based on the specified Action state.
-----------------------------------------------------------------------------------------*/
{
	if (!m_piComponentCursor)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pCursor(m_piComponentTable->CreateCursor(fTrue));
	pCursor->SetFilter(1);
	pCursor->PutString(m_colComponentKey,riComponentString);
	int iParentLevel = pCursor->Next();
	if (iParentLevel == 0)
		return PostError(Imsg(idbgBadComponent),riComponentString);
	pCursor->SetFilter(0);
	int iTreeLevel;
	iTotalCost = iNoRbTotalCost = 0;
	do
	{
		int iRuntimeFlags = pCursor->GetInteger(m_colComponentRuntimeFlags);
		if (!m_fExclusiveComponentCost || !(iRuntimeFlags & bfComponentCostMarker))
		{
			int iCost, iNoRbCost, iARPCost, iNoRbARPCost;
			IMsiRecord* piErrRec = GetComponentActionCost(pCursor,iisAction,iCost, iNoRbCost, iARPCost, iNoRbARPCost);
			if (piErrRec)
				return piErrRec;
			iTotalCost += iCost;
			iNoRbTotalCost += iNoRbCost;
			iRuntimeFlags |= bfComponentCostMarker;
			AssertNonZero(pCursor->PutInteger(m_colComponentRuntimeFlags,iRuntimeFlags));
			AssertNonZero(pCursor->Update());
			
		}
		iTreeLevel = pCursor->Next();
	}while (iTreeLevel > iParentLevel);
	
	return 0;

}


IMsiRecord* CMsiEngine::AddCostToVolumeTable(IMsiPath* piDestPath, int iCost, int iNoRbCost, int iARPCost, int iNoRbARPCost)
/*---------------------------------------------------------------------
Internal function that adds the cost specified in iCost to the volume
associated with the given path object.
-----------------------------------------------------------------------*/
{
	if (m_piVolumeCostTable == 0)
	{
		const int iInitialRows = 5;
		IMsiRecord* piErrRec = m_piDatabase->CreateTable(*MsiString(*sztblVolumeCost),iInitialRows,m_piVolumeCostTable);
		if (piErrRec)
			return piErrRec;

		AssertNonZero(m_colVolumeObject = m_piVolumeCostTable->CreateColumn(icdObject + icdNullable + icdPrimaryKey,*MsiString(*sztblVolumeCost_colVolumeObject)));
		AssertNonZero(m_colVolumeCost = m_piVolumeCostTable->CreateColumn(icdLong + icdNoNulls,*MsiString(*sztblVolumeCost_colVolumeCost)));
		AssertNonZero(m_colNoRbVolumeCost = m_piVolumeCostTable->CreateColumn(icdLong + icdNoNulls,*MsiString(*sztblVolumeCost_colNoRbVolumeCost)));
		AssertNonZero(m_colVolumeARPCost = m_piVolumeCostTable->CreateColumn(icdLong + icdNoNulls,*MsiString(*sztblVolumeCost_colVolumeARPCost)));
		AssertNonZero(m_colNoRbVolumeARPCost = m_piVolumeCostTable->CreateColumn(icdLong + icdNoNulls,*MsiString(*sztblVolumeCost_colNoRbVolumeARPCost)));
	}

	if (piDestPath)
	{
		PMsiVolume pVolume = &piDestPath->GetVolume();
		Assert(pVolume);
		PMsiCursor pVolCursor(m_piVolumeCostTable->CreateCursor(fFalse));
		Assert(pVolCursor);
		pVolCursor->Reset();
		pVolCursor->SetFilter(1);
		pVolCursor->PutMsiData(m_colVolumeObject, pVolume);
		if (!pVolCursor->Next())
		{
			AssertNonZero(pVolCursor->PutMsiData(m_colVolumeObject,pVolume));
			AssertNonZero(pVolCursor->PutInteger(m_colVolumeCost,0));
			AssertNonZero(pVolCursor->PutInteger(m_colNoRbVolumeCost, 0));
			AssertNonZero(pVolCursor->PutInteger(m_colVolumeARPCost,0));
			AssertNonZero(pVolCursor->PutInteger(m_colNoRbVolumeARPCost,0));
			AssertNonZero(pVolCursor->Insert());
		}
		int iAccumCost = pVolCursor->GetInteger(m_colVolumeCost) + iCost;
		pVolCursor->PutInteger(m_colVolumeCost,iAccumCost);
		int iAccumNoRbCost = pVolCursor->GetInteger(m_colNoRbVolumeCost) + iNoRbCost;
		pVolCursor->PutInteger(m_colNoRbVolumeCost,iAccumNoRbCost);
		int iAccumARPCost = pVolCursor->GetInteger(m_colVolumeARPCost) + iARPCost;
		pVolCursor->PutInteger(m_colVolumeARPCost,iAccumARPCost);
		int iAccumNoRbARPCost = pVolCursor->GetInteger(m_colNoRbVolumeARPCost) + iNoRbARPCost;
		pVolCursor->PutInteger(m_colNoRbVolumeARPCost,iAccumNoRbARPCost);
		AssertNonZero(pVolCursor->Update());
	}
	return 0;
}


int CMsiEngine::GetTotalCostAcrossVolumes(bool fRollbackCost, bool fARPCost)
/*---------------------------------------------------------------------
Internal function that returns the sum cost attributed to all volumes
in the VolumeCost table, in units of 512 bytes.  If fRollback cost is
TRUE, the cost assuming rollback is enabled will be returned.  If no
volumeCost table exists, or if the routine fails for any other reason,
zero is returned.
-----------------------------------------------------------------------*/
{
	int iTotalCost = 0;
	if (m_piVolumeCostTable)
	{
		PMsiCursor pVolCursor(m_piVolumeCostTable->CreateCursor(fFalse));
		Assert(pVolCursor);
		pVolCursor->Reset();
		int iColumn;
		if (fARPCost)
			iColumn = fRollbackCost ? m_colVolumeARPCost : m_colNoRbVolumeARPCost;
		else
			iColumn = fRollbackCost ? m_colVolumeCost : m_colNoRbVolumeCost;

		while (pVolCursor->Next())
		{
			iTotalCost += pVolCursor->GetInteger(iColumn);
		}
	}
	return iTotalCost;
}


void CMsiEngine::ResetEngineCosts()
{
	m_iDatabaseCost = 0;
	m_iScriptCost = 0;
	m_iScriptCostGuess = 0;
	m_iRollbackScriptCost = 0;
	m_iRollbackScriptCostGuess = 0;
	m_iPatchPackagesCost = 0;
}

static const ICHAR sqlFileScriptCost[] = TEXT("SELECT NULL FROM `File`,`Component` WHERE `Component`=`Component_` AND (`Action` = 0 OR `Action`= 1 OR `Action` = 2)");

static const ICHAR sqlRegScriptCost[] =
TEXT("SELECT NULL FROM `Registry`,`Component` WHERE `Component` = `Component_` AND (`Action` = 0 OR `Action`= 1 OR `Action` = 2)");

static const ICHAR sqlBindImageScriptCost[] =
TEXT("SELECT NULL FROM `BindImage`, `File`, `Component` WHERE `File` = `File_` AND `Component` = `Component_` AND (`Action`=0 OR `Action`= 1 OR `Action` = 2)");

static const ICHAR sqlRegisterProgIdScriptCost[] = TEXT("SELECT DISTINCT NULL FROM `ProgId`, `Class`, `Feature`, `Component` WHERE `ProgId`.`Class_` = `Class`.`CLSID` AND `Class`.`Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND ((`Feature`.`Action` = 0 OR `Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");

static const ICHAR sqlPublishComponentsScriptCost[]   = TEXT("SELECT NULL FROM `PublishComponent`, `Component`, `Feature`  WHERE `PublishComponent`.`Component_` = `Component`.`Component` AND `PublishComponent`.`Feature_` = `Feature`.`Feature` AND ((`Feature`.`Action` = 0 OR `Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");

static const ICHAR sqlPublishFeaturesScriptCost[] = TEXT("SELECT NULL FROM `Feature` WHERE ((`Feature`.`Action` = 0 OR `Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");

static const ICHAR sqlSelfRegScriptCost[] = TEXT("SELECT NULL FROM `SelfReg`, `File`, `Component`")
									TEXT(" WHERE `SelfReg`.`File_` = `File`.`File` And `File`.`Component_` = `Component`.`Component`")
									TEXT(" AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2 OR `Component`.`Action` = 0)");

static const ICHAR sqlRegisterComponentsScriptCost[] = TEXT("SELECT NULL FROM `Component` WHERE `Component_Parent` = NULL AND (`ActionRequest` = 0 OR `ActionRequest` = 1 OR `ActionRequest` = 2)");

static const ICHAR sqlRegisterExtensionInfoScriptCost[] = TEXT("SELECT NULL FROM `Extension`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 0 OR `Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");

static const ICHAR sqlRegisterFontsScriptCost[] = TEXT("SELECT NULL FROM `Font`, `File`, `Component` WHERE `Font`.`File_` = `File`.`File` And `File`.`Component_` = `Component`.`Component` AND (`Component`.`Action` = 0 OR `Component`.`Action` = 1 OR `Component`.`Action` = 2)");

static const ICHAR sqlCreateShortcutsScriptCost[] = TEXT("SELECT NULL FROM `Shortcut`, `Feature`, `Component`, `File`")
TEXT(" WHERE `Target` = `Feature` AND `Shortcut`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND")
TEXT(" ((`Feature`.`Action` = 0 OR `Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");

static const ICHAR sqlRegisterClassInfo[] = TEXT("SELECT NULL FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 0 OR `Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");

static const ICHAR sqlComponentCount[] = TEXT("SELECT NULL FROM `Component`");

struct ScriptCostQuery
{
	const ICHAR* szSQL;
	const ICHAR* szTable;
	int iCostPerRow;
	int iEventsPerRow;
};

const ICHAR szRegistryTable[]   = TEXT("Registry");
const ICHAR szBindImageTable[]  = TEXT("BindImage");
const ICHAR szProgIdTable[]    = TEXT("ProgId");
const ICHAR szPublishComponentTable[] = TEXT("PublishComponent");
const ICHAR szSelfRegTable[]    = TEXT("SelfReg");
const ICHAR szExtensionTable[]    = TEXT("Extension");
const ICHAR szFontTable[]    = TEXT("Font");
const ICHAR szShortcutTable[]    = TEXT("Shortcut");
const ICHAR szClassTable[]    = TEXT("Class");

const ScriptCostQuery g_rgScriptCostQuery[] =
{
	sqlFileScriptCost,                sztblFile,                                   75, 2,
	sqlRegScriptCost,                 sztblRegistry,                               64, 2,
	sqlBindImageScriptCost,           sztblBindImage,                      26, 1,
	sqlRegisterProgIdScriptCost,      sztblProgId,                        138, 1,
	sqlPublishComponentsScriptCost,   sztblPublishComponent,              200, 1,
	sqlPublishFeaturesScriptCost,     sztblFeature,                        82, 1,
	sqlSelfRegScriptCost,             sztblSelfReg,                                28, 1,
	sqlRegisterComponentsScriptCost,  sztblComponent,              85, 1,
	sqlRegisterExtensionInfoScriptCost, sztblExtension,           170, 1,
	sqlRegisterFontsScriptCost,       sztblFont,                           48, 1,
	sqlCreateShortcutsScriptCost,     sztblShortcut,                       75, 1,
	sqlRegisterClassInfo,             sztblClass,                                 208, 1,
	sqlComponentCount,                sztblComponent,                               0, iComponentCostWeight, // Counts only events for costing progress
};

const int g_cScriptCostQueries = sizeof(g_rgScriptCostQuery)/sizeof(ScriptCostQuery);

IMsiRecord* CMsiEngine::GetScriptCost(int* piScriptCost, int* piScriptEvents, Bool fExact, Bool* pfUserCancelled)
//-----------------------------------
{
	Assert(!pfUserCancelled || !*pfUserCancelled);
	if (piScriptCost)
		*piScriptCost = 0;
	else if (piScriptEvents && !fExact && m_iScriptEvents != 0 && piScriptCost == 0)
	{
		*piScriptEvents = m_iScriptEvents;
		return 0;
	}
	
	if (piScriptEvents) *piScriptEvents = 0;

	if (fExact)
	{
		m_iScriptEvents = 0;
		PMsiView pView(0);
		IMsiRecord* piErrRec;
		for (int x = 0; x < g_cScriptCostQueries;x++)
		{
			if(pfUserCancelled && ActionProgress() == imsCancel)
			{
				*pfUserCancelled = fTrue;
				return 0;
			}
			
			piErrRec= OpenView(g_rgScriptCostQuery[x].szSQL, ivcFetch, *&pView);
			if (piErrRec)
			{
				if(piErrRec->GetInteger(1) == idbgDbQueryUnknownTable)
				{
					piErrRec->Release();
					continue;
				}
				else
					return piErrRec;
			}

			if ((piErrRec = pView->Execute(0)) != 0)
				return piErrRec;

			long iRowCount;
			piErrRec = pView->GetRowCount(iRowCount);
			if (piErrRec)
				return piErrRec;
			if (piScriptCost) *piScriptCost += iRowCount * g_rgScriptCostQuery[x].iCostPerRow;
			m_iScriptEvents += iRowCount * g_rgScriptCostQuery[x].iEventsPerRow;
		}
		if (piScriptEvents) *piScriptEvents = m_iScriptEvents;
	}
	else
	{
		PMsiTable pTable(0);
		IMsiRecord* piErrRec;
		for (int x = 0; x < g_cScriptCostQueries;x++)
		{
			if(pfUserCancelled && ActionProgress() == imsCancel)
			{
				*pfUserCancelled = fTrue;
				return 0;
			}
			
			piErrRec = m_piDatabase->LoadTable(*MsiString(g_rgScriptCostQuery[x].szTable), 0, *&pTable);
			if (piErrRec)
			{
				if(piErrRec->GetInteger(1) == idbgDbTableUndefined)
				{
					piErrRec->Release();
					continue;
				}
				else
					return piErrRec;
			}

			long iRowCount;
			iRowCount = pTable->GetRowCount();
			if (piScriptCost) *piScriptCost += iRowCount * g_rgScriptCostQuery[x].iCostPerRow;
			if (piScriptEvents) *piScriptEvents += iRowCount * g_rgScriptCostQuery[x].iEventsPerRow;
		}
		

	}
	return 0;
}

IMsiRecord* CMsiEngine::EnumEngineCosts(int iIndex, Bool fRecalc, Bool fExact, Bool& fValidEnum,
										IMsiPath*& rpiPath, int& iCost, int& iNoRbCost, Bool* pfUserCancelled)
/*----------------------------------------------------------------
Internal function that allows the caller to enumerate through and
retrieve the set of disk cost requirements that are intrinsic to
the operation of the Engine.

- iIndex: 0-based index; the caller should increment this value on
  each call to EnumEngineCosts.

- fRecalc: If fTrue, EnumEngineCosts will recalculate and store
  the engine costs for the current index, based on current
  conditions.

- fExact: Passed to GetScriptCost, tells us if we need to be exact
  with our costing or not for the script

- fValidEnum: If returned as fTrue, the cost values, based on the
  current index, are valid.  The caller should continue to call
  EnumEngineCosts (incrementing iIndex each time) until fValidEnum
  is returned as fFalse.

- rpiPath: if fValidEnum is fTrue, a path object, representing the
  volume on which the cost should be incurred, will be returned.

- iCost: the disk cost (expressed as a multiple of 512 bytes). A
  negative number indicates disk space will be freed up.
- iNoRbCost: the disk cost, IF rollback were to be turned off.
----------------------------------------------------------------- */
 {
	fValidEnum = fFalse;

	if (iIndex == 0)  // Cached Database costs
	{
		// If advertising or substorage child install, no database caching
		if ((GetMode() & iefAdvertise) ||
			 *(const ICHAR*)MsiString(GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE)) == ':') // SubStorage
		{
			fValidEnum = fTrue;
			return 0;
		}
		
		MsiString strMsiDirectory = GetMsiDirectory();
		PMsiPath pMsiPath(0);
		IMsiRecord* piErrRec = m_riServices.CreatePath(strMsiDirectory, *&pMsiPath);
		if (piErrRec)
			return piErrRec;

		if (fRecalc)
		{
			MsiString strDatabasePath = GetPropertyFromSz(IPROPNAME_DATABASE);
			MsiString strDatabaseName = strDatabasePath.Extract(iseAfter, chDirSep);
			PMsiPath pDatabaseSourcePath(0);
			piErrRec = m_riServices.CreatePath(strDatabasePath, *&pDatabaseSourcePath);
			if (piErrRec)
				return piErrRec;

			piErrRec = pDatabaseSourcePath->ChopPiece(); // chop off database name
			if (piErrRec)
				return piErrRec;

			unsigned int uiDatabaseSize;
			piErrRec = pDatabaseSourcePath->FileSize(strDatabaseName, uiDatabaseSize);
			if (piErrRec)
				return piErrRec;

			unsigned int uiClusteredSize;
			if ((piErrRec = pMsiPath->ClusteredFileSize(uiDatabaseSize, uiClusteredSize)) != 0)
				return piErrRec;

			Bool fFeaturesInstalled = FFeaturesInstalled(*this);
			m_iDatabaseCost = 0;
			if (m_fMode & iefMaintenance && !fFeaturesInstalled)
				m_iDatabaseCost -= uiClusteredSize;
			if (!(m_fMode & iefMaintenance) && fFeaturesInstalled)
			{
				m_iDatabaseCost = uiClusteredSize;

				// If connected to the server, then a second, temporary, copy
				// of the MSI will be made before beginning the InstallExecuteSequence,
				// so we've got to account for that when running the UI sequence on
				// the client side.  However, since this copy will already have been
				// made once we execute the InstallExecuteSequence, we don't want to
				// account for it then.
				if (!FIsUpdatingProcess() && g_scServerContext == scClient)
					m_iDatabaseCost += uiClusteredSize;
			}
		}

		rpiPath = pMsiPath;
		rpiPath->AddRef();

		iCost = m_iDatabaseCost;
		iNoRbCost = iCost;
		fValidEnum = fTrue;
	}

	else if (iIndex == 1) // Script file cost estimate
	{
		// If EXECUTEMODE property is empty or set to "SCRIPT", we know we are
		// going to create an execute script.
		int iScriptCount = 0;
		Bool fCreateRollbackScript = fFalse;
		MsiString strExecuteMode(GetPropertyFromSz(IPROPNAME_EXECUTEMODE));
		if(strExecuteMode.TextSize() == 0 || (((const ICHAR*)strExecuteMode)[0] & 0xDF) == 'S')
		{
				iScriptCount++;
				fCreateRollbackScript = fTrue;
		}

		// In addition, if the SCRIPTFILE property is set, we are going to
		// create a user script.
		PMsiPath pScriptPath(0);
		MsiString strScriptPath = GetPropertyFromSz(IPROPNAME_SCRIPTFILE);
		if (strScriptPath.TextSize() == 0)
		{
		    strScriptPath = GetTempDirectory();
		}
		else
		{
			iScriptCount++;
		}

		if (iScriptCount)
		{
			IMsiRecord* piErrRec = m_riServices.CreatePath(strScriptPath, *&pScriptPath);
			if (piErrRec)
				return piErrRec;

			if (fRecalc)
			{
				m_iScriptCost = 0;
				m_iRollbackScriptCost = 0;
				if (!fExact && m_iScriptCostGuess != 0)
				{
					// If we already have a guess, we don't need to recalc no matter what
					fRecalc = fFalse;
				}
			}
			else if (fExact && m_iScriptCost == 0)
			{
				// If we're being exact but we don't have an exact number, need to recalc it
				fRecalc = fTrue;
			}
				
			if (fRecalc)
			{
				int iScriptCost = 0;
				int iScriptCostFinal = 0;
				int iRollbackScriptCostFinal = 0;
				
				piErrRec = GetScriptCost(&iScriptCost, 0, fExact, pfUserCancelled);
				if (piErrRec)
					return piErrRec;
				if (pfUserCancelled && *pfUserCancelled)
					return 0;

				iScriptCost += 325;         // Standard Script overhead: ixoHead, ixoProductInfo, ixoRollbackInfo, ixoEnd
				iScriptCost += 40 * 45; // ixoActionStart, ixoProgressTotal per script action
				iScriptCost += 1700 + 60 + 285;    // PublishProduct, UserRegister, RegisterProduct
				iScriptCost += (iScriptCost * 15) / 100;    // Small-time actions
				unsigned int uiClusteredSize;
				if ((piErrRec = pScriptPath->ClusteredFileSize(iScriptCost, uiClusteredSize)) != 0)
					return piErrRec;
				iScriptCostFinal = uiClusteredSize * iScriptCount;

				if (fCreateRollbackScript)
				{
					iScriptCost += iScriptCost / 2;  // Rollback script about 50% larger than install script
					if ((piErrRec = pScriptPath->ClusteredFileSize(iScriptCost, uiClusteredSize)) != 0)
						return piErrRec;
					iRollbackScriptCostFinal = uiClusteredSize;
				}
				if (!fExact)
				{
					m_iScriptCostGuess = iScriptCostFinal;
					m_iRollbackScriptCostGuess = iRollbackScriptCostFinal;
				}
				else
				{
					m_iScriptCost = iScriptCostFinal;
					m_iRollbackScriptCost = iRollbackScriptCostFinal;
				}
			}
			rpiPath = pScriptPath;
			rpiPath->AddRef();
		}
		if (!fExact)
		{
			iCost = m_iScriptCostGuess + m_iRollbackScriptCostGuess;
			iNoRbCost = m_iScriptCostGuess;
		}
		else
		{
			iCost = m_iScriptCost + m_iRollbackScriptCost;
			iNoRbCost = m_iScriptCost;
		}
		fValidEnum = fTrue;
	}
	else if (iIndex == 2) // Cached patch package costs
	{
		// patch packages cached in "msi" directory

		// during install or any configuration:
		//    1) any patches with TempCopy set are to be copied (path is TempCopy)
		//    2) any patches with Unregister set (and no other clients) are to be removed (path retrieved with MsiGetPatchInfo)

		// during uninstall, all patches (with no other clients) are to be removed (path retrieved with MsiGetPatchInfo)
		
		// TODO: cost patch removal - currently only patch caching is costed
			
		MsiString strMsiDirectory = GetMsiDirectory();
		PMsiPath pMsiPath(0);
		IMsiRecord* piErrRec = m_riServices.CreatePath(strMsiDirectory, *&pMsiPath);
		if (piErrRec)
			return piErrRec;

		if(fRecalc)
		{
			m_iPatchPackagesCost = 0;

			bool fUninstall = (!FFeaturesInstalled(*this));


			if(fUninstall == false)
			{
				const ICHAR sqlRegisterPatchPackages[] = TEXT("SELECT `TempCopy` FROM `#_PatchCache` ORDER BY `Sequence`");
				enum icppEnum
				{
					icppTempCopy = 1,
				};

				PMsiView pView(0);
				PMsiRecord pFetchRecord(0);

				m_iPatchPackagesCost = 0;
				
				if((piErrRec = OpenView(sqlRegisterPatchPackages, ivcFetch, *&pView)) == 0 &&
					(piErrRec = pView->Execute(0)) == 0)
				{
					while((pFetchRecord = pView->Fetch()) != 0)
					{
						MsiString strPatchPackage = pFetchRecord->GetMsiString(icppTempCopy);

						// path is to patch package that will be copied into the cache
						if(strPatchPackage.TextSize())
						{
							PMsiPath pPatchSourcePath(0);
							MsiString strPatchName;
							piErrRec = m_riServices.CreateFilePath(strPatchPackage, *&pPatchSourcePath, *&strPatchName);
							if (piErrRec)
								return piErrRec;

							unsigned int uiPatchSize;
							piErrRec = pPatchSourcePath->FileSize(strPatchName, uiPatchSize);
							if (piErrRec)
								return piErrRec;

							unsigned int uiClusteredSize;
							if ((piErrRec = pMsiPath->ClusteredFileSize(uiPatchSize, uiClusteredSize)) != 0)
								return piErrRec;
							
							m_iPatchPackagesCost += uiClusteredSize;
						}
					}
				}
				else if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
					return piErrRec;
				else
				{
					piErrRec->Release();
					piErrRec = 0;
				}

			}
			// else uninstalling // TODO: cost for uninstall
		}

		rpiPath = pMsiPath;
		rpiPath->AddRef();

		iCost = m_iPatchPackagesCost;
		iNoRbCost = iCost;
		fValidEnum = fTrue;
	}

	return 0;
}


IMsiRecord* CMsiEngine::DetermineEngineCost(int* piNetCost, int* piNetNoRbCost)
/*----------------------------------------------------------------
Internal function that allows the Engine itself to add any extra
disk costs to the VolumeCostTable.  The total costs are returned
in the piNetCost and piNetNoRbCost parameters, either of which
can be passed as NULL if the caller doesn't need those numbers.
-----------------------------------------------------------------*/
{
	PMsiPath pCostPath(0);
	int iIndex = 0;
	Bool fValidEnum = fFalse;
	if (piNetCost) *piNetCost = 0;
	if (piNetNoRbCost) *piNetNoRbCost = 0;
	do
	{
		for (int x = 0;x < 2;x++)
		{
			// Two passes - one to remove the old costs, another to
			// add back the newly calculated cost.
			Bool fRecalc = x & 1 ? fTrue : fFalse;
			int iCostSign = fRecalc ? 1 : -1;
			int iCost = 0, iNoRbCost = 0;
			IMsiRecord* piErrRec = EnumEngineCosts(iIndex,fRecalc,fFalse,fValidEnum, *&pCostPath,iCost,iNoRbCost, NULL);
			if (piErrRec)
				return piErrRec;

			if (fValidEnum && (iCost != 0 || iNoRbCost != 0))
			{
				int iNetCost = iCostSign * iCost;
				int iNetNoRbCost = iCostSign * iNoRbCost;
				int iNetARPCost = iNetCost;
				int iNetARPNoRbCost = iNetNoRbCost;
				if (piNetCost && fRecalc) *piNetCost += iNetCost;
				if (piNetNoRbCost && fRecalc) *piNetNoRbCost += iNetNoRbCost;
				if ((piErrRec = AddCostToVolumeTable(pCostPath, iNetCost, iNetNoRbCost, iNetARPCost, iNetARPNoRbCost)) != 0)
					return piErrRec;
			}
		}
		iIndex++;
	}while (fValidEnum);
	return 0;
}


void CMsiEngine::EnableRollback(Bool fEnable)
{
	if(m_iioOptions & iioDisableRollback ||
		GetIntegerPolicyValue(szDisableRollbackValueName, fTrue) == 1 ||
		GetIntegerPolicyValue(szDisableRollbackValueName, fFalse) == 1 ||
		MsiString(GetPropertyFromSz(IPROPNAME_DISABLEROLLBACK)).TextSize())
	{
		fEnable = fFalse;
		Assert((GetMode() & iefRollbackEnabled) == 0);
	}


	// check if we are disabling rollback in the middle of script generation
	// (and it was enabled previously)
	if(fEnable == fFalse && (GetMode() & iefRollbackEnabled) && (GetMode() & iefOperations))
	{
		// probably called from DisableRollback action
		
		// if in the middle of script generation, we want rollback enabled for script execution
		// up to this point, but not after - so we need to put an opcode in the script to
		// mark when rollback is disabled
		PMsiRecord pNullRec = &CreateRecord(0);
		AssertNonZero(ExecuteRecord(ixoDisableRollback,*pNullRec) == iesSuccess);
		
		m_fDisabledRollbackInScript = fTrue; // set so RunScript knows to enable rollback for first part of script
	}

	
	// now actually set the flags
	SetMode(iefRollbackEnabled, fEnable);
	if (!fEnable)
		SetPropertyInt(*MsiString(*IPROPNAME_ROLLBACKDISABLED),1);
	else
		SetProperty(*MsiString(*IPROPNAME_ROLLBACKDISABLED), g_MsiStringNull);

}

//
// A version for those who want to determineEngineCost and don't care about the return value
//
IMsiRecord *CMsiEngine::DetermineEngineCostOODS()
{

	if (m_fCostingComplete)
	{
		IMsiRecord* piErrRec;
		
		if ((piErrRec = DetermineEngineCost(NULL, NULL)) != 0)
			return piErrRec;
	}

	DetermineOutOfDiskSpace(NULL, NULL);

	return 0;
}

Bool CMsiEngine::DetermineOutOfDiskSpace(Bool* pfOutOfNoRbDiskSpace, Bool* pfUserCancelled)
/*----------------------------------------------------------------------------
Walks through all the volumes in the VolumeCostTable, and returns fTrue (and
sets the "OutOfDiskSpace" and "OutOfNoRbDiskSpace" properties) if any volume
has insufficient space for the requirements placed on it.

Also, if all volumes have enough space assuming rollback were turned off,
fTrue will be returned in pfOutOfNoRbDiskSpace.  NULL can be passed for this
parameter.
------------------------------------------------------------------------------*/
{
	Bool fOutOfDiskSpace = fFalse;
	Bool fOutOfNoRbDiskSpace = fFalse;
	PMsiVolume pScriptVolume(0);

	Assert(!pfUserCancelled || !*pfUserCancelled);
	
	if (m_piVolumeCostTable && m_fCostingComplete)
	{
		// Make sure there's enough space currently available to
		// create the script file.  Note that we have to do this
		// up front, because even if we are uninstalling the entire
		// product, and thus eventually freeing up plenty of disk
		// space, we need room for to create the script before we
		// ever remove any files.
		PMsiPath pScriptPath(0);
		Bool fValidEnum;
		int iScriptCost, iNoRbScriptCost;

		// We'll possibly go through this loop twice. First time
		// we'll take a rough cut at the size of the script file.
		// the second time we'll get the exact number if the first time
		// showed we might be out of disk space
		int cCalc = 2;
		while (cCalc > 0)
		{
			// Reset these for second time through
			fOutOfDiskSpace = fFalse;
			fOutOfNoRbDiskSpace = fFalse;
			Bool fExact = ToBool(cCalc == 1);
			// And ask it to recalc if we're getting exact cost
			PMsiRecord pErrRec = EnumEngineCosts(1,fFalse,fExact,fValidEnum, *&pScriptPath,iScriptCost,iNoRbScriptCost, pfUserCancelled);
			if (pfUserCancelled && *pfUserCancelled)
				return fFalse;
			if (pScriptPath)
			{
				if (!(GetMode() & iefRollbackEnabled))
					iScriptCost = iNoRbScriptCost;

				pScriptVolume = &pScriptPath->GetVolume();
				int iFreeScriptSpace = pScriptVolume->FreeSpace();
				if (iScriptCost > iFreeScriptSpace)
				{
					fOutOfDiskSpace = fTrue;
				}

				if (iNoRbScriptCost >= iFreeScriptSpace)
				{
					fOutOfNoRbDiskSpace = fTrue;
				}
			}
			
			if (!fOutOfDiskSpace && !fOutOfNoRbDiskSpace)
				break;
			cCalc--;
		}
		
		PMsiVolume pPrimaryVolume(0);
		PMsiPath pPrimaryFolderPath(0);
		MsiString strPrimaryFolder = GetPropertyFromSz(IPROPNAME_PRIMARYFOLDER);
		PMsiRecord pErrRec = GetTargetPath(*strPrimaryFolder, *&pPrimaryFolderPath);
		if (!pErrRec)
		{
			pPrimaryVolume = &pPrimaryFolderPath->GetVolume();
		}

		if (!fOutOfDiskSpace || !fOutOfNoRbDiskSpace || pPrimaryVolume)
		{
			PMsiDatabase pDatabase(GetDatabase());
			PMsiCursor pVolCursor = m_piVolumeCostTable->CreateCursor(fFalse);
			Assert (pVolCursor);
			while (pVolCursor->Next())
			{
				PMsiVolume pVolume = (IMsiVolume*) pVolCursor->GetMsiData(m_colVolumeObject);
				Assert(pVolume);
				bool fAdjusted = false;
				int iVolCost = pVolCursor->GetInteger((GetMode() & iefRollbackEnabled) ? m_colVolumeCost : m_colNoRbVolumeCost);
				int iNoRbVolCost = pVolCursor->GetInteger(m_colNoRbVolumeCost);

				int iSpaceAvailable = 0;
				if (pVolume == pPrimaryVolume)
				{
					iSpaceAvailable = pVolume->FreeSpace();
					SetPropertyInt(*MsiString(*IPROPNAME_PRIMARYFOLDER_SPACEAVAILABLE), iSpaceAvailable);
					SetPropertyInt(*MsiString(*IPROPNAME_PRIMARYFOLDER_SPACEREQUIRED), iNoRbVolCost);
					SetPropertyInt(*MsiString(*IPROPNAME_PRIMARYFOLDER_SPACEREMAINING), iSpaceAvailable - iNoRbVolCost);
					SetProperty(*MsiString(*IPROPNAME_PRIMARYFOLDER_PATH),*MsiString(pVolume->GetPath()));
				}

				if (iVolCost > 0)
				{
					if (iSpaceAvailable == 0)
						iSpaceAvailable = pVolume->FreeSpace();
					if (iVolCost >= iSpaceAvailable)
					{
						if (!fOutOfDiskSpace && pVolume == pScriptVolume)
						{
							fAdjusted = AdjustForScriptGuess(iVolCost, iNoRbVolCost, iSpaceAvailable, pfUserCancelled);
							if (pfUserCancelled && *pfUserCancelled)
								return fFalse;
							if (iVolCost >= iSpaceAvailable)
								fOutOfDiskSpace = fTrue;
						}
						else
							fOutOfDiskSpace = fTrue;
					}
					if (iNoRbVolCost >= iSpaceAvailable)
					{
						if (!fOutOfNoRbDiskSpace && pVolume == pScriptVolume)
						{
							if (!fAdjusted)
							{
								AdjustForScriptGuess(iVolCost, iNoRbVolCost, iSpaceAvailable, pfUserCancelled);
								if (pfUserCancelled && *pfUserCancelled)
									return fFalse;
							}
							if (iNoRbVolCost >= iSpaceAvailable)
								fOutOfNoRbDiskSpace = fTrue;
						}
						else
							fOutOfNoRbDiskSpace = fTrue;
					}
				}
			}
		}
		SetPropertyInt(*MsiString(*IPROPNAME_OUTOFDISKSPACE),fOutOfDiskSpace);
		SetPropertyInt(*MsiString(*IPROPNAME_OUTOFNORBDISKSPACE),fOutOfNoRbDiskSpace);
	}

	if (pfOutOfNoRbDiskSpace)
		*pfOutOfNoRbDiskSpace = fOutOfNoRbDiskSpace;
	return fOutOfDiskSpace;
}


bool CMsiEngine::AdjustForScriptGuess(int& iVolCost, int &iNoRbVolCost, int iVolSpace, Bool* pfUserCancelled)
{
	PMsiPath pScriptPath(0);
	bool fRet = false;
	Assert(!pfUserCancelled || !*pfUserCancelled);
	// Not enough disk space on the Script Volume, and we didn't compute
	// exact number before, see if we can do better
	if (((iVolCost - m_iScriptCostGuess - m_iRollbackScriptCostGuess) <= iVolSpace) || (iNoRbVolCost - m_iScriptCostGuess <= iVolSpace))
	{
		Bool fValidEnum;
		int iScriptCost = 0, iNoRbScriptCost = 0;
		PMsiRecord pErrRec = EnumEngineCosts(1,fFalse,fTrue,fValidEnum, *&pScriptPath,iScriptCost,iNoRbScriptCost, pfUserCancelled);

		if (pfUserCancelled && *pfUserCancelled)
			return false;
		iVolCost = iVolCost + iScriptCost - m_iScriptCostGuess - m_iRollbackScriptCostGuess;
		iNoRbVolCost = iNoRbVolCost + iNoRbScriptCost - m_iScriptCostGuess;
		fRet = true;
	}
	
	return fRet;
}

void CMsiEngine::ResetComponentCostMarkers()
/*---------------------------------------------------------------------
Cost markers are used to mark components that have already been counted
during costing.  This is necessary because components can be shared
among Features, but the cost of a particular component needs to be
counted only once.
----------------------------------------------------------------------*/

{
	if (!m_piComponentTable)
		return;

	PMsiCursor pCursor(m_piComponentTable->CreateCursor(fFalse));
	pCursor->SetFilter(0);
	while (pCursor->Next())
	{
		int iRuntimeFlags = pCursor->GetInteger(m_colComponentRuntimeFlags) & ~bfComponentCostMarker;
		AssertNonZero(pCursor->PutInteger(m_colComponentRuntimeFlags,iRuntimeFlags));
		AssertNonZero(pCursor->Update());
	}
}

//
// Maximum number of columns from any one table
// used to set array sizes
//
#define ccolMax 6

const TTBD rgttbdRegistry[] =
{
	icdString + icdPrimaryKey, sztblRegistryAction_colRegistry,
	icdShort, sztblRegistryAction_colRoot,
	icdString, sztblRegistryAction_colKey,
	icdString + icdNullable, sztblRegistryAction_colName,
	icdString + icdNullable, sztblRegistryAction_colValue,
	icdString, sztblRegistryAction_colComponent,
	icdShort + icdNullable, sztblRegistryAction_colAction,
	icdShort + icdNullable, sztblRegistryAction_colActionRequest,
	icdShort, sztblComponent_colBinaryType,
	icdShort + icdNullable, sztblComponent_colAttributes,
};

const TTBD rgttbdFile[] =
{
	icdString + icdPrimaryKey, sztblFileAction_colFile,
	icdString, sztblFileAction_colFileName,
	icdLong + icdNullable, sztblFileAction_colState,
	icdLong + icdNullable, sztblFileAction_colFileSize,
	icdString, sztblFileAction_colComponent,
	icdString, sztblFileAction_colDirectory,
	icdLong + icdNullable, sztblFileAction_colInstalled,
	icdShort + icdNullable, sztblFileAction_colAction,
	icdLong + icdNullable, sztblComponent_colForceLocalFiles,
	icdString + icdNullable, sztblFileAction_colComponentId,
	icdShort, sztblComponent_colBinaryType,
};

IMsiRecord* CMsiEngine::CreateTempActionTable(ttblEnum ttblTable)
{
	IMsiRecord* piErr;
	IMsiTable** ppiTable;
	const ICHAR* pszTableName;
	const ICHAR* pszNewTableName;
	const TTBD* pttbd;
	int cttbd;
	int i;
	int colComponent, colComponentInComponent, colAction, colActionRequest, colRuntimeFlags;
	int rgcolTbl[ccolMax], rgcolComp[ccolMax];
	int cColTbl, cColComp;
	
	if (ttblTable == ttblRegistry)
	{
		// Temp table already created
		if (m_piRegistryActionTable != 0)
			return 0;

		ppiTable = &m_piRegistryActionTable;
		pszTableName = szRegistryTable;
		pszNewTableName = sztblRegistryAction;
		pttbd = rgttbdRegistry;
		cttbd = sizeof(rgttbdRegistry)/sizeof(TTBD);
	}
	else
	{
		Assert(ttblTable == ttblFile);
		if (m_piFileActionTable != 0)
			return 0;

		ppiTable = &m_piFileActionTable;
		pszTableName = sztblFile;
		pszNewTableName = sztblFileAction;
		
		pttbd = rgttbdFile;
		cttbd = sizeof(rgttbdFile)/sizeof(TTBD);
	}

	PMsiCursor pCursorNew(0);
	PMsiCursor pCursorOld(0);
	PMsiCursor pCursorComp(0);
	
	PMsiTable pTableOld(0);
	PMsiTable pTableComp(0);
	
	piErr = m_piDatabase->LoadTable(*MsiString(*pszTableName), 0, *&pTableOld);
	if (piErr)
	{
		if(piErr->GetInteger(1) == idbgDbTableUndefined)
		{
			piErr->Release();
			return 0; // missing table so no data to process
		}
		else
			return piErr;
	}
	
	//
	// Guess that half the rows will be in the new table
	//
	piErr = m_piDatabase->CreateTable(*MsiString(*pszNewTableName), pTableOld->GetRowCount()/2, *ppiTable);
	if (piErr)
		return piErr;

	for (i = 0 ; i < cttbd ; i++)
	{
		(*ppiTable)->CreateColumn(pttbd[i].icd, *MsiString(*(pttbd[i].szColName)));
	}
	
	pCursorNew = (*ppiTable)->CreateCursor(fFalse);
	pCursorOld = pTableOld->CreateCursor(fFalse);

	// Get the Component column in the old table
	colComponent = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFile_colComponent));
	piErr = m_piDatabase->LoadTable(*MsiString(*sztblComponent), 0, *&pTableComp);

	if (piErr)
	{
		if(piErr->GetInteger(1) == idbgDbTableUndefined)
		{
			piErr->Release();
			return 0; // missing table so no data to process
		}
		else
			return piErr;
	}
	
	pCursorComp = pTableComp->CreateCursor(fFalse);
	// Get the Component column in the component table
	colComponentInComponent = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colComponent));
	colAction = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colAction));
	colActionRequest =      pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colActionRequest));
	colRuntimeFlags  = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colRuntimeFlags));
	// Now fill up the arrays with which columns we're interested in

	if (ttblTable == ttblRegistry)
	{
		// Get the Component column in the old table
		colComponent = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFile_colComponent));
		cColTbl = 6;
		rgcolTbl[0] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblRegistryAction_colRegistry));
		rgcolTbl[1] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblRegistryAction_colRoot));
		rgcolTbl[2] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblRegistryAction_colKey));
		rgcolTbl[3] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblRegistryAction_colName));
		rgcolTbl[4] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblRegistryAction_colValue));
		rgcolTbl[5] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblRegistryAction_colComponent));

		cColComp = 4;
		rgcolComp[0] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colAction));
		rgcolComp[1] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colActionRequest));
		rgcolComp[2] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colBinaryType));
		rgcolComp[3] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colAttributes));

	}
	else
	{
		cColTbl = 5;
		rgcolTbl[0] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileAction_colFile));
		rgcolTbl[1] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileAction_colFileName));
		rgcolTbl[2] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileAction_colState));
		rgcolTbl[3] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileAction_colFileSize));
		rgcolTbl[4] = pTableOld->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileAction_colComponent));

		cColComp = 6;
		rgcolComp[0] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colDirectory));
		rgcolComp[1] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colInstalled));
		rgcolComp[2] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colAction));
		rgcolComp[3] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colForceLocalFiles));
		rgcolComp[4] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colComponentId));
		rgcolComp[5] = pTableComp->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblComponent_colBinaryType));
	}

	int idComp;
	pCursorComp->SetFilter(iColumnBit(colComponentInComponent));
	
	while (pCursorOld->Next())
	{
		pCursorNew->Reset();
		idComp = pCursorOld->GetInteger(colComponent);
		pCursorComp->Reset();
		pCursorComp->PutInteger(colComponentInComponent, idComp);
		if (pCursorComp->Next())
		{
			// Skip all Null integer guys
			// NOTE: we are now also interested in the "guys" that were requested to be installed
			// but not actually selected for install, due to better component being around

			if (pCursorComp->GetInteger(colAction) == iMsiNullInteger &&
				(ttblTable != ttblRegistry || (pCursorComp->GetInteger(colRuntimeFlags) & bfComponentDisabled)|| pCursorComp->GetInteger(colActionRequest) == iMsiNullInteger))
				continue;
			int iColNew = 1;
			int id;
#ifdef DEBUG
			const ICHAR* pszTemp;
			pszTemp = (const ICHAR*)MsiString(pCursorOld->GetString(rgcolTbl[0]));
#endif
			// Move the items from the old table to the new table
			for (i = 0 ; i < cColTbl ; i++)
			{
				id = pCursorOld->GetInteger(rgcolTbl[i]);
				if (id != iMsiNullInteger)
					AssertNonZero(pCursorNew->PutInteger(iColNew, id));
				iColNew++;
			}
			// Move the items from the component table to the new table
			for (i = 0 ; i < cColComp ; i++)
			{
				id = pCursorComp->GetInteger(rgcolComp[i]);
				if (id != iMsiNullInteger)
					AssertNonZero(pCursorNew->PutInteger(iColNew, id));
				iColNew++;
			}
			
			AssertNonZero(pCursorNew->Insert());

		}
		else
			AssertSz(fFalse, "Component missing from component table.");
			
	}
	
	return 0;

}

IMsiRecord* CMsiEngine::GetFileHashInfo(const IMsiString& ristrFileKey, DWORD dwFileSize, MD5Hash& rhHash,
													 bool& fHashInfo)
// this function takes a record, with the file key in a designated field,
// and fills in the hash information for that file into the record in the indicated fields
{
	fHashInfo = false;
	
	if(m_fLookedForFileHashTable == false)
	{
		// haven't tried to open MsiFileHash table yet
		Assert(m_pFileHashCursor == 0);
		
		if(!m_piDatabase)
			return PostError(Imsg(idbgEngineNotInitialized));

		m_fLookedForFileHashTable = true;

		PMsiTable pFileHashTable(0);
		
		IMsiRecord* piError = m_piDatabase->LoadTable(*MsiString(sztblFileHash), 0, *&pFileHashTable);
		if (piError)
		{
			if(piError->GetInteger(1) == idbgDbTableUndefined)
			{
				// no table is fine
				piError->Release();
				return 0;
			}
			else
				return piError;
		}

		m_colFileHashKey     = pFileHashTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileHash_colFile));
		m_colFileHashOptions = pFileHashTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileHash_colOptions));
		m_colFileHashPart1   = pFileHashTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileHash_colPart1));
		m_colFileHashPart2   = pFileHashTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileHash_colPart2));
		m_colFileHashPart3   = pFileHashTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileHash_colPart3));
		m_colFileHashPart4   = pFileHashTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFileHash_colPart4));

		if(!m_colFileHashKey || !m_colFileHashOptions || !m_colFileHashPart1 || !m_colFileHashPart2 || !m_colFileHashPart3 || !m_colFileHashPart4)
		{
			return PostError(Imsg(idbgTableDefinition), sztblFileHash);
		}

		m_pFileHashCursor = pFileHashTable->CreateCursor(fFalse);
		m_pFileHashCursor->SetFilter(iColumnBit(m_colFileHashKey));
	}
	
	if(!m_pFileHashCursor)
	{
		// no cursor means no table means nothing to do
		return 0;
	}

	m_pFileHashCursor->Reset();
	AssertNonZero(m_pFileHashCursor->PutString(m_colFileHashKey, ristrFileKey));

	if(m_pFileHashCursor->Next())
	{
		// first 4 bits of options defines the hash type.  currently only supported type is
		//    0: MD5 hash
		// ignore any other type
		
		DWORD dwOptions = m_pFileHashCursor->GetInteger(m_colFileHashOptions);
		if((dwOptions & 0xF) == 0)
		{
			rhHash.dwOptions  = dwOptions;
			rhHash.dwFileSize = dwFileSize;
			rhHash.dwPart1    = m_pFileHashCursor->GetInteger(m_colFileHashPart1);
			rhHash.dwPart2    = m_pFileHashCursor->GetInteger(m_colFileHashPart2);
			rhHash.dwPart3    = m_pFileHashCursor->GetInteger(m_colFileHashPart3);
			rhHash.dwPart4    = m_pFileHashCursor->GetInteger(m_colFileHashPart4);

			fHashInfo = true;
		}
	}
	// else, no record for this file

	return 0;
}

const IMsiString& CMsiEngine::GetErrorTableString(int iError)
{
	MsiString strRet;
	ICHAR szQuery[256];
	wsprintf(szQuery, TEXT("SELECT `Message` FROM `Error` WHERE `Error` = %i"), iError);
	PMsiView pView(0);
	PMsiRecord pRec(0);
	bool fLookupDLL = true;
	if ((pRec = OpenView(szQuery, ivcFetch, *&pView)) == 0 && (pRec = pView->Execute(0)) == 0)
	{
		if ((pRec = pView->Fetch()))
		{
			fLookupDLL = false;
			strRet = pRec->GetMsiString(1);
		}
	}

	if ( fLookupDLL )
	{
		//  the error hasn't been found in the table or it is an empty string.
		HMODULE hLib = WIN::LoadLibraryEx(MSI_MESSAGES_NAME, NULL,
													 LOAD_LIBRARY_AS_DATAFILE);
		if ( hLib )
		{
			WORD wLanguage = (WORD)GetPropertyInt(*MsiString(IPROPNAME_INSTALLLANGUAGE));
			bool fEndLoop = false;
			int iRetry = (wLanguage == 0) ? 1 : 0;
			LPCTSTR szError = (iError == 0) ? TEXT("0") : MAKEINTRESOURCE(iError);

			while ( !fEndLoop )
			{
				if ( !MsiSwitchLanguage(iRetry, wLanguage) )
				{
					fEndLoop = true;
					continue;
				}

				HRSRC   hRsrc;
				HGLOBAL hGlobal;
				CHAR* szText;

				if ( (hRsrc = FindResourceEx(hLib, RT_RCDATA, szError, wLanguage)) != 0
					  && (hGlobal = LoadResource(hLib, hRsrc)) != 0
					  && (szText = (CHAR*)LockResource(hGlobal)) != 0
					  && *szText != 0 )
				{
					CTempBuffer<ICHAR, MAX_PATH> szBuffer;
					int cch = 0;
#ifdef UNICODE
					unsigned int iCodePage = MsiGetCodepage(wLanguage);
					cch = WIN::MultiByteToWideChar(iCodePage, 0, szText, -1, 0, 0);
					if ( cch )
					{
						szBuffer.SetSize(cch);
						AssertNonZero(WIN::MultiByteToWideChar(iCodePage, 0, szText, -1,
																			szBuffer, cch));
					}
#else
					cch = lstrlen(szText);
					if ( cch )
					{
						szBuffer.SetSize(cch+1);
						lstrcpy(szBuffer, szText);
					}
#endif // UNICODE
					if ( cch )
					{
						fEndLoop = true;
						strRet = (ICHAR*)szBuffer;
					}
				}       // if find & load resource

			}       // while ( !fEndLoop )
			AssertNonZero(WIN::FreeLibrary(hLib));

		}       // if ( hLib )
	}

	return strRet.Return();
}




const ICHAR szComponentFeatureTable[] = TEXT("CompFeatureTable");
//
// Creates a ComponentFeature table with the component as the first key
// to speed up searches
//
IMsiRecord* CMsiEngine::CreateComponentFeatureTable(IMsiTable*& rpiCompFeatureTable)
{
	IMsiRecord* piErr;
	PMsiTable pTable(0);

	piErr = m_piDatabase->LoadTable(*MsiString(*sztblFeatureComponents), 0, *&pTable);
	if (piErr)
		return piErr;

	piErr = m_piDatabase->CreateTable(*MsiString(*szComponentFeatureTable), pTable->GetRowCount(), rpiCompFeatureTable);
	if (piErr)
		return piErr;

	rpiCompFeatureTable->CreateColumn(icdString + icdPrimaryKey, *MsiString(*sztblFeatureComponents_colComponent));
	rpiCompFeatureTable->CreateColumn(icdString + icdPrimaryKey, *MsiString(*sztblFeatureComponents_colFeature));

	PMsiCursor pCursor = pTable->CreateCursor(fFalse);
	
	int colComponentInFC = pTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFeatureComponents_colComponent));
	int colFeatureInFC = pTable->GetColumnIndex(m_piDatabase->EncodeStringSz(sztblFeatureComponents_colFeature));

	PMsiCursor pCursorCF = rpiCompFeatureTable->CreateCursor(fFalse);
	
	while (pCursor->Next())
	{
		pCursorCF->Reset();
		AssertNonZero(pCursorCF->PutInteger(1, pCursor->GetInteger(colComponentInFC)));
		AssertNonZero(pCursorCF->PutInteger(2, pCursor->GetInteger(colFeatureInFC)));
		AssertNonZero(pCursorCF->Insert());
	}
	
	return 0;
	
}


////
// determines if it is safe for a managed install to be completely removed. If asking about a
// child install, this is the same as asking if this engine is managed. Otherwise, it has to
// be non-managed, an admin, not a full uninstall, or an upgrade by a managed install.
bool CMsiEngine::FSafeForFullUninstall(iremEnum iremUninstallType)
{
	switch (iremUninstallType)
	{
	case iremThis:
	{
		// figure out we have unlimited power (AlwaysInstallElevated policies are true)
		int iMachineElevate    = GetIntegerPolicyValue(szAlwaysElevateValueName, fTrue);
		int iUserElevate       = GetIntegerPolicyValue(szAlwaysElevateValueName, fFalse);
		// Admins can do anything they want, and creating an admin image or advertise script is not a problem
		if (!((iUserElevate == 1) && (iMachineElevate == 1)) && !IsAdmin() && (!(GetMode() & (iefAdmin | iefAdvertise))))
		{
			// if trying to completely remove a managed per-machine application
			if (m_fRunScriptElevated && MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() && !FFeaturesInstalled(*this))
			{
				// upgrades can remove a managed app if the parent (new version) is also managed,
				// otherwise they cannot. Nested installs and upgrades can be completely 
				// removed as long as the parent is elevated. (Presumably the parent is capable 
				// of correctly managing the lifetime of the child.) 
				if (m_piParentEngine)
				{
					return m_piParentEngine->FSafeForFullUninstall((m_iioOptions & iioUpgrade) ? iremChildUpgrade : iremChildNested);
				}

				// no parent engine, fully removing managed app, non admin, so not safe
				return false;
			}
		}

		// admin, creating advertise script, not fully removing product, not managed, or per-user
		return true;
	}
	case iremChildUpgrade:
	case iremChildNested:
	{
		// upgrades of a managed install can be removed if the new install is managed and per-machine as well.
		return m_fRunScriptElevated && MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize();
	}
	default:
		Assert(0);
		return false;
	}
}


IMsiRecord* GetServerPath(IMsiServices& riServices, bool fUNC, bool f64Bit, const IMsiString*& rpistrServerPath)
{
	IMsiRecord* piError = 0;
	ICHAR rgchPath[MAX_PATH + 50];
	Bool fFound = fFalse;
	PMsiPath pPath(0);
	MsiString strRegPath;
	MsiString strThisPath;
	MsiString strSystemPath;
	
	// 1st check our registry key if we're on Win64
	if (!g_fWin9X && g_fWinNT64)
	{
		CRegHandle riHandle;
		if (ERROR_SUCCESS == MsiRegOpen64bitKey(HKEY_LOCAL_MACHINE, szSelfRefMsiExecRegKey, 0, KEY_READ | KEY_WOW64_64KEY, &riHandle))
		{
			DWORD dwSize = MAX_PATH;
			if (ERROR_SUCCESS == RegQueryValueEx(riHandle, f64Bit ? szMsiExec64ValueName : szMsiExec32ValueName, 0, NULL, (LPBYTE)rgchPath, &dwSize))
			{
				MsiString strFileName;
				if ((piError = riServices.CreateFilePath(rgchPath,*&pPath,*&strFileName)) != 0)
					return piError;

				if ((piError = pPath->FileExists(MSI_SERVER_NAME, fFound)) != 0)
					return piError;

				strRegPath = pPath->GetPath();
			}
		}
	}

	// next try our current location, but only if its the correct type
#ifdef _WIN64
	if (!fFound && f64Bit)
#else
	if (!fFound && !f64Bit)
#endif
	{
		DWORD cch = 0;
		if (0 != (cch = WIN::GetModuleFileName(g_hInstance, rgchPath, MAX_PATH)))
		{
			Assert(cch < MAX_PATH);
			MsiString strFileName;
			if ((piError = riServices.CreateFilePath(rgchPath,*&pPath,*&strFileName)) != 0)
				return piError;

			if ((piError = pPath->FileExists(MSI_SERVER_NAME, fFound)) != 0)
				return piError;

			strThisPath = pPath->GetPath();
		}
	}

	// last chance, check the system directory
	if(!fFound)
	{
		// look in system directory
		DWORD cch = 0;
        
        cch = MsiGetSystemDirectory(rgchPath, MAX_PATH, f64Bit ? FALSE : TRUE);
		Assert(cch && cch <= MAX_PATH);
		MsiString strFileName;
		if ((piError = riServices.CreatePath(rgchPath,*&pPath)) != 0)
			return piError;
		
		if ((piError = pPath->FileExists(MSI_SERVER_NAME, fFound)) != 0)
			return piError;
			
		strSystemPath = pPath->GetPath();
	}

	if(!fFound)
	{
		// error: can't find server
		piError = &riServices.CreateRecord(5);
		ISetErrorCode(piError, Imsg(idbgServerMissing));
		AssertNonZero(piError->SetString(2,MSI_SERVER_NAME));
		AssertNonZero(piError->SetMsiString(3,*strSystemPath)); // current directory
		AssertNonZero(piError->SetMsiString(4,*strThisPath));   // system directory
		AssertNonZero(piError->SetMsiString(5,*strRegPath));    // registered directory (Win64 only)
		return piError;
	}

	Assert(pPath);
	MsiString strServerPath;
	if(fUNC)
		piError = pPath->GetFullUNCFilePath(MSI_SERVER_NAME,*&strServerPath);
	else
		piError = pPath->GetFullFilePath(MSI_SERVER_NAME,*&strServerPath);

	if(piError)
		return piError;

	strServerPath.ReturnArg(rpistrServerPath);

	return 0;
}

// look for cabinets beginning with '#', cabinets are in streams in database
// op will remove those streams from file
void CreateCabinetStreamList(IMsiEngine& riEngine, const IMsiString*& rpistrStreamList)
{
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiTable pMediaTable(0);
	PMsiRecord pRecErr(0);

	MsiString strStreams;
	int iColCabinet = 0;
	if((pRecErr = pDatabase->LoadTable(*MsiString(*TEXT("Media")),0,*&pMediaTable)) == 0 &&
		(iColCabinet = pMediaTable->GetColumnIndex(pDatabase->EncodeStringSz(TEXT("Cabinet")))) != 0)
	{
		PMsiCursor pCursor = pMediaTable->CreateCursor(fFalse);
		
		while(pCursor->Next())
		{
			MsiString strCabinet = pCursor->GetString(iColCabinet);
			if(strCabinet.Compare(iscStart,TEXT("#")))
			{
				strCabinet.Remove(iseFirst,1); // string '#'
				strStreams += strCabinet;
				strStreams += TEXT(";");
			}
		}
		strStreams.Remove(iseFrom, TEXT(';'));
	}

	strStreams.ReturnArg(rpistrStreamList);
}

// WININET functions not supported on IE3, but is there anyway.
// URLMON seems to work fine

BOOL MsiCombineUrl(
	IN LPCTSTR lpszBaseUrl,
	IN LPCTSTR lpszRelativeUrl,
	OUT LPTSTR lpszBuffer,
	IN OUT LPDWORD lpdwBufferLength,
	IN DWORD dwFlags)
{
	if (!WININET::InternetCombineUrl(lpszBaseUrl, lpszRelativeUrl, lpszBuffer, lpdwBufferLength, dwFlags))
	{
		DWORD dwLastError = WIN::GetLastError();
		if ((ERROR_PROC_NOT_FOUND == dwLastError) || (ERROR_CALL_NOT_IMPLEMENTED == dwLastError))
		{
			if (!IsURL(lpszBaseUrl))
			{
				WIN::SetLastError(ERROR_INTERNET_INVALID_URL);
				return FALSE;
			}

			int cchBase = lstrlen(lpszBaseUrl);
			int cchRelative = lstrlen(lpszRelativeUrl);

			BOOL fSepNeeded = (ICHAR('/') != lpszBaseUrl[cchBase-1]) && (ICHAR('/') != *lpszRelativeUrl);
			if (fSepNeeded)
				fSepNeeded = (ICHAR('\\') != lpszBaseUrl[cchBase-1]) && (ICHAR('\\') != *lpszRelativeUrl);

			// leave room for null and possibly separator.
			int cchBufferNeeded = cchBase+cchRelative + 1 /*NULL*/ + ((fSepNeeded) ? 1 : 0);
			if (cchBufferNeeded*sizeof(ICHAR) > *lpdwBufferLength)
			{
				*lpdwBufferLength = cchBufferNeeded*sizeof(ICHAR);
				WIN::SetLastError(ERROR_INSUFFICIENT_BUFFER);
				return FALSE;
			}

			DWORD dwExternalBufferLength = *lpdwBufferLength;
			*lpdwBufferLength = (cchBufferNeeded - 1 /*NULL*/) * sizeof(ICHAR);
			ICHAR* pchOutput;
			memcpy(lpszBuffer, lpszBaseUrl, cchBase*sizeof(ICHAR));
			pchOutput = lpszBuffer + cchBase;
			if (fSepNeeded)
			{
				*pchOutput++ = ICHAR('/');
			}
			memcpy(pchOutput, lpszRelativeUrl, cchRelative*sizeof(ICHAR));
			pchOutput += cchRelative;
			*pchOutput = ICHAR(0);
			AssertNonZero(MsiCanonicalizeUrl(lpszBuffer, lpszBuffer, &dwExternalBufferLength, dwFlags));

			return TRUE;
		}
		else
		{
			WIN::SetLastError(dwLastError);
			return FALSE;
		}
	}
	else
		return TRUE;
}

BOOL MsiCanonicalizeUrl(
	LPCTSTR lpszUrl,
	OUT LPTSTR lpszBuffer,
	IN OUT LPDWORD lpdwBufferLength,
	IN DWORD dwFlags)
{
	if (!WININET::InternetCanonicalizeUrl(lpszUrl, lpszBuffer, lpdwBufferLength, dwFlags))
	{
		DWORD dwLastError = WIN::GetLastError();
		if ((ERROR_PROC_NOT_FOUND == dwLastError) || (ERROR_CALL_NOT_IMPLEMENTED == dwLastError))
		{
			if (IsURL(lpszUrl))
			{
				int cchUrl = lstrlen(lpszUrl);

				// leave room for trailing null
				if ((cchUrl+1) * sizeof(ICHAR) > *lpdwBufferLength)
				{
					WIN::SetLastError(ERROR_INSUFFICIENT_BUFFER);
					*lpdwBufferLength = ((cchUrl+1) * sizeof(ICHAR));
					return FALSE;
				}

				// don't include NULL in outbound length
				*lpdwBufferLength = cchUrl*sizeof(ICHAR);
				memcpy(lpszBuffer, lpszUrl, *lpdwBufferLength);

				// null terminate the string
				lpszBuffer[cchUrl] = 0;
					
				// swap all the back slashes to forward slashes.
				ICHAR* pchOutbound = lpszBuffer;
				while (*pchOutbound)
				{
					if (ICHAR('\\') == *pchOutbound)
						*pchOutbound = ICHAR('/');
					pchOutbound++;
				}

				WIN::SetLastError(0);
				return TRUE;
			}
			else
			{
				WIN::SetLastError(ERROR_INTERNET_INVALID_URL);
				return FALSE;
			}
		}
		
		else
		{
			WIN::SetLastError(dwLastError);
			return FALSE;
		}
	}
	return TRUE;
}

Bool IsURL(const ICHAR* szPath, INTERNET_SCHEME* isType)
{
	// bad routine, for lack of a strncmp
	const DWORD cchMaxProtocolURL = 6;
	const DWORD cchMinProtocolURL = 4;

	DWORD cchLength = IStrLen(szPath);
	ICHAR szBuf[cchMaxProtocolURL+1]=TEXT("");

	if (cchMinProtocolURL > cchLength) return fFalse;
	IStrCopyLen(szBuf, szPath, cchMaxProtocolURL);
	if (!IStrCompI(szBuf, TEXT("https:")))
	{
		if (isType)
			*isType = INTERNET_SCHEME_HTTPS;
		return fTrue;
	}
	szBuf[5]=NULL;
	if (!IStrCompI(szBuf, TEXT("http:")))
	{
		if (isType)
			*isType = INTERNET_SCHEME_HTTP;
		return fTrue;
	}
   if (!IStrCompI(szBuf, TEXT("file:")))
	{
		if (isType)
			*isType = INTERNET_SCHEME_FILE;
		return fTrue;
	}
	szBuf[4]=NULL;
	if (!IStrCompI(szBuf, TEXT("ftp:")))
	{
		if (isType)
			*isType = INTERNET_SCHEME_FTP;
		return fTrue;
	}

	//!!REVIEW: gopher:?
	return fFalse;
}

void GetTempDirectory(CAPITempBufferRef<ICHAR>& rgchTempDir)
{
	Assert(g_scServerContext != scService); // if we want to make this callable from the service the GetMsiDirectory needs to stop using MsiStrings
	rgchTempDir[0] = 0;

	if (g_fWin9X)
	{
		// work around to Win9X behavior.  Bug #4036
		GetEnvironmentVariable(TEXT("TMP"),rgchTempDir);

		if(*rgchTempDir == 0)
			GetEnvironmentVariable(TEXT("TEMP"),rgchTempDir);
	}
	else
	{
		// on NT, GetTempPath is still the right thing to do.

// Apparently we're trying to hide GetTempPath behind
// a define in common.h to make sure that this function
// gets called instead.
#ifdef UNICODE
#define GetRealTempPath(X,Y) WIN::GetTempPathW(X,Y)
#else
#define GetRealTempPath(X,Y) WIN::GetTempPathA(X,Y)
#endif

		DWORD dwSize = rgchTempDir.GetSize();
		DWORD dwRet = GetRealTempPath(dwSize, (ICHAR*) rgchTempDir);
		
		if (dwRet > dwSize)
		{
			rgchTempDir.SetSize(dwRet);
			dwSize = dwRet;

			dwRet = GetRealTempPath(dwRet, (ICHAR*) rgchTempDir);
		}
		Assert(0 != dwRet);
	}
#undef GetRealTempPath

	bool fValidTemp = true;
	if (*rgchTempDir)
	{
		if (0xFFFFFFFF == MsiGetFileAttributes(rgchTempDir))
			fValidTemp = CreateDirectory(rgchTempDir, 0) ? true : false;
	}

	if(*rgchTempDir == 0 || !fValidTemp)
	{
		if(g_fWin9X)
		{
			MsiGetWindowsDirectory(rgchTempDir, rgchTempDir.GetSize());
		}
		else
		{
			GetEnvironmentVariable(TEXT("SystemDrive"),rgchTempDir);
		}

		Assert(*rgchTempDir);

		int cchLen = IStrLen(rgchTempDir);
		if(cchLen && rgchTempDir[cchLen-1] == '\\')
			rgchTempDir[cchLen-1] = 0;

		IStrCat(rgchTempDir,TEXT("\\TEMP"));

		if (0xFFFFFFFF == MsiGetFileAttributes(rgchTempDir))
			AssertNonZero(CreateDirectory(rgchTempDir, 0));
	}
}

const IMsiString& GetTempDirectory()
{
	if (g_scServerContext == scService)
	{
		return GetMsiDirectory();
	}
	else
	{
		CAPITempBuffer<ICHAR, MAX_PATH> rgchTempDir;
		GetTempDirectory(rgchTempDir);

		MsiString strTempFolder = (const ICHAR*)rgchTempDir;
		return strTempFolder.Return();
	}
}

const IMsiString& GetMsiDirectory()
{
	ICHAR rgchPath[MAX_PATH] = {0};

#ifdef DEBUG
	if(GetTestFlag('C'))
	{
		GetEnvironmentVariable(TEXT("_MSICACHE"), rgchPath, MAX_PATH);
		return MsiString(rgchPath).Return();
	}
#endif //DEBUG

	if (!MsiGetWindowsDirectory(rgchPath, sizeof(rgchPath)/sizeof(ICHAR)))
	{
		AssertNonZero(StartImpersonating());
		AssertNonZero(MsiGetWindowsDirectory(rgchPath, sizeof(rgchPath)/sizeof(ICHAR)));
		StopImpersonating();
	}
	MsiString strMsiDir = rgchPath;
	if (!strMsiDir.Compare(iscEnd, TEXT("\\")))
		strMsiDir += TEXT("\\");

	strMsiDir += szMsiDirectory;
	return strMsiDir.Return();
}


iptEnum PathType(const ICHAR* szPath)
{
	if(!szPath || IStrLen(szPath) == 0)
		return iptInvalid;
	
	if (IsURL(szPath))
		return iptFull;

	if ((szPath[0] < 0x7f && szPath[1] == ':') || (szPath[0] == '\\' && szPath[1] == '\\'))
		return iptFull;

	return iptRelative;
}

#ifndef DEBUG
inline
#endif
static void EnsureSharedDllsKey(IMsiServices& riServices)
{

	if (0 == g_piSharedDllsRegKey)
	{
		PMsiRegKey pLocalMachine = &riServices.GetRootKey(rrkLocalMachine, ibtCommon);
		g_piSharedDllsRegKey = &pLocalMachine->CreateChild(szSharedDlls);
	}
	if (g_fWinNT64 && 0 == g_piSharedDllsRegKey32)
	{
		PMsiRegKey pLocalMachine = &riServices.GetRootKey(rrkLocalMachine, ibt32bit);
		g_piSharedDllsRegKey32 = &pLocalMachine->CreateChild(szSharedDlls);
	}
}

static IMsiRegKey* GetSharedDLLKey(IMsiServices& riServices,
											  ibtBinaryType iType)
{
	EnsureSharedDllsKey(riServices);
	IMsiRegKey* pSharedDllKey = 0;
	bool fAssigned = false;
	if ( g_fWinNT64 )
	{
		if ( iType == ibt64bit )
		{
			fAssigned = true;
			pSharedDllKey = g_piSharedDllsRegKey;
		}
		else if ( iType == ibt32bit )
		{
			fAssigned = true;
			pSharedDllKey = g_piSharedDllsRegKey32;
		}
	}
	else if ( iType == ibt32bit )
	{
		fAssigned = true;
		pSharedDllKey = g_piSharedDllsRegKey;
	}
	if ( fAssigned )
	{
		if ( pSharedDllKey )
			pSharedDllKey->AddRef();
		else
			AssertSz(0, TEXT("g_piSharedDllsRegKey hasn't been initialized!"));
	}
	else
		AssertSz(0, TEXT("GetSharedDLLKey called with invalid ibtBinaryType argument!"));

	return pSharedDllKey;
}

static const ICHAR* GetRightSharedDLLPath(ibtBinaryType iType,
														const ICHAR* szFullFilePath)
{
	static ICHAR rgchFullFilePath[MAX_PATH+1];
	// clear previously returned string
	*rgchFullFilePath = 0;
	if ( g_fWinNT64 && iType == ibt32bit )
	{
		ieSwappedFolder iRes = g_Win64DualFolders.SwapFolder(ie32to64,
																	szFullFilePath,
																	rgchFullFilePath,
																	ieSwapForSharedDll);
		Assert(iRes != iesrError && iRes != iesrNotInitialized);
	}
	return *rgchFullFilePath ? rgchFullFilePath : szFullFilePath;
}

IMsiRecord* GetSharedDLLCount(IMsiServices& riServices,
										const ICHAR* szFullFilePath,
										ibtBinaryType iType,
										const IMsiString*& rpistrCount)
{
	PMsiRegKey pSharedDllKey = GetSharedDLLKey(riServices, iType);

	if ( pSharedDllKey )
	{
		const ICHAR* szPath = GetRightSharedDLLPath(iType, szFullFilePath);
		Assert(szPath);
		return pSharedDllKey->GetValue(szPath, *&rpistrCount);
	}

	return 0;
}

IMsiRecord* SetSharedDLLCount(IMsiServices& riServices,
										const ICHAR* szFullFilePath,
										ibtBinaryType iType,
										const IMsiString& ristrCount)
{
	PMsiRegKey pSharedDllKey = GetSharedDLLKey(riServices, iType);

	if ( pSharedDllKey )
	{
		const ICHAR* szPath = GetRightSharedDLLPath(iType, szFullFilePath);
		Assert(szPath);
		return pSharedDllKey->SetValue(szPath, ristrCount);
	}

	return 0;
}

//__________________________________________________________________________
//
// Global PostError routines
//
//   PostError:  create error record and report error to event log
//   PostRecord: create error record but don't report error to event log
//
//__________________________________________________________________________

IMsiRecord* PostError(IErrorCode iErr)
{
	IMsiRecord* piError = &CreateRecord(1);
	ISetErrorCode(piError, iErr);
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, int i)
{
	IMsiRecord* piError = &CreateRecord(2);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetInteger(2, i));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr)
{
	IMsiRecord* piError = &CreateRecord(2);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr, int i)
{
	IMsiRecord* piError = &CreateRecord(3);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr));
	AssertNonZero(piError->SetInteger(3, i));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr, int i1, int i2)
{
	IMsiRecord* piError = &CreateRecord(4);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr));
	AssertNonZero(piError->SetInteger(3, i1));
	AssertNonZero(piError->SetInteger(4, i2));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, int i, const IMsiString& ristr1, const IMsiString& ristr2)
{
	IMsiRecord* piError = &CreateRecord(4);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetInteger(2, i));
	AssertNonZero(piError->SetMsiString(3, ristr1));
	AssertNonZero(piError->SetMsiString(4, ristr2));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz)
{
	IMsiRecord* piError = &CreateRecord(2);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetString(2, sz));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, const ICHAR* sz2)
{
	IMsiRecord* piError = &CreateRecord(3);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetString(2, sz1));
	AssertNonZero(piError->SetString(3, sz2));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, const ICHAR* sz2,
												 const ICHAR* sz3)
{
	IMsiRecord* piError = &CreateRecord(4);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetString(2, sz1));
	AssertNonZero(piError->SetString(3, sz2));
	AssertNonZero(piError->SetString(4, sz3));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, int i, const ICHAR* sz)
{
	IMsiRecord* piError = &CreateRecord(3);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetInteger(2, i));
	AssertNonZero(piError->SetString(3, sz));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz, int i)
{
	IMsiRecord* piError = &CreateRecord(3);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetString(2, sz));
	AssertNonZero(piError->SetInteger(3, i));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, const ICHAR* sz2, int i)
{
	IMsiRecord* piError = &CreateRecord(4);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetString(2, sz1));
	AssertNonZero(piError->SetString(3, sz2));
	AssertNonZero(piError->SetInteger(4, i));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, const ICHAR* sz2, int i, const ICHAR* sz3)
{
    IMsiRecord* piError = &CreateRecord(5);
    ISetErrorCode(piError, iErr);
    AssertNonZero(piError->SetString(2, sz1));
    AssertNonZero(piError->SetString(3, sz2));
    AssertNonZero(piError->SetInteger(4, i));
    AssertNonZero(piError->SetString(5, sz3));
    DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
    return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const ICHAR* sz1, int i, const ICHAR* sz2, const ICHAR* sz3, const ICHAR* sz4)
{
    IMsiRecord* piError = &CreateRecord(6);
    ISetErrorCode(piError, iErr);
    AssertNonZero(piError->SetString(2, sz1));
    AssertNonZero(piError->SetInteger(3, i));
    AssertNonZero(piError->SetString(4, sz2));
    AssertNonZero(piError->SetString(5, sz3));
    AssertNonZero(piError->SetString(6, sz4));
    DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
    return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr1, const IMsiString& ristr2,
							 int i1)
{
	IMsiRecord* piError = &CreateRecord(4);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr1));
	AssertNonZero(piError->SetMsiString(3, ristr2));
	AssertNonZero(piError->SetInteger(4, i1));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr1, const IMsiString& ristr2,
							 int i1, int i2)
{
	IMsiRecord* piError = &CreateRecord(5);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr1));
	AssertNonZero(piError->SetMsiString(3, ristr2));
	AssertNonZero(piError->SetInteger(4, i1));
	AssertNonZero(piError->SetInteger(5, i2));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr1, const IMsiString& ristr2,
							 const IMsiString& ristr3, const IMsiString& ristr4)
{
	IMsiRecord* piError = &CreateRecord(5);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr1));
	AssertNonZero(piError->SetMsiString(3, ristr2));
	AssertNonZero(piError->SetMsiString(4, ristr3));
	AssertNonZero(piError->SetMsiString(5, ristr4));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr1, const IMsiString& ristr2,
							 const IMsiString& ristr3)
{
	IMsiRecord* piError = &CreateRecord(4);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr1));
	AssertNonZero(piError->SetMsiString(3, ristr2));
	AssertNonZero(piError->SetMsiString(4, ristr3));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, const IMsiString& ristr1, const IMsiString& ristr2)
{
	IMsiRecord* piError = &CreateRecord(3);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetMsiString(2, ristr1));
	AssertNonZero(piError->SetMsiString(3, ristr2));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

IMsiRecord* PostError(IErrorCode iErr, int i1, const ICHAR* sz1, int i2, const ICHAR* sz2,
							 const ICHAR* sz3)
{
	IMsiRecord* piError = &CreateRecord(6);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetInteger(2, i1));
	AssertNonZero(piError->SetString(3, sz1));
	AssertNonZero(piError->SetInteger(4, i2));
	AssertNonZero(piError->SetString(5, sz2));
	AssertNonZero(piError->SetString(6, sz3));
	DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
	return piError;
}

// PostRecord fns don't report to event log

IMsiRecord* PostRecord(IErrorCode iErr)
{
	IMsiRecord* piError = &CreateRecord(1);
	ISetErrorCode(piError, iErr);
	return piError;
}

IMsiRecord* PostRecord(IErrorCode iErr, int i)
{
	IMsiRecord* piError = &CreateRecord(2);
	ISetErrorCode(piError, iErr);
	AssertNonZero(piError->SetInteger(2, i));
	return piError;
}


// COMPAT CHECK FUNCTIONS

const int iInvalidDirectoryRootMaxSchema = 150; // only allow invalid Directory table root DefaultDir properties
                                                // for packages less then 150

bool CMsiEngine::FPerformAppcompatFix(iacsAppCompatShimFlags iacsFlag)
{
	if(iacsFlag == iacsAcceptInvalidDirectoryRootProps)
	{
		return ((m_iDatabaseVersion == iMsiStringBadInteger || m_iDatabaseVersion < iInvalidDirectoryRootMaxSchema) &&
			GetMode() & iefCabinet); // NOTE: this may be checking the sourcetype of the cached package, which is ok
	}
	else
	{
		return (m_iacsShimFlags & (int)iacsFlag) ? true : false;
	}
}


CMsiStringNullCopy MsiString::s_NullString;  // initialized by InitializeClass below


extern "C" int __stdcall ProxyDllMain(HINSTANCE hInst, DWORD fdwReason, void* pvreserved);
extern void GetVersionInfo(int* piMajorVersion, int* piMinorVersion, int* piWindowsBuild, bool* pfWin9X, bool* pfWinNT64);

REGSAM g_samRead;
void InitializeModule()
{
	ProxyDllMain(g_hInstance, DLL_PROCESS_ATTACH, 0);
	MsiString::InitializeClass(g_MsiStringNull);
	GetVersionInfo(&g_iMajorVersion, &g_iMinorVersion, &g_iWindowsBuild, &g_fWin9X, &g_fWinNT64);

	// initialize the global read sam for ability to read Win64 hive from win32 msi
	g_samRead = KEY_READ;
#ifndef _WIN64
	if(g_fWinNT64)
		g_samRead |= KEY_WOW64_64KEY;
#endif
}

extern CMsiAPIMessage       g_message;
extern EnumEntityList g_EnumProducts;
extern EnumEntityList g_EnumComponentQualifiers;
extern EnumEntityList g_EnumComponents;
extern EnumEntityList g_EnumComponentClients;
extern EnumEntityList g_EnumAssemblies;
extern EnumEntityList g_EnumComponentAllClients;
extern CSharedCount g_SharedCount;
extern CFeatureCache g_FeatureCache;
extern CRFSCachedSourceInfo g_RFSSourceCache;

void TerminateModule()
{
	AssertZero(CheckAllHandlesClosed(false, WIN::GetCurrentThreadId()));
	g_message.Destroy();

	g_EnumProducts.Destroy();
	g_EnumComponentQualifiers.Destroy();
	g_EnumComponents.Destroy();
	g_EnumComponentClients.Destroy();
	g_EnumAssemblies.Destroy();
	g_EnumComponentAllClients.Destroy();
	g_SharedCount.Destroy();
	g_FeatureCache.Destroy();
	g_RFSSourceCache.Destroy();
	//
	// We allocate this TLS slot only once and then hold on to it as long
	// as we are loaded. So we need to free it here otherwise we end up
	// leaking TLS slots every time someone loads and unloads us. Over a 
	// period of time, it causes that process to run out of TLS slots and 
	// then we can end up in all sorts of trouble.
	//
	if (INVALID_TLS_SLOT != g_dwImpersonationSlot)
	{
		AssertNonZero(TlsFree(g_dwImpersonationSlot));
		g_dwImpersonationSlot = INVALID_TLS_SLOT;
	}
	ProxyDllMain(g_hInstance, DLL_PROCESS_DETACH, 0);
}

#if defined(TRACK_OBJECTS)
//____________________________________________________________________________
//
// Array of mappings for tracking objects
//____________________________________________________________________________

Bool CMsiRef<iidMsiConfigurationManager>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiServices>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiDatabase>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiCursor>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiTable>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiView>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiRecord>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiStream>::m_fTrackClass = fFalse;
Bool CMsiRef<iidMsiStorage>::m_fTrackClass = fFalse;

#ifdef cmitObjects
extern const MIT rgmit[cmitObjects];

const MIT       rgmit[cmitObjects] =
{
	iidMsiConfigurationManager, &(CMsiRef<iidMsiConfigurationManager>::m_fTrackClass),
	iidMsiServices, &(CMsiRef<iidMsiServices>::m_fTrackClass),
	iidMsiDatabase, &(CMsiRef<iidMsiDatabase>::m_fTrackClass),
	iidMsiCursor,   &(CMsiRef<iidMsiCursor>::m_fTrackClass),
	iidMsiTable,    &(CMsiRef<iidMsiTable>::m_fTrackClass),
	iidMsiView,             &(CMsiRef<iidMsiView>::m_fTrackClass),
	iidMsiRecord,   &(CMsiRef<iidMsiRecord>::m_fTrackClass),
	iidMsiStream,           &(CMsiRef<iidMsiStream>::m_fTrackClass),
	iidMsiStorage,  &(CMsiRef<iidMsiStorage>::m_fTrackClass),
};
#endif // cmitObjects


#endif //TRACK_OBJECTS

void CWin64DualFolders::Clear()
{
	if ( m_prgFolderPairs )
	{
		delete [] m_prgFolderPairs;
		m_prgFolderPairs = NULL;
	}
}

bool CWin64DualFolders::CopyArray(const strFolderPairs* pArg)
{
	if ( pArg != m_prgFolderPairs )
	{
		Clear();
		if ( !pArg )
			return true;
		// counting the non-null elements in pArg
		for (int iCount = 0; 
			  pArg[iCount].str64bit.TextSize() && pArg[iCount].str32bit.TextSize();
			  iCount++)
			;
		Assert(iCount > 0);  // this is the way it was intended to work
		m_prgFolderPairs = new strFolderPairs[iCount+1];
		if ( !m_prgFolderPairs )
		{
			Assert(0);  // fairly impossible
			return false;
		}
		// copying the array
		for (int i = 0; i <= iCount; i++)
		{
			m_prgFolderPairs[i].str64bit = pArg[i].str64bit;
			m_prgFolderPairs[i].str32bit = pArg[i].str32bit;
			m_prgFolderPairs[i].iSwapAttrib = pArg[i].iSwapAttrib;
		}
	}
	return true;
}

CWin64DualFolders& CWin64DualFolders::operator = (const CWin64DualFolders& Arg)
{
	if ( this != &Arg )
	{
		CopyArray(Arg.m_prgFolderPairs);
		m_f32bitPackage = Arg.m_f32bitPackage;
	}
	return *this;
}

ieIsDualFolder CWin64DualFolders::IsWin64DualFolder(ieFolderSwapType iConvertFrom,
												const ICHAR* szCheckedFolder,
												int& iSwapAttrib,
												int* iCharsToSubstite,
												ICHAR* szToSubstituteWith)
{
	if ( !m_prgFolderPairs )
		return ieisNotInitialized;
	else if ( !g_fWinNT64 )
		return ieisNotWin64DualFolder;

	for (int iIndex = 0;
		  m_prgFolderPairs[iIndex].str64bit.TextSize() && m_prgFolderPairs[iIndex].str32bit.TextSize();
		  iIndex++ )
	{
		ICHAR* szToCheckAgainst;
		ICHAR* szToReplaceWith;
		int iToCheckLen;
		int iToReplaceLen;
		if ( iConvertFrom == ie32to64 )
		{
			szToCheckAgainst = (ICHAR*)(const ICHAR*)m_prgFolderPairs[iIndex].str32bit;
			iToCheckLen = m_prgFolderPairs[iIndex].str32bit.TextSize();
			szToReplaceWith = (ICHAR*)(const ICHAR*)m_prgFolderPairs[iIndex].str64bit;
			iToReplaceLen = m_prgFolderPairs[iIndex].str64bit.TextSize();
		}
		else
		{
			szToCheckAgainst = (ICHAR*)(const ICHAR*)m_prgFolderPairs[iIndex].str64bit;
			iToCheckLen = m_prgFolderPairs[iIndex].str64bit.TextSize();
			szToReplaceWith = (ICHAR*)(const ICHAR*)m_prgFolderPairs[iIndex].str32bit;
			iToReplaceLen = m_prgFolderPairs[iIndex].str32bit.TextSize();
		}
		int iLen = IStrLen(szCheckedFolder);
		int iLimit;
		bool fSkippedSep = false;
		if ( szToCheckAgainst[iToCheckLen-1] == chDirSep )
		{
			if ( iLen < iToCheckLen - 1 )
				// the folder passed in as an argument cannot be compared
				// with szToCheckAgainst since it's too short
				continue;
			else if ( iLen == iToCheckLen - 1 )
			{
				// szCheckedFolder doesn't extend up to szToCheckAgainst's
				// trailing chDirSep
				iLimit = iLen;
				fSkippedSep = true;
			}
			else
				iLimit = iToCheckLen;
		}
		else
		{
			// the array should be initialized from properties so
			// that we should never get here
			Assert(0);
			continue;
		}
		if ( !IStrNCompI(szToCheckAgainst, szCheckedFolder, iLimit) )
		{
			if ( szToSubstituteWith )
			{
				IStrCopy(szToSubstituteWith, szToReplaceWith);
				if ( fSkippedSep )
				{
					if ( szToSubstituteWith[iToReplaceLen-1] == chDirSep )
						szToSubstituteWith[iToReplaceLen-1] = 0;
				}
			}
			if ( iCharsToSubstite )
				*iCharsToSubstite = iLimit;
			iSwapAttrib = m_prgFolderPairs[iIndex].iSwapAttrib;
			return ieisWin64DualFolder;
		}
	}
	iSwapAttrib = ieSwapInvalid;
	return iIndex ? ieisNotWin64DualFolder : ieisNotInitialized;
}

ieSwappedFolder CWin64DualFolders::SwapFolder(ieFolderSwapType iConvertFrom,
												const ICHAR* szFolder,
												ICHAR* szSubstituted,
												int iSwapMask)
{
	ICHAR szToSubstituteWith[MAX_PATH+1] = {0};
	int iToSubstituteLen = 0;
	int iSwapAttrib = ieSwapInvalid;
	ieIsDualFolder iRet = IsWin64DualFolder(iConvertFrom, szFolder, iSwapAttrib,
														 &iToSubstituteLen, szToSubstituteWith);
	if ( iRet == ieisNotWin64DualFolder )
		return iesrNotSwapped;
	else if ( iRet == ieisNotInitialized )
	{
		Assert(0);
		return iesrNotInitialized;
	}
	else if ( iToSubstituteLen <= 0 )
	{
		Assert(0);
		return iesrError;
	}
	else if ( !*szToSubstituteWith )
	{
		Assert(0);
		return iesrError;
	}
	// OK, we've found what we want to substitute with, now we need
	// to figure out if the substitution is appropriate.
	bool fToSubstitute = false;
	if ( iSwapMask == ieSwapAlways )
		fToSubstitute = true;
	else
	{
		ICHAR rgchBuffer[MAX_PATH+1];
		bool fError = false;
		if ( !strFolderPairs::IsValidSwapAttrib(iSwapMask) )
		{
			wsprintf(rgchBuffer,
				TEXT("WIN64DUALFOLDERS: %d is an invalid mask argument!"),
				iSwapMask);
			AssertSz(0, rgchBuffer);
			DEBUGMSG(rgchBuffer);
			fError = true;
		}
		else if ( !strFolderPairs::IsValidSwapAttrib(iSwapAttrib) )
		{
			wsprintf(rgchBuffer,
				TEXT("WIN64DUALFOLDERS: %d is an invalid iSwapAttrib folder pair member!"),
				iSwapAttrib);
			AssertSz(0, rgchBuffer);
			DEBUGMSG(rgchBuffer);
			fError = true;
		}
		if ( fError )
			// there was some error setting the limitation, so that we do not set any.
			fToSubstitute = true;
		else
			fToSubstitute = (iSwapMask & iSwapAttrib) ? true : false;
	}
	if ( !fToSubstitute )
	{
		DEBUGMSG3(TEXT("WIN64DUALFOLDERS: Substitution in \'%s\' folder had ")
			TEXT("been blocked by the %d mask argument (the folder pair's iSwapAttrib ")
			TEXT("member = %d)."), szFolder, (const ICHAR*)(INT_PTR)iSwapMask,
			(const ICHAR*)(INT_PTR)iSwapAttrib);
		return iesrNotSwapped;
	}
	DEBUGMSG5(TEXT("WIN64DUALFOLDERS: \'%s\' will substitute %d characters ")
		TEXT("in \'%s\' folder path. (mask argument = %d, the folder pair's ")
		TEXT("iSwapAttrib member = %d)."), szToSubstituteWith,
		(const ICHAR*)(INT_PTR)iToSubstituteLen, szFolder,
		(const ICHAR*)(INT_PTR)iSwapMask, (const ICHAR*)(INT_PTR)iSwapAttrib);
	IStrCopy(szSubstituted, szToSubstituteWith);
	if ( iToSubstituteLen < IStrLen(szFolder) )
		IStrCat(szSubstituted, szFolder+iToSubstituteLen);
	return iesrSwapped;
}

extern bool MakeFusionPath(const ICHAR* szFile, ICHAR* szFullPath);

// global fns to post assembly errors, in addition to posting error, this fn also logs the formatmessage string for the error

IMsiRecord* PostAssemblyError(const ICHAR* szComponentId, HRESULT hResult, const ICHAR* szInterface, const ICHAR* szFunction, const ICHAR* szAssemblyName)
{
	return PostAssemblyError(szComponentId, hResult, szInterface, szFunction, szAssemblyName, iatURTAssembly);
}

IMsiRecord* PostAssemblyError(const ICHAR* szComponentId, HRESULT hResult, const ICHAR* szInterface, const ICHAR* szFunction, const ICHAR* szAssemblyName, iatAssemblyType iatAT)
{
	HMODULE hLibmscorrc = 0;
	ICHAR szFullPath[MAX_PATH];
	ICHAR szMsgBuf[MAX_PATH];
	// first try the system, then, if not found and assembly is .net assembly, try mscorrc.dll
	if((WIN::FormatMessage(	FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_FROM_SYSTEM,
							0, 
							hResult, 
							0,
							szMsgBuf,
							(sizeof(szMsgBuf)/sizeof(ICHAR)), 
							0)) ||
		(	iatAT == iatURTAssembly && 
			MakeFusionPath(TEXT("mscorrc.dll"), szFullPath) && 		
			((hLibmscorrc = WIN::LoadLibraryEx(szFullPath, 0, LOAD_WITH_ALTERED_SEARCH_PATH | LOAD_LIBRARY_AS_DATAFILE)) != 0) &&
			WIN::LoadString(hLibmscorrc, HRESULT_CODE(hResult), szMsgBuf, (sizeof(szMsgBuf)/sizeof(ICHAR)))))

	{
		DEBUGMSG1(TEXT("Assembly Error:%s"), (const ICHAR*)szMsgBuf);
	}
	if(hLibmscorrc)
		WIN::FreeLibrary(hLibmscorrc);
	return PostError(Imsg(imsgAssemblyInstallationError), szComponentId, hResult, szInterface, szFunction, szAssemblyName);
}

#ifdef _X86_
#if !defined(PROFILE)
// So we don't pull in some unnecessary floating point routines.
extern "C" int _fltused = 1;
#endif // !PROFILE

#endif

#include "clibs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\dgtlsig.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       digtlsig.cpp
//
//--------------------------------------------------------------------------

#include "precomp.h"
#include <wincrypt.h>
#include <wintrust.h>
#include <softpub.h>
#include "tables.h"
#include "_engine.h"
#include "_dgtlsig.h"
#include "eventlog.h"

icrCompareResult MsiCompareSignatureCertificates(IMsiStream *piSignatureCert, CERT_CONTEXT const *psCertContext, const IMsiString& riFileName);
icrCompareResult MsiCompareSignatureHashes(IMsiStream *piSignatureHash, CRYPT_DATA_BLOB& sEncryptedHash, const IMsiString& riFileName);
void ReleaseWintrustStateData(GUID *pgAction, WINTRUST_DATA& sWinTrustData);

iesEnum GetObjectSignatureInformation(IMsiEngine& riEngine, const IMsiString& riTable, const IMsiString& riObject, IMsiStream*& rpiCertificate, IMsiStream*& rpiHash)
/*----------------------------------------------------------------------------------------------------------------------------------------------------------------
Checks if the given object needs a signature check and returns the certificate and hash streams in rpiCertificate and rpiHash

  Arguments:
	riEngine       -- [IN]  Installer engine object
	riTable        -- [IN]  Table to which object belongs (only Media is allowed)
	riObject       -- [IN]  Name of possibly signed object
	rpiCertificate -- [OUT] Certificate stream for signed object (un-modified if iesNoAction or iesFailure)
	rpiHash        -- [OUT] Hash stream for signed object (un-modified if iesNoAction or iesFailure)

  Return Values:
	iesNoAction   >> no signature check required
	iesSuccess    >> signature check required
	iesFailure    >> problem occurred

  Notes:
	1.  If the Table-Object pair is present in the MsiDigitalSignature table, the object must be signed (verified via WVT)
	2.  If a hash is present for the Table-Object pair, then the object must be signed AND its hash must match that authored in the MsiDigitalSignature table
	3.  The object must be signed AND its certificate must match that authored in the MsiDigitalSignature table
	4.  The presence of a hash in the MsiDigitalSignature table is optional
	5.  The certificate is required in the MsiDigitalSignature table.
----------------------------------------------------------------------------------------------------------------------------------------------------------------*/
{
	PMsiTable pDigSigTable(0);
	PMsiRecord pError(0);
	PMsiDatabase pDatabase = riEngine.GetDatabase();

	// init to 0 for none found
	rpiCertificate = 0;
	rpiHash = 0;

	// load the DigitalSignature table
	if ((pError = pDatabase->LoadTable(*MsiString(sztblDigitalSignature),0,*&pDigSigTable)) != 0)
		return iesNoAction; // DigitalSignature table not present so no signature verification required
	
	// determine the columns for the MsiDigitalSignature table
	int iColSigTable, iColSigObject, iColSigCert, iColSigHash;
	iColSigTable  = pDigSigTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblDigitalSignature_colTable));
	iColSigObject = pDigSigTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblDigitalSignature_colObject));
	iColSigCert   = pDigSigTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblDigitalSignature_colCertificate));
	iColSigHash   = pDigSigTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblDigitalSignature_colHash));
	if (0 == iColSigTable || 0 == iColSigObject || 0 == iColSigCert || 0 == iColSigHash)
	{
		// table definition error
		// non-ignorable authoring error (security reasons)
		PMsiRecord precError(PostError(Imsg(idbgTableDefinition), *MsiString(*sztblDigitalSignature)));
		return riEngine.FatalError(*precError);
	}

	// set up filter on cursor to look for this table-object pair in the MsiDigitalSignature table
	PMsiCursor pDigSigCursor = pDigSigTable->CreateCursor(fFalse);
	pDigSigCursor->PutString(iColSigTable, riTable);
	pDigSigCursor->PutString(iColSigObject, riObject);
	pDigSigCursor->SetFilter(iColumnBit(iColSigTable) | iColumnBit(iColSigObject));

	if (!pDigSigCursor->Next())
		return iesNoAction; // table-object not listed in MsiDigitalSignature table
	
	// all signed objects require a certificate check
	MsiStringId idCertificateKey = pDigSigCursor->GetInteger(iColSigCert);
	if (0 == idCertificateKey)
	{
		// non-nullable column -- must have a value
		// this is a non-ignorable authoring error (security reasons)
		MsiString strPrimaryKey(riTable.GetString());
		strPrimaryKey += TEXT(".");
		strPrimaryKey += riObject.GetString();
		PMsiRecord precError(PostError(Imsg(idbgNullInNonNullableColumn), *strPrimaryKey, 
			*MsiString(*sztblDigitalSignature_colCertificate), *MsiString(*sztblDigitalSignature)));
		return riEngine.FatalError(*precError);
	}

	// load the MsiDigitalCertificate table
	PMsiTable pDigCertTable(0);
	if((pError = pDatabase->LoadTable(*MsiString(sztblDigitalCertificate),0,*&pDigCertTable)) != 0)
	{
		// there is a foreign key to the MsiDigitalCertificate table, but the table is missing.
		// this is a non-ignorable authoring error (security reasons)
		PMsiRecord precError(PostError(Imsg(idbgBadForeignKey), pDatabase->DecodeString(idCertificateKey),
			*MsiString(*sztblDigitalSignature_colCertificate),*MsiString(*sztblDigitalSignature)));
		return riEngine.FatalError(*precError);
	}

	// determine columns of MsiDigitalCertificate table
	int iColCertCert, iColCertData;
	iColCertCert = pDigCertTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblDigitalCertificate_colCertificate));
	iColCertData = pDigCertTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblDigitalCertificate_colData));
	if (0 == iColCertCert || 0 == iColCertData)
	{
		// table definition error
		// non-ignorable authoring error (security reasons)
		PMsiRecord precError(PostError(Imsg(idbgTableDefinition), *MsiString(*sztblDigitalCertificate)));
		return riEngine.FatalError(*precError);
	}

	// set up filter on cursor to look for this certificate in the MsiDigitalCertificate table
	PMsiCursor pDigCertCursor = pDigCertTable->CreateCursor(fFalse);
	pDigCertCursor->PutInteger(iColCertCert, idCertificateKey);
	pDigCertCursor->SetFilter(iColumnBit(iColCertCert));
	if (!pDigCertCursor->Next())
	{
		// there is a foreign key to the MsiDigitalCertificate table, but the entry is missing.
		// This is a non-ignorable authoring error (security reasons).
		PMsiRecord precError(PostError(Imsg(idbgBadForeignKey), pDatabase->DecodeString(idCertificateKey),
			*MsiString(*sztblDigitalSignature_colCertificate),*MsiString(*sztblDigitalSignature)));
		return riEngine.FatalError(*precError);
	}

	// retrieve stream
	rpiCertificate = pDigCertCursor->GetStream(iColCertData);

	// retrieve hash
	rpiHash = pDigSigCursor->GetStream(iColSigHash);

	return iesSuccess;
}

icrCompareResult MsiCompareSignatureHashes(IMsiStream *piSignatureHash, CRYPT_DATA_BLOB& sEncryptedHash, const IMsiString& riFileName)
/*-----------------------------------------------------------------------------------------------------------------------------------
Returns the result of a comparision of two digital signature hashes

  Arguments:
	piSignatureHash -- [IN] Hash stream from MsiDigitalSignature table
	sEncryptedHash  -- [IN] Hash from signed object
	riFileName     -- [IN] Name of Signed Cabinet

  Returns:
	icrMatch       >> hashes match
	icrSizesDiffer >> hashes differ in size (precludes hash comparison)
	icrDataDiffer  >> hashes differ (sizes are the same)
	icrError       >> some error occurred
-----------------------------------------------------------------------------------------------------------------------------------*/
{
	// ensure at start of hash stream
	piSignatureHash->Reset();

	// get encoded hash sizes
	DWORD cbHash = sEncryptedHash.cbData;
	unsigned int cbMsiStoredHash = piSignatureHash->Remaining();

	// compare sizes
	if (cbHash != cbMsiStoredHash)
	{
		// hashes are different --> sizes do not match
		DEBUGMSGV1(TEXT("Hash of signed cab '%s' differs in size with the hash of the cab in the MsiDigitalSignature table"), riFileName.GetString());
		return icrSizesDiffer;
	}

	// set up data buffer
	BYTE *pbMsiStoredHash = new BYTE[cbMsiStoredHash];

	if (!pbMsiStoredHash)
	{
		// out of memory
		DEBUGMSGV(TEXT("Failed allocation -- Out of Memory"));
		return icrError;
	}

	// init to error
	icrCompareResult icr = icrError;

	// get encoded hashes
	piSignatureHash->GetData((void*)pbMsiStoredHash, cbMsiStoredHash);

	// compare hashes
	if (0 != memcmp((void*)sEncryptedHash.pbData, (void*)pbMsiStoredHash, cbHash))
	{
		// hashes don't match
		DEBUGMSGV1(TEXT("Hash of signed cab '%s' does not match hash authored in the MsiDigitalSignature table"), riFileName.GetString());
		icr = icrDataDiffer;
	}
	else
		icr = icrMatch;

	// clean-up
	delete [] pbMsiStoredHash;

	return icr;
}

icrCompareResult MsiCompareSignatureCertificates(IMsiStream *piSignatureCert, CERT_CONTEXT const *psCertContext, const IMsiString& riFileName)
/*-----------------------------------------------------------------------------------------------------------------------------------
Returns the result of a comparision of two digital signature certificates

  Arguments:
	piSignatureCert -- [IN] Certificate stream from MsiDigitalCertificate table
	psCertContext   -- [IN] Certificate from signed object
	riFileName     -- [IN] Name of Signed Cabinet

  Returns:
	icrMatch       >> certificates match
	icrSizesDiffer >> certificates differ in size (precludes certificate comparison)
	icrDataDiffer  >> certificates differ (sizes are the same)
	icrError       >> some error occurred
-----------------------------------------------------------------------------------------------------------------------------------*/
{
	// ensure at start of cert stream
	piSignatureCert->Reset();

	// get encoded cert sizes
	DWORD cbCert = psCertContext->cbCertEncoded;
	unsigned int cbMsiStoredCert = piSignatureCert->Remaining();

	// compare sizes
	if (cbCert != cbMsiStoredCert)
	{
		// certs are different -->> sizes do not match
		DEBUGMSGV1(TEXT("Certificate of signed cab '%s' differs in size with the certificate of the cab in the MsiDigitalCertificate table"), riFileName.GetString());
		return icrSizesDiffer;
	}

	// set up data buffers
	BYTE *pbMsiStoredCert = new BYTE[cbMsiStoredCert];

	if (!pbMsiStoredCert)
	{
		// out of memory
		DEBUGMSGV(TEXT("Failed allocation -- Out of Memory"));
		return icrError;
	}

	// init to error
	icrCompareResult icr = icrError;

	// get encoded certs
	piSignatureCert->GetData((void*)pbMsiStoredCert, cbMsiStoredCert);

	// compare certificates
	if (0 != memcmp((void*)psCertContext->pbCertEncoded, (void*)pbMsiStoredCert, cbCert))
	{
		// certs don't match
		DEBUGMSGV1(TEXT("Certificate of signed cab '%s' does not match certificate authored in the MsiDigitalCertificate table"), riFileName.GetString());
		icr = icrDataDiffer;
	}
	else
		icr = icrMatch;

	// clean-up
	delete [] pbMsiStoredCert;

	return icr;
}

void ReleaseWintrustStateData(GUID *pgAction, WINTRUST_DATA& sWinTrustData)
/*------------------------------------------------------------------------
Calls WinVerifyTrust (WVT) to release the WintrustStateData that had been
 preserved via a call to WVT with dwStateAction = WTD_STATEACTION_VERIFY

  Arguments:
	pgAction      -- [IN] Action Identifier
	sWinTrustData -- [IN] WinTrust data structure

  Returns:
	none
------------------------------------------------------------------------*/
{
	// update WINTRUST data struct
	sWinTrustData.dwUIChoice    = WTD_UI_NONE;           // no UI
	sWinTrustData.dwStateAction = WTD_STATEACTION_CLOSE; // release state

	// perform trust action w/ no interactive user
	WINTRUST::WinVerifyTrust(/*UI Window Handle*/(HWND)INVALID_HANDLE_VALUE, pgAction, &sWinTrustData);
}

icsrCheckSignatureResult MsiVerifyNonPackageSignature(const IMsiString& riFileName, HANDLE hFile, IMsiStream& riSignatureCert, IMsiStream * piSignatureHash, HRESULT& hrWVT)
/*-------------------------------------------------------------------------------------------------------------------------------------------------------
Determines whether or not the signed object is trusted.  A trusted object must pass two trust tests. . .
	1.  WinVerifyTrust validates the signature on the object (hash matches that in signature, certificate is properly formed)
	2.  Hash and Certificate of object match that stored in the MsiDigitalSignature and MsiDigitalCertificate tables in the package

  Arguments:
	riFileName      -- [IN] file name of object to verify (name of cabinet)
	hFile           -- [IN] handle to file to verify (can be INVALID_HANDLE_VALUE)
	riSignatureCert -- [IN] certificate stream stored in MsiDigitalCertificate table for object
	piSignatureHash -- [IN] hash stream stored in MsiDigitalSignature table for object

  Returns:
	icsrTrusted            >> signed object is trusted
	icsrNotTrusted         >> signed object is not trusted (least specific error)
	icsrNoSignature        >> object does not have a signature
	icsrBadSignature       >> signed object's hash or certificate are invalid (as determined by WVT)
	icsrWrongCertificate   >> signed object's certificate does not match that authored in MSI
	icsrWrongHash          >> signed object's hash does not match that authored in MSI
	icsrBrokenRegistration >> crypto registration is broken
	icsrMissingCrypto      >> crypto is not available on the machine

	hrWVT                  >> HRESULT return value from WinVerifyTrust
--------------------------------------------------------------------------------------------------------------------------------------------------------*/
{
	DEBUGMSGV1(TEXT("Authoring of MsiDigitalSignature table requires a trust check for CAB '%s'"), riFileName.GetString());

	// initialize trust
	icsrCheckSignatureResult icsrTrustValue = icsrNotTrusted; // init to an untrusted state

	// start impersonating -- needed because WVT policy state data is per-user
	CImpersonate Impersonate(true);

	// 
	// WVT is called twice
	//	1.  Actual trust verification with additional specification to hold onto the state data
	//  2.  Tell WVT to release the state data
	//

	//-------------------------------------------------------------
	// Step 1: Initialize WVT structure
	//-------------------------------------------------------------
	WINTRUST_DATA       sWinTrustData;
	WINTRUST_FILE_INFO  sFileData;

	const GUID guidCabSubject = WIN_TRUST_SUBJTYPE_CABINET;
	const GUID guidAction     = WINTRUST_ACTION_GENERIC_VERIFY_V2;

	// initialize structures to all 0
	memset((void*)&sWinTrustData, 0x00, sizeof(WINTRUST_DATA));
	memset((void*)&sFileData, 0x00, sizeof(WINTRUST_FILE_INFO));

	// set size of structures
	sWinTrustData.cbStruct = sizeof(WINTRUST_DATA);
	sFileData.cbStruct = sizeof(WINTRUST_FILE_INFO);

	// initialize WINTRUST_FILE_INFO struct -->> so Authenticode knows what it is verifying
	sFileData.pgKnownSubject = 0; // const_cast<GUID *>(&guidCabSubject); -->> shortcut
	sFileData.pcwszFilePath = CConvertString(riFileName.GetString());
	sFileData.hFile = hFile;

	// initialize WINTRUST_DATA struct
	sWinTrustData.pPolicyCallbackData = NULL;
	sWinTrustData.pSIPClientData = NULL;

	// set file information (cabinet)
	sWinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
	sWinTrustData.pFile = &sFileData;

	sWinTrustData.dwUIChoice = WTD_UI_NONE;	// no UI
	sWinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE; // no additional revocation checks are needed, those by provider are fine

	// save state
	sWinTrustData.dwStateAction = WTD_STATEACTION_VERIFY;


	//-------------------------------------------------------------
	// Step 2: 1st call to WVT, saving state data.  WVT will verify
	//   signature on signed cab (including whether hashes match
	//   and cert chain builds to a trusted root)
	//   * Use NO UI.
	//-------------------------------------------------------------
	hrWVT = WINTRUST::WinVerifyTrust(/*UI Window Handle*/(HWND)INVALID_HANDLE_VALUE, const_cast<GUID *>(&guidAction), &sWinTrustData);
	switch (hrWVT)
	{
	case ERROR_SUCCESS: // subject trusted according to WVT
		{
			icsrTrustValue =  icsrTrusted;
			break;
		}
	case TRUST_E_NOSIGNATURE: // subject is not signed
		{
			icsrTrustValue = icsrNoSignature;
			DEBUGMSGV1(TEXT("Cabinet '%s' does not have a digital signature."), riFileName.GetString());
			break;
		}
	case TRUST_E_BAD_DIGEST: // hash does not verify
		{
			DEBUGMSGV1(TEXT("Cabinet '%s' has an invalid hash.  It is possibly corrupted."), riFileName.GetString());
			icsrTrustValue = icsrBadSignature;
			break;
		}
	case TRUST_E_NO_SIGNER_CERT: // signer cert is missing
	case TRUST_E_SUBJECT_NOT_TRUSTED:
	case CERT_E_MALFORMED: // certificate is invalid
		{
			DEBUGMSGV2(TEXT("Digital signature on the '%s' cabinet is invalid.  WinVerifyTrust returned 0x%X"), riFileName.GetString(), (const ICHAR*)(INT_PTR)hrWVT);
			icsrTrustValue = icsrBadSignature;
			break;
		}
	case TRUST_E_PROVIDER_UNKNOWN:      // registration is broken
	case TRUST_E_ACTION_UNKNOWN:        // ...
	case TRUST_E_SUBJECT_FORM_UNKNOWN : // ...
		{
			DEBUGMSGV1(TEXT("Crypt registration is broken.  WinVerifyTrust returned 0x%X"), (const ICHAR*)(INT_PTR)hrWVT);
			icsrTrustValue = icsrBrokenRegistration;
			break;
		}
	case CERT_E_EXPIRED: // certificate has expired
		{
			// we have to trust the certificate (as long as it matches the authoring) because the MSI package could
			// have an extended lifetime
			icsrTrustValue = icsrTrusted;
			break;
		}
	case CERT_E_REVOKED: // certificate has been revoked
		{
			// not a common scenario, but it means that the certificate has ended up on a revocation list
			// this means that the private key of the certificate has been compromised
			DEBUGMSGV1(TEXT("The certificate in the digital signature for the '%s' cabinet has been revoked by its issuer"), riFileName.GetString());
			icsrTrustValue = icsrBadSignature;
			break;
		}
	case CERT_E_UNTRUSTEDROOT: // the root cert is not trusted
	case CERT_E_UNTRUSTEDTESTROOT: // the root cert which is the test root is not trusted
	case CERT_E_UNTRUSTEDCA: // one of the CA certs is not trusted
		{
			// we trust here because our trust relationship is determined by the trust of the toplevel object
			// as long as the certificate matches that which is authored (checked below), we are okay
			icsrTrustValue = icsrTrusted;
			break;
		}
	case TYPE_E_DLLFUNCTIONNOTFOUND: // failed to call WVT
		{
			// crypto is not installed on the machine and we couldn't call WinVerifyTrust
			DEBUGMSGE(EVENTLOG_WARNING_TYPE, EVENTLOG_TEMPLATE_WINVERIFYTRUST_UNAVAILABLE, riFileName.GetString());
			return icsrMissingCrypto;
		}
	default:
		{
			// must FAIL in the default case!
			DEBUGMSGV2(TEXT("Cabinet '%s' is not trusted.  WinVerifyTrust returned 0x%X"), riFileName.GetString(), (const ICHAR*)(INT_PTR)hrWVT);
			icsrTrustValue = icsrNotTrusted;
		}
	}

	//-------------------------------------------------------------
	// Step 3: Release State Data if subject is not trusted
	//-------------------------------------------------------------
	if (icsrTrusted != icsrTrustValue)
	{
		ReleaseWintrustStateData(const_cast<GUID *>(&guidAction), sWinTrustData);
		return icsrTrustValue;
	}
	
	//-------------------------------------------------------------
	// Step 4: Obtain provider data
	//-------------------------------------------------------------
	CRYPT_PROVIDER_DATA const *psProvData     = NULL;
	CRYPT_PROVIDER_SGNR       *psProvSigner   = NULL;
	CRYPT_PROVIDER_CERT       *psProvCert     = NULL;
	CMSG_SIGNER_INFO          *psSigner       = NULL;

	// grab the provider data
	psProvData = WINTRUST::WTHelperProvDataFromStateData(sWinTrustData.hWVTStateData);
	if (psProvData)
	{
		// grab the signer data from the CRYPT_PROV_DATA
		psProvSigner = WINTRUST::WTHelperGetProvSignerFromChain((PCRYPT_PROVIDER_DATA)psProvData, 0 /*first signer*/, FALSE /* not a counter signer */, 0);

		if (psProvSigner)
		{
			// grab the signer cert from CRYPT_PROV_SGNR (pos 0 = signer cert; pos csCertChain-1 = root cert)
			psProvCert = WINTRUST::WTHelperGetProvCertFromChain(psProvSigner, 0);
		}
	}

	//----------------------------------------------------------------
	// Step 5: Verify state data obtained, return and release if not
	//----------------------------------------------------------------
	if (!psProvData || !psProvSigner || !psProvCert)
	{
		// no state data!
		ReleaseWintrustStateData(const_cast<GUID *>(&guidAction), sWinTrustData);
		DEBUGMSGV(TEXT("Unable to obtain the saved state data from WinVerifyTrust"));
		return icsrMissingCrypto;
	}

	//----------------------------------------------------------------
	// Step 6: Compare Signed CAB cert to MSI stored cert
	//----------------------------------------------------------------
	if (icrMatch != MsiCompareSignatureCertificates(&riSignatureCert, psProvCert->pCert, riFileName))
	{
		ReleaseWintrustStateData(const_cast<GUID *>(&guidAction), sWinTrustData);
		return icsrWrongCertificate;
	}

	//----------------------------------------------------------------
	// Step 7: Compare Signed CAB hash to MSI stored hash
	//----------------------------------------------------------------
	if (!piSignatureHash)
	{
		DEBUGMSGV1(TEXT("Skipping Signed CAB hash to MSI stored hash comparison --> No authored hash in MsiDigitalSignature table for cabinet '%s'"), riFileName.GetString());
	}
	else if (icrMatch != MsiCompareSignatureHashes(piSignatureHash, psProvSigner->psSigner->EncryptedHash, riFileName))
	{
		ReleaseWintrustStateData(const_cast<GUID *>(&guidAction), sWinTrustData);
		return icsrWrongHash;
	}

	//----------------------------------------------------------------
	// Step 8: Release State Data and Return trusted
	//----------------------------------------------------------------
	DEBUGMSGV1(TEXT("CAB '%s' is a validly signed cab and validates according to authoring of MSI package"), riFileName.GetString());
	ReleaseWintrustStateData(const_cast<GUID *>(&guidAction), sWinTrustData);
	return icsrTrusted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\execute.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       execute.cpp
//
//--------------------------------------------------------------------------

 /* execute.cpp - IMsiExecute implementation

____________________________________________________________________________*/

#include "precomp.h" 

#include "_execute.h"
#include "eventlog.h"
#include "_srcmgmt.h"
#include <accctrl.h>
#include "_camgr.h"
#define REG_SELFREG_INFO // remove if self registration info unnecessary
#define MAX_NET_RETRIES 5

extern const IMsiString& g_riMsiStringNull;

//____________________________________________________________________________
//
// helper functions useful for clean up.
//____________________________________________________________________________

class CDeleteFileOnClose
{
 public:
	CDeleteFileOnClose(IMsiString const& ristrFileName) : m_ristrName(ristrFileName) { m_ristrName.AddRef(); }
	~CDeleteFileOnClose()
		{
			BOOL fDeleted = WIN::DeleteFile(m_ristrName.GetString());
			DWORD dwLastError = WIN::GetLastError();
	
			m_ristrName.Release();
			if (!fDeleted)
			{
				if (ERROR_FILE_NOT_FOUND == dwLastError)
					return;
				else
					AssertNonZero(fDeleted);
			}
		}
 protected:
	IMsiString const &m_ristrName;
};

class CDeleteEmptyDirectoryOnClose
{
 public:
	CDeleteEmptyDirectoryOnClose(IMsiString const& ristrName) : m_ristrName(ristrName) { m_ristrName.AddRef(); }
	~CDeleteEmptyDirectoryOnClose() { WIN::RemoveDirectory(m_ristrName.GetString()); m_ristrName.Release(); }
 protected:
	IMsiString const &m_ristrName;
};

// class that allows random IUnknown objects to be stored in columns of msi tables
// is derived from IMsiData, since database implementation expects object to be 
// derived from IMsiData

// smart pointer to wrap the CMsiDataWrapper pointer
class CMsiDataWrapper;typedef CComPointer<CMsiDataWrapper>  PMsiDataWrapper;

class CMsiDataWrapper: public IMsiData
{
public:
	HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj)
	{
		if (MsGuidEqual(riid, IID_IUnknown)
		 || MsGuidEqual(riid, IID_IMsiData))
		{
			*ppvObj = this;
			AddRef();
			return NOERROR;
		}
		*ppvObj = 0;
		return E_NOINTERFACE;
	}

	unsigned long __stdcall AddRef()
	{
		return ++m_iRefCnt;
	}
	unsigned long  __stdcall Release()
	{
		if (--m_iRefCnt != 0)
			return m_iRefCnt;
		if(m_pObj) // release member IUnknown object that we wrap
			m_pObj->Release();
		delete this;
		return 0;
	}
	const IMsiString& __stdcall GetMsiStringValue() const
	{
		return g_riMsiStringNull;// return irrelevant
	}

	int __stdcall GetIntegerValue() const
	{
		return iMsiNullInteger;// return irrelevant
	}

#ifdef USE_OBJECT_POOL
	unsigned int __stdcall GetUniqueId() const
	{
		return m_iCacheId;
	}

	void __stdcall SetUniqueId(unsigned int id)
	{
		Assert(m_iCacheId == 0);
		m_iCacheId = id;
	}
#endif //USE_OBJECT_POOL
	IUnknown* GetObject() const
	{
		if(m_pObj)
		{
			m_pObj->AddRef();
		}
		return m_pObj;
	}
	// helper fn to decipher the IUnknown object held by a CMsiDataWrapper object
	static IUnknown* GetWrappedObject(const IMsiData* piData)
	{
		CMsiDataWrapper* piDataWrapper = const_cast<CMsiDataWrapper*>(static_cast<const CMsiDataWrapper*> (piData));
		if(!piDataWrapper)
			return 0;
		else
			return piDataWrapper->GetObject();
	}

	friend CMsiDataWrapper* CreateMsiDataWrapper(IUnknown* piUnk);
protected:
	CMsiDataWrapper(IUnknown* piUnk)
	{
		m_iRefCnt = 1;     // we're returning an interface, passing ownership
		m_pObj = piUnk;
		if(m_pObj) // hold on to the IUnknown object we wrap
			m_pObj->AddRef();
#ifdef USE_OBJECT_POOL
		m_iCacheId = 0;
#endif //USE_OBJECT_POOL
	}
	int  m_iRefCnt;
	IUnknown* m_pObj;
#ifdef USE_OBJECT_POOL
    unsigned int  m_iCacheId;
#endif //USE_OBJECT_POOL
};

// CMsiDataWrapper creator fn.
CMsiDataWrapper* CreateMsiDataWrapper(IUnknown* piUnk)
{
	return new CMsiDataWrapper(piUnk);
}


#define LODWORD(d)           ((DWORD)(d))
#define HIDWORD(d)           ((DWORD)(((DWORDLONG)(d) >> 32) & 0xFFFFFFFF))
BOOL CALLBACK CMsiOpExecute::SfpProgressCallback(IN PFILEINSTALL_STATUS pFileInstallStatus, IN DWORD_PTR Context)
{
	CMsiOpExecute* pMsiOpExecute = (CMsiOpExecute*) Context;
	MsiString strFilePath = CConvertString(pFileInstallStatus->FileName);
	strFilePath.LowerCase();
	pMsiOpExecute->m_pFileCacheCursor->Reset();
	AssertNonZero(pMsiOpExecute->m_pFileCacheCursor->PutString(pMsiOpExecute->m_colFileCacheFilePath,*strFilePath));
	if (!pMsiOpExecute->m_pFileCacheCursor->Next())
	{
		DEBUGMSG1(TEXT("SFP has installed a file not found in our file cache - File installed: %s"), strFilePath);
		return true;
	}

	MsiString strPackageVersion = pMsiOpExecute->m_pFileCacheCursor->GetString(pMsiOpExecute->m_colFileCacheVersion);
	DWORD dwProtectedMS = HIDWORD(pFileInstallStatus->Version);
	DWORD dwProtectedLS = LODWORD(pFileInstallStatus->Version);
	MsiString strProtectedVersion = CreateVersionString(dwProtectedMS, dwProtectedLS);
	if (pFileInstallStatus->Win32Error == NO_ERROR)
	{
		DWORD dwPackageMS, dwPackageLS;
		AssertNonZero(ParseVersionString(strPackageVersion, dwPackageMS, dwPackageLS));
		if (CompareVersions(dwProtectedMS, dwProtectedLS, dwPackageMS, dwPackageLS) == icfvExistingLower)
		{
			imsEnum imsResult = pMsiOpExecute->DispatchError(imtEnum(imtError+imtOkCancel+imtDefault1), Imsg(imsgCannotUpdateProtectedFile),
				*strFilePath, *strPackageVersion, *strProtectedVersion);
			if (imsResult == imsCancel)
			{
				pMsiOpExecute->m_fSfpCancel = true;
			}
		}
		else
		{
			DEBUGMSG2(TEXT("File installed by SFP: %s, version: %s"), strFilePath, strProtectedVersion);
		}
	}
	else
	{
		imsEnum imsResult = pMsiOpExecute->DispatchError(imtEnum(imtError+imtOk), Imsg(imsgErrorUpdatingProtectedFile),
			*strFilePath, *strPackageVersion, *strProtectedVersion, pFileInstallStatus->Win32Error);
	}

	PMsiPath pPath(0);
	MsiString strFileName;
	iesEnum ies;
	if((ies = pMsiOpExecute->CreateFilePath(strFilePath, *&pPath, *&strFileName)) == iesSuccess)
	{
		unsigned int uiFileSize;
		PMsiRecord pRecErr(0);
		if ((pRecErr = pPath->FileSize(strFileName, uiFileSize)) == 0)
		{
			if(pMsiOpExecute->DispatchProgress(uiFileSize) == imsCancel)
				pMsiOpExecute->m_fSfpCancel = true;
		}
	}
	return pMsiOpExecute->m_fSfpCancel ? false : true;
}


Bool FGetTTFTitle(const ICHAR* szFile, const IMsiString*& rpiTitle); // from path.cpp
Bool GetExpandedProductInfo(const ICHAR* szProductCode, const ICHAR* szProperty,
										  CTempBufferRef<ICHAR>& rgchExpandedInfo, bool fPatch); // from engine.cpp

IMsiRecord* EnsureShortcutExtension(MsiString& rstrShortcutPath, IMsiServices& riServices); // from services.cpp

bool PrepareHydraRegistryKeyMapping(bool fTSPerMachineInstall); // from engine.cpp

static const ICHAR* DIR_CACHE               = TEXT("Installer");
static const ICHAR* DIR_SECURE_TRANSFORMS   = TEXT("SecureTransforms");

// constant strings used during registration
const ICHAR* g_szDefaultValue = TEXT("");
const ICHAR* g_szExtension = TEXT("Extension");
const ICHAR* g_szClassID = TEXT("CLSID");
const ICHAR* g_szContentType = TEXT("Content Type");
const ICHAR* g_szAssembly = TEXT("Assembly");
const ICHAR* g_szCodebase = TEXT("CodeBase");


// shortcut creation strings
const ICHAR szGptShortcutPrefix[] = TEXT("::{9db1186e-40df-11d1-aa8c-00c04fb67863}:");
const ICHAR szGptShortcutSuffix[] = TEXT("::");

// global strings for this file
const ICHAR szSessionManagerKey[] = TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager");
const ICHAR szPendingFileRenameOperationsValue[] = TEXT("PendingFileRenameOperations");
const ICHAR szBackupFolder[] = TEXT("Config.Msi"); // not localized

// strings that define the data type of the value written by ProcessRegInfo
const ICHAR g_chTypeIncInteger = 'n';
const ICHAR g_szTypeIncInteger[] = TEXT("n");
const ICHAR g_chTypeInteger = 'i'; // integer
const ICHAR g_szTypeInteger[] = TEXT("i");
const ICHAR g_chTypeString = 's'; // string
const ICHAR g_szTypeString[] = TEXT("s");
const ICHAR g_chTypeExpandString = 'e';// expand string
const ICHAR g_szTypeExpandString[] = TEXT("e");
const ICHAR g_chTypeMultiSzStringPrefix = 'b';// multisz prefix
const ICHAR g_szTypeMultiSzStringPrefix[] = TEXT("b");
const ICHAR g_chTypeMultiSzStringSuffix = 'a';// multisz suffix
const ICHAR g_szTypeMultiSzStringSuffix[] = TEXT("a");
const ICHAR g_chTypeMultiSzStringDD = 'd';// multisz prefix DD - special logic to break out of removing if not last
const ICHAR g_szTypeMultiSzStringDD[] = TEXT("d");

void CreateCustomActionManager(bool fRemapHKCU);

//____________________________________________________________________________
//
// IMsiExecute factory implementation - all member data zeroed by new operator
//____________________________________________________________________________

extern Bool IsTerminalServerInstalled(); // from services.cpp

CMsiOpExecute::CMsiOpExecute(IMsiConfigurationManager& riConfigurationManager,
									  IMsiMessage& riMessage, IMsiDirectoryManager* piDirectoryManager,
									  Bool fRollbackEnabled, unsigned int fFlags, HKEY* phKey)
 : m_riServices(riConfigurationManager.GetServices()),
	m_riConfigurationManager(riConfigurationManager),m_piDirectoryManager(piDirectoryManager),
	m_pProgressRec(0),
	m_riMessage(riMessage), m_pConfirmCancelRec(0), m_iWriteFIFO(0),m_iReadFIFO(0),
	m_pRollbackAction(0), m_pCleanupAction(0),
	m_pCachePath(0), m_pActionThreadData(0), m_fFlags(fFlags),
	m_pEnvironmentWorkingPath95(0), m_pEnvironmentPath95(0),
	m_pDatabase(0), m_pFileCacheTable(0), m_pFileCacheCursor(0), m_fShellRefresh(fFalse),
	m_fEnvironmentRefresh(fFalse), m_pShellNotifyCacheTable(0), m_pShellNotifyCacheCursor(0),
	m_fSfpCancel(false), m_fRunScriptElevated(false), m_pAssemblyCacheTable(0), m_pAssemblyUninstallTable(0), m_iMaxNetSource(0), m_iMaxURLSource(0),
	m_fUserChangedDuringInstall(false), m_pUrlCacheCabinet(0), m_fRemapHKCU(true)
{
	m_fReverseADVTScript = m_fFlags & SCRIPTFLAGS_REVERSE_SCRIPT ? fTrue: fFalse; // flag to force the reversal of the script operations
	m_piProductInfo = &m_riServices.CreateRecord(0); // in case accessors called without ProductInfo record
	if(phKey && *phKey)
	{
		m_fKey = fFalse;
		m_hOLEKey = *phKey;
		m_hOLEKey64 = *phKey;
	}
	else
	{
		m_fKey = fTrue;
	}
	GetRollbackPolicy(m_irlRollbackLevel);
	if(fRollbackEnabled == fFalse)
		m_irlRollbackLevel = irlNone; // passed in value overrides policy
	m_cSuppressProgress = g_MessageContext.IsOEMInstall() ? 1 : 0; // for OEM installs we do not display progress

	m_hUserDataKey = 0;

	m_rgDisplayOnceMessages[0] = MAKELONG(0, imsgCannotUpdateProtectedFile);
	m_rgDisplayOnceMessages[1] = 0;

	// since there is no TS transaction window for advertise scripts, there is no point in doing any 
	// registry mapping work for per-machine advertisements on TS machines. If the script is being run
	// as part of an actual install, the header opcode contains the correct state.
}

CMsiOpExecute::~CMsiOpExecute()
{
	WaitForCustomActionThreads(0, fTrue, m_riMessage);
	IMsiRecord* piFileRec;
	while ((piFileRec = PullRecord()) != 0)
	{
		piFileRec->Release();
	}
}


// constructor used internally
CMsiExecute::CMsiExecute(IMsiConfigurationManager& riConfigurationManager, IMsiMessage& riMessage,
								 IMsiDirectoryManager* piDirectoryManager, Bool fRollbackEnabled, unsigned int fFlags, HKEY* phKey)
	: CMsiOpExecute(riConfigurationManager, riMessage, piDirectoryManager, fRollbackEnabled, fFlags, phKey)
	, m_iRefCnt(1)
{
	riConfigurationManager.AddRef();  // services addref by configmgr
	riMessage.AddRef();
	if(piDirectoryManager)
		piDirectoryManager->AddRef();
	m_pProgressRec = &m_riServices.CreateRecord(ProgressData::imdNextEnum);
	Assert(m_pProgressRec);
}


// factory called from OLE class factory, either client or standalone instance
IUnknown* CreateExecutor()
{
	PMsiMessage pMessage = (IMsiMessage*)ENG::CreateMessageHandler();
	PMsiConfigurationManager pConfigManager(ENG::CreateConfigurationManager());
	if (!pConfigManager)
		return 0;  // should happen only if out of memory
	return ENG::CreateExecutor(*pConfigManager, *pMessage, 0, fTrue);
}

IMsiExecute* CreateExecutor(IMsiConfigurationManager& riConfigurationManager, IMsiMessage& riMessage,
									 IMsiDirectoryManager* piDirectoryManager,
									 Bool fRollbackEnabled, unsigned int fFlags, HKEY* phKey)
{
	return new CMsiExecute(riConfigurationManager, riMessage, piDirectoryManager, fRollbackEnabled, fFlags, phKey);
}


inline CMsiExecute::~CMsiExecute()
{
	Assert(m_piProductInfo);
	m_piProductInfo->Release();

	if (m_pUrlCacheCabinet)
	{
		delete m_pUrlCacheCabinet;
		m_pUrlCacheCabinet = 0;
	}
	if(m_hKey)
		WIN::RegCloseKey(m_hKey);
	if(m_hKeyRm)
		WIN::RegCloseKey(m_hKeyRm);
	if(m_fKey)
	{
		if(m_hOLEKey)
			WIN::RegCloseKey(m_hOLEKey);
		if(m_hOLEKey64 && m_hOLEKey64 != m_hOLEKey)
			WIN::RegCloseKey(m_hOLEKey64);
	}
	if(m_hUserDataKey)
		WIN::RegCloseKey(m_hUserDataKey);
}

IMsiServices& CMsiExecute::GetServices()
//----------------------------------------------
{
	return (m_riServices.AddRef(), m_riServices);
}

//____________________________________________________________________________
//
// OpCode dispatch table - array of member function pointers
//____________________________________________________________________________

CMsiExecute::FOpExecute CMsiExecute::rgOpExecute[] =
{
#define MSIXO(op,type,args) ixf##op,
#include "opcodes.h"
};

int CMsiExecute::rgOpTypes[] =
{
#define MSIXO(op,type,args) type,
#include "opcodes.h"
};


//____________________________________________________________________________
//
// IMsiExecute virtual function implementation
//____________________________________________________________________________

HRESULT CMsiExecute::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown) || MsGuidEqual(riid, IID_IMsiExecute))
		return (*ppvObj = (IMsiExecute*)this, AddRef(), NOERROR);
	else
		return (*ppvObj = 0, E_NOINTERFACE);
}

unsigned long CMsiExecute::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiExecute::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;

	for (int iRecord = 0; iRecord <= cMaxSharedRecord+1; iRecord++)
		if (m_rgpiSharedRecords[iRecord])
			m_rgpiSharedRecords[iRecord]->Release();

	m_riServices.Release();
	m_riMessage.Release();
	if(m_piDirectoryManager)
		m_piDirectoryManager->Release();
	
	PMsiConfigurationManager pConfigMgr(&m_riConfigurationManager);
	delete this;  // configmgr freed after memory released
	return 0;
}

#ifndef UNICODE
// construct the secure transform path
IMsiRecord* GetSecureTransformCachePath(IMsiServices& riServices, 
										const IMsiString& riProductKey, 
										IMsiPath*& rpiPath)
{
	IMsiRecord* piError = 0;

	// On Win9x the path is to %WINDOWS%\Installer\{ProductCode}\SecureTransforms

	MsiString strCachePath = GetMsiDirectory();
	Assert(strCachePath.TextSize());
	piError = riServices.CreatePath(strCachePath, rpiPath);
	if(!piError)
		piError = rpiPath->AppendPiece(riProductKey);
	if(!piError)
		piError = rpiPath->AppendPiece(*MsiString(*DIR_SECURE_TRANSFORMS));
	return piError;
}
#endif

/*inline*/LONG GetPublishKey(iaaAppAssignment iaaAsgnType, HKEY& rhKey, HKEY& rhOLEKey, const IMsiString*& rpiPublishSubKey, const IMsiString*& rpiPublishOLESubKey)
{
	return GetPublishKeyByUser(NULL, iaaAsgnType, rhKey, rhOLEKey, rpiPublishSubKey, rpiPublishOLESubKey);
}

LONG GetPublishKeyByUser(const ICHAR* szUserSID, iaaAppAssignment iaaAsgnType, HKEY& rhKey, HKEY& rhOLEKey, const IMsiString*& rpiPublishSubKey, const IMsiString*& rpiPublishOLESubKey)
{
	MsiString strPublishSubKey;
	MsiString strPublishOLESubKey;
	MsiString strUserSID;

	if (g_fWin9X == false)
	{
		if (szUserSID)
		{
			strUserSID = szUserSID;
			AssertSz(iaaAsgnType != iaaUserAssign, TEXT("Attempted to get per-user non-managed publish key for another user. Not allowed due to roaming issues."));
		}
		else
		{
			DWORD dwError = GetCurrentUserStringSID(*&strUserSID);
			if (ERROR_SUCCESS != dwError)
				return dwError;
		}
	}

	if(iaaAsgnType == iaaMachineAssign || IsDarwinDescriptorSupported(iddOLE) == fFalse)
	{
		rhOLEKey = HKEY_LOCAL_MACHINE;
		strPublishOLESubKey = szClassInfoSubKey;
	}
	else
	{
		if (strUserSID.TextSize())
		{
			rhOLEKey = HKEY_USERS;
			strPublishOLESubKey = strUserSID + MsiString(TEXT("\\"));
		}
		else
		{
			rhOLEKey = HKEY_CURRENT_USER;
		}
		strPublishOLESubKey += szClassInfoSubKey;
	}
	
	switch(iaaAsgnType)
	{
	case iaaMachineAssign:
		rhKey = HKEY_LOCAL_MACHINE;
		strPublishSubKey = _szMachineSubKey;
		break;
	case iaaUserAssign:
		if(g_fWin9X)
			return ERROR_FILE_NOT_FOUND; //!! random error
		Assert(strUserSID.TextSize());
		rhKey = HKEY_LOCAL_MACHINE;
		strPublishSubKey = MsiString(MsiString(*_szManagedUserSubKey) + TEXT("\\")) + strUserSID;
		break;
	case iaaUserAssignNonManaged:
		if (strUserSID.TextSize())
		{
			rhKey = HKEY_USERS;
			strPublishSubKey = MsiString(strUserSID + TEXT("\\")) + MsiString(*_szNonManagedUserSubKey);
		}
		else
		{
			rhKey = HKEY_CURRENT_USER;
			strPublishSubKey = _szNonManagedUserSubKey;
		}
		break;
	default:
		Assert(0);
	}

	strPublishSubKey.ReturnArg(rpiPublishSubKey);
	strPublishOLESubKey.ReturnArg(rpiPublishOLESubKey);
	return ERROR_SUCCESS;
}


bool VerifyProduct(iaaAppAssignment iaaAsgnType, const ICHAR* szProductKey, HKEY& rhKey, HKEY& rhOLEKey, const IMsiString*& rpiPublishSubKey, const IMsiString*& rpiPublishOLESubKey)
{
	MsiString strPublishSubKey;
	MsiString strPublishOLESubKey;

	MsiString strProductKeySQUID = GetPackedGUID(szProductKey);

	CRegHandle HProductKey;
	DWORD dwRet = GetPublishKey(iaaAsgnType, rhKey, rhOLEKey, *&strPublishSubKey, *&strPublishOLESubKey);
	if (ERROR_SUCCESS != dwRet)
		return false;

	MsiString strSubKey = strPublishSubKey;
	strSubKey += TEXT("\\") _szGPTProductsKey TEXT("\\");
	strSubKey += strProductKeySQUID;

	dwRet = MsiRegOpen64bitKey(rhKey, strSubKey, 0, KEY_READ | (g_fWinNT64 ? KEY_WOW64_64KEY : 0), &HProductKey);
	if (ERROR_SUCCESS != dwRet)
		return false;

	if(!g_fWin9X && iaaAsgnType != iaaUserAssignNonManaged)
	{
		// get the owner
		bool fIsManaged = false;

		DWORD dwRet = FIsKeySystemOrAdminOwned(HProductKey, fIsManaged);
	
		if ((ERROR_SUCCESS != dwRet) || !fIsManaged)
			return false;
	}

	// get the assignment
	int iAssignment;
	DWORD dwType, dwSize = sizeof(iAssignment);
	dwRet = RegQueryValueEx(HProductKey,szAssignmentTypeValueName,
								  0,&dwType,(LPBYTE)&iAssignment,&dwSize);

	if (ERROR_SUCCESS != dwRet || (iAssignment != (iaaAsgnType == iaaMachineAssign ? 1:0)))
		return false;

	strPublishSubKey.ReturnArg(rpiPublishSubKey);
	strPublishOLESubKey.ReturnArg(rpiPublishOLESubKey);
	return true;        
}


//!! currently ConvertPathName expected to be called with "cpToLong" on Win2k only
//!! KERNEL32::GetLongPathName supported on Win2k and Win98 only
Bool ConvertPathName(const ICHAR* pszPathFormatIn, CTempBufferRef<ICHAR>& rgchPathFormatOut, cpConvertType cpTo)
{
	extern bool GetImpersonationFromPath(const ICHAR* szPath);
	CImpersonate impersonate((g_scServerContext == scService && GetImpersonationFromPath(pszPathFormatIn)) ? fTrue: fFalse); // impersonate, if accessing the net and are a service

	DWORD dwResult;
	if(cpTo == cpToShort)
		dwResult = WIN::GetShortPathName(pszPathFormatIn,rgchPathFormatOut,rgchPathFormatOut.GetSize());
	else
		dwResult = KERNEL32::GetLongPathName(pszPathFormatIn,rgchPathFormatOut,rgchPathFormatOut.GetSize());
	if(!dwResult)
	{
		return fFalse;
	}
	if(dwResult > rgchPathFormatOut.GetSize() - 1)
	{
		rgchPathFormatOut.SetSize(dwResult + 1);
		if(cpTo == cpToShort)
			dwResult = WIN::GetShortPathName(pszPathFormatIn,rgchPathFormatOut,rgchPathFormatOut.GetSize());
		else
			dwResult = KERNEL32::GetLongPathName(pszPathFormatIn,rgchPathFormatOut,rgchPathFormatOut.GetSize());
		if(!dwResult || dwResult > rgchPathFormatOut.GetSize() - 1)
		{
			Assert(0);
			return fFalse;
		}
	}
	return fTrue;
}

 // DetermineLongFileNameOnly returns in rgchFileNameOut the LFN form of the file referenced by the full
 // path input pszPathFormatIn. rgchFileNameOut does NOT include the path. Returns true on success.
 // The file must exist. The function will impersonate if necessary to access network shares. The function
 // does NOT try to convert each segment of th path, and thus does NOT require list rights to any directory
 // in the tree above the file except the deepest. (This is in contrast to GetLongPathName, which converts
 // each segment and thus requires either explicit list right on each directory.)
 bool DetermineLongFileNameOnly(const ICHAR* pszPathFormatIn, CTempBufferRef<ICHAR>& rgchFileNameOut)
 {
	extern bool GetImpersonationFromPath(const ICHAR* szPath);

	// determine if impersonation is needed and impersonate if required
	CImpersonate impersonate((g_scServerContext == scService && GetImpersonationFromPath(pszPathFormatIn)) ? fTrue: fFalse); // impersonate, if accessing the net and are a service

	DWORD dwLength = 0;
	WIN32_FIND_DATA FindData;
	HANDLE hFind = INVALID_HANDLE_VALUE;
	hFind = FindFirstFile(pszPathFormatIn, &FindData);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		FindClose(hFind);
		dwLength = IStrLen(FindData.cFileName);
		if (!dwLength)
			return false;
	}
	else
		return false;
	// if the provided input buffer is too small to hold the LFN, resize it.
	if(dwLength > rgchFileNameOut.GetSize() - 1)
	{
		// no error detection on resizing function, to detect failure, check that the pointer
		// is valid and that the size is what is expected.
		rgchFileNameOut.SetSize(dwLength + 1);
		if ((rgchFileNameOut.GetSize() != (dwLength+1)) || !static_cast<const ICHAR*>(rgchFileNameOut))
			return false;
	}
	// copy the long file name into the output buffer.
	return (IStrCopyLen(rgchFileNameOut, FindData.cFileName, rgchFileNameOut.GetSize()) != NULL);
}

const IMsiString& GetSFN(const IMsiString& riValue, IMsiRecord& riParams, int iBegin)
{
	CTempBuffer<ICHAR, 512> rgchOut;
	CTempBuffer<ICHAR, 512> rgchLFN;
	CTempBuffer<ICHAR, 512> rgchSFN;

	int cch = 0;
	int iStart = iBegin;
	while(!riParams.IsNull(iBegin))
	{
		// copy text between the sfns
		const ICHAR* psz = riValue.GetString();
		if(iBegin != iStart)
		{
			psz = psz + riParams.GetInteger(iBegin - 2) + riParams.GetInteger(iBegin - 1);
		}
		const ICHAR* pszBeginLFN = riValue.GetString() + riParams.GetInteger(iBegin);
		unsigned int cchLen = (unsigned int)(pszBeginLFN - psz);
		ResizeTempBuffer(rgchOut,  cchLen + cch);
		if ( ! (ICHAR *) rgchOut )
			return g_riMsiStringNull;
		memcpy(&rgchOut[cch], psz,cchLen * sizeof(ICHAR));
		cch += cchLen;

		// get the sfn string
		cchLen = riParams.GetInteger(iBegin + 1);
		rgchLFN.SetSize(cchLen + 1);
		if ( ! (ICHAR *) rgchLFN )
			return g_riMsiStringNull;
		memcpy((ICHAR* )rgchLFN, pszBeginLFN, cchLen * sizeof(ICHAR));
		rgchLFN[cchLen] = 0;

		if(ConvertPathName(rgchLFN, rgchSFN, cpToShort))
		{
			int cchSFNLen = IStrLen(rgchSFN);
			ResizeTempBuffer(rgchOut, cch + cchSFNLen);
			memcpy(&rgchOut[cch], rgchSFN,cchSFNLen * sizeof(ICHAR));
			cch += cchSFNLen;
		}
		else
		{
			//?? else use LFN
			ResizeTempBuffer(rgchOut, cch + cchLen);
			memcpy(&rgchOut[cch], rgchLFN,cchLen * sizeof(ICHAR));
			cch += cchLen;
		}
		iBegin += 2;
	}
	if(iBegin != iStart)
	{
		// copy text after the last sfn
		const ICHAR* psz = riValue.GetString() + riParams.GetInteger(iBegin - 2) + riParams.GetInteger(iBegin - 1);
		unsigned int cchLen = (unsigned int)((riValue.GetString() + riValue.TextSize()) - psz);
		ResizeTempBuffer(rgchOut,  cchLen + cch);
		memcpy(&rgchOut[cch], psz, cchLen * sizeof(ICHAR));
		cch += cchLen;
	}
	MsiString istrOut;
	// we take the perf hit on Win9X to be able to handle DBCS, on UNICODE -- fDBCS arg is ignored
	memcpy(istrOut.AllocateString(cch, /*fDBCS=*/fTrue), (ICHAR*) rgchOut, cch * sizeof(ICHAR));
	return istrOut.Return();
}

IMsiRecord* CMsiOpExecute::GetCachePath(IMsiPath*& rpiPath, const IMsiString** ppistrEncodedPath=0)
{
	IMsiRecord* piError = 0;

	// we place the Msi folder in the user's app data folder
	MsiString strCachePath;
	piError = GetShellFolder(CSIDL_APPDATA, *&strCachePath);
	if(!piError)
		piError = m_riServices.CreatePath(strCachePath,rpiPath);
	if(!piError)
		piError = rpiPath->AppendPiece(*MsiString(TEXT("Microsoft")));
	if(!piError)
		piError = rpiPath->AppendPiece(*MsiString(DIR_CACHE));
	if(!piError)
		piError = rpiPath->AppendPiece(*MsiString(GetProductKey()));

	if (ppistrEncodedPath)
	{
		MsiString strPath = rpiPath->GetPath();
		strPath.Remove(iseFirst, strCachePath.CharacterCount());
		MsiString strEncodedPath = MsiChar(SHELLFOLDER_TOKEN);
		strEncodedPath += CSIDL_APPDATA;
		strEncodedPath += MsiChar(SHELLFOLDER_TOKEN);
		strEncodedPath += strPath;
		strEncodedPath.ReturnArg(*ppistrEncodedPath);
	}

	return piError;
}

void BuildFullRegKey(const HKEY hRoot, const ICHAR* rgchSubKey,
							const ibtBinaryType iType, const IMsiString*& strFullKey);

iesEnum CMsiOpExecute::EnsureClassesRootKeyRW()
{
	if(m_fKey)
	{
		DWORD lResult;

		if ( !m_hOLEKey )
		{
			REGSAM dwSam = KEY_READ| KEY_WRITE;
			if ( g_fWinNT64 )
				dwSam |= KEY_WOW64_32KEY;
			lResult = RegCreateKeyAPI(m_hPublishRootOLEKey, m_strPublishOLESubKey, 0, 0,
													0, dwSam, 0, &m_hOLEKey, 0);
			if(lResult != ERROR_SUCCESS)
			{
				MsiString strFullKey;
				BuildFullRegKey(m_hPublishRootOLEKey, m_strPublishOLESubKey, ibt32bit, *&strFullKey);
				PMsiRecord pError = PostError(Imsg(imsgCreateKeyFailed), *strFullKey, (int)lResult);
				return FatalError(*pError);
			}
		}
		if ( !m_hOLEKey64 )
		{
			if ( !g_fWinNT64 )
				m_hOLEKey64 = m_hOLEKey;
			else
			{
				lResult = RegCreateKeyAPI(m_hPublishRootOLEKey, m_strPublishOLESubKey, 0, 0,
														0, KEY_READ| KEY_WRITE | KEY_WOW64_64KEY, 0, &m_hOLEKey64, 0);
				if(lResult != ERROR_SUCCESS)
				{
					MsiString strFullKey;
					BuildFullRegKey(m_hPublishRootOLEKey, m_strPublishOLESubKey, ibt64bit, *&strFullKey);
					PMsiRecord pError = PostError(Imsg(imsgCreateKeyFailed), *strFullKey, (int)lResult);
					return FatalError(*pError);
				}
			}
		}
	}
	return iesSuccess;
}

iesEnum CMsiOpExecute::DoMachineVsUserInitialization()
{
	PMsiRecord pError(0);
	HRESULT lResult;
	// set the appropriate control flags for the execution of the script
	// where do we write our product information
	if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
	{
		// have we machine assigned before?
		m_fAssigned = VerifyProduct(iaaMachineAssign, MsiString(GetProductKey()), m_hPublishRootKey, m_hPublishRootOLEKey, *&m_strPublishSubKey, *&m_strPublishOLESubKey);
		if(!m_fAssigned)
		{
			// are we app deploying or admin?
			//BUGBUG 9558: this check is bogus, as it doesn't allow non-localadmins to deploy an app via the MMC
			if((!IsImpersonating(true) || IsAdmin()) || ((m_fFlags & SCRIPTFLAGS_INPROC_ADVERTISEMENT) && RunningAsLocalSystem()))
			{
				m_fAssigned = true;
				lResult = GetPublishKey(iaaMachineAssign, m_hPublishRootKey, m_hPublishRootOLEKey, *&m_strPublishSubKey, *&m_strPublishOLESubKey);
				if (lResult != ERROR_SUCCESS)
					return FatalError(*PMsiRecord(PostError(Imsg(idbgPublishRoot), lResult)));
			}
			else
			{
				// cannot machine assign
				DispatchError(imtError, Imsg(imsgInsufficientUserPrivileges));
				return iesFailure;
			}
		}
		else // m_fAssigned == true
		{
			if (m_istScriptType == istAdvertise)
			{
				if (m_fKey && !((m_fFlags & SCRIPTFLAGS_INPROC_ADVERTISEMENT) && RunningAsLocalSystem()))
				{
					// cannot re-advertise an app unless either
					// 1) you've given an external reg key (deploying via MMC) OR
					// 2) you're app deployment (advertising during winlogon)

					DispatchError(imtError, Imsg(imsgInsufficientUserPrivileges));
					return iesFailure;
				}
			}
		}
	}
	else // user assignment
	{
		if (GetIntegerPolicyValue(CApiConvertString(szDisableUserInstallsValueName), fTrue))// policy set to ignore user installs 
		{
			DispatchError(imtError, Imsg(imsgUserInstallsDisabled));
			return iesFailure;
		}

		// have we user assigned (managed) before?
		m_fAssigned = VerifyProduct(iaaUserAssign, MsiString(GetProductKey()), m_hPublishRootKey, m_hPublishRootOLEKey, *&m_strPublishSubKey, *&m_strPublishOLESubKey);

		if(!m_fAssigned)
		{
			// are we app deploying?
			if((m_fFlags & SCRIPTFLAGS_INPROC_ADVERTISEMENT) && RunningAsLocalSystem())
			{
				m_fAssigned = true;
				lResult = GetPublishKey(iaaUserAssign, m_hPublishRootKey, m_hPublishRootOLEKey, *&m_strPublishSubKey, *&m_strPublishOLESubKey);
				if (lResult != ERROR_SUCCESS)
					return FatalError(*PMsiRecord(PostError(Imsg(idbgPublishRoot), lResult)));
			}
			else
			{
				// have we user assigned (non-managed) before?
				if(!VerifyProduct(iaaUserAssignNonManaged, MsiString(GetProductKey()), m_hPublishRootKey, m_hPublishRootOLEKey, *&m_strPublishSubKey, *&m_strPublishOLESubKey))
				{
					// open new non-managed app key
					lResult = GetPublishKey(iaaUserAssignNonManaged, m_hPublishRootKey, m_hPublishRootOLEKey, *&m_strPublishSubKey, *&m_strPublishOLESubKey);
					if (lResult != ERROR_SUCCESS)
						return FatalError(*PMsiRecord(PostError(Imsg(idbgPublishRoot), lResult)));
				}
			}
		}
		if(m_fAssigned)
		{
			if (m_istScriptType == istAdvertise)
			{
				if (m_fKey && !((m_fFlags & SCRIPTFLAGS_INPROC_ADVERTISEMENT) && RunningAsLocalSystem()))
				{
					// cannot re-advertise an app unless either
					// 1) you've given an external reg key (deploying via MMC) OR
					// 2) you're app deployment (advertising during winlogon)
					DispatchError(imtError, Imsg(imsgInsufficientUserPrivileges));
					return iesFailure;
				}
			}

			// get the auxiliary keys to publish the roaming info
			HKEY hkeyTmp;
			MsiString strTmp;
			lResult = GetPublishKey(iaaUserAssignNonManaged, m_hPublishRootKeyRm, hkeyTmp, *&m_strPublishSubKeyRm, *&strTmp);
			if (lResult != ERROR_SUCCESS)
				return FatalError(*PMsiRecord(PostError(Imsg(idbgPublishRoot), lResult)));
		}
	}

	m_fUserSpecificCache = true;

	if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
	{
		// we place the Installer folder below the Windows directory, in a per-product folder
		MsiString strCachePath = GetMsiDirectory();
		Assert(strCachePath.TextSize());
		pError = m_riServices.CreatePath(strCachePath,*&m_pCachePath);
		if(!pError)
			pError = m_pCachePath->AppendPiece(*MsiString(GetProductKey()));

		m_fUserSpecificCache = false;
	}
	else
	{
		// use the appdata folder
		pError = GetCachePath(*&m_pCachePath);
	}

	if(pError)
		return FatalError(*pError);
	if(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO) // do we do darwin config data
	{
		if(m_hKey)
			WIN::RegCloseKey(m_hKey), m_hKey = 0; // close key, if not 0 - might get called twice if validating transform
		lResult = MsiRegCreate64bitKey(m_hPublishRootKey, m_strPublishSubKey, 0, 0,
												 0, KEY_READ| KEY_WRITE, 0, &m_hKey, 0);
		if(lResult != ERROR_SUCCESS)
		{
			PMsiRecord pError = PostError(Imsg(imsgCreateKeyFailed), *m_strPublishSubKey, lResult);
			return FatalError(*pError);
		}

		// if we are writing to assigned user, we also write to the roaming part
		if(m_fAssigned && !(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN))
		{
			if(m_hKeyRm)        
				WIN::RegCloseKey(m_hKeyRm), m_hKeyRm = 0; // close key, if not 0 - might get called twice if validating transform
			lResult = MsiRegCreate64bitKey(m_hPublishRootKeyRm, m_strPublishSubKeyRm, 0, 0,
													 0, KEY_READ| KEY_WRITE, 0, &m_hKeyRm, 0);
			if(lResult != ERROR_SUCCESS)
			{
				PMsiRecord pError = PostError(Imsg(imsgCreateKeyFailed), *m_strPublishSubKeyRm, lResult);
				return FatalError(*pError);
			}
		}
	}

	if(m_fFlags & SCRIPTFLAGS_REGDATA_APPINFO) // do we do app data
	{
		if(!m_fKey)// REGKEY - externally provided
		{
			Assert(m_irlRollbackLevel == irlNone); // should have been set this way in GetRollbackPolicy
		}
		else
		{
			if(m_hOLEKey)
				WIN::RegCloseKey(m_hOLEKey); // close key, if not 0 - might get called twice if validating transform
			if(m_hOLEKey64 && m_hOLEKey64 != m_hOLEKey)
				WIN::RegCloseKey(m_hOLEKey64); // close key, if not 0 - might get called twice if validating transform
			m_hOLEKey = m_hOLEKey64 = 0;
		}
	}

	return iesSuccess;
}

iesEnum CMsiExecute::GetTransformsList(IMsiRecord& riProductInfoParams, IMsiRecord& riProductPublishParams, const IMsiString*& rpiTransformsList)
{
	iesEnum iesRet = ixfProductInfo(riProductInfoParams);
	if (iesSuccess == iesRet)
	{
		iesRet = ProcessPublishProduct(riProductPublishParams, fFalse, &rpiTransformsList);
	}

	return iesRet;
}

iesEnum CMsiExecute::RunScript(const ICHAR* szScriptFile, bool fForceElevation)
{
	// fForceElevation means to elevate even if script header does not have Elevate attribute
	AssertSz(fForceElevation || IsImpersonating(), TEXT("Elevated at start of RunScript"));

	m_fRunScriptElevated = fForceElevation;  // may be set to true when reading script header below
	g_fRunScriptElevated = fForceElevation;

	iesEnum iesResult = iesSuccess;
	Assert(m_ixsState == ixsIdle);

	PMsiStream pStream(0);
	PMsiStream pRollbackStream(0);

	// Elevate this block... may not want to elevate when running the script
	{
		CElevate elevate;

		// open script
		PMsiRecord pError(0);
		pError = m_riServices.CreateFileStream(szScriptFile, fFalse, *&pStream);
		if (pError)
		{
			Message(imtError, *pError);
			return iesFailure;
		}

		// read script header
		PMsiRecord pParams(0);
		PMsiRecord pPrevParams(0);
		pParams = m_riServices.ReadScriptRecord(*pStream, *&pPrevParams, 0);
		if (!pParams) // file error or premature end of file
		{
			DispatchError(imtError, Imsg(idbgReadScriptRecord), *MsiString(szScriptFile));
			return iesFailure;
		}
		if((ixoEnum)pParams->GetInteger(0) != ixoHeader)
		{
			DispatchError(imtError, Imsg(idbgMissingScriptHeader), *MsiString(szScriptFile));
			return iesFailure;
		}

		pStream->Reset();
		pStream->Seek(pStream->Remaining() - sizeof(int));
		m_iProgressTotal = pStream->GetInt32();
		pStream->Reset();

		// check if this script version is supported
		m_iScriptVersion = pParams->GetInteger(IxoHeader::ScriptMajorVersion);
		m_iScriptVersionMinor = pParams->GetInteger(IxoHeader::ScriptMinorVersion);
		if(m_iScriptVersion == iMsiStringBadInteger)
			m_iScriptVersion = 0;
		if(m_iScriptVersion < iScriptVersionMinimum || m_iScriptVersion > iScriptVersionMaximum)
		{
			DispatchError(imtError, Imsg(idbgOpScriptVersionUnsupported), szScriptFile, m_iScriptVersion,
							  iScriptVersionMinimum, iScriptVersionMaximum);
			return (iesEnum)iesUnsupportedScriptVersion;
		}
		
		WORD iPackagePlatform = HIWORD((istEnum)pParams->GetInteger(IxoHeader::Platform));
		if ( iPackagePlatform == (WORD)PROCESSOR_ARCHITECTURE_IA64 && !g_fWinNT64 )
		{
			DEBUGMSGE(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_SCRIPT_PLATFORM_UNSUPPORTED, szScriptFile);
			DispatchError(imtEnum(imtError), Imsg(idbgScriptPlatformUnsupported), *MsiString(szScriptFile));
			return iesFailure;
		}
	
		m_istScriptType = (istEnum)pParams->GetInteger(IxoHeader::ScriptType);

		if(!pParams->IsNull(IxoHeader::ScriptAttributes))
		{
			isaEnum isaScriptAttributes = (isaEnum)pParams->GetInteger(IxoHeader::ScriptAttributes);
			if(isaScriptAttributes & isaElevate)
			{
				m_fRunScriptElevated = true;
				g_fRunScriptElevated = true;
			}
		
			// if the script is marked with the TS registry attribute, remap the appropriate HKCU
			// key and initialize the CA servers. Do NOT respect this attribute if the script is
			// called via the advertise API (told not to respect script settings).
			if (MinimumPlatformWindows2000() && IsTerminalServerInstalled() && (m_fFlags & SCRIPTFLAGS_MACHINEASSIGN_SCRIPTSETTINGS))
			{
				m_fRemapHKCU = (isaScriptAttributes & isaUseTSRegistry) ? false : true;
				PrepareHydraRegistryKeyMapping(/*TSPerMachineInstall=*/!m_fRemapHKCU);
			}
		}

		MsiString strRollbackScriptFullPath, strRollbackScriptName;
		PMsiPath pRollbackScriptDir(0);
		// create rollback script if rollback enabled
		if(m_irlRollbackLevel != irlNone && m_istScriptType != istRollback)
		{
			// create secured rollback script
			if((iesResult = GenerateRollbackScriptName(*&pRollbackScriptDir, *&strRollbackScriptName)) != iesSuccess)
				return iesResult;
			if((pError = pRollbackScriptDir->GetFullFilePath(strRollbackScriptName,*&strRollbackScriptFullPath)) != 0)
			{
				Message(imtError, *pError);
				return iesFailure;
			}

			pError = m_riServices.CreateFileStream(strRollbackScriptFullPath,fTrue, *&pRollbackStream);
			if (pError)
			{
				Message(imtError, *pError);
				return iesFailure;
			}

			DWORD isaRollbackScriptAttributes = 0;
			// if we are elevating for this script, then we should elevate for the rollback as well
			if(m_fRunScriptElevated)
				isaRollbackScriptAttributes = isaElevate;
			
			// if using the TS registry propagation system for this script, must also use it for
			// rollback
			if (!m_fRemapHKCU)
				isaRollbackScriptAttributes |= isaUseTSRegistry;
				
			m_pRollbackScript = new CScriptGenerate(*pRollbackStream,
													pParams->GetInteger(IxoHeader::LangId),
													GetCurrentDateTime(),
													istRollback, static_cast<isaEnum>(isaRollbackScriptAttributes),
													m_riServices);
			if (!m_pRollbackScript)
			{
				DispatchError(imtError, Imsg(idbgInitializeRollbackScript),*strRollbackScriptFullPath);
				return iesFailure;
			}


			// package platform for rollback script same as for install script
			while (m_pRollbackScript->InitializeScript(iPackagePlatform) == false)
			{
				if (PostScriptWriteError(m_riMessage) == fFalse)
					return iesFailure;
			}

			// register rollback script - if we should abort abnormally, rollback script will be registered
			// to undo changes made up to that point
			AssertRecord(m_riConfigurationManager.RegisterRollbackScript(strRollbackScriptFullPath));
		}
	}

	// elevate if necessary for this script execution
	CElevate elevate(m_fRunScriptElevated);

	// run script
	switch (m_istScriptType)
	{
	case istAdvertise:
	case istInstall:
	case istPostAdminInstall:
	case istAdminInstall:
		m_ixsState = ixsRunning;
		iesResult = RunInstallScript(*pStream, szScriptFile);
		// if we are successful, do the commiting of the assemblies
		if(iesResult == iesSuccess || iesResult == iesNoAction || iesResult == iesFinished)
			iesResult = CommitAssemblies();
		m_ixsState = ixsIdle;
		break;
	case istRollback:
	{
		// disable cancel button on dialog
		PMsiRecord pControlMessage = &m_riServices.CreateRecord(2);
		AssertNonZero(pControlMessage->SetInteger(1,(int)icmtCancelShow));
		AssertNonZero(pControlMessage->SetInteger(2,(int)fFalse));
		Message(imtCommonData, *pControlMessage);

		m_ixsState = ixsRollback;
		
		// drop the ShellNotifyCache deferral tables
		m_pShellNotifyCacheTable = 0;
		m_pShellNotifyCacheCursor = 0;

		iesResult = RunRollbackScript(*pStream, szScriptFile);

		// if we are successful, do the commiting of the assemblies
		if(iesResult == iesSuccess || iesResult == iesNoAction || iesResult == iesFinished)
			iesResult = CommitAssemblies();
		m_ixsState = ixsIdle;

		// re-enable cancel button on dialog
		AssertNonZero(pControlMessage->SetInteger(2,(int)fTrue));
		Message(imtCommonData, *pControlMessage);
		break;
	}
	default:
		DispatchError(imtError, Imsg(idbgOpInvalidParam), TEXT("ixfHeader"),
						  (int)IxoHeader::ScriptType);
		iesResult = iesFailure;
		break;
	};

	if(m_pRollbackScript)
	{
		delete m_pRollbackScript; // release hold of script
		m_pRollbackScript = 0;

		pRollbackStream = 0; // release
	}

	ClearExecutorData();
	
	Bool fReboot = m_fRebootReplace;
	m_fRebootReplace = fFalse;
	if(iesResult == iesSuccess || iesResult == iesNoAction || iesResult == iesFinished)
	{
		extern CSharedCount g_SharedCount;
		MsiInvalidateFeatureCache(); // invalidate our processes' feature cache
		if(g_SharedCount.Initialize())
			g_SharedCount.IncrementCurrentCount();

		if(m_fShellRefresh)
		{
			ShellNotifyProcessDeferred();
			SHELL32::SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_DWORD, 0, 0); // per reinerf in NT to refresh associations
		}

		if(m_fFontRefresh)
			WIN::PostMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0); // font change notification

		if (m_fEnvironmentRefresh && !g_fWin9X && !fReboot)
		{
			// environment variables
			ULONG_PTR dwResult = 0;

			// Notifies top level windows that an environment setting has changed.  This gives the shell
			// the opportunity to spawn new command shells with correct settings, for example.  Without this,
			// the changes do not take affect until a reboot.

			MsiDisableTimeout();
			// this call may pause an amount of time (see call in milliseconds), per top level window.
			// This normally shouldn't happen, unless someone isn't pumping their messages.
			AssertNonZero(WIN::SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0, (LPARAM) TEXT("Environment"), SMTO_ABORTIFHUNG, 5*1000, &dwResult));
			MsiEnableTimeout();
		}

		// Let the start menu and ARP know that something's changed. If we're uninstalling completely
		// then we pass SCHNEE_MSI_UNINSTALL so they don't have to query the state of every feature

		if ( !g_fWin9X && g_iMajorVersion >= 5 )
		{
			//  eugend: NT5 specific, fix to bug # 5296.
			//  updated for bug 9404 so the shell can actually handle it
			MsiString strProdKey(GetProductKey());
			if ( strProdKey.CharacterCount() <= 38 )
			{
				SHChangeProductKeyAsIDList pkidl;
				memset(&pkidl, 0, sizeof(pkidl));
				pkidl.cb = sizeof(pkidl) - sizeof(pkidl.cbZero);
				IStrCopy((ICHAR*) pkidl.wszProductKey, (const ICHAR*)strProdKey);

				SHChangeDWORDAsIDList dwidl;
				memset(&dwidl, 0, sizeof(dwidl));
				dwidl.cb = sizeof(dwidl) - sizeof(dwidl.cbZero);
				dwidl.dwItem1 = m_fStartMenuUninstallRefresh ?
					  SHCNEE_MSI_UNINSTALL : SHCNEE_MSI_CHANGE;

				SHELL32::SHChangeNotify(SHCNE_EXTENDED_EVENT, 0, (LPCITEMIDLIST)&dwidl, (LPCITEMIDLIST)&pkidl);
			}
		}
		if(fReboot)
			iesResult = iesSuspend;
	}	
	return iesResult;
}


iesEnum CMsiExecute::CommitAssemblies()
{
	// we commit the assemblies we are installing
	if(m_pAssemblyCacheTable)
	{
		PMsiCursor pCacheCursor = m_pAssemblyCacheTable->CreateCursor(fFalse);
		while(pCacheCursor->Next())
		{
			PAssemblyCacheItem pASM = static_cast<IAssemblyCacheItem*>(CMsiDataWrapper::GetWrappedObject(PMsiData(pCacheCursor->GetMsiData(m_colAssemblyMappingASM))));
			if(pASM) 
			{
				//we made a new copy of the assembly
				// check if the assembly already exists
				bool fInstalled = false;
				PMsiRecord pRecErr = IsAssemblyInstalled(	*MsiString(pCacheCursor->GetString(m_colAssemblyUninstallComponentId)), 
															*MsiString(pCacheCursor->GetString(m_colAssemblyMappingAssemblyName)), 
															(iatAssemblyType)pCacheCursor->GetInteger(m_colAssemblyMappingAssemblyType), 
															fInstalled, 
															0, 
															0);
				if (pRecErr)
					return FatalError(*pRecErr);

				HRESULT hr = pASM->Commit(fInstalled ? IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH : 0, NULL);
				if(!SUCCEEDED(hr))
				{
						return FatalError(*PMsiRecord(PostAssemblyError(MsiString(pCacheCursor->GetString(m_colAssemblyMappingComponentId)), hr, TEXT("IAssemblyCacheItem"), TEXT("Commit"), MsiString(pCacheCursor->GetString(m_colAssemblyMappingAssemblyName)), (iatAssemblyType)pCacheCursor->GetInteger(m_colAssemblyMappingAssemblyType))));
				}
			}
			// else do nothing, the assembly is already present in the GAC
		}
	}

	// we also uninstall any assemblies that we are unregistering, if there are no clients
	if(m_pAssemblyUninstallTable)
	{
		PMsiCursor pCacheCursor = m_pAssemblyUninstallTable->CreateCursor(fFalse);
		while(pCacheCursor->Next())
		{
			MsiString strComponentId = pCacheCursor->GetString(m_colAssemblyUninstallComponentId);

			// check if there are any other clients of this assembly that we know of
			// the same assembly may be published under some other componentid
			// following MsiProvideAssemblyCall will catch all instances
			iatAssemblyType iat = (iatAssemblyType)pCacheCursor->GetInteger(m_colAssemblyUninstallAssemblyType);
			DWORD dwAssemblyInfo = (iatWin32Assembly == iat) ? MSIASSEMBLYINFO_WIN32ASSEMBLY : MSIASSEMBLYINFO_NETASSEMBLY;
			DWORD dwRet = MsiProvideAssemblyW(CApiConvertString(MsiString(pCacheCursor->GetString(m_colAssemblyUninstallAssemblyName))), 0, INSTALLMODE_NODETECTION_ANY, dwAssemblyInfo, 0, 0);
			if(ERROR_SUCCESS != dwRet)
			{
				// no more clients, need to Uninstall as far as WI is concerned
				// make backup of the installed assembly so that we can put the assembly back, if need be, during rollback
				iesEnum iesRet = BackupAssembly(*strComponentId, *MsiString(pCacheCursor->GetString(m_colAssemblyUninstallAssemblyName)), iat);
				if(iesRet != iesSuccess)
					return iesRet;
				PMsiRecord pRecErr = UninstallAssembly(*strComponentId, *MsiString(pCacheCursor->GetString(m_colAssemblyUninstallAssemblyName)), iat);
				//we dont treat uninstalls as errors, simply log
				if(pRecErr)
					Message(imtInfo,*pRecErr);
			}//else do nothing, there are other clients for this assembly, they must simply be under another componentid
		}
	}
	return iesSuccess;
}

void CMsiExecute::ClearExecutorData()
{
	if (m_strEnvironmentWorkingFile95.TextSize())
	{
		RemoveFile(*m_pEnvironmentWorkingPath95, *m_strEnvironmentWorkingFile95, fFalse,/*fBypassSFC*/ false, false);
		m_pEnvironmentWorkingPath95 = 0;
		m_strEnvironmentWorkingFile95 = MsiString(TEXT(""));
	}

	IMsiRecord* piRec = m_piProductInfo;
	while(piRec)
	{
#ifdef _WIN64       // !merced
		IMsiRecord *piRecHold = !piRec->IsNull(0) ? (IMsiRecord*)piRec->GetHandle(0) : 0;
#else
		IMsiRecord *piRecHold = !piRec->IsNull(0) ? (IMsiRecord*)piRec->GetInteger(0) : 0;
#endif

		piRec->Release();
		piRec = piRecHold;
	}

	m_piProductInfo = &m_riServices.CreateRecord(0);
}

#define DEBUGMSGIXO(ixo,rec) if (FDiagnosticModeSet(dmDebugOutput|dmLogging)) DebugDumpIxo(ixo,rec)

extern const ICHAR* rgszixo[];

void DebugDumpIxo(ixoEnum ixo, IMsiRecord& riRecord)
{
	Assert(riRecord.GetInteger(0) == ixo);
	riRecord.SetString(0, rgszixo[ixo]);
	int iSwappedField1, iSwappedField2;
	iSwappedField1 = iSwappedField2 = 0;
	switch (ixo)
	{
	case ixoServiceInstall:
		iSwappedField1 = IxoServiceInstall::Password;
		break;
	case ixoCustomActionSchedule:
	case ixoCustomActionCommit:
	case ixoCustomActionRollback:
		if ( (riRecord.GetInteger(IxoCustomActionSchedule::ActionType) & msidbCustomActionTypeHideTarget) == msidbCustomActionTypeHideTarget )
		{
			iSwappedField1 = IxoCustomActionSchedule::Target;
			iSwappedField2 = IxoCustomActionSchedule::CustomActionData;
		}
		break;
	};
	MsiString strSwappedValue1;
	MsiString strSwappedValue2;
	if ( iSwappedField1 && riRecord.GetFieldCount() >= iSwappedField1 )
	{
		strSwappedValue1 = riRecord.GetMsiString(iSwappedField1);
		AssertNonZero(riRecord.SetString(iSwappedField1, IPROPVALUE_HIDDEN_PROPERTY));
	}
	else
		iSwappedField1 = 0;

	if ( iSwappedField2 && riRecord.GetFieldCount() >= iSwappedField2 )
	{
		strSwappedValue2 = riRecord.GetMsiString(iSwappedField2);
		AssertNonZero(riRecord.SetString(iSwappedField2, IPROPVALUE_HIDDEN_PROPERTY));
	}
	else
		iSwappedField2 = 0;
	
	MsiString strArgs = riRecord.FormatText(fFalse);
	DEBUGMSG1(TEXT("Executing op: %s"), (const ICHAR*)strArgs);
	riRecord.SetInteger(0, ixo);
	if ( iSwappedField1 )
		AssertNonZero(riRecord.SetMsiString(iSwappedField1, *strSwappedValue1));
	if ( iSwappedField2 )
		AssertNonZero(riRecord.SetMsiString(iSwappedField2, *strSwappedValue2));
}

iesEnum CMsiExecute::RunInstallScript(IMsiStream& riScript, const ICHAR* szScriptFile)
{
	PMsiRecord pParams(0);
	Assert(m_ixsState == ixsRunning);
	iesEnum iesResult = iesNoAction;
	int cRecords = 0;
#ifdef DEBUG
	ixoEnum ixoLastOpCode = ixoNoop;
#endif
	IMsiRecord *piPrevRecord = 0;

	do
	{
		pParams = m_riServices.ReadScriptRecord(riScript, *&piPrevRecord, m_iScriptVersion);
		if (!pParams) // file error or premature end of file
		{
			DispatchError(imtError, Imsg(idbgReadScriptRecord), *MsiString(szScriptFile));
			iesResult = iesFailure;
			break;
		}
		ixoEnum ixoOpCode = (ixoEnum)pParams->GetInteger(0);
		if (cRecords++ == 0 && ixoOpCode != ixoHeader)
		{
			DispatchError(imtError, Imsg(idbgMissingScriptHeader), *MsiString(szScriptFile));
			iesResult = iesFailure;
			break;
		}
		DEBUGMSGIXO(ixoOpCode, *pParams);

		iesResult = (this->*rgOpExecute[ixoOpCode])(*pParams);

		if(iesResult == iesErrorIgnored)
			iesResult = iesSuccess; // non-fatal error occurred - continue running script
		
		if(m_fCancel && (iesResult == iesNoAction || iesResult == iesSuccess))
		{
			AssertSz(0,"Didn't catch cancel message in RunInstallScript");
			iesResult = iesUserExit;
		}

	} while (iesResult == iesSuccess || iesResult == iesNoAction); // end record processing loop

	if (piPrevRecord != 0)
		piPrevRecord->Release();
	return iesResult;
}

void AddOpToList(int& cOpCount, CTempBufferRef<int>& rgBuff, int cbOffset)
{
	cOpCount++;
	if(cOpCount > rgBuff.GetSize())
		rgBuff.Resize(rgBuff.GetSize()*2);
	rgBuff[cOpCount-1] = cbOffset;
}

iesEnum CMsiExecute::RunRollbackScript(IMsiStream& riScript, const ICHAR* /*szScriptFile*/)
{
	Assert(m_ixsState == ixsRollback);

	// populate 3 buffers with init, update and finalize ops
	int cUpdateOps = 0, cInitOps = 0, cFinalizeOps = 0, cFirstUpdateOps = 0, cLastUpdateOps = 0;
	CTempBuffer<int, 500> rgUpdateOps;
	memset((void*)(int*)rgUpdateOps,0,sizeof(int)*(rgUpdateOps.GetSize()));
	CTempBuffer<int, 10> rgInitOps;
	memset((void*)(int*)rgInitOps,0,sizeof(int)*(rgInitOps.GetSize()));
	CTempBuffer<int, 1> rgFinalizeOps;
	memset((void*)(int*)rgFinalizeOps,0,sizeof(int)*(rgFinalizeOps.GetSize()));
	CTempBuffer<int, 50> rgFirstUpdateOps;
	memset((void*)(int*)rgFirstUpdateOps,0,sizeof(int)*(rgFirstUpdateOps.GetSize()));
	CTempBuffer<int, 50> rgLastUpdateOps;
	memset((void*)(int*)rgLastUpdateOps,0,sizeof(int)*(rgLastUpdateOps.GetSize()));
	
	CTempBuffer<int, ixoOpCodeCount> rgStateOps; // cache for state ops that must be moved
	memset((void*)(int*)rgStateOps,0,sizeof(int)*(rgStateOps.GetSize()));

	ixoEnum ixoOpCode = ixoNoop;
	PMsiRecord pParams(0);
	IMsiRecord* piPrevRecord = 0;
	riScript.Reset();
	Bool fFirstUpdateOpAdded = fFalse, fLastUpdateOpAdded = fFalse;
	int i;
	//!! logic below does not guarantee ixoProductInfo will be executed right away - it could be after some
	//!! other state operations - is this a problem?
	while(ixoOpCode != ixoEnd)
	{
		int cbOffset = riScript.GetIntegerValue() - riScript.Remaining();
		pParams = m_riServices.ReadScriptRecord(riScript, *&piPrevRecord, m_iScriptVersion);
		if (!pParams) // file error or premature end of file
		{
			// we make no assumptions that a rollback file is a valid script file
			// (e.g. that it ends with a complete record or with an ixoEnd operation)
			// if we can't read a script record, assume it is the end of the script
			
			// set ixoOpCode to ixoEnd to force flushing of cached ops
			ixoOpCode = ixoEnd;
		}
		else
			ixoOpCode = (ixoEnum)pParams->GetInteger(0);

		switch (rgOpTypes[(int)ixoOpCode])
		{
		case XOT_INIT:
			AddOpToList(cInitOps,rgInitOps,cbOffset);
			break;
		case XOT_FINALIZE:
			// flush state ops cache, ActionStart last
			for(i=0;i<ixoOpCodeCount;i++)
			{
				if((i != (int)ixoActionStart) && rgStateOps[i] != 0)
				{
					AddOpToList(cUpdateOps,rgUpdateOps,rgStateOps[i]-1);
					if(fFirstUpdateOpAdded) AddOpToList(cFirstUpdateOps,rgFirstUpdateOps,rgStateOps[i]-1);
					if(fLastUpdateOpAdded) AddOpToList(cLastUpdateOps,rgLastUpdateOps,rgStateOps[i]-1);
					rgStateOps[i] = 0;
				}
			}
			if(rgStateOps[(int)ixoActionStart] != 0)
			{
				AddOpToList(cUpdateOps,rgUpdateOps,rgStateOps[(int)ixoActionStart]-1);
				if(fFirstUpdateOpAdded) AddOpToList(cFirstUpdateOps,rgFirstUpdateOps,rgStateOps[(int)ixoActionStart]-1);
				if(fLastUpdateOpAdded) AddOpToList(cLastUpdateOps,rgLastUpdateOps,rgStateOps[(int)ixoActionStart]-1);
				rgStateOps[(int)ixoActionStart] = 0;
			}

			if(pParams) // we read an actual finalization op, not just eof and flushing ops
				AddOpToList(cFinalizeOps,rgFinalizeOps,cbOffset);
			break;
		case XOT_STATE:
		case XOT_GLOBALSTATE:
			if(ixoOpCode == ixoActionStart)
			{
				// special case - need to flush all cached state ops - ActionStart last
				for(i=0;i<ixoOpCodeCount;i++)
				{
					if((i != (int)ixoActionStart) && rgStateOps[i] != 0 && rgOpTypes[i] != XOT_GLOBALSTATE)
					{
						AddOpToList(cUpdateOps,rgUpdateOps,rgStateOps[i]-1);
						if(fFirstUpdateOpAdded) AddOpToList(cFirstUpdateOps,rgFirstUpdateOps,rgStateOps[i]-1);
						if(fLastUpdateOpAdded) AddOpToList(cLastUpdateOps,rgLastUpdateOps,rgStateOps[i]-1);
						rgStateOps[i] = 0;
					}
				}
			}
			// flush previous cached op, if there is one
			if(rgStateOps[(int)ixoOpCode] != 0)
			{
				AddOpToList(cUpdateOps,rgUpdateOps,rgStateOps[(int)ixoOpCode]-1);
				if(fFirstUpdateOpAdded) AddOpToList(cFirstUpdateOps,rgFirstUpdateOps,rgStateOps[(int)ixoOpCode]-1);
				if(fLastUpdateOpAdded) AddOpToList(cLastUpdateOps,rgLastUpdateOps,rgStateOps[(int)ixoOpCode]-1);
			}
			// cache this op
			rgStateOps[(int)ixoOpCode] = cbOffset + 1; // add 1 to prevent 0 offset
			if(ixoOpCode == ixoActionStart)
			{
				fFirstUpdateOpAdded = fFalse;
				fLastUpdateOpAdded = fFalse;
			}
			break;

		case XOT_UPDATEFIRST:
			fFirstUpdateOpAdded = fTrue;
			AddOpToList(cFirstUpdateOps,rgFirstUpdateOps,cbOffset);
			break;
		case XOT_UPDATELAST:
			fLastUpdateOpAdded = fTrue;
			AddOpToList(cLastUpdateOps,rgLastUpdateOps,cbOffset);
			break;
		case XOT_COMMIT:
			break; // commit opcodes don't run during rollback
		default: // XOT_UPDATE, XOT_MSG, XOT_ADVT
			AddOpToList(cUpdateOps,rgUpdateOps,cbOffset);
			break;
		};
	}
	riScript.Reset();
	iesEnum iesReturn = iesNoAction;
	if (piPrevRecord != 0)
	{
		piPrevRecord->Release();
		piPrevRecord = 0;
	}

#ifdef DEBUG
//  PMsiStream pTempStream(0);
//  AssertZero(m_riServices.CreateFileStream("c:\\winnt\\msi\\rollback.scr",fTrue, *&pTempStream));
//  CScriptGenerate sgTempScript(*pTempStream,0,istRollback, m_riServices);
#endif

	// run script
	// execute initialization ops
	for(i=0; i<cInitOps; i++)
	{
		riScript.Seek(rgInitOps[i]);
		PMsiRecord pParams = m_riServices.ReadScriptRecord(riScript, *&piPrevRecord, m_iScriptVersion);
		if (!pParams) // file error or premature end of file
		{
			Assert(0); // this should never happen - we have already read through the entire script above
		}
		else
		{
			ixoEnum ixoOpCode = (ixoEnum)pParams->GetInteger(0);
			DEBUGMSGIXO(ixoOpCode,*pParams);
			iesReturn = (this->*rgOpExecute[ixoOpCode])(*pParams);

			if(iesReturn == iesErrorIgnored)
				iesReturn = iesSuccess; // non-fatal error occurred - continue running script
		
			if (iesReturn != iesSuccess && iesReturn != iesNoAction)
			{
				// Bug #6500 - No failures in rollback - just keep on going.
				DEBUGMSG1(TEXT("Error in rollback skipped.  Return: %d"), (const ICHAR*)(INT_PTR) iesReturn);
			}
		}
	}

	// setup progress - don't call through Message, which suppresses progress during rollback
	// action start 
	if(!m_pRollbackAction)
		m_pRollbackAction = &m_riServices.CreateRecord(3);
	AssertZero(m_riMessage.Message(imtActionStart, *m_pRollbackAction) == imsCancel);

	// progress
	PMsiRecord pProgress = &m_riServices.CreateRecord(ProgressData::imdNextEnum);
	AssertNonZero(pProgress->SetInteger(ProgressData::imdSubclass, ProgressData::iscMasterReset));
	AssertNonZero(pProgress->SetInteger(ProgressData::imdProgressTotal,cUpdateOps+cFirstUpdateOps+cLastUpdateOps));
	AssertNonZero(pProgress->SetInteger(ProgressData::imdDirection,ProgressData::ipdBackward));
	AssertNonZero(pProgress->SetInteger(ProgressData::imdEventType,ProgressData::ietTimeRemaining));
	AssertZero((m_riMessage.Message(imtProgress, *pProgress)) == imsCancel);

	// action data
	PMsiRecord pActionData = &m_riServices.CreateRecord(1);
	
	for(int j=0; j<3; j++)
	{
		// execute first update, update, and last update operations, in that order
		int* rgOps = 0;
		int cOps = 0;
		switch(j)
		{
		case 0:
			rgOps = rgFirstUpdateOps; cOps = cFirstUpdateOps; break;
		case 1:
			rgOps = rgUpdateOps; cOps = cUpdateOps; break;
		case 2:
			rgOps = rgLastUpdateOps; cOps = cLastUpdateOps; break;
		default:
			Assert(0);
		};

		if (piPrevRecord != 0)
		{
			piPrevRecord->Release();
			piPrevRecord = 0;
		}

		if ( ! rgOps )
			return iesFailure;

		for(i=cOps-1; i>=0; i--)
		{
			riScript.Seek(rgOps[i]);
			PMsiRecord pParams = m_riServices.ReadScriptRecord(riScript, *&piPrevRecord, m_iScriptVersion);
#ifdef DEBUG
//          Assert(pParams);
//          ixoEnum ixoTemp = (ixoEnum)pParams->GetInteger(0);
//          AssertNonZero(sgTempScript.WriteRecord((ixoEnum)pParams->GetInteger(0),pParams));
#endif
			if (!pParams) // file error or premature end of file
			{
				Assert(0); // this should never happen since we have already read through the entire script
							  // above
			}
			else
			{
				ixoEnum ixoOpCode = (ixoEnum)pParams->GetInteger(0);
				if(ixoOpCode == ixoActionStart)
				{
					// setup and send ActionData record
					MsiString strActionDescription = pParams->GetMsiString(IxoActionStart::Description);
					if(strActionDescription.TextSize() == 0)
						strActionDescription = pParams->GetMsiString(IxoActionStart::Name);

					AssertNonZero(pActionData->SetMsiString(1, *strActionDescription));
					AssertZero((m_riMessage.Message(imtActionData, *pActionData)) == imsCancel);
				}
				// dispatch progress
				AssertNonZero(pProgress->SetInteger(ProgressData::imdSubclass, ProgressData::iscProgressReport));
				AssertNonZero(pProgress->SetInteger(ProgressData::imdIncrement, 1));
				AssertZero((m_riMessage.Message(imtProgress, *pProgress)) == imsCancel);

				// execute op
				DEBUGMSGIXO(ixoOpCode,*pParams);
				iesReturn = (this->*rgOpExecute[ixoOpCode])(*pParams);

				if(iesReturn == iesErrorIgnored)
					iesReturn = iesSuccess; // non-fatal error occurred - continue running script
		
				if (iesReturn != iesSuccess && iesReturn != iesNoAction)
				{
					// Bug #6500 - No failures in rollback - just keep on going.
					DEBUGMSG1(TEXT("Error in rollback skipped.  Return: %d"), (const ICHAR*)(INT_PTR) iesReturn);
				}
			}
		}
	}

	if (piPrevRecord != 0)
	{
		piPrevRecord->Release();
		piPrevRecord = 0;
	}
	// execute finalization ops
	for(i=0; i<cFinalizeOps; i++)
	{
		riScript.Seek(rgFinalizeOps[i]);
		PMsiRecord pParams = m_riServices.ReadScriptRecord(riScript, *&piPrevRecord, m_iScriptVersion);
		if (!pParams) // file error or premature end of file
		{
			Assert(0); // this should never happen - we have already read through the entire script above
		}
		else
		{
			ixoEnum ixoOpCode = (ixoEnum)pParams->GetInteger(0);
			DEBUGMSGIXO(ixoOpCode,*pParams);
			iesReturn = (this->*rgOpExecute[ixoOpCode])(*pParams);

			if(iesReturn == iesErrorIgnored)
				iesReturn = iesSuccess; // non-fatal error occurred - continue running script
		
			if (iesReturn != iesSuccess && iesReturn != iesNoAction)
			{
				// Bug #6500 - No failures in rollback - just keep on going.
				DEBUGMSG1(TEXT("Error in rollback skipped.  Return: %d"), (const ICHAR*)(INT_PTR) iesReturn);
			}
		}
	}
	if (piPrevRecord != 0)
	{
		piPrevRecord->Release();
		piPrevRecord = 0;
	}
	return iesReturn;
}

iesEnum CMsiExecute::GenerateRollbackScriptName(IMsiPath*& rpiPath, const IMsiString*& rpistr)
{
	CElevate elevate; // use high privileges for this function

	PMsiRecord pRecErr(0);
	iesEnum iesRet;
	PMsiPath pBackupFolder(0);
	PMsiPath pMsiFolder(0);
	MsiString strFile;

	if((iesRet = GetBackupFolder(0,*&pBackupFolder)) != iesSuccess)
		return iesRet;

	if((pRecErr = pBackupFolder->TempFileName(0,szRollbackScriptExt,fTrue, *&strFile, &CSecurityDescription(true, false))) != 0)
		return FatalError(*pRecErr);
	rpiPath = pBackupFolder;
	rpiPath->AddRef();
	strFile.ReturnArg(rpistr);
	return iesSuccess;
}

struct RBSInfo
{
	const IMsiString* pistrRollbackScript;
	MsiDate date;
	RBSInfo* pNext;

	RBSInfo(const IMsiString& ristr, MsiDate d);
	~RBSInfo();
};

RBSInfo::RBSInfo(const IMsiString& ristr, MsiDate d) : pistrRollbackScript(&ristr), date(d)
{
	pistrRollbackScript->AddRef();
}

RBSInfo::~RBSInfo()
{
	pistrRollbackScript->Release();
}

IMsiRecord* CMsiExecute::GetSortedRollbackScriptList(MsiDate date, Bool fAfter, RBSInfo*& rpListHead)
{
	PEnumMsiString pScriptEnum(0);
	PMsiRecord pError(0);
	if((pError = m_riConfigurationManager.GetRollbackScriptEnumerator(date,fAfter,*&pScriptEnum)) != 0)
		return pError;
      
	// place dates and scripts into a linked list - sort as we go
	rpListHead = 0;
	MsiString strRBSInfo;
	while((pScriptEnum->Next(1, &strRBSInfo, 0)) == S_OK)
	{
		MsiDate dScriptDate = (MsiDate)(int)MsiString(strRBSInfo.Extract(iseUpto, '#'));
		MsiString strScriptFile = strRBSInfo;
		strScriptFile.Remove(iseIncluding, '#');
		RBSInfo* pNewNode = new RBSInfo(*strScriptFile, dScriptDate);
		if ( ! pNewNode )
			return PostError(Imsg(idbgInitializeRollbackScript), *strScriptFile );
		
		RBSInfo* pTemp = 0;
		
		// place in linked list
		if(!rpListHead ||
			(fAfter ? ((int)rpListHead->date < (int)dScriptDate) : ((int)rpListHead->date > (int)dScriptDate)))
		{
			// need to place at start of list
			pTemp = rpListHead;
			rpListHead = pNewNode;
			pNewNode->pNext = pTemp;
		}
		else
		{
			for(RBSInfo* p = rpListHead;
				 p->pNext && (fAfter ? ((int)(p->pNext->date) > (int)dScriptDate) : ((int)(p->pNext->date) < (int)dScriptDate));
				 p = p->pNext);
			// place after node pointed to by p
			pTemp = p->pNext;
			p->pNext = pNewNode;
			pNewNode->pNext = pTemp;
		}
		
#ifdef DEBUG
		for(RBSInfo* pt = rpListHead;pt;pt=pt->pNext)
		{
		}
#endif

	}
	return 0;
}

void CMsiExecute::DeleteRollbackScriptList(RBSInfo* pListHead)
{
	for(RBSInfo* p = pListHead; p;)
	{
		RBSInfo* pTemp = p->pNext;
		delete p;
		p = pTemp;
	}
}

iesEnum CMsiExecute::RollbackFinalize(iesEnum iesState, MsiDate date, bool fUserChangedDuringInstall)
{
	enum iefrtEnum
	{
		iefrtNothing, // save rollback files if they exist
		iefrtRollback, // rollback to date
		iefrtPurge, // remove all rollback files to current date
	};
	
	iefrtEnum iefrt = iefrtNothing;
	
	Bool fRollbackScriptsDisabled = fFalse;
	PMsiRecord pError = m_riConfigurationManager.RollbackScriptsDisabled(fRollbackScriptsDisabled);
	if(pError)
		return FatalError(*pError);

	if(fRollbackScriptsDisabled)
		iesState = iesSuccess; // force cleanup - not rollback
	
	switch(iesState)
	{
	// success
	case iesSuccess:
	case iesFinished:
	case iesNoAction:
		if(m_irlRollbackLevel == irlRollbackNoSave)
			iefrt = iefrtPurge;
		else
			iefrt = iefrtNothing;
		break;
	
	// suspend
	case iesSuspend:
		iefrt = iefrtNothing;
		break;

	// failure
	default: // iesWrongState, iesBadActionData, iesInstallRunning
		Assert(0); // fall through
	case iesUserExit:
	case iesFailure:
		if(m_irlRollbackLevel == irlNone)
			iefrt = iefrtNothing;
		else
			iefrt = iefrtRollback;
		break;
	};

	iesEnum iesRet = iesSuccess;
	if(iefrt == iefrtPurge)
	{
		// purge rollback files to now

		// disable cancel button on dialog
		PMsiRecord pControlMessage = &m_riServices.CreateRecord(2);
		AssertNonZero(pControlMessage->SetInteger(1,(int)icmtCancelShow));
		AssertNonZero(pControlMessage->SetInteger(2,(int)fFalse));
		Message(imtCommonData, *pControlMessage);
		
		iesRet = RemoveRollbackFiles(ENG::GetCurrentDateTime());

		// re-enable cancel button on dialog
		AssertNonZero(pControlMessage->SetInteger(2,(int)fTrue));
		Message(imtCommonData, *pControlMessage);

		if (iesRet == iesFailure && fRollbackScriptsDisabled == fFalse) //!! which errors should force rollback? only Commit errors?
			iefrt = iefrtRollback;  // commit failed, force rollback
	}
	if(iefrt == iefrtRollback)
	{
		// rollback to date
		//FUTURE: we should disable the cancel button here, instead of around the running of each
		// rollback script
		iesRet = Rollback(date, fUserChangedDuringInstall);
	}

	if(fRollbackScriptsDisabled)
	{
		AssertRecord(m_riConfigurationManager.DisableRollbackScripts(fFalse)); // re-enable rollback scripts
	}
	
	return iesRet;
}

void CMsiOpExecute::GetRollbackPolicy(irlEnum& irlLevel)
{
	irlLevel = irlNone;

	if(!m_fKey)
	{
		// we were passed in an external hKey, rollback is disabled
		return;
	}

	// check registry for level of rollback support
	if(GetIntegerPolicyValue(szDisableRollbackValueName, fFalse) == 1 ||
	   GetIntegerPolicyValue(szDisableRollbackValueName, fTrue) == 1)
		irlLevel = irlNone;
	else
		irlLevel = irlRollbackNoSave;
}

iesEnum CMsiExecute::Rollback(MsiDate date, bool fUserChangedDuringInstall)
{
	RBSInfo* pListHead = 0;
	PMsiRecord pError = 0;
	
	if((pError = GetSortedRollbackScriptList(date,fTrue,pListHead)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	
	// run rollback scripts
	iesEnum iesRet = iesSuccess; //?? Is this initialization correct?
	Bool fReboot = fFalse;
	m_fUserChangedDuringInstall = fUserChangedDuringInstall;
	MsiString strRollbackScriptFullPath, strRollbackScriptName;
	PMsiPath pRollbackScriptPath(0);
	for(RBSInfo* p = pListHead; p; p=p->pNext)
	{
		Assert(p->pistrRollbackScript);
		strRollbackScriptFullPath = *(p->pistrRollbackScript);
		p->pistrRollbackScript->AddRef();

		// unregister rollback script
		pError = m_riConfigurationManager.UnregisterRollbackScript(strRollbackScriptFullPath); // ignore failure
		
		pError = m_riServices.CreateFilePath(strRollbackScriptFullPath,*&pRollbackScriptPath,*&strRollbackScriptName);
		if(pError)
		{
			// invalid path syntax, continue without error
			AssertRecordNR(pError);
			Message(imtInfo,*pError);
			continue;
		}
		
		iesRet = RunScript(strRollbackScriptFullPath, false);
		if (iesRet == iesFailure)
		{
			pError = PostError(Imsg(imsgRollbackScriptError));
			Message(imtError, *pError);
			iesRet = iesSuccess;
		}

		if(iesRet == iesUnsupportedScriptVersion)
			iesRet = iesFailure;
		
		if(iesRet == iesSuspend)
			fReboot = fTrue;

		if(iesRet != iesSuccess && iesRet != iesFinished && iesRet != iesNoAction && iesRet != iesSuspend) // failure
			continue; // continue without error

		// remove rollback script
		{
			CElevate elevate;
			RemoveFile(*pRollbackScriptPath,*strRollbackScriptName,fFalse,/*fBypassSFC*/ false,false); // ignore failure
		}
	}
	m_fUserChangedDuringInstall = false;

	DeleteRollbackScriptList(pListHead);

	if(fReboot)
		return iesSuspend;
	return iesRet;
}

iesEnum CMsiExecute::RemoveRollbackFiles(MsiDate date)
{
	Assert(m_ixsState == ixsIdle);
	
	RBSInfo* pListHead = 0;
	PMsiRecord pError = 0;
	
	Bool fAfter = fFalse;
	if((int)date == 0)
		fAfter = fTrue; // remove all rollback files - after 0
	if((pError = GetSortedRollbackScriptList(date,fAfter,pListHead)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	
	// run rollback scripts
	iesEnum iesRet = iesSuccess;
	for(RBSInfo* p = pListHead; p; p=p->pNext)
	{
		Assert(p->pistrRollbackScript);
		m_ixsState = ixsCommit;
		iesRet = RemoveRollbackScriptAndBackupFiles(*(p->pistrRollbackScript));
		m_ixsState = ixsIdle;
		if(iesRet != iesSuccess && iesRet != iesFinished && iesRet != iesNoAction)
			break;
		// unregister rollback script
		if((pError = m_riConfigurationManager.UnregisterRollbackScript(p->pistrRollbackScript->GetString())) != 0)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
	}

	DeleteRollbackScriptList(pListHead);

	return iesRet;
}
	
iesEnum CMsiExecute::RemoveRollbackScriptAndBackupFiles(const IMsiString& ristrScriptFile)
{
	int cBackupFiles = 0;
	CTempBuffer<int, 500> rgBackupFileOps;
	int cCommitOps = 0;
	CTempBuffer<int, 20>  rgCommitOps;
	memset((void*)(int*)rgBackupFileOps,0,sizeof(int)*(rgBackupFileOps.GetSize()));
	
	// open script
	PMsiRecord pError(0);
	PMsiStream pStream(0);
	
	{
		CElevate elevate; // elevate to read rollback script
		pError = m_riServices.CreateFileStream(ristrScriptFile.GetString(), fFalse, *&pStream);
	}
	
	if (pError)
	{
		// rollback script is missing or invalid, log warning and continue without failure
		Message(imtInfo, *pError);
		return iesSuccess;
	}

	// script is not elevated unless the header of the script is marked with isaElevate
	m_fRunScriptElevated = false;
	g_fRunScriptElevated = false;

	Assert(pStream);
	PMsiRecord pParams(0);
	iesEnum iesResult = iesNoAction;
	int cRecords = 0;
	ixoEnum ixoOpCode = ixoNoop;
	MsiString strPath, strFileName;
	PMsiPath pPath(0);
	IMsiRecord* piPrevRecord = 0;
	
	while(ixoOpCode != ixoEnd)
	{
		int cbOffset = pStream->GetIntegerValue() - pStream->Remaining();
		pParams = m_riServices.ReadScriptRecord(*pStream, *&piPrevRecord, m_iScriptVersion);
		if (!pParams) // file error or premature end of file
		{
			// we make no assumptions that a rollback file is a valid script file
			// (e.g. that it ends with a complete record or with an ixoEnd operation)
			// if we can't read a script record, assume it is the end of the script
			break;
		}
		ixoOpCode = (ixoEnum)pParams->GetInteger(0);
		if (ixoOpCode == ixoHeader)
		{
			// determine if this script should run elevated
			if(!pParams->IsNull(IxoHeader::ScriptAttributes))
			{
				DWORD isaScriptAttributes = pParams->GetInteger(IxoHeader::ScriptAttributes);
				if(isaScriptAttributes & isaElevate)
				{
					m_fRunScriptElevated = true;
					g_fRunScriptElevated = true;
				}

				// if the script is marked with the TS registry attribute, remap the appropriate HKCU
				// key and initialize the CA servers. Always respect rollback/commit script attributes.
				if (MinimumPlatformWindows2000() && IsTerminalServerInstalled())
				{
					m_fRemapHKCU = (isaScriptAttributes & isaUseTSRegistry) ? false : true;
					PrepareHydraRegistryKeyMapping(/*TSPerMachineInstall=*/!m_fRemapHKCU);
				}
			}
		}
		if (rgOpTypes[(int)ixoOpCode] == XOT_COMMIT)
		{
			AddOpToList(cCommitOps,rgCommitOps,cbOffset);
		}
		if(ixoOpCode == ixoRollbackInfo)
		{
			ixfRollbackInfo(*pParams); // set m_pCleanupAction
		}
		if(ixoOpCode == ixoRegisterBackupFile)
		{
			AddOpToList(cBackupFiles,rgBackupFileOps,cbOffset);
		}
	}

	if (piPrevRecord != 0)
	{
		piPrevRecord->Release();
		piPrevRecord = 0;
	}
	pStream->Reset();

	// setup progress - don't call through Message, which suppresses progress during rollback
	// action start 
	if(!m_pCleanupAction)
		m_pCleanupAction = &m_riServices.CreateRecord(3);
	AssertZero((m_riMessage.Message(imtActionStart, *m_pCleanupAction)) == imsCancel);

	{
		// elevate if necessary for this script execution
		CElevate elevate(m_fRunScriptElevated);
	
		// commit ops, if any returns failure then force rollback
		for(int iOp=0; iOp < cCommitOps; iOp++)
		{
			pStream->Seek(rgCommitOps[iOp]);
			pParams = m_riServices.ReadScriptRecord(*pStream, *&piPrevRecord, m_iScriptVersion);
			if (!pParams) // file error or premature end of file
			{
				Assert(0); // this should never happen - we have already read through the entire script above
				if (piPrevRecord != 0)
					piPrevRecord->Release();
				return iesFailure;
			}
			ixoOpCode = (ixoEnum)pParams->GetInteger(0);
			iesResult = (this->*rgOpExecute[ixoOpCode])(*pParams);
	
			if(iesResult == iesErrorIgnored)
				iesResult = iesSuccess; // non-fatal error occurred - continue running script
			
			if (iesResult == iesFailure)  //!! what should kill the install at this point?
			{
				if (piPrevRecord != 0)
					piPrevRecord->Release();
				return iesResult;
			}
			//!! would like progress here? but how to do it? by op count?
		}
	}

	if (piPrevRecord != 0)
	{
		piPrevRecord->Release();
		piPrevRecord = 0;
	}
	// progress
	using namespace ProgressData;
	PMsiRecord pProgress = &m_riServices.CreateRecord(ProgressData::imdNextEnum);
	AssertNonZero(pProgress->SetInteger(imdSubclass, iscMasterReset));
	AssertNonZero(pProgress->SetInteger(imdProgressTotal,cBackupFiles));
	AssertNonZero(pProgress->SetInteger(imdDirection,ipdForward));
	AssertNonZero(pProgress->SetInteger(imdEventType,ietTimeRemaining));
	AssertZero((m_riMessage.Message(imtProgress,*pProgress)) == imsCancel);

	// action data
	PMsiRecord pActionData = &m_riServices.CreateRecord(1);

	// remove backup files
	for(int i=0; i<cBackupFiles; i++)
	{
		pStream->Seek(rgBackupFileOps[i]);
		pParams = m_riServices.ReadScriptRecord(*pStream, *&piPrevRecord, m_iScriptVersion);
		if (!pParams) // file error or premature end of file
		{
			Assert(0); // this should never happen - we have already read through the entire script above
			// we make no assumptions that a rollback file is a valid script file
			// (e.g. that it ends with a complete record or with an ixoEnd operation)
			// if we can't read a script record, assume it is the end of the script
			break;
		}
		Assert((ixoEnum)pParams->GetInteger(0) == ixoRegisterBackupFile);
		strPath = pParams->GetMsiString(IxoRegisterBackupFile::File);

		// dispatch progress
		AssertNonZero(pActionData->SetMsiString(1,*strPath));
		AssertZero((m_riMessage.Message(imtActionData, *pActionData)) == imsCancel);
		AssertNonZero(pProgress->SetInteger(imdSubclass,iscProgressReport));
		AssertNonZero(pProgress->SetInteger(imdIncrement,1));
		AssertZero((m_riMessage.Message(imtProgress, *pProgress)) == imsCancel);

		if((pError = m_riServices.CreateFilePath(strPath, *&pPath, *&strFileName)) != 0)
		{
			AssertRecordNR(pError);
			Message(imtInfo, *pError);
		}
		else
		{
			CElevate elevate; // elevate to remove rollback files
			
			RemoveFile(*pPath, *strFileName, fFalse/*no rollback*/,/*fBypassSFC*/ false,false); // Ignore error
			RemoveFolder(*pPath); // Nothing we can do if it fails, so ignore error
		}
	}

	if (piPrevRecord != 0)
	{
		piPrevRecord->Release();
		piPrevRecord = 0;
	}
	// remove rollback script
	pStream = 0; // release
	
	if((pError = m_riServices.CreateFilePath(ristrScriptFile.GetString(),*&pPath,*&strFileName)) != 0)
	{
		AssertRecordNR(pError);
		Message(imtInfo, *pError);
	}
	else
	{
		CElevate elevate; // elevate to remove rollback script
		RemoveFile(*pPath,*strFileName,fFalse,/*fBypassSFC*/ false,false); //!! suppress error dialogs?
	}
	return iesSuccess;
}


iesEnum CMsiOpExecute::ixfDisableRollback(IMsiRecord& riParams)
{
	// disable rollback for remainder of script and remainder of install
	using namespace IxoDisableRollback;

	if(!RollbackRecord(Op,riParams))
		return iesFailure;

	Assert(m_ixsState != ixsRollback); // shouldn't be running a rollback script that contains this op
	Assert(m_pRollbackScript); // shouldn't have this op if rollback was disabled already

	if(m_pRollbackScript)
	{
		// close rollback script - will prevent future rollback processing
		delete m_pRollbackScript;
		m_pRollbackScript = 0;
	}
	
	m_irlRollbackLevel = irlNone;

	PMsiRecord pError = m_riConfigurationManager.DisableRollbackScripts(fTrue);
	if(pError)
		return FatalError(*pError);

	return iesSuccess;
}

IMsiRecord* CMsiOpExecute::SetSecureACL(IMsiPath& riPath, bool fHidden)
{
	// locks down a folder, but only when we don't own it already.
	// Note that locking down a folder does not necessarily protect the files within.
	// See LockdownPath to secure our configuration files.

	DWORD dwError = 0;
	char* rgchSD;
	if (ERROR_SUCCESS != (dwError = ::GetSecureSecurityDescriptor(&rgchSD, /*fAllowDelete*/fTrue, fHidden)))
		return PostError(Imsg(idbgOpSecureSecurityDescriptor), dwError);

	Bool fSetACL = fTrue;

	// an initial guess at the size of the descriptor.
	// This is slightly larger than machines I've tried this on.
	CTempBuffer<char, 3072> rgchFileSD;
	DWORD cLengthSD = 3072;

	BOOL fRet = ADVAPI32::GetFileSecurity((const ICHAR*)MsiString(riPath.GetPath()), DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
		(PSECURITY_DESCRIPTOR) rgchFileSD, cLengthSD, &cLengthSD);

	if (!fRet)
	{
		DWORD dwLastError = WIN::GetLastError();
		if (dwLastError == ERROR_INSUFFICIENT_BUFFER)
		{
			rgchFileSD.SetSize(cLengthSD);
			fRet = ADVAPI32::GetFileSecurity((const ICHAR*)MsiString(riPath.GetPath()), DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
				(PSECURITY_DESCRIPTOR) rgchFileSD, cLengthSD, &cLengthSD);
			dwLastError = WIN::GetLastError();
		}
		else fRet = FALSE;

		if (!fRet)
			return PostError(Imsg(imsgGetFileSecurity), dwLastError, MsiString(riPath.GetPath()));
	}

	// Check the current SD on the file; don't bother setting our SD if we already own object
	if (FIsSecurityDescriptorSystemOwned(rgchFileSD))
	{
		fSetACL = fFalse;
	}

	CRefCountedTokenPrivileges(itkpSD_WRITE, fSetACL);
	if (fSetACL && !WIN::SetFileSecurity(MsiString(riPath.GetPath()),
		  DACL_SECURITY_INFORMATION|OWNER_SECURITY_INFORMATION, (char*)rgchSD))
		return PostError(Imsg(imsgOpSetFileSecurity), GetLastError(), MsiString(riPath.GetPath()));

	return 0;
}


iesEnum CMsiOpExecute::GetBackupFolder(IMsiPath* piRootPath, IMsiPath*& rpiFolder)
{
	//!! TODO: fairly expensive function that is called quite a bit
	//!! TODO: cache backup folder when determined and compare volumes in next call
	
	CElevate elevate; // use high privileges for this function

	PMsiRecord pRecErr(0);
	rpiFolder = 0;
	Bool fMakeHidden = fTrue;
	PMsiPath pPath(0);

	PMsiPath pRootPath(0);

	// if piRootPath not specific, use drive holding our temp directory
	if(piRootPath == 0)
	{
		MsiString strMsiDir = ENG::GetTempDirectory();
		if((pRecErr = m_riServices.CreatePath(strMsiDir,*&pRootPath)) != 0)
			return FatalError(*pRecErr);
	}
	else
	{
		pRootPath = piRootPath;
		piRootPath->AddRef();
	}
	
	// use riPath - first, check if "Config.Msi" folder on volume is writable,
	PMsiVolume pVolume(&(pRootPath->GetVolume()));
	idtEnum idtType = pVolume->DriveType();

	AssertRecord(m_riServices.CreatePath(MsiString(pVolume->GetPath()),
													 *&pPath));
	AssertRecord(pPath->AppendPiece(*MsiString(szBackupFolder)));
	Bool fWritable = fFalse;

	// We should only secure the config.msi directory.
	Bool fSecurable = fFalse;

	// Also, on a remote drive, don't try creating the config.msi directory.
	if((pRecErr = pPath->Writable(fWritable)) != 0 || fWritable == fFalse || idtRemote == idtType)
	{
		// try path itself -- this is a user owned directory, so be careful with its
		// permission settings or deleting extra stuff.
		if((pRecErr = pRootPath->Writable(fWritable)) != 0 || fWritable == fFalse)
		{
			// error
			DispatchError(imtError,Imsg(imsgDirectoryNotWritable),
							  *MsiString(pRootPath->GetPath()));
			return iesFailure;
		}
		else
		{
			rpiFolder = pRootPath;
			rpiFolder->AddRef();
		}
	}
	else
	{
		fSecurable = fTrue;
		rpiFolder = pPath;
		rpiFolder->AddRef();
	}

	Bool fExists;
	if((pRecErr = rpiFolder->Exists(fExists)) != 0)
	{
		rpiFolder->Release();
		rpiFolder = 0;
		return FatalError(*pRecErr);
	}
	if(fExists)
	{
		if (RunningAsLocalSystem())
		{
			if (fSecurable && (pRecErr = SetSecureACL(*rpiFolder, /*fHidden=*/true)) != 0)
				return FatalError(*pRecErr);
		}
		return iesSuccess;
	}
	iesEnum iesRet;

	PMsiStream pSecurityDescriptorStream(0);
	if (RunningAsLocalSystem())
	{
		if (fSecurable && (pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptorStream, /*fHidden=*/true)) != 0)
			return FatalError(*pRecErr);
	}

	if((iesRet = CreateFolder(*rpiFolder, fFalse, fFalse, pSecurityDescriptorStream)) != iesSuccess)
	{
		rpiFolder->Release();
		rpiFolder = 0;
		return iesRet;
	}

	if(fMakeHidden)
	{
		// set folder attributes
		AssertRecord(rpiFolder->SetAllFileAttributes(0,FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM));
	}
	return iesSuccess;
}

iesEnum CMsiExecute::ExecuteRecord(ixoEnum ixoOpCode, IMsiRecord& riParams)
{
	if ((unsigned)ixoOpCode >= ixoOpCodeCount)
		return iesNoAction;

	return (this->*rgOpExecute[ixoOpCode])(riParams);
}

IMsiRecord* CMsiExecute::EnumerateScript(const ICHAR* szScriptFile, IEnumMsiRecord*& rpiEnumerator)
{
	return ::CreateScriptEnumerator(szScriptFile, m_riServices, rpiEnumerator);
}

const IMsiString& ComposeDescriptor(const IMsiString& riProductCode, const IMsiString& riFeature, const IMsiString& riComponent, bool fComClassicInteropForAssembly)
{
	int cchFeatureLen = riFeature.TextSize();
	int cchComponentLen = riComponent.TextSize();

	if(!cchFeatureLen || !cchComponentLen)
		return g_MsiStringNull; // empty string

	int cchLen = IStrLen(riComponent.GetString());
	MsiString strMsiDesc;
	int iOptimization = 0;
	if(cchComponentLen != cchLen) // multi_sz
	{
		iOptimization = MsiString(*(riComponent.GetString() + cchLen + 1));
	}

	if(iOptimization & ofSingleComponent)
	{
		cchComponentLen = 0; // can skip the component
	}
	else
	{
		// feature has multiple components, need to use compressed guid
		cchComponentLen = cchComponentIdCompressed;
	}
	if(iOptimization & ofSingleFeature)
	{
		cchFeatureLen = 0; // can skip the feature
	}

	// no expectation of DBCS characters (Feature names follow identifier rules, GUID is hex)
	ICHAR* szBuf = strMsiDesc.AllocateString((fComClassicInteropForAssembly ? 1 : 0) /* for chGUIDCOMToCOMPlusInteropToken */ + (cchProductCodeCompressed + cchFeatureLen + cchComponentLen + 1/* for the chGUIDAbsentToken OR the chComponentGUIDSeparatorToken*/), /*fDBCS=*/fFalse);
	if(fComClassicInteropForAssembly)
	{
		szBuf[0] = chGUIDCOMToCOMPlusInteropToken;
		szBuf++;
	}
	AssertNonZero(PackGUID(riProductCode.GetString(), szBuf, ipgCompressed)); // product code

	if(cchFeatureLen)
	{
		memcpy(szBuf + cchProductCodeCompressed, riFeature.GetString(), cchFeatureLen* sizeof(ICHAR)); // feature
	}
	if(cchComponentLen)
	{
		// feature has multiple components, need to use compressed guid
		szBuf[cchProductCodeCompressed + cchFeatureLen] = chComponentGUIDSeparatorToken;
		AssertNonZero(PackGUID(riComponent.GetString(), szBuf + cchProductCodeCompressed + cchFeatureLen + 1, ipgCompressed)); // component id
	}
	else
	{
		szBuf[cchProductCodeCompressed + cchFeatureLen] = chGUIDAbsentToken;
		szBuf[cchProductCodeCompressed + cchFeatureLen + 1] = 0;
	}
	return strMsiDesc.Return();
}

// this function may also be used in case we have a darwin descriptor referring to an alien product (for rollback)
// here the feature string is empty
const IMsiString& CMsiOpExecute::ComposeDescriptor(const IMsiString& riFeature, const IMsiString& riComponent, bool fComClassicInteropForAssembly)
{
	return ::ComposeDescriptor(*MsiString(GetProductKey()), riFeature, riComponent, fComClassicInteropForAssembly);
}


IMsiRecord* CMsiOpExecute::GetShellFolder(int iFolderId, const IMsiString*& rpistrLocation)
{
	// we have a shell folder id
	// we may need to translate the folderid from personal to all users
	// OR vice versa depending on the SCRIPTFLAGS_MACHINEASSIGN flag

	// ALLUSER shell folders dont exist on Win9X so  always use personal folders
	const ShellFolder* pShellFolder = 0;
	if(!g_fWin9X && (m_fFlags & SCRIPTFLAGS_MACHINEASSIGN))
	{
		pShellFolder = rgPersonalProfileShellFolders;
	}
	else
	{
		pShellFolder = rgAllUsersProfileShellFolders;
	}
	for (; pShellFolder->iFolderId >= 0; pShellFolder++)
	{
		if(iFolderId == pShellFolder->iFolderId)
		{
			iFolderId = pShellFolder->iAlternateFolderId;
			break;
		}
	}
	return m_riServices.GetShellFolderPath(iFolderId, !g_fWin9X && (m_fFlags & SCRIPTFLAGS_MACHINEASSIGN), rpistrLocation);
}

//____________________________________________________________________________
//
// EnumerateScript implementation - enumerates operation records without execution
//____________________________________________________________________________

class CEnumScriptRecord : public IEnumMsiRecord
{
 public:
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT __stdcall Next(unsigned long cFetch, IMsiRecord** rgpi, unsigned long* pcFetched);
	HRESULT __stdcall Skip(unsigned long cSkip);
	HRESULT __stdcall Reset();
	HRESULT __stdcall Clone(IEnumMsiRecord** ppiEnum);
 public: // constructor
	CEnumScriptRecord(IMsiServices& riServices, IMsiStream& riStream);
 protected:
  ~CEnumScriptRecord(); // protected to prevent creation on stack
	unsigned long    m_iRefCnt;      // reference count
	IMsiStream&      m_riScript;     // ref count transferred at construction
	IMsiServices&    m_riServices;   // owns a ref count to prevent destruction
	IMsiRecord*      m_piPrevRecord;
	int              m_iScriptVersion;
};

CEnumScriptRecord::CEnumScriptRecord(IMsiServices& riServices, IMsiStream& riStream)
 : m_riScript(riStream),
	m_riServices(riServices),
	m_piPrevRecord(0),
	m_iScriptVersion(0),
	m_iRefCnt(1)
{
	riServices.AddRef();  // riStream already refcnt'd by creator
}

CEnumScriptRecord::~CEnumScriptRecord()
{
	if (m_piPrevRecord != 0)
		m_piPrevRecord->Release();
}

HRESULT CEnumScriptRecord::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IEnumMsiRecord)
	{
		*ppvObj = this;
		AddRef();
		return S_OK;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CEnumScriptRecord::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CEnumScriptRecord::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	PMsiServices pServices(&m_riServices); // release after delete
	m_riScript.Release();
	delete this;
	return 0;
}

HRESULT CEnumScriptRecord::Next(unsigned long cFetch, IMsiRecord** rgpi, unsigned long* pcFetched)
{
	unsigned long cFetched = 0;

	if (rgpi)
	{
		while (cFetched < cFetch)
		{
			IMsiRecord* piRecord = m_riServices.ReadScriptRecord(m_riScript, *&m_piPrevRecord, m_iScriptVersion);
			if (!piRecord)     // end of file or error
				break;
			if (piRecord->GetInteger(0) == ixoHeader)
			{
				m_iScriptVersion = piRecord->GetInteger(IxoHeader::ScriptMajorVersion);
			}
			*rgpi = piRecord;  // transfers refcnt
			rgpi++;
			cFetched++;
		}
	}
	if (pcFetched)
		*pcFetched = cFetched;
	return (cFetched == cFetch ? S_OK : S_FALSE);
}

HRESULT CEnumScriptRecord::Skip(unsigned long cSkip)
{
	while (cSkip--)
	{
		IMsiRecord* piRecord = m_riServices.ReadScriptRecord(m_riScript, *&m_piPrevRecord, m_iScriptVersion);
		if (!piRecord)
			return S_FALSE;
		if (piRecord->GetInteger(0) == ixoHeader)
		{
			m_iScriptVersion = piRecord->GetInteger(IxoHeader::ScriptMajorVersion);
		}
		piRecord->Release();
	}
	return S_OK;
}

HRESULT CEnumScriptRecord::Reset()
{
	m_riScript.Reset();
	return S_OK;
}

HRESULT CEnumScriptRecord::Clone(IEnumMsiRecord** /*ppiEnum*/)
{
	return E_NOTIMPL; // need to implement Clone on underlying stream first
}

IMsiRecord* CreateScriptEnumerator(const ICHAR* szScriptFile, IMsiServices& riServices, IEnumMsiRecord*& rpiEnum)
{
	IMsiStream* piStream;
	IMsiRecord* piError = riServices.CreateFileStream(szScriptFile, fFalse, piStream);
	if (piError)
		return piError;
	rpiEnum = new CEnumScriptRecord(riServices, *piStream);
	return 0;
}


//____________________________________________________________________________
//
// IMsiOpExecute helper functions
//____________________________________________________________________________

// GetSharedRecord: returns one of cached records - caller should not hold reference to record
IMsiRecord& CMsiOpExecute::GetSharedRecord(int cParams)
{
	int iRecord = cParams;  // index into record cache
	if (cParams > cMaxSharedRecord)
	{
		iRecord = cMaxSharedRecord + 1;  // overflow record
		if (m_rgpiSharedRecords[cMaxSharedRecord+1])
		{
			if (m_rgpiSharedRecords[cMaxSharedRecord+1]->GetFieldCount() != cParams)
			{
				m_rgpiSharedRecords[cMaxSharedRecord+1]->Release();
				m_rgpiSharedRecords[cMaxSharedRecord+1] = 0;
			}
		}
	}
	if (!m_rgpiSharedRecords[iRecord])
		m_rgpiSharedRecords[iRecord] = &m_riServices.CreateRecord(cParams);

	if(m_rgpiSharedRecords[iRecord]->ClearData() == fFalse)
	{
		// failed to clear record, probably because something else is holding a reference
		// need to release this record and create a new one
		m_rgpiSharedRecords[iRecord]->Release();
		m_rgpiSharedRecords[iRecord] = &m_riServices.CreateRecord(cParams);
	}
	return *m_rgpiSharedRecords[iRecord];
}

imsEnum CMsiOpExecute::Message(imtEnum imt, IMsiRecord& riRecord)
{

	if(m_cSuppressProgress > 0 && (imt == imtActionData || imt == imtProgress))
		return imsNone;

	if (m_ixsState == ixsRollback || m_ixsState == ixsCommit)
	{


		// suppress progress messages if running rollback script - progress handles externally
		if (imt == imtActionStart || imt == imtActionData || imt == imtProgress)
			return imsNone;

		// Bug #6500:  Suppress any error messages during rollback.
		int imsg = (unsigned)(imt & ~iInternalFlags) >> imtShiftCount;
		switch (imsg)
		{
			case imtInfo        >> imtShiftCount: 
			case imtWarning        >> imtShiftCount:
			case imtError          >> imtShiftCount:
			case imtUser           >> imtShiftCount:
			case imtFatalExit      >> imtShiftCount:
			case imtOutOfDiskSpace >> imtShiftCount:
				imt = imtInfo;
				break;
			default:
				break;
		}

	}

	imsEnum ims = m_riMessage.Message(imt, riRecord);
	if(ims == imsCancel && (m_ixsState != ixsRollback))
		m_fCancel = fTrue;
	return ims;
}

bool ShouldGoToEventLog(imtEnum imtArg);

imsEnum CMsiOpExecute::DispatchMessage(imtEnum imt, IMsiRecord& riRecord, Bool fConfirmCancel)
{
	int i;
	bool fFound;
	int iError;
	for ( i = 0, fFound = false, iError = riRecord.GetInteger(1);
			m_rgDisplayOnceMessages[i] && !fFound; i++ )
	{
		if ( HIWORD(m_rgDisplayOnceMessages[i]) == iError )
		{
			fFound = true;
			if ( !LOWORD(m_rgDisplayOnceMessages[i]) )
				// it's OK to display the message this time and I signal that
				// it had been displayed.
				m_rgDisplayOnceMessages[i] |= MAKELONG(1, 0);
			else
				// the message had already been displayed, I make it go into the log
				// and possibly into the eventlog.
				imt = (imtEnum)((ShouldGoToEventLog(imt) ? imtSendToEventLog : 0) | imtInfo);
		}
	}

	MsiString strError = riRecord.GetMsiString(0);
	for(;;)
	{
		imsEnum ims = Message(imt, riRecord);
		if(fConfirmCancel && (ims == imsAbort || ims == imsCancel))
		{
			if(!m_pConfirmCancelRec)
			{
				m_pConfirmCancelRec = &m_riServices.CreateRecord(1);
			}
			ISetErrorCode(m_pConfirmCancelRec, Imsg(imsgConfirmCancel)); // have to do this each time
			switch(Message(imtEnum(imtUser+imtYesNo+imtDefault2), *m_pConfirmCancelRec))
			{
			case imsNo:
				AssertNonZero(riRecord.SetMsiString(0,*strError)); // set error string and number again, since Message always
																				  // pre-pends "Error [1]. " to the message string
				m_fCancel = fFalse; // it was set by Message
				continue;
			default: // imsNone, imsYes
				if(ims == imsCancel) //!! should handle imsAbort here also
					m_fCancel = fTrue;
				return ims;
			}
		}
		else
		{
			if(ims == imsCancel) //!! should handle imsAbort here also
				m_fCancel = fTrue;
			return ims;
		}
	}
}


imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg)
{
	IMsiRecord& riError = GetSharedRecord(1);
	ISetErrorCode(&riError, imsg);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, const IMsiString& riStr)
{
	IMsiRecord& riError = GetSharedRecord(2);
	ISetErrorCode(&riError, imsg);
	riError.SetMsiString(2, riStr);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, int i)
{
	IMsiRecord& riError = GetSharedRecord(2);
	ISetErrorCode(&riError, imsg);
	riError.SetInteger(2, i);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, int i, const ICHAR* sz)
{
	IMsiRecord& riError = GetSharedRecord(3);
	ISetErrorCode(&riError, imsg);
	riError.SetInteger(2, i);
	riError.SetString(3, sz);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, const IMsiString& riStr1, const IMsiString& riStr2)
{
	IMsiRecord& riError = GetSharedRecord(3);
	ISetErrorCode(&riError, imsg);
	riError.SetMsiString(2, riStr1);
	riError.SetMsiString(3, riStr2);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, const IMsiString& riStr1, const IMsiString& riStr2, const IMsiString& riStr3)
{
	IMsiRecord& riError = GetSharedRecord(4);
	ISetErrorCode(&riError, imsg);
	riError.SetMsiString(2, riStr1);
	riError.SetMsiString(3, riStr2);
	riError.SetMsiString(4, riStr3);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, const IMsiString& riStr1, const IMsiString& riStr2,
									 const IMsiString& riStr3, int i)
{
	IMsiRecord& riError = GetSharedRecord(5);
	ISetErrorCode(&riError, imsg);
	riError.SetMsiString(2, riStr1);
	riError.SetMsiString(3, riStr2);
	riError.SetMsiString(4, riStr3);
	riError.SetInteger(5, i);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, const IMsiString& riStr1,
												 const IMsiString& riStr2, const IMsiString& riStr3,
												 const IMsiString& riStr4, const IMsiString& riStr5)
{
	IMsiRecord& riError = GetSharedRecord(6);
	ISetErrorCode(&riError, imsg);
	riError.SetMsiString(2, riStr1);
	riError.SetMsiString(3, riStr2);
	riError.SetMsiString(4, riStr3);
	riError.SetMsiString(5, riStr4);
	riError.SetMsiString(6, riStr5);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, const ICHAR* sz, int i)
{
	IMsiRecord& riError = GetSharedRecord(3);
	ISetErrorCode(&riError, imsg);
	riError.SetString(2, sz);
	riError.SetInteger(3,i);
	return DispatchMessage(imtType, riError, fTrue);
}

imsEnum CMsiOpExecute::DispatchError(imtEnum imtType, IErrorCode imsg, const ICHAR* sz, int i1,int i2,int i3)
{
	IMsiRecord& riError = GetSharedRecord(5);
	ISetErrorCode(&riError, imsg);
	riError.SetString(2, sz);
	riError.SetInteger(3,i1);
	riError.SetInteger(4,i2);
	riError.SetInteger(5,i3);
	return DispatchMessage(imtType, riError, fTrue);
}

bool CMsiOpExecute::WriteRollbackRecord(ixoEnum ixoOpCode, IMsiRecord& riParams)
{
	return WriteScriptRecord(m_pRollbackScript, ixoOpCode, riParams, true, m_riMessage);
}

// Rollback script handling
bool CMsiOpExecute::RollbackRecord(ixoEnum ixoOpcode, IMsiRecord& riParams)
{
	return m_pRollbackScript ? WriteRollbackRecord(ixoOpcode, riParams) : true;
}

Bool CMsiOpExecute::RollbackEnabled(void)
{
	return m_pRollbackScript ? fTrue : fFalse;
}

// accessors for current ProductInfo record

const IMsiString& CMsiOpExecute::GetProductKey()        {return m_piProductInfo->GetMsiString(IxoProductInfo::ProductKey);}
const IMsiString& CMsiOpExecute::GetProductName()       {return m_piProductInfo->GetMsiString(IxoProductInfo::ProductName);}
const IMsiString& CMsiOpExecute::GetPackageName()       {return m_piProductInfo->GetMsiString(IxoProductInfo::PackageName);}
int               CMsiOpExecute::GetProductLanguage()   {return m_piProductInfo->GetInteger(  IxoProductInfo::Language);}
int               CMsiOpExecute::GetProductVersion()    {return m_piProductInfo->GetInteger(  IxoProductInfo::Version);}
int               CMsiOpExecute::GetProductAssignment() {return m_piProductInfo->GetInteger(  IxoProductInfo::Assignment);}
int               CMsiOpExecute::GetProductInstanceType(){return m_piProductInfo->IsNull(IxoProductInfo::InstanceType) ? 0 : m_piProductInfo->GetInteger( IxoProductInfo::InstanceType);}
const IMsiString& CMsiOpExecute::GetProductIcon()       {return m_piProductInfo->GetMsiString(IxoProductInfo::ProductIcon);}
const IMsiString& CMsiOpExecute::GetPackageMediaPath()  {return m_piProductInfo->GetMsiString(IxoProductInfo::PackageMediaPath);}
const IMsiString& CMsiOpExecute::GetPackageCode()       {return m_piProductInfo->GetMsiString(IxoProductInfo::PackageCode);}
bool              CMsiOpExecute::GetAppCompatCAEnabled(){return (!m_piProductInfo->IsNull(IxoProductInfo::AppCompatDB) && !m_piProductInfo->IsNull(IxoProductInfo::AppCompatID));}

// convert a stored GUID string in the product info record at iField into a GUID and
// store it in the provided buffer. Returns a pointer to the provided buffer if
// successful and NULL if the field is NULL or on error.
const GUID* CMsiOpExecute::GUIDFromProdInfoData(GUID* pguidOutputBuffer, int iField)
{
	// check field for NULL
	if (m_piProductInfo->IsNull(iField))
		return NULL;

	// retrieve stream pointer
	PMsiData piData(m_piProductInfo->GetMsiData(iField));
	if (!piData)
		return NULL;
	PMsiStream piStream(0);
	if(piData->QueryInterface(IID_IMsiStream, (void**)&piStream) != S_OK)
		return NULL;
	if (!piStream)
		return NULL;
	
	// extract GUID from stream
	piStream->Reset();
	if (sizeof(GUID) != piStream->GetData(pguidOutputBuffer, sizeof(GUID)))
		return NULL;

	// return GUID buffer.
	return pguidOutputBuffer; 
}

const GUID* CMsiOpExecute::GetAppCompatDB(GUID* pguidOutputBuffer) { return GUIDFromProdInfoData(pguidOutputBuffer, IxoProductInfo::AppCompatDB); };
const GUID* CMsiOpExecute::GetAppCompatID(GUID* pguidOutputBuffer) { return GUIDFromProdInfoData(pguidOutputBuffer, IxoProductInfo::AppCompatID); };


//____________________________________________________________________________
//
// IMsiOpExecute operator functions, all of type FOpExecute
//____________________________________________________________________________

// Script management operations

iesEnum CMsiOpExecute::ixfFail(IMsiRecord& /*riParams*/)
{
	return iesFailure;
}

iesEnum CMsiOpExecute::ixfNoop(IMsiRecord& /*riParams*/)
{
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfFullRecord(IMsiRecord& /*riParams*/)
{
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfHeader(IMsiRecord& riParams)
{
	using namespace IxoHeader;
	using namespace ProgressData;
	if (riParams.GetInteger(Signature) != iScriptSignature)
		return iesBadActionData;
	int iMsiVersion = riParams.GetInteger(Version);
	MsiDate iDate = MsiDate(riParams.GetInteger(Timestamp));
	int iLangId = riParams.GetInteger(LangId);
	istEnum istScriptType = (istEnum)riParams.GetInteger(ScriptType);

	AssertNonZero(m_pProgressRec->SetInteger(imdSubclass, iscMasterReset));
	AssertNonZero(m_pProgressRec->SetInteger(imdProgressTotal, m_iProgressTotal));
	AssertNonZero(m_pProgressRec->SetInteger(imdDirection, ipdForward));
	AssertNonZero(m_pProgressRec->SetInteger(imdEventType,ietTimeRemaining));
	if(Message(imtProgress, *m_pProgressRec) == imsCancel)
		return iesUserExit;

	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfEnd(IMsiRecord& /*riParams*/)
{
	using namespace IxoEnd;
//!! validate checksum?
//  if (ixsState == ixsRunning)
	return iesFinished;
}

UINT IsProductManaged(const ICHAR* szProductKey, bool &fIsProductManaged)
{
	Assert(szProductKey && *szProductKey);

	fIsProductManaged = false;
	DWORD dwRet = ERROR_SUCCESS;

	if (g_fWin9X == false)
	{
		MsiString strProductKeySQUID = GetPackedGUID(szProductKey);
		CRegHandle HProductKey;
		iaaAppAssignment iType = iaaNone;
		dwRet = GetProductAssignmentType(strProductKeySQUID, iType, HProductKey);
		if (ERROR_SUCCESS == dwRet && (iType == iaaUserAssign || iType == iaaMachineAssign))
		{
			// check for the security on the key if context is "managed"
			char* rgchSD;
			dwRet = ::GetSecureSecurityDescriptor(&rgchSD);
			if (ERROR_SUCCESS == dwRet)
			{
						
				if ((ERROR_SUCCESS == FIsKeySystemOrAdminOwned(HProductKey, fIsProductManaged)) && fIsProductManaged)
				{                   
					DEBUGMSG1(TEXT("Product %s is admin assigned: LocalSystem owns the publish key."), szProductKey);
				}
			}
		}
		Assert(ERROR_SUCCESS == dwRet || ERROR_FILE_NOT_FOUND == dwRet);
	}
	else
		fIsProductManaged = true;


	DEBUGMSG2(TEXT("Product %s %s."), szProductKey && *szProductKey ? szProductKey : TEXT("first-run"), fIsProductManaged ? TEXT("is managed") : TEXT("is not managed"));
	return dwRet;
}

bool IsProductManaged(const ICHAR* szProductKey)
{
	bool fManaged=false;
	IsProductManaged(szProductKey, fManaged);
	return fManaged;
}

iesEnum CMsiOpExecute::ixfProductInfo(IMsiRecord& riParams)
{
	using namespace IxoProductInfo;
	//!! TODO: make sure the record parameters are valid

#ifdef DEBUG
	const ICHAR* szProductName = riParams.GetString(ProductName);
#endif //DEBUG
	
	if(riParams.GetFieldCount())
	{
		if (m_piProductInfo->GetFieldCount() == 0)
		{
			// null record, not saved on stack
			m_piProductInfo->Release();
			m_piProductInfo = 0;
		}
#ifdef _WIN64       // !merced
		riParams.SetHandle(0, (HANDLE)m_piProductInfo);  // keeps ref-counted object in field 0
#else
		riParams.SetInteger(0, (int)m_piProductInfo);  // keeps ref-counted object in field 0
#endif
		//!! do we have to clear any other variables in prep. for nested install?
		m_piProductInfo = &riParams, riParams.AddRef();
		if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN_SCRIPTSETTINGS)
		{
			// we need to preserve the request in the script
			(!riParams.IsNull(Assignment) && riParams.GetInteger(Assignment)) ? m_fFlags |= SCRIPTFLAGS_MACHINEASSIGN : m_fFlags &= ~SCRIPTFLAGS_MACHINEASSIGN;
		}

		// this is the time to initialise the per machine vs per user variables
		iesEnum iesRet  = DoMachineVsUserInitialization();
		if(iesRet != iesSuccess)
			return iesRet;
	}
	else
	{
		// restore previous product info
		PMsiRecord pOldInfo = m_piProductInfo;  // force release of old record
#ifdef _WIN64       // !merced
		m_piProductInfo = (IMsiRecord*)pOldInfo->GetHandle(0);
#else
		m_piProductInfo = (IMsiRecord*)pOldInfo->GetInteger(0);
#endif
		Assert(m_piProductInfo != (IMsiRecord*)((INT_PTR)iMsiNullInteger));
	}

	// generate undo operation
	Assert(m_piProductInfo && m_piProductInfo->GetFieldCount());
	
#ifdef DEBUG
	szProductName = riParams.GetString(ProductName);
#endif //DEBUG

	if (!RollbackRecord(Op, *m_piProductInfo))
		return iesFailure;

	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfDialogInfo(IMsiRecord& riParams)
{
	using namespace IxoDialogInfo;
	Message(imtCommonData, riParams);
	
	// generate undo operation
	if((icmtEnum)riParams.GetInteger(1) == icmtCancelShow)
	{
		// in rollback script, always disable cancel button
		riParams.SetInteger(2, (int)fFalse);
	}
	if (!RollbackRecord(Op, riParams))
		return iesFailure;

	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfRollbackInfo(IMsiRecord& riParams)
{
	using namespace IxoRollbackInfo;
	if(!m_pRollbackAction)
		m_pRollbackAction = &m_riServices.CreateRecord(3);
	if(!m_pCleanupAction)
		m_pCleanupAction = &m_riServices.CreateRecord(3);
	AssertNonZero(m_pRollbackAction->SetMsiString(1,*MsiString(riParams.GetMsiString(RollbackAction))));
	AssertNonZero(m_pRollbackAction->SetMsiString(2,*MsiString(riParams.GetMsiString(RollbackDescription))));
	AssertNonZero(m_pRollbackAction->SetMsiString(3,*MsiString(riParams.GetMsiString(RollbackTemplate))));
	AssertNonZero(m_pCleanupAction->SetMsiString(1,*MsiString(riParams.GetMsiString(CleanupAction))));
	AssertNonZero(m_pCleanupAction->SetMsiString(2,*MsiString(riParams.GetMsiString(CleanupDescription))));
	AssertNonZero(m_pCleanupAction->SetMsiString(3,*MsiString(riParams.GetMsiString(CleanupTemplate))));

	if (!RollbackRecord(ixoRollbackInfo, riParams))
		return iesFailure;

	return iesSuccess;
}

// Notification operations

iesEnum CMsiOpExecute::ixfInfoMessage(IMsiRecord& riParams)
{
	using namespace IxoInfoMessage;
	Message(imtInfo, riParams);
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfActionStart(IMsiRecord& riParams)
{
	using namespace IxoActionStart;
#ifdef DEBUG
	const ICHAR* sz = riParams.GetString(Name);
	const ICHAR* sz2 = riParams.GetString(Description);
#endif //DEBUG

	// reset state variables
	delete &m_state;
	m_state = *(new (&m_state) CActionState);

	iesEnum iesReturn = iesSuccess;
	AssertNonZero(m_pProgressRec->SetMsiString(3, *MsiString(riParams.GetMsiString(Name)))); // set action name
	if(Message(imtActionStart, riParams) == imsCancel)
		return iesUserExit;

	// generate undo operation - undo op will reset state, but message will not be displayed
	// since progress is handled by RunRollbackScript, so we don't need to change the parameters
	if (!RollbackRecord(ixoActionStart,riParams))
		return iesFailure;

	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfProgressTotal(IMsiRecord& riParams)
{
	using namespace IxoProgressTotal;
	using namespace ProgressData;
	iesEnum iesReturn = iesNoAction;
	AssertNonZero(m_pProgressRec->SetInteger(imdSubclass, iscActionInfo)); // Action progress init
	AssertNonZero(m_pProgressRec->SetInteger(imdPerTick, riParams.GetInteger(ByteEquivalent)));
	AssertNonZero(m_pProgressRec->SetInteger(imdType, riParams.GetInteger(Type)));
	if(Message(imtProgress, *m_pProgressRec) == imsCancel)
		iesReturn = iesUserExit;
	else

		iesReturn = iesSuccess;
	
	// no undo operation for ixoProgressTotal - RunRollbackScript handles progress
	
	return iesReturn;
}

// eat up a progress tick in an action
iesEnum CMsiOpExecute::ixfProgressTick(IMsiRecord& /*riParams*/)
{
	return (DispatchProgress(1) == imsCancel) ? iesUserExit:iesSuccess;
}


/*---------------------------------------------------------------------------
   DispatchProgress: increments m_pProgressRec[1] by cIncrement and
		dispatches progress message
---------------------------------------------------------------------------*/
imsEnum CMsiOpExecute::DispatchProgress(unsigned int cIncrement)
{
	using namespace ProgressData;
	if(m_cSuppressProgress > 0) // don't increment progress or send message if suppressing progress
		return imsNone;
	AssertNonZero(m_pProgressRec->SetInteger(imdSubclass, iscProgressReport));
	AssertNonZero(m_pProgressRec->SetInteger(imdIncrement, cIncrement));
	return Message(imtProgress, *m_pProgressRec);
}

void CMsiOpExecute::GetProductClientList(const ICHAR* szParent, const ICHAR* szRelativePackagePath, unsigned int uiDiskId, const IMsiString*& rpiClientList)
{
	PMsiRegKey pProductKey(0);
	MsiString strProductKey = GetProductKey();
	CTempBuffer<ICHAR, 256> rgchProductInfo;


	MsiString strClients;
	if(szParent && *szParent)
	{
		// child install
		strClients = szParent;
		strClients += MsiString(MsiChar(';'));
		strClients += szRelativePackagePath;
		strClients += MsiString(MsiChar(';'));
		strClients += (int)uiDiskId;
	}
	else // parent
		strClients = szSelfClientToken;
	strClients.ReturnArg(rpiClientList);
}

// Configuration manager operations

iesEnum CMsiOpExecute::ixfProductRegister(IMsiRecord& riParams)
{
	using namespace IxoProductRegister;

	MsiString strProductKey = GetProductKey();
	
	// are we in sequence
	if(!strProductKey.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductRegister")));
		return iesFailure;
	}
						
	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strProductKey));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	PMsiRecord pRecErr(0);
	return ProcessRegisterProduct(riParams, fFalse);
}

iesEnum CMsiOpExecute::ixfUserRegister(IMsiRecord& riParams)
{
	// are we in sequence
	MsiString strProductKey = GetProductKey();
	if(!strProductKey.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfUserRegister")));
		return iesFailure;
	}

	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strProductKey));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	return ProcessRegisterUser(riParams, fFalse);
}

iesEnum CMsiOpExecute::ixfProductUnregister(IMsiRecord& riParams)
{
	using namespace IxoProductUnregister;

	// are we in sequence
	MsiString strProductKey = GetProductKey();
	if(!strProductKey.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductUnregister")));
		return iesFailure;
	}
	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strProductKey));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	iesEnum iesRet = iesSuccess;

	PMsiRecord pParams(0);

	// remove any cached secure transforms
#ifdef UNICODE
	MsiString strSecureTransformsKey;
	PMsiRecord pError = GetProductSecureTransformsKey(*&strSecureTransformsKey);
	if(pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	PMsiRegKey pHKLM = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hUserDataKey, ibtCommon);
	PMsiRegKey pSecureTransformsKey = &pHKLM->CreateChild(strSecureTransformsKey);
	// enumerate through the secure transforms
	PEnumMsiString pEnum(0);
	if((pError = pSecureTransformsKey->GetValueEnumerator(*&pEnum)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	MsiString strValueName, strValue;
	PMsiPath pTransformPath(0);
	while((pEnum->Next(1, &strValueName, 0)) == S_OK)
	{
		if((pError = pSecureTransformsKey->GetValue(strValueName,*&strValue)) != 0)
		{
			Message(imtError, *pError);
			return iesFailure;
		}

		// set up the transform file for deletion
		if(!pTransformPath)
		{
			MsiString strCachePath = GetMsiDirectory();
			Assert(strCachePath.TextSize());
			if((pError = m_riServices.CreatePath(strCachePath,*&pTransformPath)))
				return FatalError(*pError);
		}
		MsiString strTransformFullPath;
		if((pError = pTransformPath->GetFullFilePath(strValue,*&strTransformFullPath)))
			return FatalError(*pError);

		if(iesSuccess != DeleteFileDuringCleanup(strTransformFullPath, true))
		{
			DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove),*strTransformFullPath);
		}
	}


	// remove any cached secure transforms registration
	{
		CElevate elevate; // so we can remove the feature usage key

		// Remove feature usage key
		pParams = &m_riServices.CreateRecord(IxoRegOpenKey::Args);
		
#ifdef _WIN64	// !merced
			AssertNonZero(pParams->SetHandle(IxoRegOpenKey::Root,(HANDLE)m_hUserDataKey));
#else			// win-32
			AssertNonZero(pParams->SetInteger(IxoRegOpenKey::Root,(int)m_hUserDataKey));
#endif
		AssertNonZero(pParams->SetMsiString(IxoRegOpenKey::Key, *strSecureTransformsKey));
		AssertNonZero(pParams->SetInteger(IxoRegOpenKey::BinaryType, (int)ibtCommon));

		m_cSuppressProgress++;  
		iesRet = ixfRegOpenKey(*pParams);
		if (iesRet == iesSuccess || iesRet == iesNoAction)
			iesRet = ixfRegRemoveKey(*pParams);//!! should pass in a new record of size IxoRegRemoveKey::Args here to be safe from future revision
		
		m_cSuppressProgress--;
	}
#else
	WIN32_FIND_DATA fdFileData;
	HANDLE hFindFile = INVALID_HANDLE_VALUE;

	PMsiPath pTransformPath(0);
	PMsiRecord pError = GetSecureTransformCachePath(m_riServices, 
													*MsiString(GetProductKey()), 
													*&pTransformPath);
	if (pError)
		return FatalError(*pError);

	Assert(pTransformPath);

	MsiString strSearchPath = pTransformPath->GetPath();
	strSearchPath += TEXT("*.*");

	bool fContinue = true;

	hFindFile = WIN::FindFirstFile(strSearchPath, &fdFileData);
	if (hFindFile != INVALID_HANDLE_VALUE)
	{
		for (;;)
		{
			if ((fdFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
			{
				// add file to the list of temporary files to be deleted when install packages
				// are released
				MsiString strFullFilePath;
				AssertRecord(pTransformPath->GetFullFilePath(fdFileData.cFileName,
																							 *&strFullFilePath));

				if(iesSuccess != DeleteFileDuringCleanup(strFullFilePath, true))
				{
					DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove),*strFullFilePath);
				}
			}
			
			if (!WIN::FindNextFile(hFindFile, &fdFileData))
			{
				Assert(ERROR_NO_MORE_FILES == GetLastError());
				WIN::FindClose(hFindFile);
				break;
			}
		}
	}
#endif

	// if there's a cached database then we need to remove it
	// since its probably in use, we can't remove it now so just schedule it for delete after reboot
	// NOTE: we could call RemoveFile() which would schedule it for deletion
	// but that will try to backup the file and make a copy without
	// removing the original since the file is held in place
	// its safe to not backup this file since no one will try to install over it
	// (cached msis always have unique names)

	// get the appropriate cached database key/ value
	MsiString strLocalPackageKey;
	HKEY hKey = 0; // will be set to global key, do not close
	if((pError = GetProductInstalledPropertiesKey(hKey, *&strLocalPackageKey)) != 0)
		return FatalError(*pError);

	PMsiRegKey pHRoot = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)hKey, ibtCommon);

	PMsiRegKey pCachedDatabaseKey = &pHRoot->CreateChild(strLocalPackageKey);
	MsiString strCachedDatabase;
	iaaAppAssignment iaaAsgnType = m_fFlags & SCRIPTFLAGS_MACHINEASSIGN ? iaaMachineAssign : (m_fAssigned? iaaUserAssign : iaaUserAssignNonManaged);

	if((pError = pCachedDatabaseKey->GetValue(iaaAsgnType == iaaUserAssign ? szLocalPackageManagedValueName : szLocalPackageValueName,*&strCachedDatabase)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	if (strCachedDatabase.TextSize())
	{
		if(iesSuccess != DeleteFileDuringCleanup(strCachedDatabase,false))
		{
			// not a fatal error - just log it
			DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove), *strCachedDatabase);
		}
	}

	if ((iesRet = ProcessRegisterProduct(riParams, fTrue)) != iesSuccess)
		return iesRet;

	{
		CElevate elevate; // so we can remove the feature usage key

		// Remove feature usage key
		MsiString strFeatureUsage;
		if ((pError = GetProductFeatureUsageKey(*&strFeatureUsage)) != 0)
			return FatalError(*pError);

		pParams = &m_riServices.CreateRecord(IxoRegOpenKey::Args);
		
#ifdef _WIN64	// !merced
			AssertNonZero(pParams->SetHandle(IxoRegOpenKey::Root,(HANDLE)m_hUserDataKey));
#else			// win-32
			AssertNonZero(pParams->SetInteger(IxoRegOpenKey::Root,(int)m_hUserDataKey));
#endif
		AssertNonZero(pParams->SetMsiString(IxoRegOpenKey::Key, *strFeatureUsage));
		AssertNonZero(pParams->SetInteger(IxoRegOpenKey::BinaryType, (int)ibtCommon));

		m_cSuppressProgress++;  
		iesRet = ixfRegOpenKey(*pParams);
		if (iesRet == iesSuccess || iesRet == iesNoAction)
			iesRet = ixfRegRemoveKey(*pParams);//!! should pass in a new record of size IxoRegRemoveKey::Args here to be safe from future revision
		
		m_cSuppressProgress--;
	}

	if (iesRet == iesSuccess || iesRet == iesNoAction)
	{
		// Remove user registration
		pParams = &m_riServices.CreateRecord(IxoUserRegister::Args);
		iesRet = ProcessRegisterUser(*pParams, fTrue);
	}

	return iesRet;
}


/*---------------------------------------------------------------------------
ixfProductCPDisplayInfoRegister
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfProductCPDisplayInfoRegister(IMsiRecord& riParams)
{
	using namespace IxoProductCPDisplayInfoRegister;

	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductCPDisplayInfoRegister")));
		return iesFailure;
	}

	return ProcessRegisterProductCPDisplayInfo(riParams, fFalse);
}

/*---------------------------------------------------------------------------
ixfProductCPDisplayInfoUnregister
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfProductCPDisplayInfoUnregister(IMsiRecord& riParams)
{
	using namespace IxoProductCPDisplayInfoUnregister;

	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductCPDisplayInfoUnregister")));
		return iesFailure;
	}
	
	return ProcessRegisterProductCPDisplayInfo(riParams, fTrue);
}

// FN: checks to see if a product is registered for any user
bool FProductRegisteredForAUser(const ICHAR* szProductCode)
{
	bool fRegistered = false;
	unsigned uiUser = 0;
	CRegHandle hKey;
	DWORD dwResult;
	extern DWORD OpenEnumedUserInstalledProductInstallPropertiesKey(unsigned int uiUser, const ICHAR* szProduct, CRegHandle& rhKey); // from msinst.cpp

	while(!fRegistered && (ERROR_NO_MORE_ITEMS != (dwResult = OpenEnumedUserInstalledProductInstallPropertiesKey(uiUser++, szProductCode, hKey))))
	{
		if((ERROR_SUCCESS == dwResult && ERROR_SUCCESS == (dwResult = WIN::RegQueryValueEx(hKey, szWindowsInstallerValueName, 0, 0, 0, 0))) ||
			(ERROR_FILE_NOT_FOUND != dwResult))
			fRegistered = true;	// non-expected error from OpenEnumedUserInstalledProductInstallPropertiesKey, err on the side of safety
								// and prevent legacy stuff from being removed AND also prevent infinite loop on the side
	}
	return fRegistered;
}


iesEnum CMsiOpExecute::ProcessRegisterProductCPDisplayInfo(IMsiRecord& /*riParams*/, Bool fRemove)
{
	CElevate elevate; // elevate this entire function

	MsiString strDisplayName = GetProductName();

	MsiString strProductInstalledPropertiesKey;
	HKEY hKey = 0; // will be set to global key, do not close
	PMsiRecord pRecErr(0);
	if((pRecErr = GetProductInstalledPropertiesKey(hKey, *&strProductInstalledPropertiesKey)) != 0)
		return FatalError(*pRecErr);

	ICHAR szInstallPropertiesLocation[MAX_PATH * 2];
	IStrCopy(szInstallPropertiesLocation, strProductInstalledPropertiesKey);
	const ICHAR* rgszProductInfoRegData[] = 
	{
		TEXT("%s"), szInstallPropertiesLocation, 0, 0,
		szDisplayNameValueName,     (const ICHAR*)strDisplayName,             g_szTypeString,
		0,
		0,
	};

	PMsiStream pSecurityDescriptor(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	iesEnum iesRet = ProcessRegInfo(rgszProductInfoRegData, hKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
    if (iesRet != iesSuccess)
        return iesRet;

#ifdef UNICODE
	// update the legacy location
	MsiString strProductKey = GetProductKey();
	wsprintf(szInstallPropertiesLocation, TEXT("%s\\%s"), szMsiUninstallProductsKey_legacy, (const ICHAR*)strProductKey);

	if(!fRemove)
	{
        iesRet = CreateUninstallKey();
        if (iesRet != iesSuccess)
            return iesRet;
	}

	if(!fRemove || !FProductRegisteredForAUser(strProductKey))
		iesRet = ProcessRegInfo(rgszProductInfoRegData, HKEY_LOCAL_MACHINE, fRemove, pSecurityDescriptor, 0, ibtCommon);
#endif
	return iesRet;
}


bool FIsRegistryOrAssemblyKeyPath(const IMsiString& riPath, bool fRegistryOnly)
{
	ICHAR ch = 0;

	if(!fRegistryOnly && (*(riPath.GetString()) == chTokenFusionComponent || *(riPath.GetString()) == chTokenWin32Component))
		return true;

	if (riPath.TextSize() > 2)
		ch = ((const ICHAR*)riPath.GetString())[2];
		
	if ((ch == TEXT(':')) || (ch == TEXT('*'))) // look for registry tokens
		return true;
	else
		return false;
}


const IMsiString& GetSourcePathForRollback(const IMsiString& ristrPath)
{
	ristrPath.AddRef();
	MsiString strRet = ristrPath;

	if(!FIsRegistryOrAssemblyKeyPath(ristrPath, false))
		strRet.Remove(iseFirst, 2);

	return strRet.Return();
}

IMsiRecord* AreAssembliesEqual(const IMsiString& ristrAssemblyName1, const IMsiString& ristrAssemblyName2, iatAssemblyType iatAT, bool& rfAssemblyEqual)
{
	// create the assembly name object
	PAssemblyName pAssemblyName1(0);
	PAssemblyName pAssemblyName2(0);

	for(int cCount = 0; cCount < 2; cCount++)
	{
		LPCOLESTR szAssemblyName;
#ifndef UNICODE
		CTempBuffer<WCHAR, MAX_PATH>  rgchAssemblyName;
		ConvertMultiSzToWideChar(cCount ? ristrAssemblyName2 : ristrAssemblyName1, rgchAssemblyName);
		szAssemblyName = rgchAssemblyName;
#else
		szAssemblyName = cCount ? ristrAssemblyName2.GetString() : ristrAssemblyName1.GetString();
#endif
		HRESULT hr;
		if(iatAT == iatURTAssembly)
		{
			hr = FUSION::CreateAssemblyNameObject(cCount ? &pAssemblyName2 : &pAssemblyName1, szAssemblyName, CANOF_PARSE_DISPLAY_NAME, 0);
		}
		else
		{
			Assert(iatAT == iatWin32Assembly);
			hr = SXS::CreateAssemblyNameObject(cCount ? &pAssemblyName2 : &pAssemblyName1, szAssemblyName, CANOF_PARSE_DISPLAY_NAME, 0);
		}
		if(!SUCCEEDED(hr))
			return PostAssemblyError(TEXT(""), hr, TEXT(""), TEXT("CreateAssemblyNameObject"), cCount ? ristrAssemblyName2.GetString() : ristrAssemblyName1.GetString(), iatAT);
	}
	rfAssemblyEqual = (S_OK == pAssemblyName1->IsEqual(pAssemblyName2, ASM_CMPF_DEFAULT)) ? true:false;
	return 0;
}

iesEnum CMsiOpExecute::ixfComponentRegister(IMsiRecord& riParams)
{
	using namespace IxoComponentRegister;

	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfComponentRegister")));
		return iesFailure;
	}

	MsiString istrComponent = riParams.GetMsiString(ComponentId);
	MsiString istrKeyPath = riParams.GetMsiString(KeyPath);
	INSTALLSTATE iState = (INSTALLSTATE)riParams.GetInteger(State);
	int iSharedDllRefCount = riParams.GetInteger(SharedDllRefCount);
	IMsiRecord& riActionData = GetSharedRecord(3); // don't change ref count - shared record
	MsiString strProduct;
	
	if (riParams.IsNull(ProductKey))
		strProduct = GetProductKey();
	else
		strProduct = riParams.GetMsiString(ProductKey);

	AssertNonZero(riActionData.SetMsiString(1, *strProduct));
	AssertNonZero(riActionData.SetMsiString(2, *istrComponent));
	AssertNonZero(riActionData.SetMsiString(3, *istrKeyPath));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	// gather info for undo op
	// determine if component is already registered, and get key path
	PMsiRecord pError(0);
	PMsiRecord pComponentInfo(0);
	Bool fRegistered = fTrue;
	MsiString strOldKeyPath;
	MsiString strOldAuxPath;
	int iOldInstallState = 0;
	Bool fOldSharedDllRefCount = fFalse;

	// read previous component information from the appropriate location
	iaaAppAssignment iaaAsgnType = m_fFlags & SCRIPTFLAGS_MACHINEASSIGN ? iaaMachineAssign : (m_fAssigned? iaaUserAssign : iaaUserAssignNonManaged);
	if((pError = GetComponentPath(m_riServices, 0, *strProduct,*istrComponent,*&pComponentInfo, &iaaAsgnType)) != 0)
		// component not registered
		fRegistered = fFalse;
	else
	{
		iOldInstallState = pComponentInfo->GetInteger(icmlcrINSTALLSTATE_Static);
		if(INSTALLSTATE_UNKNOWN == iOldInstallState)
			fRegistered = fFalse;
		else
		{
			// use the raw path for registry paths (for bug fix 9006) and assembly paths
			// else use the actual path
			strOldKeyPath = pComponentInfo->GetMsiString(icmlcrRawFile);
			if(!FIsRegistryOrAssemblyKeyPath(*strOldKeyPath, false))
				strOldKeyPath = pComponentInfo->GetMsiString(icmlcrFile);
			if(INSTALLSTATE_SOURCE == iOldInstallState)
			{
				strOldKeyPath = GetSourcePathForRollback(*strOldKeyPath);
			}
			strOldAuxPath = pComponentInfo->GetMsiString(icmlcrRawAuxPath);
			if(strOldAuxPath.TextSize())
			{
				Assert(FIsRegistryOrAssemblyKeyPath(*strOldAuxPath, true)); // aux key path can only be a registry
				if(INSTALLSTATE_SOURCE == iOldInstallState)
				{
					strOldAuxPath = GetSourcePathForRollback(*strOldAuxPath);
				}
				// append the auxiliary key path to the key path
				strOldKeyPath = strOldKeyPath + MsiString(MsiChar(0));
				strOldKeyPath += strOldAuxPath;
			}
			fOldSharedDllRefCount = (Bool)(pComponentInfo->GetInteger(icmlcrSharedDllCount) == fTrue);
		}
	}
	
	int iDisk = riParams.GetInteger(Disk);
	if (iMsiStringBadInteger == iDisk)
		iDisk = 1;
	iesEnum iesRet = iesNoAction;
	Bool fRetry = fTrue, fSuccess = fFalse;
	ibtBinaryType iType;
	if ( riParams.GetInteger(BinaryType) == iMsiNullInteger )
		iType = ibt32bit;
	else
	{
		iType = (ibtBinaryType)riParams.GetInteger(BinaryType);
		Assert(iType == ibt32bit || iType == ibt64bit);
	}

	while(fRetry)  // retry loop
	{
		pError = 0;
		//check for Fusion components
		iatAssemblyType iatOld;
		MsiString strAssemblyName;
		iatAssemblyType iatNew;
		iatNew = *(const ICHAR* )istrKeyPath == chTokenFusionComponent ? iatURTAssembly : 
			(*(const ICHAR* )istrKeyPath == chTokenWin32Component ? iatWin32Assembly : iatNone);
		if(iatURTAssembly == iatNew || iatWin32Assembly == iatNew)
		{
			// create the component id to assembly mapping for files to come

			// Extract upto the first '\\', the rest is the assembly name
			strAssemblyName = istrKeyPath;
			strAssemblyName.Remove(iseIncluding, '\\');
			// save off the Assembly info about the component in a temp table
			pError = CacheAssemblyMapping(*istrComponent, *strAssemblyName, iatNew);
		}
		if(!pError && fRegistered)
		{
			// check the type of old registration

			iatOld = *(const ICHAR* )strOldKeyPath == chTokenFusionComponent ? iatURTAssembly : 
			(*(const ICHAR* )strOldKeyPath == chTokenWin32Component ? iatWin32Assembly : iatNone);
			if(iatURTAssembly == iatOld || iatWin32Assembly == iatOld)
			{
				// if the old registration does not match the new, then possibly uninstall the old assembly
				bool fAssemblyUnchanged = true;
				MsiString strAssemblyNameOld = strOldKeyPath;
				strAssemblyNameOld.Remove(iseIncluding, '\\');
				if(iatOld != iatNew)
					fAssemblyUnchanged = false;
				else
					pError = AreAssembliesEqual(*strAssemblyName, *strAssemblyNameOld, iatOld, fAssemblyUnchanged);
				if(!pError && !fAssemblyUnchanged)
 					pError = CacheAssemblyForUninstalling(*istrComponent, *strAssemblyNameOld, iatOld);
			}
		}
		if(!pError)
			pError = RegisterComponent(*strProduct,*istrComponent, iState, *istrKeyPath, (unsigned int)iDisk, iSharedDllRefCount, iType);
		if (pError)
		{
			switch (DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault3), Imsg(idbgOpCompRegister),*istrComponent))
			{
			case imsAbort: iesRet = iesFailure; fRetry = fFalse; break;
			case imsRetry: continue;
			default:       iesRet = iesSuccess; fRetry = fFalse;//!!?? imsIgnore, imsNone
			};
		}
		else
		{
			iesRet = iesSuccess;
			fSuccess = fTrue;
			fRetry = fFalse;
		}
	}

	if(fSuccess)
	{
		// generate rollback op
		if(fRegistered == fTrue)
		{
			// register old component on rollback
			IMsiRecord& riUndoParams = GetSharedRecord(Args);
			AssertNonZero(riUndoParams.SetMsiString(ComponentId,*istrComponent));
			AssertNonZero(riUndoParams.SetMsiString(KeyPath,*strOldKeyPath));
			AssertNonZero(riUndoParams.SetInteger(State,iOldInstallState));         
			AssertNonZero(riUndoParams.SetInteger(SharedDllRefCount,fOldSharedDllRefCount));
			AssertNonZero(riUndoParams.SetMsiString(ProductKey,*strProduct));
			AssertNonZero(riUndoParams.SetInteger(BinaryType,iType));
			if (!RollbackRecord(ixoComponentRegister,riUndoParams))
				return iesFailure;

			// don't need to unregister new component
		}
		else
		{
			// unregister component on rollback
			IMsiRecord& riUndoParams = GetSharedRecord(IxoComponentUnregister::Args);
			AssertNonZero(riUndoParams.SetMsiString(IxoComponentUnregister::ComponentId,*istrComponent));
			AssertNonZero(riUndoParams.SetMsiString(IxoComponentUnregister::ProductKey,*strProduct));
			AssertNonZero(riUndoParams.SetInteger(IxoComponentUnregister::BinaryType,iType));
			// if this is rollback, then check if we were installed prior to this install
			// if yes then we skip the Uninstallning 
			// this is to catch scenarios where the assembly was installed via some other
			// user
			if(	*(const ICHAR* )istrKeyPath == chTokenFusionComponent || 
				*(const ICHAR* )istrKeyPath == chTokenWin32Component)
			{
				iatAssemblyType iatAT = (*(const ICHAR* )istrKeyPath == chTokenFusionComponent) ? iatURTAssembly : iatWin32Assembly;
				bool fInstalled = false;
				// Extract upto the first '\\', the rest is the assembly name
				MsiString strAssemblyName = istrKeyPath;
				strAssemblyName.Remove(iseIncluding, '\\');
				pError = IsAssemblyInstalled(*istrComponent, *strAssemblyName, iatAT, fInstalled, 0, 0);
				if (pError)
					return FatalError(*pError);
				if(fInstalled)
				{
					AssertNonZero(riUndoParams.SetInteger(IxoComponentUnregister::PreviouslyPinned, 1));
				}
			
			}
			if (!RollbackRecord(ixoComponentUnregister,riUndoParams))
				return iesFailure;
		}
	}
	return iesRet;
}

iesEnum CMsiOpExecute::ixfComponentUnregister(IMsiRecord& riParams)
{
	using namespace IxoComponentUnregister;
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfComponentUnregister")));
		return iesFailure;
	}
	MsiString istrComponent = riParams.GetMsiString(ComponentId);
	IMsiRecord& riActionData = GetSharedRecord(2); // don't change ref count - shared record
	MsiString strProduct;
	
	if (riParams.IsNull(ProductKey))
		strProduct = GetProductKey();
	else
		strProduct = riParams.GetMsiString(ProductKey);

	AssertNonZero(riActionData.SetMsiString(1, *strProduct));
	AssertNonZero(riActionData.SetMsiString(2, *istrComponent));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	// gather info for undo op
	// determine if component is already registered, and get key path
	PMsiRecord pError(0);
	PMsiRecord pComponentInfo(0);
	Bool fRegistered = fTrue;
	MsiString strOldKeyPath;
	MsiString strOldAuxPath;
	int iOldInstallState = 0;
	Bool fOldSharedDllRefCount = fFalse;

	//read info from the appropriate components location
	iaaAppAssignment iaaAsgnType = m_fFlags & SCRIPTFLAGS_MACHINEASSIGN ? iaaMachineAssign : (m_fAssigned? iaaUserAssign : iaaUserAssignNonManaged);
	if((pError = GetComponentPath(m_riServices, 0, *strProduct,*istrComponent,*&pComponentInfo, &iaaAsgnType)) != 0)
		fRegistered = fFalse;
	else
	{
		iOldInstallState = pComponentInfo->GetInteger(icmlcrINSTALLSTATE_Static);
		if(INSTALLSTATE_UNKNOWN == iOldInstallState)
			fRegistered = fFalse;
		else
		{
			// use the raw path for registry paths (for bug fix 9006) and assembly paths
			// else use the actual path
			strOldKeyPath = pComponentInfo->GetMsiString(icmlcrRawFile);
			if(!FIsRegistryOrAssemblyKeyPath(*strOldKeyPath, false))
				strOldKeyPath = pComponentInfo->GetMsiString(icmlcrFile);
			if(INSTALLSTATE_SOURCE == iOldInstallState)
			{
				strOldKeyPath = GetSourcePathForRollback(*strOldKeyPath);
			}
			strOldAuxPath = pComponentInfo->GetMsiString(icmlcrRawAuxPath);
			if(strOldAuxPath.TextSize())
			{
				Assert(FIsRegistryOrAssemblyKeyPath(*strOldAuxPath, true)); // aux key path can only be a registry
				if(INSTALLSTATE_SOURCE == iOldInstallState)
				{
					strOldAuxPath = GetSourcePathForRollback(*strOldAuxPath);
				}
				// append the auxiliary key path to the key path
				strOldKeyPath = strOldKeyPath + MsiString(MsiChar(0));
				strOldKeyPath += strOldAuxPath;
			}
			fOldSharedDllRefCount = (Bool)(pComponentInfo->GetInteger(icmlcrSharedDllCount) == fTrue);
		}
	}
	
	iesEnum iesRet = iesNoAction;
	Bool fRetry = fTrue, fSuccess = fFalse;
	ibtBinaryType iType;
	if ( riParams.GetInteger(BinaryType) == iMsiNullInteger )
		iType = ibt32bit;
	else
	{
		iType = (ibtBinaryType)riParams.GetInteger(BinaryType);
		Assert(iType == ibt32bit || iType == ibt64bit);
	}

	while(fRetry)  // retry loop
	{
		PMsiRecord pError(0);
		// we treat 
		if(*(const ICHAR* )strOldKeyPath == chTokenFusionComponent || *(const ICHAR* )strOldKeyPath == chTokenWin32Component)
		{
			// set up the unclienting of assembly components at the end
			// get assembly name
			MsiString strAssemblyName = strOldKeyPath;
			strAssemblyName.Remove(iseIncluding, '\\');

			// set for Uninstallning only if not previously pinned
			if(riParams.GetInteger(PreviouslyPinned) == iMsiNullInteger)
				CacheAssemblyForUninstalling(*istrComponent, *strAssemblyName, *(const ICHAR* )strOldKeyPath == chTokenFusionComponent ?  iatURTAssembly : iatWin32Assembly);
		}

		if(!pError)
		pError = UnregisterComponent(*strProduct, *istrComponent, iType);
		if (pError)
		{
			switch (DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault3), Imsg(idbgOpCompUnregister),*istrComponent))
			{
			case imsAbort: iesRet = iesFailure; fRetry = fFalse; break;
			case imsRetry: continue;
			default:       iesRet = iesSuccess; fRetry = fFalse; // imsIgnore, imsNone
			};
		}
		else
		{
			iesRet = iesSuccess;
			fSuccess = fTrue;
			fRetry = fFalse;
		}
	}

	if(fSuccess && fRegistered == fTrue)
	{
		// generate rollback op
		// register component on rollback
		IMsiRecord& riUndoParams = GetSharedRecord(IxoComponentRegister::Args);
		AssertNonZero(riUndoParams.SetMsiString(IxoComponentRegister::ProductKey,*strProduct));
		AssertNonZero(riUndoParams.SetInteger(IxoComponentRegister::State,iOldInstallState));           
		AssertNonZero(riUndoParams.SetInteger(IxoComponentRegister::SharedDllRefCount,fOldSharedDllRefCount));          
		AssertNonZero(riUndoParams.SetMsiString(IxoComponentRegister::ComponentId,*istrComponent));
		AssertNonZero(riUndoParams.SetMsiString(IxoComponentRegister::KeyPath,*strOldKeyPath));
		AssertNonZero(riUndoParams.SetInteger(IxoComponentRegister::BinaryType,iType));
		if (!RollbackRecord(ixoComponentRegister,riUndoParams))
			return iesFailure;
	}
	return iesRet;
}

// increment guid to get the next guid to represent the system client
// dependant on the fact that PackGUID switches the guid around as shown
// {F852C27C-F690-11d2-94A1-006008993FDF} => C72C258F096F2d11491A00068099F3FD
bool GetNextSystemGuid(ICHAR* szProductKeyPacked)
{
	int iPos = 0;
	while(iPos < 2) // we support a max of FF (2 digits) different locations
	{
		if(*(szProductKeyPacked + iPos) == 'F') // last digit
			*(szProductKeyPacked + iPos++) = '0'; // reset
		else
		{
			if(*(szProductKeyPacked + iPos) == '9')
				(*(szProductKeyPacked + iPos)) = 'A'; // jump to A if at 9
			else
				(*(szProductKeyPacked + iPos))++;
			return true;
		}
	}
	AssertSz(0, "Limit for number of locations possible for a permanent component reached"); // never expect us to reach the FF limit for FF possible locations for the same permanent component
	// GUID has laready been reset back to the starting guid
	return false; // no more 
}

IMsiRecord* CMsiOpExecute::RegisterComponent(const IMsiString& riProductKey, const IMsiString& riComponentsKey, INSTALLSTATE iState, const IMsiString& riKeyPath, unsigned int uiDisk, int iSharedDllRefCount, const ibtBinaryType iType)
{
	MsiString strSubKey;
	IMsiRecord* piError = 0;
	if((piError = GetProductInstalledComponentsKey(riComponentsKey.GetString(), *&strSubKey)) != 0)
		return piError;

	bool fIsSystemClient = (riProductKey.Compare(iscExact, szSystemProductKey) != 0);

	ICHAR szProductKeyPacked[cchProductCode  + 1];
	AssertNonZero(PackGUID(riProductKey.GetString(),    szProductKeyPacked));

	PMsiRegKey pRootKey(0);
	if(!fIsSystemClient)
	{
		// choose install location for config data based on installation type
		pRootKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hUserDataKey, ibtCommon);		//--merced: changed (int) to (INT_PTR)
	}
	else
	{
		// permanant components registered globally in per machine location
		PMsiRegKey pLocalMachine = &m_riServices.GetRootKey(rrkLocalMachine, ibtCommon);

		MsiString strLocalMachineData = szMsiUserDataKey;
		strLocalMachineData += szRegSep;
		strLocalMachineData += szLocalSystemSID;
		pRootKey = &pLocalMachine->CreateChild(strLocalMachineData);
	}

	PMsiRegKey pComponentIdKey = &pRootKey->CreateChild(strSubKey);
	{
		CElevate elevate;
		if((piError = pComponentIdKey->Create()) != 0)
			return piError;
	}

	const ICHAR* szKeyPath = riKeyPath.GetString();

	Assert(*(riKeyPath.GetString()) != 0 || iState == INSTALLSTATE_NOTUSED); // installstate should be not used for disabled components
	
	if(!FIsRegistryOrAssemblyKeyPath(riKeyPath, false))
	{		
		// we have a key file. 

		PMsiRecord pSharedDllCompatibilityError(0);
		// pSharedDllCompatibilityError will be set if we error while doing shared dll compatibility stuff
		//!! currently ignored as non fatal, this will get logged when we have implicit logging in PostError in services

		MsiString strOldKey;
		bool fOldRefcounted;

		// if this is the system client, AND the current GUID that represents the system is already registered to a 
		// different location than where we wish to register, we increment the GUID and try again (and again)
		do{
			fOldRefcounted = false;
			if((piError = pComponentIdKey->GetValue(szProductKeyPacked, *&strOldKey)) != 0)
				return piError;

			if(strOldKey.TextSize() && !*(const ICHAR* )strOldKey) // we have a multi_sz
				strOldKey.Remove(iseFirst, 1); // drop the beginning null

			if(strOldKey.TextSize() > 1 && *((const ICHAR*)strOldKey + 1) == chSharedDllCountToken)
			{
				fOldRefcounted = true;
				ICHAR chSecond = *((const ICHAR*)strOldKey) == '\\' ? '\\' : ':'; // replace the chSharedDllCountToken
				strOldKey = MsiString(MsiString(strOldKey.Extract(iseFirst, 1)) + MsiString(MsiChar(chSecond))) + MsiString(strOldKey.Extract(iseLast, strOldKey.CharacterCount() - 2));
			}
		}while(fIsSystemClient && strOldKey.TextSize() && !riKeyPath.Compare(iscExactI, strOldKey) 
				&& ((fOldRefcounted = GetNextSystemGuid(szProductKeyPacked)) == true));

		// decrement any old reg count, will be re-incremented if doing a reinstall
		if(fOldRefcounted)
		{
			Assert(strOldKey.TextSize());
			pSharedDllCompatibilityError = SetSharedDLLCount(m_riServices, strOldKey, iType, *MsiString(*szDecrementValue));
		}

		MsiString strKeyPath;
		if (iState == INSTALLSTATE_SOURCE)
		{
			Assert(uiDisk >= 1 && uiDisk <= 99);
			if (uiDisk < 10)
				strKeyPath = TEXT("0");
			
			strKeyPath += MsiString((int)uiDisk);
		}

		strKeyPath += riKeyPath;

		// increment the reg count, if file
		// !! we would remove this check when we explicitly pass in the fact as to whether 
		// !! we have a file or a folder as the key path

		// skip disabled components, run from source components, folder paths
		if(iState != INSTALLSTATE_NOTUSED && iState != INSTALLSTATE_SOURCE && *((const ICHAR*)strKeyPath + IStrLen(strKeyPath) - 1) != chDirSep)
		{
			Bool fLegacyFileExisted = iSharedDllRefCount & ircenumLegacyFileExisted ? fTrue:fFalse;
			Bool fSharedDllRefCount = iSharedDllRefCount & ircenumRefCountDll ? fTrue:fFalse;
			pSharedDllCompatibilityError = GetSharedDLLCount(m_riServices, szKeyPath, iType, *&strOldKey);

			if(!pSharedDllCompatibilityError)
			{
				strOldKey.Remove(iseFirst, 1);
				bool fPrevRefcounted = (strOldKey != iMsiStringBadInteger && strOldKey >= 1);
				if(fSharedDllRefCount || fPrevRefcounted) // need to refcount
				{
					MsiString strIncrementValue(*szIncrementValue);
					pSharedDllCompatibilityError = SetSharedDLLCount(m_riServices, strKeyPath, iType, *strIncrementValue);
					if(!pSharedDllCompatibilityError && fLegacyFileExisted && !fPrevRefcounted) // need to doubly refcount
					{
						pSharedDllCompatibilityError = SetSharedDLLCount(m_riServices, strKeyPath, iType, *strIncrementValue);
					}
					if(!pSharedDllCompatibilityError) // we managed to refcount 
						strKeyPath = MsiString(MsiString(strKeyPath.Extract(iseFirst, 1)) + MsiString(MsiChar(chSharedDllCountToken))) + MsiString(strKeyPath.Extract(iseLast, strKeyPath.CharacterCount() - 2));
				}
			}
		}

		{
			CElevate elevate;
			// set the key file
			if((piError = pComponentIdKey->SetValue(szProductKeyPacked, *strKeyPath)) != 0)
				return piError;
		}
	}
	else // should be a reg key
	{
		{
			CElevate elevate;
			if((piError = pComponentIdKey->SetValue(szProductKeyPacked, riKeyPath)) != 0)
				return piError;
		}
	}

	return 0;
}



IMsiRecord* CMsiOpExecute::UnregisterComponent(	const IMsiString& riProductKey, const IMsiString& riComponentsKey, const ibtBinaryType iType)
{
	MsiString strSubKey;
	IMsiRecord* piError = 0;
	if((piError = GetProductInstalledComponentsKey(riComponentsKey.GetString(), *&strSubKey)) != 0)
		return piError;

	PMsiRegKey pRootKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hUserDataKey, ibtCommon);		//--merced: changed (int) to (INT_PTR)

	ICHAR szProductKeyPacked[cchProductCode  + 1];
	AssertNonZero(PackGUID(riProductKey.GetString(),    szProductKeyPacked));

	PMsiRegKey pComponentIdKey = &pRootKey->CreateChild(strSubKey);

	MsiString strOldKey;
	if((piError = pComponentIdKey->GetValue(szProductKeyPacked, *&strOldKey)) != 0)
		return piError;

	DWORD dwProductIndex = 0;
	ICHAR szProductBuf[39];
	{
		CElevate elevate;
		// remove client entry
		if((piError = pComponentIdKey->RemoveValue(szProductKeyPacked, 0)) != 0)
			return piError;
	}

	// decrement the reg count if any for file key paths	
    if(strOldKey.TextSize() && !*(const ICHAR* )strOldKey) // we have a multi_sz
        strOldKey.Remove(iseFirst, 1); // drop the beginning null

	if(strOldKey.TextSize() && !FIsRegistryOrAssemblyKeyPath(*strOldKey, false))
	{
		if(strOldKey.TextSize() > 1 && *((const ICHAR* )strOldKey + 1) == chSharedDllCountToken)
		{
			ICHAR chSecond = *((const ICHAR*)strOldKey) == '\\' ? '\\' : ':'; // replace the chSharedDllCountToken
			strOldKey = MsiString(MsiString(strOldKey.Extract(iseFirst, 1)) + MsiString(MsiChar(chSecond))) + MsiString(strOldKey.Extract(iseLast, strOldKey.CharacterCount() - 2));
			PMsiRecord pSharedDllCompatibilityError(0);
			// pSharedDllCompatibilityError will be set if we error while doing shared dll compatibility stuff
			//!! currently ignored as non fatal, this will get logged when we have implicit logging in PostError in services
			pSharedDllCompatibilityError = SetSharedDLLCount(m_riServices, strOldKey, iType, *MsiString(*szDecrementValue));
		}
	}
	return 0;
}

// Registry operations

/*---------------------------------------------------------------------------
	ixoRegOpenKey: opens RegKey as sub key of RootRegKey
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegOpenKey(IMsiRecord& riParams)
{
	using namespace IxoRegOpenKey;
	
	rrkEnum rrkRoot = (rrkEnum)riParams.GetInteger(Root);
	ibtBinaryType iType;
	if ( riParams.GetInteger(BinaryType) == iMsiNullInteger )
		iType = ibt32bit;
	else
	{
		iType = (ibtBinaryType)riParams.GetInteger(BinaryType);
		if ( iType == ibtCommon )
			iType = g_fWinNT64 ? ibt64bit : ibt32bit;
	}
	PMsiRegKey pRootRegKey(0);
	MsiString strRootRegKey;
	
	MsiString strSIDKey;
	if(rrkRoot == rrkClassesRoot)
	{
		// HKCR is HKLM\S\C for machine assigned OR non DDSupportOLE machines
		// else HKCR is HKCU\S\C
		if((m_fFlags & SCRIPTFLAGS_MACHINEASSIGN) || IsDarwinDescriptorSupported(iddOLE) == fFalse)
			rrkRoot = rrkLocalMachine;
		else
			rrkRoot = rrkCurrentUser;
		m_state.strRegSubKey = szClassInfoSubKey;
	}
	else
	{
		if(rrkRoot == rrkUserOrMachineRoot)
		{
			// HKLM for machine assigned else HKCU
			if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
				rrkRoot = rrkLocalMachine;
			else
				rrkRoot = rrkCurrentUser;
		}
		m_state.strRegSubKey = TEXT("");
	}
	
	if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
	{
		// don't change HKCU
		if (rrkRoot == rrkCurrentUser)
		{
			DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
			m_state.pRegKey = NULL;
			return iesNoAction;
		}
	}
	if(m_state.strRegSubKey.TextSize())
		m_state.strRegSubKey += szRegSep;
	m_state.strRegSubKey += MsiString(riParams.GetMsiString(Key));
	pRootRegKey = &m_riServices.GetRootKey(rrkRoot, iType);
	strRootRegKey = pRootRegKey->GetKey();
	
#ifdef DEBUG
	MsiString strSpace = TEXT(" ");
	if(m_state.strRegSubKey.Compare(iscStart, strSpace) ||
		m_state.strRegSubKey.Compare(iscEnd, strSpace))
		AssertSz(0, "Debug Warning...Key begins or ends with white space");
#endif // DEBUG
	m_state.rrkRegRoot = rrkRoot;
	m_state.iRegBinaryType = iType;
	m_state.pRegKey = &pRootRegKey->CreateChild(m_state.strRegSubKey, PMsiStream((IMsiStream*) riParams.GetMsiData(SecurityDescriptor)));       
	Assert(m_state.pRegKey);
	m_state.strRegKey = strRootRegKey; // strRegRootKey may not be the same key as pRegRootKey->GetKey()
	m_state.strRegKey += szRegSep;
	m_state.strRegKey += m_state.strRegSubKey;

	// generate undo record
	if(RollbackEnabled())
	{
		if((HKEY)rrkRoot == m_hKey || (m_hOLEKey && (HKEY)rrkRoot == m_hOLEKey) || 
			(m_hOLEKey64 && (HKEY)rrkRoot == m_hOLEKey64) || (m_hKeyRm && (HKEY)rrkRoot == m_hKeyRm) ||
			(m_hUserDataKey && (HKEY)rrkRoot == m_hUserDataKey))
		{
			// our/OLE  root for advertising
			// use m_hPublishRootKey/ m_hPublishRootKeyRm/ m_hPublishRootOLEKey and m_strPublishSubKey/ m_strPublishSubKeyRm/ m_strPublishOLESubKey to get true root and subkey
			IMsiRecord& riUndoParams = GetSharedRecord(Args);
			MsiString strSubKey;
			if((HKEY)rrkRoot == m_hKey)
			{
				Assert(m_hPublishRootKey);
#ifdef _WIN64   // !merced
				AssertNonZero(riUndoParams.SetHandle(Root,(HANDLE)m_hPublishRootKey));
#else           // win-32
				AssertNonZero(riUndoParams.SetInteger(Root,(int)m_hPublishRootKey));
#endif
				strSubKey = m_strPublishSubKey;
			}
			else if(m_hOLEKey && (HKEY)rrkRoot == m_hOLEKey ||
					  (m_hOLEKey64 && (HKEY)rrkRoot == m_hOLEKey64))
			{
				Assert(m_hPublishRootOLEKey);
#ifdef _WIN64   // !merced
				AssertNonZero(riUndoParams.SetHandle(Root,(HANDLE)m_hPublishRootOLEKey));
#else           // win-32
				AssertNonZero(riUndoParams.SetInteger(Root,(int)m_hPublishRootOLEKey));
#endif
				strSubKey = m_strPublishOLESubKey;
			}
			else if(m_hUserDataKey && (HKEY)rrkRoot == m_hUserDataKey)
			{
#ifdef _WIN64	// !merced
				AssertNonZero(riUndoParams.SetHandle(Root,(HANDLE)HKEY_LOCAL_MACHINE));
#else			// win-32
				AssertNonZero(riUndoParams.SetInteger(Root,(int)HKEY_LOCAL_MACHINE));
#endif
				strSubKey = m_strUserDataKey;
			}
			else
			{
				Assert(m_hKeyRm && (HKEY)rrkRoot == m_hKeyRm);
				Assert(m_hPublishRootKeyRm);
#ifdef _WIN64   // !merced
				AssertNonZero(riUndoParams.SetHandle(Root,(HANDLE)m_hPublishRootKeyRm));
#else           // win-32
				AssertNonZero(riUndoParams.SetInteger(Root,(int)m_hPublishRootKeyRm));
#endif
				strSubKey = m_strPublishSubKeyRm;
			}
			if(strSubKey.TextSize())
				strSubKey += szRegSep;
			strSubKey += MsiString(riParams.GetMsiString(Key));
			AssertNonZero(riUndoParams.SetMsiString(Key,*strSubKey));
			AssertNonZero(riUndoParams.SetInteger(BinaryType,iType));
			if (!RollbackRecord(Op,riUndoParams))
				return iesFailure;
		}
		else // assume rrkRoot is a valid root
		{
			if (!RollbackRecord(Op,riParams))
				return iesFailure;
		}
	}

	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixoRegAddValue: writes value to RegKey
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegAddValue(IMsiRecord& riParams)
{
	using namespace IxoRegAddValue;

	// elevate when in rollback script - necessary if this op is rolling back config reg data
	// could have elevated only for the necessary ops,
	//   but this is safe since we generated the op for rollback and know what its doing (user can't control)

	CElevate elevate(m_istScriptType == istRollback);

	PMsiRecord pError(0);
	if(!m_state.pRegKey)
	{
		if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
		{
			// key wasn't opened since we detected it was user data
			DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
			return iesNoAction;
		}

		// ixoRegOpenKey must not have been called
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoRegAddValue")));
		return iesFailure;
	}



	MsiString strName = riParams.GetMsiString(Name);
	MsiString strValue = riParams.GetMsiString(Value);
	int iAttributes = riParams.IsNull(Attributes) ? 0: riParams.GetInteger(Attributes);
	if(!riParams.IsNull(IxoRegAddValue::Args + 1))
	{
		strValue = GetSFN(*strValue, riParams, IxoRegAddValue::Args + 1);
	}

	IMsiRecord& riActionData = GetSharedRecord(3); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *(m_state.strRegKey)));
	AssertNonZero(riActionData.SetMsiString(2, *strName));
	AssertNonZero(riActionData.SetMsiString(3, *strValue));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;
	
	// get info for undo operation
	Bool fKeyExists = fFalse, fValueExists = fFalse;
	MsiString strOldValue;
	if((pError = m_state.pRegKey->Exists(fKeyExists)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	if(fKeyExists)
	{
		if((pError = m_state.pRegKey->ValueExists(strName, fValueExists)) != 0)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
	}

	if(fValueExists)
	{
		if(iAttributes & rwWriteOnAbsent) // we are writing info for a lesser component, skip if value already exists
			return iesNoAction;

		// get current value
		if((pError = m_state.pRegKey->GetValue(strName, *&strOldValue)) != 0) //!! need to determine if this is empty or null
		{
			Message(imtError, *pError);
			return iesFailure;
		}
	}

	// if we are writing to the per user HKCR (HKCU\S\C) AND the key under which we are creating the
	// value does not exist BUT the corr. key  in the per machine HKCR (HKLM\S\C) exists,
	// AND rwWriteOnAbsent attribute is set, then we should skip creating the key-value altogether
	// since this will then shadow the per machine HKCR.
	if(!fKeyExists && IsDarwinDescriptorSupported(iddOLE) && (iAttributes & rwWriteOnAbsent)
		&& m_state.rrkRegRoot == rrkCurrentUser && m_state.strRegSubKey.Compare(iscStartI, szClassInfoSubKey))
	{
		PMsiRegKey pRootRegKey = &m_riServices.GetRootKey(rrkLocalMachine, m_state.iRegBinaryType);
		PMsiRegKey pSubKey = &pRootRegKey->CreateChild(m_state.strRegSubKey);
		Bool fHKLMKeyExists = fFalse;
		if((pError = pSubKey->Exists(fHKLMKeyExists)) != 0)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
		if(fHKLMKeyExists)
			return iesNoAction;
	}


	iesEnum iesReturn = iesNoAction;
	Bool fRetry = fTrue, fSuccess = fFalse;
	while(fRetry)
	{
		pError = m_state.pRegKey->SetValue(strName, *strValue);
		if(pError)
		{
			if(iAttributes & rwNonVital)
			{
				DispatchError(imtInfo, Imsg(imsgSetValueFailed), *strName, *m_state.strRegKey);
				iesReturn = iesSuccess; fRetry = fFalse;
			}
			else
			{
				switch(DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault1), Imsg(imsgSetValueFailed),
											*strName,
											*m_state.strRegKey))
				{
				case imsRetry: continue;
				case imsIgnore:
					iesReturn = iesSuccess; fRetry = fFalse;
					break;
				default:
					iesReturn = iesFailure; fRetry = fFalse;  // imsAbort, imsNone
					break;
				};
			}
		}
		else
		{
			iesReturn = iesSuccess;
			fSuccess = fTrue;
			fRetry = fFalse;
		}
	}

	// generate undo operations
	
	if(fSuccess)
	{
		MsiString strSubKey = MsiString(m_state.pRegKey->GetKey());
		strSubKey.Remove(iseIncluding, chRegSep);
		
		IMsiRecord* piUndoParams = 0;
		
		if(fKeyExists)
		{
			// key existed
			if(fValueExists)
			{
				// value existed, write old value back - this will create the key also
				piUndoParams = &GetSharedRecord(IxoRegAddValue::Args);
				AssertNonZero(piUndoParams->SetMsiString(IxoRegAddValue::Name, *strName));
				AssertNonZero(piUndoParams->SetMsiString(IxoRegAddValue::Value, *strOldValue));  //!! need to specify null or empty
				if (!RollbackRecord(IxoRegAddValue::Op, *piUndoParams))
					return iesFailure;
			}
			else
			{
				// value didn't exist, but key did - create key to ensure it exists
				piUndoParams = &GetSharedRecord(IxoRegCreateKey::Args);
				if (!RollbackRecord(IxoRegCreateKey::Op, *piUndoParams))
					return iesFailure;
			}
		}
		else
		{
			// key didn't exist, remove key
			piUndoParams = &GetSharedRecord(IxoRegRemoveKey::Args);
			if (!RollbackRecord(IxoRegRemoveKey::Op, *piUndoParams))
				return iesFailure;
		}

		// remove new value
		piUndoParams = &GetSharedRecord(IxoRegRemoveValue::Args);
		AssertNonZero(piUndoParams->SetMsiString(IxoRegRemoveValue::Name, *strName));
		AssertNonZero(piUndoParams->SetMsiString(IxoRegRemoveValue::Value, *strValue));
		if (!RollbackRecord(IxoRegRemoveValue::Op, *piUndoParams))
			return iesFailure;
	}

	return iesReturn;
}

/*---------------------------------------------------------------------------
ixoRegRemoveValue: removes value from RegKey
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegRemoveValue(IMsiRecord& riParams)
{
	using namespace IxoRegRemoveValue;

	// elevate when in rollback script - necessary if this op is rolling back config reg data
	// could have elevated only for the necessary ops,
	//   but this is safe since we generated the op for rollback and know what its doing (user can't control)
	CElevate elevate(m_istScriptType == istRollback);
	
	PMsiRecord pError(0);
	if(!m_state.pRegKey)
	{
		if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
		{
			// key wasn't opened since we detected it was user data
			DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
			return iesNoAction;
		}

		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoRegRemoveValue")));
		return iesFailure;
	}
	MsiString strName = riParams.GetMsiString(Name);
	MsiString strValue = riParams.GetMsiString(Value);

	IMsiRecord& riActionData = GetSharedRecord(2); // don't change ref count - shared record

	AssertNonZero(riActionData.SetMsiString(1, *(m_state.strRegKey)));
	AssertNonZero(riActionData.SetMsiString(2, *strName));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	// get info for undo operation
	Bool fKeyExists = fFalse, fValueExists = fFalse;
	MsiString strOldValue;
	if((pError = m_state.pRegKey->Exists(fKeyExists)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	if(fKeyExists)
	{
		if((pError = m_state.pRegKey->ValueExists(strName, fValueExists)) != 0)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
	}
	if(fValueExists)
	{
		// get current value
		if((pError = m_state.pRegKey->GetValue(strName, *&strOldValue)) != 0) //!! need to determine if this is empty or null
		{
			Message(imtError, *pError);
			return iesFailure;
		}
	}

	// remove value
	Bool fSuccess = fFalse;
	pError = m_state.pRegKey->RemoveValue(strName, strValue);
	if (pError)
	{
		DispatchError(imtInfo, Imsg(imsgRemoveValueFailed), *strName, *m_state.strRegKey);
	}
	else
		fSuccess = fTrue;

	// generate undo operations
	
	if(fSuccess)
	{
		MsiString strSubKey = MsiString(m_state.pRegKey->GetKey());
		strSubKey.Remove(iseIncluding, chRegSep);
		
		IMsiRecord* piUndoParams = 0;
		
		if(fKeyExists)
		{
			// key existed
			if(fValueExists)
			{
				// value existed, write old value back - this will create the key also
				piUndoParams = &GetSharedRecord(IxoRegAddValue::Args);
				AssertNonZero(piUndoParams->SetMsiString(IxoRegAddValue::Name, *strName));
				AssertNonZero(piUndoParams->SetMsiString(IxoRegAddValue::Value, *strOldValue));  //!! need to specify null or empty
				if (!RollbackRecord(IxoRegAddValue::Op, *piUndoParams))
					return iesFailure;
			}
			else
			{
				// value didn't exist, but key did - create key to ensure it exists
				piUndoParams = &GetSharedRecord(IxoRegCreateKey::Args);
				if (!RollbackRecord(IxoRegCreateKey::Op, *piUndoParams))
					return iesFailure;
			}
		}
		else
		{
			// key didn't exist, remove key
			piUndoParams = &GetSharedRecord(IxoRegRemoveKey::Args);
			if (!RollbackRecord(IxoRegRemoveKey::Op, *piUndoParams))
				return iesFailure;
		}
	}
	return iesSuccess;
}

/*---------------------------------------------------------------------------
	ixoRegCreateKey: creates RegKey as sub key of RootRegKey
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegCreateKey(IMsiRecord& /*riParams*/)
{
	using namespace IxoRegCreateKey;

	// elevate when in rollback script - necessary if this op is rolling back config reg data
	// could have elevated only for the necessary ops,
	//   but this is safe since we generated the op for rollback and know what its doing (user can't control)
	CElevate elevate(m_istScriptType == istRollback);
	
	if(!m_state.pRegKey)
	{
		// ixoRegOpenKey must not have been called
		if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
		{
			// key wasn't opened since we detected it was user data
			DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
			return iesNoAction;
		}

		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoRegCreateKey")));
		return iesFailure;
	}

	IMsiRecord& riActionData = GetSharedRecord(3); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *(m_state.strRegKey)));
	AssertNonZero(riActionData.SetNull(2));
	AssertNonZero(riActionData.SetNull(3));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	PMsiRecord pError(0);
	Bool fKeyExists; // determines which undo op to use
	if((pError = m_state.pRegKey->Exists(fKeyExists)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	iesEnum iesReturn = iesNoAction;
	Bool fRetry = fTrue, fSuccess = fFalse;
	while(fRetry) // retry loop
	{
		pError = m_state.pRegKey->Create();
		if(pError)
		{
			switch(DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault1), Imsg(imsgCreateKeyFailed),
										*m_state.strRegKey))
			{
			case imsRetry: continue;
			case imsIgnore:
				iesReturn = iesSuccess; fRetry = fFalse;
				break;
			default:
				iesReturn = iesFailure; fRetry = fFalse; //!!?? imsAbort, imsNone
				break;
			};
		}
		else
		{
			iesReturn = iesSuccess;
			fSuccess = fTrue;
			fRetry = fFalse;
		}
	}

	// generate undo operation
	if(fSuccess)
	{
		if(fKeyExists)
		{
			IMsiRecord* piUndoParams = &GetSharedRecord(IxoRegCreateKey::Args);
			if (!RollbackRecord(IxoRegCreateKey::Op, *piUndoParams))
				return iesFailure;
		}
		else
		{
			IMsiRecord* piUndoParams = &GetSharedRecord(IxoRegRemoveKey::Args);
			if (!RollbackRecord(IxoRegRemoveKey::Op, *piUndoParams))
				return iesFailure;

		}
	}
	return iesReturn;
}

iesEnum CMsiOpExecute::ixfRegRemoveKey(IMsiRecord& /*riParams*/)
{
	using namespace IxoRegRemoveKey;

	// elevate when in rollback script - necessary if this op is rolling back config reg data
	// could have elevated only for the necessary ops,
	//   but this is safe since we generated the op for rollback and know what its doing (user can't control)
	CElevate elevate(m_istScriptType == istRollback);

	if(!m_state.pRegKey)
	{
		// ixoRegOpenKey must not have been called
		if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
		{
			// key wasn't opened since we detected it was user data
			DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
			return iesNoAction;
		}

		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoRegRemoveKey")));
		return iesFailure;
	}

	IMsiRecord& riActionData = GetSharedRecord(3); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *(m_state.strRegKey)));
	AssertNonZero(riActionData.SetNull(2));
	AssertNonZero(riActionData.SetNull(3));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	PMsiRecord pError(0);
	Bool fKeyExists; // determines which undo op to use
	if((pError = m_state.pRegKey->Exists(fKeyExists)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	iesEnum iesReturn = iesNoAction;

	// traverse the key and put the undo ops in the rollback script
	if(fKeyExists && RollbackEnabled())
	{
		iesReturn = SetRemoveKeyUndoOps(*m_state.pRegKey);
		if(iesReturn != iesSuccess && iesReturn != iesNoAction)
			return iesReturn;
	}

	Bool fRetry = fTrue, fSuccess = fFalse;
	while(fRetry) // retry loop
	{
		pError = m_state.pRegKey->Remove();
		if(pError)
		{
			switch(DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault1), Imsg(imsgRemoveKeyFailed),
										*m_state.strRegKey))
			{
			case imsRetry: continue;
			case imsIgnore:
				iesReturn = iesSuccess; fRetry = fFalse;
				break;
			default:
				iesReturn = iesFailure; fRetry = fFalse; //!!?? imsAbort, imsNone
				break;
			};
		}
		else
		{
			iesReturn = iesSuccess;
			fSuccess = fTrue;
			fRetry = fFalse;
		}
	}

	// generate undo operation
	if(fSuccess)
	{
		if(fKeyExists == fFalse)
		{
			// key didn't exist, undo operation should unsure it doesn't exist
			IMsiRecord* piUndoParams = &GetSharedRecord(IxoRegRemoveKey::Args);
			if (!RollbackRecord(IxoRegRemoveKey::Op, *piUndoParams))
				return iesFailure;
		}
		// else we did the CreateKey op in SetRemoveKeyUndoOps()
	}
	return iesReturn;
}

iesEnum CMsiOpExecute::ixfRegAddRunOnceEntry(IMsiRecord& riParams)
{
	// write 2 reg values:
	// szRunOnceKey:        value = Name, data = "/@ [Name]"
	// szRunOnceEntriesKey: value = Name, data = Command
	
	using namespace IxoRegAddRunOnceEntry;

	iesEnum iesRet = iesSuccess;
	PMsiRecord pError(0);

	// find server. If running on Win64, get the 64bit path, otherwise the 32 bit path. Because this is a service
	// opcode, we can always get the current type.
	MsiString strRunOnceCommand;
#ifdef _WIN64
	if((pError = GetServerPath(m_riServices, true, true, *&strRunOnceCommand)) != 0)
#else
	if((pError = GetServerPath(m_riServices, true, false, *&strRunOnceCommand)) != 0)
#endif
		return FatalError(*pError);
	Assert(strRunOnceCommand.TextSize());

	strRunOnceCommand += TEXT(" /");
	strRunOnceCommand += MsiChar(CHECKRUNONCE_OPTION);
	strRunOnceCommand += TEXT(" \"");
	strRunOnceCommand += MsiString(riParams.GetMsiString(Name));
	strRunOnceCommand += TEXT("\"");

	// write RunOnce entry
	PMsiRecord pOpenKeyParams = &CreateRecord(IxoRegOpenKey::Args);
	PMsiRecord pAddValueParams = &CreateRecord(IxoRegAddValue::Args);

	AssertNonZero(pOpenKeyParams->SetInteger(IxoRegOpenKey::Root, rrkLocalMachine));
	AssertNonZero(pOpenKeyParams->SetString(IxoRegOpenKey::Key, szRunOnceKey));
	if((iesRet = ixfRegOpenKey(*pOpenKeyParams)) != iesSuccess)
		return iesRet;

	AssertNonZero(pAddValueParams->SetMsiString(IxoRegAddValue::Name, *MsiString(riParams.GetMsiString(Name))));
	AssertNonZero(pAddValueParams->SetMsiString(IxoRegAddValue::Value, *strRunOnceCommand));
	if((iesRet = ixfRegAddValue(*pAddValueParams)) != iesSuccess)
		return iesRet;

	// write our own RunOnceEntries entry - so we know its OK to run the RunOnce command
	{

		CElevate elevate; // to write to our own key

		AssertNonZero(pOpenKeyParams->SetInteger(IxoRegOpenKey::Root, rrkLocalMachine));
		AssertNonZero(pOpenKeyParams->SetString(IxoRegOpenKey::Key, szMsiRunOnceEntriesKey));
		if((iesRet = ixfRegOpenKey(*pOpenKeyParams)) != iesSuccess)
			return iesRet;

		AssertNonZero(pAddValueParams->SetMsiString(IxoRegAddValue::Name, *MsiString(riParams.GetMsiString(Name))));
		AssertNonZero(pAddValueParams->SetMsiString(IxoRegAddValue::Value, *MsiString(riParams.GetMsiString(Command))));
		if((iesRet = ixfRegAddValue(*pAddValueParams)) != iesSuccess)
			return iesRet;
	
	}

	return iesSuccess;
}

iesEnum CMsiOpExecute::SetRegValueUndoOps(rrkEnum rrkRoot, const ICHAR* szKey,
														const ICHAR* szName, ibtBinaryType iType)
{
	// generates rollback ops to delete/restore a registry value
	// call before removing or overwriting a reg value

	PMsiRecord pError(0);
	
	PMsiRegKey pRoot = &m_riServices.GetRootKey(rrkRoot, iType);
	PMsiRegKey pEntry = &pRoot->CreateChild(szKey);
	Bool fKeyExists = fFalse;
	pError = pEntry->Exists(fKeyExists); // ignore error

	IMsiRecord* piUndoParams = &GetSharedRecord(IxoRegOpenKey::Args);
	AssertNonZero(piUndoParams->SetInteger(IxoRegOpenKey::Root, rrkRoot));
	AssertNonZero(piUndoParams->SetInteger(IxoRegOpenKey::BinaryType, iType));
	AssertNonZero(piUndoParams->SetString(IxoRegOpenKey::Key, szKey));
	if (!RollbackRecord(ixoRegOpenKey, *piUndoParams))
		return iesFailure;
	
	if(fKeyExists)
	{
		// key existed
		Bool fValueExists = fFalse;
		pError = pEntry->ValueExists(szName,fValueExists);
		if(fValueExists)
		{
			MsiString strOldValue;
			pError = pEntry->GetValue(szName,*&strOldValue);
			if(pError)
				return FatalError(*pError);

			// value existed, write old value back - this will create the key also
			piUndoParams = &GetSharedRecord(IxoRegAddValue::Args);
			AssertNonZero(piUndoParams->SetString(IxoRegAddValue::Name, szName));
			AssertNonZero(piUndoParams->SetMsiString(IxoRegAddValue::Value, *strOldValue));
			if (!RollbackRecord(IxoRegAddValue::Op, *piUndoParams))
				return iesFailure;
		}
		else
		{
			// value didn't exist, but key did - create key to ensure it exists
			piUndoParams = &GetSharedRecord(IxoRegCreateKey::Args);
			if (!RollbackRecord(IxoRegCreateKey::Op, *piUndoParams))
				return iesFailure;
		}
	}
	else
	{
		// key didn't exist, remove key
		piUndoParams = &GetSharedRecord(IxoRegRemoveKey::Args);
		if (!RollbackRecord(IxoRegRemoveKey::Op, *piUndoParams))
			return iesFailure;
	}

	// remove new value during rollback - not needed if just removing the value now but it doesn't hurt
	piUndoParams = &GetSharedRecord(IxoRegRemoveValue::Args);
	AssertNonZero(piUndoParams->SetString(IxoRegRemoveValue::Name, szName));
	if (!RollbackRecord(IxoRegRemoveValue::Op, *piUndoParams))
		return iesFailure;

	return iesSuccess;
}


iesEnum CMsiOpExecute::SetRemoveKeyUndoOps(IMsiRegKey& riRegKey)
{
	// assumes key exists
	
	if(RollbackEnabled() == fFalse)
		return iesSuccess;
	
	PMsiRecord pError(0);
	iesEnum iesRet = iesNoAction;
	
	// An existing value causes an implied create on this regkey object,
	// allowing security to be set.
	// However, creating a subkey does not necessarily create this *object*
	// and security will not be set.  You must have the object created to
	// allow the security to be applied.
	bool fValue = false;
	
	PEnumMsiString pEnum(0);
	if((pError = riRegKey.GetSubKeyEnumerator(*&pEnum)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	MsiString strTemp;
	while((pEnum->Next(1, &strTemp, 0)) == S_OK)
	{
		PMsiRegKey pKey = &riRegKey.CreateChild(strTemp);
		if((iesRet = SetRemoveKeyUndoOps(*pKey)) != iesSuccess) // recursive call
			return iesRet;
	}

	// generate undo ops for this key
	IMsiRecord& riParams = GetSharedRecord(IxoRegOpenKey::Args);

	MsiString strSubKey = riRegKey.GetKey();
	strSubKey.Remove(iseIncluding, chRegSep);
	
	//!! we can probably do this more efficiently
	if((HKEY)m_state.rrkRegRoot == m_hKey || (m_hOLEKey && (HKEY)m_state.rrkRegRoot == m_hOLEKey) ||
		(m_hOLEKey64 && (HKEY)m_state.rrkRegRoot == m_hOLEKey64) ||(m_hKeyRm && (HKEY)m_state.rrkRegRoot == m_hKeyRm))
	{
		// our/OLE  root for advertising
		// use m_hPublishRootKey/ m_hPublishRootKeyRm/ m_hPublishRootOLEKey and m_strPublishSubKey/ m_strPublishSubKeyRm/ m_strPublishOLESubKey to get true root and subkey
		MsiString strTrueSubKey;
		if((HKEY)m_state.rrkRegRoot == m_hKey)
		{
			Assert(m_hPublishRootKey);
#ifdef _WIN64   // !merced
			AssertNonZero(riParams.SetHandle(IxoRegOpenKey::Root,(HANDLE)m_hPublishRootKey));
#else           // win-32
			AssertNonZero(riParams.SetInteger(IxoRegOpenKey::Root,(int)m_hPublishRootKey));
#endif
			strTrueSubKey = m_strPublishSubKey;
		}
		else if((m_hOLEKey && (HKEY)m_state.rrkRegRoot == m_hOLEKey) ||
				  (m_hOLEKey64 && (HKEY)m_state.rrkRegRoot == m_hOLEKey64))
		{
			Assert(m_hPublishRootOLEKey);
#ifdef _WIN64   // !merced
			AssertNonZero(riParams.SetHandle(IxoRegOpenKey::Root,(HANDLE)m_hPublishRootOLEKey));
#else           //  win-32
			AssertNonZero(riParams.SetInteger(IxoRegOpenKey::Root,(int)m_hPublishRootOLEKey));
#endif
			strTrueSubKey = m_strPublishOLESubKey;
		}
		else
		{
			Assert(m_hKeyRm && (HKEY)m_state.rrkRegRoot == m_hKeyRm);
			Assert(m_hPublishRootKeyRm);
#ifdef _WIN64   // !merced
			AssertNonZero(riParams.SetHandle(IxoRegOpenKey::Root,(HANDLE)m_hPublishRootKeyRm));
#else           // win-32
			AssertNonZero(riParams.SetInteger(IxoRegOpenKey::Root,(int)m_hPublishRootKeyRm));
#endif
			strTrueSubKey = m_strPublishSubKeyRm;
		}
		if(strTrueSubKey.TextSize())
			strTrueSubKey += szRegSep;
		strTrueSubKey += strSubKey;
		AssertNonZero(riParams.SetMsiString(IxoRegOpenKey::Key,*strTrueSubKey));
	}
	else // assume rrkRoot is a valid root
	{
		AssertNonZero(riParams.SetInteger(IxoRegOpenKey::Root, m_state.rrkRegRoot));
		AssertNonZero(riParams.SetMsiString(IxoRegOpenKey::Key, *strSubKey));
		PMsiStream piSD(0);
		pError = riRegKey.GetSelfRelativeSD(*&piSD);
		AssertNonZero(riParams.SetMsiData(IxoRegOpenKey::SecurityDescriptor, piSD));
	}
	AssertNonZero(riParams.SetInteger(IxoRegOpenKey::BinaryType, m_state.iRegBinaryType));
	if (!RollbackRecord(IxoRegOpenKey::Op, riParams))
		return iesFailure;
	
	if((pError = riRegKey.GetValueEnumerator(*&pEnum)) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	MsiString strValue;
	while((pEnum->Next(1, &strTemp, 0)) == S_OK)
	{
		if((pError = riRegKey.GetValue(strTemp,*&strValue)) != 0)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
		AssertNonZero(riParams.ClearData());
		AssertNonZero(riParams.SetMsiString(IxoRegAddValue::Name, *strTemp));
		AssertNonZero(riParams.SetMsiString(IxoRegAddValue::Value, *strValue));
		if (!RollbackRecord(IxoRegAddValue::Op, riParams))
			return iesFailure;
		fValue = true;
	}

	if(!fValue)
	{
		// no values on this key.  It would be created by a subkey,
		// but it might not have had its security applied.

		AssertNonZero(riParams.ClearData());
		if (!RollbackRecord(IxoRegCreateKey::Op, riParams))
			return iesFailure;
	}
	
	return iesSuccess;
}

iesEnum CMsiOpExecute::ProcessSelfReg(IMsiRecord& riParams, Bool fReg)
{
	using namespace IxoRegSelfReg;
	if(!m_state.pTargetPath)
	{  // must not have called ixoSetTargetFolder
		// this is never done during rollback, so we don't need to worry about checking for a changed user
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
			(fReg != fFalse) ? *MsiString(*TEXT("ixoRegSelfReg")) : *MsiString(*TEXT("ixoRegSelfUnReg")));
		return iesFailure;
	}
	PMsiRecord pError(0);

	IMsiRecord& riActionData = GetSharedRecord(2);  // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *MsiString(riParams.GetMsiString(1))));
	AssertNonZero(riActionData.SetMsiString(2, *MsiString(m_state.pTargetPath->GetPath())));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	MsiString strFullFileName;
	if((pError = m_state.pTargetPath->GetFullFilePath(MsiString(riParams.GetMsiString(1)),
																	  *&strFullFileName)))
	{
		return FatalError(*pError);
	}

	// per bug 5342 we elevate self-reg (icaNoImpersonate) for managed apps.
	// Note: this will cause selfregs that access the net to fail. if a self-reg
	// needs to access the net it must be written as a custom action

	iesEnum iesRet = iesSuccess;
	Bool fRetry = fTrue;
	while(fRetry)
	{
		IMsiRecord& riCARec = GetSharedRecord(IxoCustomActionSchedule::Args);
		int icaFlags = icaNoTranslate | icaInScript | icaExe | icaProperty;

		// set the File_ value from the File table for use in AppCompat checks
		MsiString strFileId;
		strFileId += (fReg ? TEXT("+") : TEXT("-"));
		strFileId += MsiString(riParams.GetMsiString(2));
		riCARec.SetMsiString(IxoCustomActionSchedule::Action, *strFileId);

		if (!IsImpersonating()) // if we're not impersonating then we don't want the self-reg to impersonate
		{
			if (PMsiVolume(&m_state.pTargetPath->GetVolume())->DriveType() == idtRemote)
				icaFlags |= icaSetThreadToken; // so we can access the net from msiexec.exe

			icaFlags |= icaNoImpersonate;
		}

		riCARec.SetInteger(IxoCustomActionSchedule::ActionType, icaFlags);

		// determine if the self-reg DLL is 64bit or 32bit. Don't need to do this check on non-64 platforms.
		bool fIs64Bit = false;
		if (g_fWinNT64)
		{
			if ((pError = m_state.pTargetPath->IsPE64Bit(MsiString(riParams.GetMsiString(1)), fIs64Bit)) != 0)
			{
				return FatalError(*pError);
			}
		}

		MsiString strServerPath;
		if((pError = GetServerPath(m_riServices,false,fIs64Bit,*&strServerPath)) != 0)
		{
			return FatalError(*pError);
		}
		Assert(strServerPath.TextSize());
		riCARec.SetMsiString(IxoCustomActionSchedule::Source, *strServerPath);

		
		MsiString strCommandLine = MsiChar('/');
		if(fReg)
			strCommandLine += MsiChar(SELF_REG_OPTION);
		else
			strCommandLine += MsiChar(SELF_UNREG_OPTION);
		
		strCommandLine += TEXT(" \"");
		strCommandLine += strFullFileName;
		strCommandLine += TEXT("\"");
		riCARec.SetMsiString(IxoCustomActionSchedule::Target, *strCommandLine);

		GUID guidAppCompatID;
		GUID guidAppCompatDB;
		HRESULT hr = (HRESULT) ENG::ScheduledCustomAction(riCARec, *MsiString(GetProductKey()), (LANGID)GetProductLanguage(), m_riMessage, m_fRunScriptElevated, GetAppCompatCAEnabled(), GetAppCompatDB(&guidAppCompatDB), GetAppCompatID(&guidAppCompatID));
		if(!SUCCEEDED(hr)) //!! is this the right check - maybe we should ceck NOERROR (0)
		{
			IErrorCode imsg;
			if(fReg)
				imsg = Imsg(imsgOpRegSelfRegFailed);
			else
				imsg = Imsg(imsgOpRegSelfUnregFailed);
			if(!fReg)
			{
				// simply log the failure
				DispatchError(imtInfo, imsg, (const ICHAR*)strFullFileName, hr);
				fRetry = fFalse;
			}
			else
			{
				switch(DispatchError(imtEnum(imtError+imtAbortRetryIgnore), imsg,
						 (const ICHAR*)strFullFileName, hr))
				{
				case imsRetry: break; // will continue, but may need to FreeLibrary before retry
				case imsIgnore:
					iesRet = iesSuccess; fRetry = fFalse; break;
				default:
					iesRet = iesFailure; fRetry = fFalse; break; // imsAbort, imsNone
				}
			}
		}
		else
			fRetry = fFalse;
	}
	
	return iesRet;
}

bool CMsiOpExecute::IsChecksumOK(IMsiPath& riFilePath, const IMsiString& ristrFileName,
											IErrorCode iErr, imsEnum* imsUsersChoice,
											bool fErrorDialog, bool fVitalFile, bool fRetryButton)
{
	bool fReturn = true;
	PMsiRecord pError(0);
	DWORD dwHeaderSum, dwComputedSum;
	bool fDamagedFile = false;

	pError = riFilePath.GetFileChecksum(ristrFileName.GetString(), &dwHeaderSum, &dwComputedSum);
	if ( pError && pError->GetInteger(1) == idbgErrorNoChecksum )
	{
		// this can happen in the case when there's no checksum in the file
		// or the file is badly damaged.
		pError = 0;
		fDamagedFile = true;
	}
	if ( pError )
	{
		fReturn = false;
		if ( !fErrorDialog )
		{
			DispatchError(imtInfo, Imsg(idbgOpCRCCheckFailed), ristrFileName);
			pError = 0; // prevents the error dialog from getting displayed below.
		}
	}
	else if ( dwHeaderSum != dwComputedSum ||
				 fDamagedFile )
	{
		fReturn = false;
		if ( !fErrorDialog )
			DispatchError(imtInfo, Imsg(idbgInvalidChecksum), ristrFileName,
							  *MsiString((int)dwHeaderSum), *MsiString((int)dwComputedSum));
		else
			// causes the error dialog to get displayed.
			pError = PostError(iErr, ristrFileName.GetString());
	}
	
	imsEnum imsRet = imsNone; // initialized for the above cases where !fErrorDialog
	if ( pError )
	{
		Assert(!fReturn);
		imtEnum imtButtons;
		if ( fRetryButton )
			imtButtons = imtEnum(fVitalFile ? imtRetryCancel + imtDefault1 :
														 imtAbortRetryIgnore + imtDefault2);
		else
			imtButtons = imtEnum((fVitalFile ? imtOk : imtOkCancel) + imtDefault1);
		imsRet = DispatchMessage(imtEnum(imtError+imtButtons), *pError, fTrue);
	}
	
	if ( !fReturn && imsUsersChoice )
		*imsUsersChoice = imsRet;

	return fReturn;
}

/*---------------------------------------------------------------------------
ixoRegSelfReg: calls SelfReg function of file
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegSelfReg(IMsiRecord& riParams)
{
	return ProcessSelfReg(riParams, fTrue);
}

/*---------------------------------------------------------------------------
ixoRegSelfReg: calls SelfUnreg function of file
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegSelfUnreg(IMsiRecord& riParams)
{
	return ProcessSelfReg(riParams, fFalse);
}

/*---------------------------------------------------------------------------
ixoFileBindImage: calls BindImage function of services
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfFileBindImage(IMsiRecord& riParams)
{
	using namespace IxoFileBindImage;
	if(!m_state.pTargetPath)
	{  // must not have called ixoSetTargetFolder
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoBindImage")));
		return iesFailure;
	}
	PMsiRecord pError(0);

	// determine if the target file was previously copied to a temporary location
	MsiString strTemp;
	if((pError = m_state.pTargetPath->GetFullFilePath(riParams.GetString(File),*&strTemp)) != 0)
		return FatalError(*pError);

	MsiString strTempLocation;
	icfsEnum icfsFileState = (icfsEnum)0;
	Bool fRes = GetFileState(*strTemp, &icfsFileState, &strTempLocation, 0, 0);

	// if we didn't install or patch this file, skip the binding
	// (its assumed it was done when the file WAS installed or patched last)
	if(((icfsFileState & icfsFileNotInstalled) != 0) &&
		((icfsFileState & icfsPatchFile) == 0))
	{
		// didn't actually install this file, so we assume it has already been bound
		DEBUGMSG1(TEXT("Not binding file %s because it wasn't installed or patched in this install session"),strTemp);
		return iesNoAction;
	}

	// if file is protected, don't bind - SFP would replace file anyway
	if (icfsFileState & icfsProtected)
	{
		DEBUGMSG1(TEXT("Not binding file %s because it is protected by Windows"),strTemp);
		return iesNoAction;
	}
		
	PMsiPath pTargetPath(0);
	MsiString strTargetFileName;
	
	if(strTempLocation.TextSize())
	{
		DEBUGMSG2(TEXT("File %s actually installed to %s, binding temp copy."),strTemp,strTempLocation);
		if((pError = m_riServices.CreateFilePath(strTempLocation,*&pTargetPath,*&strTargetFileName)) != 0)
			return FatalError(*pError);
	}
	else
	{
		pTargetPath = m_state.pTargetPath;
		strTargetFileName = riParams.GetMsiString(File);
	}

	// now pTargetPath and strTargetFileName point to the correct target file
	IMsiRecord& riActionData = GetSharedRecord(2);  // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strTargetFileName));
	AssertNonZero(riActionData.SetMsiString(2, *MsiString(pTargetPath->GetPath())));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	PMsiRecord piError(0);
	if ( msidbFileAttributesChecksum == 
		  (riParams.GetInteger(FileAttributes) & msidbFileAttributesChecksum) )
	{
		if ( !IsChecksumOK(*pTargetPath, *strTargetFileName,
								 0, 0,
								 /* fErrorDialog = */ false, /* fVitalFile = */ false,
								 /* fRetryButton = */ false) )
		{
			DispatchError(imtInfo, Imsg(idbgOpImageNotBound), *strTargetFileName);
			return (iesEnum)iesErrorIgnored;
		}
	}

	MsiDisableTimeout();
	piError = pTargetPath->BindImage(*strTargetFileName,
												*MsiString(riParams.GetMsiString(Folders)));
	MsiEnableTimeout();
	if (piError)//?? only in the debug mode
	{
		//AssertSz(0, TEXT("Could not BindImage file"));
		DispatchError(imtInfo, Imsg(idbgOpBindImage), *strTargetFileName);
	}
	return iesSuccess;
}

// Shortcut operations

iesEnum CMsiOpExecute::CreateFolder(IMsiPath& riPath, Bool fForeign, Bool fExplicitCreation, IMsiStream* pSD)
{
	int cCreatedFolders = 0;
	// create any non-existent folders
	PMsiRecord pRecErr(0);

	while((pRecErr = riPath.EnsureExists(&cCreatedFolders)) != 0)
	{

		switch(DispatchMessage(imtEnum(imtError+imtRetryCancel+imtDefault1), *pRecErr, fTrue))
		{
		case imsRetry:  continue;
		case imsCancel: return iesUserExit;
		default:        return iesFailure;
		};
		break;
	}

	if (pSD)
	{
		// set security on the folder
		CTempBuffer<char, cbDefaultSD> pchSD;
		
		pSD->Reset();

		int cbSD = pSD->GetIntegerValue();
		if (cbDefaultSD < cbSD)
			pchSD.SetSize(cbSD);
			
		// Self Relative Security Descriptor
		pSD->GetData(pchSD, cbSD);
		AssertNonZero(WIN::IsValidSecurityDescriptor(pchSD));


		SECURITY_INFORMATION siAvailable = GetSecurityInformation(pchSD);
		if (m_ixsState == ixsRollback)
		{
			CElevate elevate;
			CRefCountedTokenPrivileges cPrivs(itkpSD_WRITE);
			
			if (!WIN::SetFileSecurity((const ICHAR*) MsiString(riPath.GetPath()), siAvailable, pchSD))
			{
				DWORD dwLastError = WIN::GetLastError();
				Assert(0);
			}
		}
		else
		{
			AssertNonZero(WIN::SetFileSecurity((const ICHAR*) MsiString(riPath.GetPath()), siAvailable, pchSD));
		}
	}

	// register created folders
	if(cCreatedFolders && !fForeign && !(istAdminInstall == m_istScriptType))
	{
		PMsiPath pTempPath(0);
		pRecErr = riPath.ClonePath(*&pTempPath);
		if (pRecErr)
		{
			Message(imtError, *pRecErr);
			return iesFailure;
		}
		for(int i=0;i<cCreatedFolders;i++)
		{
			pRecErr = m_riConfigurationManager.RegisterFolder(*pTempPath, fExplicitCreation);
			if (pRecErr)
			{
				Message(imtInfo, *pRecErr);

				// Bug 9966
				// when we run out of space under a key in Win9X, the register folder is going to start
				// dying.  For simplicity, we'll ignore this error on all platforms.
				// The lResult returned in the error record is ERROR_OUTOFMEMORY
				Assert(g_fWin9X);
			}
			AssertZero(pTempPath->ChopPiece());
		}
	}
	//!! do we do any cleanup if RegisterFolder fails?
	return iesSuccess;
}

iesEnum RemoveFolder(IMsiPath& riPath, Bool fForeign, Bool fExplicitCreation,
							IMsiConfigurationManager& riConfigManager, IMsiMessage& riMessage)
{
	PMsiPath pTempPath(0);
	PMsiRecord pRecErr = riPath.ClonePath(*&pTempPath);
	if (pRecErr)
	{
		riMessage.Message(imtError, *pRecErr);
		return iesFailure;
	}
	MsiString strFolder = pTempPath->GetEndSubPath();
	while(strFolder.TextSize())
	{
		Bool fRemovable = fTrue;
		if (!fForeign)
			pRecErr = riConfigManager.IsFolderRemovable(*pTempPath, fExplicitCreation, fRemovable);

		if (pRecErr)
		{
			riMessage.Message(imtError, *pRecErr);
			return iesFailure;
		}
		if(fRemovable)
		{
			Bool fRetry = fTrue;
			while(fRetry)
			{
				pRecErr = pTempPath->Remove(0);
				if (pRecErr)
				{
					pRecErr = &CreateRecord(2);
					ISetErrorCode(pRecErr, Imsg(idbgOpRemoveFolder));
					pRecErr->SetMsiString(2, *MsiString(pTempPath->GetPath()));
					riMessage.Message(imtInfo, *pRecErr);
					fRetry = fFalse;
/*                  switch(DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault3),
												Imsg(idbgOpRemoveFolder),
												*MsiString(pTempPath->GetPath())))
					{
					case imsAbort:  return iesUserExit;
					case imsRetry:  continue;
					case imsIgnore: fRetry = fFalse; break;  //!! schedule for deletion on reboot???
					default:        fRetry = fFalse; break;  // imsNone //!! do we want to fail here?
					};
*/
				}
				else
					fRetry = fFalse;
			}
		}

		Bool fExists = fFalse;
		pRecErr = pTempPath->Exists(fExists);
		if (pRecErr)
		{
			riMessage.Message(imtError, *pRecErr);
			return iesFailure;
		}
		if(fRemovable && !fExists)
		{
			pRecErr = riConfigManager.UnregisterFolder(*pTempPath);
			if (pRecErr)
			{
				riMessage.Message(imtError, *pRecErr);
				return iesFailure;
			}
		}
		if(fExists || fForeign)
			break; // folder still exists, can't remove any parent folders

		pTempPath->ChopPiece();
		strFolder = pTempPath->GetEndSubPath();
	}
	return iesSuccess;
}

iesEnum CMsiOpExecute::RemoveFolder(IMsiPath& riPath, Bool fForeign, Bool fExplicitCreation)
{
	return ::RemoveFolder(riPath, fForeign, fExplicitCreation, m_riConfigurationManager, m_riMessage);
}
	
iesEnum CMsiOpExecute::FileCheckExists(const IMsiString& ristrName, const IMsiString& ristrPath)
{
	PMsiPath piPath(0);
	PMsiRecord pRecErr = m_riServices.CreatePath(ristrPath.GetString(), *&piPath);
	if (pRecErr)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}
	Bool fExists;
	pRecErr = piPath->FileExists(ristrName.GetString(), fExists);
	if (pRecErr)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}
	if (!fExists)
	{
		MsiString strFullPath;
		PMsiRecord(piPath->GetFullFilePath(ristrName.GetString(), *&strFullPath));
		DispatchError(imtError, Imsg(idbgOpFileMissing),
						  *strFullPath);
		return iesFailure;
	}
	return iesSuccess;
}



//!! for fonts registration - should be put in central location!!
static const ICHAR* WIN_INI = TEXT("WIN.INI");
static const ICHAR* REGKEY_WIN_95_FONTS = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Fonts");
static const ICHAR* REGKEY_WIN_NT_FONTS = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts");

iesEnum CMsiOpExecute::ixfFontRegister(IMsiRecord& riParams)
{
	using namespace IxoFontRegister;
	// m_state.pTargetPath may be 0 to indicate the file is in the default font folder
	if (!m_state.pTargetPath && (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback)))
	{
		DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
		return iesNoAction;
	}
	return ProcessFont(riParams, fFalse);
}

iesEnum CMsiOpExecute::ixfFontUnregister(IMsiRecord& riParams)
{
	using namespace IxoFontUnregister;
	
	if (!m_state.pTargetPath && (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback)))
	{
		DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
		return iesNoAction;
	}
	return ProcessFont(riParams, fTrue);
}

iesEnum CMsiOpExecute::ProcessFont(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoFontRegister; // same as IxoFontUnregister

	MsiString strTitle = riParams.GetMsiString(Title);
	MsiString strFont = riParams.GetMsiString(File);
	IMsiRecord& riActionData = GetSharedRecord(1);
	AssertNonZero(riActionData.SetMsiString(1, *strFont));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	PMsiRecord pRecErr(0);
		
	iesEnum iesRet = iesNoAction;
	bool fSuccess = true;
	MsiString strOldFont; // old font for rollback
	bool fRegistered = false;
	PMsiPath pOldFontPath(0);

	for(;;)
	{
		fSuccess = true;
		//!! fInUse is a misnomer - should actually be called fFileNotCopied
		bool fInUse = false;
		// if font title not specified, get the font title from the file
		if(!strTitle.TextSize())
		{
			Assert(strFont.TextSize()); // we expect the font file to have been specified
			MsiString strFullFilePath;
			MsiString strTitleInTTFFile;
			if((pRecErr = (m_state.pTargetPath)->GetFullFilePath(strFont, *&strFullFilePath)) != 0)
			{
				Message(imtInfo, *pRecErr);
				fSuccess = false;
			}
			else
			{
				if(!fRemove)
				{
					icfsEnum icfsFileState = (icfsEnum)0;
					MsiString strTempLocation;
					AssertNonZero(GetFileState(*strFullFilePath, &icfsFileState, &strTempLocation, 0, 0));
					if(icfsFileState & icfsFileNotInstalled) // was the file actually copied???
						fInUse = true;

					if(strTempLocation.TextSize())
					{
						DEBUGMSG2(TEXT("Font File %s actually installed to %s, getting font title from temp copy."),strFullFilePath,strTempLocation);
						strFullFilePath = strTempLocation;
						fInUse = true;
					}
				}

				if(FGetTTFTitle(strFullFilePath, *&strTitleInTTFFile) && strTitleInTTFFile.TextSize())
					strTitle = strTitleInTTFFile;
				else
				{
					// cannot set the font title
					DEBUGMSG1(TEXT("Cannot get the font title for %s."), strFont);
					fSuccess = false;
				}
			}
		}

		if(fSuccess)
		{
			// check if font is already registered
			const ICHAR* szKey = g_fWin9X ? REGKEY_WIN_95_FONTS : REGKEY_WIN_NT_FONTS;
			MsiString strOldFontPath;

			PMsiRegKey pRegKeyRoot = &m_riServices.GetRootKey(rrkLocalMachine, ibtCommon);
			PMsiRegKey pRegKey = &(pRegKeyRoot->CreateChild(szKey));
			if((pRecErr =  pRegKey->GetValue(strTitle, *&strOldFontPath)) == 0 && strOldFontPath.TextSize())
			{
				if(ENG::PathType(strOldFontPath) == iptFull)
				{
					if((pRecErr = m_riServices.CreateFilePath(strOldFontPath,*&pOldFontPath,*&strOldFont)) != 0)
						Message(imtInfo, *pRecErr);
					else
						fRegistered = true;
				}
				else
				{
					strOldFont = strOldFontPath;
					fRegistered = true;
				}
			}
		
			if(!fRemove)
				pRecErr = m_riServices.RegisterFont(strTitle,strFont, m_state.pTargetPath, fInUse);
			else
				pRecErr = m_riServices.UnRegisterFont(strTitle);
			if (pRecErr)
			{
				Message(imtInfo, *pRecErr);
				fSuccess = false;
			}
			else
			{
				m_fFontRefresh = true; // flag to send the font change message at the end of the install
				if(g_fWin9X && !m_fResetTTFCache) // we need to set up the deletion of the cached folder if fonts installed (on Win9x only)
				{
					// Construct the full pathname of the ttfCache file.
					TCHAR szPathnamettfCache[MAX_PATH];
					MsiGetWindowsDirectory(szPathnamettfCache, MAX_PATH);
					PMsiPath pPath(0);
					MsiString strttfCache = *TEXT("ttfCache");
					pRecErr = m_riServices.CreatePath(szPathnamettfCache, *&pPath);
					if (pRecErr)
					{
						Message(imtInfo, *pRecErr);
						fSuccess = false;
					}
					else
					{
						MsiString strFullPathttfCache;
						pRecErr = pPath->GetFullFilePath(strttfCache, *&strFullPathttfCache);
						if (pRecErr)
						{
							Message(imtInfo, *pRecErr);
							fSuccess = false;
						}
						else if(ReplaceFileOnReboot(strFullPathttfCache, 0)) //!!
							m_fResetTTFCache = true; // so that we dont do this again
						else
							fSuccess = false;
					}
				}
			}
		}

		if(!fSuccess)
		{
			if(!fRemove)
			{
				switch(DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault3),
						 Imsg(imsgOpRegFont),
						 *strTitle))
					{
					case imsRetry:  continue;
					case imsIgnore:
						iesRet = iesSuccess; break;
					default:
						iesRet = iesFailure; break; // imsAbort, imsNone
					}
			}
			else
			{
				DispatchError(imtInfo, Imsg(imsgOpUnregFont), *strTitle);
				iesRet = iesSuccess;
			}
		}
		break;
	}

	// generate undo op
	if(fSuccess)
	{
		if(fRegistered)
		{
			// re-register old font on rollback
			IMsiRecord* piSTFUndoParams = 0;
			if((pOldFontPath && !m_state.pTargetPath) ||
				(!pOldFontPath && m_state.pTargetPath) ||
				(pOldFontPath && m_state.pTargetPath &&
				(0 == MsiString(pOldFontPath->GetPath()).Compare(iscExactI, MsiString(m_state.pTargetPath->GetPath())))))
			{
				piSTFUndoParams = &GetSharedRecord(IxoSetTargetFolder::Args);
				if(pOldFontPath)
					AssertNonZero(piSTFUndoParams->SetMsiString(IxoSetTargetFolder::Folder,
																			  *MsiString(pOldFontPath->GetPath())));
				else
					AssertNonZero(piSTFUndoParams->SetNull(IxoSetTargetFolder::Folder));
				if (!RollbackRecord(ixoSetTargetFolder, *piSTFUndoParams))
					return iesFailure;
			}

			IMsiRecord* piFRUndoParams = &GetSharedRecord(IxoFontRegister::Args);
			AssertNonZero(piFRUndoParams->SetMsiString(IxoFontRegister::Title,*strTitle));
			AssertNonZero(piFRUndoParams->SetMsiString(IxoFontRegister::File,*strOldFont));
			if (!RollbackRecord(ixoFontRegister, *piFRUndoParams))
				return iesFailure;

			if(piSTFUndoParams)
			{
				if(m_state.pTargetPath)
				AssertNonZero(piSTFUndoParams->SetMsiString(IxoSetTargetFolder::Folder,
																		  *MsiString(m_state.pTargetPath->GetPath())));
				else
					AssertNonZero(piSTFUndoParams->SetNull(IxoSetTargetFolder::Folder));
				if (!RollbackRecord(ixoSetTargetFolder, *piSTFUndoParams))
					return iesFailure;
			}
		}
		if(!fRemove)
		{
			// unregister new font on rollback
			IMsiRecord* piFUUndoParams = &GetSharedRecord(IxoFontUnregister::Args);
			AssertNonZero(piFUUndoParams->SetMsiString(IxoFontUnregister::Title,*strTitle));
			AssertNonZero(piFUUndoParams->SetMsiString(IxoFontUnregister::File,*strFont));
			if (!RollbackRecord(ixoFontUnregister, *piFUUndoParams))
				return iesFailure;
		}
	}

	return iesRet;
}


// Ini file operations

Bool IniKeyExists(IMsiPath* piPath, const ICHAR* szFile, const ICHAR* szSection, const ICHAR* szKey)
{
    Assert(szFile && szSection && szKey);
    if(!(*szKey))
        return fFalse;
    PMsiRecord pError(0);
    Bool fWinIni;
    int icurrLen = 100;
    CTempBuffer<ICHAR,100> rgBuffer;
    ICHAR* szDefault = TEXT("");
    MsiString strFullFilePath;
    if((!IStrCompI(szFile, WIN_INI)) && (piPath == 0))
    {
        // WIN.INI
        fWinIni = fTrue;
    }
    else
    {
        // not WIN.INI
        fWinIni = fFalse;
        if(piPath != 0)
        {
            pError = piPath->GetFullFilePath(szFile, *&strFullFilePath);
            if(pError != 0)
                return fFalse;
        }
    }
    for(;;)
    {
        rgBuffer.SetSize(icurrLen); // add space to append new value
		if ( ! (ICHAR *) rgBuffer )
			return fFalse;
        int iret;
        if(fWinIni)
        {
            iret = GetProfileString(szSection,       // address of section name
                                    0,   // address of key name
                                    szDefault,       // address of default string
                                    rgBuffer,        // address of destination buffer
                                    icurrLen); // size of destination buffer
        }
        else
        {
            iret = GetPrivateProfileString(szSection,       // address of section name
                                            0,   // address of key name
                                            szDefault,       // address of default string
                                            rgBuffer,        // address of destination buffer
                                            icurrLen, // size of destination buffer
                                            strFullFilePath); // .INI file
        }
        if((icurrLen - 1) != iret)
            // sufficient memory
            break;
        icurrLen += 100;
    }

	// check if key exists in section
	MsiString strCurrentKey;
	ICHAR* pch = rgBuffer;
	while(*pch != 0)
	{
		if(IStrCompI(pch, szKey) == 0)
			return fTrue;
		else
			pch += IStrLen(pch) + 1;
	}
	return fFalse;
}

/*---------------------------------------------------------------------------
ixoIniWriteRemoveValue: writes or removes value from .ini file
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfIniWriteRemoveValue(IMsiRecord& riParams)
{
	using namespace IxoIniWriteRemoveValue;
	PMsiRecord pError(0);
	
	MsiString strSection = riParams.GetMsiString(Section);
	MsiString strKey = riParams.GetMsiString(Key);
	MsiString strValue = riParams.GetMsiString(Value);
	if(!riParams.IsNull(IxoIniWriteRemoveValue::Args + 1))
	{
		strValue = GetSFN(*strValue, riParams, IxoIniWriteRemoveValue::Args + 1);
	}

	iifIniMode iif = (iifIniMode)riParams.GetInteger(Mode);

	// m_state.pIniPath may be null, and that's OK
	IMsiRecord& riActionData = GetSharedRecord(4);
	AssertNonZero(riActionData.SetMsiString(1, *(m_state.strIniFile)));
	AssertNonZero(riActionData.SetMsiString(2, *strSection));
	AssertNonZero(riActionData.SetMsiString(3, *strKey));
	AssertNonZero(riActionData.SetMsiString(4, *strValue));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	// gather information for undo op
	Bool fKeyExists = fFalse, fTagExists = fFalse;
	MsiString strOldLine;
	// check if key exists
	if((pError = m_riServices.ReadIniFile(m_state.pIniPath,
													  m_state.strIniFile,
													  strSection,
													  strKey,
													  0, *&strOldLine)) != 0)
	{
		Message(imtError, *pError); //!!
		return iesFailure;
	}
	if(strOldLine.TextSize() || IniKeyExists(m_state.pIniPath,m_state.strIniFile,strSection,strKey))
	{
		fKeyExists = fTrue;
	}
	if(fKeyExists && (iif == iifIniAddTag || iif == iifIniRemoveTag))
	{
		MsiString strValueStart = strValue;
		strValueStart += TEXT(",");
		MsiString strValueEnd = TEXT(",");
		strValueEnd += strValue;
		MsiString strValueMiddle = strValueEnd;
		strValueMiddle += TEXT(",");
		if(strOldLine.Compare(iscExactI,strValue) ||
			strOldLine.Compare(iscStartI,strValueStart) ||
			strOldLine.Compare(iscEndI,strValueEnd) ||
			strOldLine.Compare(iscWithinI,strValueMiddle))
			fTagExists = fTrue;
	}

	iesEnum iesRet = iesSuccess;
	if((iif == iifIniAddLine || iif == iifIniCreateLine || iif == iifIniAddTag) && (m_state.pIniPath))
	{
		iesRet = CreateFolder(*m_state.pIniPath);
	}
	
	MsiString strPath;
	if(m_state.pIniPath)
		strPath = m_state.pIniPath->GetPath();
	Bool fRetry = fTrue, fSuccess = fFalse;
	if(iesRet == iesSuccess)
	{
		while(fRetry)
		{
			pError = m_riServices.WriteIniFile(m_state.pIniPath,
														  m_state.strIniFile,
														  strSection,
														  strKey,
														  strValue,
														  iif);
			if(pError)
			{
				switch(DispatchError(imtEnum(imtError+imtRetryCancel+imtDefault1), Imsg(imsgOpUpdateIni),
											*strPath,
											*m_state.strIniFile))
				{
				case imsRetry: continue;
				default:
					iesRet = iesFailure; fRetry = fFalse;  // imsCancel, imsNone
					break;
				};
			}
			else
			{
				iesRet = iesSuccess;
				fSuccess = fTrue;
				fRetry = fFalse;
			}
		}
	}
	
	if (fSuccess && IsTerminalServerInstalled() && g_iMajorVersion >= 5 && m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
	{
		MsiString strFullPath;
		TCHAR szWindowsFolder[MAX_PATH];
		MsiGetWindowsDirectory(szWindowsFolder, MAX_PATH);
		strFullPath += szWindowsFolder;

		// NT5 Hydra installs should notify the system if the INI file is in the WindowsFolder
		// so it can be propogated to each user's private Windows folder.
		bool fIsWindowsFolder = (m_state.pIniPath == 0);
		if (!fIsWindowsFolder)
		{
			PMsiPath pWinPath(0);
			if (0 == m_riServices.CreatePath(szWindowsFolder, *&pWinPath))
			{
				ipcEnum ipcWinDir;
				m_state.pIniPath->Compare(*pWinPath, ipcWinDir);
				fIsWindowsFolder = (ipcEqual == ipcWinDir);
			}
		}

		if (fIsWindowsFolder)
		{
			// generate the full filename
			if (!strFullPath.Compare(iscEnd, TEXT("\\")))
				strFullPath += TEXT("\\");
			strFullPath += m_state.strIniFile;

			TSAPPCMP::TermsrvLogInstallIniFileEx(CConvertString(strFullPath));
		}
	}

	if(fSuccess && (iif == iifIniRemoveLine || iif == iifIniRemoveTag) && (m_state.pIniPath))
	{
		if((iesRet = RemoveFolder(*m_state.pIniPath)) != iesSuccess)
			return iesRet;
	}

	// generate undo op
	if(fSuccess) // everything worked
	{
		IMsiRecord& riUndoParams = GetSharedRecord(Args);
		AssertNonZero(riUndoParams.SetMsiString(Section, *strSection));
		AssertNonZero(riUndoParams.SetMsiString(Key, *strKey));
		if(iif == iifIniAddLine || iif == iifIniCreateLine || iif == iifIniRemoveLine)
		{
			if(fKeyExists && iif != iifIniCreateLine)
			{
				// generate op to add back old line
				AssertNonZero(riUndoParams.SetMsiString(Value,*strOldLine));
				AssertNonZero(riUndoParams.SetInteger(Mode,iifIniAddLine));
				if (!RollbackRecord(ixoIniWriteRemoveValue,riUndoParams))
					return iesFailure;
			}
			if(iif != iifIniRemoveLine)
			{
				// generate op to remove line we just added
				AssertNonZero(riUndoParams.SetMsiString(Value,*strValue));
				AssertNonZero(riUndoParams.SetInteger(Mode,iifIniRemoveLine));
				if (!RollbackRecord(ixoIniWriteRemoveValue,riUndoParams))
					return iesFailure;
			}
		}
		else // iifIniAddTag, iifIniRemoveTag
		{
			if(fTagExists)
			{
				// generate op to add back old tag //!! don't need this
				AssertNonZero(riUndoParams.SetMsiString(Value,*strValue));
				AssertNonZero(riUndoParams.SetInteger(Mode,iifIniAddTag));
				if (!RollbackRecord(ixoIniWriteRemoveValue,riUndoParams))
					return iesFailure;
			}
			if(iif != iifIniRemoveTag)
			{
				// generate op to remove tag we just added
				AssertNonZero(riUndoParams.SetMsiString(Value,*strValue));
				AssertNonZero(riUndoParams.SetInteger(Mode,iifIniRemoveTag));
				if (!RollbackRecord(ixoIniWriteRemoveValue,riUndoParams))
					return iesFailure;
			}
		}
	}

	return iesRet;
}

/*---------------------------------------------------------------------------
ixoIniFilePath - sets .ini filename and path, path may be NULL
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfIniFilePath(IMsiRecord& riParams)
{
	using namespace IxoIniFilePath;
	PMsiRecord pError(0);
	if(MsiString(riParams.GetMsiString(2)).TextSize())
	{
		if((pError = m_riServices.CreatePath(riParams.GetString(2),*&m_state.pIniPath)) != 0)
		{
			Message(imtError, *pError); //!! reformat error message
			return iesFailure;
		}
	}
	else
	{
		m_state.pIniPath = 0;
	}
	m_state.strIniFile = riParams.GetMsiString(1);
	
	// generate undo operation
	if (!RollbackRecord(Op, riParams))
		return iesFailure;
	
	return iesSuccess;
}


iesEnum CMsiOpExecute::ixfResourceUpdate(IMsiRecord& )
{
	// OBSELETE
	AssertSz(0, TEXT("UpdateResource functionality not supported"));
	return iesFailure;
}

// File system operations

/*---------------------------------------------------------------------------
ixoSetSourceFolder: Sets the source path for ixoCopyTo
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSetSourceFolder(IMsiRecord& riParams)
{
	using namespace IxoSetSourceFolder;

	m_state.pCurrentSourcePathPrivate = 0;
	m_state.strCurrentSourceSubPathPrivate = g_MsiStringNull;
	m_state.iCurrentSourceTypePrivate = -1;
	m_state.fSourcePathSpecified = true;

	MsiString strEncodedPath = riParams.GetMsiString(IxoSetTargetFolder::Folder); // the path may be encoded
	int cch = 0;
	if((cch = strEncodedPath.Compare(iscStart, szUnresolvedSourceRootTokenWithBS)) != 0)
	{
		strEncodedPath.Remove(iseFirst, cch);
		m_state.strCurrentSourceSubPathPrivate = strEncodedPath;

		// will determine full source path and type when GetCurrentSourcePathAndType is called
	}
	else
	{
		Assert(PathType(strEncodedPath) == iptFull);

		int cSilentRetries = 0;
		bool fRetry;
		do
		{
			fRetry = false;
			PMsiRecord pRecErr = m_riServices.CreatePath(strEncodedPath,*&(m_state.pCurrentSourcePathPrivate));
			if (pRecErr)
			{
				int iError = pRecErr->GetInteger(1);
				if (iError == imsgPathNotAccessible && cSilentRetries < MAX_NET_RETRIES)
				{
					Sleep(1000);
					cSilentRetries++;
					fRetry = true;
					continue;
				}
				else
				{
					switch(DispatchMessage(imtEnum(imtError+imtRetryCancel+imtDefault1), *pRecErr, fTrue))
					{
					case imsRetry:
						fRetry = true;
						continue;
					default:  // imsCancel
						return iesFailure;
					};
				}
			}
		}while (fRetry);

		Assert(m_state.pCurrentSourcePathPrivate);

		// set current source type
		// since this is not a path to the original source, the type of source is determined by
		// just the volume attributes, not the package settings
		m_state.iCurrentSourceTypePrivate = (m_state.pCurrentSourcePathPrivate->SupportsLFN()) ? 0 : msidbSumInfoSourceTypeSFN;
	}

	// NOTE: we don't put SetSourceFolder operation in rollback script
	// it is never used and could potentially cause problems when one user tries to
	// access a source used by another user

	return iesSuccess;
}

iesEnum CMsiOpExecute::GetSourceRootAndType(IMsiPath*& rpiSourceRoot, int& iSourceType)
{
	if(!m_piDirectoryManager)
	{
		DispatchError(imtError, Imsg(idbgOpNoDirMgr));
		return iesFailure;
	}
	
	PMsiRecord pError = m_piDirectoryManager->GetSourceRootAndType(rpiSourceRoot, iSourceType);
	if(pError)
	{
		if (pError->GetInteger(1) == imsgUser)
			return iesUserExit;
		else
			return FatalError(*pError);
	}

	return iesSuccess;
}

// GetCurrentSourcePath: returns the path set by the ixoSetSourcePath operation
//                       because source resolution may be necessary to fully resolve
//                       that path, this function should be called when the path
//                       is needed
iesEnum CMsiOpExecute::GetCurrentSourcePathAndType(IMsiPath*& rpiSourcePath, int& iSourceType)
{
	if(!m_state.fSourcePathSpecified)
	{  // must not have called ixoSetSourceFolder
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoSetSourceFolder")));
		return iesFailure;
	}
	
	if(m_state.pCurrentSourcePathPrivate == 0)
	{
		// we need to get the source root (which may require resolving the source)
		// and tack on the current sub-path
		PMsiPath pSourceRootPath(0);
		iesEnum iesRet = GetSourceRootAndType(*&pSourceRootPath, m_state.iCurrentSourceTypePrivate);
		if(iesRet != iesSuccess)
			return iesRet;

		// append path and subpath
		PMsiRecord pError(0);
		if((pError = pSourceRootPath->ClonePath(*&m_state.pCurrentSourcePathPrivate)) != 0)
		{
			return FatalError(*pError);
		}

		// if source type is compressed, return just the root (all files live at the root)
		if((!(m_state.iCurrentSourceTypePrivate & msidbSumInfoSourceTypeCompressed) ||
			  (m_state.iCurrentSourceTypePrivate & msidbSumInfoSourceTypeAdminImage)) &&
			m_state.strCurrentSourceSubPathPrivate.TextSize())
		{
			// sub-path may be short|long pair (where each half is the entire sub-path)
			Bool fLFN = ToBool(FSourceIsLFN(m_state.iCurrentSourceTypePrivate,
													  *(m_state.pCurrentSourcePathPrivate)));
			
			MsiString strExtractedSubPath = m_state.strCurrentSourceSubPathPrivate.Extract(fLFN ? iseAfter : iseUpto,
																								  chFileNameSeparator);
			
			if((pError = m_state.pCurrentSourcePathPrivate->AppendPiece(*strExtractedSubPath)) != 0)
			{
				return FatalError(*pError);
			}
		}
	}

	rpiSourcePath = m_state.pCurrentSourcePathPrivate;
	rpiSourcePath->AddRef();

	iSourceType = m_state.iCurrentSourceTypePrivate;

	return iesSuccess;
}


/*---------------------------------------------------------------------------
ixoSetTargetFolder: Sets the target path for ixoCopyTo and ixoFileRemove
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSetTargetFolder(IMsiRecord& riParams)
{
	using namespace IxoSetTargetFolder;

	// If the cabinet copier notified us that a media change is required,
	// we must defer any set target folders until a media change is executed.
	if (m_state.fWaitingForMediaChange)
	{
		PushRecord(riParams);
		return iesSuccess;
	}

	if(riParams.IsNull(IxoSetTargetFolder::Folder))
	{
		m_state.pTargetPath = 0;
		return iesSuccess;
	}

	PMsiRecord pError(0);
	MsiString strEncodedPath = riParams.GetMsiString(IxoSetTargetFolder::Folder); // the path may be encoded
	MsiString strLocation = strEncodedPath.Extract(iseUpto, MsiChar(chDirSep));
	CTempBuffer<ICHAR, MAX_PATH> rgchPath;
	if(strLocation != iMsiStringBadInteger)
	{
		int iFolderId = strLocation;
		pError = GetShellFolder(iFolderId, *&strLocation);
		
		// must prevent writes to the shell folders during rollback initiated by a changed user.
		if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
		{
			m_state.pTargetPath = NULL;
			DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
			return iesNoAction;
		}

		if (pError)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
		if(strEncodedPath.Remove(iseUpto, MsiChar(chDirSep)))
		{
			//?? ugly
			MsiString strDirSep = MsiChar(chDirSep);
			if(strLocation.Compare(iscEnd, strDirSep))
				strLocation.Remove(iseLast, 1); // chop off the separator, if present
			strLocation += strEncodedPath;
		}
	}
	else
	{
		strLocation = strEncodedPath;
	}

	GetEnvironmentStrings(strLocation,rgchPath);

	pError = m_riServices.CreatePath(rgchPath,*&(m_state.pTargetPath));
	if (pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	// generate undo operation
	if (!RollbackRecord(Op, riParams))
		return iesFailure;

	return iesSuccess;
}


iesEnum CMsiOpExecute::CreateFilePath(const ICHAR* szPath, IMsiPath*& rpiPath, const IMsiString*& rpistrFileName)
{
	bool fRetry;
	do
	{
		PMsiRecord pRecErr(0);
		fRetry = false;
		if((pRecErr = m_riServices.CreateFilePath(szPath,rpiPath,rpistrFileName)) != 0)
		{
			switch (DispatchMessage(imtEnum(imtError+imtAbortRetryIgnore+imtDefault1), *pRecErr, fTrue))
			{
			case imsRetry:
				fRetry = true;
				continue;
			case imsIgnore:
				return iesSuccess;
			default:
			return iesFailure;
			}
		}
	}while (fRetry);
	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixoFileRemove: Remove the specified file
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfFileRemove(IMsiRecord& riParams)
{
	using namespace IxoFileRemove;

	PMsiPath pPath(0);
	MsiString strFileName, strFilePath = riParams.GetMsiString(FileName);
	// check if files is full or relative path
	if(ENG::PathType(strFilePath) == iptFull)
	{
		iesEnum iesResult = CreateFilePath(strFilePath,*&pPath,*&strFileName);
		if (iesResult != iesSuccess)
			return iesResult;

		AssertNonZero(riParams.SetMsiString(FileName,*strFileName)); // replace full path with file name
	}
	else
	{
		pPath = m_state.pTargetPath;
		strFileName = strFilePath;
	}

	
	if(!pPath)
	{  // must not have called ixoSetTargetFolder
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoFileRemove")));
		return iesFailure;
	}

	// check if file is part of Assembly
	bool fFusionComponent = false;
	MsiString strComponentId = riParams.GetMsiString(ComponentId);
	if(strComponentId.TextSize() && m_pAssemblyUninstallTable)
	{
		PMsiCursor pCacheCursor = m_pAssemblyUninstallTable->CreateCursor(fFalse);
		pCacheCursor->SetFilter(iColumnBit(m_colAssemblyUninstallComponentId));
		AssertNonZero(pCacheCursor->PutString(m_colAssemblyUninstallComponentId, *strComponentId));
		if(pCacheCursor->Next())
		{
			// a fusion component
			fFusionComponent = true;
		}
	}

	IMsiRecord& riActionData = GetSharedRecord(9);
	AssertNonZero(riActionData.SetMsiString(1, *strFileName));
	if(!fFusionComponent)
		AssertNonZero(riActionData.SetMsiString(9, *MsiString(pPath->GetPath())));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	if(fFusionComponent)
	{
		// do not attempt to remove the files ourselves
		DEBUGMSG1(TEXT("delegating uninstallation of assembly file : %s to Fusion"), (const ICHAR*)strFileName);
		return iesNoAction;
	}


#ifdef CONFIGDB
	if (!riParams.IsNull(ComponentId))
	{
		icdrEnum icdr = m_riConfigurationManager.UnregisterFile(MsiString(pPath->GetPath()), strFileName, MsiString(riParams.GetMsiString(ComponentId)));
		if (icdr == icdrMore)
			return iesNoAction;
		Assert(icdr == icdrOk);
	}
#endif
	
	// elevate if necessary
	bool fElevate = (!riParams.IsNull(Elevate) && riParams.GetInteger(Elevate) != 0) ? true : false;
	CElevate elevate(fElevate);

	return RemoveFile(*pPath, *strFileName, fTrue, /*fBypassSFC*/ false);
}

// RemoveFile: helper function to remove a file and handle rollback - called by ixfFileRemove
//  and ixfFileCopy when moving a file
iesEnum CMsiOpExecute::RemoveFile(IMsiPath& riPath, const IMsiString& ristrFileName, Bool fHandleRollback, bool fBypassSFC,
									bool fRebootOnRenameFailure, Bool fRemoveFolder, iehEnum iehErrorMode, bool fWillReplace)
{
	bool fRetry;
	Bool fExists;
	DWORD dwExistError;
	PMsiRecord pRecErr(0);
	do
	{
		fRetry = false;
		if((pRecErr = riPath.FileExists(ristrFileName.GetString(),fExists,&dwExistError)) != 0)
		{
			if (iehErrorMode == iehSilentlyIgnoreError)
			{
				Message(imtInfo, *pRecErr);
				return (iesEnum) iesErrorIgnored;
			}

			switch (DispatchMessage(imtEnum(imtError+imtAbortRetryIgnore+imtDefault2), *pRecErr, fTrue))
			{
			case imsIgnore:
				return (iesEnum) iesErrorIgnored;
			case imsRetry:
					fRetry = true;
					continue;
			default:
				return iesFailure;
			return iesFailure;
			}
		}
	}while (fRetry);

	if(!fExists)
	{
		if ((dwExistError != ERROR_FILE_NOT_FOUND) && (dwExistError != ERROR_PATH_NOT_FOUND))
		{
			DEBUGMSG2(TEXT("Error %d attempting to delete file %s"), (const ICHAR *)(INT_PTR)dwExistError, ristrFileName.GetString()); 
		}
		return fRemoveFolder ? RemoveFolder(riPath) : iesSuccess;
	}

	// Do not attempt to delete any file protected by SFP
	MsiString strFullPath;
	if ((pRecErr = riPath.GetFullFilePath(ristrFileName.GetString(), *&strFullPath)) == 0)
	{
		AssertSz(!(!g_fWin9X && g_iMajorVersion >= 5) || g_MessageContext.m_hSfcHandle,
					g_szNoSFCMessage);
		BOOL fProtected = fFalse;
 		if (!fBypassSFC && g_MessageContext.m_hSfcHandle )
			fProtected = SFC::SfcIsFileProtected(g_MessageContext.m_hSfcHandle, CConvertString(strFullPath));
		if (fProtected)
		{
			DEBUGMSG1(TEXT("This following file was not removed, because it is protected by Windows: %s"), strFullPath);
			return iesSuccess;
		}
	}

	iesEnum iesRet = iesNoAction;
	if(fHandleRollback && RollbackEnabled())
	{
		// create a backup file - essentially removes file as well
		if((iesRet = BackupFile(riPath,ristrFileName,fTrue,fRemoveFolder,iehErrorMode,fRebootOnRenameFailure,fWillReplace)) != iesSuccess)
			return iesRet;
	}
	else
	{
		// attempt to delete file
		fRetry = false;
		pRecErr = riPath.RemoveFile(ristrFileName.GetString());
		if(pRecErr)
		{
			// failed to remove file
			// either access denied or sharing violation
			iesRet = VerifyAccessibility(riPath, ristrFileName.GetString(), DELETE, iehErrorMode); //!! doesn't catch case where dir has DELETE access but file doesn't
			if(iesRet != iesSuccess)
				return iesRet;
			
			// access verified - must be sharing violation
			
			MsiString strFileFullPath;
			if((pRecErr = riPath.GetFullFilePath(ristrFileName.GetString(),
															 *&strFileFullPath)) != 0)
			{
				Message(imtError, *pRecErr);
				return iesFailure;
			}

			bool fRenameSuccess = false;
			if(fRebootOnRenameFailure)
			{
				// we are attempting to remove this in-use file to put another in its place
				// rather than install the new file to a temporary location, check if we can
				// move this file to a temp location and install the new file to the correct
				// location

				MsiString strTempFilePath, strTempFileName;
				if((pRecErr = riPath.TempFileName(TEXT("TBD"),0,fTrue,*&strTempFileName, 0)) != 0)
					return FatalError(*pRecErr);

				if((pRecErr = riPath.GetFullFilePath(strTempFileName, *&strTempFilePath)) != 0)
					return FatalError(*pRecErr);

				if((pRecErr = riPath.RemoveFile(strTempFileName)) != 0)
					return FatalError(*pRecErr);

				if(WIN::MoveFile(strFileFullPath, strTempFilePath))
				{
					// successfully moved file - schedule temp file for delete on reboot instead
					strFileFullPath = strTempFilePath;
					fRenameSuccess = true;
				}
				else
				{
					// can't rename file, so the file is in the original spot and will be scheduled to be deleted
					// need to prompt for reboot to a subsequent install won't think file exists when it is
					// really going away after the next reboot - bug 7687

					// NOTE: it is assumed that if fRebootOnRenameFailure is FALSE, we don't care if the file is in use
					// i.e. it has a unique name already like an .rbf file.
					m_fRebootReplace = fTrue;
				}

			}
			
			// bug 8906: on Win9X don't write a delete line to wininit.ini followed by a rename line
			// for the same file, since in some rare cases wininit.ini may be processed twice, and
			// the second time through we would delete files and not replace them
			
			// so, if NT, or we are deleting this file without subsequently replacing
			// then write the wininit.ini delete operation
			// NOTE: if we renamed the file to TBD* above, we won't be replacing the TBD file, so we
			// still schedule a delete for it
			if(g_fWin9X == false || fWillReplace == false || fRenameSuccess == true)
			{
				if(ReplaceFileOnReboot(strFileFullPath,0) == fFalse)
				{
					DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove),*strFileFullPath);
					return iesSuccess;
				}
			}
		}
	}
	return fRemoveFolder ? RemoveFolder(riPath) : iesSuccess;
}

/*---------------------------------------------------------------------------
ixoChangeMedia: verify that the source volume and file are present and
accounted for.
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfChangeMedia(IMsiRecord& riParams)
{
	// set m_pCurrentMediaRec
	m_state.pCurrentMediaRec = &riParams;
	riParams.AddRef();
	m_state.fPendingMediaChange = fTrue;
	m_state.fCompressedSourceVerified = fFalse; // new change media, haven't verified source yet
	m_state.fUncompressedSourceVerified = fFalse; // new change media, haven't verified source yet

	// reset data for last copied file, since this isn't applicable across cabinets
	m_state.strLastFileKey = g_MsiStringNull;
	m_state.strLastFileName = g_MsiStringNull;
	m_state.pLastTargetPath = 0;

	// If there are any file records that were waiting for a media
	// change before being executed, we'll now pull them out and
	// let them fly.

	// ixfFileCopy will use m_pCurrentMediaRec
	m_state.fWaitingForMediaChange = fFalse;
	IMsiRecord* piFileRec;
	while (m_state.fWaitingForMediaChange == fFalse && (piFileRec = PullRecord()) != 0)
	{
		ixoEnum ixoOpCode = (ixoEnum)piFileRec->GetInteger(0);
		iesEnum ies;
		if(ixoOpCode == ixoFileCopy)
			ies = ixfFileCopy(*piFileRec); // Can change fWaitingForMediaChange state
		else if(ixoOpCode == ixoAssemblyCopy)
			ies = ixfAssemblyCopy(*piFileRec);
		else if(ixoOpCode == ixoSetTargetFolder)
			ies = ixfSetTargetFolder(*piFileRec);
		else
		{
			ies = iesFailure;
			Assert(0);
		}
		piFileRec->Release();
		if (ies != iesSuccess)
			return ies;
	}

	return iesSuccess;
}

iesEnum CMsiOpExecute::ResolveMediaRecSourcePath(IMsiRecord& riMediaRec, int iIndex)
{
	// if no path, nothing to resolve
	if(riMediaRec.IsNull(iIndex))
		return iesSuccess;
	
	MsiString strEncodedPath = riMediaRec.GetMsiString(iIndex);
	int cch = 0;
	if((cch = strEncodedPath.Compare(iscStart, szUnresolvedSourceRootTokenWithBS)) != 0)
	{
		strEncodedPath.Remove(iseFirst, cch);

		PMsiPath pSourceRootPath(0);
		int iSourceType = 0;
		iesEnum iesRet = GetSourceRootAndType(*&pSourceRootPath, iSourceType);
		if(iesRet != iesSuccess)
			return iesRet;

		PMsiRecord pError(0);
		PMsiPath pSourcePath(0);
		if((pError = pSourceRootPath->ClonePath(*&pSourcePath)) != 0)
		{
			return FatalError(*pError);
		}

		if((pError = pSourcePath->AppendPiece(*strEncodedPath)) != 0)
		{
			return FatalError(*pError);
		}

		strEncodedPath = pSourcePath->GetPath();
		// remove trailing dirsep since this is a file path
		strEncodedPath.Remove(iseLast, 1);

		AssertNonZero(riMediaRec.SetMsiString(iIndex, *strEncodedPath));
	}

	return iesSuccess;
}

/*---------------------------------------------------------------------------
InitCopier: does 3 things:

	1) verify that source is accessible (if floppy or cd)
	2) creates appropriate copier object if not already created
	3) calls ChangeMedia on copier object if necessary
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::InitCopier(Bool fCabinetCopier, int cbPerTick,
									const IMsiString& ristrFileName,
									IMsiPath* piSourcePath,
									Bool fVerifyMedia) // ristrFileName used for error msgs only
{
	using namespace IxoChangeMedia;

	PMsiRecord pRecErr(0);
	iesEnum iesResult = iesSuccess;
	
	PMsiPath pSourcePath(0);
	MsiString strMediaCabinet;

	if (fVerifyMedia)
	{
		// fVerifyMedia: true if we need to validate the media and call ChangeMedia for the copier object
		fVerifyMedia = (m_state.fPendingMediaChange ||  // have a pending ChangeMedia operation
								(fCabinetCopier && !m_state.fCompressedSourceVerified) ||  // doing compressed copy but compressed source not verified yet
								(!fCabinetCopier && !m_state.fUncompressedSourceVerified)) // doing uncompressed copy but uncompressed source not verified yet
								? fTrue : fFalse;
	}   

	if(fVerifyMedia == fTrue)
	{
		if (m_pUrlCacheCabinet)
		{
			DEBUGMSGV1(TEXT("Clearing cabinet from URL cache: %s"), MsiString(*m_pUrlCacheCabinet->GetFileName()));
			// At most we'll have one cabinet, and the database in the cache.
			delete m_pUrlCacheCabinet;
			m_pUrlCacheCabinet = 0;
		}

		if(m_state.pCurrentMediaRec)
		{
			// there may be unresolved paths to cabinets or packages in the current media record
			// now that we know a file copy will happen, we can fully resolve those paths
			if((iesResult = ResolveMediaRecSourcePath(*(m_state.pCurrentMediaRec), IxoChangeMedia::MediaCabinet)) != iesSuccess)
				return iesResult;

			if((iesResult = ResolveMediaRecSourcePath(*(m_state.pCurrentMediaRec), IxoChangeMedia::ModuleFileName)) != iesSuccess)
				return iesResult;
		}
	
		// ensure that source is accessible

		// m_pCurrentMediaRec may not be set for uncompressed installs (ixoChangeMedia not required)
		if(m_state.pCurrentMediaRec)
		{
			m_state.strMediaLabel = m_state.pCurrentMediaRec->GetString(MediaVolumeLabel);
			m_state.strMediaPrompt = m_state.pCurrentMediaRec->GetString(MediaPrompt);
		}

		// set the source path to verify
		if(!fCabinetCopier)
		{
			if(!piSourcePath)
			{
				// not set - error
				DispatchError(imtError, Imsg(idbgOpSourcePathNotSet), ristrFileName);
				return iesFailure;
			}
			pSourcePath = piSourcePath;
			piSourcePath->AddRef();
		}
		else
		{
			if(!m_state.pCurrentMediaRec)
			{
				// attempting to copy compressed file but ixoChangeMedia never executed
				DispatchError(imtError, Imsg(idbgOpCompressedCopyWithoutCabinet), ristrFileName);
				return iesFailure;
			}
			// cabinet copier
			int iPathIndex;
			ictEnum ictCopierType = (ictEnum)m_state.pCurrentMediaRec->GetInteger(CopierType);
			if(ictCopierType == ictStreamCabinetCopier)
			{
				// source dir is directory containing storage module (database)
				iPathIndex = IxoChangeMedia::ModuleFileName;
			}
			else  // file cabinet
			{
				// source dir is directory containing cabinet
				iPathIndex = IxoChangeMedia::MediaCabinet;
			}
		
			MsiString strFullFilePath = m_state.pCurrentMediaRec->GetMsiString(iPathIndex);


			if (ictCopierType != ictStreamCabinetCopier)
			{
				MsiString pPackagePath;
				Bool fURL = IsURL(strFullFilePath);
				DWORD iStat = ERROR_SUCCESS;

				// IsURL only tells us if it looks like a URL.  DownloadUrlFile does
				// further processing and canonicalization to make sure...
				if (fURL)
				{
					for(;;)
					{
						iStat = DownloadUrlFile((const ICHAR*) strFullFilePath, *&pPackagePath, fURL, 1);

						if (ERROR_SUCCESS == iStat)
						{
							Assert(pPackagePath);
							strFullFilePath = pPackagePath;
							AssertNonZero(m_state.pCurrentMediaRec->SetMsiString(iPathIndex, *strFullFilePath));
							
							m_pUrlCacheCabinet = new CDeleteUrlCacheFileOnClose(*strFullFilePath);
							break;
						}
						else
						{
							// warn user, and retry.
							
							pRecErr = PostError(Imsg(imsgErrorCreateNetPath), *strFullFilePath);
							switch (DispatchMessage(imtEnum(imtError + imtRetryCancel + imtDefault1), *pRecErr, fTrue))
							{
								case imsRetry:
									continue;
								default:
									return iesFailure;
							}
						}
					}
				}
			}

			if(PathType(strFullFilePath) != iptFull)
			{
				DispatchError(imtError, Imsg(idbgOpSourcePathNotSet), ristrFileName);
				return iesFailure;
			}
			MsiString strFileName;

			iesResult = CreateFilePath(strFullFilePath,*&pSourcePath,*&strFileName);
			if (iesResult != iesSuccess)
				return iesResult;

			if(ictCopierType == ictStreamCabinetCopier)
			{
				strMediaCabinet = m_state.pCurrentMediaRec->GetMsiString(IxoChangeMedia::MediaCabinet);
			}
			else
			{
				strMediaCabinet = strFileName;
			}
		}
		
		Assert(pSourcePath);
		m_state.pMediaPath = pSourcePath;
		PMsiVolume pNewVolume(0);
		UINT uiDisk = 0;
		if (m_state.pCurrentMediaRec)
			uiDisk = m_state.pCurrentMediaRec->GetInteger(IxoChangeMedia::IsFirstPhysicalMedia);
		if (!VerifySourceMedia(*m_state.pMediaPath, m_state.strMediaLabel, m_state.strMediaPrompt, uiDisk, *&pNewVolume))
			return iesUserExit;
		if (pNewVolume)
			pSourcePath->SetVolume(*pNewVolume);

		// what source did we just verify?
		if(!fCabinetCopier)
			m_state.fUncompressedSourceVerified = fTrue;
		else
			m_state.fCompressedSourceVerified = fTrue;
	}

	// create appropriate copier object if not already created
	if(fCabinetCopier == fFalse)
	{
		// initialize file copier
		if (m_state.pFileCopier == 0)
		{
			PMsiRecord pRecErr = m_riServices.CreateCopier(ictFileCopier,0,*&(m_state.pFileCopier));
			if (pRecErr)
			{
				Message(imtError, *pRecErr);
				return iesFailure;
			}
		}
		m_state.piCopier = m_state.pFileCopier;
	}
	else
	{
		ictEnum ictCopierType;
		if(!m_state.pCurrentMediaRec ||
			(ictCopierType = (ictEnum)m_state.pCurrentMediaRec->GetInteger(IxoChangeMedia::CopierType)) == ictFileCopier)
		{
			// attempting to copy compressed file but ixoChangeMedia never executed (or does not specify cabinet)
			DispatchError(imtError, Imsg(idbgOpCompressedCopyWithoutCabinet), ristrFileName);
			return iesFailure;
		}
		// initialize cabinet copier if necessary
		MsiString strModuleFileName = m_state.pCurrentMediaRec->GetMsiString(IxoChangeMedia::ModuleFileName);
		MsiString strModuleSubStorageList = m_state.pCurrentMediaRec->GetMsiString(IxoChangeMedia::ModuleSubStorageList);
		if(m_state.pCabinetCopier == 0 || ictCopierType != m_state.ictCabinetCopierType ||
			(ictCopierType == ictStreamCabinetCopier &&
			 (m_state.strMediaModuleFileName.Compare(iscExact,strModuleFileName) == 0 ||
			  m_state.strMediaModuleSubStorageList.Compare(iscExact,strModuleSubStorageList) == 0)))
		{
			Assert(m_state.pCurrentMediaRec);
			Assert(ictCopierType != ictFileCopier);

			PMsiStorage pCabinetStorage(0);
			if(ictCopierType == ictStreamCabinetCopier)
			{
				// need to pass storage object to CreateCopier
				// file should be accessible since we called VerifySourceMedia above

				//!!?? post better error when ModuleFileName is empty string?
				// we are cracking open the storage in order to extract an embedded cabinet

				//
				// SAFER: we need to make sure the package is still valid.  This package is at the source as the embedded cabinets
				//          are stripped from the local cached package.  However, we should limit this check to as few times as
				//          possible, so once will suffice when we open the package for the first time.  If the strModuleFileName is
				//          still the same, no further WVT checks are needed.  But, if strModuleFileName is different, we need to
				//          perform a SAFER check again
				//

				bool fCallSAFER = false;
				if (m_state.strMediaModuleFileName.Compare(iscExact, strModuleFileName) == 0)
				{
					//
					// SAFER: package is new, SAFER check is required
					//

					fCallSAFER = true;
				}

				SAFER_LEVEL_HANDLE hSaferLevel = 0;
				pRecErr = OpenAndValidateMsiStorageRec(strModuleFileName,stIgnore, m_riServices,*&pCabinetStorage,fCallSAFER,strModuleFileName,/* phSaferLevel = */ fCallSAFER ? &hSaferLevel : NULL);
				if (pRecErr)
				{
					Message(imtError, *pRecErr);
					return iesFailure;
				}

				// backward compatibility code, remove when raw stream names no longer supported
				IMsiStorage* piDummy;
				if (pCabinetStorage->ValidateStorageClass(ivscDatabase1)
				 || pCabinetStorage->ValidateStorageClass(ivscPatch1))
					pCabinetStorage->OpenStorage(0, ismRawStreamNames, piDummy);

				MsiString strTempSubStorageList = strModuleSubStorageList;

				while(strTempSubStorageList.TextSize())
				{
					// storage is sub-storage, possible many levels deep
					MsiString strSubStorageName = strTempSubStorageList.Extract(iseUpto, ':');

					IMsiStorage* piParentStorage = pCabinetStorage;
					piParentStorage->AddRef();

					pRecErr = piParentStorage->OpenStorage(strSubStorageName, ismReadOnly, *&pCabinetStorage);

					piParentStorage->Release();
					
					if(pRecErr)
						return FatalError(*pRecErr);

					// backward compatibility code, remove when raw stream names no longer supported
					IMsiStorage* piDummy;
					if (pCabinetStorage->ValidateStorageClass(ivscDatabase1)
					 || pCabinetStorage->ValidateStorageClass(ivscPatch1))
						pCabinetStorage->OpenStorage(0, ismRawStreamNames, piDummy);

					if(strTempSubStorageList.TextSize() != strSubStorageName.TextSize()) // done with list
						strTempSubStorageList.Remove(iseIncluding, ':');
					else
						break;
				}
			}
			
			pRecErr = m_riServices.CreateCopier(ictCopierType,pCabinetStorage,
														   *&m_state.pCabinetCopier);
			if (pRecErr)
			{
				Message(imtError, *pRecErr);
				return iesFailure;
			}
			m_state.ictCabinetCopierType = ictCopierType;
		}
		m_state.piCopier = m_state.pCabinetCopier;
		m_state.strMediaModuleFileName = strModuleFileName;
		m_state.strMediaModuleSubStorageList = strModuleSubStorageList;
	}

	if(fVerifyMedia == fTrue)
	{
		Assert(pSourcePath); // should have been set above for VerifySourceMedia
		Assert(m_state.pMediaPath);
		// call ChangeMedia for copier  
		for (;;)
		{
			// when passing ChangeMedia to a cabinet copier, we might need signature information
			Bool fSignatureRequired = (m_state.pCurrentMediaRec->GetInteger(IxoChangeMedia::SignatureRequired) == 1) ? fTrue : fFalse;
			PMsiStream pCertificate(const_cast<IMsiStream*>(static_cast<const IMsiStream *>(m_state.pCurrentMediaRec->GetMsiData(IxoChangeMedia::SignatureCert))));
			PMsiStream pHash(const_cast<IMsiStream*>(static_cast<const IMsiStream *>(m_state.pCurrentMediaRec->GetMsiData(IxoChangeMedia::SignatureHash))));

			// doesn't do anything for file copier
			pRecErr = m_state.piCopier->ChangeMedia(*pSourcePath, strMediaCabinet, fSignatureRequired, pCertificate, pHash);
			if (pRecErr)
			{
				int iError = pRecErr->GetInteger(1);
				if (iError == idbgDriveNotReady)
				{
					Assert(m_state.strMediaLabel.TextSize() > 0);
					Assert(m_state.strMediaPrompt.TextSize() > 0);
					PMsiVolume pNewVolume(0);
					UINT uiDisk = 0;
					if (m_state.pCurrentMediaRec)
						uiDisk = m_state.pCurrentMediaRec->GetInteger(IxoChangeMedia::IsFirstPhysicalMedia);

					if (!VerifySourceMedia(*m_state.pMediaPath, m_state.strMediaLabel,m_state.strMediaPrompt, uiDisk, *&pNewVolume))
						return iesUserExit;
					else
						continue;
				}
				else
				{
					// if error is imsgCABSignatureRejected or imsgCABSignatureMissing, simply FAIL -- there is nothing the user can do and we don't
					//  want to spin on a retry
					imtEnum imtMsg = (iError == imsgCABSignatureRejected || iError == imsgCABSignatureMissing) ? imtEnum(imtError + imtOk + imtDefault1) : imtEnum(imtError + imtRetryCancel + imtDefault1);
					switch (DispatchMessage(imtMsg, *pRecErr, fTrue))
					{
					case imsRetry: continue;
					default: return iesFailure;
					};
				}
			}
			break;
		}

	}
	
	m_state.fPendingMediaChange = fFalse;
	Assert(m_state.piCopier);
	int iRemainder = m_state.piCopier->SetNotification(0, 0);
	m_state.piCopier->SetNotification(cbPerTick, iRemainder);

	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixoSetCompanionParent: Indicates that the installation state of the next
file to (potentially) be copied by ixoFileCopy should be determined by
the install state of a 'companion parent' - i.e. the filename and version
of a parent file.  ixoSetCompanionParent sets the file path, name, and
version of the parent.
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSetCompanionParent(IMsiRecord& riParams)
{
	using namespace IxoSetCompanionParent;
	PMsiRecord pRecErr = m_riServices.CreatePath(riParams.GetString(ParentPath),
		*&(m_state.pParentPath));
	if (pRecErr)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}
	m_state.strParentFileName = riParams.GetMsiString(ParentName);
	m_state.strParentVersion = riParams.GetMsiString(ParentVersion);
	m_state.strParentLanguage = riParams.GetMsiString(ParentLanguage);
	return iesSuccess;
}


void CMsiOpExecute::PushRecord(IMsiRecord& riParams)
/*---------------------------------------------------------------------------
Stores the given record on the first-in, first-out stack.
---------------------------------------------------------------------------*/
{
	Assert(m_iWriteFIFO < MAX_RECORD_STACK_SIZE);
	if (m_iWriteFIFO < MAX_RECORD_STACK_SIZE)
	{
		m_piStackRec[m_iWriteFIFO++] = &riParams;
		riParams.AddRef();
	}
}

void CMsiOpExecute::InsertTopRecord(IMsiRecord& riParams)
/*---------------------------------------------------------------------------
Stores the given record as the next record to Pull on the first-in, first-out stack.
---------------------------------------------------------------------------*/
{
	Assert(m_iWriteFIFO < MAX_RECORD_STACK_SIZE);
	if (m_iWriteFIFO >= MAX_RECORD_STACK_SIZE)
		return;
		
	int iInsert = 0;
	if (m_iWriteFIFO == 0)
		m_iWriteFIFO++;
	else if (m_iReadFIFO > 0)
		iInsert = --m_iReadFIFO;
	else
	{
		Assert(fFalse);
		int i;
		for (i = m_iWriteFIFO; i > 0 ; i--)
			m_piStackRec[i] = m_piStackRec[i - 1];
		m_iWriteFIFO++;
	}

	m_piStackRec[iInsert] = &riParams;
	riParams.AddRef();
}


IMsiRecord* CMsiOpExecute::PullRecord()
/*---------------------------------------------------------------------------
Pulls a record out of the first-in, first-out stack.
---------------------------------------------------------------------------*/
{
	if (m_iWriteFIFO > m_iReadFIFO)
	{
		int iReadFIFO = m_iReadFIFO++;
		if (m_iReadFIFO == m_iWriteFIFO)
			m_iReadFIFO = m_iWriteFIFO = 0;

		return m_piStackRec[iReadFIFO];
	}
	return 0;
}

imsEnum CMsiOpExecute::ShowFileErrorDialog(IErrorCode err,const IMsiString& riFullPathString,Bool fVital)
/*---------------------------------------------------------------------------
Displays an error dialog based on the code passed in the err parameter. The
string passed in riFullPathString will replace the [2] parameter within the
error string.  If fVital is fTrue, the 'Ignore' button in the dialog will
be suppressed.

Returns: imsEnum value specifying the button pressed by the user.
---------------------------------------------------------------------------*/
{
	PMsiRecord pRecErr = &m_riServices.CreateRecord(2);
	ISetErrorCode(pRecErr, err);
	pRecErr->SetMsiString(2, riFullPathString);

	imtEnum imtButtons = fVital ? imtRetryCancel : imtAbortRetryIgnore;
	return DispatchMessage(imtEnum(imtError+imtButtons+imtDefault1), *pRecErr, fTrue);
}

IMsiRecord* CMsiOpExecute::CacheFileState(const IMsiString& ristrFilePath,
														icfsEnum* picfsState,
														const IMsiString* pistrTempLocation,
														const IMsiString* pistrVersion,
														int* pcRemainingPatches,
														int* pcRemainingPatchesToSkip)
{
	IMsiRecord* piError = 0;
	if(!m_pDatabase)
	{
		piError = m_riServices.CreateDatabase(0,idoCreate,*&m_pDatabase);
		if(piError)
			return piError;
	}

	if(!m_pFileCacheTable)
	{
		MsiString strTableName = m_pDatabase->CreateTempTableName();
		piError = m_pDatabase->CreateTable(*strTableName,0,*&m_pFileCacheTable);
		if(piError)
			return piError;

		MsiString strNull;
		m_colFileCacheFilePath     = m_pFileCacheTable->CreateColumn(icdPrimaryKey + icdString + icdTemporary,*strNull);
		m_colFileCacheState        = m_pFileCacheTable->CreateColumn(icdLong + icdTemporary + icdNullable,*strNull);
		m_colFileCacheTempLocation = m_pFileCacheTable->CreateColumn(icdString + icdTemporary + icdNullable,*strNull);
		m_colFileCacheVersion      = m_pFileCacheTable->CreateColumn(icdString + icdTemporary + icdNullable,*strNull);
		m_colFileCacheRemainingPatches = m_pFileCacheTable->CreateColumn(icdLong + icdTemporary + icdNullable,*strNull);
		m_colFileCacheRemainingPatchesToSkip = m_pFileCacheTable->CreateColumn(icdLong + icdTemporary + icdNullable,*strNull);

		Assert(m_colFileCacheFilePath && m_colFileCacheState && m_colFileCacheTempLocation && m_colFileCacheVersion && m_colFileCacheRemainingPatches && m_colFileCacheRemainingPatchesToSkip);

		m_pFileCacheCursor = m_pFileCacheTable->CreateCursor(fFalse);
		m_pFileCacheCursor->SetFilter(iColumnBit(m_colFileCacheFilePath)); // permanent setting, effects get but no put
	}

	MsiString strFilePath;
	ristrFilePath.LowerCase(*&strFilePath);
	m_pFileCacheCursor->Reset();
	AssertNonZero(m_pFileCacheCursor->PutString(m_colFileCacheFilePath,*strFilePath));
	int iNext = m_pFileCacheCursor->Next();
	if(!iNext)
		AssertNonZero(m_pFileCacheCursor->PutString(m_colFileCacheFilePath,*strFilePath));

	if(picfsState)
		AssertNonZero(m_pFileCacheCursor->PutInteger(m_colFileCacheState,(int)*picfsState));
	if(pistrTempLocation)
		AssertNonZero(m_pFileCacheCursor->PutString(m_colFileCacheTempLocation,*pistrTempLocation));
	if(pistrVersion)
		AssertNonZero(m_pFileCacheCursor->PutString(m_colFileCacheVersion,*pistrVersion));
	if(pcRemainingPatches)
		AssertNonZero(m_pFileCacheCursor->PutInteger(m_colFileCacheRemainingPatches,(int)*pcRemainingPatches));
	if(pcRemainingPatchesToSkip)
		AssertNonZero(m_pFileCacheCursor->PutInteger(m_colFileCacheRemainingPatchesToSkip,(int)*pcRemainingPatchesToSkip));

	if(iNext)
		// primary key exists, need to update
		AssertNonZero(m_pFileCacheCursor->Update());
	else
		// primary key doesn't exist, need to insert
		AssertNonZero(m_pFileCacheCursor->InsertTemporary());

	return 0;
}

// fn: create a temporary table to manage the assemblies creation/ removal for this session
IMsiRecord* CMsiOpExecute::CreateAssemblyCacheTable()
{
	IMsiRecord* piError = 0;

	if(m_pAssemblyCacheTable)
		return 0;// table already created

	if(!m_pDatabase)
	{
		// create temp database
		piError = m_riServices.CreateDatabase(0,idoCreate,*&m_pDatabase);
		if(piError)
			return piError;
	}

	MsiString strTableName = m_pDatabase->CreateTempTableName();
	piError = m_pDatabase->CreateTable(*strTableName,0,*&m_pAssemblyCacheTable);
	if(piError)
		return piError;

	// table has 4 columns
	//1 = component id
	//2 = assembly name
	//3 = manifest file
	//4 = column to store IAssemblyCacheItem object

	MsiString strNull;
	m_colAssemblyMappingComponentId = m_pAssemblyCacheTable->CreateColumn(icdPrimaryKey + icdString + icdTemporary, *strNull);
	m_colAssemblyMappingAssemblyName= m_pAssemblyCacheTable->CreateColumn(icdString + icdTemporary, *strNull);
	m_colAssemblyMappingAssemblyType = m_pAssemblyCacheTable->CreateColumn(icdShort  + icdTemporary, *strNull);
	m_colAssemblyMappingASM         = m_pAssemblyCacheTable->CreateColumn(icdObject + icdTemporary + icdNullable, *strNull);
	Assert(m_colAssemblyMappingComponentId && m_colAssemblyMappingAssemblyName  && m_colAssemblyMappingAssemblyType && m_colAssemblyMappingASM);

	return 0;
}

IMsiRecord* CMsiOpExecute::CacheAssemblyMapping(const IMsiString& ristrComponentId,
												const IMsiString& ristrAssemblyName,
												iatAssemblyType iatType)
{
	IMsiRecord* piError;
	piError = CreateAssemblyCacheTable();
	if(piError)
		return piError;

	Assert(m_pAssemblyCacheTable);

	PMsiCursor pCacheCursor = m_pAssemblyCacheTable->CreateCursor(fFalse);

	// cache the entries
	AssertNonZero(pCacheCursor->PutString(m_colAssemblyMappingComponentId, ristrComponentId));
	AssertNonZero(pCacheCursor->PutString(m_colAssemblyMappingAssemblyName,ristrAssemblyName));
	AssertNonZero(pCacheCursor->PutInteger(m_colAssemblyMappingAssemblyType, (int)iatType));	
	AssertNonZero(pCacheCursor->Insert());
	return 0;
}

iesEnum CMsiOpExecute::ixfAssemblyMapping(IMsiRecord& riParams)
{
	using namespace IxoAssemblyMapping;
	PMsiRecord pErr = CacheAssemblyMapping(*MsiString(riParams.GetMsiString(IxoAssemblyMapping::ComponentId)), *MsiString(riParams.GetMsiString(IxoAssemblyMapping::AssemblyName)), (iatAssemblyType) riParams.GetInteger(IxoAssemblyMapping::AssemblyType));
	if(pErr)
		return FatalError(*pErr);
	return iesSuccess;
}


IMsiRecord* CMsiOpExecute::CreateTableForAssembliesToUninstall()
{
	IMsiRecord* piError = 0;

	if(m_pAssemblyUninstallTable)
		return 0;// table already created

	if(!m_pDatabase)
	{
		// create temp database
		piError = m_riServices.CreateDatabase(0,idoCreate,*&m_pDatabase);
		if(piError)
			return piError;
	}

	MsiString strTableName = m_pDatabase->CreateTempTableName();
	piError = m_pDatabase->CreateTable(*strTableName,0,*&m_pAssemblyUninstallTable);
	if(piError)
		return piError;

	// table has 2 columns
	//1 = component id
	//2 = assembly name

	MsiString strNull;

	m_colAssemblyUninstallComponentId  = m_pAssemblyUninstallTable->CreateColumn(icdPrimaryKey + icdString + icdTemporary, *strNull);
	m_colAssemblyUninstallAssemblyName = m_pAssemblyUninstallTable->CreateColumn(icdString + icdTemporary, *strNull);
	m_colAssemblyUninstallAssemblyType = m_pAssemblyUninstallTable->CreateColumn(icdShort + icdTemporary, *strNull);

	Assert(m_colAssemblyUninstallComponentId  && m_colAssemblyUninstallAssemblyName && m_colAssemblyUninstallAssemblyType);
	return 0;

}

IMsiRecord* CMsiOpExecute::CacheAssemblyForUninstalling(const IMsiString& ristrComponentId, const IMsiString& ristrAssemblyName, iatAssemblyType iatAT)
{
	IMsiRecord* piError;
	piError = CreateTableForAssembliesToUninstall();
	if(piError)
		return piError;

	Assert(m_pAssemblyUninstallTable);

	PMsiCursor pCacheCursor = m_pAssemblyUninstallTable->CreateCursor(fFalse);

	// cache the entries
	AssertNonZero(pCacheCursor->PutString(m_colAssemblyUninstallComponentId, ristrComponentId));
	AssertNonZero(pCacheCursor->PutString(m_colAssemblyUninstallAssemblyName, ristrAssemblyName));
	AssertNonZero(pCacheCursor->PutInteger(m_colAssemblyUninstallAssemblyType, (int)iatAT));	
	AssertNonZero(pCacheCursor->Insert());
	return 0;
}



//fn: Gets info for a particular assembly as to whether it is installed
IMsiRecord*   CMsiOpExecute::IsAssemblyInstalled(const IMsiString& rstrComponentId, const IMsiString& ristrAssemblyName, iatAssemblyType iatAT, bool& rfInstalled, IAssemblyCache** ppIAssemblyCache, IAssemblyName** ppIAssemblyName)
{
	// create the assembly name object
	PAssemblyName pAssemblyName(0);
	LPCOLESTR szAssemblyName;
#ifndef UNICODE
	CTempBuffer<WCHAR, MAX_PATH>  rgchAssemblyName;
	ConvertMultiSzToWideChar(ristrAssemblyName, rgchAssemblyName);
	szAssemblyName = rgchAssemblyName;
#else
	szAssemblyName = ristrAssemblyName.GetString();
#endif
	HRESULT hr;
	if(iatAT == iatURTAssembly)
	{
		hr = FUSION::CreateAssemblyNameObject(&pAssemblyName, szAssemblyName, CANOF_PARSE_DISPLAY_NAME, 0);
	}
	else
	{
		Assert(iatAT == iatWin32Assembly);
		hr = SXS::CreateAssemblyNameObject(&pAssemblyName, szAssemblyName, CANOF_PARSE_DISPLAY_NAME, 0);
	}
	if(!SUCCEEDED(hr))
		return PostAssemblyError(rstrComponentId.GetString(), hr, TEXT(""), TEXT("CreateAssemblyNameObject"), ristrAssemblyName.GetString(), iatAT);

	// create the assembly interface
	PAssemblyCache pCache(0);
	if(iatAT == iatURTAssembly)
	{
		hr = FUSION::CreateAssemblyCache(&pCache, 0); 
	}
	else
	{
		Assert(iatAT == iatWin32Assembly);
		hr = SXS::CreateAssemblyCache(&pCache, 0); 
	}
	if(!SUCCEEDED(hr))
		return PostAssemblyError(rstrComponentId.GetString(), hr, TEXT(""), TEXT("CreateAssemblyCache"), ristrAssemblyName.GetString(), iatAT);

	hr = pCache->QueryAssemblyInfo(0, szAssemblyName, NULL);
	if(SUCCEEDED(hr))
		rfInstalled = true;
	else
		rfInstalled = false;

	// check if we need to return the interfaces we have created
	if(ppIAssemblyCache)
	{
		*ppIAssemblyCache = pCache;
		(*ppIAssemblyCache)->AddRef();
	}
	if(ppIAssemblyName)
	{
		*ppIAssemblyName = pAssemblyName;
		(*ppIAssemblyName)->AddRef();
	}
	return 0;
}

//fn: uninstalls the assembly for the WI
IMsiRecord* CMsiOpExecute::UninstallAssembly(const IMsiString& rstrComponentId, const IMsiString& ristrAssemblyName, iatAssemblyType iatAT)
{
	PAssemblyCache pCache(0);
	HRESULT hr=S_OK;

	LPCOLESTR szAssemblyName;
#ifndef UNICODE
	CTempBuffer<WCHAR, MAX_PATH>  rgchAssemblyName;
	ConvertMultiSzToWideChar(ristrAssemblyName, rgchAssemblyName);
	szAssemblyName = rgchAssemblyName;
#else
	szAssemblyName = ristrAssemblyName.GetString();
#endif

	if(iatAT == iatURTAssembly)
		hr = FUSION::CreateAssemblyCache(&pCache, 0);
	else
	{
		Assert(iatAT == iatWin32Assembly);
		hr = SXS::CreateAssemblyCache(&pCache, 0);
	}

	if(!SUCCEEDED(hr))
	{
		return PostAssemblyError(rstrComponentId.GetString(), hr, TEXT(""), TEXT("CreateAssemblyCache"), ristrAssemblyName.GetString(), iatAT);
	}
  	hr = pCache->UninstallAssembly(0, szAssemblyName, NULL, NULL);
	if(!SUCCEEDED(hr))
	{
		return PostAssemblyError(rstrComponentId.GetString(), hr, TEXT("IAssemblyCache"), TEXT("UninstallAssembly"), ristrAssemblyName.GetString(), iatAT);
	}
    	return 0;
}


Bool CMsiOpExecute::GetFileState(const IMsiString& ristrFilePath,
											icfsEnum* picfsState,
											const IMsiString** ppistrTempLocation,
											int* pcPatchesRemaining,
											int* pcPatchesRemainingToSkip)
{
	if(!m_pFileCacheCursor)
		return fFalse;

	MsiString strFilePath;
	ristrFilePath.LowerCase(*&strFilePath);
	m_pFileCacheCursor->Reset();
	AssertNonZero(m_pFileCacheCursor->PutString(m_colFileCacheFilePath,*strFilePath));
	if(!m_pFileCacheCursor->Next())
		return fFalse;

	if(picfsState)
		*picfsState = (icfsEnum)m_pFileCacheCursor->GetInteger(m_colFileCacheState);

	if(ppistrTempLocation)
		*ppistrTempLocation = &m_pFileCacheCursor->GetString(m_colFileCacheTempLocation);

	if(pcPatchesRemaining)
	{
		*pcPatchesRemaining = m_pFileCacheCursor->GetInteger(m_colFileCacheRemainingPatches);
		if(*pcPatchesRemaining == iMsiNullInteger)
			*pcPatchesRemaining = 0;
	}
	
	if(pcPatchesRemainingToSkip)
	{
		*pcPatchesRemainingToSkip = m_pFileCacheCursor->GetInteger(m_colFileCacheRemainingPatchesToSkip);
		if(*pcPatchesRemainingToSkip == iMsiNullInteger)
			*pcPatchesRemainingToSkip = 0;
	}

	return fTrue;
}

/*---------------------------------------------------------------------------
ixoFileCopy: Copy a file from source to target (depends upon the internal
state previously set up by preceding actions).
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfFileCopy(IMsiRecord& riParams)
{
	using namespace IxoFileCopy;

	// If the cabinet copier notified us that a media change is required,
	// we must defer any file copy requests until a media change is executed.
	if (m_state.fWaitingForMediaChange)
	{
		PushRecord(riParams);
		return iesSuccess;
	}

	int fInstallModeFlags = riParams.GetInteger(InstallMode);
	ielfEnum ielfCurrentElevateFlags = riParams.IsNull(ElevateFlags) ? ielfNoElevate :
												  (ielfEnum)riParams.GetInteger(ElevateFlags);

	if (fInstallModeFlags & icmRunFromSource)
	{
		//!! Log RunFromSource install state, as soon as we decide how
		/*IMsiRecord& riLogRec = GetSharedRecord(3);
		ISetErrorCode(&riLogRec, Imsg(imsgLogFileRunFromSource));
		AssertNonZero(riLogRec.SetMsiString(1,strDestName)));
		Message(imtInfo,riLogRec);*/
		return iesSuccess;
	}

	PMsiRecord pRecErr(0);
	PMsiPath pTargetPath(0);
	MsiString strDestPath = riParams.GetMsiString(DestName);
	MsiString strDestName;
	
	// check if files are full or relative paths
	if(ENG::PathType(strDestPath) == iptFull)
	{
			iesEnum iesResult = CreateFilePath(strDestPath,*&pTargetPath,*&strDestName);
			if (iesResult != iesSuccess)
				return iesResult;

		AssertNonZero(riParams.SetMsiString(DestName, *strDestName)); // replace full path with file name
	}
	else
	{
		pTargetPath = m_state.pTargetPath;
		strDestName = strDestPath;
	}

	if(!pTargetPath)
	{  // must not have called ixoSetTargetFolder
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixoFileCopy")));
		return iesFailure;
	}
	
	// target name and path may be redirected below, but we want the action data message to contain
	// the original file information, so we'll store that away here
	MsiString strActionDataDestName = strDestName;
	MsiString strActionDataDestPath = pTargetPath->GetPath();

	iesEnum iesRet = iesNoAction;
#ifdef DEBUG
	ICHAR rgchDestName[256];
	strDestName.CopyToBuf(rgchDestName,255);
#endif
	if(!strDestName.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpInvalidParam),
						  MsiString(*TEXT("ixoFileCopy")),(int)DestName);
		return iesFailure;
	}

	// STEP 1: version check existing file
	
	// If we're in the middle of copying a split file, we know the install verification
	// state has already been determined - don't want to check it again (especially since
	// the partial new file is now sitting in the dest directory!).

	Bool fShouldInstall = fFalse;

	static iehEnum s_iehErrorMode = iehShowNonIgnorableError;
	if (m_state.fSplitFileInProgress)
	{
		fShouldInstall = fTrue;
	}
	else
	{
		MsiString strVersion(riParams.GetMsiString(Version));
		MsiString strLanguage(riParams.GetMsiString(Language));
		MsiString strTargetFullPath;
		if((pRecErr = pTargetPath->GetFullFilePath(strDestName,*&strTargetFullPath)) != 0)
			return FatalError(*pRecErr);

		ifsEnum ifsState;
		int fBitVersioning;
		Bool fCompanionFile = fFalse;
		Bool fCompanionFileHashOverride = fFalse;
		MsiString strLogParentFileName;

		MD5Hash hHash;
		MD5Hash* pHash = 0;
		if(riParams.IsNull(HashOptions) == fFalse)
		{
			hHash.dwFileSize = riParams.GetInteger(FileSize);
			hHash.dwPart1    = riParams.GetInteger(HashPart1);
			hHash.dwPart2    = riParams.GetInteger(HashPart2);
			hHash.dwPart3    = riParams.GetInteger(HashPart3);
			hHash.dwPart4    = riParams.GetInteger(HashPart4);

			pHash = &hHash;
		}

		// If a CompanionParent has been set up for this file, we'll use that parent's
		// name and version for our InstallState verification check.
		for (;;)
		{
			if (m_state.strParentFileName.TextSize())
			{
				fCompanionFile = fTrue;
				pRecErr = m_state.pParentPath->GetCompanionFileInstallState(*(m_state.strParentFileName),
																					*(m_state.strParentVersion),
																					*(m_state.strParentLanguage),
																					*pTargetPath,
																					*strDestName,
																					pHash,
																					ifsState,fShouldInstall,0,0,fInstallModeFlags,
																					&fBitVersioning);
				strLogParentFileName = m_state.strParentFileName;
				m_state.strParentFileName = TEXT("");
				m_state.strParentVersion = TEXT("");
				m_state.strParentLanguage = TEXT("");

			}
			else
			{
				pRecErr = pTargetPath->GetFileInstallState(*strDestName,*strVersion,*strLanguage,pHash,ifsState,
																		 fShouldInstall,0,0,fInstallModeFlags,&fBitVersioning);
			}
			if (pRecErr)
			{
				if (pRecErr->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
				{
					Message(imtError, *pRecErr);
					return iesFailure;
				}
			}

			// We've got 3 potential modes if/when an error occurs:
			// - if our source file is unversioned, is NOT a companion file, and there's an existing
			//   version of the file at the destination, AND the reinstall mode doesn't specify that all
			//   files must be replaced, then we'll silently ignore the error, and go on.
			// - Otherwise, we go by the fVital flag to determine whether an ignore button appears on
			//   the resulting error dialog
			Bool fVital = riParams.GetInteger(Attributes) & msidbFileAttributesVital ? fTrue : fFalse;
			if (!(fBitVersioning & ifBitNewVersioned) && !fCompanionFile && (ifsState & ifsBitExisting) && ifsState != ifsExistingAlwaysOverwrite)
				s_iehErrorMode = iehSilentlyIgnoreError;
			else
				s_iehErrorMode = fVital ? iehShowNonIgnorableError : iehShowIgnorableError;

			if (ifsState == ifsExistingFileInUse)
			{
				MsiString strFullPath;
				if (m_state.strParentFileName.TextSize())
					m_state.pParentPath->GetFullFilePath(m_state.strParentFileName,*&strFullPath); //!! error record leak
				else
					strFullPath = strTargetFullPath;

				if (s_iehErrorMode == iehSilentlyIgnoreError)
				{
					// Just log the error and go on
					DispatchError(imtInfo, Imsg(imsgSharingViolation), *strFullPath);
					return (iesEnum) iesErrorIgnored;
				}

				switch (ShowFileErrorDialog(Imsg(imsgSharingViolation),*strFullPath,fVital))
				{
				case imsIgnore:
					return (iesEnum) iesErrorIgnored;
				case imsRetry:
					continue;
				default:  // imsCancel
					return iesFailure;
				};
			}
			else
				break;
		}

		int iCachedState = 0;
		if (fShouldInstall)
		{
			AssertSz(!(!g_fWin9X && g_iMajorVersion >= 5) || g_MessageContext.m_hSfcHandle,
						g_szNoSFCMessage);
			BOOL fProtected = false;
			if ( g_MessageContext.m_hSfcHandle && !(ielfCurrentElevateFlags & ielfBypassSFC))
				fProtected = SFC::SfcIsFileProtected(g_MessageContext.m_hSfcHandle, CConvertString(strTargetFullPath));
			if (fProtected)
			{
				iCachedState |= icfsProtected;

				MsiString strProtectedVersion;
				PMsiRecord(pTargetPath->GetFileVersionString(strDestName, *&strProtectedVersion));
				if (ifsState == ifsExistingEqualVersion || ifsState == ifsExistingNewerVersion ||
					ifsState == ifsExistingAlwaysOverwrite)
				{
					DEBUGMSG3(TEXT("The Installer did not reinstall the file %s, because it is protected by Windows. ")
						TEXT("Either the existing file is an equal or greater version, or the installer was requested ")
						TEXT("to re-install all files regardless of version.  Package version: %s, ")
						TEXT("existing version: %s"), strTargetFullPath, strVersion, strProtectedVersion);
				}
				else if (ifsState & ifsBitExisting)
				{
					imtEnum imtButtons = imtEnum(imtError + imtOkCancel);
					imsEnum imsResponse = DispatchError(imtButtons, Imsg(imsgCannotUpdateProtectedFile), *strTargetFullPath,
														*strVersion, *strProtectedVersion);
					if (imsResponse == imsCancel)
						return iesFailure;
				}
				else
				{
					// set bit for use by ixfInstallProtectedFiles
					iCachedState |= icfsProtectedInstalledBySFC;
				}

				pRecErr = CacheFileState(*strTargetFullPath,(icfsEnum*)&iCachedState,
												 0, strVersion, 0, 0);
				if(pRecErr)
					return FatalError(*pRecErr);

				return iesSuccess;
			}
		}

		// if this file is to be patched (patch headers have been passed in riParams)
		// then test the patches
		Bool fShouldPatch = fFalse;
		bool fPatches = (!riParams.IsNull(TotalPatches) && riParams.GetInteger(TotalPatches) > 0) ? true : false;
		int cPatchesToSkip = 0;
		if(fShouldInstall && fPatches)
		{
			if(FFileExists(*pTargetPath,*strDestName))
			{
			
				icpEnum icpPatchTest;
				int iPatchIndex = 0;
				if((iesRet = TestPatchHeaders(*pTargetPath, *strDestName, riParams, icpPatchTest, iPatchIndex)) != iesSuccess)
					return iesRet;

				if(icpPatchTest == icpCanPatch || icpPatchTest == icpUpToDate)
				{
					// file can already be patched, so don't need to install file
					fShouldInstall = fFalse;
					fShouldPatch = icpPatchTest == icpCanPatch ? fTrue : fFalse;

					cPatchesToSkip = iPatchIndex - 1; // iPatchIndex is the index of the first patch that could be applied
																 // properly to this file.  so we need to skip the patches that come
																 // before it.
				}
				else if(icpPatchTest == icpCannotPatch)
				{
					// can't patch the file as it stands
					// but fShouldInstall is true so we'll recopy the source file first which should be patchable
					fShouldPatch = fTrue;

					cPatchesToSkip = 0; // need to copy source file and apply all patches
				}
				else
				{
					AssertSz(0, "Invalid return from TestPatchHeaders()");
				}
			}
			else
			{
				fShouldPatch = fTrue;
			}
		}

		// If in verbose mode, log the results of file version checking
		if (FDiagnosticModeSet(dmVerboseDebugOutput|dmVerboseLogging))
		{
			enum iverEnum
			{
				iverAbsent = 0,
				iverExistingLower,
				iverExistingEqual,
				iverExistingNewer,
				iverExistingCorrupt,
				iverOverwriteAll,
				iverNewVersioned,
				iverOldVersioned,
				iverOldUnmodifiedHashMatch,
				iverOldModified,
				iverExistingLangSubset,
				iverOldUnmodifiedHashMismatch,
				iverOldUnmodifiedNoHash,
				iverUnknown,
				iverNextEnum
			};
			const ICHAR szVer[][96] = {TEXT("No existing file"),
								  TEXT("Existing file is a lower version"),
								  TEXT("Existing file is of an equal version"),
								  TEXT("Existing file has a newer version"),
								  TEXT("Existing file is corrupt (invalid checksum)"),
								  TEXT("REINSTALLMODE specifies all files to be overwritten"),
								  TEXT("New file versioned - existing file unversioned"),
								  TEXT("New file unversioned - existing file versioned"),
								  TEXT("Existing file is unversioned and unmodified - hash matches source file"),
								  TEXT("Existing file is unversioned but modified"),
								  TEXT("New file supports language(s) the existing file doesn't support"),
								  TEXT("Existing file is unversioned and unmodified - hash doesn't match source file"),
								  TEXT("Existing file is unversioned and unmodified - no source file hash provided to compare"),
								  TEXT("")};

			enum iomEnum
			{
				iomInstall = 0,
				iomNoOverwrite,
				iomOverwrite,
				iomNextEnum
			};
			const ICHAR szOverwrite[][20] = {TEXT("To be installed"),
											 TEXT("Won't Overwrite"),
											 TEXT("Overwrite")};
			enum ipmEnum
			{
				ipmNoPatch = 0,
				ipmWillPatch,
				ipmWontPatch,
				ipmNextEnum
			};
			const ICHAR szPatchMsg[][20] = {TEXT("No patch"),
													  TEXT("Will patch"),
													  TEXT("Won't patch")};

			const ICHAR szCompanion[] = TEXT("  (Checked using version of companion: %s)");

			iverEnum iver = iverUnknown;
			if (ifsState == ifsAbsent)
				iver = iverAbsent;
			else if (ifsState == ifsExistingAlwaysOverwrite)
				iver = iverOverwriteAll;
			else if ((fBitVersioning & ifBitNewVersioned) && !(fBitVersioning & ifBitExistingVersioned))
				iver = iverNewVersioned;
			else if (!(fBitVersioning & ifBitNewVersioned) && (fBitVersioning & ifBitExistingVersioned))
				iver = iverOldVersioned;
			else if (!(fBitVersioning & ifBitNewVersioned) && !(fBitVersioning & ifBitExistingVersioned))
			{
				// both files unversioned
				if(ifsState == ifsExistingEqualVersion)
				{
					Assert((fBitVersioning & ifBitExistingModified) == 0);
					iver = iverOldUnmodifiedHashMatch;					
				}
				else if(ifsState == ifsExistingLowerVersion)
				{
					Assert((fBitVersioning & ifBitExistingModified) == 0);
					if(fBitVersioning & ifBitUnversionedHashMismatch)
						iver = iverOldUnmodifiedHashMismatch;
					else
						iver = iverOldUnmodifiedNoHash;
				}
				else if(ifsState == ifsExistingNewerVersion)
				{
					Assert((fBitVersioning & ifBitExistingModified));
					iver = iverOldModified;
				}
			}
			else
			{
				// both files versioned
				Assert((fBitVersioning & ifBitNewVersioned) && (fBitVersioning & ifBitExistingVersioned));
				
				if (fBitVersioning & ifBitExistingLangSubset)
					iver = iverExistingLangSubset;
				else
				{
					switch (ifsState)
					{
						case ifsExistingLowerVersion:  iver = iverExistingLower;break;
						case ifsExistingEqualVersion:  iver = iverExistingEqual;break;
						case ifsExistingNewerVersion:  iver = iverExistingNewer;break;
						case ifsExistingCorrupt:       iver = iverExistingCorrupt;break;
						default:Assert(0);iver = iverUnknown;break;
					}
				}
			}
			ICHAR rgchCompanion[MAX_PATH];
			rgchCompanion[0] = 0;
			if (fCompanionFile && iver != iverAbsent && iver != iverOverwriteAll)
			{
				MsiString strCompanionFullPath;
				if((pRecErr = m_state.pParentPath->GetFullFilePath(strLogParentFileName,*&strCompanionFullPath)) != 0)
					return FatalError(*pRecErr);
				if (strCompanionFullPath.TextSize() + IStrLen(szCompanion) < MAX_PATH)
					wsprintf(rgchCompanion,szCompanion,(const ICHAR*) strCompanionFullPath);

			}
			iomEnum iomOverwriteMode = iomInstall;
			if (iver != iverAbsent)
				iomOverwriteMode = fShouldInstall ? iomOverwrite : iomNoOverwrite;
			ipmEnum ipmPatchMode = ipmNoPatch;
			if (fPatches)
				ipmPatchMode = fShouldPatch ? ipmWillPatch : ipmWontPatch;
			DEBUGMSG5(TEXT("File: %s;  %s;  %s;  %s%s"), (const ICHAR*) strTargetFullPath,
						  szOverwrite[iomOverwriteMode],
						  szPatchMsg[ipmPatchMode],
						  szVer[iver],rgchCompanion);
		}

		if(!fShouldInstall)
			iCachedState |= icfsFileNotInstalled;


		MsiString strTempFileFullPathForPatch;
		if(fShouldPatch)
		{
			iCachedState |= icfsPatchFile;

			if(fShouldInstall)
			{
				// we are copying a file that will be subsequently patched
				// we will delay overwriting the existing file until we have a fully patched file
				// this is done by copying the file to a temp location (\config.msi folder, random name)
				// and patching that file.  the patch opcode will then copy the patched file to the
				// correct name

				PMsiPath pTempFolder(0);
				if((iesRet = GetBackupFolder(pTargetPath, *&pTempFolder)) != iesSuccess)
					return iesRet;

				MsiString strTempFileNameForPatch;

				{ // scope elevation
					CElevate elevate; // elevate to create temp file on secure temp folder
					if((pRecErr = pTempFolder->TempFileName(TEXT("PT"),0,fTrue,*&strTempFileNameForPatch, 0)) != 0)
						return FatalError(*pRecErr);
				}

				if((pRecErr = pTempFolder->GetFullFilePath(strTempFileNameForPatch,*&strTempFileFullPathForPatch)) != 0)
					return FatalError(*pRecErr);
				
				// we need to keep this file around as a placeholder for the name
				// filecopy will back this file up and restore it on rollback, so we need another rollback op to delete this file
				IMsiRecord& riUndoParams = GetSharedRecord(IxoFileRemove::Args);
				AssertNonZero(riUndoParams.SetMsiString(IxoFileRemove::FileName, *strTempFileFullPathForPatch));

				if (!RollbackRecord(ixoFileRemove, riUndoParams))
					return iesFailure;

				// reset copy arguments to reflect new file copy - new path, new filename, and since
				// the file is being copied into the secured config folder, we need to elevate for the target
				// NOTE: we aren't changing strDestName, which is used below
				//       for those uses it is correct to use the original dest name
				AssertNonZero(riParams.SetMsiString(DestName,*strTempFileNameForPatch));
				pTargetPath = pTempFolder;
 
				AssertNonZero(riParams.SetInteger(ElevateFlags, ielfCurrentElevateFlags | ielfElevateDest));

				DEBUGMSG2(TEXT("Redirecting file copy of '%s' to '%s'.  A subsequent patch will update the intermediate file, and then copy over the original."),
									(const ICHAR*)strTargetFullPath, (const ICHAR*)strTempFileFullPathForPatch);
			}

		}

		int iTotalPatches = riParams.IsNull(TotalPatches) ? 0 : riParams.GetInteger(TotalPatches);
		
		pRecErr = CacheFileState(*strTargetFullPath,(icfsEnum*)&iCachedState,
										 strTempFileFullPathForPatch, strVersion,
										 &iTotalPatches, &cPatchesToSkip);
		if(pRecErr)
			return FatalError(*pRecErr);
	}
	
	if(!fShouldInstall && !(fInstallModeFlags & icmRemoveSource))
	{
		// not moving the file, and not installing the file, so there is nothing left to do
		return iesSuccess;
	}

	// end of version/patch checking.  if we got this far, it means the sourcepath is required
	// to continue  determine source path now...


	// STEP 2: resolve source path and type
	
	PMsiPath pSourcePath(0);
	bool fCabinetCopy = false;
	bool fMoveFile    = false;

	if(m_state.fSplitFileInProgress)
	{
		// must be a cabinet copy
		fCabinetCopy = true;
	}
	else
	{
		if((iesRet = ResolveSourcePath(riParams, *&pSourcePath, fCabinetCopy)) != iesSuccess)
			return iesRet;

		fMoveFile = ((fInstallModeFlags & icmRemoveSource) && (fCabinetCopy == false)) ? fTrue : fFalse;
	}


	// STEP 3: perform copy/move operation
	
	if (!fShouldInstall)
	{
		if(fMoveFile)
		{
			// won't copy new file but still need to remove source file 
			Assert(pSourcePath);
			return RemoveFile(*pSourcePath, *MsiString(riParams.GetMsiString(SourceName)), fTrue, /*fBypassSFC*/ false);
		}
		return iesSuccess;
	}
	else if(!fCabinetCopy)
	{
		// if source and target paths and filenames are the same, skip file copy
		// NOTE: this will happen when patching an admin image - this check prevents us from
		//       attempting to install files over themselves
		//       we must make this check here instead of InstallFiles since the version check
		//       above is required for patching in the subsequent ixoPatchApply operation

		// a quick check is to compare the serial numbers of the two volumes
		// if they are the same then we will compare the SFN versions of each path
		if(PMsiVolume(&pSourcePath->GetVolume())->SerialNum() ==
			PMsiVolume(&pTargetPath->GetVolume())->SerialNum())
		{
			// volumes most likely match, now let's check SFN paths
			MsiString strSourceFullPath, strTargetFullPath;
			CTempBuffer<ICHAR,MAX_PATH> rgchSourceFullPath;
			CTempBuffer<ICHAR,MAX_PATH> rgchTargetFullPath;
			
			if((pRecErr = pSourcePath->GetFullFilePath(MsiString(riParams.GetMsiString(SourceName)),
																	 *&strSourceFullPath)) == 0 &&
				(pRecErr = pTargetPath->GetFullFilePath(strDestName, *&strTargetFullPath)) == 0 &&
				ConvertPathName(strSourceFullPath, rgchSourceFullPath, cpToShort) &&
				ConvertPathName(strTargetFullPath, rgchTargetFullPath, cpToShort) &&
				(IStrCompI(rgchSourceFullPath, rgchTargetFullPath) == 0))
			{
				// short names match
				return iesSuccess;
			}
		}
	}

	// action data
	// NOTE: the action data is sent here so we don't say we are copying a file before
	// we really know if we will copy it or not (fShouldInstall == fFalse)
	IMsiRecord& riActionData = GetSharedRecord(9);
	AssertNonZero(riActionData.SetMsiString(1, *strActionDataDestName));
	AssertNonZero(riActionData.SetInteger(6,riParams.GetInteger(FileSize)));
	AssertNonZero(riActionData.SetMsiString(9, *strActionDataDestPath));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	// perform operation
	bool fForever = true;
	while ( fForever )
	{
		if(fMoveFile)
		{
			Assert(!m_state.fSplitFileInProgress);
			iesRet = MoveFile(*pSourcePath, *pTargetPath, riParams, fTrue, fTrue, true, false,iehShowNonIgnorableError); // handles rollback
		}
		else
		{
			iesRet = CopyFile(*pSourcePath, *pTargetPath, riParams, /*fHandleRollback=*/ fTrue, s_iehErrorMode, fCabinetCopy);
		}
		if ( iesRet != iesSuccess || 
			  m_state.fSplitFileInProgress ||
			  riParams.GetInteger(CheckCRC) == iMsiNullInteger ||
			  !riParams.GetInteger(CheckCRC) )
			return iesRet;

		// we go ahead and check the checksum
		MsiString strDestFile;
		PMsiPath pDestPath(0);

		pRecErr = pTargetPath->GetFullFilePath(strDestName, *&strDestFile);
		if ( !pRecErr )
		{
			MsiString strTemp;
			Bool fRes = GetFileState(*strDestFile, 0, &strTemp, 0, 0);
			if ( fRes && strTemp.TextSize() )
			{
				// the file landed into a temp location: we need to check that temporary copy.
				pRecErr = m_riServices.CreateFilePath(strTemp, *&pDestPath, *&strDestFile);
				if ( !pRecErr )
					DEBUGMSG2(TEXT("File %s actually installed to %s; checking CRC of temporary copy."),
								 strDestName, strTemp);
			}
			else
			{
				//  the file didn't land in a temporary location
				strDestFile = strDestName;
				pDestPath = pTargetPath;
			}
		}
		if ( pRecErr )
			return (iesEnum)iesErrorIgnored;

		imsEnum imsClickedButton;
		bool fVitalFile = 
			((riParams.GetInteger(Attributes) & msidbFileAttributesVital) == 
			msidbFileAttributesVital) ? true : false;
		if ( !IsChecksumOK(*pDestPath, *strDestFile,
								 fMoveFile ? Imsg(imsgOpBadCRCAfterMove) : Imsg(imsgOpBadCRCAfterCopy),
								 &imsClickedButton, /* fErrorDialog = */ true,
								 fVitalFile, /* fRetryButton = */ !fCabinetCopy && !fMoveFile) )
		{
			switch (imsClickedButton)
			{
				case imsRetry:
					continue;
				case imsIgnore:
					return (iesEnum)iesErrorIgnored;
				case imsAbort:
				case imsCancel:
					return iesUserExit;
				default:
					Assert(imsClickedButton == imsNone || imsClickedButton == imsOk);
					return fVitalFile ? iesFailure : (iesEnum)iesErrorIgnored;
			};
		}
		else
			return iesSuccess;
	}  // while ( true )

	return iesSuccess;  // should never get here: it's for the compiler
}


iesEnum CMsiOpExecute::VerifyAccessibility(IMsiPath& riPath, const ICHAR* szFile, DWORD dwAccess, iehEnum iehErrorMode)
{
	// will return iesErrorIgnored if file cannot be accessed and the user either ignores the error, or
	// iehSilentlyIgnoreError is passed in for the iehErrorMode parameter.
	
	if(g_fWin9X)
		return iesSuccess; // all files accessible on Win9X

	for (;;)
	{
		DEBUGMSGV1(TEXT("Verifying accessibility of file: %s"), szFile);
		
		bool fVerified = false;
		PMsiRecord pRecErr = riPath.FileCanBeOpened(szFile, dwAccess, fVerified);
		
		if (pRecErr == 0 && fVerified)
		{
			break;
		}

		MsiString strFullPath;
		riPath.GetFullFilePath(szFile, *&strFullPath);

		if (!fVerified)
			pRecErr = PostError(Imsg(imsgAccessToFileDenied), *strFullPath);

		if (iehErrorMode == iehSilentlyIgnoreError)
		{
			Message(imtInfo, *pRecErr);
			return (iesEnum) iesErrorIgnored;
		}
		
		imtEnum imtButtons = iehErrorMode == iehShowNonIgnorableError ? imtRetryCancel : imtAbortRetryIgnore;
		switch(DispatchMessage(imtEnum(imtError+imtButtons+imtDefault1), *pRecErr, fTrue))
		{
		case imsIgnore:
			return (iesEnum) iesErrorIgnored;
		case imsRetry:
			continue;
		default:  // imsCancel
			return iesFailure;
		};
	}

	return iesSuccess;
}

#ifndef DEBUG
inline
#endif
bool IsRetryableError(const int iError)
{
	return (iError == imsgNetErrorReadingFromFile || iError == imsgErrorReadingFromFile ||
			  iError == imsgNetErrorOpeningCabinet || iError == imsgErrorOpeningCabinet ||
			  iError == imsgErrorOpeningFileForRead || iError == imsgCorruptCabinet);
}

iesEnum CMsiOpExecute::CopyFile(IMsiPath& riSourcePath, IMsiPath& riTargetPath, IMsiRecord& riParams,
								Bool fHandleRollback, iehEnum iehErrorMode, bool fCabinetCopy)
{
	return _CopyFile(riSourcePath, &riTargetPath, 0,  false, riParams, fHandleRollback, iehErrorMode, fCabinetCopy);
}

iesEnum CMsiOpExecute::CopyFile(IMsiPath& riSourcePath, IAssemblyCacheItem& riASM, bool fManifest, IMsiRecord& riParams,
								Bool fHandleRollback, iehEnum iehErrorMode, bool fCabinetCopy)
{
	return _CopyFile(riSourcePath, 0, &riASM, fManifest, riParams, fHandleRollback, iehErrorMode, fCabinetCopy);

}

iesEnum CMsiOpExecute::_CopyFile(IMsiPath& riSourcePath, IMsiPath* piTargetPath, IAssemblyCacheItem* piASM,  bool fManifest, IMsiRecord& riParams,
								Bool fHandleRollback, iehEnum iehErrorMode, bool fCabinetCopy)

{
	// NOTE: riSourcePath may be a reference to a NULL pointer if cabinet copy
	
	using namespace IxoFileCopyCore;

	int iNetRetries = 0;
	PMsiRecord pRecErr(0);
	iesEnum iesRet = iesNoAction;

	CDeleteUrlCacheFileOnClose cDeleteUrlCacheFileOnClose; // will set file name if actually downloaded

	ielfEnum ielfElevateFlags = riParams.IsNull(ElevateFlags) ? ielfNoElevate : (ielfEnum)riParams.GetInteger(ElevateFlags);
	
	if (!m_state.fSplitFileInProgress)
	{
		m_state.cbFileSoFar = 0;

		// skip security acls, rollback for existing file and folder creation stuff for fusion files
		if(piTargetPath)
		{
			bool fNoSecurityDescriptor = riParams.IsNull(SecurityDescriptor) == fTrue;
			MsiString strDestFullFilePath;

			if (fNoSecurityDescriptor || fHandleRollback)
			{
				pRecErr = piTargetPath->GetFullFilePath(riParams.GetString(DestName),
																	*&strDestFullFilePath);

				if (pRecErr)
				{
					Message(imtError, *pRecErr);
					return iesFailure;
				}
			}

			// we need to preserve the destination ACL if we're not already applying a descriptor to the dest file
			if (fNoSecurityDescriptor)
			{
				Assert(strDestFullFilePath.TextSize());

				Bool fExists = fFalse;
				pRecErr = piTargetPath->FileExists(MsiString(riParams.GetString(DestName)), fExists);
				if (pRecErr)
				{
					Message(imtError, *pRecErr);
					return iesFailure;
				}

				if (fExists)
				{
					PMsiStream pSecurityDescriptor(0);

					DEBUGMSGV("Re-applying security from existing file.");
					if ((iesRet = GetSecurityDescriptor(strDestFullFilePath, *&pSecurityDescriptor)) != iesSuccess)
						return iesRet;

					AssertNonZero(riParams.SetMsiData(SecurityDescriptor, pSecurityDescriptor));
				}
			}

			// HandleExistingFile may change the value of riParams[IxoFileCopy::DestFile] if the existing file
			// cannot be moved
			bool fFileExists = false;
			if((iesRet = HandleExistingFile(*piTargetPath,riParams,fHandleRollback,iehErrorMode, fFileExists)) != iesSuccess)
				return iesRet;

			if(fHandleRollback && !fFileExists)
			{
				// if we aren't overwriting an existing file, generate undo op to remove new file
				// otherwise the undo op to put the backup file back will overwrite the new file
				// NOTE: to fix bug 7376, we avoid doing a remove then replace during rollback

				// do this before the copy begins in case the copy fails part way through

				Assert(strDestFullFilePath.TextSize());

				IMsiRecord& riUndoParams = GetSharedRecord(IxoFileRemove::Args);
				AssertNonZero(riUndoParams.SetMsiString(IxoFileRemove::FileName,
																	 *strDestFullFilePath));

				if(ielfElevateFlags & ielfElevateDest)
				{
					// if we will elevate to copy this file, it means we will have to elevate
					// to remove the file on rollback
					AssertNonZero(riUndoParams.SetInteger(IxoFileRemove::Elevate,1));
				}
				
				if (!RollbackRecord(ixoFileRemove, riUndoParams))
					return iesFailure;
			}

			// scope elevate
			{
				CElevate elevate(Tobool(ielfElevateFlags & ielfElevateDest));

				if((iesRet = CreateFolder(*piTargetPath)) != iesSuccess)
					return iesRet;
			}
		}
	}
	

#ifdef DEBUG
	const ICHAR* szDebug = riParams.GetString(DestName);
#endif DEBUG
	m_state.fSplitFileInProgress = fFalse;  
	unsigned int cbFileSize = riParams.GetInteger(FileSize);
	int iPerTick = riParams.GetInteger(PerTick);

	// for uncompressed files, the source path is passed in, for compressed copies riSourcePath is invalid
	//!! should fix that, shouldn't pass in reference to null pointer
	PMsiPath pSourcePath(0);
	if(!fCabinetCopy)
	{
		pSourcePath = &riSourcePath;
		riSourcePath.AddRef();
	}

	MsiString strKeyName = riParams.GetMsiString(SourceName);
	if (fCabinetCopy && strKeyName.Compare(iscExactI, m_state.strLastFileKey))
	{
		//?? Will not work if the file is installed to a fusion assembly
		//?? dont think we need to support duplicate file copy for files belonging to fusion assemblies
		//!! need validation to prevent this from happening
		pSourcePath = m_state.pLastTargetPath;
		riParams.SetMsiString(SourceName, *m_state.strLastFileName);
		fCabinetCopy = fFalse;
	}

	// for URL downloads, the source name may be re-directed.
	// if it is, we will change pSourcePath and riParams[SourceName]

	PMsiVolume piSourceVolume(0);
	if (pSourcePath)
		piSourceVolume = &(pSourcePath->GetVolume());

	imtEnum imtButtons = iehErrorMode == iehShowNonIgnorableError ? imtRetryCancel : imtAbortRetryIgnore;

	int iCopyAttributes = riParams.GetInteger(Attributes);

	if (piSourceVolume && piSourceVolume->IsURLServer())
	{
		int cAutoRetry = 0;
		for(;;)
		{
			// download the file to the cache, and redirect the source name and path.
			// downloading cabs are handled elsewhere...
			MsiString strSourceURL;
			pSourcePath->GetFullFilePath(riParams.GetString(SourceName), *&strSourceURL);
			Assert(strSourceURL);
			MsiString strCacheFileName;
 
			Bool fUrl = fTrue;
			HRESULT hResult = DownloadUrlFile((const ICHAR*) strSourceURL, *&strCacheFileName, fUrl, -1);

			if (ERROR_SUCCESS == hResult)
			{
				MsiString strSourceName;
				AssertRecord(m_riServices.CreateFilePath((const ICHAR*) strCacheFileName, *&pSourcePath, *&strSourceName));
				AssertNonZero(riParams.SetMsiString(SourceName,*strSourceName));
				cDeleteUrlCacheFileOnClose.SetFileName(*strSourceURL);
				break;
			}
			else
			{
				DWORD dwLastError = WIN::GetLastError();
				pRecErr = PostError(Imsg(imsgErrorSourceFileNotFound), (const ICHAR*) strSourceURL);

				if (iehErrorMode == iehSilentlyIgnoreError)
				{
					Message(imtInfo, *pRecErr); // Make sure we write to the non-verbose log
					return (iesEnum) iesErrorIgnored;
				}

				
				// give the download 3 retries, then give up and prompt the user.  They can always keep retrying
				// or ignore themselves.
				if (cAutoRetry < 2)
				{
					cAutoRetry++;
					DispatchMessage(imtInfo, *pRecErr, fTrue);
					continue;
				}
				else
				{
					cAutoRetry = 0;
				}

				switch(DispatchMessage(imtEnum(imtError+imtButtons+imtDefault1), *pRecErr, fTrue))
				{
				case imsRetry:
					continue;

				case imsIgnore:
					return (iesEnum) iesErrorIgnored;
				
				case imsCancel:
				case imsAbort:
					return iesUserExit;

				case imsNone:
				default:  //imsNone
					return iesFailure;
				}
			}
		}
	}

	iesRet = InitCopier(ToBool(fCabinetCopy),iPerTick,*MsiString(riParams.GetMsiString(SourceName)), pSourcePath, Bool(riParams.GetInteger(VerifyMedia)));
	if (iesRet != iesSuccess)
	{
		return iesRet;
	}

	// if elevating for source or dest exclusively, need to make sure we aren't letting the user do something
	// they couldn't normally do
	if (!fCabinetCopy && ((ielfElevateFlags & (ielfElevateDest|ielfElevateSource)) == ielfElevateDest))
	{
		// if we want to elevate for the dest only we still have to elevate for the source.
		// if this is the case then we'd better be sure that, *before* we elevate, we have GENERIC_READ access
		// to the source file

		// SECURITY:  Could this open us to reading from a cabinet the user doesn't have access to?

		iesRet = VerifyAccessibility(*pSourcePath, riParams.GetString(SourceName), GENERIC_READ, iehErrorMode);
		if (iesRet != iesSuccess)
			return iesRet;
	}

	if (piTargetPath && (ielfElevateFlags & (ielfElevateDest|ielfElevateSource)) == ielfElevateSource)
	{
		// if we want to elevate for the source only we still have to elevate for the desination.
		// if this is the case then we'd better be sure that, *before* we elevate, we have GENERIC_WRITE access
		// to the destination file

		iesRet = VerifyAccessibility(*piTargetPath, riParams.GetString(DestName), GENERIC_WRITE, iehErrorMode);
		if (iesRet != iesSuccess)
			return iesRet;
	}


	CElevate elevate(Tobool(ielfElevateFlags & (ielfElevateDest|ielfElevateSource)));
	int iPrevError = 0;
	int cSameError = 0;
	bool fDoCopy = true;
	for (;;)
	{
		if ( fDoCopy )
		{
			if(piTargetPath)
				pRecErr = m_state.piCopier->CopyTo(*pSourcePath, *piTargetPath, riParams);
			else
			{
				Assert(piASM);
				pRecErr = m_state.piCopier->CopyTo(*pSourcePath, *piASM, fManifest, riParams);
			}
		}
		else
			pRecErr = 0;

		if (pRecErr)
		{
			int iError = pRecErr->GetInteger(1);
			if ( iError == iPrevError )
				cSameError++;
			else
				cSameError = 0;
			iPrevError = iError;

			// If the copier reported that it needs the next cabinet,
			// we've got to wait until a media change operation
			// executes before continuing with file copying.
			if (iError == idbgNeedNextCabinet)
			{
				// Do this record again right after the media change
				InsertTopRecord(riParams);
				m_state.fSplitFileInProgress = fTrue;
				m_state.fWaitingForMediaChange = fTrue;
				break;
			}
			else if (iError == idbgCopyNotify)
			{
				if(DispatchProgress(iPerTick) == imsCancel)
					return iesUserExit;
				m_state.cbFileSoFar += iPerTick;
			}
			else if (iError == idbgErrorSettingFileTime ||
						iError == idbgCannotSetAttributes)
			{
				// non-critical error - log warning message and end copy
				Message(imtInfo, *pRecErr);
				if(DispatchProgress(cbFileSize - m_state.cbFileSoFar) == imsCancel)
					return iesUserExit;
				break;
			}
			else if (iError == idbgDriveNotReady)
			{
				Assert(m_state.strMediaLabel.TextSize() > 0);
				Assert(m_state.strMediaPrompt.TextSize() > 0);
				PMsiVolume pNewVolume(0);

				UINT uiDisk = 0;
				if (m_state.pCurrentMediaRec)
					uiDisk = m_state.pCurrentMediaRec->GetInteger(IxoChangeMedia::IsFirstPhysicalMedia);

				if (!VerifySourceMedia(*m_state.pMediaPath,m_state.strMediaLabel,m_state.strMediaPrompt,
					uiDisk, *&pNewVolume))
				{
					riParams.SetInteger(Attributes, iCopyAttributes | ictfaCancel);
				}
			}
			else if (iError == idbgUserAbort)
			{
				return iesUserExit;
			}
			else if (iError == idbgUserIgnore)
			{
				return (iesEnum) iesErrorIgnored;
			}
			else if (iError == idbgUserFailure)
			{
				return iesFailure;
			}
			else if ( IsRetryableError(iError) &&
						 iNetRetries < MAX_NET_RETRIES )
			{
				iNetRetries++;
				riParams.SetInteger(Attributes, iCopyAttributes | ictfaRestart);
				continue;
			}
			else
			{
				if (iehErrorMode == iehSilentlyIgnoreError)
				{
					Message(imtInfo, *pRecErr);
					if ( cSameError < MAX_NET_RETRIES )
						riParams.SetInteger(Attributes, iCopyAttributes | ictfaIgnore);
					else
						// iError already showed up MAX_NET_RETRIES consecutive times.
						// We need to make sure we do not enter into an infinite loop.
						fDoCopy = false;
					continue;
				}

				if (iError == idbgStreamReadError)
				{
					MsiString strModuleFileName = m_state.pCurrentMediaRec->GetMsiString(IxoChangeMedia::ModuleFileName);
					pRecErr = PostError(Imsg(imsgOpFileCopyStreamReadErr), *strModuleFileName);
					imtButtons = imtRetryCancel; // Can't ignore if we can't access the source stream cabinet
				}
				else if (iError == imsgDiskFull || iError == imsgErrorWritingToFile || iError == imsgErrorReadingFromFile)
					imtButtons = imtRetryCancel; // Can't ignore errors when accessing an open file
				else if (iError == imsgFileNotInCabinet || iError == imsgCABSignatureMissing || iError == imsgCABSignatureRejected)
					imtButtons = imtOk; // Can't continue the install if file not found in cabinet or cabinet's signature rejected
				else
					imtButtons = iehErrorMode == iehShowNonIgnorableError ? imtRetryCancel : imtAbortRetryIgnore;

				switch(DispatchMessage(imtEnum(imtError+imtButtons+imtDefault1), *pRecErr, fTrue))
				{
				case imsIgnore:
					riParams.SetInteger(Attributes, iCopyAttributes | ictfaIgnore);
					continue;
				case imsRetry:
					if ( IsRetryableError(iError) )
					{
						iNetRetries = 0;
						riParams.SetInteger(Attributes, iCopyAttributes | ictfaRestart);
					}
					continue;
				case imsOk:
					return iesFailure;
				default:  // imsCancel or imsAbort
					riParams.SetInteger(Attributes, iCopyAttributes | ictfaFailure);
					continue;
				};
			}
		}
		else
		{
			// Dispatch remaining progress for this file
			if(DispatchProgress(cbFileSize - m_state.cbFileSoFar) == imsCancel)
				return iesUserExit;

			if (fCabinetCopy)
			{
				m_state.strLastFileKey = riParams.GetMsiString(SourceName);
				m_state.strLastFileName = riParams.GetMsiString(DestName);
				m_state.pLastTargetPath = piTargetPath;
				if(piTargetPath)
					piTargetPath->AddRef();
			}
			
			break;
		}
	}
	return iesSuccess;
}


iesEnum CMsiOpExecute::BackupFile(IMsiPath& riPath, const IMsiString& ristrFile, Bool fRemoveOriginal,
											 Bool fRemoveFolder, iehEnum iehErrorMode, bool fRebootOnRenameFailure,
											 bool fWillReplace, const IMsiString* pistrAssemblyComponentId, bool fManifest)
{
	Assert(RollbackEnabled());
	PMsiRecord pRecErr(0);
	MsiString strFileFullPath;
	if((pRecErr = riPath.GetFullFilePath(ristrFile.GetString(),
													 *&strFileFullPath)) != 0)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}

	iesEnum iesRet;
	PMsiPath pBackupFolder(0);
	if((iesRet = GetBackupFolder(&riPath,*&pBackupFolder)) != iesSuccess)
		return iesRet;
	
	MsiString strBackupFileFullPath, strBackupFile;
	{
		CElevate elevate;
		if((pRecErr = pBackupFolder->TempFileName(0, szRollbackFileExt, fTrue, *&strBackupFile, 0)) != 0)
			return FatalError(*pRecErr);
	}

	if((pRecErr = pBackupFolder->GetFullFilePath(strBackupFile,*&strBackupFileFullPath)) != 0)
		return FatalError(*pRecErr);
	
	// generate op to register backup file
	{
	using namespace IxoRegisterBackupFile;
	IMsiRecord& riUndoParams = GetSharedRecord(Args);
	AssertNonZero(riUndoParams.SetMsiString(File,*strBackupFileFullPath));
	if (!RollbackRecord(ixoRegisterBackupFile,riUndoParams))
		return iesFailure;
	}

	{
		CElevate elevate;
		// remove temp file so that MoveFile won't attempt to back up old file
		if((pRecErr = pBackupFolder->RemoveFile(strBackupFile)) != 0)
		{
			Message(imtError, *pRecErr);  //!! how do we handle this?
			return iesFailure;
		}
	}

	m_cSuppressProgress++; // suppress progress messages from MoveFile
	iesRet = CopyOrMoveFile(riPath, *pBackupFolder, ristrFile, *strBackupFile,
									fRemoveOriginal, fRemoveFolder, fTrue, iehErrorMode, 0, ielfElevateDest, /* fCopyACL = */ true,
									fRebootOnRenameFailure, fWillReplace);
	m_cSuppressProgress--;

	// hide the files, so we don't have to look at them when they happen to be on the desk top.
	// The rollback in CopyOrMoveFile manages the attributes for when we put it back, so mucking with it here
	// won't hurt.
	{
		CElevate elevate;
		if((iesRet == iesSuccess) && (pRecErr = pBackupFolder->SetAllFileAttributes(strBackupFile, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN)) != 0)
		{                               
			Message(imtError, *pRecErr); // should never happen.
			return iesFailure;
		}
	}

	// is the file part of an assembly?
	// for assemblies we have passed in the componentid
	
	Assert(!pistrAssemblyComponentId || !fRemoveOriginal); // we should never be called to remove the original file in case of assemblies

	
	if (!fRemoveOriginal)
	{
		// It's not automatic to put the old one back during rollback, so we'll have to do it.

		// When we're not removing the original, we use CopyOrMoveFile to just copy the file.
		// Copying creates a rollback to remove the copy, but *not* to copy it back over the
		// original file.

		// This semantic gives us the chance to copy a file, muck with it, and have rollback
		// restore to its original state.
		using namespace IxoFileCopyCore;
		IMsiRecord& riUndoParams = GetSharedRecord(pistrAssemblyComponentId ? IxoAssemblyCopy::Args : IxoFileCopy::Args);
		PMsiRecord pRecErr(0);

		MsiString strFilePath(0);
		if((pRecErr = riPath.GetFullFilePath(ristrFile.GetString(), *&strFilePath)) != 0)
			return FatalError(*pRecErr);
		AssertNonZero(riUndoParams.SetMsiString(SourceName, *strBackupFileFullPath));

		int iAttribs = 0;
		riPath.GetAllFileAttributes(ristrFile.GetString(), iAttribs);
		AssertNonZero(riUndoParams.SetInteger(Attributes, iAttribs));

		unsigned int uiFileSize = 0;
		if ((pRecErr = riPath.FileSize(ristrFile.GetString(),uiFileSize)) != 0)
			AssertNonZero(riUndoParams.SetInteger(FileSize,uiFileSize));
		else
			AssertNonZero(riUndoParams.SetInteger(FileSize,0));

		AssertNonZero(riUndoParams.SetInteger(PerTick,0));
		AssertNonZero(riUndoParams.SetInteger(VerifyMedia,fFalse));

		int ielfElevateFlags = ielfElevateSource; // since rollback op is copying from backup folder,
																	  // need to elevate source
		if(!IsImpersonating())
		{
			// we are currently elevated to backup this file
			// which means we need to elevate during rollback to restore the file
			ielfElevateFlags |= ielfElevateDest;
		}

		AssertNonZero(riUndoParams.SetInteger(ElevateFlags, ielfElevateFlags));

		if(!pistrAssemblyComponentId)
		{
			AssertNonZero(riUndoParams.SetInteger(IxoFileCopy::InstallMode, icmOverwriteAllFiles));
			AssertNonZero(riUndoParams.SetMsiString(DestName, *strFilePath));
			RollbackRecord(ixoFileCopy, riUndoParams);
		}
		else
		{
			AssertNonZero(riUndoParams.SetMsiString(DestName, ristrFile));
			AssertNonZero(riUndoParams.SetMsiString(IxoAssemblyCopy::ComponentId, *pistrAssemblyComponentId));
			if(fManifest)
			{
				AssertNonZero(riUndoParams.SetInteger(IxoAssemblyCopy::IsManifest, fTrue)); // need to know the manifest file during assembly installation
			}
			RollbackRecord(ixoAssemblyCopy, riUndoParams);
		}
	}


	return iesRet;
}

// call this MoveFile if all you have are the names of the files
iesEnum CMsiOpExecute::CopyOrMoveFile(IMsiPath& riSourcePath, IMsiPath& riDestPath,
										  const IMsiString& ristrSourceName,
										  const IMsiString& ristrDestName,
										  Bool fMove,
										  Bool fRemoveFolder,
										  Bool fHandleRollback,
										  iehEnum iehErrorMode,
										  IMsiStream* pSecurityDescriptor,
										  ielfEnum ielfElevateFlags,
										  bool fCopyACL,
										  bool fRebootOnSourceRenameFailure,
										  bool fWillReplace)
{
	using namespace IxoFileCopyCore;

	PMsiRecord pRecErr(0);
	PMsiRecord pCopyOrMoveFileRec = &m_riServices.CreateRecord(Args);
	unsigned int uiFileSize = 0;
	int iFileAttributes = 0;

	// scope elevate
	{
		CElevate elevate(Tobool(ielfElevateFlags & ielfElevateSource));
		pRecErr = riSourcePath.GetAllFileAttributes(ristrSourceName.GetString(),iFileAttributes);
		if(!pRecErr)
			pRecErr = riSourcePath.FileSize(ristrSourceName.GetString(),uiFileSize);
	}
	
	if(pRecErr)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}

	if(iFileAttributes == FILE_ATTRIBUTE_NORMAL)
		// set to 0, this value is interpreted as something else by CMsiFileCopy::CopyTo
		iFileAttributes = 0;

	if (fCopyACL)
		iFileAttributes |= ictfaCopyACL;
	
	AssertNonZero(pCopyOrMoveFileRec->SetMsiString(SourceName,ristrSourceName));
	AssertNonZero(pCopyOrMoveFileRec->SetMsiString(DestName,ristrDestName));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(FileSize,uiFileSize));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(Attributes,iFileAttributes)); //!! are these the correct attributes?
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(PerTick,0));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(VerifyMedia,fFalse));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(ElevateFlags,ielfElevateFlags));
	
	if (pSecurityDescriptor)
		AssertNonZero(pCopyOrMoveFileRec->SetMsiData(SecurityDescriptor, pSecurityDescriptor));


	return fMove ? MoveFile(riSourcePath, riDestPath, *pCopyOrMoveFileRec, fRemoveFolder, fHandleRollback, fRebootOnSourceRenameFailure, fWillReplace, iehErrorMode) :
				   CopyFile(riSourcePath, riDestPath, *pCopyOrMoveFileRec, fHandleRollback, iehErrorMode, /*fCabinetCopy=*/false);
}

iesEnum CMsiOpExecute::CopyASM(IMsiPath& riSourcePath, const IMsiString& ristrSourceName,
										 IAssemblyCacheItem& riASM, const IMsiString& ristrDestName, bool fManifest, 
										 Bool fHandleRollback, iehEnum iehErrorMode, ielfEnum ielfElevateFlags)
{
	using namespace IxoFileCopyCore;

	PMsiRecord pRecErr(0);
	PMsiRecord pCopyOrMoveFileRec = &m_riServices.CreateRecord(Args);
	unsigned int uiFileSize = 0;
	int iFileAttributes = 0;

	// scope elevate
	{
		CElevate elevate(Tobool(ielfElevateFlags & ielfElevateSource));
		pRecErr = riSourcePath.GetAllFileAttributes(ristrSourceName.GetString(),iFileAttributes);
		if(!pRecErr)
			pRecErr = riSourcePath.FileSize(ristrSourceName.GetString(),uiFileSize);
	}
	
	if(pRecErr)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}

	if(iFileAttributes == FILE_ATTRIBUTE_NORMAL)
		// set to 0, this value is interpreted as something else by CMsiFileCopy::CopyTo
		iFileAttributes = 0;

	AssertNonZero(pCopyOrMoveFileRec->SetMsiString(SourceName,ristrSourceName));
	AssertNonZero(pCopyOrMoveFileRec->SetMsiString(DestName,ristrDestName));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(FileSize,uiFileSize));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(Attributes,iFileAttributes)); //!! are these the correct attributes?
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(PerTick,0));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(VerifyMedia,fFalse));
	AssertNonZero(pCopyOrMoveFileRec->SetInteger(ElevateFlags,ielfElevateFlags));

	return CopyFile(riSourcePath, riASM, fManifest, *pCopyOrMoveFileRec, fHandleRollback, iehErrorMode, /*fCabinetCopy=*/false);
}

iesEnum CMsiOpExecute::MoveFile(IMsiPath& riSourcePath, IMsiPath& riDestPath,
										  IMsiRecord& riParams, Bool fRemoveFolder, Bool fHandleRollback,
										  bool fRebootOnSourceRenameFailure,
										  bool fWillReplaceSource, iehEnum iehErrorMode)
{
	using namespace IxoFileCopyCore;
	PMsiRecord pError(0);
	iesEnum iesRet = iesNoAction;

	ielfEnum ielfElevateFlags = riParams.IsNull(ElevateFlags) ? ielfNoElevate : (ielfEnum)riParams.GetInteger(ElevateFlags);

	// backup or delete existing file
	// HandleExistingFile may change the value of riParams[IxoFileCopy::DestFile] if the existing file
	// cannot be moved
	bool fFileExists = false;
	if((iesRet = HandleExistingFile(riDestPath,riParams,fHandleRollback,iehErrorMode,fFileExists)) != iesSuccess)
		return iesRet;
	
	MsiString strSourceFileFullPath, strDestFileFullPath;
	if(((pError = riSourcePath.GetFullFilePath(riParams.GetString(SourceName),*&strSourceFileFullPath)) != 0) ||
		((pError = riDestPath.GetFullFilePath(riParams.GetString(DestName),*&strDestFileFullPath)) != 0))
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	// scope elevate
	{
		CElevate elevate(Tobool(ielfElevateFlags & ielfElevateDest));
		// create folder
		if((iesRet = CreateFolder(riDestPath)) != iesSuccess)
			return iesRet;
	}

	// create undo record
	PMsiRecord pUndoParams = 0;
	if(fHandleRollback && RollbackEnabled())
	{
		// use IxoFileCopy args for rollback op
		pUndoParams = &m_riServices.CreateRecord(IxoFileCopy::Args);
		AssertNonZero(pUndoParams->SetMsiString(IxoFileCopy::SourceName,*strDestFileFullPath));
		AssertNonZero(pUndoParams->SetMsiString(IxoFileCopy::DestName,*strSourceFileFullPath));
		AssertNonZero(pUndoParams->SetInteger(IxoFileCopy::FileSize,riParams.GetInteger(FileSize)));
		AssertNonZero(pUndoParams->SetInteger(IxoFileCopy::Attributes,riParams.GetInteger(Attributes))); //!! use these attributes?
		AssertNonZero(pUndoParams->SetInteger(IxoFileCopy::PerTick,0));
		AssertNonZero(pUndoParams->SetInteger(IxoFileCopy::InstallMode,icmRemoveSource | icmOverwriteAllFiles));
		AssertNonZero(pUndoParams->SetInteger(IxoFileCopy::VerifyMedia,fFalse));
		
		// determine elevation flags for rollback op
		int ielfRollbackElevateFlags = ielfNoElevate;
		if(!IsImpersonating())
		{
			// we are currently elevated, which means its safe to elevate for src and dest during rollback
			ielfRollbackElevateFlags = ielfElevateSource|ielfElevateDest;
		}
		else
		{
			// if currently elevating for source, rollback needs to elevate for dest
			if(ielfElevateFlags & ielfElevateSource)
				ielfRollbackElevateFlags |= ielfElevateDest;

			// if currently elevating for dest, rollback needs to elevate for source
			if(ielfElevateFlags & ielfElevateDest)
				ielfRollbackElevateFlags |= ielfElevateSource;
		}

		AssertNonZero(pUndoParams->SetInteger(IxoFileCopy::ElevateFlags,ielfRollbackElevateFlags));
		// don't need to set version or language - install mode says always overwrite
	}

	// attempt to move file

	// if elevating for source or dest exclusively, need to make sure we aren't letting the user do something
	// they couldn't normally do
	if ((ielfElevateFlags & (ielfElevateDest|ielfElevateSource)) == ielfElevateDest)
	{
		// if we want to elevate for the dest only we still have to elevate for the source.
		// if this is the case then we'd better be sure that, *before* we elevate, we have DELETE access
		// to the source file

		iesRet = VerifyAccessibility(riSourcePath, riParams.GetString(SourceName), DELETE, iehErrorMode); //!! doesn't catch case where dir has DELETE access but file doesn't
		if (iesRet != iesSuccess)
			return iesRet;
	}

	if ((ielfElevateFlags & (ielfElevateDest|ielfElevateSource)) == ielfElevateSource)
	{
		// if we want to elevate for the source only we still have to elevate for the desination.
		// if this is the case then we'd better be sure that, *before* we elevate, we have GENERIC_WRITE access
		// to the destination file

		iesRet = VerifyAccessibility(riDestPath, riParams.GetString(DestName), GENERIC_WRITE, iehErrorMode);
		if (iesRet != iesSuccess)
			return iesRet;
	}

	BOOL fRes = FALSE;

	bool fDestSupportsACLs = (PMsiVolume(&riDestPath.GetVolume())->FileSystemFlags() & FS_PERSISTENT_ACLS) != 0;

	if (!fDestSupportsACLs || riParams.IsNull(SecurityDescriptor)) // if we have security descriptor to apply then we need to do a copy and remove
	{
		// scope elevate
		CElevate elevate(Tobool(ielfElevateFlags & (ielfElevateDest|ielfElevateSource)));

		//!! MoveFile *will* copy the ACLs on same-drive moves; we don't respect the ictfaCopyACL attributes in this case. this is spec issue bug #6546
		FILETIME ftLastWrite;
		DWORD dwResult = GetFileLastWriteTime(strSourceFileFullPath, ftLastWrite);

		fRes = WIN::MoveFile(strSourceFileFullPath,strDestFileFullPath);
		if (fRes && dwResult == NO_ERROR)
		{
			// Not fatal if file time can't be set, so don't throw error
			if ((pError = riDestPath.SetAllFileAttributes(riParams.GetString(DestName), FILE_ATTRIBUTE_NORMAL)) == 0)
				dwResult = MsiSetFileTime(strDestFileFullPath, &ftLastWrite);
		}

	}

	if(fRes)
	{
		if(pUndoParams)
			if (!RollbackRecord(ixoFileCopy, *pUndoParams))
				return iesFailure; //!! is this the correct place?

		// scope elevate
		{
			CElevate elevate(Tobool(ielfElevateFlags & ielfElevateDest));

			// set appropriate file attributes
			if((pError = riDestPath.SetAllFileAttributes(riParams.GetString(DestName),
																		riParams.GetInteger(Attributes))) != 0)
			{
				// If we can't set the file attributes, it's not a fatal error.
				Message(imtInfo, *pError);
			}
		}
		// Dispatch remaining progress for this file
		if(DispatchProgress(riParams.GetInteger(FileSize)) == imsCancel)
			return iesUserExit;

		if(fRemoveFolder)
		{
			CElevate elevate(Tobool(ielfElevateFlags & ielfElevateSource));
			return RemoveFolder(riSourcePath);
		}
		else
			return iesSuccess;
	}
	else
	{
		// move failed
		// copy and remove file
		iesRet = CopyFile(riSourcePath, riDestPath, riParams, fFalse, iehShowNonIgnorableError,
								/*fCabinetCopy=*/false);
		if(iesRet == iesSuccess)
		{
			if(pUndoParams)
				if (!RollbackRecord(ixoFileCopy, *pUndoParams))
					return iesFailure; //!! is this the correct place?
			// remove source file
			return RemoveFile(riSourcePath, *MsiString(riParams.GetMsiString(IxoFileCopy::SourceName)), fFalse, /*fBypassSFC*/ false,
									fRebootOnSourceRenameFailure, fRemoveFolder, iehErrorMode, fWillReplaceSource);
		}
		return iesRet;
	}
}

iesEnum CMsiOpExecute::HandleExistingFile(IMsiPath& riTargetPath, IMsiRecord& riParams,Bool fHandleRollback,
										  iehEnum iehErrorMode, bool& fFileExisted)
{
	// this function may change the value of riParams[IxoFileCopy::DestFile] if the existing file
	// cannot be moved
	using namespace IxoFileCopyCore;

	PMsiRecord pRecErr(0);
	iesEnum iesRet = iesNoAction;
	MsiString strDestFileName = riParams.GetMsiString(DestName);

	ielfEnum ielfCurrentElevateFlags = riParams.IsNull(ElevateFlags) ? ielfNoElevate :
												  (ielfEnum)riParams.GetInteger(ElevateFlags);

	bool fBypassSFC = (ielfCurrentElevateFlags & ielfBypassSFC) ? true : false;
	
	fFileExisted = false;

	// we may be copying over an existing file
	Bool fFileExists = FFileExists(riTargetPath,*strDestFileName);
	if(fFileExists)
	{
		fFileExisted = true;
		
		Bool fInUse = fFalse;
		// note: FileInUse doesn't catch every file in use, such as fonts
		// the worst that can happen from this is that we don't reboot when copying over a font
		if((pRecErr = riTargetPath.FileInUse(strDestFileName,fInUse)) == 0 && fInUse == fTrue)
		{
			// existing file is in use - make sure we prompt for reboot - we may not actually schedule
			// a file for reboot but since the existing file is in use we need to reboot so that
			// the installed file will be used rather than the existing file
			
			DispatchError(imtInfo, Imsg(imsgFileInUseLog),
							  *MsiString(riTargetPath.GetPath()), *strDestFileName);
			m_fRebootReplace = fTrue;
		}

		//!!?? check if source file exists before removing target file???
		if((iesRet = RemoveFile(riTargetPath,*strDestFileName,fHandleRollback, fBypassSFC, true,fTrue,iehErrorMode,true)) != iesSuccess)
			return iesRet;

		// check if file still exists.  If so, we need to install to a different spot
		// and schedule the replacement on reboot
		if(FFileExists(riTargetPath,*strDestFileName))
		{
			// since remove file succeeded, we must have delete access for the existing file
			// which means it is safe to schedule a rename to that spot after reboot
			// we also assume we have ADD_FILE access to this directory, since if we don't, we
			// will fail the file copy when that is attempted
			MsiString strDestFullPath,strTempFileFullPath,strTempFileName;
			if((pRecErr = riTargetPath.GetFullFilePath(strDestFileName,*&strDestFullPath)) != 0)
				return FatalError(*pRecErr);

			if((pRecErr = riTargetPath.TempFileName(TEXT("TBM"),0,fTrue,*&strTempFileName, 0)) != 0)
				return FatalError(*pRecErr);

			if((pRecErr = riTargetPath.GetFullFilePath(strTempFileName,*&strTempFileFullPath)) != 0)
				return FatalError(*pRecErr);
			
			if((pRecErr = CacheFileState(*strDestFullPath,0,strTempFileFullPath, 0, 0, 0)) != 0)
				return FatalError(*pRecErr);
			
			AssertNonZero(riParams.SetMsiString(DestName,*strTempFileName));

			for(;;)
			{
				if(ReplaceFileOnReboot(strTempFileFullPath,strDestFullPath) == fFalse)
				{
					if (iehErrorMode == iehSilentlyIgnoreError)
					{
						// Just log the error and go on
						DispatchError(imtInfo, Imsg(imsgOpScheduleRebootReplace), *strTempFileFullPath, *strDestFullPath);
						return (iesEnum) iesErrorIgnored;
					}

					imtEnum imtButtons = imtEnum(imtError + (iehErrorMode == iehShowNonIgnorableError ? imtRetryCancel : imtAbortRetryIgnore));
					switch(DispatchError(imtButtons,Imsg(imsgOpScheduleRebootReplace),
												*strTempFileFullPath,
												*strDestFullPath))
					{
					case imsRetry:
						continue;

					case imsIgnore:
						return (iesEnum) iesErrorIgnored;

					case imsAbort:
					case imsCancel:
					case imsNone:
					default:
						return iesFailure;
					};
				}
				else
					break;
			}
		}
	}
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfRegisterBackupFile(IMsiRecord& /*riParams*/)
{
	// do nothing, only purpose is to show backup file for Rollback script cleanup
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfFileUndoRebootReplace(IMsiRecord& riParams)
{
	using namespace IxoFileUndoRebootReplace;
	
	PMsiRecord pRecErr(0);
	MsiString strExistingFile = riParams.GetMsiString(ExistingFile);
	if(!strExistingFile.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpInvalidParam), TEXT("ixfFileUndoRebootReplace"),
						  (int)ExistingFile);
		return iesFailure;
	}
	MsiString strNewFile = riParams.GetMsiString(NewFile);

	Bool fWindows = riParams.GetInteger(Type) == 0 ? fTrue : fFalse;
	if(fWindows) // Win95
	{
		//FUTURE:  Combine this and similar section in ReplaceFileOnReboot

#ifdef UNICODE
		AssertSz(0, TEXT("unicode build attempting to operate on wininit.ini"));
#else //ANSI
		// remove entry from WININIT.INI file

		// the last line of the file should contain a newline combo.
		char szNewLine[] = "\r\n";
		unsigned int cchNewLine = sizeof(szNewLine)-1;

		char szRenameLine[1024];
		int cchRenameLine = wsprintfA(szRenameLine,
#ifdef UNICODE
	  "%ls=%ls\r\n",
#else
	  "%hs=%hs\r\n",
#endif
	  (strNewFile.TextSize() == 0) ? TEXT("NUL") : (const ICHAR*)strNewFile, (const ICHAR*)strExistingFile);
	  char szRenameSec[] = "[Rename]\r\n";
	  int cchRenameSec = sizeof(szRenameSec) - 1;
	  HANDLE hfile, hfilemap;
	  TCHAR szPathnameWinInit[MAX_PATH];

	  // Construct the full pathname of the WININIT.INI file.
	  MsiGetWindowsDirectory(szPathnameWinInit, MAX_PATH);
	  IStrCat(szPathnameWinInit, __TEXT("\\WinInit.Ini"));

	  // Open/Create the WININIT.INI file.
	  hfile = CreateFile(szPathnameWinInit,
		 GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
		 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

		if(hfile != INVALID_HANDLE_VALUE)
		{
			MsiRegisterSysHandle(hfile);
			DWORD dwFileSize = GetFileSize(hfile,NULL);
			hfilemap = CreateFileMapping(hfile, NULL, PAGE_READWRITE, 0, dwFileSize+1+cchNewLine, NULL);

			if (hfilemap != NULL)
			{
				MsiRegisterSysHandle(hfilemap);
				// Map the WININIT.INI file into memory.  Note: The contents
				// of WININIT.INI are always ANSI; never Unicode.
				char* pszWinInit = (char*) MapViewOfFile(hfilemap, FILE_MAP_WRITE, 0, 0, 0);

				if (pszWinInit != NULL && !IsBadWritePtr(pszWinInit,dwFileSize))
				{
					// normalize the file with a newline combo at the end.
					if (dwFileSize < cchNewLine ||
						 0 != memcmp(pszWinInit + (dwFileSize - cchNewLine), szNewLine, cchNewLine))
					{
						memcpy(pszWinInit + dwFileSize, szNewLine, cchNewLine);
						dwFileSize += cchNewLine;
					}

					pszWinInit[dwFileSize] = 0; // null-terminate so strstr won't go past the end
														 // this is safe since we create file map of size dwFileSize+1

					// Search for the [Rename] section in the file.
					// need to use MsiString to perform case-insensitive search
					MsiString strWininit = *pszWinInit;
					int cchRenameSecInFile = strWininit.Compare(iscWithinI,szRenameSec);
					if (cchRenameSecInFile)
					{
						// We found the [Rename] section
						char* pszRenameSecInFile = pszWinInit + cchRenameSecInFile - 1;

						char* szNextSection = strchr(pszRenameSecInFile+1,'[');
						char* pszRenameLineInFile = strstr(pszRenameSecInFile, szRenameLine);
						if(pszRenameLineInFile && (!szNextSection || pszRenameLineInFile < szNextSection))
						{
							// found the line in the [Rename] section
							// find the start of the line
							memmove((void*)pszRenameLineInFile,(void*)(pszRenameLineInFile+(INT_PTR)cchRenameLine),     //--merced: added (INT_PTR)
									  dwFileSize - (pszRenameLineInFile - pszWinInit) - cchRenameLine);
							dwFileSize -= cchRenameLine;
						}
					}

				}
				if(pszWinInit)
					AssertNonZero(WIN::UnmapViewOfFile(pszWinInit));
				AssertNonZero(MsiCloseSysHandle(hfilemap));
			}

			// Force the end of the file to be the new calculated size.
			WIN::SetFilePointer(hfile, dwFileSize, NULL, FILE_BEGIN);
			AssertNonZero(WIN::SetEndOfFile(hfile));
			AssertNonZero(MsiCloseSysHandle(hfile));
		}
#endif //UNICODE-ANSI
   }
	else // NT
	{
		MsiString strExistingFileEntry = MsiString(*TEXT("??\\")) + strExistingFile;
		MsiString strNewFileEntry;
		if(strNewFile.TextSize())
			strNewFileEntry = MsiString(*TEXT("??\\")) + strNewFile;

		// remove entry from registry
		HKEY hKey;
		//!! eugend: there's an error here waiting to happen if szSessionManager
		// key ever gets redirected/replicated on Win64: if this code is
		// run in a 32-bit process, it will attempt to open the 32-bit copy
		// of the key, whereas the 64-bit process will open the 64-bit one.
		LONG lRes = RegOpenKeyAPI(HKEY_LOCAL_MACHINE, szSessionManagerKey, 0, KEY_READ|KEY_WRITE, &hKey);
		if(lRes != ERROR_SUCCESS)
			return iesSuccess; // not a fatal error

		CTempBuffer<ICHAR, 200> rgBuffer;
		DWORD dwType, dwSize = 200;

		lRes = RegQueryValueEx(hKey,szPendingFileRenameOperationsValue,
									  0,&dwType,(LPBYTE)(ICHAR*)rgBuffer,&dwSize);
		if(lRes == ERROR_MORE_DATA)
		{
			rgBuffer.SetSize(dwSize);
			lRes = RegQueryValueEx(hKey,szPendingFileRenameOperationsValue,
										  0,&dwType,(LPBYTE)(ICHAR*)rgBuffer,&dwSize);
		}
		if(lRes != ERROR_SUCCESS)
		{
			RegCloseKey(hKey);
			return iesSuccess; // not a fatal error
		}

		ICHAR* pch = rgBuffer; // pointer to move around data
		unsigned int cchTotal = dwSize/sizeof(ICHAR);
		ICHAR* pchEndOfBuffer = (ICHAR*)rgBuffer+cchTotal;
	
		MsiString strFirstEntry, strSecondEntry;
		int cch=0;
		for(;;)
		{
			strFirstEntry = ((const ICHAR&)*pch);
			if(!strFirstEntry.TextSize())
			{
				// we have reached the end of the entries
				Assert((pch - (ICHAR*)rgBuffer) == cchTotal);
				break;
			}
			if(strFirstEntry.Compare(iscEndI, strExistingFileEntry))
			{
				// first in pair matches, check next entry
				cch = IStrLen(pch)+1;
				if((pch - (ICHAR*)rgBuffer + cch) >= (cchTotal - 1))
					break;
				strSecondEntry = (const ICHAR&)*(pch+cch);
				if(((strSecondEntry.TextSize() == 0) && (strNewFileEntry.TextSize() == 0)) ||
					  strSecondEntry.Compare(iscEndI, strNewFileEntry))
				{
					// found it!  now delete these two entries
					// get the size of the two entries combined
					int cchEntries = strFirstEntry.TextSize()+strSecondEntry.TextSize()+2;
					// move up the data past the two entries

					ICHAR* pchEndOfEntries = pch+cchEntries;
					Assert((UINT_PTR) (pchEndOfBuffer-pchEndOfEntries) <= UINT_MAX);    //--merced: we typecast below to uint, it better be in range
					memmove((void*)pch, pchEndOfEntries, (unsigned int)(pchEndOfBuffer-pchEndOfEntries)*sizeof(ICHAR));     //--merced: added (unsigned int)

					// write value back
					RegSetValueEx(hKey,szPendingFileRenameOperationsValue,0,REG_MULTI_SZ,
									  (LPBYTE)(ICHAR*)rgBuffer,(cchTotal-cchEntries)*sizeof(ICHAR));  // nothing we can do if this fails
					break;
				}
			}
			// done checking this pair, go to next pair
			// move pch to next pair - be sure not to advance past buffer
			cch = IStrLen(pch)+1;
			if((pch - (ICHAR*)rgBuffer + cch) >= (cchTotal - 1))
				break;
			pch += cch;
			cch = IStrLen(pch)+1;
			if((pch - (ICHAR*)rgBuffer + cch) >= (cchTotal - 1))
				break;
			pch += cch;
		}
		RegCloseKey(hKey);
	}
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfFolderCreate(IMsiRecord& riParams)
{
	using namespace IxoFolderCreate;
	PMsiPath pPath(0);
	PMsiRecord pError(m_riServices.CreatePath(riParams.GetString(IxoFolderCreate::Folder), *&pPath));
	if (pError)  // happens only if invalid systax, retry won't help
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	IMsiRecord& riActionData = GetSharedRecord(1);
	AssertNonZero(riActionData.SetMsiString(1,*MsiString(pPath->GetPath())));
	if(Message(imtActionData,riActionData) == imsCancel)
		return iesUserExit;

	Bool fForeign = riParams.GetInteger(Foreign) == 1 ? fTrue : fFalse;

	iesEnum iesRet = iesNoAction;
	if((iesRet = CreateFolder(*pPath, fForeign, fTrue, PMsiStream((IMsiStream*) riParams.GetMsiData(SecurityDescriptor)))) != iesSuccess)
		return iesRet;
	
	// generate undo operation
	IMsiRecord& riUndoParams = GetSharedRecord(IxoFolderRemove::Args);
	riUndoParams.SetMsiString(IxoFolderRemove::Folder, *MsiString(riParams.GetMsiString(IxoFolderCreate::Folder)));
	riUndoParams.SetInteger(IxoFolderRemove::Foreign, fForeign ? 1 : 0);
	if (!RollbackRecord(ixoFolderRemove,riUndoParams))
		return iesFailure;

	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfFolderRemove(IMsiRecord& riParams)
{
	using namespace IxoFolderRemove;
	PMsiPath pPath(0);
	PMsiRecord pError(m_riServices.CreatePath(riParams.GetString(IxoFolderRemove::Folder), *&pPath));
	if (pError)
	{
		// happens only if invalid systax, retry won't help
		Message(imtWarning, *pError);
		return iesFailure; //!!
	}
		
	IMsiRecord& riActionData = GetSharedRecord(1);
	AssertNonZero(riActionData.SetMsiString(1,*MsiString(pPath->GetPath())));
	if(Message(imtActionData,riActionData) == imsCancel)
		return iesUserExit;

	Bool fForeign = (riParams.GetInteger(Foreign) == 1) ? fTrue : fFalse;

	// determine what folders actually exist before we remove
	PMsiPath pPath2(0);
	pError = m_riServices.CreatePath(riParams.GetString(IxoFolderRemove::Folder), *&pPath2);
	if (pError)
	{
		// happens only if invalid systax, retry won't help
		Message(imtWarning, *pError);
		return iesFailure; //!!
	}

	Bool fExists = fFalse;
	MsiString strSubPath;
	for(;;)
	{
		strSubPath = pPath2->GetEndSubPath();
		if(strSubPath.TextSize() == 0)
		{
			// no sub path, just volume - no rollback necessary
			break;
		}
		
		if((pError = pPath2->Exists(fExists)) != 0)
		{
			Message(imtWarning, *pError);
			return iesFailure; //!!
		}

		if(fExists == fTrue || fForeign)
			break;  // folder exists, this is the folder we put in the rollback script to re-create
		else
			AssertRecord(pPath2->ChopPiece());
	}

	// even if there is no folder to remove, we may still need to unregister the folders
	// so call RemoveFolder even if fExists = fFalse
	iesEnum iesRet = iesNoAction;

	PMsiStream piSD(0);

	bool fFolderSupportsACLs = (PMsiVolume(&pPath2->GetVolume())->FileSystemFlags() & FS_PERSISTENT_ACLS) != 0;
	
	if (fFolderSupportsACLs)
	{
		if ((pError = pPath2->GetSelfRelativeSD(*&piSD)) != 0)
		{
			return FatalError(*pError);
		}
	}

	if((iesRet = RemoveFolder(*pPath, fForeign, fTrue)) != iesSuccess)
		return iesRet;
	
	// generate undo operation
	if(fExists)
	{
		IMsiRecord& riUndoParams = GetSharedRecord(IxoFolderCreate::Args);
		AssertNonZero(riUndoParams.SetMsiString(IxoFolderCreate::Folder, *MsiString(pPath2->GetPath())));
		AssertNonZero(riUndoParams.SetInteger(Foreign, fForeign ? 1 : 0));
		AssertNonZero(riUndoParams.SetMsiData(IxoFolderCreate::SecurityDescriptor,piSD));
		if (!RollbackRecord(ixoFolderCreate,riUndoParams))
			return iesFailure;
	}

	return iesSuccess;
}

Bool CMsiOpExecute::FFileExists(IMsiPath& riPath, const IMsiString& ristrFile)
{
	PMsiRecord pError(0);
	Bool fExists = fFalse;
	if(((pError = riPath.FileExists(ristrFile.GetString(),fExists)) != 0) || fExists == fFalse)
		return fFalse;
	else
		return fTrue;
}


iesEnum CMsiOpExecute::GetSecurityDescriptor(const ICHAR* szFile, IMsiStream*& rpiSecurityDescriptor)
{
	bool fNetPath = FIsNetworkVolume(szFile);
	rpiSecurityDescriptor = 0;

	if (!g_fWin9X && !fNetPath)
	{
		CElevate elevate; // so we can always read the security info

		CTempBuffer<char, 3072> rgchFileSD;
		DWORD cbFileSD = 3072;

		// reads a self-relative security descriptor
		if (!ADVAPI32::GetFileSecurity(szFile,OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION|DACL_SECURITY_INFORMATION|SACL_SECURITY_INFORMATION,
				(PSECURITY_DESCRIPTOR) rgchFileSD, cbFileSD, &cbFileSD))
		{
			DWORD dwLastError = WIN::GetLastError();
			BOOL fRet = FALSE;
			if (ERROR_INSUFFICIENT_BUFFER == dwLastError)
			{
				rgchFileSD.SetSize(cbFileSD);
				fRet = ADVAPI32::GetFileSecurity(szFile,OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION|DACL_SECURITY_INFORMATION|SACL_SECURITY_INFORMATION,
					(PSECURITY_DESCRIPTOR) rgchFileSD, cbFileSD, &cbFileSD);
			}
			if (!fRet)
			{
				PMsiRecord pRecord = PostError(Imsg(imsgGetFileSecurity), GetLastError(), szFile);
				return FatalError(*pRecord);
			}
		}

		Assert(IsValidSecurityDescriptor((PSECURITY_DESCRIPTOR) rgchFileSD));
		DWORD dwLength = GetSecurityDescriptorLength((PSECURITY_DESCRIPTOR) rgchFileSD);
	
		char* pbstrmSD = m_riServices.AllocateMemoryStream(dwLength, rpiSecurityDescriptor);
		Assert(pbstrmSD);
		memcpy(pbstrmSD, rgchFileSD, dwLength);
	}
	return iesSuccess;
}

// patching operations

/*---------------------------------------------------------------------------
ixoPatchApply: applies a patch to file in m_pTargetPath with m_pFilePatch
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfPatchApply(IMsiRecord& riParams)
{
	using namespace IxoPatchApply;
	PMsiRecord pError(0);
	iesEnum iesRet = iesNoAction;
	
	if(!m_state.pFilePatch)
	{
		// create FilePatch object
		if((pError = m_riServices.CreatePatcher(*&(m_state.pFilePatch))) != 0)
		{
			Message(imtError,*pError);
			return iesFailure;
		}
	}
	Assert(m_state.pFilePatch);

	// the following steps may be taken by this operation:
	//
	// 1) file is already up-to-date, or newer than what would be patched to
	//     determined: FileState contains no icfsPatchFile bit
	//     action:     do nothing
	//
	// 2) file was NOT copied by previous ixoFileCopy, or patched by previous ixoFilePatch
	//    also, this is NOT the last patch for this file
	//     determined: FileState contains no temporary file path, cRemainingPatches > 1
	//     action:     patch against target file, mark output file as new temporary file
	//
	// 3) file was NOT copied by previous ixoFileCopy, or patched by previous ixoFilePatch
	//    also, this IS the last patch for this file
	//     determined: FileState contains no temporary file path, cRemainingPatches == 1
	//     action:     patch against target file, copy over target file
	//
	// 4) file was copied by previous ixoFileCopy, or patched by previous ixoFilePatch
	//    also, this is NOT the last patch for this file
	//     determined: FileState contains temporary file path
	//     action:     patch against temp file, delete old temp file, mark output file as new temporary file
	//
	// 5) file was copied by previous ixoFileCopy, or patched by previous ixoFilePatch
	//    also, this IS the last patch for this file
	//     determined: FileState contains temporary file path
	//     action:     patch against temp file, delete old temp file, copy over target file

	
	// file to apply patch against
	PMsiPath pPatchTargetPath(0);
	MsiString strPatchTargetFileName;

	// file to overwrite with resultant file after patch
	PMsiPath pCopyTargetPath(0);
	MsiString strCopyTargetFileName = riParams.GetMsiString(TargetName);

	if(PathType(strCopyTargetFileName) == iptFull)
	{
		MsiString strTemp;
		if((pError = m_riServices.CreateFilePath(strCopyTargetFileName,*&pCopyTargetPath,*&strTemp)) != 0)
			return FatalError(*pError);
		strCopyTargetFileName = strTemp;
	}
	else
	{
		if(!m_state.pTargetPath)
		{  // must not have called ixoSetTargetFolder
			DispatchError(imtError, Imsg(idbgOpOutOfSequence),
							  *MsiString(*TEXT("ixoPatchApply")));
			return iesFailure;
		}

		pCopyTargetPath = m_state.pTargetPath;
	}

	// by default, the file to apply patch against and the file to overwrite are the same
	// but the file to apply patch against may be changed below
	pPatchTargetPath = pCopyTargetPath;
	strPatchTargetFileName = strCopyTargetFileName;
	
	// get any cached state for the target file
	MsiString strCopyTargetFilePath;
	if((pError = pCopyTargetPath->GetFullFilePath(strCopyTargetFileName,*&strCopyTargetFilePath)) != 0)
		return FatalError(*pError);
	
	MsiString strPatchTargetFilePath = strCopyTargetFilePath;

	icfsEnum icfsFileState = (icfsEnum)0;
	MsiString strTempLocation;
	int cRemainingPatches = 0;
	int cRemainingPatchesToSkip = 0;
	Bool fRes = GetFileState(*strCopyTargetFilePath, &icfsFileState, &strTempLocation, &cRemainingPatches, &cRemainingPatchesToSkip);

	if(!fRes || !(icfsFileState & icfsPatchFile))
	{
		// don't patch file
		DEBUGMSG1(TEXT("Skipping all patches for file '%s'.  File does not need to be patched."),
					 (const ICHAR*)strCopyTargetFilePath);
		return iesSuccess;
	}

	Assert(cRemainingPatches > 0);

	if(cRemainingPatchesToSkip > 0)
	{
		// skip this patch, but reset cached file state first
		cRemainingPatches--;
		cRemainingPatchesToSkip--;

		DEBUGMSG3(TEXT("Skipping this patch for file '%s'.  Number of remaining patches to skip for this file: '%d'.  Number of total remaining patches: '%d'."),
					 (const ICHAR*)strCopyTargetFilePath, (const ICHAR*)(INT_PTR)cRemainingPatchesToSkip, (const ICHAR*)(INT_PTR)cRemainingPatches);

		if((pError = CacheFileState(*strCopyTargetFilePath, 0, 0, 0, &cRemainingPatches, &cRemainingPatchesToSkip)) != 0)
			return FatalError(*pError);

		return iesSuccess;
	}
	
	if(strTempLocation.TextSize())
	{
		// file was actually copied to temp location.  this is the copy we want to apply the patch against
		DEBUGMSG2(TEXT("Patch for file '%s' is redirected to patch '%s' instead."),
					 (const ICHAR*)strCopyTargetFilePath,(const ICHAR*)strTempLocation);
		if((pError = m_riServices.CreateFilePath(strTempLocation,*&pPatchTargetPath,*&strPatchTargetFileName)) != 0)
			return FatalError(*pError);
	
		strPatchTargetFilePath = strTempLocation;
	}

	unsigned int cbFileSize = riParams.GetInteger(TargetSize);
	bool fVitalFile = (riParams.GetInteger(FileAttributes) & msidbFileAttributesVital) != 0;
	bool fVitalPatch = (riParams.GetInteger(PatchAttributes) & msidbPatchAttributesNonVital) == 0;

	// dispatch ActionData message
	IMsiRecord& riActionData = GetSharedRecord(3);
	AssertNonZero(riActionData.SetMsiString(1, *strCopyTargetFileName));
	AssertNonZero(riActionData.SetMsiString(2, *MsiString(pCopyTargetPath->GetPath())));
	AssertNonZero(riActionData.SetInteger(3, cbFileSize));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;
	
	PMsiPath pTempFolder(0);
	if((iesRet = GetBackupFolder(pPatchTargetPath, *&pTempFolder)) != iesSuccess)
		return iesRet;

	MsiString strOutputFileName;
	MsiString strOutputFileFullPath;
	if((iesRet = ApplyPatchCore(*pPatchTargetPath, *pTempFolder, *strPatchTargetFileName,
										 riParams, *&strOutputFileName, *&strOutputFileFullPath)) != iesSuccess)
	{
		return iesRet;
	}

	MsiString strNewTempLocation;
	if(iesRet == iesSuccess)
	{
		if(cRemainingPatches > 1)
		{
			// there is at least one more patch to be done on this file
			// therefor we will reset the temporary name for this file to be the patch output file
			// but won't overwrite the original file yet
			strNewTempLocation = strOutputFileFullPath;
		}
		else
		{
			// this is the last patch - time to finally overwrite the original file
			
			// we always need to handle rollback.  we wouldn't if a previous filecopy operation wrote to the same
			// target that we are copying over now, but that should never happen since when patching will happen
			// filecopy should be writing to an intermediate file
			Assert(strTempLocation.TextSize() || (icfsFileState & icfsFileNotInstalled));

			// get acl for file after its moved
			// if existing file, use existing acl.
			// otherwise create a temp file and grab acl from it (yes, its ugly)
			PMsiStream pSecurityDescriptor(0);
			if(!g_fWin9X)
			{
				MsiString strFileForACL;
				bool fTempFileForACL = false;
				if(FFileExists(*pCopyTargetPath, *strCopyTargetFileName))
				{
					strFileForACL = strCopyTargetFilePath;
				}
				else
				{
					if((iesRet = CreateFolder(*pCopyTargetPath)) != iesSuccess)
						return iesRet;

					if((pError = pCopyTargetPath->TempFileName(TEXT("PT"),0,fFalse,*&strFileForACL, 0 /* use default ACL for folder*/)) != 0)
						return FatalError(*pError);

					fTempFileForACL = true;
				}

				CSecurityDescription security(strFileForACL);

				if(fTempFileForACL)
					AssertNonZero(WIN::DeleteFile(strFileForACL));

				if (!security.isValid())
				{
					return FatalError(*PMsiRecord(PostError(Imsg(imsgGetFileSecurity), WIN::GetLastError(), strFileForACL)));
				}

				security.SecurityDescriptorStream(m_riServices, *&pSecurityDescriptor);
			}

			// move output file over target file - handles file in use case
			iesRet = CopyOrMoveFile(*pTempFolder, *pCopyTargetPath, *strOutputFileName, *strCopyTargetFileName, fTrue, fTrue,
				fTrue, fVitalFile ? iehShowNonIgnorableError : iehShowIgnorableError, pSecurityDescriptor, ielfElevateSource);

			if ( iesRet == iesSuccess && 
				  riParams.GetInteger(CheckCRC) != iMsiNullInteger && 
				  riParams.GetInteger(CheckCRC) )
			{
				imsEnum imsClickedButton;
				if ( !IsChecksumOK(*pCopyTargetPath, *strCopyTargetFileName,
										 Imsg(imsgOpBadCRCAfterPatch), &imsClickedButton,
										 /* fErrorDialog = */ true, fVitalFile, /* fRetryButton = */ false) )
				{
					switch (imsClickedButton)
					{
						case imsIgnore:
							iesRet = (iesEnum)iesErrorIgnored;
							break;
						case imsCancel:
							iesRet = iesUserExit;
							break;
						default:
							Assert(imsClickedButton == imsNone || imsClickedButton == imsOk);
							iesRet = fVitalFile ? iesFailure : (iesEnum)iesErrorIgnored;
							break;
					};
				}
			}
		}
	}
	else
	{
		CElevate elevate;
		// remove output file if failure
		if((pError = pTempFolder->RemoveFile(strOutputFileName)) != 0) // non-critical error
		{
			Message(imtInfo,*pError);
		}

		if(fVitalPatch == false)
		{
			// failed to apply vital patch - return success to allow script to continue
			iesRet = iesSuccess;
		}
	}

	// if we patched a temp file, remove that file
	if(strTempLocation.TextSize())
	{
		if((pError = pPatchTargetPath->RemoveFile(strPatchTargetFileName)) != 0) // non-critical error
		{
			Message(imtInfo,*pError);
		}
	}

	// reset cached file state
	// one fewer remaining patch now, and we may either have a new temporary location, or no temporary location
	cRemainingPatches--;
	Assert(cRemainingPatchesToSkip == 0);
	if((pError = CacheFileState(*strCopyTargetFilePath, 0, strNewTempLocation, 0, &cRemainingPatches, 0)) != 0)
		return FatalError(*pError);

	return iesRet;
}

iesEnum CMsiOpExecute::TestPatchHeaders(IMsiPath& riPath, const IMsiString& ristrFile, IMsiRecord& riParams,
													 icpEnum& icpResult, int& iPatch)
{
	// assumes the target file exists - don't call if it doesn't
	using namespace IxoFileCopy;
	PMsiRecord pError(0);
	iesEnum iesRet = iesNoAction;
	
	MsiString strTargetFilePath;
	if((pError = riPath.GetFullFilePath(ristrFile.GetString(), *&strTargetFilePath)) != 0)
		return FatalError(*pError);
	
	if(!m_state.pFilePatch)
	{
		// create FilePatch object
		if((pError = m_riServices.CreatePatcher(*&(m_state.pFilePatch))) != 0)
		{
			Message(imtError,*pError);
			return iesFailure;
		}
	}
	Assert(m_state.pFilePatch);

	int cHeaders = riParams.IsNull(TotalPatches) ? 0 : riParams.GetInteger(TotalPatches);

	if(cHeaders == 0)
		return iesSuccess;

	int iHeadersStart = riParams.IsNull(PatchHeadersStart) ? 0 : riParams.GetInteger(PatchHeadersStart);
	int iLastHeader = iHeadersStart + cHeaders - 1;
	
	icpResult = icpCannotPatch;
	iPatch = 1;
	for(int i = iHeadersStart; i <= iLastHeader; i++, iPatch++)
	{
		//!! should be able to pass memory pointer to CanPatchFile rather than extracting file from script
		MsiString strTempName;
		if((pError = riPath.TempFileName(0, 0,fTrue, *&strTempName, &CSecurityDescription(strTargetFilePath))) != 0)
		{
			// telling the user about the temporary file being unwritable isn't useful,
			// the real problem is that the original file is unwritable due to its security
			// settings.
			if (imsgErrorWritingToFile == (pError->GetInteger(1)))
			{
				pError->SetMsiString(2, *strTargetFilePath);
			}
		
			return FatalError(*pError);
		}
		
		if((iesRet = CreateFileFromData(riPath,*strTempName,PMsiData(riParams.GetMsiData(i)), 0)) != iesSuccess)
			return iesRet;
	
		if((pError = m_state.pFilePatch->CanPatchFile(riPath,ristrFile.GetString(),riPath,strTempName,icpResult)) != 0)
			return FatalError(*pError);

		RemoveFile(riPath,*strTempName,fFalse,/*fBypassSFC*/ false,false);
		
		if(icpResult == icpCanPatch)
		{
			// can patch file with this patch, assume remaining patches will work also
			break;
		}
	}
	
	// icpResult will either be:
	//    icpCanPatch: file can be patched with patch iPatch, assume that remaining patches will work as well
	//    icpCannotPatch: file could not be patched by any patches
	//    icpUpToDate: file already up to date by all patches
	
	return iesSuccess;
}

bool CMsiOpExecute::PatchHasClients(const IMsiString& ristrPatchCode, const IMsiString& ristrUpgradingProductCode)
{
	Assert(ristrPatchCode.TextSize());
	
	// check if any product currently has this patch registered.  If not, unregister global patch info
	
	// product defined by UpgradingProductCode may not be installed yet but may still
	// require the global patch registration.  If it is not yet installed, skip patch unregistration
	INSTALLSTATE is = INSTALLSTATE_UNKNOWN;
	if(ristrUpgradingProductCode.TextSize() &&
		((is = MsiQueryProductState(ristrUpgradingProductCode.GetString())) != INSTALLSTATE_DEFAULT) &&
		(is != INSTALLSTATE_ADVERTISED))
	{
		return true;
	}
	else
	{
		PMsiRecord pError(0);
		ICHAR rgchBuffer[MAX_PATH];
		MsiString strPatchCodeSQUID =  GetPackedGUID(ristrPatchCode.GetString());
		PMsiRegKey pRootKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hKey, ibtCommon);        //--merced: changed (int) to (INT_PTR)
		PMsiRegKey pProductsKey = &pRootKey->CreateChild(_szGPTProductsKey);

		rgchBuffer[0] = 0;
		int iIndex = 0;

		ICHAR rgchProductKey[cchProductCode + 1];
		while(MsiEnumProducts(iIndex,rgchProductKey) == ERROR_SUCCESS)
		{
			iIndex++;
			if(MsiString(GetProductKey()).Compare(iscExact,rgchProductKey))
				continue; // skip check if this product
			
			AssertNonZero(PackGUID(rgchProductKey, rgchBuffer));
			IStrCat(rgchBuffer+IStrLen(rgchBuffer), TEXT("\\") szPatchesSubKey);
			PMsiRegKey pPatchesKey = &pProductsKey->CreateChild(rgchBuffer);
			Bool fExists;
			if(((pError = pPatchesKey->ValueExists(strPatchCodeSQUID, fExists)) == 0) && fExists == fTrue)
			{
				return true;
			}
		}
	}
	return false;
}

iesEnum CMsiOpExecute::ProcessPatchRegistration(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoPatchRegister;
	
	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;
	ICHAR rgchBuffer[MAX_PATH];

	MsiString strPatchCode = riParams.GetMsiString(PatchId);
	if(!strPatchCode.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpInvalidParam),fRemove ? TEXT("ixfPatchUnregister") : TEXT("ixoPatchRegister"), PatchId);
		return iesFailure;
	}
	
	const ICHAR* szSourceList = 0;
	const ICHAR* szTransformList = 0;
	if(fRemove == fFalse)
	{
		szTransformList = riParams.GetString(TransformList);
		if(!szTransformList || !*szTransformList)
		{
			DispatchError(imtError,Imsg(idbgOpInvalidParam),fRemove ? TEXT("ixfPatchUnregister") : TEXT("ixoPatchRegister"), TransformList);
			return iesFailure;
		}
	}
	
	// per-product patch registration

	PMsiStream pSecurityDescriptor(0);
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	MsiString strProductKeySQUID = GetPackedGUID(MsiString(GetProductKey()));
	MsiString strPatchCodeSQUID =  GetPackedGUID(strPatchCode);
	const ICHAR* rgszPerUserProductPatchRegData[] =
	{
		TEXT("%s\\%s\\%s"), _szGPTProductsKey, strProductKeySQUID, szPatchesSubKey,
		szPatchesValueName,  strPatchCodeSQUID,  g_szTypeMultiSzStringSuffix,
		strPatchCodeSQUID,   szTransformList,    g_szTypeString,
		0,
		0,
	};

	{
		CElevate elevate;
		if((iesRet = ProcessRegInfo(rgszPerUserProductPatchRegData, m_hKey, fRemove,
											 pSecurityDescriptor, 0, ibtCommon)) != iesSuccess)
			return iesRet;
	}

	if(fRemove &&
		false == PatchHasClients(*strPatchCode,
										*MsiString(riParams.GetMsiString(IxoPatchUnregister::UpgradingProductCode))))
	{
		// remove per-machine patch registration (this information is written by ixoPatchCache)
		// delete patch package if it exists

		MsiString strLocalPatchKey;
		if((pError = GetInstalledPatchesKey(strPatchCode, *&strLocalPatchKey)) != 0)
			return FatalError(*pError);
		
		PMsiRegKey pHKLM = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hUserDataKey, ibtCommon);
		PMsiRegKey pPatchKey = &pHKLM->CreateChild(strLocalPatchKey);
		
		MsiString strPackagePath;
		pError = pPatchKey->GetValue(szLocalPackageValueName,*&strPackagePath);
		if(pError == 0) // ignore failure
		{
			PMsiPath pPackagePath(0);
			MsiString strPackageName;
		
			// schedule file for deletion once we let go of install packages/transforms
			if(iesSuccess != DeleteFileDuringCleanup(strPackagePath, false))
			{
				DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove), *strPackagePath);
			}
				
			// remove per-machine patch information
			// ProcessRegInfo handles rollback
			const ICHAR* rgszPerMachinePatchRegData[] =
			{
				TEXT("%s"), strLocalPatchKey, 0, 0,
				szLocalPackageValueName, strPackagePath,  g_szTypeString,
				0,
				0,
			};

			{
				CElevate elevate;
				if((iesRet = ProcessRegInfo(rgszPerMachinePatchRegData, m_hUserDataKey, fRemove,
													 pSecurityDescriptor, 0, ibtCommon)) != iesSuccess)
					return iesRet;
			}
		}
	}
	return iesRet;
}

iesEnum CMsiOpExecute::ixfPatchRegister(IMsiRecord& riParams)
{
	return ProcessPatchRegistration(riParams,fFalse);
}

iesEnum CMsiOpExecute::ixfPatchUnregister(IMsiRecord& riParams)
{
	return ProcessPatchRegistration(riParams,fTrue);
}

iesEnum CMsiOpExecute::ixfPatchCache(IMsiRecord& riParams)
{
	using namespace IxoPatchCache;
	
	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;

	MsiString strPatchCode = riParams.GetMsiString(PatchId);
	MsiString strPatchCodeSQUID = GetPackedGUID(strPatchCode);
	if(!strPatchCodeSQUID.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpInvalidParam), TEXT("ixfPatchCache"), PatchId);
		return iesFailure;
	}

	MsiString strPatchPath = riParams.GetMsiString(PatchPath);
	if(!strPatchPath.TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpInvalidParam), TEXT("ixfPatchCache"), PatchId);
		return iesFailure;
	}

	// Generate a unique name for patch

	PMsiPath pSourcePath(0), pDestPath(0);
	MsiString strSourceName, strDestName, strCachedPackagePath;

	if((pError = m_riServices.CreateFilePath(strPatchPath,*&pSourcePath,*&strSourceName)) != 0)
		return FatalError(*pError);

	CElevate elevate; // elevate for remainder of function

	MsiString strMsiDirectory = GetMsiDirectory();
	Assert(strMsiDirectory.TextSize());

	if (((pError = m_riServices.CreatePath(strMsiDirectory, *&pDestPath)) != 0) ||
		((pError = pDestPath->EnsureExists(0)) != 0) ||
		((pError = pDestPath->TempFileName(0, szPatchExtension, fTrue, *&strDestName, 0)) != 0)
		)
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	// remove temp file so that CopyOrMoveFile won't attempt to back up old file
	if((pError = pDestPath->RemoveFile(strDestName)) != 0)
		return FatalError(*pError);

	PMsiStream pSecurityDescriptor(0);
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	// move patch package to cached package folder
	if((iesRet = CopyOrMoveFile(*pSourcePath,*pDestPath,*strSourceName,*strDestName,
										 fFalse,fTrue,fTrue,iehShowNonIgnorableError, pSecurityDescriptor)) != iesSuccess)
		return iesRet;

	// register local package path
	if((pError = pDestPath->GetFullFilePath(strDestName,*&strCachedPackagePath)) != 0)
		return FatalError(*pError);

	MsiString strLocalPatchKey;
	if((pError = GetInstalledPatchesKey(strPatchCode, *&strLocalPatchKey)) != 0)
		return FatalError(*pError);

	const ICHAR* rgszPerMachinePatchRegData[] =
	{
		TEXT("%s"), strLocalPatchKey, 0, 0,
		szLocalPackageValueName, strCachedPackagePath, g_szTypeString,
		0,
		0,
	};

	return ProcessRegInfo(rgszPerMachinePatchRegData, m_hUserDataKey, fFalse,
								 pSecurityDescriptor, 0, ibtCommon);
}


Bool CMsiOpExecute::ReplaceFileOnReboot(const ICHAR* pszExisting, const ICHAR* pszNew)
/*----------------------------------------------------------------------------
Local function that replaces or deletes an existing file on reboot.  Most
useful for replacing or deleting a file that is in-use at the time of install.
To delete a file on reboot, pass NULL for pszNew.

Returns:
	fTrue if the function is successful.

Original source: MSJ 1/96

NOTE: it is assumed that the proper access checks have been made on NT
	  before calling this function.  we do not want to schedule a file for
		delete or rename that the user doesn't have access to since that is
		done with system priviledges and we elevate before calling MoveFileEx
----------------------------------------------------------------------------*/
{
	Bool fDelete = (pszNew == 0 || *pszNew == 0) ? fTrue : fFalse;
	// generate the undo operation for this
	using namespace IxoFileUndoRebootReplace;
	PMsiRecord pUndoParams = &m_riServices.CreateRecord(Args);
	
	if(fDelete)
		DispatchError(imtInfo, Imsg(imsgOpDeleteFileOnReboot), *MsiString(pszExisting));
	else
		DispatchError(imtInfo, Imsg(imsgOpMoveFileOnReboot), *MsiString(pszExisting), *MsiString(pszNew));

	// on NT we use the MoveFileEx function.
	if(g_fWin9X == false)
	{
		CElevate elevate; // assume this is safe - access checks made already
		
		if(MoveFileEx(pszExisting, pszNew, MOVEFILE_DELAY_UNTIL_REBOOT))
		{
			AssertNonZero(pUndoParams->SetString(ExistingFile,pszExisting));
			AssertNonZero(pUndoParams->SetString(NewFile,pszNew));
			AssertNonZero(pUndoParams->SetInteger(Type,1));
			if (!RollbackRecord(ixoFileUndoRebootReplace, *pUndoParams))
				return fFalse;

			if(fDelete == fFalse) // don't reboot when removing file
				m_fRebootReplace = fTrue;
			return fTrue;
		}
		else
			return fFalse;
	}

	// on Win9X we write to the wininit.ini file
	
	// get short names of files - wininit.ini processed in DOS, LFN doesn't work
	CTempBuffer<ICHAR,MAX_PATH> rgchNewFile;
	CTempBuffer<ICHAR,MAX_PATH> rgchExistingFile;
	
	DWORD dwSize = 0;
	int cchFile = 0;
	if(pszNew && *pszNew)
	{
		if(ConvertPathName(pszNew,rgchNewFile, cpToShort) == fFalse)
		{
			// if GetShortPathName fails, use path we already have
			// this is to handle non-existent files - see bug 8721
			// FUTURE: chop off filename and get short path of folder
			rgchNewFile.SetSize(IStrLen(pszNew)+1); // +1 for null terminator
			IStrCopy(rgchNewFile,pszNew);
		}
	}
	else
	{
		rgchNewFile[0] = 0;
	}

	Assert(pszExisting && *pszExisting);
	if(ConvertPathName(pszExisting,rgchExistingFile, cpToShort) == fFalse)
	{
		// if GetShortPathName fails, use path we already have
		// this is to handle non-existent files - see bug 8721
		// FUTURE: chop off filename and get short path of folder
		rgchExistingFile.SetSize(IStrLen(pszExisting)+1); // +1 for null terminator
		IStrCopy(rgchExistingFile,pszExisting);
	}

	AssertNonZero(pUndoParams->SetString(ExistingFile,rgchExistingFile));
	AssertNonZero(pUndoParams->SetString(NewFile,rgchNewFile));
	AssertNonZero(pUndoParams->SetInteger(Type,0));
	if (!RollbackRecord(ixoFileUndoRebootReplace, *pUndoParams))
		return fFalse;

	Bool fOk = fFalse;
	// If MoveFileEx failed, we are running on Windows 95 and need to add
	// entries to the WININIT.INI file (an ANSI file).
	// Start a new scope for local variables.
	{
		//FUTURE:  Combine this and similar section in ixfFileUndoRebootReplace
#ifdef UNICODE
		AssertSz(0, TEXT("unicode build attempting to operate on wininit.ini"));
#else //ANSI

		// the last line of the file should combine a newline combo.
		char szNewLine[] = "\r\n";
		unsigned int cchNewLine = sizeof(szNewLine)-1;

		char szRenameLine[1024];
		int cchRenameLine = wsprintfA(szRenameLine,
#ifdef UNICODE
		"%ls=%ls\r\n",
#else
		"%hs=%hs\r\n",
#endif
		(!pszNew || !*pszNew) ? TEXT("NUL") : (ICHAR*)rgchNewFile, (ICHAR*)rgchExistingFile);
		char szRenameSec[] = "[Rename]\r\n";
		int cchRenameSec = sizeof(szRenameSec) - 1;
		HANDLE hfile, hfilemap;
		DWORD dwFileSize, dwNextSectionLinePos;
		TCHAR szPathnameWinInit[MAX_PATH];

		// Construct the full pathname of the WININIT.INI file.
		MsiGetWindowsDirectory(szPathnameWinInit, MAX_PATH);
		IStrCat(szPathnameWinInit, __TEXT("\\WinInit.Ini"));

		// Open/Create the WININIT.INI file.  We can't use WritePrivateProfileString because that
		// function allows no more than one value of the same name to the left of the "=" in an
		// INI file line - we potentially need a number of "NUL=..." lines.
		hfile = CreateFile(szPathnameWinInit,
		GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

		if (hfile == INVALID_HANDLE_VALUE)
			return(fFalse);

		MsiRegisterSysHandle(hfile);
		// Create a file mapping object that is the current size of
		// the WININIT.INI file plus the length of the additional string
		// that we're about to insert into it plus the length of the section
		// header (which we might have to add), plus adding a newline at the end
		// to normalize the file, if necessary.
		dwFileSize = GetFileSize(hfile, NULL);

		DWORD dwSizeOfMap = dwFileSize + cchRenameLine + cchRenameSec + cchNewLine;
		hfilemap = CreateFileMapping(hfile, NULL, PAGE_READWRITE, 0,
											  dwSizeOfMap, NULL);

		if (hfilemap != NULL)
		{
			MsiRegisterSysHandle(hfilemap);
			// Map the WININIT.INI file into memory.  Note: The contents
			// of WININIT.INI are always ANSI; never Unicode.
			char* pszWinInit = (char*) MapViewOfFile(hfilemap,
			FILE_MAP_WRITE, 0, 0, 0);

			if (pszWinInit != NULL && !IsBadWritePtr(pszWinInit,dwSizeOfMap))
			{

				// normalize the file with a newline combo at the end.
				if (dwFileSize < cchNewLine ||
					 (0 != memcmp(pszWinInit + (dwFileSize - cchNewLine), szNewLine, cchNewLine)))
				{
					memcpy(pszWinInit + dwFileSize, szNewLine, cchNewLine);
					dwFileSize += cchNewLine;
				}

				pszWinInit[dwFileSize] = 0; // null-terminate so strstr won't go past the end
													 // this is safe since dwSizeOfMap > dwFileSize


				// Search for the [Rename] section in the file.
				// need to use MsiString to perform case-insensitive search
				MsiString strWininit = *pszWinInit;
				int cchRenameSecInFile = strWininit.Compare(iscWithinI,szRenameSec);
				if (cchRenameSecInFile == 0)
				{
					// There is no [Rename] section in the WININIT.INI file.
					// We must add the section too.
					dwFileSize += wsprintfA(&pszWinInit[dwFileSize], "%s",
													szRenameSec);
					dwNextSectionLinePos = dwFileSize;

				}
				else
				{
					char* pszRenameSecInFile = pszWinInit + cchRenameSecInFile - 1;

					// We found the [Rename] section, shift the following section
					// (if any) down to make room for our new line at the end
					// of the [Rename] section.
					char* pszNextSectionLine = strchr(pszRenameSecInFile+1, '[');
					if (pszNextSectionLine)
					{

						Assert((UINT_PTR)(pszWinInit + dwFileSize - pszNextSectionLine) <= UINT_MAX
							&& (UINT_PTR)(pszNextSectionLine - pszWinInit));                        //--merced: we typecast below to uint, it better be in range
						memmove(pszNextSectionLine + cchRenameLine, pszNextSectionLine,
							(unsigned int) (pszWinInit + dwFileSize - pszNextSectionLine));         //--merced: added (unsigned int). okay to typecast
						dwNextSectionLinePos = (unsigned int) (pszNextSectionLine - pszWinInit);    //--merced: added (unsigned int). okay to typecast
					}
					else
					{
						dwNextSectionLinePos = dwFileSize;
					}
				}

				// Insert the new line
				memcpy(&pszWinInit[dwNextSectionLinePos], szRenameLine, cchRenameLine);
				dwFileSize += cchRenameLine;
				if(fDelete == fFalse) // don't reboot when removing file
					m_fRebootReplace = fTrue;
				fOk = fTrue;
			}
			if(pszWinInit)
				AssertNonZero(WIN::UnmapViewOfFile(pszWinInit));
			AssertNonZero(MsiCloseSysHandle(hfilemap));
		}

		// Force the end of the file to be the new calculated size.
		SetFilePointer(hfile, dwFileSize, NULL, FILE_BEGIN);
		SetEndOfFile(hfile);

		AssertNonZero(MsiCloseSysHandle(hfile));
#endif //UNICODE-ANSI
	}

	return(fOk);
}


iesEnum CMsiOpExecute::DeleteFileDuringCleanup(const ICHAR* szFile, bool fDeleteEmptyFolderToo)
{
	if(!szFile || !*szFile)
	{
		Assert(0);
		return iesFailure;
	}
	
	PMsiRecord pRecErr(0);
	PMsiStream pSecurityDescriptor(0);
	if((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	DEBUGMSG1(TEXT("Scheduling file '%s' for deletion during post-install cleanup (not post-reboot)."), szFile);
	
	int iOptions = 0;
	if(fDeleteEmptyFolderToo)
		iOptions |= TEMPPACKAGE_DELETEFOLDER;

	MsiString strOptions = iOptions;

	const ICHAR* rgszRegData[] =
	{
		TEXT("%s"), szMsiTempPackages, 0, 0,
		szFile,     (const ICHAR*)strOptions,     g_szTypeInteger,
		0,
		0,
	};

	CElevate elevate;
	return ProcessRegInfo(rgszRegData, HKEY_LOCAL_MACHINE, fFalse, pSecurityDescriptor, 0, ibtCommon);
}


HANDLE CreateDiskPromptMutex()
/*---------------------------------------------------------------------------------------
Global function that creates a "Prompt for disk" mutex object, allowing active non-Darwin
processes to know when Darwin is prompting for a disk.  This function should be called
just prior to putting up a "please insert disk dialog" prompt.  After the dialog is taken
down, the CloseDiskPromptMutex called must be called.

Returns:
	A handle to the created mutex.  CloseDiskPromptMutex must be called to dispose of
	this handle when disk prompting is over.
---------------------------------------------------------------------------------------*/
{
	char rgchSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
	PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR) &rgchSD;

	if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION) ||
		!SetSecurityDescriptorDacl(pSD, TRUE,(PACL) NULL, FALSE))
		return NULL;

	SECURITY_ATTRIBUTES     sa;
	sa.nLength = sizeof(sa);
	sa.lpSecurityDescriptor = pSD;
	sa.bInheritHandle = TRUE;

	HANDLE hMutex = CreateMutex(&sa, FALSE, TEXT("__MsiPromptForCD"));
	MsiRegisterSysHandle(hMutex);
	return hMutex;
}

void CloseDiskPromptMutex(HANDLE hMutex)
/*--------------------------------------------------------------------------------------
Closes the handle created by a call to CreateDiskPromptMutex.  If called with a NULL
handle, CloseDiskPromptMutex does nothing.
---------------------------------------------------------------------------------------*/
{
	if (hMutex)
		MsiCloseSysHandle(hMutex);
}


// verifies that the source is valid by checking the package code of the package at the location 
// (for physical disk 1) or that the volume label is correct (for all other disks). Returns
// true if the source is valid, false otherwise. Patches are never disk 1, so no danger there
bool CMsiOpExecute::ValidateSourceMediaLabelOrPackage(IMsiVolume* pSourceVolume, const unsigned int uiDisk, const ICHAR* szLabel)
{
	AssertSz(pSourceVolume, "No Source Volume in ValidateSourceMediaLabelOrPackage");

	if (!pSourceVolume)
		return false;

	if (uiDisk == 1)
	{
		PMsiPath pPath(0);
		PMsiRecord pError(0);

		// create path to volume
		if ((pError = m_riServices.CreatePath(MsiString(pSourceVolume->GetPath()), *&pPath)) != 0)
		{
			return false;
		}
		
		// ensure path was created successfully
		if (!pPath)
		{
			return false;
		}

		// append relative path to package
		MsiString strMediaRelativePath;
		strMediaRelativePath = MsiString(GetPackageMediaPath());
		if ((pError = pPath->AppendPiece(*strMediaRelativePath)) != 0)
		{
			return false;
		}

		// append package name to path
		MsiString strPackageName;
		strPackageName = MsiString(GetPackageName());

		MsiString strPackageFullPath;
		AssertRecord(pPath->GetFullFilePath(strPackageName, *&strPackageFullPath));

		
		PMsiStorage pStorage(0);

		// SAFER check does not occur when validating source
		UINT uiStat = ERROR_SUCCESS;
		if (ERROR_SUCCESS != (uiStat = OpenAndValidateMsiStorage(strPackageFullPath, stDatabase, m_riServices, *&pStorage, /*fCallSAFER = */false, /*szFriendlyName = */NULL, /* phSaferLevel = */ NULL)))
		{
			// unable to open package
			DEBUGMSG1(TEXT("Source is incorrect. Unable to open or validate MSI package %s."), strPackageFullPath);
			return false;
		}

		if (!pStorage)
		{
			return false;
		}
	
		MsiString strExistingPackageCode = GetPackageCode();	
	
		// grab the package code from the MSI and compare it to the expected package code. 
		ICHAR szPackageCode[39];
		uiStat = GetPackageCodeAndLanguageFromStorage(*pStorage, szPackageCode);
		if (0 != IStrCompI(szPackageCode, strExistingPackageCode))
		{
			DEBUGMSG1(TEXT("Source is incorrect. Package code of %s is incorrect."), strPackageFullPath);
			return false;
		}
		return true;
	}
	else
	{
		// for all non-disk1 media, the volume label is sufficient for verification
		MsiString strMediaLabel(szLabel);
		MsiString strCurrLabel(pSourceVolume->VolumeLabel());
		if (strMediaLabel.Compare(iscExactI,strCurrLabel) == fFalse)
		{
			DEBUGMSG2(TEXT("Source is incorrect. Volume label should be %s but is %s."), strMediaLabel, strCurrLabel);
			return false;
		}
		return true;
	}
	return false;
}


bool CMsiOpExecute::VerifySourceMedia(IMsiPath& riSourcePath, const ICHAR* szLabel,
									const ICHAR* szPrompt, const unsigned int uiDisk, IMsiVolume*& rpiNewVol)
/*--------------------------------------------------------------------------------------
Internal function that attempts to locate a removable drive having the volume label
matching the szLabel parameter.  The volume associated with riSourcePath is first
checked - if this volume doesn't match (or no disk is in that drive), VerifySourceMedia
next inspects all volumes that are of the same type as riSourcePath's volume.  If no
matches are found, a message is sent back to the engine to prompt the user to insert
the proper disk; the string passed in the szPrompt parameter is displayed as the text
for the prompt dialog.

After the engine message call returns, VerifySourceMedia searches again to see if the
required disk has been mounted.  If not, the Message call is repeated until either
the proper disk is found, or the user cancels.

If a matching volume is found, a volume object representing the located volume (which
may be different than that associated with riSourcePath) is returned in the rpiNewVol
parameter.  Note: rpiNewVol will be returned as NULL if the required volume was found
immediately as matching riSourcPath's volume.

Returns:
	fTrue if the required volume is found, or if riSourcePath's volume is not
	removable.  fFalse if the user cancels without the required volume having been
	located.
---------------------------------------------------------------------------------------*/
{
	// initialize output volume to NULL
	rpiNewVol = 0;
	
	PMsiVolume pSourceVolume(&riSourcePath.GetVolume());
	idtEnum idtDriveType = pSourceVolume->DriveType();

	// Prompt only if the source is a removable disk.
	if (idtDriveType == idtFloppy || idtDriveType == idtCDROM)
	{
		// If disk is in the drive, and the label matches, we're OK
		if (pSourceVolume->DiskNotInDrive() == fFalse)
		{
			if (ValidateSourceMediaLabelOrPackage(pSourceVolume, uiDisk, szLabel))
				return true;
		}

		// Ok, the drive referenced by riSourcePath does not have a matching label 
		// (or package). Let's look for a mounted drive of the same type that does match.
		HANDLE hMutex = NULL;
		PMsiRecord pRec(&m_riServices.CreateRecord(1));
	
		// keep searching and prompting as long as the user keeps pressing "OK"
		do
		{
			// obtain an enumerator for all volumes of the relevant type (CDROM or Floppy)
			IEnumMsiVolume& riEnum = m_riServices.EnumDriveType(idtDriveType);
	
			// loop through all volume objects of that type
			PMsiVolume piVolume(0);
			for (int iMax = 0; riEnum.Next(1, &piVolume, 0) == S_OK; )
			{
				if (!piVolume)
					continue;
	
				#define DISK_RETRIES 10 // Give the poor CDROM a chance to spin up.
				int cRetries = 0;
				bool fVolumeValid = false;
				for(cRetries = 0; cRetries < DISK_RETRIES; cRetries++)
				{
					if (!piVolume->DiskNotInDrive())
					{
						fVolumeValid = true;
						break;
					}
					Sleep(1000);
				}
	
				if (fVolumeValid)
				{
					if (ValidateSourceMediaLabelOrPackage(piVolume, uiDisk, szLabel))
					{
						CloseDiskPromptMutex(hMutex);
						piVolume->AddRef();
						rpiNewVol = piVolume;
						return true;
					}
				}
			}

			riEnum.Release();
	
			// no removable media in the system matched the required disk. Dispatch a message
			// to prompt the user
			if (pRec)
				pRec->SetString(0, szPrompt);
			if (hMutex == NULL)
				hMutex = CreateDiskPromptMutex();
		}
		while (pRec && (DispatchMessage((imtEnum) (imtUser + imtOkCancel + imtDefault1), *pRec, fTrue) == imsOk));
	
		// user hit cancel to get here.
		CloseDiskPromptMutex(hMutex);
		return fFalse;
	}
	else // Non-removable drive
		return fTrue;
}


/*---------------------------------------------------------------------------
ixoSummaryInfoUpdate: Update summary information for database
---------------------------------------------------------------------------*/

iesEnum CMsiOpExecute::ixfSummaryInfoUpdate(IMsiRecord& riParams)
{
	using namespace IxoSummaryInfoUpdate;
	PMsiRecord pError(0);

	PMsiPath pDatabasePath(0);
	MsiString strDatabaseName;
	if((pError = m_riServices.CreateFilePath(riParams.GetString(Database),*&pDatabasePath,*&strDatabaseName)) != 0)
		return FatalError(*pError);

	int iOldAttribs = -1;
	if((pError = pDatabasePath->EnsureOverwrite(strDatabaseName, &iOldAttribs)) != 0)
		return FatalError(*pError);
	
	PMsiStorage pStorage(0);
	pError = m_riServices.CreateStorage(riParams.GetString(Database), ismDirect, *&pStorage);
	if (pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	PMsiSummaryInfo pSummary(0);
	pError = pStorage->CreateSummaryInfo(Args, *&pSummary);
	if (pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	if (!riParams.IsNull(LastUpdate))
		pSummary->SetTimeProperty(PID_LASTSAVE_DTM, MsiDate(riParams.GetInteger(LastUpdate)));
	if (!riParams.IsNull(LastAuthor))
		pSummary->SetStringProperty(PID_LASTAUTHOR, *MsiString(riParams.GetMsiString(LastAuthor)));
	if (!riParams.IsNull(InstallDate))
		pSummary->SetTimeProperty(PID_LASTPRINTED, MsiDate(riParams.GetInteger(InstallDate)));
	if (!riParams.IsNull(SourceType))
		pSummary->SetIntegerProperty(PID_MSISOURCE, riParams.GetInteger(SourceType));
	if (!riParams.IsNull(Revision))
		pSummary->SetStringProperty(PID_REVNUMBER, *MsiString(riParams.GetMsiString(Revision)));
	if (!riParams.IsNull(Subject))
		pSummary->SetStringProperty(PID_SUBJECT, *MsiString(riParams.GetMsiString(Subject)));
	if (!riParams.IsNull(Comments))
		pSummary->SetStringProperty(PID_COMMENTS, *MsiString(riParams.GetMsiString(Comments)));

	if (!pSummary->WritePropertyStream())
	{
		pError = PostError(Imsg(imsgErrorWritingToFile),riParams.GetString(Database));
		return FatalError(*pError);
	}

	// NOTE: if a failure happened after removing the read-only attribute but before this point, rollback will
	// restore the proper attributes when restoring the file
	// this op doesn't generate the rollback op, but a previous op (ixoDatabaseCopy or ixoDatabasePatch) will
	if((pError = pDatabasePath->SetAllFileAttributes(strDatabaseName, iOldAttribs)) != 0)
		return FatalError(*pError);

	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfStreamsRemove(IMsiRecord& riParams)
{
	// doesn't handle rollback - only used when copying the database
	using namespace IxoStreamsRemove;
	PMsiStorage pStorage(0);
	PMsiRecord pError = m_riServices.CreateStorage(riParams.GetString(File), ismTransact, *&pStorage);
	if (pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	MsiString strStreams = riParams.GetMsiString(Streams);
	MsiString strStreamName;
	while(strStreams.TextSize())
	{
		strStreamName = strStreams.Extract(iseUpto,';');
		if(strStreamName.TextSize() == strStreams.TextSize())
			strStreams = TEXT("");
		else
			strStreams.Remove(iseFirst,strStreamName.TextSize()+1);
		if((pError = pStorage->RemoveElement(strStreamName, fFalse)) != 0)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
	}
	if((pError = pStorage->Commit()) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfStreamAdd(IMsiRecord& riParams)
{
	// doesn't handle rollback - only used when copying the database
	// Trivial to add, just add a ixoStreamsRemove call.

	using namespace IxoStreamAdd;
	PMsiStorage pStorage(0);
	PMsiRecord pError = m_riServices.CreateStorage(riParams.GetString(File), ismTransact, *&pStorage);
	if (pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}
	MsiString strStream = riParams.GetMsiString(Stream);
	PMsiStream pData((IMsiStream*) riParams.GetMsiData(Data));
	PMsiStream pOutData(0);

	if (!(pError = pStorage->OpenStream(strStream, fTrue, *&pOutData)))
	{
		const int cchBuffer = 4096;
		char pchBuffer[cchBuffer];
		int cchRemaining = pData->Remaining();
		int cchInUse;
		while(cchRemaining)
		{
			cchInUse = (cchRemaining > cchBuffer) ? cchBuffer : cchRemaining;
			pData->GetData(pchBuffer, cchInUse);
			pOutData->PutData(pchBuffer, cchInUse);
			cchRemaining -= cchInUse;
		}
	}
	else
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	if((pError = pStorage->Commit()) != 0)
	{
		Message(imtError, *pError);
		return iesFailure;
	}   
	return iesSuccess;
}

//**************************************************************************//
//ADVERTISE OPCODES
//**************************************************************************//

/*---------------------------------------------------------------------------
ixfPackageCodePublish: Advertise package code
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfPackageCodePublish(IMsiRecord& riParams)
{
	using namespace IxoPackageCodePublish;

	if(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO) // do we write/delete the registry
	{
		MsiString strPackageCodeSQUID = GetPackedGUID(MsiString(riParams.GetMsiString(PackageKey)));
		MsiString strProductKeySQUID  = GetPackedGUID(MsiString(GetProductKey()));

		PMsiRecord pRecErr(0);
		PMsiStream pSecurityDescriptor(0);
		if((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
			return FatalError(*pRecErr);

		const ICHAR* rgszRegData[] =
		{
			TEXT("%s\\%s"), _szGPTProductsKey, strProductKeySQUID, 0,
			szPackageCodeValueName,     (const ICHAR*)strPackageCodeSQUID,     g_szTypeString,
			0,
			0,
		};

		CElevate elevate;
		return ProcessRegInfo(rgszRegData, m_hKey, fFalse, pSecurityDescriptor, 0, ibtCommon);
	}
	else
	{
		return iesNoAction;
	}
}

/*---------------------------------------------------------------------------
ixfUpgradeCodePublish: Advertise upgrade code
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfUpgradeCodePublish(IMsiRecord& riParams)
{
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfUpgradeCodePublish")));
		return iesFailure;
	}

	return ProcessUpgradeCodePublish(riParams, m_fReverseADVTScript);
}

iesEnum CMsiOpExecute::ixfUpgradeCodeUnpublish(IMsiRecord& riParams)
{
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfUpgradeCodeUnpublish")));
		return iesFailure;
	}

	return ProcessUpgradeCodePublish(riParams, fTrue);
}

iesEnum CMsiOpExecute::ProcessUpgradeCodePublish(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoUpgradeCodePublish;

	if(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO) // do we write/delete the registry
	{
		MsiString strUpgradeCodeSQUID = GetPackedGUID(MsiString(riParams.GetMsiString(UpgradeCode)));
		MsiString strProductKeySQUID  = GetPackedGUID(MsiString(GetProductKey()));

		PMsiRecord pRecErr(0);
		PMsiStream pSecurityDescriptor(0);
		if((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
			return FatalError(*pRecErr);

		const ICHAR* rgszRegData[] =
		{
			TEXT("%s\\%s"), _szGPTUpgradeCodesKey, strUpgradeCodeSQUID, 0,
			strProductKeySQUID,  0,   g_szTypeString,
			0,
			0,
		};  

		CElevate elevate;
		return ProcessRegInfo(rgszRegData, m_hKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
	}
	else
	{
		return iesNoAction;
	}
}

/*---------------------------------------------------------------------------
ixfProductPublish: Advertise common product info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfProductPublish(IMsiRecord& riParams)
{
	using namespace IxoProductPublish;

	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductPublish")));
		return iesFailure;
	}

	return ProcessPublishProduct(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfProductUnpublish: Unadvertise common product info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfProductUnpublish(IMsiRecord& riParams)
{
	using namespace IxoProductUnpublish;

	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductUnpublish")));
		return iesFailure;
	}
	
	return ProcessPublishProduct(riParams, fTrue);
}

/*---------------------------------------------------------------------------
ixfProductPublishUpdate: re-register common product info (product name and version)
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfProductPublishUpdate(IMsiRecord& /*riParams*/)
{
	using namespace IxoProductPublishUpdate;

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO)) // do we write/delete the registry
		return iesNoAction;

	PMsiRecord pRecErr(0);
	PMsiStream pSecurityDescriptor(0);
	if((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	MsiString strProductKeySQUID  = GetPackedGUID(MsiString(GetProductKey()));
	MsiString strProductName      = MsiString(GetProductName());
	MsiString strVersion          = MsiString(GetProductVersion());

	const ICHAR* rgszRegData[] =
	{
		TEXT("%s\\%s"), _szGPTProductsKey, strProductKeySQUID, 0,
		szProductNameValueName,     (const ICHAR*)strProductName,       g_szTypeString,
		szVersionValueName,         (const ICHAR*)strVersion,           g_szTypeInteger,
		0,
		0,
	};

	CElevate elevate;
	return ProcessRegInfo(rgszRegData, m_hKey, fFalse, pSecurityDescriptor, 0, ibtCommon);
}

/*---------------------------------------------------------------------------
ProcessPublishProduct: process common product Advertise info
---------------------------------------------------------------------------*/

inline bool IsStringField(IMsiRecord& riRec, unsigned int iField)
{
	PMsiData pData = riRec.GetMsiData(iField);
	IMsiString* piString;

	if (pData && (pData->QueryInterface(IID_IMsiString, (void**)&piString) == NOERROR))
	{
		piString->Release();
		return true;
	}

	return false;
}

iesEnum CMsiOpExecute::ProcessPublishProduct(IMsiRecord& riParams, Bool fRemove, const IMsiString** pistrTransformsValue)
{
	using namespace IxoProductPublish;

	// If pistrTransformsValue is set then we're simply building the list
	// of transforms that we _would_ publish, but we don't actually
	// publish anything. Why? Because MsiAdvertiseScript needs this.
	Assert(!(fRemove && pistrTransformsValue));
	
	MsiString strProductKey = GetProductKey();

	if (pistrTransformsValue == 0)
	{
		IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
		AssertNonZero(riActionData.SetMsiString(1, *strProductKey));
		if(Message(imtActionData, riActionData) == imsCancel)
			return iesUserExit;
	}

	//!! TODO??: check that other values have been set
		
	MsiString strLanguage  = MsiString(GetProductLanguage());
	MsiString strVersion =   MsiString(GetProductVersion());
	MsiString strInstanceType = MsiString(GetProductInstanceType());

	if (fRemove) // if we're unpublishing then we can tell the start menu that this product is going away
		m_fStartMenuUninstallRefresh = true;

	PMsiRecord pRecErr(0);

	// process the transform information

	PMsiRecord pArgParams(0);
	int cFields = 0;

	if (fRemove)
	{
		// We're unpublishing. Instead of using the transform information that's
		// in the script we'll use the information that's been registered for
		// this product.

		// We'll create a dummy record that the rest of the opcode can use.
		
		int cDummyRecordFieldCount = 1 + 10; // PackageKey + guess of max 10 transforms
		bool fContinue = true;

		while (fContinue)
		{
			fContinue = false;
			pArgParams = &m_riServices.CreateRecord(cDummyRecordFieldCount);
			
			// grab the transforms list from the registry

			CTempBuffer<ICHAR, 100> szBuffer;
			MsiString strDummyTransformList;
			if (ENG::GetExpandedProductInfo(strProductKey, INSTALLPROPERTY_TRANSFORMS, szBuffer))
				strDummyTransformList = (const ICHAR*)szBuffer;

			// parse it and create a dummy record to use instead of riParams

			MsiString strDummyTransform;
			Assert(PackageKey == 1);
			pArgParams->SetString(PackageKey, MsiString(riParams.GetString(PackageKey)));
			int cDummyCount = 2;

			if (strDummyTransformList.TextSize())
			{
				for (;;)
				{
					strDummyTransform = strDummyTransformList.Extract(iseUpto, ';');

					pArgParams->SetString(cDummyCount++, strDummyTransform);
					if (!strDummyTransformList.Remove(iseIncluding, ';'))
						break;

					if (cDummyCount > pArgParams->GetFieldCount())
					{
						// our record isn't big enough; need to start again with a bigger record
						cDummyRecordFieldCount += 10;
						fContinue = true;
						break;
					}
				}
			}
			cFields = cDummyCount - 1;
		}
		
	}
	else
	{
		riParams.AddRef();
		pArgParams = &riParams;
		cFields = pArgParams->GetFieldCount();
	}

	int cCount = PackageKey + 1;
	
	MsiString strTransformList;
	tsEnum tsTransformsSecure = tsNo;

	while(cCount <= cFields)
	{
		MsiString strTransform = pArgParams->GetMsiString(cCount);
		if(strTransformList.TextSize())
			strTransformList += MsiString(*TEXT(";"));

		if (cCount == PackageKey+1) // first transform
		{
			// This is the first transform. If there's a secure token then it will
			// be prepended to this transform.
			//
			// We need to do two things:
			//
			// 1) Put the correct token at the head of our transforms list that we're
			//    going to store in the registry
			// 2) Determine whether we have secure transforms and, if so, what type
			
			ICHAR chFirst = *(const ICHAR*)strTransform;
			ICHAR chToken = 0;

			if (chFirst == SECURE_RELATIVE_TOKEN)
			{
				tsTransformsSecure = tsRelative;
				chToken = SECURE_RELATIVE_TOKEN;
			}
			else if (chFirst == SECURE_ABSOLUTE_TOKEN)
			{
				tsTransformsSecure = tsAbsolute;
				chToken = SECURE_ABSOLUTE_TOKEN;
			}
			else if (!fRemove &&
						(GetIntegerPolicyValue(szTransformsSecureValueName,   fTrue) ||
						 GetIntegerPolicyValue(szTransformsAtSourceValueName, fFalse)))
			{
				// Don't check policy when unpublishing. Policy isn't relevant then --
				// we simply rely on whatever tokens have been prepended to the transforms
				// list in was stored in the registry.
				//
				// If, however, we're publishing and one of the secure policies is set
				// _and_ no token was set then we know that transforms are secure, but
				// we don't know whether they're absolutley pathed or relatively pathed
				// (i.e. at-source). We'll determine this once we start looking at the
				// transforms lists.
				
				tsTransformsSecure = tsUnknown;
			}

			// If we did find a secure token at the front of our first transform
			// then we tack it onto the front of our transforms list that's
			// to be stored in the registry. We also remove the token from the
			// transform so as not to confuse ourselves below.
			if (chToken)
			{
				strTransformList += MsiString(MsiChar(chToken));
				strTransform.Remove(iseFirst, 1);
			}
		}

		cCount++;
		
		DEBUGMSG1(TEXT("Transforms are %s secure."), (tsTransformsSecure == tsNo) ? TEXT("not") : (tsTransformsSecure == tsAbsolute) ? TEXT("absolute") : (tsTransformsSecure == tsRelative) ? TEXT("relative") : (tsTransformsSecure == tsUnknown) ? TEXT("unknown") : TEXT("??"));

		// In the olden days we prepend the SECURE_RELATIVE_TOKEN
		// (formerly the source token) to _each_ transform in our list, e.g.
		// @foo1.mst;@foo2.mst;@foo3.mst. In case we run into transformed registered
		// in this way we strip off any extraneous "@" tokens that we find and
		// we're going through our transforms.

		if (*(const ICHAR*)strTransform == SECURE_RELATIVE_TOKEN)
			strTransform.Remove(iseFirst, 1);

		if((*(const ICHAR*)strTransform == SHELLFOLDER_TOKEN))
		{
			// Transforms that are cached in the user profile need to
			// be removed. We need to translate the shell folder syntax
			// (*26*....) into a real path and then remove the transform file.

			if (fRemove)
			{
				MsiString strFullPath;
				if ((pRecErr = ExpandShellFolderTransformPath(*strTransform, *&strFullPath, m_riServices)))
				{
					return FatalError(*pRecErr);
				}
				else
				{
					DEBUGMSGV1(TEXT("Removing shell-folder cached transform: %s"), strFullPath);
					// schedule file for deletion once we let go of install packages/transforms
					if(iesSuccess != DeleteFileDuringCleanup(strFullPath, true))
					{
						DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove), *strFullPath);
					}
				}
			}
			else
			{
				AssertSz(0, TEXT("Encountered a shell-folder token in our transforms list in the script"));
			}
		}
		else if ((*(const ICHAR*)strTransform == STORAGE_TOKEN))
		{
			// Storage transforms don't need to be "removed". They do, however, need to
			// be registered.

			if (!fRemove)
			{
				strTransformList += strTransform;
				DEBUGMSGV1(TEXT("Registering storage transform: %s"), strTransform);
			}
		}
		else if(tsTransformsSecure != tsNo) // Transforms are secure
		{
			Assert(tsTransformsSecure == tsUnknown  ||
					 tsTransformsSecure == tsRelative ||
					 tsTransformsSecure == tsAbsolute);
			

			if (!pArgParams->IsNull(cCount) && !IsStringField(*pArgParams, cCount)) // skip data field, if any
			{
				cCount++;
			}

			// We decided above that we have a secure transform of some form. If
			// the exact type is unknown then we'll determine it now, based
			// on what type of path the transform has.

			if (tsTransformsSecure == tsUnknown)
			{
				if (ENG::PathType(strTransform) == iptFull)
				{
					tsTransformsSecure = tsAbsolute;
				}
				else
				{
					tsTransformsSecure = tsRelative;
				}
			}

			strTransformList += strTransform;
			DEBUGMSGV2(TEXT("%s secure transform: %s"), fRemove ? TEXT("Unregistering") : TEXT("Registering"), strTransform);
		}
		else // file transform that needs to be cached
		{
			// Ignore the full path if present. We only care about the file name.
			PMsiPath pPath(0);
			MsiString strFileName;
			if ((pRecErr = m_riServices.CreateFilePath(strTransform, *&pPath, *&strFileName)))
				return FatalError(*pRecErr);
			
			strTransform = strFileName;

			// We need to either dump the transforms from the script onto
			// the machine (ProductPublish) or simply remove the existing
			// transform (ProductUnpublish)

			if((m_fFlags & SCRIPTFLAGS_CACHEINFO))// do we process the cached icons/ transforms
			{
				// Determine where we're going to put the transform/where we're going to delete it from
				Assert(m_pCachePath);
				MsiString strTransformFullPath;
				if((pRecErr = m_pCachePath->GetFullFilePath(strTransform,*&strTransformFullPath)))
					return FatalError(*pRecErr);

				DEBUGMSGV1(TEXT("Processing cached transform: %s"), strTransformFullPath);

				
				{
					CElevate elevate; // elevate to create or remove files in secured folder

					iesEnum iesRet = iesNoAction;
					if(fRemove)
					{
						// schedule file for deletion once we let go of install packages/transforms
						if(iesSuccess != DeleteFileDuringCleanup(strTransformFullPath, true))
						{
							DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove), *strTransformFullPath);
						}
					}
					else if (pistrTransformsValue != 0)
					{
						// we're only building the transforms list; simply skip the data
						cCount++;
					}
					else
					{
						// we create the file from the binary data
						LPSECURITY_ATTRIBUTES pAttributes;
						SECURITY_ATTRIBUTES saAttributes;
						if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
						{
							if (ERROR_SUCCESS != GetLockdownSecurityAttributes(saAttributes, false))
								return iesFailure;
							pAttributes = &saAttributes;
						}
						else
						{
							// do not attempt to secure the transform file in the  appdata folder
							// since it might not be local OR may move to the net later
							pAttributes = 0;
						}


						if((iesRet = ProcessFileFromData(*m_pCachePath,*strTransform,
							PMsiData(pArgParams->GetMsiData(cCount++)),
							pAttributes)) != iesSuccess)
							return iesRet;

						// mark transform read-only to dissuade users from
						// deleting it from their profile
						if((pRecErr = m_pCachePath->SetFileAttribute(strTransform, ifaReadOnly, fTrue)))
						{
							Message(imtInfo, *pRecErr);
						}
					}
				}
			}
			else
			{
				cCount++; // skip transform data
			}

			// Now that we've dumped the transform onto the machine (if needed)
			// we need to register the correct path for the transform. If
			// the path is user specific then we need to encode the path so
			// that instead of something like:
			//
			//    C:\Winnt\Profiles\JoeUser\Application Data\Microsoft...
			//
			// we have instead:
			//
			//    *26*\Microsoft...
			//
			// This is in case the user roams and the machine they roam to has
			// Application Data elsewhere.

			MsiString strPath;
			if(!m_fUserSpecificCache)
			{
				strPath = m_pCachePath->GetPath();
			}
			else
			{
				if ((pRecErr = GetCachePath(*&m_pCachePath, &strPath))) // get encoded cache path (shell ID at the beginning)
				{
					Message(imtError, *pRecErr);
					return iesFailure;
				}
			}

			strPath += strTransform;
			strTransformList += strPath;
			DEBUGMSGV1(TEXT("Registering cached transform: %s"), strPath);
		}
	}

	iesEnum iesRet = iesSuccess;

	// We need to mark the front of the transforms list with
	// the appropriate token if necessary

	if (strTransformList.TextSize())
	{
		if ((tsTransformsSecure == tsRelative) &&
			(*(const ICHAR*)strTransformList != SECURE_RELATIVE_TOKEN))
		{
			strTransformList = MsiString(MsiChar(SECURE_RELATIVE_TOKEN)) + strTransformList;
		}
		else if ((tsTransformsSecure == tsAbsolute) &&
			(*(const ICHAR*)strTransformList != SECURE_ABSOLUTE_TOKEN))
		{
			strTransformList = MsiString(MsiChar(SECURE_ABSOLUTE_TOKEN)) + strTransformList;
		}
	}

	if (pistrTransformsValue)
	{
		// we're not registering anything -- simple return the
		// transforms list htat we built
		strTransformList.ReturnArg(*pistrTransformsValue);
	}
	else if(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO) // do we write/delete the registry
	{
		// published data needs to be secure

		PMsiStream pSecurityDescriptor(0);
		if((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
			return FatalError(*pRecErr);

		MsiString strProductKeySQUID = GetPackedGUID(strProductKey);

		if ( !fRemove )
		{
			MsiString strAssignmentType;
			if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
				strAssignmentType = MsiString(1);
			else
				strAssignmentType = MsiString(0);

			MsiString strPackageKeySQUID = GetPackedGUID(MsiString(pArgParams->GetMsiString(PackageKey)));
			
			MsiString strProductIcon(GetProductIcon());
			bool fExpandProductIcon = false;

			// Convert the Product Icon to an actual path from the cache.
			// is this a full path or an index into the icon table
			if (strProductIcon.TextSize())
			{
				if(PathType(strProductIcon) != iptFull)
				{
					Assert(m_pCachePath);
					MsiString strIconPath = GetUserProfileEnvPath(*MsiString(m_pCachePath->GetPath()), fExpandProductIcon);
					strProductIcon = strIconPath + strProductIcon;
				}
			}
				
			MsiString strADVTFlags = MsiString((m_fFlags & SCRIPTFLAGS_REGDATA_APPINFO) | (m_fFlags & SCRIPTFLAGS_SHORTCUTS)); // store off what we advertise the first time round
			int cLimit = fRemove ? 1 : 0;
			for (int cCount = 1; cCount >= cLimit; cCount--) // remove previous entries and then add any new entries
			{
				const ICHAR* rgszRegData[] =
				{
					TEXT("%s\\%s"), _szGPTProductsKey, strProductKeySQUID, 0,
					szProductNameValueName,     cCount ? 0 : (const ICHAR*)MsiString(GetProductName()),       g_szTypeString,
					szPackageCodeValueName,     cCount ? 0 : (const ICHAR*)strPackageKeySQUID,     g_szTypeString,
					szLanguageValueName,        cCount ? 0 : (const ICHAR*)strLanguage,           g_szTypeInteger,
					szVersionValueName,         cCount ? 0 : (const ICHAR*)strVersion,            g_szTypeInteger,
					szTransformsValueName,      cCount ? 0 : (const ICHAR*)strTransformList,       g_szTypeExpandString,
					szAssignmentTypeValueName,  cCount ? 0 : (const ICHAR*)strAssignmentType,      g_szTypeInteger,
					szAdvertisementFlags,       cCount ? 0 : (const ICHAR*)strADVTFlags,           g_szTypeInteger,
					szProductIconValueName,     cCount ? 0 : (const ICHAR*)strProductIcon,         (fExpandProductIcon) ? g_szTypeExpandString : g_szTypeString,
					szInstanceTypeValueName,    cCount ? 0 : (const ICHAR*)strInstanceType,      g_szTypeInteger,
					0,
					0,
				};

				CElevate elevate;
				iesRet = ProcessRegInfo(rgszRegData, m_hKey, cCount ? fTrue : fFalse, pSecurityDescriptor, 0, ibtCommon);
				if(iesRet != iesSuccess && iesRet != iesNoAction)
					return iesRet;
			}
		}
		else
		{
			m_cSuppressProgress++;  

			MsiString strProductsKey = _szGPTProductsKey TEXT("\\");
			strProductsKey += strProductKeySQUID;

			MsiString strFeaturesKey = _szGPTFeaturesKey TEXT("\\");
			strFeaturesKey += strProductKeySQUID;

			PMsiRecord pParams = &m_riServices.CreateRecord(IxoRegOpenKey::Args);
			
			for (int cCount = 0; (iesRet == iesSuccess || iesRet == iesNoAction) && cCount < (m_hKeyRm ? 2:1);cCount++)
			{

#ifdef _WIN64   // !merced
				AssertNonZero(pParams->SetHandle(IxoRegOpenKey::Root, cCount ? (HANDLE)m_hKeyRm : (HANDLE)m_hKey ));
#else
				AssertNonZero(pParams->SetInteger(IxoRegOpenKey::Root, cCount ? (int)m_hKeyRm : (int)m_hKey));
#endif
				AssertNonZero(pParams->SetInteger(IxoRegOpenKey::BinaryType, (int)ibtCommon));

				// clear product info
				AssertNonZero(pParams->SetString(IxoRegOpenKey::Key, strProductsKey));
				// we elevate this block to ensure that we're able to remove our key
				{
					CElevate elevate;
					iesRet = ixfRegOpenKey(*pParams);
					if (iesRet == iesSuccess || iesRet == iesNoAction)
						iesRet = ixfRegRemoveKey(*pParams);//!! should pass in a new record of size IxoRegRemoveKey::Args here to be safe from future revision
				}
				
				if ( iesRet != iesSuccess && iesRet != iesNoAction )
					continue;

				// clear out any registered feature info, that may potentially remain for disabled features
				AssertNonZero(pParams->SetMsiString(IxoRegOpenKey::Key, *strFeaturesKey));
				// we elevate this block to ensure that we're able to remove our key
				{
					CElevate elevate;
					iesRet = ixfRegOpenKey(*pParams);
					if (iesRet == iesSuccess || iesRet == iesNoAction)
						iesRet = ixfRegRemoveKey(*pParams);//!! should pass in a new record of size IxoRegRemoveKey::Args here to be safe from future revision
				}
			}
			m_cSuppressProgress--;  
		}
	}   
	return iesRet;
}

/*---------------------------------------------------------------------------
ixfAdvtFlagsUpdate
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfAdvtFlagsUpdate(IMsiRecord& riParams)
{
	using namespace IxoAdvtFlagsUpdate;

	PMsiStream pSecurityDescriptor(0);
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	MsiString strProductKeySQUID  = GetPackedGUID(MsiString(GetProductKey()));
	MsiString strAdvtFlags = riParams.GetMsiString(Flags);

	const ICHAR* rgszRegData[] =
	{
		TEXT("%s\\%s"), _szGPTProductsKey, strProductKeySQUID, 0,
				szAdvertisementFlags,    (const ICHAR*)strAdvtFlags,  g_szTypeInteger,
				0,
				0,
	};

	CElevate elevate;
	return ProcessRegInfo(rgszRegData, m_hKey, fFalse, pSecurityDescriptor, 0, ibtCommon);
}

/*---------------------------------------------------------------------------
ixfProductPublishClient
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfProductPublishClient(IMsiRecord& riParams)
{
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductPublishClient")));
		return iesFailure;
	}

	return ProcessPublishProductClient(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfProductUnpublishClient
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfProductUnpublishClient(IMsiRecord& riParams)
{
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfProductUnpublishClient")));
		return iesFailure;
	}
	
	return ProcessPublishProductClient(riParams, fTrue);
}

iesEnum CMsiOpExecute::ProcessPublishProductClient(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoProductPublishClient;

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO)) // do we write/delete the registry
		return iesSuccess;

	PMsiStream pSecurityDescriptor(0);
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	MsiString strProductKeySQUID = GetPackedGUID(MsiString(GetProductKey()));

	MsiString strParent              = riParams.GetMsiString(Parent);
	MsiString strRelativePackagePath = riParams.GetMsiString(ChildPackagePath);
	unsigned int uiDiskId            = riParams.GetInteger(ChildDiskId);
	MsiString strClients;
	GetProductClientList(strParent, strRelativePackagePath, uiDiskId, *&strClients);

	// we elevate this block to ensure that we're able to write to our key
	{
		CElevate elevate;
		const ICHAR* rgszRegData[] =
		{
			TEXT("%s\\%s"), _szGPTProductsKey, strProductKeySQUID, 0,
			szClientsValueName,         strClients,              g_szTypeMultiSzStringSuffix,
			0,
			0
		};

		return ProcessRegInfo(rgszRegData, m_hKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
	}
}

/*---------------------------------------------------------------------------
ixfFeaturePublish: advertise feature-component info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfFeaturePublish(IMsiRecord& riParams)
{
	// Record description
	// 1 = Feature ID
	// 2 = Parent feature(optional)
	// 3 = Absent
	// 4 = Component#1
	// 5 = Component#2
	// 6 = Component#3
	// ...
	// ...

	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfFeaturePublish")));
		return iesFailure;
	}
	return ProcessPublishFeature(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfFeatureUnpublish: unadvertise feature-component info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfFeatureUnpublish(IMsiRecord& riParams)
{
	// Record description
	// 1 = Feature ID
	// 2 = Parent feature(optional)
	// 3 = Absent
	// 4 = Component#1
	// 5 = Component#2
	// 6 = Component#3
	// ...
	// ...

	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfFeatureUnpublish")));
		return iesFailure;
	}
	return ProcessPublishFeature(riParams, fTrue);
}

/*---------------------------------------------------------------------------
ProcessPublishFeature: Process feature-component info for advertising
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessPublishFeature(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoFeaturePublish;
	// Record description
	// 1 = Feature ID
	// 2 = Parent feature(optional)
	// 3 = Absent
	// 4 = Component#1
	// 5 = Component#2
	// 6 = Component#3
	// ...
	// ...

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO)) // do we write/delete the registry
		return iesSuccess;


	MsiString strFeature = riParams.GetMsiString(Feature);
	MsiString strFeatureParent = riParams.GetMsiString(Parent);

	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strFeature));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	PMsiStream pSecurityDescriptor(0);
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	// registration of features in CurrentUser - changed to omit component list
	MsiString strProductKeySQUID = GetPackedGUID(MsiString(GetProductKey()));
	// we elevate this block to ensure that we're able to write to our key
	{
		const ICHAR* szValue;
		bool fSetFeatureAbsent = false;
		ICHAR rgchTemp[MAX_FEATURE_CHARS + 16];
		if(riParams.GetInteger(Absent) & iPublishFeatureAbsent)  // flag feature as not advertised
		{
			fSetFeatureAbsent = true;
			// if we are (re)advertising then we should respect the fact that the
			// feature may have been previously explicitly made available by the user
			// prior to this logon
			if(m_fFlags & SCRIPTFLAGS_INPROC_ADVERTISEMENT)
			{
				// read the previous registration
				MsiString strSubKey = _szGPTFeaturesKey TEXT("\\");
				strSubKey += strProductKeySQUID;
				PMsiRegKey pRootKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hKey, ibtCommon);        //--merced: changed (int) to (INT_PTR)
				PMsiRegKey pFeaturesKey = &pRootKey->CreateChild(strSubKey);
				MsiString strOldValue;
				Bool bValueExists = fFalse;
				if((pRecErr = pFeaturesKey->ValueExists(strFeature, bValueExists)) != 0)
				{
					Message(imtError, *pRecErr);
					return iesFailure;
				}
				if(bValueExists == fTrue)
				{
					if((pRecErr = pFeaturesKey->GetValue(strFeature,*&strOldValue)) != 0)
					{
						Message(imtError, *pRecErr);
						return iesFailure;
					}
					if(!strOldValue.TextSize() || *(const ICHAR*)strOldValue != chAbsentToken)
						fSetFeatureAbsent = false;
				}
			}
		}
		if(fSetFeatureAbsent)
		{
			// set feature to absent
			rgchTemp[0] = chAbsentToken;
			IStrCopyLen(&rgchTemp[1], (const ICHAR*)strFeatureParent, sizeof(rgchTemp)/sizeof(ICHAR) - 1);
			szValue = rgchTemp;
		}
		else if (strFeatureParent.TextSize())
			szValue = strFeatureParent;
		else
			szValue = 0;  // force registry write (empty string suppresses)

		const ICHAR* rgszRegData[] = {
			TEXT("%s\\%s"), _szGPTFeaturesKey, strProductKeySQUID,0,
			strFeature, szValue, g_szTypeString,
			0,
			0,
		};
		CElevate elevate;
		iesEnum iesRet = ProcessRegInfo(rgszRegData, m_hKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
		if (iesRet != iesSuccess || !(riParams.GetInteger(Absent) & iPublishFeatureInstall))
			return iesRet;
	}

	if(strFeatureParent.TextSize())
	{
		// we have a parent feature. delimit
		strFeatureParent = MsiString(MsiChar(chFeatureIdTerminator)) + strFeatureParent;
	}
	MsiString strComponentsList;
	int cPos = Component;
	if(m_iScriptVersion < 21 || (m_iScriptVersion == 21 && m_iScriptVersionMinor < 3))
	{
		// components are not packed on the client side
		while(!riParams.IsNull(cPos))
		{
			ICHAR szSQUID[cchComponentIdCompressed+1];
			AssertNonZero(PackGUID(riParams.GetString(cPos++), szSQUID, ipgCompressed));
			strComponentsList += szSQUID;
		}
	}
	else
	{
		// components are packed on the client side
		strComponentsList += riParams.GetString(cPos++);
	}
	strComponentsList += strFeatureParent;
	const ICHAR* pszComponentsList = strComponentsList;

    // registration of features in LocalMachine
	MsiString strLocalFeaturesKey;
	if((pRecErr = GetProductInstalledFeaturesKey(*&strLocalFeaturesKey)) != 0)
		return FatalError(*pRecErr);

	// we elevate this block to ensure that we're able to write to our key
	{
		const ICHAR* rgszRegData[] = {
			TEXT("%s"), strLocalFeaturesKey, 0,0,
			strFeature, *pszComponentsList ? pszComponentsList : 0 /* force the feature publish, whether or not the component list is empty*/, g_szTypeString,
			0,
			0,
		};
		CElevate elevate;
		return ProcessRegInfo(rgszRegData, m_hUserDataKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
	}
}

/*---------------------------------------------------------------------------
ixfComponentPublish: advertise component-factory info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfComponentPublish(IMsiRecord& riParams)
{
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfComponentPublish")));
		return iesFailure;
	}
	return ProcessPublishComponent(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfComponentUnpublish: unadvertise component-factory info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfComponentUnpublish(IMsiRecord& riParams)
{
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfComponentUnpublish")));
		return iesFailure;
	}
	return ProcessPublishComponent(riParams, fTrue);
}

/*---------------------------------------------------------------------------
ProcessPublishComponent: Process component info for advertising
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessPublishComponent(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoComponentPublish;
	// Record description
	// 1 = Feature
	// 2 = Component
	// 3 = Component ID
	// 4 = Qualifier
	// 5 = AppData

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO)) // do we write/delete the registry
		return iesSuccess;

	PMsiStream pSecurityDescriptor(0);
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	MsiString strPublishComponent = riParams.GetString(ComponentId);
	MsiString strQualifier = riParams.GetMsiString(Qualifier);
	MsiString strServer    = ComposeDescriptor(*MsiString(riParams.GetMsiString(Feature)),
												*MsiString(riParams.GetMsiString(Component)));
	strServer += MsiString(riParams.GetMsiString(AppData)); // we append the app data to the Darwin Descriptor

	IMsiRecord& riActionData = GetSharedRecord(2); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strPublishComponent));
	AssertNonZero(riActionData.SetMsiString(2, *strQualifier));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	MsiString strPublishComponentSQUID = GetPackedGUID(strPublishComponent);

	const ICHAR* rgszRegData[] = {
		TEXT("%s\\%s"),      _szGPTComponentsKey, strPublishComponentSQUID ,0,
		strQualifier,        strServer,           g_szTypeMultiSzStringDD,
		0,
		0,
	};

	{
		CElevate elevate;
		return ProcessRegInfo(rgszRegData, m_hKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
	}
}


/*---------------------------------------------------------------------------
ixfAssemblyPublish: advertise assembly info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfAssemblyPublish(IMsiRecord& riParams)
{
	return ProcessPublishAssembly(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfAssemblyUnpublish: unadvertise assembly info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfAssemblyUnpublish(IMsiRecord& riParams)
{
	return ProcessPublishAssembly(riParams, fTrue);
}

/*---------------------------------------------------------------------------
ProcessPublishAssembly: Process assembly info for advertising
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessPublishAssembly(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoAssemblyPublish;
	// Record description
	// 1 = Feature
	// 2 = Component
	// 3 = AssemblyType
	// 4 = AppCtx
	// 5 = AssemblyName

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO)) // do we write/delete the registry
		return iesSuccess;

	PMsiStream pSecurityDescriptor(0);
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	MsiString strAppCtx = riParams.GetString(AppCtx);
	if(!strAppCtx.TextSize())
		strAppCtx = szGlobalAssembliesCtx; // this assembly is being advertised to the GAC
	else
	{
		// we need to replace the backslashes in the AppCtx with something else, since registry keys cannot
		// have backslashes
		CTempBuffer<ICHAR, MAX_PATH> rgchAppCtxWOBS;
		DWORD cchLen = strAppCtx.TextSize() + 1;
		rgchAppCtxWOBS.SetSize(cchLen);
		memcpy((ICHAR*)rgchAppCtxWOBS, (const ICHAR*)strAppCtx, cchLen*sizeof(ICHAR));
		ICHAR* lpTmp = rgchAppCtxWOBS;
		while(*lpTmp)
		{
			if(*lpTmp == '\\')
				*lpTmp = '|';
			lpTmp = ICharNext(lpTmp);
		}
		strAppCtx = (const ICHAR* )rgchAppCtxWOBS;
	}

	MsiString strAssemblyName = riParams.GetMsiString(AssemblyName);
	MsiString strServer    = ComposeDescriptor(*MsiString(riParams.GetMsiString(Feature)),
												*MsiString(riParams.GetMsiString(Component)));

	IMsiRecord& riActionData = GetSharedRecord(2); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strAppCtx));
	AssertNonZero(riActionData.SetMsiString(2, *strAssemblyName));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	iatAssemblyType iatType = (iatAssemblyType)riParams.GetInteger(AssemblyType);

	const ICHAR* rgszRegData[] = {
		TEXT("%s\\%s"),       (iatWin32Assembly == iatType || iatWin32AssemblyPvt == iatType) ? _szGPTWin32AssembliesKey : _szGPTNetAssembliesKey, strAppCtx,0,
		strAssemblyName,      strServer,        g_szTypeMultiSzStringDD,
		0,
		0,
	};

	{
		CElevate elevate;
		return ProcessRegInfo(rgszRegData, m_hKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
	}
}


const idtEnum rgidtMediaTypes[] = {idtCDROM, idtRemovable}; //!! need to add floppy when it's distinguished from removable

iesEnum CMsiOpExecute::PopulateMediaList(const MsiString& strSourceListMediaKey, const IMsiRecord& riParams, int iFirstField, int iNumberOfMedia)
{
	MsiString strMediaInfo;
	MsiString strMediaNumber;
	unsigned int iMediaArg = iFirstField + 1;
	
	while (iNumberOfMedia--)
	{
		int iDisk          = riParams.GetInteger(iMediaArg);
		MsiString strLabel = riParams.GetString(iMediaArg + 1);
		strMediaNumber     = MsiString(iDisk);

		strMediaInfo  = strLabel;
		strMediaInfo += TEXT(";");
		strMediaInfo += MsiString(riParams.GetString(iMediaArg + 2));
		iMediaArg += 3;

		// we elevate this block to ensure that we're able to write to our key
		{
			CElevate elevate;
			const ICHAR* rgszMediaRegData[] = {
					TEXT("%s"), strSourceListMediaKey, 0, 0,
					strMediaNumber,      strMediaInfo,       g_szTypeString,
					0,
					0,
					};

			iesEnum iesRet = ProcessRegInfo(rgszMediaRegData, m_hKey, fFalse, 0, 0, ibtCommon);
			if (iesRet != iesSuccess && iesRet != iesNoAction)
				return iesRet;
		}
	}
	return iesSuccess;
}

iesEnum CMsiOpExecute::PopulateNonMediaList(const MsiString& strSourceListKey, const IMsiRecord& riParams, int iFirstSource, int &iNetIndex, int &iURLIndex)
{
	enum {
		rdSourceListKey        = 1,
		rdIndex                = 4,
		rdSource               = 5,
		rdType                 = 6,
	};
	
	const ICHAR* rgszRegData[] = {
		TEXT("%s"), 0/*rdSourceListKey*/, 0, 0,
		0 /*rdIndex*/,  0 /*rdSource*/,  g_szTypeExpandString /*rdType*/ ,
		0,
		0,
	};
	
	MsiString strSourceListURLKey   = strSourceListKey;
	strSourceListURLKey += MsiString(MsiChar(chRegSep));
	strSourceListURLKey += MsiString(szSourceListURLSubKey);

	MsiString strSourceListNetKey   = strSourceListKey;
	strSourceListNetKey += MsiString(MsiChar(chRegSep));
	strSourceListNetKey += MsiString(szSourceListNetSubKey);

	for (int c = iFirstSource; !riParams.IsNull(c); c++)
	{
		MsiString strUnexpandedSourcePath = riParams.GetString(c);
		MsiString strSourceListSubKey;
		MsiString strIndex;

		bool fIsURL = IsURL(strUnexpandedSourcePath) == fTrue;

		if (fIsURL)
		{
			strIndex = MsiString(iURLIndex++);
			strSourceListSubKey = strSourceListURLKey;
		}
		else
		{
			strIndex = MsiString(iNetIndex++);
			strSourceListSubKey = strSourceListNetKey;
		}
			
		// elevate this block to ensure that we're able to write to our key
		{
			CElevate elevate;

			rgszRegData[rdSourceListKey] = strSourceListSubKey;
			rgszRegData[rdIndex]         = strIndex;
			// Note that we don't respect VolumePref here. We assume that the admin has specified the path in the form they desire.
			rgszRegData[rdSource]        = strUnexpandedSourcePath;

			iesEnum iesRet = ProcessRegInfo(rgszRegData, m_hKey, fFalse, 0, 0, ibtCommon);
			if (iesRet != iesSuccess && iesRet != iesNoAction)
				return iesRet;
		}
	}
	return iesSuccess;
}


/*---------------------------------------------------------------------------
ProcessPublishSourceList:
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessPublishSourceList(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoSourceListPublish;

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO)) // do we write/delete the registry
		return iesSuccess;

	iesEnum iesRet;

	MsiString strPatchCode = riParams.GetMsiString(PatchCode);

	// special check required for patch source list unregistration
	if(fRemove && strPatchCode.TextSize() &&
		true == PatchHasClients(*strPatchCode,
										*MsiString(riParams.GetMsiString(IxoSourceListUnpublish::UpgradingProductCode))))
	{
		return iesSuccess;
	}

	// delete existing source lists

	PMsiRecord pParams = &m_riServices.CreateRecord(IxoRegOpenKey::Args);
	
	// construct URL and Net source list subkey strings
	
	MsiString strPackageName;
	MsiString strSourceListKey;
	if (strPatchCode.TextSize())
	{
		strSourceListKey =  _szGPTPatchesKey;
		strSourceListKey += MsiString(MsiChar(chRegSep));
		strSourceListKey += MsiString(GetPackedGUID(strPatchCode));
		strPackageName   =  riParams.GetMsiString(PatchPackageName);
	}
	else
	{
		strSourceListKey =  _szGPTProductsKey;
		strSourceListKey += MsiString(MsiChar(chRegSep));
		strSourceListKey += MsiString(GetPackedGUID(MsiString(GetProductKey())));   
		strPackageName   =  MsiString(GetPackageName());
	}

	strSourceListKey += MsiString(MsiChar(chRegSep));
	strSourceListKey += szSourceListSubKey;
	MsiString strSourceListMediaKey = strSourceListKey;
	strSourceListMediaKey += MsiString(MsiChar(chRegSep));
	strSourceListMediaKey += MsiString(szSourceListMediaSubKey);

	// always delete existing source list keys
	m_cSuppressProgress++;  
#ifdef _WIN64   // !merced
	AssertNonZero(pParams->SetHandle(IxoRegOpenKey::Root, (HANDLE)m_hKey));
#else
	AssertNonZero(pParams->SetInteger(IxoRegOpenKey::Root, (int)m_hKey));
#endif
	AssertNonZero(pParams->SetInteger(IxoRegOpenKey::BinaryType, (int)ibtCommon));

	AssertNonZero(pParams->SetMsiString(IxoRegOpenKey::Key, *strSourceListKey));
	// we elevate this block to ensure that we're able to remove our key
	{
		CElevate elevate;
		iesRet = ixfRegOpenKey(*pParams);
		if (iesRet == iesSuccess || iesRet == iesNoAction)
			iesRet = ixfRegRemoveKey(*pParams);//!! should pass in a new record of size IxoRegRemoveKey::Args here to be safe from future revision
	}
	m_cSuppressProgress--;  

	if(m_hKeyRm) // duplicate action for user assigned apps in the non-assigned (roaming) hive
	{
		if (iesRet != iesSuccess && iesRet != iesNoAction)
			return iesRet;

		m_cSuppressProgress++;  
#ifdef _WIN64   // !merced
		AssertNonZero(pParams->SetHandle(IxoRegOpenKey::Root, (HANDLE)m_hKeyRm));
#else
		AssertNonZero(pParams->SetInteger(IxoRegOpenKey::Root, (int)m_hKeyRm));
#endif
		AssertNonZero(pParams->SetInteger(IxoRegOpenKey::BinaryType, (int)ibtCommon));

		AssertNonZero(pParams->SetMsiString(IxoRegOpenKey::Key, *strSourceListKey));
		// we elevate this block to ensure that we're able to remove our key
		{
			CElevate elevate;
			iesRet = ixfRegOpenKey(*pParams);
			if (iesRet == iesSuccess || iesRet == iesNoAction)
				iesRet = ixfRegRemoveKey(*pParams);//!! should pass in a new record of size IxoRegRemoveKey::Args here to be safe from future revision
		}
		m_cSuppressProgress--;  
	}
	
	if (fRemove || (iesRet != iesSuccess && iesRet != iesNoAction))
		return iesRet;

	// populate source list keys
	PMsiRecord pError(0);
	int cSources = riParams.GetFieldCount();

	enum {
		rdSourceListKey        = 1,
		rdIndex                = 4,
		rdSource               = 5,
		rdType                 = 6,
	};

	const ICHAR* rgszRegData[] = {
		TEXT("%s"), 0/*rdSourceListKey*/, 0, 0,
		0 /*rdIndex*/,  0 /*rdSource*/,  g_szTypeString /*rdType*/ ,
		0,
		0,
	};

	// we elevate this block to ensure that we're able to write to our key
	{
		CElevate elevate;
	
		rgszRegData[rdSourceListKey] = strSourceListKey;
		rgszRegData[rdIndex]         = szPackageNameValueName;
		rgszRegData[rdSource]        = strPackageName;
		
		iesRet = ProcessRegInfo(rgszRegData, m_hKey, fFalse, 0, 0, ibtCommon);
		if (iesRet != iesSuccess && iesRet != iesNoAction)
			return iesRet;
	}

	rgszRegData[rdType]          = g_szTypeExpandString;

	unsigned int cDisks = riParams.GetInteger(NumberOfDisks);
	
	m_iMaxNetSource = 1;
	m_iMaxURLSource = 1;

	// populate Net and URL source list
	if (iesSuccess != (iesRet = PopulateNonMediaList(strSourceListKey, riParams, IxoSourceListPublish::NumberOfDisks + 1 + (3*cDisks), m_iMaxNetSource, m_iMaxURLSource)))
		return iesRet;

	// Populate media entries

	MsiString strMediaPackagePath  = riParams.GetString(PackagePath);
	MsiString strDiskPromptTemplate = riParams.GetString(DiskPromptTemplate);

	// write the disk prompt template and the media package path    
	if (cDisks)
	{
		// we elevate this block to ensure that we're able to write to our key
		{
			CElevate elevate;
			const ICHAR* rgszMediaRelativePathRegData[] = {
				TEXT("%s"), strSourceListMediaKey, 0, 0,
				szMediaPackagePathValueName,      strMediaPackagePath,       g_szTypeString,
				szDiskPromptTemplateValueName,     strDiskPromptTemplate,      g_szTypeString,
				0,
				0
				};

			iesRet = ProcessRegInfo(rgszMediaRelativePathRegData, m_hKey, fFalse, 0, 0, ibtCommon);
			if (iesRet != iesSuccess && iesRet != iesNoAction)
				return iesRet;
		}
	}

	// write the media entries
	iesRet = PopulateMediaList(strSourceListMediaKey, riParams, IxoSourceListPublish::NumberOfDisks, cDisks);
	
	return iesRet;
}

/*---------------------------------------------------------------------------
ProcessPublishSourceListEx: Registers additional sources for a product
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessPublishSourceListEx(IMsiRecord& riParams)
{
	using namespace IxoSourceListAppend;

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CNFGINFO)) // do we write/delete the registry
		return iesSuccess;

	iesEnum iesRet;

	MsiString strPatchCode = riParams.GetMsiString(PatchCode);

	// construct URL and Net source list subkey strings
	
	MsiString strPackageName;
	MsiString strSourceListKey;
	if (strPatchCode.TextSize())
	{
		strSourceListKey =  _szGPTPatchesKey;
		strSourceListKey += MsiString(MsiChar(chRegSep));
		strSourceListKey += MsiString(GetPackedGUID(strPatchCode));
	}
	else
	{
		strSourceListKey =  _szGPTProductsKey;
		strSourceListKey += MsiString(MsiChar(chRegSep));
		strSourceListKey += MsiString(GetPackedGUID(MsiString(GetProductKey())));   
	}

	strSourceListKey += MsiString(MsiChar(chRegSep));
	strSourceListKey += szSourceListSubKey;
	strSourceListKey += MsiString(MsiChar(chRegSep));
	MsiString strSourceListMediaKey = strSourceListKey + MsiString(szSourceListMediaSubKey);
	strSourceListKey.Remove(iseLast, 1);

	unsigned int cDisks = riParams.GetInteger(NumberOfMedia);

	// process additional net/URL sources. Additional sources should be added at the end of the list,
	// which requires retrieving the current largest source for both types.
	int iNetIndex = 0;
	int iURLIndex = 0;

	// if this is a patch, we have to open the sourcelist key for the patch and
	// enumerate through the values to ensure that we don't duplicate a source
	// index. For the product itself, we can use the stored state
	if (strPatchCode.TextSize())
	{
		PMsiRegKey pRegKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hKey);        

		MsiString strSourceListNetKey   = strSourceListKey;
		MsiString strSourceListURLKey   = strSourceListKey;
		strSourceListURLKey += MsiString(MsiChar(chRegSep)) + MsiString(szSourceListURLSubKey);
		strSourceListNetKey += MsiString(MsiChar(chRegSep)) + MsiString(szSourceListNetSubKey);

		int *piIndex = NULL;
		for (int iType =0; iType<2; iType++)
		{
			piIndex = iType ? &iURLIndex : &iNetIndex;
			
			// open subkey to determine max index for net and URL sources
			PMsiRegKey pFormatKey = &pRegKey->CreateChild(iType ? strSourceListURLKey : strSourceListNetKey);
			PEnumMsiString pEnumString(0);
			PMsiRecord piError = 0;
			if ((piError = pFormatKey->GetValueEnumerator(*&pEnumString)) != 0)
				continue;
				
			MsiString strIndex;
			while (S_OK == pEnumString->Next(1, &strIndex, 0))
			{
				int iIndex = strIndex;

				if (iIndex > *piIndex)
					*piIndex = iIndex;
			}
		}

		// increment the indicies by 1 so the first write doesn't overwrite the current maximum
		iNetIndex++;
		iURLIndex++;
	}
	else
	{
		iNetIndex = m_iMaxNetSource;
		iURLIndex = m_iMaxURLSource;
	}
	
	// actually populate the list
	if (iesSuccess != (iesRet = PopulateNonMediaList(strSourceListKey, riParams, IxoSourceListAppend::NumberOfMedia + 1 + (3*cDisks), iNetIndex, iURLIndex)))
		return iesRet;

	if (!strPatchCode.TextSize())
	{
		m_iMaxNetSource = iNetIndex;
		m_iMaxURLSource = iURLIndex;
	}

	// Populate additional media entries. ProcessPublishSourceList registers the disk
	// template and disk prompt template, so we just need to register disk IDs and labels.
	iesRet = PopulateMediaList(strSourceListMediaKey, riParams, IxoSourceListAppend::NumberOfMedia, cDisks);
	
	return iesRet;
}

/*---------------------------------------------------------------------------
ixfSourceListPublish:Publish source list
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSourceListPublish(IMsiRecord& riParams)
{
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfSourceListPublish")));
		return iesFailure;
	}
	return ProcessPublishSourceList(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfSourceListPublishEx:Publish additional source list entries
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSourceListAppend(IMsiRecord& riParams)
{
	// for reverse-advertisement, removal is accomplished by the original
	// SourceListPublish operation.
	if (m_fReverseADVTScript)
		return iesSuccess;
		
	// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfSourceListAppend")));
		return iesFailure;
	}
	return ProcessPublishSourceListEx(riParams);
}

/*---------------------------------------------------------------------------
ixfSourceListUnpublish
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSourceListUnpublish(IMsiRecord& riParams)
{
		// are we in sequence
	if(!MsiString(GetProductKey()).TextSize())
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfSourceListUnpublish")));
		return iesFailure;
	}
	return ProcessPublishSourceList(riParams, fTrue);
}

/*---------------------------------------------------------------------------
ixfSourceListRegisterLastUsed
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSourceListRegisterLastUsed(IMsiRecord& riParams)
{
	using namespace IxoSourceListRegisterLastUsed;
	
	PMsiRecord pError(0);
	iesEnum iesRet;
	MsiString strLastUsedSource = riParams.GetMsiString(LastUsedSource);
	MsiString strProductKey     = riParams.GetMsiString(SourceProduct);
	Assert(strProductKey.TextSize());

	MsiString strRawSource, strIndex, strType, strSource, strSourceListKey, strSourceListSubKey;
	


	if ((pError = m_riConfigurationManager.SetLastUsedSource(strProductKey, strLastUsedSource, /*fAddToList =*/ fTrue, fFalse,
		&strRawSource, &strIndex, &strType, &strSource, &strSourceListKey, &strSourceListSubKey)) != 0)
		return FatalError(*pError);

	// we elevate this block to ensure that we're able to write to our key
	{
		CElevate elevate;

		MsiString strLastUsedSource = strType;
		strLastUsedSource += MsiChar(';');
		strLastUsedSource += strIndex;
		strLastUsedSource += MsiChar(';');
		strLastUsedSource += strRawSource;

		const ICHAR* rgszRegData[] = {
			TEXT("%s"), strSourceListKey, 0, 0,
			szLastUsedSourceValueName,      strLastUsedSource, g_szTypeExpandString,
			0,
			TEXT("%s"), strSourceListSubKey, 0, 0,
			strIndex,                       strSource,    g_szTypeExpandString,
			0,
			0,
		};

		if((iesRet = ProcessRegInfo(rgszRegData, m_hKey, fFalse, 0, 0, ibtCommon)) != iesSuccess)
			return iesRet;
	}

	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixfURLSourceTypeRegister
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfURLSourceTypeRegister(IMsiRecord& riParams)
{
	using namespace IxoURLSourceTypeRegister;

	PMsiRecord pError(0);
	iesEnum iesRet;

	MsiString strProductKey = riParams.GetMsiString(ProductCode);
	int iSourceType         = riParams.GetInteger(SourceType);
	MsiString strSourceType = iSourceType;

	Assert(strProductKey.TextSize());

	MsiString strSourceListURLKey;
	strSourceListURLKey =  _szGPTProductsKey;
	strSourceListURLKey += MsiString(MsiChar(chRegSep));
	strSourceListURLKey += MsiString(GetPackedGUID(strProductKey));   
	strSourceListURLKey += MsiString(MsiChar(chRegSep));
	strSourceListURLKey += szSourceListSubKey;
	strSourceListURLKey += MsiString(MsiChar(chRegSep));
	strSourceListURLKey += MsiString(szSourceListURLSubKey);

	// we elevate this block to ensure that we're able to write to our key
	{
		CElevate elevate;

		const ICHAR* rgszRegData[] = {
			TEXT("%s"), strSourceListURLKey, 0, 0,
			szURLSourceTypeValueName,      (const ICHAR*)strSourceType, g_szTypeInteger,
			0,
			0,
		};

		if((iesRet = ProcessRegInfo(rgszRegData, m_hKey, fFalse, 0, 0, ibtCommon)) != iesSuccess)
			return iesRet;
	}

	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixfSecureTransformCache: Cache secure transform
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfSecureTransformCache(IMsiRecord& riParams)
{
	using namespace IxoSecureTransformCache;
	// Record description
	// 1 = Transform // full path to transform to cache
	// 2 = Transform type (secure vs source)

	// copy transform to the product's secure cache location

	PMsiRecord pError(0);
	iesEnum iesRet;

	PMsiPath pSourcePath(0);
	MsiString strFileName;
	pError = m_riServices.CreateFilePath(riParams.GetString(IxoSecureTransformCache::Transform), *&pSourcePath, *&strFileName);
	if (pError)
		return FatalError(*pError);

	PMsiPath pTransformPath(0);
	MsiString strDestFileName;
#ifndef UNICODE
	pError = GetSecureTransformCachePath(m_riServices, 
										 *MsiString(GetProductKey()), 
										 *&pTransformPath);
	if (pError)
		return FatalError(*pError);

	strDestFileName = strFileName;
#else
	// get the appropriate secure transforms cache key/ value
	MsiString strSecureTransformsKey;
	pError = GetProductSecureTransformsKey(*&strSecureTransformsKey);
	if(pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	MsiString strCachePath = GetMsiDirectory();
	Assert(strCachePath.TextSize());
	if((pError = m_riServices.CreatePath(strCachePath,*&pTransformPath)) != 0)
		return FatalError(*pError);

	PMsiRegKey pHKLM = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)m_hUserDataKey, ibtCommon);		//--merced: changed (int) to (INT_PTR)
	PMsiRegKey pSecureTransformsKey = &pHKLM->CreateChild(strSecureTransformsKey);
	MsiString strValue;
	bool fSourceTransformType = !riParams.IsNull(IxoSecureTransformCache::AtSource);
	MsiString strValueName = fSourceTransformType ? strFileName : MsiString(riParams.GetMsiString(IxoSecureTransformCache::Transform));
	pError = pSecureTransformsKey->GetValue(strValueName, *&strValue);
	if ((pError == 0) && (strValue.TextSize() != 0))
	{
		MsiString strTransformFullPath;
		if((pError = pTransformPath->GetFullFilePath(strValue,*&strTransformFullPath)) == 0)
		{
			IMsiRecord& riFileRemove = GetSharedRecord(IxoFileRemove::Args);
			riFileRemove.SetMsiString(IxoFileRemove::FileName, *strTransformFullPath);
			if ((iesRet = ixfFileRemove(riFileRemove)) != iesSuccess)
				return iesRet;
		}
	}

	{
		// elevate for creating temp file in secure location
		CElevate elevate;

		// Generate a unique name for transform, create and secure the file.
		// set dest path and file name
		if (((pError = pTransformPath->EnsureExists(0)) != 0) ||
			((pError = pTransformPath->TempFileName(0, szTransformExtension, fTrue, *&strDestFileName, 0)) != 0))
		{
			return FatalError(*pError);
		}
	
		// remove temp file so that CopyOrMoveFile won't attempt to back up old file
		if((pError = pTransformPath->RemoveFile(strDestFileName)) != 0)
			return FatalError(*pError);
	}
#endif
	PMsiStream pSecurityDescriptor(0);
	if ((pError = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pError);

	// copy transform to cached location
	if((iesRet = CopyOrMoveFile(*pSourcePath,*pTransformPath,*strFileName,*strDestFileName, fFalse,fFalse,fTrue,iehShowNonIgnorableError, pSecurityDescriptor, ielfElevateDest)) != iesSuccess)
		return iesRet;

#ifdef UNICODE
	// now register the transform against the temp file name

	// we elevate this block to ensure that we're able to write to our key
	{
		const ICHAR* rgszRegData[] = {
			TEXT("%s"), strSecureTransformsKey, 0,0,
			strValueName, strDestFileName, g_szTypeString,
			0,
			0,
		};
		CElevate elevate;
		return ProcessRegInfo(rgszRegData, m_hUserDataKey, fFalse, pSecurityDescriptor, 0, ibtCommon);
	}
#else
	return iesSuccess;
#endif
}


/*---------------------------------------------------------------------------
ixfIconCreate: Create icon files
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfIconCreate(IMsiRecord& riParams)
{
	using namespace IxoIconCreate;
	// Record description
	// 1 = IconName // includes the file extension since this could be .ICO or .EXE or .DLL
	// 2 = IconData

	return ProcessIcon(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixoIconRemove: Remove icon files
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfIconRemove(IMsiRecord& riParams)
{
	using namespace IxoIconRemove;
	// Record description
	// 1 = IconName // includes the file extension since this could be .ICO or .EXE or .DLL

	return ProcessIcon(riParams, fTrue);
}

/*---------------------------------------------------------------------------
ProcessIcon: Process icon info for advertising
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessIcon(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoIconCreate;
	// Record description
	// 1 = IconName // includes the file extension since this could be .ICO or .EXE or .DLL
	// 2 = IconData

	if(!(m_fFlags & SCRIPTFLAGS_CACHEINFO))// do we process the cached icons/ transforms
		return iesSuccess;
	PMsiRecord pRecErr(0);
	MsiString strIconFullPath = riParams.GetMsiString(Icon);
	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strIconFullPath));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;
	
	PMsiPath pIconFolder(0);
	MsiString strIconName;
	if(PathType(strIconFullPath) == iptFull)
	{
		//!!SECURITY -- is it OK to elevate for this "full path" case?
		if((pRecErr = m_riServices.CreateFilePath(strIconFullPath,*&pIconFolder,*&strIconName)) != 0)
			return FatalError(*pRecErr);
	}
	else
	{
		pIconFolder = m_pCachePath;
		strIconName = strIconFullPath;

		if((pRecErr = pIconFolder->GetFullFilePath(strIconName, *&strIconFullPath)) != 0)
			return FatalError(*pRecErr);
	}

	PMsiData pData(0);
	if(fRemove == fFalse)
	{
		pData = riParams.GetMsiData(Data);
	}
//  IMsiData* piData = pData;

	// elevate this block so we can access our cached location
	{
		CElevate elevate;
		if(fRemove) // we simply remove the file
		{
			// schedule file for deletion once we let go of install packages/transforms
			if(iesSuccess != DeleteFileDuringCleanup(strIconFullPath, true))
			{
				DispatchError(imtInfo,Imsg(idbgOpScheduleRebootRemove), *strIconFullPath);
			}

			return iesSuccess;
		}
		else
		{
			LPSECURITY_ATTRIBUTES pAttributes;
			SECURITY_ATTRIBUTES saAttributes;
			if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
			{
				GetLockdownSecurityAttributes(saAttributes, false);
				pAttributes = &saAttributes;
			}
			else
			{
				// do not attempt to secure the icon file in the  appdata folder
				// since it might not be local OR may move to the net later
				pAttributes = 0;
			}

			iesEnum iesRet = ProcessFileFromData(*pIconFolder,*strIconName, pData, pAttributes);
			if((pRecErr = m_pCachePath->SetFileAttribute(strIconName, ifaReadOnly, fTrue)))
			{
				Message(imtInfo, *pRecErr);
			}
			return iesRet;
		}
	}
}

iesEnum CMsiOpExecute::ProcessFileFromData(IMsiPath& riPath, const IMsiString& ristrFileName, const IMsiData* piData, LPSECURITY_ATTRIBUTES pAttributes)
{
	PMsiRecord pRecErr(0);
	iesEnum iesRet = iesNoAction;
	MsiString strFileFullPath;
	if((pRecErr = riPath.GetFullFilePath(ristrFileName.GetString(),*&strFileFullPath)) != 0)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}
	Bool fExists;
	if((pRecErr = riPath.FileExists(ristrFileName.GetString(),fExists)) != 0)
	{
		Message(imtError, *pRecErr);
		return iesFailure;
	}
	IMsiRecord* piUndoParams = 0;
	if(fExists && RollbackEnabled())
	{
		if((iesRet = BackupFile(riPath, ristrFileName, fTrue, fTrue, iehShowIgnorableError)) != iesSuccess)
			return iesRet;
	}

	Assert(piData);
	// generate rollback op to remove the new file
	piUndoParams = &GetSharedRecord(IxoFileRemove::Args);
	AssertNonZero(piUndoParams->SetMsiString(IxoFileRemove::FileName,*strFileFullPath));
	AssertNonZero(piUndoParams->SetInteger(IxoFileRemove::Elevate, true));
	if (!RollbackRecord(ixoFileRemove,*piUndoParams))
		return iesFailure;

	return CreateFileFromData(riPath,ristrFileName,piData, pAttributes);
}
	
iesEnum CMsiOpExecute::CreateFileFromData(IMsiPath& riPath, const IMsiString& ristrFileName, const IMsiData* piData, LPSECURITY_ATTRIBUTES pAttributes)
{
	Assert(piData);
	PMsiRecord pError(0);

	MsiString strFileFullPath;
	if((pError = riPath.GetFullFilePath(ristrFileName.GetString(),*&strFileFullPath)) != 0)
		return FatalError(*pError);
	
	PMsiStream piStream(0);
	if(piData->QueryInterface(IID_IMsiStream, (void**)&piStream) != NOERROR)
	{
		DispatchError(imtError,Imsg(idbgOpCreateFileFromData),*strFileFullPath);
		return iesFailure;
	}
	PMsiPath piPath(0);
	// make sure the icon path exists
	if(CreateFolder(riPath) != iesSuccess)
		return iesFailure;

	// make sure we can create the file
	if ((pError = riPath.EnsureOverwrite(ristrFileName.GetString(), 0)))
		return FatalError(*pError);

	bool fImpersonate = RunningAsLocalSystem() &&
						FVolumeRequiresImpersonation(*PMsiVolume(&riPath.GetVolume()));
			
	if(fImpersonate)
		AssertNonZero(StartImpersonating());
	
	HANDLE hFile = WIN::CreateFile(strFileFullPath, GENERIC_WRITE, FILE_SHARE_READ, pAttributes,
								CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	DWORD dwLastError = GetLastError();
	if (ERROR_ALREADY_EXISTS == dwLastError)
	{
		// when called from ProcessDataFromFile, the file is removed by the backup call.
		// The file is now locked, and truncated, so we'll just need to explicitly apply the ACL.
		dwLastError = 0;
		if (!g_fWin9X && pAttributes && pAttributes->lpSecurityDescriptor && RunningAsLocalSystem())
		{
			CElevate elevate;
			CRefCountedTokenPrivileges cPrivs(itkpSD_WRITE);
			AssertNonZero(WIN::SetFileSecurity(strFileFullPath,
				GetSecurityInformation(pAttributes->lpSecurityDescriptor),
				pAttributes->lpSecurityDescriptor));
		}
	}

	if(fImpersonate)
		StopImpersonating();
	
	if((hFile == INVALID_HANDLE_VALUE) || dwLastError)
	{
		DispatchError(imtError,Imsg(idbgOpCreateFileFromData),(const ICHAR*)strFileFullPath,(int)dwLastError);
		return iesFailure;
	}

	MsiRegisterSysHandle(hFile);
	char rgchBuf[1024];
	int cbRead, cbWrite;
	do
	{
		cbRead = sizeof(rgchBuf);
		cbWrite = piStream->GetData(rgchBuf, cbRead);
		if (cbWrite)
		{
			unsigned long cbFileWritten;
			if (!WIN::WriteFile(hFile, rgchBuf, cbWrite, &cbFileWritten, 0))
			{
				WIN::DeleteFile(strFileFullPath); // ignore error
				AssertNonZero(MsiCloseSysHandle(hFile));
				DWORD dwLastError = GetLastError();
				DispatchError(imtError,Imsg(idbgOpCreateFileFromData),(const ICHAR*)strFileFullPath,(int)dwLastError);
				return iesFailure;
			}
			Assert(cbWrite == cbFileWritten);
		}
	} while (cbWrite == cbRead);
	AssertNonZero(MsiCloseSysHandle(hFile));
	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixfShortcutCreate: Create shortcut
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfShortcutCreate(IMsiRecord& riParams)
{
	using namespace IxoShortcutCreate;
	// Record description
	// 1 = Shortcut Name
	// 2 = Target/ Darwin Descriptor
	// 3 = Arguments
	// 4 = WorkingDir //?? how do we get this
	// 5 = IconName
	// 6 = IconIndex
	// 7 = Hotkey
	// 8 = ShowCmd

	return ProcessShortcut(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfShortcutRemove: Remove shortcut
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfShortcutRemove(IMsiRecord& riParams)
{
	// Record description
	// 1 = Shortcut Name
	return ProcessShortcut(riParams, fTrue);
}


/*---------------------------------------------------------------------------
ProcessShortcut: Manage shortcuts
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessShortcut(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoShortcutCreate;
	// Record description
	// 1 = Shortcut Name
	// 2 = Feature
	// 3 = Component
	// 4 = FileName
	// 3 = Arguments
	// 4 = WorkingDir //?? how do we get this
	// 5 = IconName
	// 6 = IconIndex
	// 7 = Hotkey
	// 8 = ShowCmd
	// 9 = Description

	if(!(m_fFlags & SCRIPTFLAGS_SHORTCUTS)) // we do not create/ delete shortcuts
		return iesSuccess;

	if(!m_state.pTargetPath)
	{  // must not have called ixoSetTargetFolder
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						*MsiString(*TEXT("ixoShortcutCreate")));
		return iesFailure;
	}


	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *MsiString(riParams.GetMsiString(Name))));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	PMsiRecord piError(0);
	iesEnum iesRet = iesNoAction;

	CTempBuffer<ICHAR, MAX_PATH> rgchTemp, rgchPath;
	PMsiRecord pCurrentShortcutInfo = &m_riServices.CreateRecord(Args);
	MsiString strShortcutName;
	if((piError = m_riServices.ExtractFileName(riParams.GetString(Name),m_state.pTargetPath->SupportsLFN(),*&strShortcutName)) != 0)
	{
		Message(imtError, *piError);
		return iesFailure;
	}

	if((piError = EnsureShortcutExtension(strShortcutName, m_riServices)) != 0)
	{
		Message(imtError, *piError);
		return iesFailure;
	}

	// we can only create/ delete shortcuts that do not have the FileName, if the shell supports Darwin Descriptors
	Bool fDDSupport = IsDarwinDescriptorSupported(iddOLE);
	Bool fShellSupport = IsDarwinDescriptorSupported(iddShell); //smart shell
	CSecurityDescription security;

	MsiString strShortcutFullPath;
	if((piError = m_state.pTargetPath->GetFullFilePath(strShortcutName, *&strShortcutFullPath)) != 0)
	{
		Message(imtError, *piError);
		return iesFailure;
	}
	Bool fExists = fFalse, fShortcut = fFalse;
	if((piError = m_state.pTargetPath->FileExists(strShortcutName, fExists)) != 0)
	{
		Message(imtError, *piError);
		return iesFailure;
	}

	if (!g_fWin9X && fExists)
	{
		security.Set(strShortcutFullPath);
		if (!security.isValid())
		{
			// create an error record to get the verbose logging, but ignore the error
			PMsiRecord(PostError(Imsg(imsgGetFileSecurity), WIN::GetLastError(), strShortcutFullPath));
		}
	}

	if(fRemove && fExists && (fDDSupport || fShellSupport))
	{
		// is the existing shortcut a darwin descriptor shortcut and if so is it pointing to this product
		ICHAR szProductCode[cchGUID+1];
		if((GetShortcutTarget(strShortcutFullPath, szProductCode, 0, 0)) &&
			(IStrComp(szProductCode, MsiString(GetProductKey()))))
		{
			// dont delete the shortcut, not pointing to our product
			DEBUGMSG2(TEXT("Skipping shortcut %s removal, shortcut has been overwritten by another product %s"), (const ICHAR*)strShortcutName, szProductCode);
			return iesSuccess;
		}
	}

	if(RollbackEnabled())
	{
		if(fExists)
		{

			if((iesRet = BackupFile(*m_state.pTargetPath,*strShortcutName, fTrue, fFalse, iehShowIgnorableError)) != iesSuccess)
				return iesRet;
		}
		else if(!fRemove)
		{
			// remove new shortcut on rollback
			IMsiRecord& riUndoParams = GetSharedRecord(IxoFileRemove::Args);
			AssertNonZero(riUndoParams.SetMsiString(IxoFileRemove::FileName, *strShortcutName));
			if (!RollbackRecord(ixoFileRemove,riUndoParams))
				return iesFailure;
		}
	}

	PMsiPath piPath1(0);
	if(fRemove == fFalse)
	{
		MsiString strServerFile = riParams.GetMsiString(FileName);

		if(!strServerFile.TextSize() && !fDDSupport && !fShellSupport)
			return iesRet;

		MsiString strServerDarwinDescriptor = ComposeDescriptor(*MsiString(riParams.GetMsiString(Feature)),
											  *MsiString(riParams.GetMsiString(Component)));

		// how much of the path exists - (for shell notification)
		if((piError = m_state.pTargetPath->ClonePath(*&piPath1)) != 0)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning), Imsg(imsgOpShortcutCreate), *strShortcutName);
			return iesSuccess;
		}

		Bool fExists = fFalse;
		while(((piError = piPath1->Exists(fExists)) == 0) && (fExists == fFalse))
		{
			AssertZero(piPath1->ChopPiece());
		}
		if(piError)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning), Imsg(imsgOpShortcutCreate), *strShortcutName);
			return iesSuccess;
		}


		if((iesRet = CreateFolder(*m_state.pTargetPath)) != iesSuccess)
			return iesRet;

		// get a record for the shortcut info
		IMsiRecord& riShortcutInfoRec = GetSharedRecord(icsEnumCount); // don't change ref count - shared record
		// get the target location
		// get the working directory
		if(!riParams.IsNull(WorkingDir))
		{
			MsiString strEncodedPath = riParams.GetMsiString(WorkingDir);
			CTempBuffer<ICHAR,  MAX_PATH> rgchPath;
			MsiString strLocation = strEncodedPath.Extract(iseUpto, MsiChar(chDirSep));
			if(strLocation != iMsiStringBadInteger)
			{
				// we have a shell folder id
				int iFolderId = strLocation;
				piError = GetShellFolder(iFolderId, *&strLocation);
				if(piError)
				{
					DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning), Imsg(imsgOpShortcutCreate), *strShortcutName);
					return iesSuccess;
				}
				if(strEncodedPath.Remove(iseUpto, MsiChar(chDirSep)))
				{
					//?? ugly
					MsiString strDirSep = MsiChar(chDirSep);
					if(strLocation.Compare(iscEnd, strDirSep))
						strLocation.Remove(iseLast, 1); // chop off the separator, if present
					strLocation += strEncodedPath;
				}
			}
			else
			{
				strLocation = strEncodedPath;
			}


			GetEnvironmentStrings(strLocation,rgchPath);
#ifndef _WIN64
			riShortcutInfoRec.SetString(icsWorkingDirectory, rgchPath);
#else
			ICHAR rgchSubstitute[MAX_PATH+1] = {0};
			ICHAR* pszPath = rgchPath;
			if ( g_Win64DualFolders.ShouldCheckFolders() )
			{
				ieSwappedFolder iRes;
				iRes = g_Win64DualFolders.SwapFolder(ie64to32,
																 rgchPath,
																 rgchSubstitute);
				if ( iRes == iesrSwapped )
					pszPath = rgchSubstitute;
				else
					Assert(iRes != iesrError && iRes != iesrNotInitialized);
			}
			riShortcutInfoRec.SetString(icsWorkingDirectory, pszPath);
#endif // _WIN64
		}
		if(!riParams.IsNull(Arguments))
			riShortcutInfoRec.SetMsiString(icsArguments, *MsiString(riParams.GetMsiString(Arguments)));
		if(!riParams.IsNull(Icon))
		{
			MsiString strIconName = riParams.GetMsiString(Icon);
			// is this a full path or an index into the icon table
			if(PathType(strIconName) != iptFull)
			{
				MsiString strIconPath = m_pCachePath->GetPath();
				strIconName = strIconPath + strIconName;
			}
			riShortcutInfoRec.SetMsiString(icsIconFullPath, *strIconName);
		}
		if(!riParams.IsNull(IconIndex))
			riShortcutInfoRec.SetInteger(icsIconID, riParams.GetInteger(IconIndex));
		if(!riParams.IsNull(HotKey))
			riShortcutInfoRec.SetInteger(icsHotKey, riParams.GetInteger(HotKey));
		if(!riParams.IsNull(ShowCmd))
			riShortcutInfoRec.SetInteger(icsShowCmd, riParams.GetInteger(ShowCmd));
		if(!riParams.IsNull(Description))
			riShortcutInfoRec.SetMsiString(icsDescription, *MsiString(riParams.GetMsiString(Description)));

		MsiString strTarget;
		if(strServerDarwinDescriptor.TextSize() && (fShellSupport || fDDSupport))
		{
			strTarget = MsiString(*szGptShortcutPrefix);
			strTarget += strServerDarwinDescriptor;
			strTarget += MsiString(*szGptShortcutSuffix);
		}
		else
			 strTarget = strServerFile; // use the file

		piError = m_riServices.CreateShortcut(  *m_state.pTargetPath,
												*strShortcutName,
												0,
												strTarget,
												&riShortcutInfoRec,
												security.isValid() ? security.SecurityAttributes() : NULL);
		if (piError)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning), Imsg(imsgOpShortcutCreate), *strShortcutName);
			return iesSuccess;
		}
		if((piError = DoShellNotifyDefer(*m_state.pTargetPath, strShortcutName, *piPath1, fRemove)) != 0)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning), Imsg(imsgOpShortcutCreate), *strShortcutName);
			return iesSuccess;
		}
	}
	else
	{       
		piError = m_riServices.RemoveShortcut(*m_state.pTargetPath, *strShortcutName, 0, 0);
		if (piError)
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning),
							  Imsg(imsgOpShortcutRemove),
							  *strShortcutName);
		// remove folder if possible
		if((iesRet = RemoveFolder(*m_state.pTargetPath)) != iesSuccess)
			return iesRet;

		// how much of the path exists - (for shell notification)
		if((piError = m_state.pTargetPath->ClonePath(*&piPath1)) != 0)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning),
							  Imsg(imsgOpShortcutRemove),
							  *strShortcutName);
			return iesSuccess;
		}

		Bool fExists = fFalse;
		while(((piError = piPath1->Exists(fExists)) == 0) && (fExists == fFalse))
		{
			AssertZero(piPath1->ChopPiece());
		}
		if(piError)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning),
							  Imsg(imsgOpShortcutRemove),
							  *strShortcutName);
			return iesSuccess;
		}
		if((piError = DoShellNotifyDefer(*m_state.pTargetPath, strShortcutName, *piPath1, fRemove)) != 0)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning),
							  Imsg(imsgOpShortcutRemove),
							  *strShortcutName);
			return iesSuccess;
		}
	}

	return iesSuccess;
}


IMsiRecord* CMsiOpExecute::DoShellNotifyDefer(IMsiPath& riShortcutPath, const ICHAR* szFileName, IMsiPath& riPath2, Bool fRemove)
{
	// fix for Darwin bug #8973
	if (fRemove)
		return DoShellNotify(riShortcutPath, szFileName, riPath2, fRemove);

	m_fShellRefresh = fTrue;

	IMsiRecord* piError;
	if (!m_pDatabase)
	{
		// create the database.
		piError = m_riServices.CreateDatabase(0,idoCreate,*&m_pDatabase);
		if(piError)
			return piError;
	}

	if(!m_pShellNotifyCacheTable)
	{
		MsiString strTableName = m_pDatabase->CreateTempTableName();
		piError = m_pDatabase->CreateTable(*strTableName,0,*&m_pShellNotifyCacheTable);
		if(piError)
			return piError;

		MsiString strNull;
		m_colShellNotifyCacheShortcutPath     = m_pShellNotifyCacheTable->CreateColumn(icdPrimaryKey + icdObject + icdTemporary,
																						 *strNull);
		m_colShellNotifyCacheFileName         = m_pShellNotifyCacheTable->CreateColumn(icdPrimaryKey + icdString + icdTemporary,
																						 *strNull);
		m_colShellNotifyCachePath2            = m_pShellNotifyCacheTable->CreateColumn(icdPrimaryKey + icdObject + icdTemporary,
																						 *strNull);
		// Removes are not deferred.

		Assert(m_colShellNotifyCacheShortcutPath && m_colShellNotifyCacheFileName && m_colShellNotifyCachePath2);

		m_pShellNotifyCacheCursor = m_pShellNotifyCacheTable->CreateCursor(fFalse);
	}

	// cache the entries

	AssertNonZero(m_pShellNotifyCacheCursor->PutMsiData(m_colShellNotifyCacheShortcutPath, &riShortcutPath));
	AssertNonZero(m_pShellNotifyCacheCursor->PutString(m_colShellNotifyCacheFileName, *MsiString(szFileName)));
	AssertNonZero(m_pShellNotifyCacheCursor->PutMsiData(m_colShellNotifyCachePath2, &riPath2));
	AssertNonZero(m_pShellNotifyCacheCursor->Assign());
	
	return 0;
}
iesEnum CMsiOpExecute::ShellNotifyProcessDeferred()
{
	iesEnum iesRet = iesSuccess;
	
	// if there is no database or table, we must be done.
	if (!m_pDatabase || !m_pShellNotifyCacheTable)
		return iesSuccess;
	Assert(m_pShellNotifyCacheCursor);

	//process the entries.
	m_pShellNotifyCacheCursor->Reset();

	PMsiPath pShortcutPath(0);
	MsiString strFileName;
	PMsiPath pPath2(0);
	
	PMsiRecord pError(0);
	while(m_pShellNotifyCacheCursor->Next())
	{
		pShortcutPath     = (IMsiPath*) m_pShellNotifyCacheCursor->GetMsiData(m_colShellNotifyCacheShortcutPath);
		strFileName       = m_pShellNotifyCacheCursor->GetString(m_colShellNotifyCacheFileName);
		pPath2            = (IMsiPath*) m_pShellNotifyCacheCursor->GetMsiData(m_colShellNotifyCachePath2);

		pError = DoShellNotify(*pShortcutPath, (const ICHAR*) strFileName, *pPath2, fFalse);
		if (pError)
		{
			DispatchError(imtEnum(imtWarning|imtOk|imtIconWarning),
					  Imsg(imsgOpShortcutCreate),
					  *strFileName);
			iesRet = iesFailure;
		}
		AssertNonZero(m_pShellNotifyCacheCursor->Delete());
	}
	return iesRet;
}
IMsiRecord* CMsiOpExecute::DoShellNotify(IMsiPath& riShortcutPath, const ICHAR* szFileName, IMsiPath& riPath2, Bool fRemove)
// Please call DoShellNotifyDefer for normal shortcut notifications.  This allows deferral of the notification until
// all files necessary are in place. Darwin bug# 8973
//
// For shortcut creation we need to be sending something like:
// SHCNE_MKDIR C:\foo
// SHCNE_MKDIR C:\foo\bar
// SHCNE_CREATE w/|SHCNF_FLUSHNOWAIT C:\foo\bar\cow.lnk
//
// For shortcut removal we need to be sending something like:
// SHCNE_REMOVE C:\foo\bar\cow.lnk
// SHCNE_REMOVEDIR C:\foo\bar
// SHCNE_REMOVEDIR w/|SHCNF_FLUSHNOWAIT C:\foo
//
{
	IMsiRecord* piError = 0;
	// notify the shell of file removal/ creation
	PMsiPath pShortcutPath(0); // will be doing ChopPiece() on shortcut path so need a new path object
	if((piError = riShortcutPath.ClonePath(*&pShortcutPath)) != 0)
		return piError;
	
	MsiString strShortcutFullName;
	if((piError = pShortcutPath->GetFullFilePath(szFileName, *&strShortcutFullName)) != 0)
		return piError;


	if (fRemove)
	{
		int iNotificationType = SHCNF_PATH;
		DEBUGMSGVD1(TEXT("SHChangeNotify SHCNE_DELETE: %s"),(const ICHAR*)strShortcutFullName);
		ipcEnum ipcCompare;
		bool fContinue = (((piError = riPath2.Compare(*pShortcutPath, ipcCompare)) == 0) && (ipcCompare == ipcChild));

		//
		// Use the SHCNF_FLUSHNOWAIT flag to avoid the possibility of a hang due
		// to the synchronous nature of SHCNF_FLUSH
		//
		if(!fContinue) // we will not be removing the folder
			iNotificationType |= SHCNF_FLUSHNOWAIT;

		SHELL32::SHChangeNotify(SHCNE_DELETE,iNotificationType,(const void* )((const ICHAR*)strShortcutFullName),0);
	

		while (fContinue)
		{
			MsiString strPath = pShortcutPath->GetPath();
			AssertZero(pShortcutPath->ChopPiece());
			if (((piError = riPath2.Compare(*pShortcutPath, ipcCompare)) != 0) || (ipcCompare != ipcChild))
			{
				//
				// This is our last time through the loop; gotta flush
				//
				// Use the SHCNF_FLUSHNOWAIT flag to avoid the possibility of
				// a hang due to the synchronous nature of SHCNF_FLUSH
				//
				iNotificationType |= SHCNF_FLUSHNOWAIT;
				fContinue = false;
			}

			// notify the shell of folder removal/ creation
			DEBUGMSGVD1(TEXT("SHChangeNotify SHCNE_RMDIR: %s"), (const ICHAR* )CConvertString((const ICHAR*)strPath));
			SHELL32::SHChangeNotify(SHCNE_RMDIR,iNotificationType,(const void* )(const ICHAR* )CConvertString((const ICHAR*)strPath),0);
		}
	}
	else // !fRemove
	{
		
		ipcEnum ipcCompare;
		int cTotalPieces = 0;

		// determine how many pieces of the path we have to tell the shell about
		while (((piError = riPath2.Compare(*pShortcutPath, ipcCompare)) == 0) && (ipcCompare == ipcChild))
		{
			cTotalPieces++;
			AssertZero(pShortcutPath->ChopPiece());
		}

		// notify the shell starting with the parent folder and working our way down
		while (cTotalPieces--)
		{
			// we've chopped pShortcutPath to bits; we need the original back
			if((piError = riShortcutPath.ClonePath(*&pShortcutPath)) != 0)
				return piError;

			int cChopped = 0;
			while (cChopped++ < cTotalPieces)
				AssertZero(pShortcutPath->ChopPiece());

			MsiString strPath = pShortcutPath->GetPath();
			DEBUGMSGVD1(TEXT("SHChangeNotify SHCNE_MKDIR: %s"), (const ICHAR* )CConvertString((const ICHAR*)strPath));
			SHELL32::SHChangeNotify(SHCNE_MKDIR,SHCNF_PATH,(const void* )(const ICHAR* )CConvertString((const ICHAR*)strPath),0);

		}
			
		//
		// Use the SHCNF_FLUSHNOWAIT flag to avoid the possibility of
		// a hang due to the synchronous nature of SHCNF_FLUSH
		//
		DEBUGMSGVD1(TEXT("SHChangeNotify SHCNE_CREATE: %s"),(const ICHAR*)strShortcutFullName);
		SHELL32::SHChangeNotify(SHCNE_CREATE,SHCNF_PATH|SHCNF_FLUSHNOWAIT,(const void* )((const ICHAR*)strShortcutFullName),0);
	}

	return piError;
}

/*---------------------------------------------------------------------------
ixfClassInfoRegister: Register OLE registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegClassInfoRegister64(IMsiRecord& riParams)
{
	return ProcessClassInfo(riParams, m_fReverseADVTScript, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegClassInfoRegister(IMsiRecord& riParams)
{
	return ProcessClassInfo(riParams, m_fReverseADVTScript, ibt32bit);
}

/*---------------------------------------------------------------------------
ixfClassInfoUnregister: Unregister OLE registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegClassInfoUnregister64(IMsiRecord& riParams)
{
	return ProcessClassInfo(riParams, fTrue, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegClassInfoUnregister(IMsiRecord& riParams)
{
	return ProcessClassInfo(riParams, fTrue, ibt32bit);
}


/*---------------------------------------------------------------------------
ProcessClassInfo: common routine to Process OLE registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessClassInfo(IMsiRecord& riParams, Bool fRemove, const ibtBinaryType iType)
{
	using namespace IxoRegClassInfoRegister;
	// Record description
	// 1 = Feature
	// 2 = Component
	// 3 = FileName
	// 4 = CLSID
	// 5 = ProgId
	// 6 = VIProgId
	// 7 = Description
	// 8 = Context
	// 9 = Insertable
	//10 = Appid
	//11 = FileTypeMask
	//12 = IconName
	//13 = IconIndex
	//14 = DefInprocHandler
	//15 = Arguments
	//16 = AssemblyName
	//17 = AssemblyType

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CLASSINFO)) // do we write/delete the registry with COM Class stuff
		return iesSuccess;

	iesEnum iesR = EnsureClassesRootKeyRW(); // open HKCR for read/ write
	if(iesR != iesSuccess && iesR != iesNoAction)
		return iesR;

	// the registry structure
	MsiString strClsId   = riParams.GetMsiString(ClsId);//!! assume they come enclosed in the curly brackets
	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strClsId));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	enum clsDefProc{
		clsDefProc16=1,
		clsDefProc32=2,
	};
	MsiString strProgId  = riParams.GetMsiString(ProgId);
	MsiString strVIProgId= riParams.GetMsiString(VIProgId);
	MsiString strDesc    = riParams.GetMsiString(Description);
	MsiString strContext = riParams.GetMsiString(Context);
	const HKEY hOLEKey = (iType == ibt64bit ? m_hOLEKey64 : m_hOLEKey);
	MsiString strDefInprocHandler16;
	MsiString strDefInprocHandler32;
	if(!riParams.IsNull(DefInprocHandler))
	{
		int iDefInprocHandler = riParams.GetInteger(DefInprocHandler);
		if(iDefInprocHandler != iMsiStringBadInteger)
		{
			if(iDefInprocHandler & clsDefProc16)
				strDefInprocHandler16 = TEXT("ole2.dll");
			if(iDefInprocHandler & clsDefProc32)
				strDefInprocHandler32 = TEXT("ole32.dll");
		}
		else
			strDefInprocHandler32 = riParams.GetMsiString(DefInprocHandler);
	}
	MsiString strArgs = riParams.GetMsiString(Argument);

	MsiString strAssembly = riParams.GetMsiString(AssemblyName);
	MsiString strCodebase;
	MsiString strServerDarwinDescriptor;
	if(IsDarwinDescriptorSupported(iddOLE))
	{
		strServerDarwinDescriptor = ComposeDescriptor(*MsiString(riParams.GetMsiString(Feature)),
															*MsiString(riParams.GetMsiString(Component)), 
															strAssembly.TextSize() ? true: false);

	}


	MsiString strServerFile = riParams.GetMsiString(FileName);
	MsiString strDefault;

	//!! we never remove registration for "filename only" registrations
	//!! the "filename only" registrations allow sharing of com registration
	//!! such that each app has its own private copy of the server
	//!! fusion specs recommend that the registration itself be refcounted
	//!! so that we know when to remove it. this has been punted for 1.1
	if(fRemove)
	{
		PMsiRegKey pRootKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)hOLEKey, iType);       //--merced: changed (int) to (INT_PTR)
		ICHAR szRegData[255];
		wsprintf(szRegData, TEXT("CLSID\\%s\\%s"), (const ICHAR*)strClsId, (const ICHAR*)strContext);
		PMsiRegKey pClassKey = &pRootKey->CreateChild(szRegData);
		pClassKey->GetValue(g_szDefaultValue, *&strDefault);
		if(strDefault.TextSize())
		{
			if(strContext.Compare(iscStartI, TEXT("LocalServer"))) // remove args if localserver*, this has to be a short path
			{
				strDefault.Remove(iseFrom, ' ');
			}
		}
		if(ENG::PathType(strDefault) != iptFull)
			strServerFile = g_MsiStringNull;
	}

	if(!strServerDarwinDescriptor.TextSize() && !strServerFile.TextSize())
		return iesSuccess; // would happen during advertisement on a non-dd supported system

	if(strServerFile.TextSize())
	{
		if(ENG::PathType(strServerFile) == iptFull && !strContext.Compare(iscStartI, TEXT("InProcServer")))
		{
			// we always use short file names for OLE servers other than inprocservers
			CTempBuffer<ICHAR,MAX_PATH> rgchSFN;
			DWORD dwSize = 0;
			int cchFile = 0;

			if(ConvertPathName(strServerFile,rgchSFN, cpToShort) != fFalse)
			{
				// success, use short file name in place of long
				strServerFile = (const ICHAR*)rgchSFN;
			}
		}

		// is this com classic to urt assembly interop?
		if(strAssembly.TextSize())
		{
			if(riParams.GetInteger(AssemblyType) == (int)iatURTAssemblyPvt)
				strCodebase = strServerFile; // for privately installed assemblies, set codebase to installed assembly location
			// the server is always <system32folder>\mscoree.dll
			ICHAR szFullPath[MAX_PATH+1];
			AssertNonZero(::GetCOMPlusInteropDll(szFullPath));
			strServerFile = szFullPath;
		}
	}
	if(strArgs.TextSize())
	{
		if(strServerDarwinDescriptor.TextSize())
		{
			strServerDarwinDescriptor += TEXT(" ");
			strServerDarwinDescriptor += strArgs;
		}
		if(strServerFile.TextSize())
		{
			strServerFile += TEXT(" ");
			strServerFile += strArgs;
		}
	}
	ICHAR* pszInsert=TEXT("");    // ugly, but this will prevent the key from being generated
	ICHAR* pszNotInsert=TEXT(""); // ugly, but this will prevent the key from being generated

	if(!riParams.IsNull(Insertable))
	{
		if(!riParams.GetInteger(Insertable))
			pszNotInsert = 0;
		else
			pszInsert = 0;
	}
	MsiString strAppId   = riParams.GetMsiString(AppID);
	MsiString strIconName;
	bool fExpandIconName = false;
	if(!riParams.IsNull(Icon)) //!! check for full path
	{
		MsiString strIconPath = m_pCachePath->GetPath();
		strIconName = strIconPath + MsiString(riParams.GetMsiString(Icon));
		strIconName = GetUserProfileEnvPath(*strIconName, fExpandIconName);
		strIconName += TEXT(",");
		if(riParams.IsNull(IconIndex))
			strIconName += MsiString((int)0);
		else
			strIconName += MsiString(riParams.GetInteger(IconIndex));
	}

	iesEnum iesRet = iesNoAction;

	const ICHAR* rgszRegData[] = {
		TEXT("CLSID\\%s\\%s"), strClsId,strContext,0,
		g_szDefaultValue,     strServerFile,             g_szTypeString,
		strContext,           strServerDarwinDescriptor, g_szTypeMultiSzStringDD,
		0,
		TEXT("CLSID\\%s\\%s"), strClsId,strContext,0,
		g_szAssembly,         strAssembly,               g_szTypeString,
		g_szCodebase,         strCodebase,               g_szTypeString,
		0,
		TEXT("CLSID\\%s"), strClsId,0,0,
		g_szDefaultValue,     strDesc,                   g_szTypeString,
		TEXT("AppID"),        strAppId,                  g_szTypeString,
		0,
		TEXT("CLSID\\%s\\ProgID"), strClsId,0,0,
		g_szDefaultValue,     strProgId,                 g_szTypeString,
		0,
		TEXT("CLSID\\%s\\VersionIndependentProgID"), strClsId,0,0,
		g_szDefaultValue,     strVIProgId,               g_szTypeString,
		0,
		TEXT("CLSID\\%s\\DefaultIcon"), strClsId,0,0,
		g_szDefaultValue,     strIconName,               (fExpandIconName) ? g_szTypeExpandString : g_szTypeString,
		0,
		TEXT("CLSID\\%s\\Insertable"), strClsId,0,0,
		g_szDefaultValue,     pszInsert,                 g_szTypeString,// note that when pszInsert = 0 it creates the key, otherwise if *pszInsert = 0 it skips it
		0,
		TEXT("CLSID\\%s\\NotInsertable"), strClsId,0,0,
		g_szDefaultValue,     pszNotInsert,              g_szTypeString,// note that when pszNotInsert = 0 it creates the key, otherwise if *pszNotInsert = 0 it skips it
		0,
		TEXT("CLSID\\%s\\InprocHandler32"),strClsId,0,0,
		g_szDefaultValue,     strDefInprocHandler32,     g_szTypeString,
		0,
		TEXT("CLSID\\%s\\InprocHandler"),strClsId,0,0,
		g_szDefaultValue,     strDefInprocHandler16,     g_szTypeString,
		0,
		0,
	};

	bool fAbortedDeletion = false;
	if((iesRet = ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, &fAbortedDeletion, iType)) != iesSuccess)
		return iesRet;

	// if we removed both the default value as well as the multi_sz, delete the entire class key
	if(fRemove && !fAbortedDeletion && IsDarwinDescriptorSupported(iddOLE))
	{
		const ICHAR* rgSubKeys[] = { TEXT("CLSID\\%s"), strClsId,
									 TEXT("APPID\\%s"), strAppId,
									 0,
		}; // clean up the clsid and appid keys
		if((iesRet = RemoveRegKeys(rgSubKeys, hOLEKey, iType)) != iesSuccess)
			return iesRet;
	}

	const unsigned int iMaskDelimiter = ';';
	if(!riParams.IsNull(FileTypeMask))
	{
		// prepare a loop for the FileTypeMask
		MsiString strCombinedMask = riParams.GetMsiString(FileTypeMask);
		MsiString strFileMask;
		MsiString strCount = 0;
		do{
			strFileMask = strCombinedMask.Extract(iseUpto, iMaskDelimiter);
			const ICHAR* rgszRegData1[] = {
				TEXT("FileType\\%s\\%s"), strClsId, strCount,0,
				g_szDefaultValue,     strFileMask,      g_szTypeString,
				0,
				0,
			};
		if((iesRet = ProcessRegInfo(rgszRegData1, hOLEKey, fRemove, 0, 0, iType)) != iesSuccess)
			return iesRet;

			strCount = (int)strCount + 1;           
		}while(strCombinedMask.Remove(iseIncluding, iMaskDelimiter));
	}
	return iesSuccess;
}


/*---------------------------------------------------------------------------
ixfRegProgIdInfoRegister: Register OLE registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegProgIdInfoRegister64(IMsiRecord& riParams)
{
	return ProcessProgIdInfo(riParams, m_fReverseADVTScript, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegProgIdInfoRegister(IMsiRecord& riParams)
{
	return ProcessProgIdInfo(riParams, m_fReverseADVTScript, ibt32bit);
}

/*---------------------------------------------------------------------------
ixfRegProgIdInfoRegister: Register OLE registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegProgIdInfoUnregister64(IMsiRecord& riParams)
{
	return ProcessProgIdInfo(riParams, fTrue, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegProgIdInfoUnregister(IMsiRecord& riParams)
{
	return ProcessProgIdInfo(riParams, fTrue, ibt32bit);
}

iesEnum CMsiOpExecute::ProcessProgIdInfo(IMsiRecord& riParams, Bool fRemove, const ibtBinaryType iType)
{
	using namespace IxoRegProgIdInfoRegister;
	// Record description
	// 1 = ProgId
	// 2 = CLSID
	// 3 = Extension
	// 4 = Description
	// 5 = Icon
	// 6 = IconIndex
	// 7 = VIProgId
	// 8 = VIProgIdDescription
	// 9 = Insertable

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_APPINFO)) // do we write/delete the registry
		return iesSuccess;

	iesEnum iesR = EnsureClassesRootKeyRW(); // open HKCR for read/ write
	if(iesR != iesSuccess && iesR != iesNoAction)
		return iesR;

	// the registry structure
	MsiString strProgId = riParams.GetMsiString(ProgId);
	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strProgId));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	MsiString strClsId   = riParams.GetMsiString(ClsId);//!! assume they come enclosed in the curly brackets

	MsiString strDesc    = riParams.GetMsiString(Description);
	MsiString strIconName;
	bool fExpandIconName = false;
	if(!riParams.IsNull(Icon)) //!! check for full path
	{
		MsiString strIconPath = m_pCachePath->GetPath();
		strIconName = strIconPath + MsiString(riParams.GetMsiString(Icon));
		strIconName = GetUserProfileEnvPath(*strIconName, fExpandIconName);
		strIconName += TEXT(",");
		if(riParams.IsNull(IconIndex))
			strIconName += MsiString((int)0);
		else
			strIconName += MsiString(riParams.GetInteger(IconIndex));
	}

	MsiString strVIProgId= riParams.GetMsiString(VIProgId);
	MsiString strVIProgIdDescription= riParams.GetMsiString(VIProgIdDescription);

	ICHAR* pszInsert=TEXT("");    // ugly, but this will prevent the key from being generated
	ICHAR* pszNotInsert=TEXT(""); // ugly, but this will prevent the key from being generated

	if(!riParams.IsNull(Insertable))
	{
		if(!riParams.GetInteger(Insertable))
			pszNotInsert = 0;
		else
			pszInsert = 0;
	}

	const HKEY hOLEKey = (iType == ibt64bit ? m_hOLEKey64 : m_hOLEKey);
	MsiString strProgIdSubKey = strProgId;
	strProgIdSubKey += szRegSep;
	strProgIdSubKey += TEXT("Shell");

	// we add/ remove the information only if the extension and clsid keys have been corr. added/ removed
	// this implies that the class and extension information should be processed before
	// the info under consideration

	MsiString strClsIdSubKey;
	if (strClsId.TextSize())
	{
		strClsIdSubKey = TEXT("CLSID");
		strClsIdSubKey += szRegSep;
		strClsIdSubKey += strClsId;
		strClsIdSubKey += szRegSep;
		strClsIdSubKey += TEXT("ProgID");
	}

	const ICHAR* rgszRegKeys1[] = {
			strProgIdSubKey,
			0,
		};

	const ICHAR* rgszRegKeys2[] = {
			strClsIdSubKey,
			0,
		};

	Bool fExistsClassInfo = fFalse;
	Bool fExistsExtensionInfo = fFalse;

	PMsiRecord pError = LinkedRegInfoExists(rgszRegKeys1, fExistsExtensionInfo, iType);
	if(pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}

	pError = LinkedRegInfoExists(rgszRegKeys2, fExistsClassInfo, iType);
	if(pError)
	{
		Message(imtError, *pError);
		return iesFailure;
	}


	iesEnum iesRet = iesSuccess;
	if(fRemove && !fExistsClassInfo && !fExistsExtensionInfo)
	{
		// clear out the entire progid and viprogid keys in case we have any install time remnants underneath the key
		// we can do this when we know that both class and extension info has been removed
		const ICHAR* rgSubKeys[] = { TEXT("%s"), strProgId,
									 TEXT("%s"), strVIProgId,
									 0,
		}; // clean up the progid and viprogid subkeys

		if((iesRet = RemoveRegKeys(rgSubKeys, hOLEKey, iType)) != iesSuccess)
			return iesRet;
	}
	else
	{
		if(fExistsClassInfo^fRemove)
		{
			// pair the progid info with the class info
			const ICHAR* rgszRegData[] = {
				TEXT("%s\\CLSID"), strProgId,0,0,
				g_szDefaultValue,     strClsId,               g_szTypeString,
				0,
				TEXT("%s"), strVIProgId,0,0,
				g_szDefaultValue,     strVIProgIdDescription, g_szTypeString,
				0,
				TEXT("%s\\CLSID"), strVIProgId,0,0,
				g_szDefaultValue,     strClsId,               g_szTypeString,
				0,
				TEXT("%s\\CurVer"), strVIProgId,0,0,
				g_szDefaultValue,     strProgId,              g_szTypeString,
				0,
				TEXT("%s\\Insertable"), strProgId,0,0,
				g_szDefaultValue,     pszInsert,              g_szTypeString,// note that when pszInsert = 0 it creates the key, otherwise if *pszInsert = 0 it skips it
				0,
				TEXT("%s\\NotInsertable"), strProgId,0,0,
				g_szDefaultValue,     pszNotInsert,           g_szTypeString,// note that when pszNotInsert = 0 it creates the key, otherwise if *pszNotInsert = 0 it skips it
				0,
				0,
			};

			if((iesRet = ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, 0, iType)) != iesSuccess)
				return iesRet;
		}
		if((fExistsClassInfo | fExistsExtensionInfo)^fRemove)
		{
			// pair the progid info with both class and extension info
			const ICHAR* rgszRegData[] = {
				TEXT("%s"), strProgId,0,0,
				g_szDefaultValue,     strDesc,                g_szTypeString,
				0,
				TEXT("%s\\DefaultIcon"), strProgId,0,0,
				g_szDefaultValue,     strIconName,            (fExpandIconName) ? g_szTypeExpandString : g_szTypeString,
				0,
				0,
			};

			if((iesRet = ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, 0, iType)) != iesSuccess)
				return iesRet;
		}
	}
	return iesRet;
}

/*---------------------------------------------------------------------------
ixfMIMEInfoRegister: register MIME registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegMIMEInfoRegister64(IMsiRecord& riParams)
{
	return ProcessMIMEInfo(riParams, m_fReverseADVTScript, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegMIMEInfoRegister(IMsiRecord& riParams)
{
	return ProcessMIMEInfo(riParams, m_fReverseADVTScript, ibt32bit);
}

/*---------------------------------------------------------------------------
ixfMIMEInfoUnregister: unregister MIME registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegMIMEInfoUnregister64(IMsiRecord& riParams)
{
	return ProcessMIMEInfo(riParams, fTrue, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegMIMEInfoUnregister(IMsiRecord& riParams)
{
	return ProcessMIMEInfo(riParams, fTrue, ibt32bit);
}

/*---------------------------------------------------------------------------
ProcessMIMEInfo: common routine to process MIME registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessMIMEInfo(IMsiRecord& riParams, Bool fRemove, const ibtBinaryType iType)
{
	using namespace IxoRegMIMEInfoRegister;
	// Record description
	// 1 = ContentType
	// 2 = Extension
	// 3 = CLSID

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_APPINFO)) // do we write/delete the registry
		return iesSuccess;

	iesEnum iesR = EnsureClassesRootKeyRW(); // open HKCR for read/ write
	if(iesR != iesSuccess && iesR != iesNoAction)
		return iesR;

	MsiString strContentType = riParams.GetMsiString(ContentType);
	MsiString strExtension = MsiString(MsiChar('.')) + MsiString(riParams.GetMsiString(Extension));
	MsiString strClassId = riParams.GetMsiString(ClsId);
	
	IMsiRecord& riActionData = GetSharedRecord(2); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strContentType));
	AssertNonZero(riActionData.SetMsiString(2, *strExtension));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	const HKEY hOLEKey = (iType == ibt64bit ? m_hOLEKey64 : m_hOLEKey);

	// we add/ remove the information only if the extension and clsid keys have been removed
	// this implies that the class and extension information should be processed before
	// the info under consideration
	{
		MsiString strClsIdSubKey;
		if (strClassId.TextSize())
		{
			strClsIdSubKey = TEXT("CLSID");
			strClsIdSubKey += szRegSep;
			strClsIdSubKey += strClassId;
		}
		const ICHAR* rgszRegKeys[] = {
			strExtension,
			strClsIdSubKey,
			0,
		};
		Bool fExists = fFalse;
		PMsiRecord pError = LinkedRegInfoExists(rgszRegKeys, fExists, iType);
		if(pError)
		{
			Message(imtError, *pError);
			return iesFailure;
		}
		if(!(fExists^fRemove))
			// pair the progid info with the class/ extension info
			return iesSuccess;
	}

	if(fRemove)
	{
		iesEnum iesRet = iesSuccess;
		// clear out the entire Contenttype key in case we have any install time remnants underneath the key
		// we can do this when we know that both class and extension info has been removed

		const ICHAR* rgSubKeys[] = { TEXT("MIME\\Database\\Content Type\\%s"), strContentType,
									 0,
		}; // clean up the content type

		return RemoveRegKeys(rgSubKeys, hOLEKey, iType);
	}
	else
	{
		//?? can Extension be null
		const ICHAR* rgszRegData[] = {
			TEXT("MIME\\Database\\Content Type\\%s"), strContentType,0,0,
			g_szDefaultValue,       0,              g_szTypeString,// force the key creation
			g_szExtension,          strExtension,   g_szTypeString,
			g_szClassID,            strClassId,     g_szTypeString,
			0,
			0,
		};
		return ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, 0, iType);
	}
}

/*---------------------------------------------------------------------------
ixfExtensionInfoRegister: register Extension registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegExtensionInfoRegister64(IMsiRecord& riParams)
{
	return ProcessExtensionInfo(riParams, m_fReverseADVTScript, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegExtensionInfoRegister(IMsiRecord& riParams)
{
	return ProcessExtensionInfo(riParams, m_fReverseADVTScript, ibt32bit);
}

/*---------------------------------------------------------------------------
ixfExtensionInfoUnregister: unregister Extension registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegExtensionInfoUnregister64(IMsiRecord& riParams)
{
	return ProcessExtensionInfo(riParams, fTrue, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegExtensionInfoUnregister(IMsiRecord& riParams)
{
	return ProcessExtensionInfo(riParams, fTrue, ibt32bit);
}

/*---------------------------------------------------------------------------
ProcessExtensionInfo: common routine to process extension info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessExtensionInfo(IMsiRecord& riParams, Bool fRemove,
														  const ibtBinaryType iType)
{
	using namespace IxoRegExtensionInfoRegister;
	// Record description
	// 1 = Feature
	// 2 = Component
	// 3 = FileName
	// 4 = Extension
	// 5 = ProgId
	// 6 = ShellNew
	// 7 = ShellNewValue
	// 8 = ContentType
	// 9 = Order
	//10 = Verb1
	//11 = Command1
	//12 = Arguments1
	//13 = Verb2
	//14 = Command2
	//15 = Arguments2
	// ...
	// ...

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_EXTENSIONINFO)) // do we write/delete the registry
		return iesSuccess;

	iesEnum iesR = EnsureClassesRootKeyRW(); // open HKCR for read/ write
	if(iesR != iesSuccess && iesR != iesNoAction)
		return iesR;

	MsiString strExtension = MsiString(MsiChar('.')) + MsiString(riParams.GetMsiString(Extension));

	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strExtension));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	m_fShellRefresh = fTrue; // signal shell refresh at the end of the install

	MsiString strProgId = riParams.GetMsiString(ProgId);
	MsiString strShellNewValueName = riParams.GetMsiString(ShellNew);
	const HKEY hOLEKey = (iType == ibt64bit ? m_hOLEKey64 : m_hOLEKey);
	const ICHAR* szShellNewValue = riParams.IsNull(ShellNewValue) ? 0 : riParams.GetString(ShellNewValue);
	MsiString strVerb;
	MsiString strCommand;
	MsiString strArgs;
	MsiString strServerDarwinDescriptor;

	if(IsDarwinDescriptorSupported(iddShell))
	{
		strServerDarwinDescriptor = ComposeDescriptor(*MsiString(riParams.GetMsiString(Feature)),
															*MsiString(riParams.GetMsiString(Component)));
	}

	MsiString strServerFile = riParams.GetMsiString(FileName);

	if(!strServerDarwinDescriptor.TextSize() && !strServerFile.TextSize())
		return iesSuccess; // would happen during advertisement on a non-dd supported system

	if(strServerFile.TextSize())
	{
		MsiString strQuotes = *TEXT("\"");
		strServerFile = MsiString(strQuotes + strServerFile) + strQuotes;
	}

	MsiString strServerDarwinDescriptorArgs;
	MsiString strServerFileArgs;

	iesEnum iesRet = iesNoAction;
	const ICHAR** rgszRegData;

	int cPos = Args + 1;

	#define NUM_VERB_FIELDS 3
	// the verb information is in triplets of verb+command+argument
	// however the argument or the command+argument fields could be null
	// hence to figure out how many verbs we have we use -
	// (riParams.GetFieldCount() - Args + NUM_VERB_FIELDS - 1)/NUM_VERB_FIELDS
	int iNotOrder = (riParams.GetFieldCount() - Args + NUM_VERB_FIELDS - 1)/NUM_VERB_FIELDS - (riParams.IsNull(Order) ? 0 : riParams.GetInteger(Order));
	MsiString strOrder; // ordering
	while(!(riParams.IsNull(cPos)))
	{
		// need to read the value afresh each time
		strServerDarwinDescriptorArgs = strServerDarwinDescriptor;
		strServerFileArgs = strServerFile;
		strVerb = riParams.GetMsiString(cPos++);
		strCommand = riParams.GetMsiString(cPos++);
		strArgs = riParams.GetMsiString(cPos++);

		if(strArgs.TextSize())
		{
			if(strServerDarwinDescriptorArgs.TextSize())
			{
				strServerDarwinDescriptorArgs += TEXT(" ");
				strServerDarwinDescriptorArgs += strArgs;
			}
			if(strServerFileArgs.TextSize())
			{
				strServerFileArgs += TEXT(" ");
				strServerFileArgs += strArgs;
			}
		}

		MsiString strDefault;
		//!! we never remove registration for "filename only" registrations
		//!! the "filename only" registrations allow sharing of com registration
		//!! such that each app has its own private copy of the server
		//!! fusion specs recommend that the registration itself be refcounted
		//!! so that we know when to remove it. this has been punted for 1.1
		if(fRemove)
		{
			PMsiRegKey pRootKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)hOLEKey, iType);       //--merced: changed (int) to (INT_PTR)
			ICHAR szRegData[255];
			if(strProgId.TextSize())
				wsprintf(szRegData, TEXT("%s\\shell\\%s\\command"), (const ICHAR*)strProgId, (const ICHAR*)strVerb);
			else
				wsprintf(szRegData, TEXT("%s\\shell\\%s\\command"), (const ICHAR*)strExtension, (const ICHAR*)strVerb);

			PMsiRegKey pClassKey = &pRootKey->CreateChild(szRegData);
			pClassKey->GetValue(g_szDefaultValue, *&strDefault);
			if(strDefault.TextSize())
			{
				// remove args and quotes
				if(*(const ICHAR*)strDefault == '\"')
				{
					// quoted server file name
					strDefault.Remove(iseFirst, 1);
					strDefault = strDefault.Extract(iseUpto, '\"');
				}
				else
				{
					strDefault.Remove(iseFrom, ' ');
				}
				if(ENG::PathType(strDefault) != iptFull)
					strServerFileArgs = g_MsiStringNull;
			}
		}

		if(!strServerDarwinDescriptorArgs.TextSize() && !strServerFileArgs.TextSize())
			continue; // would happen during advertisement on a non-dd supported system

		const ICHAR* rgszRegData1WithProgId[] = {
				TEXT("%s\\shell\\%s\\command"), strProgId, strVerb,0,
				g_szDefaultValue,      strServerFileArgs,             g_szTypeString,
				TEXT("command"),       strServerDarwinDescriptorArgs, g_szTypeMultiSzStringDD,
				0,
				TEXT("%s\\shell\\%s"), strProgId, strVerb,0,
				g_szDefaultValue,      strCommand,                    g_szTypeString,
				0,
				0,
		};

		const ICHAR* rgszRegData1WOProgId[] = {
				TEXT("%s\\shell\\%s\\command"), strExtension, strVerb,0,
				g_szDefaultValue,      strServerFileArgs,             g_szTypeString,
				TEXT("command"),       strServerDarwinDescriptorArgs, g_szTypeMultiSzStringDD,
				0,
				TEXT("%s\\shell\\%s"), strExtension, strVerb,0,
				g_szDefaultValue,      strCommand,                    g_szTypeString,
				0,
				0,
		};
		if(strProgId.TextSize())
			rgszRegData = rgszRegData1WithProgId;
		else
			rgszRegData = rgszRegData1WOProgId;

		if((iesRet = ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, 0, iType)) != iesSuccess)
			return iesRet;      

		if(iNotOrder)
			iNotOrder--;
		else
		{
			if(strOrder.TextSize())
				strOrder += TEXT(",");
			strOrder += strVerb;
		}

	}
	if(strOrder.TextSize())
	{
		const ICHAR* rgszRegData2WithProgId[] = {
				TEXT("%s\\shell"), strProgId,0,0,
				g_szDefaultValue,        strOrder,        g_szTypeString,
				0,
				0,
		};

		const ICHAR* rgszRegData2WOProgId[] = {
				TEXT("%s\\shell"), strExtension,0,0,
				g_szDefaultValue,        strOrder,        g_szTypeString,
				0,
				0,
		};
		if(strProgId.TextSize())
			rgszRegData = rgszRegData2WithProgId;
		else
			rgszRegData = rgszRegData2WOProgId;

		if((iesRet = ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, 0, iType)) != iesSuccess)
			return iesRet;
	}

	// we include the darwin descriptor we may have written in the verb loop above in order to
	// conditionalize the removal of the below information only if when the last darwin
	// descriptor is removed.
	// if there are no verbs then we cannot share (as there are no Darwin Descriptors to manage
	// the sharing), and hence we remove the info.

	MsiString strContentType = riParams.GetMsiString(ContentType);

	const ICHAR* rgszRegDataWithProgId[] = {
			TEXT("%s\\shell\\%s\\command"), strProgId, strVerb,0,
			TEXT("command"),       strServerDarwinDescriptorArgs, g_szTypeMultiSzStringDD,
			0,
			TEXT("%s\\%s\\ShellNew"), strExtension, strProgId,0,
			strShellNewValueName,     szShellNewValue,              g_szTypeString,
			0,
			TEXT("%s"), strExtension, 0,0,
			g_szContentType,          strContentType, g_szTypeString,
			0,
			0,
		};

	const ICHAR* rgszRegDataWOProgId[] = {
			TEXT("%s\\shell\\%s\\command"), strExtension, strVerb,0,
			TEXT("command"),          strServerDarwinDescriptorArgs, g_szTypeMultiSzStringDD,
			0,
			TEXT("%s\\ShellNew"),     strExtension, 0,0,
			strShellNewValueName,     szShellNewValue,              g_szTypeString,
			0,
			TEXT("%s"), strExtension, 0,0,
			g_szContentType,          strContentType, g_szTypeString,
			0,
			0,
		};



	if(strProgId.TextSize())
		rgszRegData = rgszRegDataWithProgId;
	else
		rgszRegData = rgszRegDataWOProgId;

	if((iesRet = ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, 0, iType)) != iesSuccess)
		return iesRet;

	if(strProgId.TextSize())
	{
		if(fRemove)
		{
			// if Shell still exists, we should not be deleting
			// the extension

			MsiString strShell = strProgId;
			strShell += szRegSep;
			strShell += TEXT("Shell");

			const ICHAR* rgszRegKeys[] = {
				strShell,
				0,
			};

			Bool fExists = fFalse;
			PMsiRecord pError = LinkedRegInfoExists(rgszRegKeys, fExists, iType);
			if(pError)
			{
				Message(imtError, *pError);
				return iesFailure;
			}
			if(fExists)
				return iesSuccess;

			const ICHAR* rgSubKeys[] = { TEXT("%s"), strExtension,
										 0,
			}; // clean up the extension key

			if((iesRet = RemoveRegKeys(rgSubKeys, hOLEKey, iType)) != iesSuccess)
				return iesRet;
		}
		else
		{
			// write/ remove the progid
			const ICHAR* rgszRegData[] = {
			TEXT("%s"), strExtension, 0, 0,
				g_szDefaultValue,         strProgId,                     g_szTypeString,
				0,
				0,
			};
			if((iesRet = ProcessRegInfo(rgszRegData, hOLEKey, fRemove, 0, 0, iType)) != iesSuccess)
				return iesRet;
		}
	}

	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixfTypeLibraryRegister: type library info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfTypeLibraryRegister(IMsiRecord& riParams)
{
	using namespace IxoTypeLibraryRegister;
	PMsiRecord pError(0);

	// determine if the target file was previously copied to a temporary location
	MsiString strTemp = riParams.GetMsiString(FilePath);

	MsiString strTempLocation;
	icfsEnum icfsFileState = (icfsEnum)0;
	Bool fRes = GetFileState(*strTemp, &icfsFileState, &strTempLocation, 0, 0);

	if((icfsFileState & icfsFileNotInstalled) != 0)
	{
		// didn't actually install this file, so we assume it has already been registered
		return iesNoAction;
	}

	return ProcessTypeLibraryInfo(riParams, m_fReverseADVTScript);
}

/*---------------------------------------------------------------------------
ixfTypeLibraryUnregister: unregisters a type library with the system
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfTypeLibraryUnregister(IMsiRecord& riParams)
{
	return ProcessTypeLibraryInfo(riParams, fTrue);
}

CMsiCustomActionManager *GetCustomActionManager(const ibtBinaryType iType, bool fRemoteIfImpersonating, bool& fSuccess);

/*---------------------------------------------------------------------------
ProcessTypeLibraryInfo: common routine to process type library info
---------------------------------------------------------------------------*/
#pragma warning(disable : 4706) // assignment within comparison
iesEnum CMsiOpExecute::ProcessTypeLibraryInfo(IMsiRecord& riParams, Bool fRemove)
{
	using namespace IxoTypeLibraryRegister;
	// Record description
	// 1 = LibID
	// 2 = Version
	// 3 = Description
	// 4 = Language
	// 5 = Darwin Descriptor
	// 6 = Help Path
	// 7 = Full File Path
	// 8 = Binary Type

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_APPINFO)) // do we write/delete the registry
		return iesSuccess;

	iesEnum iesR = EnsureClassesRootKeyRW(); // open HKCR for read/ write
	if(iesR != iesSuccess && iesR != iesNoAction)
		return iesR;
	
	iesEnum iesRet = iesSuccess;
	MsiString strLibID = riParams.GetMsiString(LibID);

	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strLibID));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	unsigned uiVersion = riParams.GetInteger(Version);
	unsigned short usMajorVersion = (unsigned short)((uiVersion & 0xFFFF00) >> 8);
	unsigned short usMinorVersion = (unsigned short)(uiVersion & 0xFF);
	ICHAR rgchTemp[20];
	wsprintf(rgchTemp,TEXT("%x.%x"),usMajorVersion,usMinorVersion);
	MsiString strVersion = rgchTemp;
	LCID lcidLocale = MAKELCID(MsiString(riParams.GetMsiString(Language)), SORT_DEFAULT);
	wsprintf(rgchTemp, TEXT("%x"), lcidLocale);
	MsiString strLocale = rgchTemp;
	MsiString strHelpPath = riParams.GetMsiString(HelpPath);
	MsiString strServerFile = riParams.GetMsiString(FilePath);
	ibtBinaryType iType;
	if ( riParams.GetInteger(BinaryType) == iMsiNullInteger )
		iType = ibt32bit;
	else
		iType = (ibtBinaryType)riParams.GetInteger(BinaryType);
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, false /*fRemoteIfImpersonating*/, fSuccess);
	if ( !fSuccess )
		return iesFailure;

	if(fRemove == fFalse && strServerFile.TextSize())
	{
		// check if the type lib is currently registered
		IID iidLib;
	
		if( OLE32::IIDFromString(const_cast<WCHAR*>((const WCHAR*)CConvertString(strLibID)), &iidLib) == S_OK )
		{
			OLECHAR rgchTypeLibPath[MAX_PATH] = {0};
			HRESULT hRes = S_OK;
			if ( pManager )
				hRes = pManager->QueryPathOfRegTypeLib(iidLib,usMajorVersion,usMinorVersion,lcidLocale,rgchTypeLibPath,MAX_PATH-1);
			else
			{
				BSTR bstrTypeLibPath = OLEAUT32::SysAllocStringLen(NULL, MAX_PATH);
				hRes = OLEAUT32::QueryPathOfRegTypeLib(iidLib,usMajorVersion,usMinorVersion,lcidLocale,&bstrTypeLibPath);
				if ( hRes == S_OK )
					lstrcpyW(rgchTypeLibPath, bstrTypeLibPath);
				OLEAUT32::SysFreeString(bstrTypeLibPath);
			}
			DEBUGMSG3(TEXT("QueryPathOfRegTypeLib returned %d in %s context.  Path is '%s'"), (const ICHAR*)(INT_PTR)hRes,
						 pManager ? TEXT("remote") : TEXT("local"), CConvertString(rgchTypeLibPath));
			if ( hRes == S_OK)
			{
				PMsiRecord pUnregTypeLibParams = &m_riServices.CreateRecord(Args);
				AssertNonZero(pUnregTypeLibParams->SetString(FilePath,CConvertString(rgchTypeLibPath)));
				AssertNonZero(pUnregTypeLibParams->SetInteger(Version,uiVersion));
				AssertNonZero(pUnregTypeLibParams->SetMsiString(LibID,*strLibID));
				AssertNonZero(pUnregTypeLibParams->SetMsiString(Language, *MsiString(riParams.GetMsiString(Language))));
				AssertNonZero(pUnregTypeLibParams->SetInteger(BinaryType,iType));

				// get help path
				PMsiRegKey pHKCR = &m_riServices.GetRootKey(rrkClassesRoot, iType);
				MsiString strTypeLibVersionSubKey = TEXT("TypeLib");
				strTypeLibVersionSubKey += szRegSep;
				strTypeLibVersionSubKey += strLibID;
				strTypeLibVersionSubKey += szRegSep;
				strTypeLibVersionSubKey += strVersion;
				MsiString strValue;
				PMsiRegKey pTypeLibVersionKey = &pHKCR->CreateChild(strTypeLibVersionSubKey);
				PMsiRecord pError(0);
				PMsiRegKey pTypeLibHelpKey = &pTypeLibVersionKey->CreateChild(TEXT("HELPDIR"));
				if((pError = pTypeLibHelpKey->GetValue(0,*&strValue)) == 0)
					AssertNonZero(pUnregTypeLibParams->SetString(HelpPath,strValue));
				if((iesRet = ProcessTypeLibraryInfo(*pUnregTypeLibParams,fTrue)) != iesSuccess)
					return iesRet; // rollback will be generated in the call
			}
		}
	}

	for(;;)// retry loop
	{
		if(fRemove)
		{
			// clean up old darwin descriptors
			const ICHAR* rgszRegData[] = {
				TEXT("TypeLib\\%s\\%s\\%s\\win32"), strLibID,strVersion,strLocale,
				TEXT("win32"), 0,       g_szTypeString, // darwin descriptor
				0,
				0,
			};

			iesRet = ProcessRegInfo(rgszRegData, g_fWinNT64 ? m_hOLEKey64 : m_hOLEKey, fRemove, 0, 0, iType);
			if(iesRet == iesSuccess && !strServerFile.TextSize()) // old advertise scripts that have type library registration
			{
				const ICHAR* rgszRegData[] = {
					TEXT("TypeLib\\%s\\%s"), strLibID,strVersion,0,
					g_szDefaultValue,    0,	       g_szTypeString, // description
					0,
					0,
				};
				iesRet = ProcessRegInfo(rgszRegData, g_fWinNT64 ? m_hOLEKey64 : m_hOLEKey, fRemove, 0, 0, iType);
			}
		}
		
		PMsiRecord pRecord(0);
		if(iesRet == iesSuccess && strServerFile.TextSize())
		{
			pRecord = fRemove ? m_riServices.UnregisterTypeLibrary(strLibID, lcidLocale, strServerFile, iType)
									: m_riServices.RegisterTypeLibrary(strLibID, lcidLocale, strServerFile, strHelpPath, iType);
			if(!pRecord)
			{
				IMsiRecord& riParams1 = GetSharedRecord(Args);
				AssertNonZero(riParams1.SetMsiString(LibID,*MsiString(riParams.GetMsiString(LibID))));
				AssertNonZero(riParams1.SetInteger(Version,riParams.GetInteger(Version)));
				AssertNonZero(riParams1.SetMsiString(Language,*MsiString(riParams.GetMsiString(Language))));
				AssertNonZero(riParams1.SetMsiString(HelpPath,*MsiString(riParams.GetMsiString(HelpPath))));
				AssertNonZero(riParams1.SetInteger(BinaryType,iType));

				// generate undo op to re-register or unregister this type lib
				AssertNonZero(riParams1.SetMsiString(FilePath,*MsiString(riParams.GetMsiString(FilePath))));
				if(fRemove)
				{
					if (!RollbackRecord(ixoTypeLibraryRegister,riParams1))
						return iesFailure;
				}
				else
				{
					if (!RollbackRecord(ixoTypeLibraryUnregister,riParams1))
						return iesFailure;
				}
			}
		}
		if(iesRet != iesSuccess || pRecord)
		{
			// if we failed unregistering a type lib that wasn't registered, only give info message
			if(fRemove)
			{
				DispatchError(imtInfo,Imsg(imsgOpUnregisterTypeLibrary),
								  *strServerFile);
			}
			else
			{
				switch (DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault1),
					Imsg(imsgOpRegisterTypeLibrary),
					*strServerFile))
				{
				case imsRetry:  continue;
				case imsIgnore: break;
				default:        return iesFailure;  // imsAbort or imsNone
				};
			}
		}
		break; // out of the for loop
	}
	return iesSuccess;
}
#pragma warning(default : 4706)

iesEnum CMsiOpExecute::ProcessRegInfo(const ICHAR** pszData, HKEY hkey, Bool fRemove, IMsiStream* pSecurityDescriptor, bool* pfAbortedRemoval, ibtBinaryType iType)
// NOTE: We do not restore the m_state regkey set by IxoRegOpenKey. It may be changed by this function.
{
	if(pfAbortedRemoval)
		*pfAbortedRemoval = false; // set to true if we encounter a DD list that is not empty OR the default value is not empty
	const ICHAR** pszDataIn = pszData;
	iesEnum iesRet = iesSuccess;
	if ( iType == ibtUndefined )
		iType = ibt32bit;
	else if ( iType == ibtCommon )
		iType = g_fWinNT64 ? ibt64bit : ibt32bit;

	m_cSuppressProgress++; // suppress progress from ixfReg* functions

	ICHAR szRegData[255];
	// write directly to the registry
	const ICHAR* pszTemplate = NULL;
	
	PMsiRecord pParams0 = &m_riServices.CreateRecord(0); // pass to ixfRegCreateKey
	PMsiRecord pParams2 = &m_riServices.CreateRecord(2); // pass to ixfRegAddValue, ixfRegRemoveValue
	PMsiRecord pParams3 = &m_riServices.CreateRecord(IxoRegOpenKey::Args); // pass to ixfRegOpenKey
#ifdef _WIN64   // !merced
	AssertNonZero(pParams3->SetHandle(IxoRegOpenKey::Root,(HANDLE)hkey));
#else
	AssertNonZero(pParams3->SetInteger(IxoRegOpenKey::Root,(int)hkey));
#endif
	AssertNonZero(pParams3->SetInteger(IxoRegOpenKey::BinaryType,(int)iType));
	if (pSecurityDescriptor)
		AssertNonZero(pParams3->SetMsiData(IxoRegOpenKey::SecurityDescriptor, pSecurityDescriptor));
	Bool fContinue = fTrue;

	CRefCountedTokenPrivileges cPrivs(itkpSD_WRITE, pSecurityDescriptor != NULL);

	while(iesRet == iesSuccess && (pszTemplate = *pszData++) != 0 && fContinue)
	{
		// we assume atmost 3 arguments to the template
		// the strings structure needs to account for non-required arguments
		// by placing dumb strings there
		const ICHAR* pszArg1 = *pszData++;
		const ICHAR* pszArg2 = *pszData++;
		const ICHAR* pszArg3 = *pszData++;
		wsprintf(szRegData, pszTemplate, pszArg1, pszArg2, pszArg3);
		AssertNonZero(pParams3->SetString(IxoRegOpenKey::Key,szRegData));
		if((iesRet = ixfRegOpenKey(*pParams3)) != iesSuccess)
			break;

		const ICHAR* pszName;
		while((pszName = *pszData++) != 0)
		{
			const ICHAR* pszValue = *pszData++;
			const ICHAR* pchType = *pszData++;
			// we skip everything if any of the passed in parameters for the key is empty (not 0 mind you)
			if((!pszArg1 || *pszArg1) && (!pszArg2 || *pszArg2) && (!pszArg3 || *pszArg3))
			{
				MsiString strValue = pszValue;

				if (pszValue)
				{
					switch(*pchType)
					{
					case g_chTypeString:
						if(strValue.TextSize() && *(const ICHAR* )strValue == '#')
							strValue = MsiString(*TEXT("#")) + strValue; // escape any "#" at beginning of string
						break;
					case g_chTypeInteger:
						strValue = MsiString(*TEXT("#")) + strValue;
						break;
					case g_chTypeIncInteger:
						if (strValue.Compare(iscExact,TEXT("0")))
							continue;
						else
							strValue = MsiString(*TEXT("#+")) + strValue;
						break;
					case g_chTypeExpandString:
						strValue = MsiString(*TEXT("#%")) + strValue;
						break;
					case g_chTypeMultiSzStringDD: // fall through
					case g_chTypeMultiSzStringPrefix:
						strValue = strValue + MsiString(MsiChar(0));
						break;
					case g_chTypeMultiSzStringSuffix:
						strValue = MsiString(MsiChar(0)) + strValue;
						break;
					default:
						Assert(0);
						break;
					}
				}

				// we skip the SetValue if the value to be set is empty
				// so if we wish to write the value it must be null or non-empty


				if(!pszValue || *pszValue)
				{
					if(fRemove == fFalse)
					{
						//?? to get over the problem of creating the default value with null
						if(pszValue || *pszName)
						{
							AssertNonZero(pParams2->SetString(IxoRegAddValue::Name,pszName));
							AssertNonZero(pParams2->SetMsiString(IxoRegAddValue::Value,*strValue));
							if((iesRet = ixfRegAddValue(*pParams2)) != iesSuccess)
								break;
						}
						else
						{
							if((iesRet = ixfRegCreateKey(*pParams0)) != iesSuccess)
								break;
						}
					}
					else
					{
						AssertNonZero(pParams2->SetString(IxoRegRemoveValue::Name,pszName));
						AssertNonZero(pParams2->SetMsiString(IxoRegRemoveValue::Value,*strValue));
						if((iesRet = ixfRegRemoveValue(*pParams2)) != iesSuccess)
							break;
					}
				}
				// we must skip the processing of the rest of the values in the structure
				// if we are of type Darwin Descriptor and we are in remove mode and
				// there still exist values in the registry
				if(fRemove == fTrue && *pchType == g_chTypeMultiSzStringDD)
				{
					// read the value
					PMsiRegKey pRegKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)hkey, (int)iType);      //--merced: changed (int) to (INT_PTR)
					pRegKey = &pRegKey->CreateChild(szRegData);

					// check the pszName as well as the default value
					for(int i = 2; i--;)
					{
						PMsiRecord pError = pRegKey->GetValue(i ? pszName : 0, *&strValue);
						if(pError)
							return FatalError(*pError);
						if(strValue.TextSize()) // value exists
						{
							if(pfAbortedRemoval)
								*pfAbortedRemoval = true;
							fContinue = fFalse;
							break;
						}
					}
				}
			}
		}
	}

	m_cSuppressProgress--;
	if(iesRet == iesSuccess && hkey == m_hKey && m_hKeyRm)  // duplicate action for user assigned apps in the non-assigned (roaming) hive
		iesRet = ProcessRegInfo(pszDataIn, m_hKeyRm, fRemove, pSecurityDescriptor, 0, ibtCommon);
	return iesRet;
}


const ICHAR* rgPredefined[] = { TEXT("APPID"),
								TEXT("CLSID"),
								TEXT("INTERFACE"),
								TEXT("MIME"),
								TEXT("TYPELIB"),
								TEXT("INSTALLER"),
								0,
}; // predefined keys that cannot be removed

iesEnum CMsiOpExecute::RemoveRegKeys(const ICHAR** pszData, HKEY hkey, ibtBinaryType iType)
// NOTE: We do not restore the m_state regkey set by IxoRegOpenKey. It may be changed by this function.
{
	// delete entire keys
	// passed in pairs of form format string (eg "CLSID\\%s") and arg (eg {guid})
	// the pairs end with a null string
	// note: if the arg is an empty string, we skip the key removal
	iesEnum iesRet = iesSuccess;

	m_cSuppressProgress++; // suppress progress from ixfReg* functions

	ICHAR szRegData[255];
	// write directly to the registry
	const ICHAR* pszTemplate;

	PMsiRecord pParams = &m_riServices.CreateRecord(IxoRegOpenKey::Args);

#ifdef _WIN64   // !merced
	AssertNonZero(pParams->SetHandle(IxoRegOpenKey::Root, (HANDLE)hkey));
#else
	AssertNonZero(pParams->SetInteger(IxoRegOpenKey::Root, (int)hkey));
#endif      
	AssertNonZero(pParams->SetInteger(IxoRegOpenKey::BinaryType, (int)iType));

	while(iesRet == iesSuccess && (pszTemplate = *pszData++) != 0)
	{
		Assert(*pszTemplate);
		// we assume 1 arg to the template
		const ICHAR* pszArg1 = *pszData++;
		// we skip removal if the passed in parameter for the key is empty
		if(pszArg1 && *pszArg1)
		{
			wsprintf(szRegData, pszTemplate, pszArg1);

			// ensure that the keys are not one of the predefined keys
			const ICHAR**pszPredefined = rgPredefined;
			while(*pszPredefined)
				if(!IStrCompI(*pszPredefined++, szRegData))
					break;

			if(*pszPredefined)
				continue; // one of predefined keys, cannot remove
					
			AssertNonZero(pParams->SetString(IxoRegOpenKey::Key, szRegData));
			iesRet = ixfRegOpenKey(*pParams);
			if (iesRet == iesSuccess || iesRet == iesNoAction)
				iesRet = ixfRegRemoveKey(*pParams);//!! should pass in a new record of size IxoRegRemoveKey::Args here to be safe from future revision
		}
	}
	m_cSuppressProgress--;  
	return iesRet;
}


IMsiRecord* CMsiOpExecute::LinkedRegInfoExists(const ICHAR** rgszRegKeys, Bool& rfExists, const ibtBinaryType iType)
{
	rfExists = fFalse;

	const ICHAR* pszKey;
	const HKEY hOLEKey = (iType == ibt64bit ? m_hOLEKey64 : m_hOLEKey);
	while(!rfExists && ((pszKey = *rgszRegKeys++) != 0))
	{
		if(*pszKey) // will be empty string if entry not to be used, skip to next entry
		{
			IMsiRecord* piError;
			PMsiRegKey pKey = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)hOLEKey, iType);           //--merced: changed (int) to (INT_PTR)
			pKey = &pKey->CreateChild(pszKey);
			if((piError = pKey->Exists(rfExists)) != 0)
				return piError;
		}
	}

	return 0;
}

void GetEnvironmentStrings(const ICHAR* sz,CTempBufferRef<ICHAR>& rgch)
{
	Assert(sz);
	DWORD dwSize = WIN::ExpandEnvironmentStrings(sz,(ICHAR*)rgch,rgch.GetSize());
	if(dwSize > rgch.GetSize())
	{
		// try again with the correct size
		rgch.SetSize(dwSize);
		dwSize = WIN::ExpandEnvironmentStrings(sz,(ICHAR*)rgch, dwSize);
	}
	Assert(dwSize && dwSize <= rgch.GetSize());
}

void GetEnvironmentVariable(const ICHAR* sz,CAPITempBufferRef<ICHAR>& rgch)
{
	Assert(sz);
	DWORD dwSize = WIN::GetEnvironmentVariable(sz,(ICHAR*)rgch,rgch.GetSize());
	if(dwSize > rgch.GetSize())
	{
		// try again with the correct size
		rgch.SetSize(dwSize);
		if ( ! (ICHAR *) rgch )
		{
			rgch.SetSize(1);
			((ICHAR *)rgch)[0] = 0;
			return;
		}

		dwSize = WIN::GetEnvironmentVariable(sz,(ICHAR*)rgch, dwSize);
	}
	Assert(dwSize == 0 || dwSize <= rgch.GetSize());
}
	
IMsiRecord* CMsiOpExecute::GetSecureSecurityDescriptor(IMsiStream*& rpiStream, bool fHidden)
{
	return ::GetSecureSecurityDescriptor(m_riServices, rpiStream, fHidden);
}

IMsiRecord* GetSecureSecurityDescriptor(IMsiServices& riServices, IMsiStream*& rpiStream, bool fHidden)
{
	if (RunningAsLocalSystem())
	{
		DWORD dwError = 0;
		char* rgchSD;
		if (ERROR_SUCCESS != (dwError = ::GetSecureSecurityDescriptor(&rgchSD, fTrue, fHidden)))
			return PostError(Imsg(idbgOpSecureSecurityDescriptor), (int)dwError);

		DWORD dwLength = GetSecurityDescriptorLength(rgchSD);
		char* pbstrmSid = riServices.AllocateMemoryStream(dwLength, rpiStream);
		Assert(pbstrmSid);
		memcpy(pbstrmSid, rgchSD, dwLength);
	}
	return 0;
}

IMsiRecord* GetEveryOneReadWriteSecurityDescriptor(IMsiServices& riServices, IMsiStream*& rpiStream)
{
	if (RunningAsLocalSystem())
	{
		DWORD dwError = 0;
		char* rgchSD;
		if (ERROR_SUCCESS != (dwError = ::GetEveryOneReadWriteSecurityDescriptor(&rgchSD)))
			return PostError(Imsg(idbgOpSecureSecurityDescriptor), (int)dwError);

		DWORD dwLength = GetSecurityDescriptorLength(rgchSD);
		char* pbstrmSid = riServices.AllocateMemoryStream(dwLength, rpiStream);
		Assert(pbstrmSid);
		memcpy(pbstrmSid, rgchSD, dwLength);
	}
	return 0;
}

IMsiRecord* CMsiOpExecute::GetEveryOneReadWriteSecurityDescriptor(IMsiStream*& rpiStream)
{
	return ::GetEveryOneReadWriteSecurityDescriptor(m_riServices, rpiStream);
}


const ICHAR* rgszUninstallKeyRegData[] =
{
    TEXT("%s"), szMsiUninstallProductsKey_legacy, 0, 0,
    TEXT(""),     0,             g_szTypeString,
    0,
    0,
};

iesEnum CMsiOpExecute::CreateUninstallKey()
{
    return ProcessRegInfo(rgszUninstallKeyRegData, HKEY_LOCAL_MACHINE, fFalse,
                                 0, 0, ibtCommon);
}

#ifndef UNICODE
void ConvertMultiSzToWideChar(const IMsiString& ristrFileNames, CTempBufferRef<WCHAR>& rgch)
{
	rgch.SetSize(ristrFileNames.TextSize() + 1);
	*rgch = 0;
	int iRet = MultiByteToWideChar(CP_ACP, 0, ristrFileNames.GetString(), ristrFileNames.TextSize() + 1, rgch, rgch.GetSize());
	if ((0 == iRet) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
	{
		iRet = MultiByteToWideChar(CP_ACP, 0, ristrFileNames.GetString(), ristrFileNames.TextSize() + 1, 0, 0);
		if (iRet)
		{
			rgch.SetSize(iRet);
			*rgch = 0;
			iRet = MultiByteToWideChar(CP_ACP, 0, ristrFileNames.GetString(), ristrFileNames.TextSize() + 1, rgch, rgch.GetSize());
		}
	}
}
#endif


iesEnum CMsiOpExecute::ixfInstallProtectedFiles(IMsiRecord& riParams)
{
	AssertSz(!(!g_fWin9X && g_iMajorVersion >= 5) || g_MessageContext.m_hSfcHandle,
				g_szNoSFCMessage);

	// If no files in the cache at all, or couldn't load SFC.DLL, we're done.
	if(!m_pFileCacheCursor || !g_MessageContext.m_hSfcHandle)
		return iesSuccess;

	MsiString strMultiFilePaths;
	m_pFileCacheCursor->Reset();
	m_pFileCacheCursor->SetFilter(0); // temporarily remove filter to scan entire list
	int cProtectedFiles = 0;
	while (m_pFileCacheCursor->Next())
	{
		icfsEnum icfsFileState = (icfsEnum)m_pFileCacheCursor->GetInteger(m_colFileCacheState);
		if (icfsFileState & icfsProtectedInstalledBySFC)
		{
			MsiString strFilePath = m_pFileCacheCursor->GetString(m_colFileCacheFilePath);
			strMultiFilePaths += strFilePath;
			strMultiFilePaths += MsiString(MsiChar(0));
			DEBUGMSG1(TEXT("Protected file - requesting installation by SFP: %s"), strFilePath);

			cProtectedFiles++;
		}
	}
	m_pFileCacheCursor->SetFilter(iColumnBit(m_colFileCacheFilePath)); // Put back the permanent filter

	if (strMultiFilePaths.CharacterCount() > 0)
	{
		m_fSfpCancel = false;
		BOOL fAllowUI = riParams.GetInteger(IxoInstallProtectedFiles::AllowUI);
		MsiDisableTimeout();
#ifdef UNICODE
		BOOL fInstallSuccess = SFC::SfcInstallProtectedFiles(g_MessageContext.m_hSfcHandle, strMultiFilePaths, fAllowUI, NULL,
			NULL, SfpProgressCallback, (DWORD_PTR) this);
#else
		CTempBuffer<WCHAR, 256>  rgchFilePaths;
		ConvertMultiSzToWideChar(*strMultiFilePaths, rgchFilePaths);
		BOOL fInstallSuccess = SFC::SfcInstallProtectedFiles(g_MessageContext.m_hSfcHandle, rgchFilePaths, fAllowUI,
			NULL, NULL, SfpProgressCallback, (DWORD_PTR) this);
#endif
		MsiEnableTimeout();
		if (!fInstallSuccess)
		{
			int iLastError = GetLastError();

			// form list of files that is seperated by '\r\n' rather than '\0'
			// size of buffer is size of multi-sz list, plus 1 extra char for every file
			CTempBuffer<ICHAR, 256> rgchLogFilePaths;
			rgchLogFilePaths.Resize(strMultiFilePaths.TextSize() + cProtectedFiles + 2);

			const ICHAR* pchFrom = (const ICHAR*)strMultiFilePaths;
			ICHAR* pchTo = (ICHAR*)rgchLogFilePaths;

			int cch = 0;
			while((cch = lstrlen(pchFrom)) != 0)
			{
				Assert(pchFrom[cch] == 0);
				IStrCopy(pchTo, pchFrom);
				pchTo[cch]   = '\r';
				pchTo[cch+1] = '\n';
				pchTo += cch + 2;
				
				pchFrom += cch + 1;
			}

			pchTo[0] = 0; // null-terminate

			DispatchError(imtEnum(imtError+imtOk), Imsg(imsgSFCInstallProtectedFilesFailed), iLastError, (const ICHAR*)rgchLogFilePaths);
			return iesFailure;
		}
		else
			return m_fSfpCancel ? iesUserExit : iesSuccess;
	}
	else
	{
		return iesSuccess;
	}
}


iesEnum CMsiOpExecute::ixfUpdateEstimatedSize(IMsiRecord& riParams)
{
	if ( g_MessageContext.IsOEMInstall() )
		return iesSuccess;

	CElevate elevate; // elevate this entire function

	Bool fRemove = fFalse;
	using namespace IxoUpdateEstimatedSize; 
	MsiString strProductKey = GetProductKey();

	MsiString strProductInstalledPropertiesKey;
	HKEY hKey = 0; // will be set to global key, do not close
	PMsiRecord pRecErr(0);
	if ((pRecErr = GetProductInstalledPropertiesKey(hKey, *&strProductInstalledPropertiesKey)) != 0)
		return FatalError(*pRecErr);

	ICHAR szInstallPropertiesLocation[MAX_PATH * 2];
	IStrCopy(szInstallPropertiesLocation, strProductInstalledPropertiesKey);
	const ICHAR* rgszSizeInfoRegData[] = 
	{
		TEXT("%s"), szInstallPropertiesLocation, 0, 0,
		szEstimatedSizeValueName, riParams.GetString(EstimatedSize),      g_szTypeIncInteger,
		0,
		0,
	};

	PMsiStream pSecurityDescriptor(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	iesEnum iesRet;
	if((iesRet = ProcessRegInfo(rgszSizeInfoRegData, hKey, fRemove, pSecurityDescriptor, 0, ibtCommon)) != iesSuccess)
		return iesRet;

#ifdef UNICODE
	// update the legacy location
	wsprintf(szInstallPropertiesLocation, TEXT("%s\\%s"), szMsiUninstallProductsKey_legacy, (const ICHAR*)strProductKey);

    if (!fRemove)
    {
        iesRet = CreateUninstallKey();
        if (iesRet != iesSuccess)
            return iesRet;
    }
	iesRet = ProcessRegInfo(rgszSizeInfoRegData, HKEY_LOCAL_MACHINE, fRemove, pSecurityDescriptor, 0, ibtCommon);
#endif
	return iesRet;
}

iesEnum CMsiOpExecute::ProcessRegisterProduct(IMsiRecord& riProductInfo, Bool fRemove)
// Handles registration and unregistration of product information.
// Also unregisters LocalPackage value written by IxoDatabaseCopy
{
	CElevate elevate; // elevate this entire function

	using namespace IxoProductRegister;

	MsiString strModifyString;
	MsiString strMinorVersion;
	MsiString strMajorVersion;
	ICHAR rgchDate[20];

	bool fARPNoModify        = !riProductInfo.IsNull(NoModify);
	bool fARPNoRemove        = !riProductInfo.IsNull(NoRemove);
	bool fARPNoRepair        = !riProductInfo.IsNull(NoRepair);
	bool fARPSystemComponent = !riProductInfo.IsNull(SystemComponent);

	if (!fRemove)
	{
		MsiDate dtDate = ENG::GetCurrentDateTime();
		AssertNonZero(8 == wsprintf(rgchDate, TEXT("%4i%02i%02i"), ((unsigned)dtDate>>25) + 1980, (dtDate>>21) & 15, (dtDate>>16) & 31));

		// Extract minor and major versions

		MsiString strVersion = riProductInfo.GetMsiString(VersionString);
		Assert(strVersion.Compare(iscWithin, TEXT(".")));
		
		strMajorVersion = MsiString(strVersion.Extract(iseUpto, '.'));
		strVersion.Remove(iseIncluding, '.');
		
		strMinorVersion = MsiString(strVersion.Extract(iseUpto, '.'));

		PMsiRecord pRecErr(0);
		
		// uninstall string is run by downlevel ARPs (NT4, Win95)
		// if remove not allowed, we don't write the uninstall string at all
		// else if modify not allowed, uninstall string will uninstall package
		// otherwise it will enter maintenance mode
		if(fARPNoRemove == false)
		{
			strModifyString = MSI_SERVER_NAME;
			strModifyString += TEXT(" /");

			if(fARPNoModify)
				strModifyString += MsiChar(UNINSTALL_PACKAGE_OPTION);
			else
				strModifyString += MsiChar(INSTALL_PACKAGE_OPTION);
				
			strModifyString += MsiString(GetProductKey());
		}

	}

	MsiString strProductKey = GetProductKey();
	MsiString strProductKeySQUID = GetPackedGUID(strProductKey);

	MsiString strVersion =   MsiString(GetProductVersion());
	MsiString strLanguage  = MsiString(GetProductLanguage());

	MsiString strProductInstalledPropertiesKey;
	PMsiRecord pRecErr(0);
	HKEY hKey = 0; // will be set to global key, do not close
	if ((pRecErr = GetProductInstalledPropertiesKey(hKey, *&strProductInstalledPropertiesKey)) != 0)
		return FatalError(*pRecErr);

	ICHAR szInstallPropertiesLocation[MAX_PATH * 2];
	IStrCopy(szInstallPropertiesLocation, strProductInstalledPropertiesKey);
	const ICHAR* rgszProductInfoRegData[] = 
	{
		TEXT("%s"), szInstallPropertiesLocation, 0, 0,
		szAuthorizedCDFPrefixValueName,      fRemove ? 0 : riProductInfo.GetString(AuthorizedCDFPrefix),   g_szTypeString,
		szCommentsValueName,        fRemove ? 0 : riProductInfo.GetString(Comments),        g_szTypeString,
		szContactValueName,         fRemove ? 0 : riProductInfo.GetString(Contact),         g_szTypeString,
		// (DisplayName is set by ProcessRegisterProductCPDisplayInfo)
		szDisplayVersionValueName,  fRemove ? 0 : riProductInfo.GetString(VersionString),   g_szTypeString,
		szHelpLinkValueName,        fRemove ? 0 : riProductInfo.GetString(HelpLink),        g_szTypeExpandString,
		szHelpTelephoneValueName,   fRemove ? 0 : riProductInfo.GetString(HelpTelephone),   g_szTypeString,
		szInstallDateValueName,     fRemove ? 0 : rgchDate,                                 g_szTypeString,
		szInstallLocationValueName, fRemove ? 0 : riProductInfo.GetString(InstallLocation), g_szTypeString,
		szInstallSourceValueName,   fRemove ? 0 : g_MessageContext.IsOEMInstall() ? TEXT("") : riProductInfo.GetString(InstallSource),   g_szTypeString,
		szLocalPackageManagedValueName, fRemove ? 0 : TEXT(""),                             g_szTypeString, // only process when fRemove == fTrue
		szLocalPackageValueName,    fRemove ? 0 : TEXT(""),                                 g_szTypeString, // only process when fRemove == fTrue
		szModifyPathValueName,      fRemove ? 0 : (const ICHAR*)strModifyString,            g_szTypeExpandString,
		szNoModifyValueName,        fRemove ? 0 : fARPNoModify ? TEXT("1") : TEXT(""),      g_szTypeInteger,
		szNoRemoveValueName,        fRemove ? 0 : fARPNoRemove ? TEXT("1") : TEXT(""),      g_szTypeInteger,
		szNoRepairValueName,        fRemove ? 0 : fARPNoRepair ? TEXT("1") : TEXT(""),      g_szTypeInteger,
		// (ProductId is set by ixfUserRegister)
		szPublisherValueName,       fRemove ? 0 : riProductInfo.GetString(Publisher),       g_szTypeString,
		szReadmeValueName,          fRemove ? 0 : riProductInfo.GetString(Readme),          g_szTypeExpandString,
		// (RegCompany is set by ixfUserRegister)
		// (RegOwner is set by ixfUserRegister)
		szSizeValueName,            fRemove ? 0 : riProductInfo.GetString(Size),            g_szTypeInteger,
		szEstimatedSizeValueName,   fRemove ? 0 : g_MessageContext.IsOEMInstall() ? TEXT("") : riProductInfo.GetString(EstimatedSize),   g_szTypeIncInteger,
		szSystemComponentValueName, fRemove ? 0 : fARPSystemComponent ? TEXT("1") : TEXT(""), g_szTypeInteger,
		szUninstallStringValueName, fRemove ? 0 : (const ICHAR*)strModifyString,            g_szTypeExpandString,
		szURLInfoAboutValueName,    fRemove ? 0 : riProductInfo.GetString(URLInfoAbout),    g_szTypeString,
		szURLUpdateInfoValueName,   fRemove ? 0 : riProductInfo.GetString(URLUpdateInfo),   g_szTypeString,
		// (ProductIcon is set by PublishProduct)
		szVersionMajorValueName,    fRemove ? 0 : (const ICHAR*)strMajorVersion,            g_szTypeInteger,
		szVersionMinorValueName,    fRemove ? 0 : (const ICHAR*)strMinorVersion,            g_szTypeInteger,
		szWindowsInstallerValueName,fRemove ? 0 : TEXT("1"),                                g_szTypeInteger,
		szVersionValueName,         fRemove ? 0 : (const ICHAR*)strVersion,                 g_szTypeInteger,
		szLanguageValueName,        fRemove ? 0 : (const ICHAR*)strLanguage,                g_szTypeInteger,
		0,
		0,
	};

	iesEnum iesRet;

	PMsiStream pSecurityDescriptor(0);
	
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	iesRet = ProcessRegInfo(rgszProductInfoRegData, hKey, fRemove, pSecurityDescriptor, 0, ibtCommon);
	if (iesRet != iesSuccess)
		return iesRet;

#ifdef UNICODE
	// update the legacy location
	wsprintf(szInstallPropertiesLocation, TEXT("%s\\%s"), szMsiUninstallProductsKey_legacy, (const ICHAR*)strProductKey);
	if(!fRemove)
    {
        iesRet = CreateUninstallKey();
        if (iesRet != iesSuccess)
            return iesRet;
    }
    if (!fRemove || !FProductRegisteredForAUser(strProductKey))
		iesRet = ProcessRegInfo(rgszProductInfoRegData, HKEY_LOCAL_MACHINE, fRemove, pSecurityDescriptor, 0, ibtCommon);
	if (iesRet != iesSuccess)
		return iesRet;
#endif
	if(!riProductInfo.IsNull(UpgradeCode))
	{
		MsiString strUpgradeCodeSQUID = GetPackedGUID(MsiString(riProductInfo.GetMsiString(UpgradeCode)));
		const ICHAR* rgszUpgradeCodeRegData[] =
		{
			TEXT("%s\\%s"), szMsiUpgradeCodesKey, strUpgradeCodeSQUID, 0,
			strProductKeySQUID,  0,   g_szTypeString,
			0,
			0,
		};

		iesRet = ProcessRegInfo(rgszUpgradeCodeRegData, HKEY_LOCAL_MACHINE, fRemove, pSecurityDescriptor, 0, ibtCommon);
		if (iesRet != iesSuccess)
			return iesRet;
	}

	// create the usage key with read write access
	PMsiStream pReadWriteSecurityDescriptor(0);
	if ((pRecErr = GetEveryOneReadWriteSecurityDescriptor(*&pReadWriteSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);
	
	MsiString strFeatureUsageKey;
	if ((pRecErr = GetProductFeatureUsageKey(*&strFeatureUsageKey)) != 0)
		return FatalError(*pRecErr);
	
	const ICHAR* rgszUsageRegData[] =
	{
		strFeatureUsageKey, 0, 0, 0,
		TEXT(""),     0,             g_szTypeString,
		0,
		0,
	};

	iesRet = ProcessRegInfo(rgszUsageRegData, m_hUserDataKey, fRemove, pReadWriteSecurityDescriptor, 0, ibtCommon);
	if (iesRet != iesSuccess)
		return iesRet;


	return iesSuccess;
}

iesEnum CMsiOpExecute::ProcessRegisterUser(IMsiRecord& riUserInfo, Bool fRemove)
//----------------------------------------------                                                        
{
	CElevate elevate; // elevate this entire function
	using namespace IxoUserRegister;
	
	// register user information
	// ProcessRegInfo handles rollback
	MsiString strInstalledPropertiesKey;
	PMsiRecord pRecErr(0);
	HKEY hKey = 0; // will be set to global key, do not close
	if((pRecErr = GetProductInstalledPropertiesKey(hKey, *&strInstalledPropertiesKey)) != 0)
		return FatalError(*pRecErr);

	const ICHAR* rgszUserInfoRegData[] = 
	{
		TEXT("%s"), strInstalledPropertiesKey, 0, 0,
		szUserNameValueName, riUserInfo.GetString(Owner),      g_szTypeString,
		szOrgNameValueName,  riUserInfo.GetString(Company),    g_szTypeString,
		szPIDValueName,      riUserInfo.GetString(ProductId),  g_szTypeString,
		0,
		0,
	};

	PMsiStream pSecurityDescriptor(0);
	if ((pRecErr = GetSecureSecurityDescriptor(*&pSecurityDescriptor)) != 0)
		return FatalError(*pRecErr);

	iesEnum iesRet;
	if((iesRet = ProcessRegInfo(rgszUserInfoRegData, hKey, fRemove, pSecurityDescriptor,
										 0, ibtCommon)) != iesSuccess)
		return iesRet;

	return iesSuccess;
}

IMsiRecord* CMsiOpExecute::EnsureUserDataKey()
{
	if(m_hUserDataKey)
	{
		return 0;
	}

	ICHAR szUserSID[MAX_PATH];

#ifdef UNICODE
	m_strUserDataKey = szMsiUserDataKey;
	m_strUserDataKey += szRegSep;

	if(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN)
		m_strUserDataKey += szLocalSystemSID;
	else
	{
		CImpersonate impersonate(fTrue);
		DWORD dwError = GetCurrentUserStringSID(szUserSID);
		if (ERROR_SUCCESS != dwError)
		{
			return PostError(Imsg(idbgOpGetUserSID));
		}
		m_strUserDataKey += szUserSID;
	}
#else
	m_strUserDataKey = szMsiLocalInstallerKey;
#endif
	{
		CElevate elevate;
		REGSAM dwSam = KEY_READ| KEY_WRITE;
#ifndef _WIN64 
		if ( g_fWinNT64 )
			dwSam |= KEY_WOW64_32KEY;
#endif

		//?? do we need to explicitly ACL this key
		// Win64: this code runs in the 64-bit service
		long lResult = RegCreateKeyAPI(HKEY_LOCAL_MACHINE, m_strUserDataKey, 0, 0, 0, dwSam, 0, &m_hUserDataKey, 0);
		if(lResult != ERROR_SUCCESS)
		{
			MsiString strFullKey;
			BuildFullRegKey(HKEY_LOCAL_MACHINE, m_strUserDataKey, ibt64bit, *&strFullKey);
			return PostError(Imsg(imsgCreateKeyFailed), *strFullKey, (int)lResult);
		}
	}
	return 0;
}

IMsiRecord* CMsiOpExecute::GetProductFeatureUsageKey(const IMsiString*& rpiSubKey)
{
	MsiString strProductFeatureUsageKey;
	// get the appropriate installed properties key for the product

	IMsiRecord* piError = EnsureUserDataKey();
	if(piError)
		return piError;

	strProductFeatureUsageKey = szMsiProductsSubKey;
	strProductFeatureUsageKey += szRegSep;
	strProductFeatureUsageKey += MsiString(GetPackedGUID(MsiString(GetProductKey())));
#ifdef UNICODE
	strProductFeatureUsageKey += szRegSep;
	strProductFeatureUsageKey += szMsiFeatureUsageSubKey;
#endif
	strProductFeatureUsageKey.ReturnArg(rpiSubKey);
	return 0;
}

IMsiRecord* CMsiOpExecute::GetProductInstalledPropertiesKey(HKEY& rRoot, const IMsiString*& rpiSubKey)
{
	MsiString strProductInstalledPropertiesKey;
	// get the appropriate installed properties key for the product
#ifdef UNICODE
	IMsiRecord* piError = EnsureUserDataKey();
	if(piError)
		return piError;

	rRoot = m_hUserDataKey;

	strProductInstalledPropertiesKey = szMsiProductsSubKey;
	strProductInstalledPropertiesKey += szRegSep;
	strProductInstalledPropertiesKey += MsiString(GetPackedGUID(MsiString(GetProductKey())));
	strProductInstalledPropertiesKey += szRegSep;
	strProductInstalledPropertiesKey += szMsiInstallPropertiesSubKey;
#else
	rRoot = HKEY_LOCAL_MACHINE;

	strProductInstalledPropertiesKey = szMsiUninstallProductsKey_legacy;
	strProductInstalledPropertiesKey += szRegSep;
	strProductInstalledPropertiesKey += MsiString(GetProductKey());
#endif
	strProductInstalledPropertiesKey.ReturnArg(rpiSubKey);
	return 0;
}

IMsiRecord* CMsiOpExecute::GetProductInstalledFeaturesKey(const IMsiString*& rpiSubKey)
{
	MsiString strProductInstalledFeaturesKey;
	// get the appropriate features key for the product

	IMsiRecord* piError = EnsureUserDataKey();
	if(piError)
		return piError;
#ifdef UNICODE
	strProductInstalledFeaturesKey = szMsiProductsSubKey;
	strProductInstalledFeaturesKey += szRegSep;
	strProductInstalledFeaturesKey += MsiString(GetPackedGUID(MsiString(GetProductKey())));
	strProductInstalledFeaturesKey += szRegSep;
	strProductInstalledFeaturesKey += szMsiFeaturesSubKey;
#else
	strProductInstalledFeaturesKey = szMsiFeaturesSubKey;
	strProductInstalledFeaturesKey += szRegSep;
	strProductInstalledFeaturesKey += MsiString(GetPackedGUID(MsiString(GetProductKey())));
#endif
	strProductInstalledFeaturesKey.ReturnArg(rpiSubKey);
	return 0;
}

IMsiRecord* CMsiOpExecute::GetProductSecureTransformsKey(const IMsiString*& rpiSubKey)
{
	MsiString strProductSecureTransformsKey;

	IMsiRecord* piError = EnsureUserDataKey();
	if(piError)
		return piError;

	strProductSecureTransformsKey = szMsiProductsSubKey;
	strProductSecureTransformsKey += szRegSep;
	strProductSecureTransformsKey += MsiString(GetPackedGUID(MsiString(GetProductKey())));
	strProductSecureTransformsKey += szRegSep;
	strProductSecureTransformsKey += szMsiTransformsSubKey;
	strProductSecureTransformsKey.ReturnArg(rpiSubKey);
	return 0;
}

IMsiRecord* CMsiOpExecute::GetProductInstalledComponentsKey(const ICHAR* szComponentId, const IMsiString*& rpiSubKey)
{
	MsiString strProductInstalledComponentsKey;
	// get the appropriate components key for the product

	IMsiRecord* piError = EnsureUserDataKey();
	if(piError)
		return piError;

	strProductInstalledComponentsKey = szMsiComponentsSubKey;
	strProductInstalledComponentsKey += szRegSep;
	ICHAR szComponentIdPacked[cchComponentId + 1];
	AssertNonZero(PackGUID(szComponentId, szComponentIdPacked));
	strProductInstalledComponentsKey += szComponentIdPacked;
	strProductInstalledComponentsKey.ReturnArg(rpiSubKey);
	return 0;
}

IMsiRecord* CMsiOpExecute::GetInstalledPatchesKey(const ICHAR* szPatchCode, const IMsiString*& rpiSubKey)
{
	MsiString strPatchesKey;
	// get the appropriate installed properties key for the product

	IMsiRecord* piError = EnsureUserDataKey();
	if(piError)
		return piError;

	strPatchesKey = szMsiPatchesSubKey;
	strPatchesKey += szRegSep;
	ICHAR szPatchCodePacked[cchPatchCodePacked + 1];
	AssertNonZero(PackGUID(szPatchCode, szPatchCodePacked));
	strPatchesKey += szPatchCodePacked;
	strPatchesKey.ReturnArg(rpiSubKey);
	return 0;
}

iesEnum CMsiOpExecute::ixfDatabaseCopy(IMsiRecord& riParams)
{
	using namespace IxoDatabaseCopy;
	
	PMsiRecord pRecErr(0);
	iesEnum iesRet;
	
	PMsiPath pDestPath(0);
	PMsiPath pSourcePath(0);
	MsiString strDestFileName;
	MsiString strSourceFileName;
	MsiString strLocalPackageKey;

	MsiString strAdminInstallPath = riParams.GetMsiString(AdminDestFolder);
	bool fCacheDatabase = !strAdminInstallPath.TextSize();

	CElevate elevate(fCacheDatabase); // elevate for this entire function when caching

	// set source path and file name
	if((pRecErr = m_riServices.CreateFilePath(riParams.GetString(DatabasePath), *&pSourcePath, *&strSourceFileName)) != 0)
		return FatalError(*pRecErr);

	iaaAppAssignment iaaAsgnType = m_fFlags & SCRIPTFLAGS_MACHINEASSIGN ? iaaMachineAssign : (m_fAssigned? iaaUserAssign : iaaUserAssignNonManaged);
	HKEY hKey = 0; // will be set to global key, do not close
	if(fCacheDatabase)
	{
		// caching package in cache folder
		
		// Delete any existing cached database for this product

		// get the appropriate cached database key/ value
		if((pRecErr = GetProductInstalledPropertiesKey(hKey, *&strLocalPackageKey)) != 0)
			return FatalError(*pRecErr);

		MsiString strCachedDatabase;
		PMsiRegKey pHKLM = &m_riServices.GetRootKey((rrkEnum)(INT_PTR)hKey, ibtCommon);		//--merced: changed (int) to (INT_PTR)
		PMsiRegKey pProductKey = &pHKLM->CreateChild(strLocalPackageKey);

		pRecErr = pProductKey->GetValue(iaaAsgnType == iaaUserAssign ? szLocalPackageManagedValueName : szLocalPackageValueName, *&strCachedDatabase);
		if ((pRecErr == 0) && (strCachedDatabase.TextSize() != 0))
		{
			IMsiRecord& riFileRemove = GetSharedRecord(IxoFileRemove::Args);
			riFileRemove.SetMsiString(IxoFileRemove::FileName, *strCachedDatabase);
			if ((iesRet = ixfFileRemove(riFileRemove)) != iesSuccess)
				return iesRet;
		}

		// Generate a unique name for database, create and secure the file.
		MsiString strMsiDir = ENG::GetMsiDirectory();

		// set dest path and file name
		if (((pRecErr = m_riServices.CreatePath(strMsiDir, *&pDestPath)) != 0) ||
			((pRecErr = pDestPath->EnsureExists(0)) != 0) ||
			((pRecErr = pDestPath->TempFileName(0, szDatabaseExtension, fTrue, *&strDestFileName, &CSecurityDescription(true, false))) != 0) ||
			((pRecErr = pDestPath->SetAllFileAttributes(0,FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM))))
		{
			return FatalError(*pRecErr);
		}
	}
	else
	{
		// copying package to admin install point
		if((pRecErr = m_riServices.CreatePath(strAdminInstallPath, *&pDestPath)) != 0)
			return FatalError(*pRecErr);

		strDestFileName = strSourceFileName;

		if((iesRet = CreateFolder(*pDestPath)) != iesSuccess)
			return iesRet;
	}

	Assert(pSourcePath);
	Assert(pDestPath);
	Assert(strSourceFileName.TextSize());
	Assert(strDestFileName.TextSize());

	// Open storages on the source and destination databases

	MsiString strMediaLabel, strMediaPrompt;
	if (m_state.pCurrentMediaRec)
	{       
		using namespace IxoChangeMedia;
		strMediaLabel  = m_state.pCurrentMediaRec->GetString(MediaVolumeLabel);
		strMediaPrompt = m_state.pCurrentMediaRec->GetString(MediaPrompt);
	}

	// current assumption is that the package is always on disk 1.
	PMsiVolume pNewVolume(0);
	if (!VerifySourceMedia(*pSourcePath, strMediaLabel, strMediaPrompt, /*uiDisk=*/1, *&pNewVolume))
		return iesUserExit;

	if (pNewVolume)
		pSourcePath->SetVolume(*pNewVolume);

	MsiString strDbTargetFullFilePath = pDestPath->GetPath();
	strDbTargetFullFilePath += strDestFileName;

	PMsiStorage pDatabase(0);
	PMsiStorage pCachedDatabase(0);

	MsiString strPackagePath;
	if ((pRecErr = pSourcePath->GetFullFilePath(strSourceFileName, *&strPackagePath)) != 0)
		return FatalError(*pRecErr);

	// if it's from a URL, it should still be cached locally.

	if (PMsiVolume(&pSourcePath->GetVolume())->IsURLServer())
	{
		// in this case, the download code simply looks up the local one, and hands it back
		// to you.  This should not fail.

		// Note that URLMON manages the cached file itself, and we don't need to clean it up.

		MsiString strCacheFileName;
		Bool fUrl = fTrue;
		HRESULT hResult = DownloadUrlFile((const ICHAR*) strPackagePath, *&strCacheFileName, fUrl, -1);

		if (ERROR_SUCCESS == hResult)
		{
			strPackagePath = strCacheFileName;
		}
		else
		{
			Assert(ERROR_SUCCESS == hResult);
			DWORD dwLastError = WIN::GetLastError();
		}
	}

	if (((pRecErr = m_riServices.CreateStorage(strPackagePath,
								ismReadOnly, *&pDatabase)) != 0) ||
		((pRecErr = m_riServices.CreateStorage(strDbTargetFullFilePath,
								ismCreateDirect, *&pCachedDatabase)) != 0))
	{
		return FatalError(*pRecErr);
	}

	// backward compatibility code, remove when raw stream names no longer supported
	IMsiStorage* piDummy;
	if (pDatabase->ValidateStorageClass(ivscDatabase1))
		pDatabase->OpenStorage(0, ismRawStreamNames, piDummy);

	// Create a record with the streams to be dropped

	MsiString strStreams = riParams.GetMsiString(IxoDatabaseCopy::CabinetStreams);
	MsiString strStreamName;
	unsigned int cStreams = 0;
	unsigned int cCurrentStream = 0;
	IMsiRecord* piRecStreams = NULL; // don't release -- it's shared!

	// first count how many streams we have to drop; then create a record
	// with the stream names

	for (int c = 1; c <= 2; c++)
	{
		while(strStreams.TextSize())
		{
			strStreamName = strStreams.Extract(iseUpto,';');
			if(strStreamName.TextSize() == strStreams.TextSize())
				strStreams = TEXT("");
			else
				strStreams.Remove(iseFirst,strStreamName.TextSize()+1);

			if (c == 1)
				cStreams++;
			else
				piRecStreams->SetMsiString(++cCurrentStream, *strStreamName);
		}
		if (c == 1)
		{
			piRecStreams = &GetSharedRecord(cStreams);
			strStreams = riParams.GetMsiString(IxoDatabaseCopy::CabinetStreams);
		}
	}

	// Cache the database

	for (;;)
	{
		MsiDisableTimeout();
		pRecErr = pDatabase->CopyTo(*pCachedDatabase, cStreams ? piRecStreams : 0);
		MsiEnableTimeout();

		if (pRecErr == 0)
			break;
		else
		{
			DispatchMessage(imtInfo, *pRecErr, fTrue);

			if (pRecErr->GetInteger(3) == STG_E_MEDIUMFULL)
				pRecErr = PostError(Imsg(imsgDiskFull), *strDbTargetFullFilePath);
			else
				pRecErr = PostError(Imsg(imsgOpPackageCache), *strPackagePath, pRecErr->GetInteger(3));
			
			switch(DispatchMessage(imtEnum(imtError+imtRetryCancel+imtDefault1), *pRecErr, fTrue))
			{
			case imsRetry:
				continue;
			default:
				Assert(0); // fall through
			case imsCancel:
				return iesFailure;
			};
		}
	}

	IMsiRecord& riUndoParams = GetSharedRecord(IxoFileRemove::Args);
	AssertNonZero(riUndoParams.SetMsiString(IxoFileRemove::FileName,
														 *strDbTargetFullFilePath));

	// need to elevate during rollback to remove cached database
	AssertNonZero(riUndoParams.SetInteger(IxoFileRemove::Elevate, fCacheDatabase));

	if (!RollbackRecord(ixoFileRemove, riUndoParams))
		return iesFailure;

	if(fCacheDatabase)
	{
		Assert(strLocalPackageKey.TextSize() && hKey);
		
		// Write LocalPackage registry value
		// ProcessRegInfo handles rollback
		const ICHAR* rgszUserInfoRegData[] =
		{
			TEXT("%s"), strLocalPackageKey, 0, 0,
			iaaAsgnType == iaaUserAssign ? szLocalPackageManagedValueName : szLocalPackageValueName, strDbTargetFullFilePath, g_szTypeString,
			0,
			0,
		};

		return ProcessRegInfo(rgszUserInfoRegData, hKey, fFalse, 0, 0, ibtCommon);
	}
	return iesSuccess;
}

iesEnum CMsiOpExecute::ixfDatabasePatch(IMsiRecord& riParams)
{
	using namespace IxoDatabasePatch;
	
	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;

	MsiString strDatabaseFullPath = riParams.GetMsiString(DatabasePath);

	PMsiPath pDatabasePath(0);
	MsiString strDatabaseName;
	if((pError = m_riServices.CreateFilePath(strDatabaseFullPath,*&pDatabasePath,*&strDatabaseName)) != 0)
		return FatalError(*pError);

	if((iesRet = BackupFile(*pDatabasePath,*strDatabaseName,fFalse,fFalse,iehShowNonIgnorableError)) != iesSuccess)
		return iesRet;

	int iOldAttribs = -1;
	if((pError = pDatabasePath->EnsureOverwrite(strDatabaseName, &iOldAttribs)) != 0)
		return FatalError(*pError);

	PMsiDatabase pDatabase(0);
	if((pError = m_riServices.CreateDatabase(strDatabaseFullPath,idoTransact,*&pDatabase)) != 0)
		return FatalError(*pError);

	int cIndex = DatabasePath + 1;
	int cFields = riParams.GetFieldCount();
	
	for(int i = DatabasePath + 1; i <= cFields; i++)
	{
		PMsiData pData = riParams.GetMsiData(i);
		if(!pData)
		{
			AssertSz(0, "couldn't get transform stream from riParams in ixoDatabasePatch");
			continue;
		}
		PMsiMemoryStream pStream((IMsiData&)*pData, IID_IMsiStream);
		Assert(pStream);

		// create transform storage
		PMsiStorage pTransformStorage(0);
		if((pError = ::CreateMsiStorage(*pStream, *& pTransformStorage)) != 0)
			return FatalError(*pError);

		PMsiSummaryInfo pTransSummary(0);
		if ((pError = pTransformStorage->CreateSummaryInfo(0, *&pTransSummary)))
		{
			pError = PostError(Imsg(idbgTransformCreateSumInfoFailed));
			return FatalError(*pError);
		}

		int iTransCharCount = 0;
		pTransSummary->GetIntegerProperty(PID_CHARCOUNT, iTransCharCount);
		
		// apply transform
		if((pError = pDatabase->SetTransform(*pTransformStorage, iTransCharCount & 0xFFFF)) != 0)
			return FatalError(*pError);
	}
		
	if((pError = pDatabase->Commit()) != 0)
		return FatalError(*pError);

	// NOTE: if a failure happened after removing the read-only attribute but before this point, rollback will
	// restore the proper attributes when restoring the file
	if((pError = pDatabasePath->SetAllFileAttributes(strDatabaseName, iOldAttribs)) != 0)
		return FatalError(*pError);

	return iesSuccess;
}

/*---------------------------------------------------------------------------
ixfCustomActionSchedule: execute custom action or schedule it for commit or rollback
ixfCustomActionCommit:   call rollback custom action during commit
ixfCustomActionRollback: call rollback custom action during rollback
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfCustomActionSchedule(IMsiRecord& riParams)
{
	if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
	{
		DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
		return iesNoAction;
	}

	if (riParams.GetInteger(IxoCustomActionSchedule::ActionType) & icaRollback)
	{
		if (!RollbackRecord(ixoCustomActionRollback, riParams))
			return iesFailure;

		return iesSuccess;
	}
	if (riParams.GetInteger(IxoCustomActionSchedule::ActionType) & icaCommit)
	{
		if (!RollbackRecord(ixoCustomActionCommit, riParams))
			return iesFailure;
		else
			return iesSuccess;
	}
	return ixfCustomActionRollback(riParams);
}

iesEnum CMsiOpExecute::ixfCustomActionCommit(IMsiRecord& riParams)
{
	if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
	{
		DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
		return iesNoAction;
	}

	return ixfCustomActionRollback(riParams);
}

iesEnum CMsiOpExecute::ixfCustomActionRollback(IMsiRecord& riParams)
{
	if (m_fUserChangedDuringInstall && (m_ixsState == ixsRollback))
	{
		DEBUGMSGV1(TEXT("Action skipped - rolling back install from a different user."), NULL);
		return iesNoAction;
	}

	int icaFlags = riParams.GetInteger(IxoCustomActionSchedule::ActionType);
	if (!m_fRunScriptElevated || !(icaFlags & icaNoImpersonate))
		AssertNonZero(StartImpersonating());
	GUID guidAppCompatDB;
	GUID guidAppCompatID;
	iesEnum iesRet = ENG::ScheduledCustomAction(riParams, *MsiString(GetProductKey()), (LANGID)GetProductLanguage(), m_riMessage, m_fRunScriptElevated, GetAppCompatCAEnabled(), GetAppCompatDB(&guidAppCompatDB), GetAppCompatID(&guidAppCompatID));
	if (!m_fRunScriptElevated || !(icaFlags & icaNoImpersonate))
		StopImpersonating();
	return iesRet;
}

//!! do we need to create a separate IMsiMessage object to call CMsiOpExecute::Message?

void CreateCustomActionManager(bool fRemapHKCU)
{
	// in the service, the manager lives in the ConfigManager because there isn't
	// necessarily an engine

	IMsiConfigurationManager *piConfigMgr = CreateConfigurationManager();
	if (piConfigMgr)
	{
		piConfigMgr->CreateCustomActionManager(fRemapHKCU);
		piConfigMgr->Release();
	}
}

CMsiCustomActionManager *GetCustomActionManager(IMsiEngine *piEngine);

CMsiCustomActionManager *GetCustomActionManager(const ibtBinaryType iType, const bool fRemoteIfImpersonated, bool& fSuccess)
{
	CMsiCustomActionManager* pManager = NULL;
	bool fRemote = false;
	fSuccess = true;
#if defined(_WIN64)
	if ( iType == ibt32bit )
		fRemote = true;
#else
	ibtBinaryType i = iType;  // for the joy of the compiler
#endif

	if (g_scServerContext == scService)
	{
		if (fRemoteIfImpersonated && IsImpersonating(false))
		fRemote = true;
	}

#if defined(DEBUG)
	if ( !fRemote && GetTestFlag('J') )
		fRemote = true;
#endif
 
	if ( fRemote )
	{
		pManager = GetCustomActionManager(NULL);
		if ( !pManager )
		{
			const ICHAR szMessage[] = TEXT("Could not get CMsiCustomActionManager*");
			AssertSz(pManager, szMessage);
			DEBUGMSG(szMessage);
			fSuccess = false;
		}
	}
	return pManager;
}

#ifdef DEBUG
void LocalDebugOutput(const ICHAR* szAPI, int iRes, CMsiCustomActionManager* pManager)
{
	DEBUGMSG3(TEXT("%s returned %d in %s context."), szAPI, (const ICHAR*)(INT_PTR)iRes,
				 pManager ? TEXT("remote") : TEXT("local"));
}
#endif

BOOL LocalSQLInstallDriverEx(int cDrvLen, LPCTSTR szDriver, LPCTSTR szPathIn, LPTSTR szPathOut,
									  WORD cbPathOutMax, WORD* pcbPathOut, WORD fRequest,
									  DWORD* pdwUsageCount, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
		iRes = pManager->SQLInstallDriverEx(cDrvLen, szDriver, szPathIn, szPathOut, cbPathOutMax,
														pcbPathOut, fRequest, pdwUsageCount);
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLInstallDriverEx(szDriver, szPathIn, szPathOut, cbPathOutMax,
															pcbPathOut, fRequest, pdwUsageCount);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

BOOL LocalSQLConfigDriver(HWND hwndParent, WORD fRequest, LPCTSTR szDriver,
								  LPCTSTR szArgs, LPTSTR szMsg, WORD cbMsgMax, 
								  WORD* pcbMsgOut, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
	{
		Assert(hwndParent == 0);
		// since it's always called hwndParent = 0, I didn't bother marshaling hwndParent.
		iRes = pManager->SQLConfigDriver(fRequest, szDriver, szArgs,
											szMsg, cbMsgMax, pcbMsgOut);
	}
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLConfigDriver(hwndParent, fRequest, szDriver, szArgs,
											szMsg, cbMsgMax, pcbMsgOut);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

BOOL LocalSQLRemoveDriver(LPCTSTR szDriver, BOOL fRemoveDSN, DWORD* pdwUsageCount,
								  ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
		iRes = pManager->SQLRemoveDriver(szDriver, fRemoveDSN, pdwUsageCount);
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLRemoveDriver(szDriver, fRemoveDSN, pdwUsageCount);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

BOOL LocalSQLInstallTranslatorEx(int cTranLen, LPCTSTR szTranslator, LPCTSTR szPathIn, LPTSTR szPathOut,
											WORD cbPathOutMax, WORD* pcbPathOut, WORD fRequest,
											DWORD* pdwUsageCount, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
		iRes = pManager->SQLInstallTranslatorEx(cTranLen, szTranslator, szPathIn, szPathOut, cbPathOutMax,
															 pcbPathOut, fRequest, pdwUsageCount);
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLInstallTranslatorEx(szTranslator, szPathIn, szPathOut, cbPathOutMax,
																 pcbPathOut, fRequest, pdwUsageCount);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

BOOL LocalSQLRemoveTranslator(LPCTSTR szTranslator, DWORD* pdwUsageCount, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
		iRes = pManager->SQLRemoveTranslator(szTranslator, pdwUsageCount);
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLRemoveTranslator(szTranslator, pdwUsageCount);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

BOOL LocalSQLConfigDataSource(HWND hwndParent, WORD fRequest, LPCTSTR szDriver,
										LPCTSTR szAttributes, DWORD cbAttrSize, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
	{
		Assert(hwndParent == 0);
		// since it's always called hwndParent = 0, I didn't bother marshaling hwndParent.
		iRes = pManager->SQLConfigDataSource(fRequest, szDriver,
														 szAttributes, cbAttrSize);
	}
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLConfigDataSource(hwndParent, fRequest, szDriver,
														 szAttributes);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

BOOL LocalSQLInstallDriverManager(LPTSTR szPath, WORD cbPathMax, WORD* pcbPathOut, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
		iRes = pManager->SQLInstallDriverManager(szPath, cbPathMax, pcbPathOut);
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLInstallDriverManager(szPath, cbPathMax, pcbPathOut);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}
	
BOOL LocalSQLRemoveDriverManager(DWORD* pdwUsageCount, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	BOOL iRes;
	if ( pManager )
		iRes = pManager->SQLRemoveDriverManager(pdwUsageCount);
	else
	{
		if ( fSuccess )
			iRes = ODBCCP32::SQLRemoveDriverManager(pdwUsageCount);
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

short LocalSQLInstallerError(WORD iError, DWORD* pfErrorCode, LPTSTR szErrorMsg, WORD cbErrorMsgMax,
									  WORD* pcbErrorMsg, ibtBinaryType iType)
{
	bool fSuccess;
	CMsiCustomActionManager* pManager = GetCustomActionManager(iType, true /*fRemoteIfImpersonating*/, fSuccess);
	short iRes;
	if ( pManager )
	{
		iRes = pManager->SQLInstallerError(iError, pfErrorCode, szErrorMsg, cbErrorMsgMax, pcbErrorMsg);
		AssertSz(iRes != -2, TEXT("remote latebound call to SQLInstallerError failed"));
	}
	else
	{
		if ( fSuccess )
		{
			iRes = ODBCCP32::SQLInstallerError(iError, pfErrorCode, szErrorMsg, cbErrorMsgMax, pcbErrorMsg);
			AssertSz(iRes != -2, TEXT("local latebound call to SQLInstallerError failed"));
		}
		else
			return ERROR_INSTALL_SERVICE_FAILURE;
	}
#ifdef DEBUG
	LocalDebugOutput(TEXT("LocalSQLInstallDriverEx"), iRes, pManager);
#endif
	return iRes;
}

/*---------------------------------------------------------------------------
ixfODBCInstallDriver:
ixfODBCRemoveDriver:
ixfODBCInstallTranslator:
ixfODBCRemoveTranslator:
ixfODBCDataSource:
ixfODBCDriverManager:
---------------------------------------------------------------------------*/

#define SQL_MAX_MESSAGE_LENGTH 512
#define SQL_NO_DATA            100
#define ODBC_INSTALL_INQUIRY     1
#define ODBC_INSTALL_COMPLETE    2
#define ODBC_ADD_DSN             1
#define ODBC_CONFIG_DSN          2
#define ODBC_REMOVE_DSN          3
#define ODBC_ADD_SYS_DSN         4
#define ODBC_CONFIG_SYS_DSN      5
#define ODBC_REMOVE_SYS_DSN      6
#define ODBC_INSTALL_DRIVER      1
#define ODBC_REMOVE_DRIVER       2

// ODBC 3.0 wants byte counts for buffer sizes, ODBC 3.5 and newer wants character counts
//   so we double the sizes of the buffers and pass the character count, 3.0 will use 1/2 the buffer on Unicode
#ifdef UNICODE
#define SQL_FIX 2
#else
#define SQL_FIX 1
#endif

iesEnum CMsiOpExecute::RollbackODBCEntry(const ICHAR* szName, rrkEnum rrkRoot,
													  ibtBinaryType iType)
{
	// generate rollback ops to delete/restore the following registration:
	// HK[CU|LM]\Software\ODBC\ODBC.INI\[szName] (entire key)
	// HK[CU|LM]\Software\ODBC\ODBC.INI\ODBC Data Sources  (szName value)

	if(RollbackEnabled() == fFalse)
		return iesSuccess;

	// basically just rollback a single named key from HKCU.
	PMsiRecord pErr(0);
	MsiString strODBC = TEXT("Software\\ODBC\\ODBC.INI\\");
	strODBC += szName;

	PMsiRegKey pODBCKey(0);

	iesEnum iesRet = iesSuccess;

	PMsiRegKey pRoot = &m_riServices.GetRootKey(rrkRoot, iType);
	PMsiRegKey pEntry = &pRoot->CreateChild(strODBC);
	Bool fKeyExists = fFalse;
	pErr = pEntry->Exists(fKeyExists);

	IMsiRecord* piRollback = &GetSharedRecord(IxoRegOpenKey::Args);
	using namespace IxoRegOpenKey;
	AssertNonZero(piRollback->SetInteger(Root, rrkRoot));
	AssertNonZero(piRollback->SetMsiString(Key, *strODBC));
	AssertNonZero(piRollback->SetInteger(BinaryType, iType));
	if (!RollbackRecord(Op, *piRollback))
		return iesFailure;

	ixfRegOpenKey(*piRollback);

	if (fKeyExists)
	{
		// roll it back in.
		SetRemoveKeyUndoOps(*pEntry);
	}
	
	// get rid of any old values
	piRollback = &GetSharedRecord(IxoRegRemoveKey::Args);
	Assert(0 == IxoRegRemoveKey::Args);
	if (!RollbackRecord(IxoRegRemoveKey::Op, *piRollback))
		return iesFailure;

	// delete/restore "ODBC Data Sources" value
	return SetRegValueUndoOps(rrkRoot, TEXT("Software\\ODBC\\ODBC.INI\\ODBC Data Sources"), szName, iType);
}

iesEnum CMsiOpExecute::RollbackODBCINSTEntry(const ICHAR* szSection, const ICHAR* szName,
															ibtBinaryType iType)
{
	iesEnum iesStat = iesSuccess;
	PMsiRecord pErr(0);

	PMsiRegKey pLocalMachine = &m_riServices.GetRootKey(rrkLocalMachine, iType);
	if (!pLocalMachine)
		return iesFailure;

	MsiString strODBCKey = TEXT("Software\\ODBC\\ODBCINST.INI");
	
	PMsiRegKey pODBCKey = &pLocalMachine->CreateChild(strODBCKey);
	if (!pODBCKey)
		return iesFailure;

	PMsiRegKey pSectionKey = &pODBCKey->CreateChild(szSection);
	if (!pSectionKey)
		return iesFailure;

	PMsiRegKey pEntryKey = &pODBCKey->CreateChild(szName);
	if (!pEntryKey)
		return iesFailure;


	Bool fEntryExists = fFalse;
	pErr = pSectionKey->ValueExists(szName, fEntryExists);
	if (pErr)
		return iesFailure;
	
	PMsiRecord pRollbackOpenKey = &m_riServices.CreateRecord(IxoRegOpenKey::Args);
	using namespace IxoRegOpenKey;
	AssertNonZero(pRollbackOpenKey->SetInteger(Root, rrkLocalMachine));
	AssertNonZero(pRollbackOpenKey->SetInteger(BinaryType, iType));

	MsiString strOpenKey = strODBCKey + szRegSep;
	strOpenKey += szSection;

	AssertNonZero(pRollbackOpenKey->SetMsiString(Key, *strOpenKey));
	if (!RollbackRecord(Op, *pRollbackOpenKey))
		return iesFailure;

	Assert(IxoRegAddValue::Args == IxoRegRemoveValue::Args);
	Assert(IxoRegAddValue::Name == IxoRegRemoveValue::Name);
	Assert(IxoRegAddValue::Value == IxoRegRemoveValue::Value);
	IMsiRecord& riValue = GetSharedRecord(IxoRegAddValue::Args);
	AssertNonZero(riValue.SetString(IxoRegAddValue::Name, szName));

	if (fEntryExists)
	{
		// reset to the old value
		MsiString strCurrentValue;
		pErr = pSectionKey->GetValue(szName, *&strCurrentValue);
		if (pErr)
			return iesFailure;

		using namespace IxoRegAddValue;
		AssertNonZero(riValue.SetMsiString(Value, *strCurrentValue));
		if (!RollbackRecord(IxoRegAddValue::Op, riValue))
			return iesFailure;
		
		// enumerate the values of the entry key, and write those as well.
		strOpenKey = strODBCKey + szRegSep;
		strOpenKey += szName;
		AssertNonZero(pRollbackOpenKey->SetMsiString(Key,*strOpenKey));

		// remove key undo ops relies on the key being open.
		// We don't actually want to remove the key now, just save off the old values.
		if (iesSuccess != (iesStat = ixfRegOpenKey(*pRollbackOpenKey)))
			return iesStat;

		// this doesn't need the key open in the rollback script.
		if (iesSuccess != (iesStat = SetRemoveKeyUndoOps(*pEntryKey)))
			return iesStat;
	}
	else
	{
		// remove any existing value in the section key.
		using namespace IxoRegRemoveValue;
		if (!RollbackRecord(IxoRegRemoveValue::Op, riValue))
			return iesFailure;
		
		// remove the entry key by that name.  Just whack whatever is there.
		strOpenKey = strODBCKey + szRegSep;
		strOpenKey += szName;
		AssertNonZero(pRollbackOpenKey->SetMsiString(Key, *strOpenKey));
		if (!RollbackRecord(IxoRegOpenKey::Op, *pRollbackOpenKey))
			return iesFailure;

		if (!RollbackRecord(IxoRegRemoveKey::Op, riValue))
			return iesFailure;
	}

	return iesStat;
}

iesEnum CMsiOpExecute::CheckODBCError(BOOL fResult, IErrorCode imsg, const ICHAR* sz, imsEnum imsDefault, ibtBinaryType iType)
{
	if (fResult == TRUE)
		return iesSuccess;
	else if ( fResult == ERROR_INSTALL_SERVICE_FAILURE ||
				 fResult == E_NOINTERFACE )
		// something failed along the custom action route
		return iesFailure;

	DWORD iErrorCode = 0;
	ICHAR rgchMessage[SQL_MAX_MESSAGE_LENGTH * SQL_FIX];
	rgchMessage[0] = 0;
	WORD cbMessage;
	PMsiRecord pError = &m_riServices.CreateRecord(sz ? 4 : 3);
	int iStat = LocalSQLInstallerError(1, &iErrorCode, rgchMessage, (SQL_MAX_MESSAGE_LENGTH-1) * SQL_FIX, &cbMessage, iType);
	ISetErrorCode(pError, imsg);
	pError->SetInteger(2, iErrorCode);
	pError->SetString(3, rgchMessage);
	if (sz)
		pError->SetString(4, sz);

	bool fErrorIgnorable = false;
	imtEnum imt;
	switch (imsDefault)
	{
	default: Assert(0);  // coding error in caller, fall through
	case imsOk:     imt = imtEnum(imtError + imtOk); break;
	case imsAbort:  imt = imtEnum(imtError + imtAbortRetryIgnore + imtDefault1); fErrorIgnorable = true; break;
	case imsIgnore: imt = imtEnum(imtError + imtAbortRetryIgnore + imtDefault3); fErrorIgnorable = true; break;
	}
	switch (Message(imt, *pError))
	{
	case imsIgnore: return iesSuccess;  // ignore error
	case imsRetry:  return iesSuspend;  // retry (standard mapping)
	case imsNone:                       // quiet UI - ignore ignoreable errors
		if(fErrorIgnorable)
			return (iesEnum)iesErrorIgnored;
		else
			return iesFailure;
	default:        return iesFailure;  // imsOK or imsAbort
	}
}

static ICHAR* ComposeDriverKeywordList(IMsiRecord& riParams, int& cbAttrs)
{
	using namespace IxoODBCInstallDriver;
	int iField;
	int cFields = riParams.GetFieldCount();
	int cbDriverKey = riParams.GetTextSize(DriverKey);
	const ICHAR* szDriverKey = riParams.GetString(DriverKey);
	cbAttrs = cbDriverKey + 2;  // extra null at end of attribute string
	for (iField = Args - 2 + 1; iField <= cFields; iField++)
	{
		int cb = riParams.GetTextSize(iField++);
		if (cb)  // skip null attribute names
			cbAttrs += cb + 1 + riParams.GetTextSize(iField) + 1;  // "attr=value\0"
	}
	ICHAR* szAttr = new ICHAR[cbAttrs];
	if ( ! szAttr )
		return NULL;
	ICHAR* pch = szAttr;
	lstrcpy(pch, szDriverKey);
	pch += cbDriverKey + 1;
	for (iField = Args - 2 + 1; iField <= cFields; iField++)
	{
		int cb = riParams.GetTextSize(iField++);
		if (cb)  // skip null attribute names
		{
			lstrcpy(pch, riParams.GetString(iField-1));
			pch += cb;
			*pch++ = '=';
			cb = riParams.GetTextSize(iField);
			if (cb)
				lstrcpy(pch, riParams.GetString(iField));
			else
				*pch = 0;
			pch += cb + 1; // keep null separator
		}
	}
	*pch = 0;  // double null terminator
	return szAttr;
}

iesEnum CMsiOpExecute::ixfODBCInstallDriver(IMsiRecord& riParams)
{
	return ODBCInstallDriverCore(riParams, ibt32bit);
}

iesEnum CMsiOpExecute::ixfODBCInstallDriver64(IMsiRecord& riParams)
{
	return ODBCInstallDriverCore(riParams, ibt64bit);
}

iesEnum CMsiOpExecute::ODBCInstallDriverCore(IMsiRecord& riParams, ibtBinaryType iType)
{
//  MSIXO(ODBCInstallDriver, XOT_UPDATE, MSIXA5(DriverKey, Component, Folder, Attribute_, Value_))
	using namespace IxoODBCInstallDriver;
//!! If we're replace the driver with a newer version
//!! somehow we need to remove the old driver first by calling SQLRemoveDriver repeatedly?
//!! or calling SQLConfigDriver(..ODBC_REMOVE_DRIVER..), then calling SQLRemoveDriver once?
	riParams.SetNull(0); // remove opcode, should set template for all params?
	if(Message(imtActionData, riParams) == imsCancel)
		return iesUserExit;
	const ICHAR* szDriverKey = riParams.GetString(DriverKey);
	int cbAttr;
	ICHAR* szAttr = ComposeDriverKeywordList(riParams, cbAttr);
	DWORD dwUsageCount;
	ICHAR rgchPathOut[MAX_PATH * SQL_FIX];  // we should have checked this already and set directory
	WORD cchPath = 0;

	if ( ! szAttr )
		return iesFailure;

	// Writes to HKLM\Software\ODBC\ODBCINST.INI\ODBC Drivers, <description>=Installed
	//                                          \Description, bunch of named value
	RollbackODBCINSTEntry(TEXT("ODBC Drivers"), szDriverKey, iType);

	iesEnum iesRet;
	WORD cbDummy;
	while (iesSuspend == (iesRet = CheckODBCError(LocalSQLInstallDriverEx(cbAttr, szAttr, riParams.GetString(IxoODBCInstallDriver::Folder),
											rgchPathOut, MAX_PATH * SQL_FIX, &cbDummy, ODBC_INSTALL_COMPLETE, &dwUsageCount, iType),
											Imsg(imsgODBCInstallDriver), szDriverKey, imsAbort, iType))) ;
	if (dwUsageCount > 1 && riParams.IsNull(Component))   // reinstall, remove added refcount
		LocalSQLRemoveDriver(szDriverKey, FALSE, &dwUsageCount, iType);

	if (iesRet == iesSuccess)
		while (iesSuspend == (iesRet = CheckODBCError(LocalSQLConfigDriver((HWND)0, ODBC_INSTALL_DRIVER, szDriverKey, 0, rgchPathOut, MAX_PATH * SQL_FIX, &cbDummy, iType),
											Imsg(imsgODBCInstallDriver), szDriverKey, imsAbort, iType))) ;
	delete szAttr;
	return iesRet;
}

iesEnum CMsiOpExecute::ixfODBCRemoveDriver(IMsiRecord& riParams)
{
	return ODBCRemoveDriverCore(riParams, ibt32bit);
}

iesEnum CMsiOpExecute::ixfODBCRemoveDriver64(IMsiRecord& riParams)
{
	return ODBCRemoveDriverCore(riParams, ibt64bit);
}

iesEnum CMsiOpExecute::ODBCRemoveDriverCore(IMsiRecord& riParams, ibtBinaryType iType)
{
//  MSIXO(ODBCRemoveDriver, XOT_UPDATE, MSIXA2(DriverKey, Component))
// NOTE: this operator gets called only if the product is the last remaining client of the component    using namespace IxoODBCRemoveDriver;
	riParams.SetNull(0); // remove opcode
	if(Message(imtActionData, riParams) == imsCancel)
		return iesUserExit;
	const ICHAR* szDriverKey = riParams.GetString(IxoODBCRemoveDriver::DriverKey);
	DWORD dwUsageCount;
	BOOL fRemoveDSN = FALSE;

	// Removes values from HKLM\Software\ODBC\ODBCINST.INI,,,  (see SQLInstallDriverEx)
	RollbackODBCINSTEntry(TEXT("ODBC Drivers"), szDriverKey, iType);

	iesEnum iesRet = iesSuccess;

	while (iesSuspend == (iesRet = CheckODBCError(LocalSQLRemoveDriver(szDriverKey, fRemoveDSN, &dwUsageCount, iType),
									Imsg(imsgODBCRemoveDriver), szDriverKey, imsIgnore, iType))) ;
	return iesRet;
	// ODBC will automatically call SQLConfigDriver(..ODBC_REMOVE_DRIVER..) if ref count goes to 0
}

iesEnum CMsiOpExecute::ixfODBCInstallTranslator(IMsiRecord& riParams)
{
	return ODBCInstallTranslatorCore(riParams, ibt32bit);
}

iesEnum CMsiOpExecute::ixfODBCInstallTranslator64(IMsiRecord& riParams)
{
	return ODBCInstallTranslatorCore(riParams, ibt64bit);
}

iesEnum CMsiOpExecute::ODBCInstallTranslatorCore(IMsiRecord& riParams, ibtBinaryType iType)
{
	using namespace IxoODBCInstallTranslator;
//!! somehow we need to remove the old driver first by calling SQLRemoveDriver repeatedly?
	riParams.SetNull(0); // remove opcode, should set template for all params?
	if(Message(imtActionData, riParams) == imsCancel)
		return iesUserExit;
	int cbAttr;
	ICHAR* szAttr = ComposeDriverKeywordList(riParams, cbAttr);
	DWORD dwUsageCount;
	ICHAR rgchPathOut[MAX_PATH * SQL_FIX];  // we should have checked this already and set directory

	if ( ! szAttr )
		return iesFailure;

	// Writes to HKLM\Software\ODBC\ODBCINST.INI\ODBC Translators, named value
	RollbackODBCINSTEntry(TEXT("ODBC Translators"), riParams.GetString(TranslatorKey), iType);

	iesEnum iesRet;
	WORD cbDummy;
	while (iesSuspend == (iesRet = CheckODBCError(LocalSQLInstallTranslatorEx(cbAttr, szAttr,
									riParams.GetString(IxoODBCInstallTranslator::Folder),
									rgchPathOut, MAX_PATH * SQL_FIX, &cbDummy, ODBC_INSTALL_COMPLETE, &dwUsageCount, iType),
									Imsg(imsgODBCInstallDriver), riParams.GetString(TranslatorKey), imsAbort, iType))) ;
	if (dwUsageCount > 1 && riParams.IsNull(Component))   // reinstall, remove added refcount
		LocalSQLRemoveTranslator(riParams.GetString(TranslatorKey), &dwUsageCount, iType);
	delete szAttr;
	return iesRet;
}

iesEnum CMsiOpExecute::ixfODBCRemoveTranslator(IMsiRecord& riParams)
{
	return ODBCRemoveTranslatorCore(riParams, ibt32bit);
}

iesEnum CMsiOpExecute::ixfODBCRemoveTranslator64(IMsiRecord& riParams)
{
	return ODBCRemoveTranslatorCore(riParams, ibt64bit);
}

iesEnum CMsiOpExecute::ODBCRemoveTranslatorCore(IMsiRecord& riParams, ibtBinaryType iType)
{
	using namespace IxoODBCRemoveTranslator;
	riParams.SetNull(0); // remove opcode, should set template for all params?
	if(Message(imtActionData, riParams) == imsCancel)
		return iesUserExit;
	const ICHAR* szTranslatorKey = riParams.GetString(TranslatorKey);
	DWORD dwUsageCount;
	BOOL fRemoveDSN = FALSE;

	// Writes to HKLM\Software\ODBC\ODBCINST.INI\ODBC Translators, named value
	RollbackODBCINSTEntry(TEXT("ODBC Translators"), riParams.GetString(TranslatorKey), iType);

	iesEnum iesRet;
	
	while (iesSuspend == (iesRet = CheckODBCError(LocalSQLRemoveTranslator(szTranslatorKey, &dwUsageCount, iType),
								Imsg(imsgODBCRemoveDriver), szTranslatorKey, imsIgnore, iType))) ;
	return iesRet;
}

iesEnum CMsiOpExecute::ixfODBCDataSource(IMsiRecord& riParams)
{
	return ODBCDataSourceCore(riParams, ibt32bit);
}

iesEnum CMsiOpExecute::ixfODBCDataSource64(IMsiRecord& riParams)
{
	return ODBCDataSourceCore(riParams, ibt64bit);
}

iesEnum CMsiOpExecute::ODBCDataSourceCore(IMsiRecord& riParams, ibtBinaryType iType)
{
//  MSIXO(ODBCDataSource, XOT_UPDATE, MSIXA5(DriverKey, Component, Registration, Attribute_, Value_))
	using namespace IxoODBCDataSource;
	riParams.SetNull(0); // remove opcode, should set template for all params?
	if(Message(imtActionData, riParams) == imsCancel)
		return iesUserExit;
	int iRequest = riParams.GetInteger(Registration);
	ICHAR* szAttr = 0;
	int iField;
	int cFields = riParams.GetFieldCount();
	int cbAttrs = 1;  // extra null at end of attribute string
	for (iField = Args - 2 + 1; iField <= cFields; iField++)
	{
		int cb = riParams.GetTextSize(iField++);
		if (cb)  // skip null attribute names
			cbAttrs += cb + 1 + riParams.GetTextSize(iField) + 1;  // "attr=value\0"
	}
	if (cbAttrs > 1)
	{
		szAttr = new ICHAR[cbAttrs];
		if ( ! szAttr )
			return iesFailure;
		ICHAR* pch = szAttr;
		for (iField = Args - 2 + 1; iField <= cFields; iField++)
		{
			int cb = riParams.GetTextSize(iField++);
			if (cb)  // skip null attribute names
			{
				lstrcpy(pch, riParams.GetString(iField-1));
				pch += cb;
				*pch++ = '=';
				cb = riParams.GetTextSize(iField);
				if (cb)
					lstrcpy(pch, riParams.GetString(iField));
				else
					*pch = 0;
				pch += cb + 1; // keep null separator
			}
		}
		*pch = 0;  // double null terminator
	}

	const ICHAR* szDriverKey = riParams.GetString(DriverKey);

	// Writes to HKCU\Software\ODBC\ODBC.INI\<Value_>..   Contains subkeys and named values.
	rrkEnum rrkRollbackRoot = (iRequest == ODBC_ADD_DSN || iRequest == ODBC_REMOVE_DSN)
									  ? rrkCurrentUser : rrkLocalMachine;
	const ICHAR* szRollbackKey = riParams.GetString(Value_);
	RollbackODBCEntry(szRollbackKey, rrkRollbackRoot, iType);

	bool fRetry = false;
	iesEnum iesRet;
	BOOL fStat;
	if (iRequest == ODBC_REMOVE_DSN || iRequest == ODBC_REMOVE_SYS_DSN)
	{
		fStat = LocalSQLConfigDataSource((HWND)0, (WORD)iRequest, szDriverKey, 
													szAttr, cbAttrs, iType);
		if (fStat == FALSE)
			DEBUGMSG2(TEXT("Non-fatal error removing ODBC data source %s for driver %s"), szAttr, szDriverKey);
		iesRet = iesSuccess;
	}
	else // ODBC_ADD_DSN || ODBC_ADD_SYS_DSN
	{
		do
		{
			fStat = LocalSQLConfigDataSource((HWND)0, (WORD)iRequest, szDriverKey,
														szAttr, cbAttrs, iType);
			if (fStat == FALSE) // perhaps already exists and we have a old driver
				fStat = LocalSQLConfigDataSource((HWND)0, (WORD)(iRequest + ODBC_CONFIG_DSN - ODBC_ADD_DSN),
															szDriverKey, szAttr, cbAttrs, iType);
		} while (iesSuspend == (iesRet = CheckODBCError(fStat, Imsg(imsgODBCDataSource), riParams.GetString(Value_), imsIgnore, iType)));
	}
	delete szAttr;
	return iesRet;
}

iesEnum CMsiOpExecute::ixfODBCDriverManager(IMsiRecord& riParams)
{
	iesEnum iesStat = iesSuccess;
	Bool iState = (Bool)riParams.GetInteger(IxoODBCDriverManager::State);
	if (iState == iMsiNullInteger) // no action required, simply unbind
		return iesSuccess;

	ibtBinaryType iType;
	if ( riParams.GetInteger(IxoODBCDriverManager::BinaryType) == iMsiNullInteger )
		iType = ibt32bit;
	else
		iType = (ibtBinaryType)riParams.GetInteger(IxoODBCDriverManager::BinaryType);

	//this goes in HKLM\Software\ODBC\ODBCINST.INI
	PMsiRegKey pLocalMachine = &m_riServices.GetRootKey(rrkLocalMachine, iType);
	if (!pLocalMachine)
		return iesFailure;

	MsiString strODBCKey = TEXT("Software\\ODBC\\ODBCINST.INI\\ODBC Core");
	PMsiRegKey pODBCKey = &pLocalMachine->CreateChild(strODBCKey);
	if (!pODBCKey)
		return iesFailure;

	Bool fCoreExists = fFalse;
	PMsiRecord pErr = pODBCKey->Exists(fCoreExists);
	if (pErr)
		return iesFailure;

	IMsiRecord& riRollback = GetSharedRecord(IxoRegOpenKey::Args);
	AssertNonZero(riRollback.SetInteger(IxoRegOpenKey::Root, rrkLocalMachine));
	AssertNonZero(riRollback.SetMsiString(IxoRegOpenKey::Key, *strODBCKey));
	AssertNonZero(riRollback.SetInteger(IxoRegOpenKey::BinaryType, iType));
	if (!RollbackRecord(IxoRegOpenKey::Op, riRollback))
		return iesFailure;

	if (iesSuccess != (iesStat = ixfRegOpenKey(riRollback)))
			return iesStat;


	if (fCoreExists && RollbackEnabled())
	{
		// regenerate old values.
		if (iesSuccess != (iesStat = SetRemoveKeyUndoOps(*pODBCKey)))
			return iesStat;
	}

	// delete any new values
	Assert(0 == IxoRegRemoveKey::Args);
	if (!RollbackRecord(IxoRegRemoveKey::Op, riRollback))
		return iesFailure;

	if (iState) // install
	{
		ICHAR rgchPath[MAX_PATH * SQL_FIX];  // ignored, already determined location
		WORD cbDummy;
		return CheckODBCError(LocalSQLInstallDriverManager(rgchPath, MAX_PATH * SQL_FIX, &cbDummy, iType),
									 Imsg(imsgODBCInstallDriverManager), 0, imsOk, iType);
	}
	else  // remove -  we should never really remove it, but we probably want to call it to bump the ref count
	{
		DWORD dwUsageCount;  // we never remove the files, so do we care about this?
		BOOL fStat = LocalSQLRemoveDriverManager(&dwUsageCount, iType);
		return iesSuccess;
	}
}

/*---------------------------------------------------------------------------
ixfControlService: core for starting or stopping services.  
---------------------------------------------------------------------------*/

SC_HANDLE GetServiceHandle(const IMsiString& riMachineName, const IMsiString& riName, const DWORD dwDesiredAccess )
{
	SC_HANDLE hSCManager = WIN::OpenSCManager(riMachineName.GetString(), SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);
	DWORD LastError;

	if (!hSCManager)
		return NULL;

	SC_HANDLE hSCService = WIN::OpenService(hSCManager, riName.GetString(), dwDesiredAccess);
	LastError = GetLastError();
	WIN::CloseServiceHandle(hSCManager);
	SetLastError(LastError);

	return hSCService;
}

const IMsiString& GetServiceDisplayName(const IMsiString& riMachineName, const IMsiString& riName)
{
	//It isn't really necessary to keep passing the machine name around.  However, there's no great
	// cost involved, and will allow for less re-engineering if we ever attempt to control services
	// on other machines.

	DWORD cbLength = 0;

	SC_HANDLE hSCManager = WIN::OpenSCManager(riMachineName.GetString(), SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
	if (!hSCManager)
		return MsiString(*TEXT("")).Return();


	WIN::GetServiceDisplayName(hSCManager, riName.GetString(), NULL, &cbLength);
	// should fail, to get size of buffer needed.

	

	// There looks to be a bug in WIN::GetServiceDisplayName.
	// in non-UNICODE builds on NT, it looks to be returning twice the expected number.
	// it could be returning the number of bytes stored internally (which is UNICODE)
	// This isn't particularly a problem, it's just wasted space.

	TCHAR* szDisplayName = new TCHAR[cbLength + sizeof(TCHAR)];

   WIN::GetServiceDisplayName(hSCManager, riName.GetString(), szDisplayName, &cbLength);
	MsiString strDisplayName(szDisplayName);

	delete[] szDisplayName;

	return strDisplayName.Return();
}

DWORD GetServiceState(SC_HANDLE hService)
{
	SERVICE_STATUS SSCurrent;

	WIN::ControlService(hService, SERVICE_CONTROL_INTERROGATE, &SSCurrent);
	
	if (WIN::QueryServiceStatus(hService,  &SSCurrent))
	{
		return SSCurrent.dwCurrentState;
	}
	else return 0;
}

bool CMsiOpExecute::WaitForService(const SC_HANDLE hService, const DWORD dwDesiredState, const DWORD dwFailedState)
{
	// caller is responsible for retrying if they think the other guy is doing work without signalling correctly.

	// WaitForService is responsible for eventually timing out if the service never goes to an expected state.
	DWORD dwCurrentState = 0;

	int cRetry = 0;
	while(dwDesiredState != dwCurrentState)
	{   

		g_MessageContext.DisableTimeout();
		if (!(dwCurrentState = GetServiceState(hService)))
		{
			DWORD dwLastError = WIN::GetLastError();
			g_MessageContext.EnableTimeout();
			return false;
		}
		g_MessageContext.EnableTimeout();

		if (dwFailedState == dwCurrentState)
		{
			return false;
		}

		Sleep(500);
		cRetry++;
		if (cRetry > (30 /*seconds*/ * 1000 /* milliseconds */ / 500 /* number from Sleep before */))
			return false;
	}

	return true;
}
bool CMsiOpExecute::RollbackServiceConfiguration(const SC_HANDLE hSCService, const IMsiString& ristrName, IMsiRecord& riParams)
{
	// Create rollback record before we actually do anything with it.
	// This does *not* include writing appropriate registry keys.
	
	const int cbBuffer = 512;
	CTempBuffer<char, cbBuffer> pchBuffer;
	LPQUERY_SERVICE_CONFIG QSCBuffer = (LPQUERY_SERVICE_CONFIG) (char*) pchBuffer;
	DWORD cbBufferNeeded;

	if (!WIN::QueryServiceConfig(hSCService, QSCBuffer, cbBuffer, &cbBufferNeeded))
	{
		DWORD dwLastError = WIN::GetLastError();
		if (ERROR_FILE_NOT_FOUND == dwLastError)
			return false;
		Assert(ERROR_INSUFFICIENT_BUFFER == dwLastError);
		if (cbBuffer < cbBufferNeeded)
		{
			pchBuffer.SetSize(cbBufferNeeded);
			if ( ! (char *) pchBuffer )
				return false;
			QSCBuffer = (LPQUERY_SERVICE_CONFIG) (char*) pchBuffer;
			WIN::QueryServiceConfig(hSCService, QSCBuffer, cbBufferNeeded, &cbBufferNeeded);
		}
	}


	// To get the description we have to use a different function. This function
	// came to life on Win2K

	const int cbBuffer2 = 512;
	CTempBuffer<char, cbBuffer2> pchBuffer2;
	LPSERVICE_DESCRIPTION QSCBuffer2 = (LPSERVICE_DESCRIPTION) (char*) pchBuffer2;
	DWORD cbBufferNeeded2;
	MsiString strDescription;
	bool fQueriedDescription = false;
	if (!ADVAPI32::QueryServiceConfig2(hSCService, SERVICE_CONFIG_DESCRIPTION, (LPBYTE)(char*)QSCBuffer2, cbBuffer2, &cbBufferNeeded2))
	{
		DWORD dwLastError = WIN::GetLastError();
		if (ERROR_INVALID_FUNCTION != dwLastError)
		{
			if (ERROR_FILE_NOT_FOUND == dwLastError)
				return false;
			Assert(ERROR_INSUFFICIENT_BUFFER == dwLastError);
			if (cbBuffer2 < cbBufferNeeded2)
			{
				pchBuffer.SetSize(cbBufferNeeded2);
				if ( ! (char *) pchBuffer2 )
					return false;
				QSCBuffer2 = (LPSERVICE_DESCRIPTION) (char*) pchBuffer2;
				if (ADVAPI32::QueryServiceConfig2(hSCService, SERVICE_CONFIG_DESCRIPTION, (LPBYTE)(char*)QSCBuffer2, cbBufferNeeded2, &cbBufferNeeded2))
					fQueriedDescription = true;
			}
		}
	}
	else
	{
		fQueriedDescription = true;
	}
	if (fQueriedDescription)
	{
		strDescription = QSCBuffer2->lpDescription;

		if (strDescription.TextSize() == 0)
		{
			// We need to replace empty string with an embedded NULL. This
			// will force the empty string to be written back during rollback.

			// no DBCS since using an embedded NULL as only char
			ICHAR* pchDescription = strDescription.AllocateString(1, /*fDBCS=*/fFalse);
			pchDescription[0] = 0;
		}
	}

	using namespace IxoServiceInstall;

	AssertNonZero(riParams.SetMsiString(Name, ristrName));
	AssertNonZero(riParams.SetMsiString(DisplayName, *MsiString(QSCBuffer->lpDisplayName)));
	AssertNonZero(riParams.SetMsiString(ImagePath, *MsiString(QSCBuffer->lpBinaryPathName)));
	AssertNonZero(riParams.SetInteger(ServiceType, QSCBuffer->dwServiceType));
	AssertNonZero(riParams.SetInteger(StartType, QSCBuffer->dwStartType));
	AssertNonZero(riParams.SetInteger(ErrorControl, QSCBuffer->dwErrorControl));
	AssertNonZero(riParams.SetMsiString(LoadOrderGroup, *MsiString(QSCBuffer->lpLoadOrderGroup)));
	AssertNonZero(riParams.SetMsiString(Description, *strDescription));

	// dependencies are a double null terminated list...
	ICHAR* pchCounter = QSCBuffer->lpDependencies;
	AssertSz(QSCBuffer->lpDependencies, "Services dependencies list unexpectedly null.");
	while(NULL != *pchCounter || NULL != *(pchCounter+1))
		pchCounter++;

	MsiString strDependencies;
//  Assert((UINT_PTR)(pchCounter - QSCBuffer->lpDependencies +2) < UINT_MAX);   //--merced: we typecast to uint below, it better be in range.
	unsigned int cchDependencies = (unsigned int)(pchCounter - QSCBuffer->lpDependencies +2);   //--merced: added (unsigned int)
	// we take the perf hit on Win9X to be able to handle DBCS, on UNICODE -- fDBCS arg is ignored
	// service names are not localized, but it is unknown as to whether or not a service name could start out containing DBCS char
	ICHAR* pchDependencies = strDependencies.AllocateString(cchDependencies, /*fDBCS=*/fTrue);
	memcpy(pchDependencies, QSCBuffer->lpDependencies, cchDependencies);
	AssertNonZero(riParams.SetMsiString(Dependencies, *strDependencies));

	// Note:  TagId is only used for purposes of rollback.
	AssertNonZero(riParams.SetInteger(TagId, QSCBuffer->dwTagId));
	AssertNonZero(riParams.SetMsiString(StartName, *MsiString(QSCBuffer->lpServiceStartName)));
	AssertNonZero(riParams.SetNull(Password));

	return true;
}

bool CMsiOpExecute::DeleteService(IMsiRecord& riInboundParams, IMsiRecord& riUndoParams, BOOL fRollback, IMsiRecord* piActionData)
{
	using namespace IxoServiceControl;
	MsiString strName(riInboundParams.GetMsiString(Name));
	bool fRet = true;

	if (fRollback)
	{
		AssertNonZero(riUndoParams.SetMsiString(Name, *strName));
		AssertNonZero(riUndoParams.SetInteger(Action, isoDelete));
		AssertNonZero(CMsiOpExecute::RollbackRecord(ixoServiceControl, riUndoParams));
	}

	// deleting a service implies you should stop it first...
	// An author may include an explicit stop service before they get to the delete,
	// but there's no sense in making it a requirement when we know the right thing
	// to do.

	// Also, we may not have waited for the service to actually completely stop,
	// so we need to be absolutely sure it's done.

	int iWait = riInboundParams.GetInteger(Wait);

	Bool fChangedInboundRecord = fFalse;
	PMsiRecord pParams(0);
	if (IxoServiceControl::Args != riInboundParams.GetFieldCount())
	{
		fChangedInboundRecord = fTrue;
		const int cFields = IxoServiceControl::Args;
		pParams = &m_riServices.CreateRecord(cFields);
		for (int cCounter = 0; cCounter <= cFields; cCounter++)
		{
			if (riInboundParams.IsInteger(cCounter))
				AssertNonZero(pParams->SetInteger(cCounter, riInboundParams.GetInteger(cCounter)));
			else
				AssertNonZero(pParams->SetMsiData(cCounter, PMsiData(riInboundParams.GetMsiData(cCounter))));
		}
	}
	else
	{
		riInboundParams.AddRef();
		pParams = &riInboundParams;
	}

	
	Assert(IxoServiceControl::Args == pParams->GetFieldCount());
	AssertNonZero(pParams->SetInteger(Wait, 1));
	fRet = StopService(*pParams, riUndoParams, fFalse, piActionData);
	AssertNonZero(pParams->SetInteger(Wait, iWait));
	if (fRet != true)
		return false;

	SC_HANDLE hSCService = GetServiceHandle(*MsiString(pParams->GetMsiString(MachineName)), *strName,
										(DELETE | SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG));

	if (!hSCService)
	{
		DWORD dwLastError = WIN::GetLastError();
		if (ERROR_SERVICE_DOES_NOT_EXIST == dwLastError)
			return true;
		else
			return false;
	}

#ifdef DEBUG
	ICHAR szRegData[255];
	wsprintf(szRegData, TEXT("System\\CurrentControlSet\\Services\\%s"), (const ICHAR*) strName);
	PMsiRegKey pRegKey = &m_riServices.GetRootKey(rrkLocalMachine); 
	pRegKey = &pRegKey->CreateChild(szRegData);
	Bool fServiceKeyExists = fFalse;
	PMsiRecord pErr = pRegKey->Exists(fServiceKeyExists);
	Assert(fServiceKeyExists);
#endif

	IMsiRecord& riInstallParams = GetSharedRecord(IxoServiceInstall::Args);
	bool fRollbackStatus = RollbackServiceConfiguration(hSCService, *strName, riInstallParams);

	if (WIN::DeleteService(hSCService))
	{
		// register the rollback
		if (fRollbackStatus)
			RollbackRecord(ixoServiceInstall, riInstallParams);
	}
	else
	{
		DWORD dwLastError = WIN::GetLastError();
		if (ERROR_SERVICE_MARKED_FOR_DELETE != dwLastError)
			fRet = false;
	}

	WIN::CloseServiceHandle(hSCService);

	return fRet;
}

ICHAR** CMsiOpExecute::NewArgumentArray(const IMsiString& ristrArguments, int& cArguments)
{
	cArguments = 0;

	ICHAR* pchArguments = (ICHAR*) ristrArguments.GetString();
	int cchArguments = ristrArguments.CharacterCount();

	// First, determine number of arguments for size of array
	if (0 != cchArguments)
	{
		for (int cCounter = 0; cCounter <= cchArguments; cCounter++)
		{
			if (NULL != *pchArguments)
				pchArguments = INextChar(pchArguments);
			else
			{
				cArguments++;
				pchArguments++;
			}
		}
	}

	ICHAR** pszArguments;
	if (cArguments)
		pszArguments = new ICHAR*[cArguments];
	else
		pszArguments = NULL;

	// next, fill in the pointers to each substring within the packed string.
	if (cArguments)
	{
		if ( ! pszArguments )
			return NULL;
		pchArguments = (ICHAR*) ristrArguments.GetString();
		pszArguments[0] = pchArguments;
		for (int cCounter = 1; cCounter < cArguments; cCounter++)
		{
			while(NULL != *pchArguments)
			{
				pchArguments = INextChar(pchArguments);
			}
			pszArguments[cCounter] = ++pchArguments;
		}
	}
	return pszArguments;
}

bool CMsiOpExecute::StartService(IMsiRecord& riParams, IMsiRecord& riUndoParams, BOOL fRollback)
{   
	using namespace IxoServiceControl;

	MsiString strName(riParams.GetMsiString(Name));

	bool fRet = true;

	if (fRollback)
	{
		// create a rollback script to startup the described service
		AssertNonZero(riUndoParams.SetMsiString(Name, *strName));
		AssertNonZero(riUndoParams.SetInteger(Action, isoStart));
		AssertNonZero(CMsiOpExecute::RollbackRecord(ixoServiceControl,riUndoParams));

		return iesSuccess;
	}

	SC_HANDLE hSCService = GetServiceHandle(*MsiString(riParams.GetMsiString(MachineName)), *strName,
										(SERVICE_START | SERVICE_QUERY_STATUS));


	if (!hSCService)
		return false;

	int cArguments = 0;
	MsiString strArguments(riParams.GetMsiString(StartupArguments));
	ICHAR** pszArguments = NewArgumentArray(*strArguments, cArguments);

	UINT iCurrMode = WIN::SetErrorMode(0);
	WIN::SetErrorMode(iCurrMode & ~SEM_FAILCRITICALERRORS);
	if (WIN::StartService(hSCService, cArguments, (const ICHAR**) pszArguments))
	{
		// Rollback info.
		StopService(riParams, riUndoParams, fTrue);
	}
	else
	{
		DWORD dwLastError = WIN::GetLastError();

		if (ERROR_SERVICE_ALREADY_RUNNING != dwLastError)
		{
			delete[] pszArguments;
			AssertNonZero(WIN::CloseServiceHandle(hSCService));

			WIN::SetErrorMode(iCurrMode);
			WIN::SetLastError(dwLastError);
			return false;
		}
		// If the SCM is in a locked state, we'll wait and retry through the automated mechanism.
		
		// If the service startup times out (ERROR_SERVICE_REQUEST_TIMEOUT,) we'll
		// provide abort/retry/ignore mechanism through the main ixfServiceControl mechanism.
	}

	delete[] pszArguments;
	WIN::SetErrorMode(iCurrMode);
	
	if (riParams.GetInteger(Wait))
	{
		fRet = WaitForService(hSCService, SERVICE_RUNNING, SERVICE_STOPPED);
	}

	AssertNonZero(WIN::CloseServiceHandle(hSCService));

	return fRet;
}

bool CMsiOpExecute::StopService(IMsiRecord& riParams, IMsiRecord& riUndoParams, BOOL fRollback, IMsiRecord* piActionData)
{   
	using namespace IxoServiceControl;

	bool fRet = true;

	MsiString strName(riParams.GetMsiString(Name));

	if (fRollback)
	{
		// create a rollback script to stop the described service
		AssertNonZero(riUndoParams.SetMsiString(Name, *strName));
		AssertNonZero(riUndoParams.SetInteger(Action, isoStop));
		if (!RollbackRecord(ixoServiceControl,riUndoParams))
			return false;
		else
			return true;
	}

	SC_HANDLE hSCService = GetServiceHandle(*MsiString(riParams.GetMsiString(MachineName)), *strName,
										(SERVICE_STOP | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS));  

	if (!hSCService)
	{
		if (ERROR_SERVICE_DOES_NOT_EXIST == WIN::GetLastError())
		{
			return true;
		}
		else
			return false;
	}

	SERVICE_STATUS SSControl;
	if (WIN::ControlService(hSCService, SERVICE_CONTROL_STOP, &SSControl))      
	{
		// Rollback info.
		StartService(riParams, riUndoParams, fTrue);
	}
	else
	{
		DWORD dwLastError = WIN::GetLastError();

		if  (   (ERROR_SERVICE_NOT_ACTIVE == dwLastError) ||
				(ERROR_SERVICE_NEVER_STARTED == dwLastError) ||
				(ERROR_SERVICE_DOES_NOT_EXIST == dwLastError)
			)
		{
			WIN::CloseServiceHandle(hSCService);
			return true;
		}


		// if there are any dependent services running, we need to shut those down first, and retry.

		if (ERROR_DEPENDENT_SERVICES_RUNNING == dwLastError)
		{
			// enumerate the dependent services, and call StopService on those.
			// Note that this becomes a recursive call, working its way through the tree.
			// This shouldn't be very deep.

			fRet = true;

			DWORD cbNeeded = 0;
			DWORD cServices = 0;

			WIN::EnumDependentServices(hSCService, SERVICE_ACTIVE, NULL, 0, &cbNeeded, &cServices);
			DWORD dwLastError = WIN::GetLastError();
			if ((ERROR_MORE_DATA==dwLastError) && cbNeeded)
			{
				ENUM_SERVICE_STATUS* ssServices= (ENUM_SERVICE_STATUS*) new byte[cbNeeded];
				
				MsiString strDisplayName(piActionData->GetMsiString(1));
				if (WIN::EnumDependentServices(hSCService, SERVICE_ACTIVE, ssServices, cbNeeded, &cbNeeded, &cServices))
				{
					Assert(cServices);
					MsiString strDisplayName(piActionData->GetMsiString(1));
					for (int cCounter = 0; cCounter < cServices; cCounter++)
					{
						AssertNonZero(riParams.SetString(Name, ssServices[cCounter].lpServiceName));
						AssertNonZero(piActionData->SetString(1, ssServices[cCounter].lpDisplayName));
						AssertNonZero(piActionData->SetString(2, ssServices[cCounter].lpServiceName));

						if (false == (fRet = StopService(riParams, riUndoParams, fFalse, piActionData)))
						{
							break;
						}
						
					}
				}
				else
				{
					DWORD dwLastError = WIN::GetLastError();
					Assert(ERROR_MORE_DATA != dwLastError);
					fRet = false;
					WIN::SetLastError(dwLastError);
				}

				delete[] ssServices;
				AssertNonZero(riParams.SetMsiString(Name, *strName));
				AssertNonZero(piActionData->SetMsiString(1, *strDisplayName));
				AssertNonZero(piActionData->SetMsiString(2, *strName));
			}

			// try calling ourself one last time.  One of the dependent services might have
			// failed to stop, but if we can stop the one we came here for, we consider
			// it a success.
			if (false == (fRet = StopService(riParams, riUndoParams, fFalse, piActionData)))
			{
				dwLastError = WIN::GetLastError();
				Assert(ERROR_DEPENDENT_SERVICES_RUNNING != dwLastError);
				WIN::SetLastError(dwLastError);
			}

		}
		// If the SCM is in a locked state, we'll wait and retry through the automated mechanism.
		// if the service request times out, we'll retry via the automatic retry mechanism.
	}
	
#ifdef DEBUG
	// This detects a service that did not properly update its status with the SCM.
	// The common repro scenario is that sometimes you'll hit this assert, sometimes you won't.
	// Generally retrying the failure will work the second time (as the service finishes
	// what it was doing, and the retry detects it as being stopped.)
	DWORD dwServiceState = WIN::GetServiceState(hSCService);
	//Assert((SERVICE_STOP_PENDING == dwServiceState) || (SERVICE_STOPPED == dwServiceState));
#endif
	

	if (riParams.GetInteger(Wait))
	{
		fRet = WaitForService(hSCService, SERVICE_STOPPED, SERVICE_RUNNING);
	}

	AssertNonZero(WIN::CloseServiceHandle(hSCService));

	return fRet;
}

iesEnum CMsiOpExecute::ixfServiceControl(IMsiRecord& riParams)
{
	// core function for start, stop

	// this needs to be a common function to keep as much information about a service
	// available when starting or stopping.

	// Example:  If you stop a service, and rollback wants to restart it, you need to have
	// the startup arguments available.

	using namespace IxoServiceControl;
	MsiString strName(riParams.GetMsiString(Name));
	int iWaitForService = riParams.GetInteger(Wait);
	bool fRet = true;
	isoEnum isoControl = isoEnum(riParams.GetInteger(Action));


	DWORD dwErrorControl = 0;
	Bool fServiceKeyExists = fFalse;

	PMsiRecord pError(0);

	ICHAR szRegData[255];
	wsprintf(szRegData, TEXT("System\\CurrentControlSet\\Services\\%s"), (const ICHAR*) strName);
	PMsiRegKey pRegKey = &m_riServices.GetRootKey(rrkLocalMachine); 
	pRegKey = &pRegKey->CreateChild(szRegData);

	pError = pRegKey->Exists(fServiceKeyExists);

	// a very quick short-circuit to avoid mucking around with the
	// service control manager.

	if (!fServiceKeyExists && (isoStop == isoControl || isoDelete == isoControl))
		return iesSuccess;


	MsiString strErrorControl;
	if (fServiceKeyExists)
		pError = pRegKey->GetValue(TEXT("ErrorControl"), *&strErrorControl);

	// the regkey object prefaces DWORD values with #
	if (strErrorControl.Compare(iscStart, TEXT("#")))
	{
		strErrorControl = strErrorControl.Extract(iseAfter, TEXT('#'));
		dwErrorControl = strErrorControl;
	}
	else
		dwErrorControl = 0;

	

	enum enumServiceSeverity
	{
		eServiceIgnorable,
		eServiceNormal,
		eServiceCritical
	} eServiceSeverity;

	if (iWaitForService)
		eServiceSeverity = eServiceCritical;
	else if (fServiceKeyExists)
	{
		switch (dwErrorControl)
		{
			case SERVICE_ERROR_IGNORE:
					eServiceSeverity = eServiceIgnorable;
					break;
			case SERVICE_ERROR_NORMAL:
					eServiceSeverity = eServiceNormal;
					break;
			default:
					eServiceSeverity = eServiceCritical;
					break;
		}
	}
	else
		eServiceSeverity = eServiceNormal;

	if ((eServiceCritical == eServiceSeverity) && (m_ixsState == ixsRollback))
	{
		// no critical errors in rollback
		eServiceSeverity = eServiceNormal;
	}
	
	// a common record passed through for Undo.
	// Based on the action taken, the Action will vary.
	IMsiRecord& riUndoParams = GetSharedRecord(Args);
	AssertNonZero(riUndoParams.SetMsiString(MachineName,*MsiString(riParams.GetMsiString(MachineName))));


	AssertNonZero(riUndoParams.SetNull(Name));
	AssertNonZero(riUndoParams.SetNull(Action));
	AssertNonZero(riUndoParams.SetInteger(Wait,iWaitForService));
	AssertNonZero(riUndoParams.SetMsiString(StartupArguments, *MsiString(riParams.GetMsiString(StartupArguments))));


	// Record for messages
	PMsiRecord pActionData = &m_riServices.CreateRecord(2);
	
	MsiString strDisplayName(GetServiceDisplayName(*MsiString(riParams.GetMsiString(MachineName)), *strName));  
	if (!strDisplayName.CharacterCount())
			strDisplayName = strName;

	AssertNonZero(pActionData->SetMsiString(1,*strDisplayName));
	AssertNonZero(pActionData->SetMsiString(2,*strName));

	Bool fRetry = fTrue;
	imsEnum imsResponse = imsNone;

	imtEnum imtButtons;
	
	switch(eServiceSeverity)
	{
		case eServiceIgnorable:
			imtButtons = imtEnum(imtInfo);
			break;
		case eServiceNormal:
			imtButtons = imtEnum(imtError + imtAbortRetryIgnore + imtDefault3);
			break;
		case eServiceCritical:
			imtButtons = imtEnum(imtError + imtRetryCancel + imtDefault1);
			break;
		default:
			imtButtons = imtEnum(imtInfo);
			Assert(0);
	}
	if(Message(imtActionData, *pActionData) == imsCancel)
		return iesUserExit;

	// counter for automated retry.
	// This gives services that do not update their status with the SCM correctly
	// a chance to finish before reporting an error to the user.
	int cRetry = 0;
	while (fRetry)
	{
		if (cRetry)
		{
			// in an automatic retry.
			// wait a little before trying again.

			// note that WaitForService can pause for a long time as well in the service
			// requests.  This gives a pause between tries if the service is immediately
			// going to the failure state.

			// WaitForService gives the service time to do its thing, and eventually gives
			// up waiting.

			// Scenarios:
			//      Service immediately reports failure to be controlled:
			//          WaitForService immediately returns, and we retry here for 30 seconds.
			//      Service reports an unexpected state, and never enters the expected states.
			//          WaitForService times out after 30 seconds,
			//          We retry here 6 times, plus the 30 second total delay for all the retries
			//              A total time out of 3 1/2 minutes.
			WIN::Sleep(5 * 1000);
		}
		cRetry++;
		fRetry = fFalse;
		imsResponse = imsNone;

		g_MessageContext.DisableTimeout();
		switch(isoControl)
		{
			case isoStart:
				fRet = StartService(riParams, riUndoParams, fFalse);
				break;
			case isoStop:
				fRet = StopService(riParams, riUndoParams, fFalse, pActionData);
				break;
			case isoDelete:
				fRet = DeleteService(riParams, riUndoParams, fFalse, pActionData);
				break;
			default:
				Assert(0);
				// ERROR!
				break;
		}
		g_MessageContext.EnableTimeout();

		if (false == fRet)
		{

			// Set up any specific information for the error message here.
			// One possibility is querying the service status for the Win32 exit codes, and the
			// service specific error code if we want to provide additional information about
			// why the service control failed.

			// after performing automated retry, ask the user for input.
			// reset the automated retry count.
			if (cRetry > 6)
			{
				cRetry = 0;
				switch(isoControl)
				{
					case isoStart:
						imsResponse = DispatchError(imtButtons, Imsg(imsgOpStartServiceFailed), *strDisplayName, *strName);
						break;
					case isoStop:
						imsResponse = DispatchError(imtButtons, Imsg(imsgOpStopServiceFailed), *strDisplayName, *strName);
						break;
					case isoDelete:
						imsResponse = DispatchError(imtButtons, Imsg(imsgOpDeleteServiceFailed), *strDisplayName, *strName);
						break;
					default:
						//ERROR!
						Assert(0);
						break;

				}
			}
			// automatically retry the first couple of times.
			else imsResponse = imsRetry;
		}

		switch (imsResponse)
		{
			case imsNone:
			case imsIgnore:
				fRet = true;
				break;
			case imsRetry:
				fRetry = fTrue;
			default:
				break;
		}
	}

	return fRet ? iesSuccess : iesFailure;
}

iesEnum CMsiOpExecute::ixfServiceInstall(IMsiRecord& riParams)
{
	
	using namespace IxoServiceInstall;
	MsiString strName(riParams.GetMsiString(Name));
	MsiString strDisplayName(riParams.GetMsiString(DisplayName));
	iesEnum iesStatus = iesFailure;
	Bool fServiceKeyExists = fFalse;
	Bool fServiceExists = fFalse;

	PMsiRecord pError(0);

	ICHAR szRegData[255];
	wsprintf(szRegData, TEXT("System\\CurrentControlSet\\Services\\%s"), (const ICHAR*) strName);
	PMsiRegKey pRegKey = &m_riServices.GetRootKey(rrkLocalMachine); 
	pRegKey = &pRegKey->CreateChild(szRegData);

	pError = pRegKey->Exists(fServiceKeyExists);

	SC_HANDLE hSCManager = WIN::OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);

	if (!hSCManager)
	{
		imtEnum imtButtons = imtEnum(imtError + imtOk + imtDefault1);
		imsEnum imsResponse = DispatchError(imtButtons, Imsg(imsgOpInstallServiceFailed), *strDisplayName, *strName);

		return iesFailure;
	}

	DWORD dwErrorControl = riParams.GetInteger(ErrorControl);
	Bool fVital = (dwErrorControl & msidbServiceInstallErrorControlVital) ? fTrue : fFalse;
	if (fVital)
		dwErrorControl -= msidbServiceInstallErrorControlVital;

	Bool fRetry = fTrue;

#ifdef DEBUG
const ICHAR* szImagePath = riParams.GetString(ImagePath);
#endif

	const ICHAR* szStartName = riParams.GetString(StartName);

while(fRetry)
	{
		g_MessageContext.DisableTimeout();

		SC_HANDLE hService = GetServiceHandle(*MsiString(TEXT("")), *strName,
					(SERVICE_CHANGE_CONFIG | SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG)); 

		IMsiRecord* piRollbackParams = 0;
		bool fRollbackStatus = true;
		if (!hService)
		{
			fServiceExists = fFalse;
			// install a brand new service
			hService = WIN::CreateService(hSCManager, strName, strDisplayName, STANDARD_RIGHTS_REQUIRED|SERVICE_CHANGE_CONFIG,
				riParams.GetInteger(ServiceType), riParams.GetInteger(StartType), dwErrorControl,
				riParams.GetString(ImagePath), riParams.GetString(LoadOrderGroup), 0,
				riParams.GetString(Dependencies), szStartName, riParams.GetString(Password));

			if (hService)
			{
				// Need to now set the description

				SERVICE_DESCRIPTION serviceDescription;
				serviceDescription.lpDescription = const_cast<ICHAR*>(riParams.GetString(Description));

				BOOL fRet = ADVAPI32::ChangeServiceConfig2(hService,
																		 SERVICE_CONFIG_DESCRIPTION,
																		 &serviceDescription);
				if (!fRet && (ERROR_INVALID_FUNCTION != GetLastError()))
					DispatchError(imtInfo, Imsg(imsgServiceChangeDescriptionFailed), *strDisplayName, *strName);
				
			}
			// We can roll back later, since it's just a delete.
		}
		else
		{
			// We have to generate the rollback record now, so that we don't lose the current
			// information.

			fServiceExists = fTrue;
			if (hService)
			{
				piRollbackParams = &GetSharedRecord(IxoServiceInstall::Args);

				fRollbackStatus = RollbackServiceConfiguration(hService, *strName, *piRollbackParams);

				if (!WIN::ChangeServiceConfig(hService, riParams.GetInteger(ServiceType),
					riParams.GetInteger(StartType), dwErrorControl, riParams.GetString(ImagePath),
					riParams.GetString(LoadOrderGroup), 0, riParams.GetString(Dependencies),
					riParams.GetString(StartName), riParams.GetString(Password), strDisplayName))
				{
					WIN::CloseServiceHandle(hService);
					hService = 0;
				}
				else // first config succeeded
				{
					// Need to configure again to set the description

					MsiString strDescription = riParams.GetMsiString(Description);
					const ICHAR* szDescription = 0; // default to not touching the description
					if (strDescription.TextSize())
					{
						szDescription = (const ICHAR*)strDescription;
						if (*szDescription == 0)
							szDescription = TEXT(""); // we have an embedded null -- delete any existing description
					}

					SERVICE_DESCRIPTION serviceDescription;
					serviceDescription.lpDescription = const_cast<ICHAR*>(szDescription);

					BOOL fRet = ADVAPI32::ChangeServiceConfig2(hService,
																			 SERVICE_CONFIG_DESCRIPTION,
																			 &serviceDescription);
					if (!fRet && (ERROR_INVALID_FUNCTION != GetLastError()))
						DispatchError(imtInfo, Imsg(imsgServiceChangeDescriptionFailed), *strDisplayName, *strName);

				}
			}
		}
		g_MessageContext.EnableTimeout();

		if (hService)
		{
			iesStatus = iesSuccess;
			fRetry = fFalse;
			if (!fServiceExists)
			{
				// Rollback
				// Basically, just deletes one if we actually installed it.  We don't currently
				// handle "configuring" and then "re-configuring"
				using namespace IxoServiceControl;
				piRollbackParams = &GetSharedRecord(IxoServiceControl::Args);
				AssertNonZero(piRollbackParams->SetNull(MachineName));
				AssertNonZero(piRollbackParams->SetMsiString(IxoServiceControl::Name, *strName));
				AssertNonZero(piRollbackParams->SetInteger(Action, isoDelete));
				AssertNonZero(piRollbackParams->SetNull(Wait));
				AssertNonZero(piRollbackParams->SetNull(StartupArguments));

				if (!RollbackRecord(ixoServiceControl, *piRollbackParams))
					return iesFailure;
			}
			else
			{
				if (fRollbackStatus)
					if (!RollbackRecord(ixoServiceInstall, *piRollbackParams))
						return iesFailure;
			}

			WIN::CloseServiceHandle(hService);
		}
		else
		{
			imtEnum imtButtons;
			
			DWORD dwLastError = WIN::GetLastError();

			if (szStartName && (m_ixsState == ixsRollback))
			{
				// in Rollback, failure to re-install a service with a user name
				// means that we probably lost the password.  The author should
				// have written a custom action that fired before this,
				// and our subsequent entry here would have automatically succeeded.
				imtButtons = imtEnum(imtInfo);
			}
			else if (fVital)
				imtButtons = imtEnum(imtError + imtRetryCancel + imtDefault1);
			else
			{
				switch(dwErrorControl)
				{
					case SERVICE_ERROR_IGNORE:
						imtButtons = imtEnum(imtInfo);
						break;
					case SERVICE_ERROR_NORMAL:          
						imtButtons = imtEnum(imtError + imtAbortRetryIgnore + imtDefault3);
						break;
					case SERVICE_ERROR_SEVERE:
					case SERVICE_ERROR_CRITICAL:
						imtButtons = imtEnum(imtError + imtRetryCancel + imtDefault1);
						break;
					default:
						AssertSz(0, "Services:  Bad Error Control value");
						imtButtons = imtEnum(imtInfo);
						break;
				}
			}

			imsEnum imsResponse = DispatchError(imtButtons, Imsg(imsgOpInstallServiceFailed), *strDisplayName, *strName);

			if (imsResponse != imsRetry)
				fRetry = fFalse;

			if ((imsIgnore == imsResponse) || (imsNone == imsResponse))
				iesStatus = iesSuccess;
			else
				iesStatus = iesFailure;
		}
	}


	WIN::CloseServiceHandle(hSCManager);
	return iesStatus;
}

iesEnum CMsiOpExecute::ixfRegAllocateSpace(IMsiRecord& riParams)
{
	using namespace IxoRegAllocateSpace;

	int iIncrementKB = riParams.GetInteger(Space);

	IMsiRecord& riActionData = GetSharedRecord(1); // don't change ref count - shared record
	AssertNonZero(riActionData.SetInteger(1, iIncrementKB));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	if(!g_fWin9X && iIncrementKB != iMsiNullInteger) // only on WinNT
	{
		for(;;)
		{
			if(!IncreaseRegistryQuota(iIncrementKB))
			{
				switch(DispatchError(imtEnum(imtError + imtRetryCancel + imtDefault1), Imsg(imsgOutOfRegistrySpace), iIncrementKB))
				{
				case imsRetry:
					continue;
				default: // imsCancel, imsNone
					return iesFailure;
				}
			}
			break; // success
		}
	}
	return iesSuccess;
}

bool CMsiOpExecute::InitializeWindowsEnvironmentFiles(const IMsiString& ristrAutoExecPath, /*out*/ int &iFileAttributes)
{
	// make sure to protect the autoexec until the last possible moment.
	// If the system dies and we leave a corrupt autoexec, *very* bad things will
	// happen.

	// Logic to find the autoexec path is all located in shared.cpp.
	// There is also an environment variable WIN95_ENVIRONMENT_TEST that
	// allows this to be placed someplace else for testing or admin needs.

	// also, we should try to avoid copying the autoexec.bat over and over.  For the
	// moment, it's probably okay since they won't be making more than a few changes.
	// We'll save the autoexec.bat file off, and set the global state to make sure
	// we don't issue more than one rollback op, or make too many backups.

	PMsiRecord pErr(0);
	m_strEnvironmentFile95 = TEXT("AutoExec.bat");

	if ((pErr = m_riServices.CreatePath(ristrAutoExecPath.GetString(), *&m_pEnvironmentPath95)))
		return false;

	MsiString strAutoExec;
	pErr = m_pEnvironmentPath95->GetFullFilePath(m_strEnvironmentFile95, *&strAutoExec);
	Bool fAutoExecExists;
	Bool fWritable;

	if ((pErr = m_pEnvironmentPath95->FileExists(m_strEnvironmentFile95, fAutoExecExists)))
		return false;

	if (!fAutoExecExists)
	{
		HANDLE hAutoexec = INVALID_HANDLE_VALUE;
		if (INVALID_HANDLE_VALUE == (hAutoexec = WIN::CreateFile(strAutoExec, GENERIC_WRITE,
			0,
			NULL, CREATE_NEW, FILE_ATTRIBUTE_ARCHIVE, NULL)))
			return false;

		WIN::CloseHandle(hAutoexec);
		if ((pErr = m_pEnvironmentPath95->FileExists(m_strEnvironmentFile95, fAutoExecExists)))
			return false;
	}
	AssertSz(fAutoExecExists, TEXT("AUTOEXEC.BAT should exist at this point!"));

	if ((pErr = m_pEnvironmentPath95->FileWritable(m_strEnvironmentFile95, fWritable)))
		return false;

	if (fAutoExecExists)
	{
		if ( RollbackEnabled() )
		{
			// backup file with its original file attributes intact.

			// this function might actually put up another error of their own, in which case we may
			// get two errors
			if (iesSuccess != BackupFile(*m_pEnvironmentPath95, *m_strEnvironmentFile95, fFalse, fFalse, iehShowNonIgnorableError))
				return false;
		}

		pErr = m_pEnvironmentPath95->GetAllFileAttributes(m_strEnvironmentFile95, iFileAttributes);
	}

	if (!(fAutoExecExists && fWritable))
	{
		// try making the autoexec file writable.
		const iUnwritableFlags = FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM;
		if (!pErr && (iFileAttributes & iUnwritableFlags))
		{
			int iNewFileAttributes = iFileAttributes &~ iUnwritableFlags;
			pErr = m_pEnvironmentPath95->SetAllFileAttributes(m_strEnvironmentFile95, iNewFileAttributes);
			if (!pErr)
			{
				pErr = m_pEnvironmentPath95->FileWritable(m_strEnvironmentFile95, fWritable);
			}
		}

		if (pErr || !fWritable)
		{
			Message(imtInfo, *PMsiRecord(PostError(Imsg(idbgFileNotWritable), *strAutoExec)));
			return false;
		}
	}

	m_pEnvironmentWorkingPath95 = m_pEnvironmentPath95;
	pErr = m_pEnvironmentWorkingPath95->TempFileName(TEXT("Auto"), NULL, fTrue, *&m_strEnvironmentWorkingFile95, 0);
	// !! this file will get cleaned up automatically by runscript completing (CMsiExecute::ClearExecutorData).  However, should we put it in the
	// rollback script as well, in case we crash?

	if (pErr)
		return false;

	if (fAutoExecExists)
	{
		// create a working copy of the file

		// this function might actually put up another error of their own, in which case we may
		// get two errors
		if (iesSuccess != CopyOrMoveFile(*m_pEnvironmentPath95, *m_pEnvironmentWorkingPath95,
						*m_strEnvironmentFile95, *m_strEnvironmentWorkingFile95, fFalse, fFalse, fFalse, iehShowNonIgnorableError))
			return false;
	}

	return true;
}

const ICHAR* SkipWhiteSpace(const ICHAR* const szBuf)
{
	const ICHAR* pchCurrent = szBuf;
	if (!pchCurrent)
		return NULL;

	while((NULL != *pchCurrent) && (' ' == *pchCurrent) || ('\t' == *pchCurrent))
				pchCurrent = ICharNext(pchCurrent);

	return pchCurrent;
}

bool CMsiOpExecute::UpdateWindowsEnvironmentStrings(IMsiRecord& riParams)
{
	// the 9X and NT versions are wildly different.
	// 9X must update the autoexec.bat
	PMsiRecord pErr(0);

	using namespace IxoUpdateEnvironmentStrings;
	MsiString strName(riParams.GetMsiString(Name));
	MsiString strValue(riParams.GetMsiString(Value));
	iueEnum iueAction = iueEnum(riParams.GetInteger(Action));

	// Note that we don't support multi-character delimiters.
	ICHAR chDelimiter = TEXT('\0');
	if (!riParams.IsNull(Delimiter))
		chDelimiter = *riParams.GetString(Delimiter);


	static int iFileAttributes = 0;
	if (0 == m_strEnvironmentWorkingFile95.TextSize())
	{
		if (!InitializeWindowsEnvironmentFiles(*MsiString(riParams.GetMsiString(AutoExecPath)), iFileAttributes))
		{
			DEBUGMSGV(TEXT("Cannot initialize the autoexec.bat and rollback files."));
			return false;
		}
	}

	CFileRead InFile(CP_ACP);
	if (!InFile.Open(*m_pEnvironmentPath95, m_strEnvironmentFile95))
	{
		MsiString strFile;
		AssertRecord(m_pEnvironmentPath95->GetFullFilePath(m_strEnvironmentFile95, *&strFile));
		Message(imtInfo, *PMsiRecord(PostError(Imsg(idbgErrorOpeningFileForRead), WIN::GetLastError(), strFile)));
		return false;
	}

	// open the working file.  It may not exist, in which case we can just simply create it on the fly.
	MsiString strWorkingFile;
	AssertRecord(m_pEnvironmentWorkingPath95->GetFullFilePath(m_strEnvironmentWorkingFile95, *&strWorkingFile));

	CFileWrite OutFile(CP_ACP);
	if (!OutFile.Open(*m_pEnvironmentWorkingPath95, m_strEnvironmentWorkingFile95))
	{
		Message(imtInfo, *PMsiRecord(PostError(Imsg(idbgErrorOpeningFileForWrite), WIN::GetLastError(), strWorkingFile)));
		return false;
	}


	// read the named value, copying the stuff we don't want over to the working file.
	MsiString strCurrentValue;
	MsiString strInFileLine;
	ICHAR chResult;

	const ICHAR chQuietPrefix = TEXT('@');
	const ICHAR *const szSetPrefix = TEXT("SET");

	MsiString strSetName;
	

	const int cchSetPrefix = IStrLen(szSetPrefix);

	// look for the line referring to the variable we want to change.
	// write everything else to the output file.

		// Format: [set] name = value
		//     note:  whitespace could be anywhere for robustness.

		// acceptable forms:
		//   path =foo
		//   path=foo
		//   set path =bar
		//   set path=bar
		//  note: a value name could contain spaces, but this is simply covered
		//        when comparing the value name.

		// unacceptable:
		//   comment comment comment
		//   set = foo
		//   path blah = foo

	bool fNameFound = false;
	bool fValid = true;

	while ((chResult = InFile.ReadString(*&strInFileLine)))
	{
		// fNameFound true when we have a name/value pair recognized to modify
		fNameFound = false;

		// fValid set to false if the line is malformed prior to the name=value pair
		// for example, when we skip over the "set" part, we need a space after it
		// valid:    set name=value
		// invalid:  setname=value
		fValid = true;


		const ICHAR* pchInString = strInFileLine;

		pchInString = SkipWhiteSpace(pchInString);
		
		// @ at the beginning of the line indicates that echo should
		// be off for the duration of the command.
		if (chQuietPrefix == *pchInString)
		{
			pchInString = CharNext(pchInString);
			pchInString = SkipWhiteSpace(pchInString);
		}

		// skip the set, and any blanks after it.
		if (MsiString(pchInString).Compare(iscStartI, szSetPrefix))
		{
				pchInString += cchSetPrefix;        

				const ICHAR* pchPreviousSpot = pchInString;
				pchInString = SkipWhiteSpace(pchInString);

				// require white space between the set and the name.
				// expects set <name>.  Avoids set<name>
				if (pchPreviousSpot == pchInString)
					fValid = false;
		}


		if (fValid && MsiString(pchInString).Compare(iscStartI, strName))
		{
			// now at the name, or it isn't what we're looking for.
			pchInString += strName.TextSize();
			pchInString = SkipWhiteSpace(pchInString);

			// now find the equal as the very next thing.
			if (TEXT('=') == *pchInString)
			{
				strSetName = strInFileLine.Extract(iseIncluding, TEXT('='));
				fNameFound = true;
			}
		}

		if (!fValid || !fNameFound)
		{
			if (!OutFile.WriteMsiString(*strInFileLine, fTrue))
			{
				Message(imtInfo, *PMsiRecord(PostError(Imsg(imsgErrorWritingToFile), *strWorkingFile)));
				return false;
			}
		}
		else
			break;
	}


	// if chResult, then we've found a line to modify.  Otherwise, we're at the end of the file.
	// strSetName contains the front half of the line, up to the value.
	if (chResult)
	{
		// munge it as necessary

		strCurrentValue = strInFileLine.Extract(iseAfter, TEXT('='));
		MsiString strResult;
		if (RewriteEnvironmentString(iueAction, chDelimiter, *strCurrentValue, *strValue, *&strResult))
		{   
			// write the named value back to the working file.
			if (strResult.TextSize())
			{
				strSetName+=strResult;
				if (!OutFile.WriteMsiString(*strSetName, fTrue))
				{
					Message(imtInfo, *PMsiRecord(PostError(Imsg(imsgErrorWritingToFile), *strWorkingFile)));
					return false;
				}
			}
			// else drop the line from the file.
		}

		// finish copying the rest of the file
		while (InFile.ReadString(*&strInFileLine))
		{
			if (!OutFile.WriteMsiString(*strInFileLine, fTrue))
			{
				Message(imtInfo, *PMsiRecord(PostError(Imsg(imsgErrorWritingToFile), *strWorkingFile)));
				return false;
			}
		}
	}
	else
	{
		// If the value wasn't found, add it as necessary.
		if (!(iueRemove & iueAction))
		{
			// there was no entry in the file, so
			// we have to create the
			//      SET name=
			strSetName = szSetPrefix;
			strSetName += MsiChar(' ');
			strSetName += strName;
			strSetName += MsiChar('=');

			if (iueAction & (iuePrepend | iueAppend))
			{
				// We expected to append or prepend something to the variable, but didn't find
				// one that we recognize.  Just in case, though, we'll create the new line to
				// reference any current value that might have snuck through.  Overwriting a valid
				// variable, especially the path, could leave the system unbootable.
				Assert(chDelimiter);
				
				if (iuePrepend & iueAction)
				{
					strSetName+=strValue;
					strSetName+= MsiChar(chDelimiter);
				}   

				strSetName += TEXT("%");
				strSetName += strName;
				strSetName += TEXT("%");

				if (iueAppend & iueAction)
				{
					strSetName += MsiChar(chDelimiter);
					strSetName += strValue;
				}
			}
			else
			{
				strSetName+=strValue;
			}

			if (!OutFile.WriteMsiString(*strSetName, fTrue))
			{
				Message(imtInfo, *PMsiRecord(PostError(Imsg(imsgErrorWritingToFile), *strWorkingFile)));
				return false;
			}
		}
	}

	if (!(InFile.Close() && OutFile.Close()))
		return false;

	// copy the working file over the current autoexec.
	if (iesSuccess != CopyOrMoveFile(*m_pEnvironmentWorkingPath95, *m_pEnvironmentPath95,
												*m_strEnvironmentWorkingFile95, *m_strEnvironmentFile95,
												fFalse,fFalse,fFalse,iehShowNonIgnorableError))
	{
		DEBUGMSGV("Cannot replace autoexec.bat file with working copy.");
		return false;
	}

	if (iFileAttributes)
	{
		// restore original file attributes to the autoexec.bat
		pErr = m_pEnvironmentPath95->SetAllFileAttributes(m_strEnvironmentFile95, iFileAttributes);
		if (pErr)
			return false;
	}
	return true;
}

bool CMsiOpExecute::UpdateRegistryEnvironmentStrings(IMsiRecord& riParams)
{
	// the 95 and NT versions are wildly different in the storage mechanism.
	// NT should store the values in the registry.
	
	// SYSTEM:   HKLM\System\CurrentControlSet\Control\Session Manager\Environment
	// USER:    HKCU\Environment

	iesEnum iesRet = iesSuccess;
	PMsiRecord pErr(0);

	using namespace IxoUpdateEnvironmentStrings;
	

	MsiString strName(riParams.GetMsiString(Name));
	MsiString strValue(riParams.GetMsiString(Value));
	iueEnum iueAction = iueEnum(riParams.GetInteger(Action));

	// Note that we don't support multi-character delimiters.
	ICHAR chDelimiter = TEXT('\0');
	if (!riParams.IsNull(Delimiter))
		chDelimiter = *riParams.GetString(Delimiter);

	rrkEnum rrkRoot;
	MsiString strSubKey;

	PMsiRegKey pEnvironmentKey(0);
	if (iueMachine & iueAction)
	{
		rrkRoot = rrkLocalMachine;
		strSubKey = szMachineEnvironmentSubKey;
	}
	else
	{
		rrkRoot = rrkCurrentUser;
		strSubKey = szUserEnvironmentSubKey;
	}

	PMsiRegKey pHU = &m_riServices.GetRootKey(rrkRoot);
	if (!pHU)
		return false;

	pEnvironmentKey = &pHU->CreateChild(strSubKey);
	if (!pEnvironmentKey)
	{
		Message(imtInfo, *PMsiRecord(PostError(Imsg(imsgOpenKeyFailed), *strSubKey, WIN::GetLastError())));
		return false;
	}

	Assert(pEnvironmentKey);

	Bool fKeyExists = fFalse;
	Bool fValueExists = fFalse;

	MsiString strCurrentValue;
	
	// rollback the entire registry value, rather than trying to rebuild it with
	// the update environment.

	pErr = pEnvironmentKey->GetValue(strName, *&strCurrentValue);
	if (pErr)
	{
		Message(imtInfo, *pErr);
		return false;
	}

	MsiString strRawCurrentValue = strCurrentValue;
	
	if (strCurrentValue.Compare(iscStart, TEXT("#%")))
		strCurrentValue.Remove(iseFirst, 2);

	// might contain the value.  rewrite as necessary, and then shove it in.
	MsiString strResult;
	if (RewriteEnvironmentString(iueAction, chDelimiter, *strCurrentValue, *strValue, *&strResult))
	{   
		// new value may end up being blank.  We treat that as a remove.
		if (!strResult.Compare(iscExact, strCurrentValue))
		{
			if (strResult.TextSize())
			{
				MsiString strNewResult;
				if (strResult.Compare(iscWithin, TEXT("%")))
					strNewResult = *TEXT("#%");

				strNewResult += strResult;

				pErr = pEnvironmentKey->SetValue(strName, *strNewResult);
			}
			else
				pErr = pEnvironmentKey->RemoveValue(strName, NULL);
	
			if (pErr)
				return false;

			// Rollback
			// For efficiency, we should sort between user and machine values, and only issue
			// the open key once.  However, this is one of those really rare actions, and
			// better to be done with it.
			IMsiRecord* piParams = &GetSharedRecord(IxoRegOpenKey::Args);
			AssertNonZero(piParams->SetInteger(IxoRegOpenKey::Root, rrkRoot));
			AssertNonZero(piParams->SetMsiString(IxoRegOpenKey::Key, *strSubKey));
			if (!RollbackRecord(ixoRegOpenKey,*piParams))
				return false;
				
			Assert(IxoRegRemoveValue::Args == IxoRegAddValue::Args);
			Assert(IxoRegRemoveValue::Name == IxoRegAddValue::Name);
			Assert(IxoRegRemoveValue::Value == IxoRegAddValue::Value);

			piParams = &GetSharedRecord(IxoRegRemoveValue::Args);
			AssertNonZero(piParams->SetMsiString(IxoRegRemoveValue::Name, *strName));

			if (0 == strCurrentValue.TextSize())
			{
				if (!RollbackRecord(ixoRegRemoveValue, *piParams))
					return false;
			}
			else
			{
				AssertNonZero(piParams->SetMsiString(IxoRegAddValue::Value, *strRawCurrentValue));
				if (!RollbackRecord(ixoRegAddValue, *piParams))
					return false;
			}
		}
		return true;
	}
	else
		return false;   
}

bool CMsiOpExecute::RewriteEnvironmentString(const iueEnum iueAction, const ICHAR chDelimiter,
																const IMsiString& ristrCurrent, const IMsiString& ristrNew,
																const IMsiString*& rpiReturn)
{
	// this builds the new environment string after doing substring matching and replacement or removal.
	// If we do nothing, return out the old value, as it will be used absolutely.

	// All of these cases are no-ops except for remove
	// ;value<EOS>
	// <EOS>value;
	// ;value;
	// If there's a false hit, then we get to add it as needed.
	ristrCurrent.AddRef();
	ristrNew.AddRef();
	MsiString strCurrent(ristrCurrent);
	MsiString strNew(ristrNew);
	
	MsiString strReturn(strCurrent);
	Bool fConcatenation = ((iueAction & iueAppend) + (iueAction & iuePrepend)) ? fTrue : fFalse;
#ifdef DEBUG
	if (fConcatenation)
		Assert(chDelimiter);
	else
		Assert(TEXT('\0') == chDelimiter);
#endif

	// cases:
	//      no new value
	//          no concatenation
	//              Remove -- remove always
	//              Set -- effectively a remove
	//              SetIfAbsent -- no op
	//          concatenation
	//              Remove -- no op
	//              Set -- no op
	//              SetIfAbsent -- no op
			
	//      no concatenation
	//       Set --  absolute set
	//       SetIfAbsent -- set if the name doesn't exist.
	//          Remove -- get rid of it if the strings are the same


	//      concatenate a new string onto an existing value
	//          new value isn't found in string,
	//              Set -- insert as necessary, beggining or end
	//              SetIfAbsent -- same as Set
	//              Remove -- no op
	//          Value *is* found in string
	//              make sure it isn't a false hit on a substring.  If it is, go back to new value that isn't
	//          found in string.
	//                  Exact Match:
	//                      Remove --  remove entire string
	//                      Set -- no op
	//                   SetIfAbsent -- no op
	//                  Substring:
	//                      Remove -- remove piece
	//                      Set -- no op
	//                      SetIfAbsent -- no op

	
	if (0 == strNew.TextSize())
	{
		if ((iueRemove & iueAction) || (iueSet & iueAction))
			strReturn = MsiString();
	}
	else if (!fConcatenation)
	{
		// no concatenation
		if (iueSet & iueAction)
		{
			strReturn = strNew;
		}
		else if (iueSetIfAbsent & iueAction)
		{
			if (0 == strCurrent.TextSize())
				// the the value is absent
				strReturn = strNew;
		}
		else if (iueRemove & iueAction)
		{
			if (strCurrent.Compare(iscExactI, strNew))
				strReturn = MsiString();
		}
	}
	else
	{
		// concatenate a non-null value
		if (!strCurrent.Compare(iscWithinI, strNew))
		{
NewValue:
			// doesn't contain the substring, and concatenate a non-null new value
			// add the string as necessary
			if ((iueSet & iueAction) || (iueSetIfAbsent & iueAction))
			{
				if (iueAppend & iueAction)
				{
					
					if (strCurrent.TextSize())
					{
						const ICHAR* pchEnd = ((const ICHAR*)strCurrent) + strCurrent.TextSize();
						pchEnd = CharPrev((const ICHAR*)strCurrent, pchEnd);
						if (chDelimiter != *pchEnd)
							strReturn += MsiChar(chDelimiter);
					}
					strReturn += strNew;
				}
				else if (iuePrepend & iueAction)
				{
					if (strCurrent.TextSize())
						if (chDelimiter != *(const ICHAR*)strCurrent)
							strReturn = MsiString(MsiChar(chDelimiter)) + strCurrent;
					strReturn = strNew + strReturn;
				}
			}
		}
		else
		{
			// the value is probably there.
			// beware of false hits without delimiters
			Assert(chDelimiter);
			if (strCurrent.Compare(iscExactI, strNew))
			{
				if ((iueSet & iueAction) || (iueSetIfAbsent & iueAction))
				{
					// no op
				}
				else if (iueRemove & iueAction)
				{
					strReturn = MsiString();
				}
			}
			else
			{
				// might contain the value.  rewrite as necessary, and then shove it in.
					// new value may end up being blank.
				// There might not have been an exact match due to a bogus delimiter that we cleaned up.
				//  Watch out for NAME=blahblahVALUEblah;blahblah
				//  NAME=value;
				//  NAME=;value
				//  NAME=blah;value;blah
		
				MsiString strStart = strNew + MsiString(MsiChar(chDelimiter));
				MsiString strEnd = MsiString(MsiChar(chDelimiter)) + strNew;
				MsiString strMid = strEnd + MsiString(MsiChar(chDelimiter));
				if (strCurrent.Compare(iscStartI, strStart))
				{
					// start
					if (iueRemove & iueAction)
						AssertNonZero(strReturn.Remove(iseFirst, strStart.CharacterCount()));
				}
				else if (strCurrent.Compare(iscEndI, strEnd))
				{
					if (iueRemove & iueAction)
						AssertNonZero(strReturn.Remove(iseLast, strEnd.CharacterCount()));
					// at the end
				}
				else if (strCurrent.Compare(iscWithinI, strMid))
				{
					// in the middle
					//!! Compare returns a location of the match, we should just use that instead.
					if (iueRemove & iueAction)
					{
						CTempBuffer<ICHAR, MAX_PATH> rgchReturn;
						MsiString strWithin;
						if (strCurrent.TextSize() > MAX_PATH)
							rgchReturn.SetSize(strCurrent.TextSize());

						ICHAR* pchCurrent = (ICHAR*) (const ICHAR*) strCurrent;
						while(NULL != *pchCurrent)
						{
							if (*pchCurrent != chDelimiter)
								pchCurrent = INextChar(pchCurrent);
							else
							{
								strWithin = pchCurrent;
								if (!strWithin.Compare(iscStartI, strMid))
									pchCurrent = INextChar(pchCurrent);
								else
								{
									strEnd = strWithin.Extract(iseLast, strWithin.TextSize() - strMid.TextSize() + 1 /*chDelimiter*/);
									strStart = strCurrent.Extract(iseFirst, strCurrent.TextSize() - strWithin.TextSize());
									strReturn = strStart + strEnd;
									break;
								}
							}
						}           
					}
				}
				else
					goto NewValue;
			}
		}
	}
	strReturn.ReturnArg(rpiReturn);
	return true;
}

iesEnum CMsiOpExecute::ixfUpdateEnvironmentStrings(IMsiRecord &riParams)
{
	bool fReturn;

	using namespace IxoUpdateEnvironmentStrings;
	MsiString strName(riParams.GetMsiString(Name));
	MsiString strValue(riParams.GetMsiString(Value));
	iueEnum iueAction = iueEnum(riParams.GetInteger(Action));

	IMsiRecord& riActionData = GetSharedRecord(3); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strName));
	AssertNonZero(riActionData.SetMsiString(2, *strValue));
	AssertNonZero(riActionData.SetInteger(3, iueAction));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	m_fEnvironmentRefresh = true;
	for(;;)
	{
		if (g_fWin9X)
			fReturn = UpdateWindowsEnvironmentStrings(riParams);
		else
			fReturn = UpdateRegistryEnvironmentStrings(riParams);

		// This may give a second error describing the overall problem of not being able
		// to update the environment variables.  Within the previous functions (Update*EnvironmentStrings,) only
		// specific remediable problems will get errors.
		if (!fReturn)
		{
			using namespace IxoUpdateEnvironmentStrings;
			MsiString strName(riParams.GetMsiString(Name));

			switch(DispatchError(imtEnum(imtError + imtAbortRetryIgnore + imtDefault3), Imsg(imsgUpdateEnvironment), *strName))
			{
				case imsRetry:
					continue;
				case imsAbort:
					return iesUserExit;
				case imsNone:
				case imsIgnore:
					return iesSuccess;
				default:
					Assert(0);
			}
		}
		else return iesSuccess;
	}
}



/*---------------------------------------------------------------------------
ixfAppIdInfoRegister: register AppId registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegAppIdInfoRegister64(IMsiRecord& riParams)
{
	return ProcessAppIdInfo(riParams, m_fReverseADVTScript, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegAppIdInfoRegister(IMsiRecord& riParams)
{
	return ProcessAppIdInfo(riParams, m_fReverseADVTScript, ibt32bit);
}

/*---------------------------------------------------------------------------
ixfAppIdInfoUnregister: unregister AppId registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ixfRegAppIdInfoUnregister64(IMsiRecord& riParams)
{
	return ProcessAppIdInfo(riParams, fTrue, ibt64bit);
}

iesEnum CMsiOpExecute::ixfRegAppIdInfoUnregister(IMsiRecord& riParams)
{
	return ProcessAppIdInfo(riParams, fTrue, ibt32bit);
}

/*---------------------------------------------------------------------------
ProcessAppIdInfo: common routine to process AppId registry info
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::ProcessAppIdInfo(IMsiRecord& riParams, Bool fRemove, const ibtBinaryType iType)
{
	// No action data, since this is really firing off the class registration...
	using namespace IxoRegAppIdInfoRegister;
	// Record description
	// 1 = AppId
	// 2 = CLSID
	// 3 = RemoteServerName
	// 4 = LocalService
	// 5 = ServiceParameters
	// 6 = DllSurrogate
	// 7 = ActivateAtStorage
	// 8 = RunAsInteractiveUser
	riParams; fRemove;

	if(!(m_fFlags & SCRIPTFLAGS_REGDATA_CLASSINFO)) // do we write/delete the registry
		return iesSuccess;

	iesEnum iesR = EnsureClassesRootKeyRW(); // open HKCR for read/ write
	if(iesR != iesSuccess && iesR != iesNoAction)
		return iesR;

	MsiString strAppId = riParams.GetMsiString(AppId);
	MsiString strClassId = riParams.GetMsiString(ClsId);
	MsiString strRemoteServerName = riParams.GetMsiString(RemoteServerName);
	MsiString strLocalService = riParams.GetMsiString(LocalService);
	MsiString strDllSurrogate = riParams.GetMsiString(DllSurrogate);
	MsiString strServiceParameters = riParams.GetMsiString(ServiceParameters);
	const int iActivateAtStorage = riParams.GetInteger(ActivateAtStorage);
	const int iRunAsInteractiveUser = riParams.GetInteger(RunAsInteractiveUser);
	
	const ICHAR* rgszRegData[] = {
		TEXT("AppID\\%s"), strAppId,0,0,
		g_szDefaultValue,               0,                              g_szTypeString,// force the key creation
		TEXT("DllSurrogate"),       strDllSurrogate,            g_szTypeString,
		TEXT("LocalService"),       strLocalService,            g_szTypeString,
		TEXT("ServiceParameters"),  strServiceParameters,   g_szTypeString,
		TEXT("RemoteServerName"),   strRemoteServerName,        g_szTypeString,
		TEXT("ActivateAtStorage"),  ((iMsiStringBadInteger == iActivateAtStorage) || (0 == iActivateAtStorage)) ? TEXT("") : TEXT("Y"), g_szTypeString,
		TEXT("RunAs"),  ((iMsiStringBadInteger == iRunAsInteractiveUser) || (0 == iRunAsInteractiveUser)) ? TEXT("") : TEXT("Interactive User"), g_szTypeString,
		0,
		0,
	};
	
	return ProcessRegInfo(rgszRegData, iType == ibt64bit ? m_hOLEKey64 : m_hOLEKey, fRemove, 0, 0, iType);
}

int GetScriptMajorVersionFromHeaderRecord(IMsiRecord* piRecord)
{
	return piRecord->GetInteger(IxoHeader::ScriptMajorVersion);
}

const IMsiString& CMsiOpExecute::GetUserProfileEnvPath(const IMsiString& ristrPath, bool& fExpand)
{
	
	ristrPath.AddRef();
	MsiString strRet = ristrPath;
	fExpand = false;


	// there is no %USERPROFILE% on 9X
	if (!g_fWin9X && !(m_fFlags & SCRIPTFLAGS_MACHINEASSIGN))
	{
		PMsiRecord piError(0);
		if (!m_strUserAppData.TextSize())
			piError = GetShellFolder(CSIDL_APPDATA, *&m_strUserAppData);

		if(!m_strUserProfile.TextSize())
			m_strUserProfile = m_riServices.GetUserProfilePath();

		// search from the most specific (longest) match to the least.
		// FUTURE:  If we add more paths, consider initializing an array of the paths to search.
		if (!piError && (g_iMajorVersion >= 5 && g_iWindowsBuild >= 2042) && ristrPath.Compare(iscStartI, m_strUserAppData)) // NT5 ONLY
		{
			// APPDATA implemented in NT5 build 2042
			fExpand = true;
			strRet = TEXT("%APPDATA%\\");
			strRet += MsiString(ristrPath.Extract(iseLast, ristrPath.CharacterCount() - m_strUserAppData.CharacterCount()));
		}
		else if (ristrPath.Compare(iscStartI, m_strUserProfile))
		{
			// replace the string with a %USERPROFILE%
			fExpand = true;
			strRet = TEXT("%USERPROFILE%\\");
			strRet += MsiString(ristrPath.Extract(iseLast, ristrPath.CharacterCount() - m_strUserProfile.CharacterCount()));
		}
	}

	return strRet.Return();
}

iesEnum CMsiOpExecute::ixfInstallSFPCatalogFile(IMsiRecord& riParams)
{
	// This Windows-Millennium only code.
	// See spec at http://dartools/dardev/specs/SFP-Millennium.htm

	Assert(g_fWin9X);

	using namespace IxoInstallSFPCatalogFile;

	MsiString strName(riParams.GetMsiString(Name));
	PMsiData pCatalogData(riParams.GetMsiData(Catalog));
	MsiString strDependency(riParams.GetMsiString(Dependency));

	PMsiRecord pErr(0);
	iesEnum iesRet = iesSuccess;

	IMsiRecord& riActionData = GetSharedRecord(2); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strName));
	AssertNonZero(riActionData.SetMsiString(2, *strDependency));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;


	// We use the cache path so that we can leave an explicitly named file
	// we can't rename the catalog, so it has to go in place.  
	PMsiPath pCachePath(0);
	pErr = GetCachePath(*&pCachePath);
	
	MsiString strCachePath(pCachePath->GetPath());
	if ((pErr = pCachePath->EnsureExists(0)))
	{
		Message(imtError, *pErr);
		return iesFailure;
	}
	CDeleteEmptyDirectoryOnClose cDeleteTempDir(*strCachePath);

	MsiString strCacheFile;
	pErr = pCachePath->GetFullFilePath(strName, *&strCacheFile);
	CDeleteFileOnClose cTempFile(*strCacheFile);

#ifdef DEBUG
	Bool fCacheFileExists = fFalse;
	Bool fCachePathExists = fFalse;

	pErr = pCachePath->Exists(fCachePathExists);
	Assert(fCachePathExists);

	pErr = pCachePath->FileExists(strName, fCacheFileExists);
	Assert(!fCacheFileExists);
#endif
	
	// create a temporary file to hold the old catalog, and to
	// hold a temporary copy of the new catalog for submission to the system.

	do
	{
		pErr = pCachePath->EnsureOverwrite(strName, 0);
		if (pErr)
		{
			// can't overwrite our own file.  Something seriously wrong.
			switch(Message(imtEnum(imtError+imtRetryCancel+imtDefault1), *pErr))
			{
				case imsRetry:  continue;
				default:        return iesFailure; // fail in quiet install.
			}
		}
	} while(pErr);
	
	// get information to set rollback info.
	PMsiRecord pRollbackParams = &m_riServices.CreateRecord(Args);
	AssertNonZero(pRollbackParams->SetMsiString(Name, *strName));
	AssertNonZero(pRollbackParams->SetMsiString(Dependency, *strDependency));

	DWORD dwResult = SFC::SfpDuplicateCatalog(strName, strCachePath);
	if (ERROR_SUCCESS == dwResult)
	{
		// stream the temp file into the rollback opcode,
		// with the Dependency from this new one, since there is no
		// other way to query the Dependency.

		DEBUGMSGV("Updating existing catalog.\n");
		PMsiStream pCatalogStream(0);
		do
		{
			pErr = m_riServices.CreateFileStream(strCacheFile, fFalse, *&pCatalogStream);
			if (!pErr)
			{
				AssertNonZero(pRollbackParams->SetMsiData(Catalog, pCatalogStream));

				// the file will now be persisted into the rollback script
				if (!CMsiOpExecute::RollbackRecord(ixoInstallSFPCatalogFile, *pRollbackParams))
					return iesFailure;

				// release the hold on the file so that we can re-use it.
				pRollbackParams->SetMsiData(Catalog, PMsiData(0));
			}
			else
			{
				switch(Message(imtEnum(imtError+imtRetryCancel+imtDefault1), *pErr))
				{
					case imsRetry:  continue;
					default:        return iesFailure;
						// fail in quiet install
						// The file copy probably wouldn't work, and yet the system wouldn't tell us
						// about it.  So this is really our only chance to know the files won't update.
				}
			}
		} while (pErr);
	}
	else if (ERROR_FILE_NOT_FOUND == dwResult)
	{
		// no catalog by this name exists
		if (pCatalogData)
		{
			// rollback is to delete
			DEBUGMSGV("Installing brand new catalog.\n");
			AssertNonZero(pRollbackParams->SetMsiData(Catalog, PMsiData(0)));
			if (!CMsiOpExecute::RollbackRecord(ixoInstallSFPCatalogFile, *pRollbackParams))
				return iesFailure;
		}
		// else do nothing - nothing was there, and we're not installing anything.
	}
	else
	{
		// something went wrong duplicating the file from the catalog.
		DispatchError(imtError, Imsg(idbgErrorSfpDuplicateCatalog), (const ICHAR*)strName, dwResult);
		return iesFailure;
	}

	iesEnum iesWrite = iesFailure;
	if (pCatalogData)
	{
		// must stream catalog into temporary file with correct file name, then
		// pass the entire path to the file into the API
		do
		{
			iesWrite = CreateFileFromData(*pCachePath, *strName, pCatalogData, NULL /*FUTURE:  Secure this*/);
			if (iesSuccess == iesWrite)
			{
				if (ERROR_SUCCESS != (dwResult = SFC::SfpInstallCatalog(strCacheFile, strDependency)))
				{
					DispatchError(imtError, Imsg(idbgErrorSfpInstallCatalog), (const ICHAR*)strName, dwResult);
					return iesFailure;
				}
			}
			else
			{
				// couldn't write from the memory stream to the file.
				switch(DispatchError(imtEnum(imtError+imtRetryCancel+imtDefault1), Imsg(imsgErrorWritingToFile), *strCacheFile))
				{
					case imsRetry:  continue;
					default:        return iesFailure; // fail in quiet install.
				}
			}
		} while (iesSuccess != iesWrite);
	}
	else
	{
		// nuke the old catalog.
		if (ERROR_SUCCESS != (dwResult = SFC::SfpDeleteCatalog(strName)))
		{
			DispatchError(imtInfo, Imsg(idbgErrorSfpDeleteCatalog), (const ICHAR*)strName, dwResult);
		}
	}

	return iesRet;
}

iesEnum CMsiOpExecute::ResolveSourcePath(IMsiRecord& riParams, IMsiPath*& rpiSourcePath, bool& fCabinetCopy)
{
	using namespace IxoFileCopyCore;

	iesEnum iesRet = iesSuccess;
	PMsiRecord pRecErr(0);

	rpiSourcePath = 0;
	MsiString strSourcePath = riParams.GetMsiString(SourceName);
	MsiString strSourceName;

	// check if files are full or relative paths
	if(ENG::PathType(strSourcePath) == iptFull)
	{
		iesRet = CreateFilePath(strSourcePath,rpiSourcePath,*&strSourceName);
		if (iesRet != iesSuccess)
			return iesRet;
	}
	else
	{
		int iFileAttributes = riParams.GetInteger(Attributes);
		int iSourceType = 0;
		
		// PatchAdded files are always compressed and come from a secondary source that has already been resolved
		if(iFileAttributes & msidbFileAttributesPatchAdded)
		{
			rpiSourcePath = 0;
			iSourceType = msidbSumInfoSourceTypeCompressed;
		}
		else
		{
			iesRet = GetCurrentSourcePathAndType(rpiSourcePath, iSourceType); // may trigger source resolution
			if(iesRet != iesSuccess)
				return iesRet;
		}

		// file compression may have been determined on script generation side
		// if it has, respect it.  if it hasn't, determine compression using file attributes
		// and source type
		if(riParams.IsNull(IsCompressed))
		{
			fCabinetCopy = FFileIsCompressed(iSourceType, iFileAttributes);
		}
		else
		{
			fCabinetCopy = riParams.GetInteger(IsCompressed) == 1 ? true : false;
		}
		
		if(fCabinetCopy)
		{
			// set SourceName field in params to cabinet filekey
			strSourceName = riParams.GetMsiString(SourceCabKey);

			DEBUGMSG1(TEXT("Source for file '%s' is compressed"), (const ICHAR*)strSourceName);
		}
		else
		{
			// short|long file pair may have been supplied
			Bool fLFN = ToBool(FSourceIsLFN(iSourceType, *rpiSourcePath));
			pRecErr = m_riServices.ExtractFileName(strSourcePath, fLFN, *&strSourceName);
			if(pRecErr)
				return FatalError(*pRecErr);

			DEBUGMSG2(TEXT("Source for file '%s' is uncompressed, at '%s'."),
						 (const ICHAR*)strSourceName, (const ICHAR*)MsiString(rpiSourcePath->GetPath()));
		}
	}

	// put correct filename/key back into filecopy record
	Assert(strSourceName.TextSize());
	if(strSourceName.TextSize())
	{
		AssertNonZero(riParams.SetMsiString(SourceName, *strSourceName));
	}

	if(!fCabinetCopy && !rpiSourcePath)
	{  // must not have called ixoSetSourceFolder
		DispatchError(imtError, Imsg(idbgOpSourcePathNotSet), *strSourceName);
		return iesFailure;
	}
	// pSourcePath is validated for cab installs in CopyFile after calling InitCopier

	return iesSuccess;
}

INSTALLSTATE GetFusionPath(LPCWSTR szRegistration, LPWSTR lpPath, DWORD *pcchPath, CAPITempBufferRef<WCHAR>& rgchPathOverflow, int iDetectMode, iatAssemblyType iatAT, WCHAR* szManifest);

IMsiRecord* FindFusionAssemblyFolder(IMsiServices& riServices, const IMsiString& ristrAssemblyName,
												 iatAssemblyType iatAT, IMsiPath*& rpiPath, const IMsiString** ppistrManifest = 0)
{
	rpiPath = 0;
	
	MsiString strKeyPath = TEXT("\\");
	strKeyPath += ristrAssemblyName;
	
	WCHAR wszManifest[MAX_PATH];
	CAPITempBuffer<WCHAR, 256> rgchPath;	
	INSTALLSTATE is = GetFusionPath(CConvertString(strKeyPath), 0, 0, rgchPath, DETECTMODE_VALIDATEPATH, iatAT, ppistrManifest ? wszManifest : 0);

	if(is == INSTALLSTATE_LOCAL)
	{
		if(ppistrManifest)
		{
			// copy the manifest file to the out string
			MsiString strManifest = CConvertString(wszManifest);
			strManifest.ReturnArg(*ppistrManifest);
		}

		return riServices.CreatePath(CConvertString(rgchPath),rpiPath);
	}
	else
	{
		return 0; // missing file is not a failure
	}
}

/*---------------------------------------------------------------------------

BackupAssembly: back up the files of GA before Uninstalling it
---------------------------------------------------------------------------*/
iesEnum CMsiOpExecute::BackupAssembly(const IMsiString& rstrComponentId, const IMsiString& rstrAssemblyName, iatAssemblyType iatType)
{
	if(RollbackEnabled())
	{
		// get the assembly installation folder
		PMsiPath pAssemblyFolder(0);
		MsiString strManifest;
		PMsiRecord pRecErr = FindFusionAssemblyFolder(m_riServices, rstrAssemblyName, iatType, *&pAssemblyFolder, &strManifest);
		if(pRecErr)
			return FatalError(*pRecErr);
		if(pAssemblyFolder)
		{
			// enumerate though all the files and copy to the backup folder
			iesEnum iesRet = iesSuccess;
			WIN32_FIND_DATA fdFileData;
			HANDLE hFindFile = INVALID_HANDLE_VALUE;

			MsiString strSearchPath = pAssemblyFolder->GetPath();
			strSearchPath += TEXT("*.*");

			bool fContinue = true;

			hFindFile = WIN::FindFirstFile(strSearchPath, &fdFileData);
			if (hFindFile != INVALID_HANDLE_VALUE)
			{
				for (;;)
				{
					if ((fdFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
					{
						// backup the file and set it up so that it gets installed back to the assembly on rollback
						if((iesRet = BackupFile(*pAssemblyFolder, *MsiString(CConvertString(fdFileData.cFileName)), fFalse, fFalse, iehShowIgnorableError, false, false, &rstrComponentId, strManifest.Compare(iscExactI, fdFileData.cFileName) ? true:false)) != iesSuccess)
							return iesRet;
					}
					
					if (!WIN::FindNextFile(hFindFile, &fdFileData))
					{
						Assert(ERROR_NO_MORE_FILES == GetLastError());
						WIN::FindClose(hFindFile);
						break;
					}
				}
			}
		}
		// generate opcode to create the assembly mapping
		IMsiRecord& riUndoParams = GetSharedRecord(IxoAssemblyMapping::Args);
		AssertNonZero(riUndoParams.SetMsiString(IxoAssemblyMapping::ComponentId, rstrComponentId));
		AssertNonZero(riUndoParams.SetMsiString(IxoAssemblyMapping::AssemblyName, rstrAssemblyName));
		AssertNonZero(riUndoParams.SetInteger(IxoAssemblyMapping::AssemblyType, iatType));
		if (!RollbackRecord(ixoAssemblyMapping, riUndoParams))
			return iesFailure;
	}
	return iesSuccess;
}


/*---------------------------------------------------------------------------
ixoAssemblyCopy: Copy a file to the Global Assembly Cache
---------------------------------------------------------------------------*/

enum iacdEnum
{
	iacdNoCopy,
	iacdGAC,
	iacdFileFolder,
};

iesEnum CMsiOpExecute::ixfAssemblyCopy(IMsiRecord& riParams)
{
	using namespace IxoAssemblyCopy;

	// If the cabinet copier notified us that a media change is required,
	// we must defer any file copy requests until a media change is executed.
	if (m_state.fWaitingForMediaChange)
	{
		PushRecord(riParams);
		return iesSuccess;
	}

	ielfEnum ielfCurrentElevateFlags = riParams.IsNull(ElevateFlags) ? ielfNoElevate :
												  (ielfEnum)riParams.GetInteger(ElevateFlags);

	PMsiRecord pRecErr(0);
	iesEnum iesRet = iesNoAction;

	iacdEnum iacdCopyDestination = iacdGAC;
		
	MsiString strDestName = riParams.GetMsiString(DestName);
	PMsiPath pTargetPath(0);
	// target name and path may be redirected below, but we want the action data message to contain
	// the original file information, so we'll store that away here
	MsiString strActionDataDestName = strDestName;
	
	// check if file is part of Assembly
	MsiString strComponentId = riParams.GetMsiString(ComponentId);
	if(!strComponentId.TextSize() || m_pAssemblyCacheTable == 0)
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfAssemblyCopy")));
		return iesFailure;
	}

	//
	// STEP 1: create/retrive AssemblyCacheItem for this file's assembly
	//

	PAssemblyCacheItem pASM(0);
	bool fManifest = riParams.IsNull(IsManifest) ? false: true;
	iatAssemblyType iatAT = iatNone;
	if((iesRet = GetAssemblyCacheItem(*strComponentId, *&pASM, iatAT)) != iesSuccess)
		return iesRet;

	//
	// STEP 2: if patching, look for target file in GAC and copy file to working directory
	//
	
	int cPatches          = riParams.IsNull(TotalPatches)       ? 0 : riParams.GetInteger(TotalPatches);
	int cOldAssemblyNames = riParams.IsNull(OldAssembliesCount) ? 0 : riParams.GetInteger(OldAssembliesCount);
	Assert(cOldAssemblyNames == 0 || cPatches != 0); // shouldn't have old assemblies w/o patches

	if(cPatches)
	{
		DEBUGMSG2(TEXT("FUSION PATCHING: Patching assembly file '%s' from component '%s'."), (const ICHAR*)strDestName,
					 (const ICHAR*)strComponentId);

		//
		// STEP 2a: we are patching, which means we will need an intermediate file to patch
		//          go ahead and determine the folder and filename for that file now
		//

		PMsiPath pPatchWorkingDir(0);
		MsiString strTempNameForPatch;

		// FUTURE: don't always use system drive as working directory - determine more appropriate drive
		if((iesRet = GetBackupFolder(0, *&pPatchWorkingDir)) != iesSuccess)
			return iesRet;

		{ // scope elevation
			CElevate elevate; // elevate to create temp file on secure temp folder
			if((pRecErr = pPatchWorkingDir->TempFileName(TEXT("PT"),0,fTrue,*&strTempNameForPatch, 0)) != 0)
				return FatalError(*pRecErr);
		}

		// we need to keep this file around as a placeholder for the name
		// filecopy will back this file up and restore it on rollback, so we need another rollback op to delete this file

		MsiString strTempFileFullPath;
		if((pRecErr = pPatchWorkingDir->GetFullFilePath(strTempNameForPatch,*&strTempFileFullPath)) != 0)
			return FatalError(*pRecErr);
		
		IMsiRecord& riUndoParams = GetSharedRecord(IxoFileRemove::Args);
		AssertNonZero(riUndoParams.SetMsiString(IxoFileRemove::FileName, *strTempFileFullPath));

		if (!RollbackRecord(ixoFileRemove, riUndoParams))
			return iesFailure;
		
		//
		// STEP 2b: if old assembly names are supplied, look for an existing file in the GAC
		//

		bool fShouldPatch          = true;
		bool fCopyIntermediateFile = true;
		int  cPatchesToSkip = 0;

		if(cOldAssemblyNames)
		{
			// look for an existing file in the GAC to apply our patches against
			int iOldAssemblyNameStart = riParams.IsNull(OldAssembliesStart) ? 0 : riParams.GetInteger(OldAssembliesStart);

			PMsiPath pAssemblyFolder(0);
			bool fFoundAssembly = false;
			int i = 0;
			for(i = iOldAssemblyNameStart; i < cOldAssemblyNames + iOldAssemblyNameStart; i++)
			{
				pRecErr = FindFusionAssemblyFolder(m_riServices, *MsiString(riParams.GetMsiString(i)),
															  iatAT, *&pAssemblyFolder);
				if(pRecErr)
					return FatalError(*pRecErr);

				if(pAssemblyFolder && FFileExists(*pAssemblyFolder, *strDestName))
				{
					fFoundAssembly = true;
					break;
				}
			}

			if(fFoundAssembly)
			{
				
				Assert(pAssemblyFolder);

				DEBUGMSG2(TEXT("FUSION PATCHING: Found existing file to patch in assembly with name: '%s' in folder '%s'"),
							 (const ICHAR*)MsiString(riParams.GetMsiString(i)),
							 (const ICHAR*)MsiString(pAssemblyFolder->GetPath()));
							 

				//
				// STEP 2c: if old file found, copy from GAC to working folder
				//

				m_cSuppressProgress++; // suppress progress messages
				iesRet = CopyOrMoveFile(*pAssemblyFolder, *pPatchWorkingDir, *strDestName, *strTempNameForPatch,
												fFalse, fFalse, fTrue, iehShowNonIgnorableError, 0, ielfElevateDest,
												/* fCopyACL = */ false, false, false);
				m_cSuppressProgress--;
				
				if(iesRet != iesSuccess)
					return iesRet;

				//
				// STEP 2d: test patch headers against file
				//

				icpEnum icpPatchTest = icpCannotPatch;
				int iPatchIndex = 0;
				iesRet = TestPatchHeaders(*pPatchWorkingDir, *strTempNameForPatch, riParams, icpPatchTest, iPatchIndex);
				if(iesRet == iesSuccess)
				{
					if(icpPatchTest == icpCanPatch || icpPatchTest == icpUpToDate)
					{
						// file can already be patched, so don't need to install file
						fCopyIntermediateFile = false;
						fShouldPatch = icpPatchTest == icpCanPatch ? true : false;

						cPatchesToSkip = iPatchIndex - 1; // iPatchIndex is the index of the first patch that could be applied
																	 // properly to this file.  so we need to skip the patches that come
																	 // before it.
					}
					else if(icpPatchTest == icpCannotPatch)
					{
						// can't patch the file as it stands
						// but fCopyIntermediateFile is true so we'll recopy the source file first which should be patchable
						fCopyIntermediateFile = true;
						fShouldPatch = true;

						cPatchesToSkip = 0; // need to copy source file and apply all patches
					}
					else
					{
						AssertSz(0, "Invalid return from TestPatchHeaders()");
					}
				}
			}
		}

		//
		// STEP 2d: setup copy and/or patch
		//

		int iCachedState = 0;
		
		if(fShouldPatch)
		{
			if(fCopyIntermediateFile)
			{
				// need to copy file from source to temp location

				// reset copy arguments to reflect new file copy - new path, new filename, and since
				// the file is being copied into the secured config folder, we need to elevate for the target
				// NOTE: we aren't changing strDestName, which is used below
				//       for those uses it is correct to use the original dest name
				AssertNonZero(riParams.SetMsiString(DestName,*strTempNameForPatch));
				pTargetPath = pPatchWorkingDir;

				AssertNonZero(riParams.SetInteger(ElevateFlags, ielfCurrentElevateFlags | ielfElevateDest));

				iacdCopyDestination = iacdFileFolder;

				DEBUGMSG(TEXT("FUSION PATCHING: Either no existing file found to patch, or existing file is unpatchable.  Copying file from source."));
			}
			else
			{
				// the intermediate file we have already is patchable, so no need to copy the source file to the intermediate
				// location or to the GAC
				DEBUGMSG(TEXT("FUSION PATCHING: Existing file is patchable.  Source file will not be copied."));

				iacdCopyDestination = iacdNoCopy;
			}

			iCachedState |= icfsPatchFile;

			DEBUGMSG1(TEXT("FUSION PATCHING: Subsequent patch(es) will update file '%s', then copy file into Global Assembly Cache."),
						 (const ICHAR*)strTempFileFullPath);
		}

		// FileState index for assembly files is ComponentID + FileName
		MsiString strIndex = strComponentId;
		strIndex += strDestName;

		pRecErr = CacheFileState(*strIndex,(icfsEnum*)&iCachedState,
										 strTempFileFullPath, 0, &cPatches, &cPatchesToSkip);
		if(pRecErr)
			return FatalError(*pRecErr);
	}

	if(iacdCopyDestination == iacdNoCopy)
		return iesSuccess;
	
	// STEP 3: resolve source path and type
	
	PMsiPath pSourcePath(0);
	bool fCabinetCopy = false;

	if(m_state.fSplitFileInProgress)
	{
		// must be a cabinet copy
		fCabinetCopy = true;
	}
	else
	{
		if((iesRet = ResolveSourcePath(riParams, *&pSourcePath, fCabinetCopy)) != iesSuccess)
			return iesRet;
	}

	// STEP 4: perform copy/move operation
	
	// action data
	IMsiRecord& riActionData = GetSharedRecord(9);
	AssertNonZero(riActionData.SetMsiString(1, *strActionDataDestName));
	AssertNonZero(riActionData.SetInteger(6,riParams.GetInteger(FileSize)));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	// perform operation
	if(iacdCopyDestination == iacdGAC)
	{
		return CopyFile(*pSourcePath, *pASM, fManifest, riParams, /*fHandleRollback=*/ fTrue, iehShowNonIgnorableError, fCabinetCopy);
	}
	else if(iacdCopyDestination == iacdFileFolder)
	{
		Assert(pTargetPath);
		return CopyFile(*pSourcePath, *pTargetPath, riParams, /*fHandleRollback=*/ fTrue, iehShowNonIgnorableError, fCabinetCopy);
	}
	else
	{
		Assert(0);
		return iesSuccess;
	}
}

iesEnum CMsiOpExecute::ApplyPatchCore(IMsiPath& riTargetPath, IMsiPath& riTempFolder, const IMsiString& ristrTargetName,
												  IMsiRecord& riParams, const IMsiString*& rpistrOutputFileName,
												  const IMsiString*& rpistrOutputFilePath)
{
	using namespace IxoFilePatchCore;	

	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;

	// the binary patch file is extracted into the config folder.  this requires elevation
	// also when the target file may be a temporary file in the secured config folder, this also requires elevation
	CElevate elevate;

	// get temp name for output file
	if((pError = riTempFolder.TempFileName(TEXT("PT"),0,fTrue,rpistrOutputFileName, 0 /* use default ACL for folder */)) != 0)
		return FatalError(*pError);
	
	// rollback for ApplyPatch call is to remove patch output file
	// below we will copy the output file over the existing file - the rollback for that operation
	// will move the output file back and this rollback operation will remove it
	if((pError = riTempFolder.GetFullFilePath(rpistrOutputFileName->GetString(), rpistrOutputFilePath)) != 0)
		return FatalError(*pError);

	IMsiRecord* piUndoParams = &GetSharedRecord(IxoFileRemove::Args);
	AssertNonZero(piUndoParams->SetMsiString(IxoFileRemove::FileName,*rpistrOutputFilePath));
	AssertNonZero(piUndoParams->SetInteger(IxoFileRemove::Elevate, true));
	if (!RollbackRecord(ixoFileRemove,*piUndoParams))
		return iesFailure;

	// get temp name for patch file -- it may be sensitive information, so hide it from the user.
	MsiString strPatchFileName;

	if((pError = riTempFolder.TempFileName(TEXT("PF"),0,fTrue,*&strPatchFileName, 0 /* use default ACL for folder*/)) != 0)
		return FatalError(*pError);

	unsigned int cbPerTick = riParams.GetInteger(PerTick);
	unsigned int cbFileSize = riParams.GetInteger(TargetSize);

	// extract patch file from cabinet into temp file
	// set up record for ixfFileCopy
	PMsiRecord pFileCopyRec = &m_riServices.CreateRecord(IxoFileCopyCore::Args);
	AssertNonZero(pFileCopyRec->SetMsiString(IxoFileCopyCore::SourceName,
														  *MsiString(riParams.GetMsiString(PatchName))));
	AssertNonZero(pFileCopyRec->SetMsiString(IxoFileCopyCore::DestName, *strPatchFileName));
	
	AssertNonZero(pFileCopyRec->SetInteger(IxoFileCopyCore::Attributes,0));
	AssertNonZero(pFileCopyRec->SetInteger(IxoFileCopyCore::FileSize,riParams.GetInteger(PatchSize)));
	AssertNonZero(pFileCopyRec->SetInteger(IxoFileCopyCore::PerTick,cbPerTick));
	AssertNonZero(pFileCopyRec->SetInteger(IxoFileCopyCore::VerifyMedia,fTrue));
	AssertNonZero(pFileCopyRec->SetInteger(IxoFileCopyCore::ElevateFlags, ielfElevateDest));
	
	// don't need to set Version or Language

	iesRet = CopyFile(*PMsiPath(0)/* not used for cab installs*/,
					  riTempFolder,*pFileCopyRec,fFalse,iehShowNonIgnorableError,/*fCabinetCopy=*/true); // don't handle rollback
	if(iesRet != iesSuccess)
	{
		// remove patch file in case only part was copied
		pError = riTempFolder.RemoveFile(strPatchFileName); // ignore error
		return iesRet;
	}

	// after this point, don't return without deleting patch file

	// apply patch to target file
	int cbFileSoFar = 0;
	Bool fRetry = fTrue;
	bool fVitalFile = (riParams.GetInteger(FileAttributes) & msidbFileAttributesVital) != 0;
	bool fVitalPatch = (riParams.GetInteger(PatchAttributes) & msidbPatchAttributesNonVital) == 0;

	// ApplyPatch can sometimes be a long operation without a patch notify message
	// need to disable timeout until more frequent notification messages are added
	// NOTE: must not return before the next MsiEnableTimeout call below
	MsiDisableTimeout();

	// start patch application, continue if necessary with ContinuePatch
	while(fRetry)
	{
		pError = m_state.pFilePatch->ApplyPatch(riTargetPath, ristrTargetName.GetString(),
															 riTempFolder, rpistrOutputFileName->GetString(),
															 riTempFolder, strPatchFileName,
															 cbPerTick);
		Bool fContinue = fTrue;
		while(fContinue)  // both a retry loop and loop to call Continue until 0 is returned.
		{
			if(pError)
			{
				int iError = pError->GetInteger(1);
				if(iError == idbgPatchNotify)
				{
					int cb = pError->GetInteger(2);
					Assert((cb - cbFileSoFar) >= 0);
					if (DispatchProgress(cb - cbFileSoFar) == imsCancel)  // increment by difference from last update
					{
						fRetry = fFalse;
						fContinue = fFalse;
						iesRet = iesUserExit;
						// cancel patch if still in-progress
						pError = m_state.pFilePatch->CancelPatch();
						if(pError)
							Message(imtInfo,*pError);
					}
					else
						cbFileSoFar = cb;  // update
				}
				else
				{
					fContinue = fFalse;
					imtEnum imtType = imtInfo;
					if(fVitalPatch)
					{
						imtType = fVitalFile ? imtEnum(imtError+imtRetryCancel+imtDefault2) :
													  imtEnum(imtError+imtAbortRetryIgnore+imtDefault1);
					}

					switch(DispatchMessage(imtType,*pError,fTrue))
					{
					case imsRetry:
						continue;
					case imsIgnore:
						fRetry = fFalse;
						iesRet = (iesEnum) iesErrorIgnored;
						break;
					default:  // imsCancel, imsNone (for imtInfo)
						fRetry = fFalse;
						iesRet = iesFailure;
					};
				}
			}
			else
			{
				// file has been patched
				if (DispatchProgress(cbFileSize - cbFileSoFar) == imsCancel)
					iesRet = iesUserExit;
				else
					iesRet = iesSuccess;
				fRetry = fFalse;
				fContinue = fFalse;
			}
		
			if(fRetry)
			{
				// continue patch application
				pError = m_state.pFilePatch->ContinuePatch();
			}
		}
	}

	// re-enable timeout after patch application
	MsiEnableTimeout();

	// cleanup
	if((pError = riTempFolder.RemoveFile(strPatchFileName)) != 0) // non-critical error
	{
		Message(imtInfo,*pError);
	}

	return iesRet;
}


iesEnum CMsiOpExecute::ixfAssemblyPatch(IMsiRecord& riParams)
{
	using namespace IxoAssemblyPatch;

	//
	// STEP 0: check state, parameters for errors
	//
	
	PMsiRecord pError(0);
	iesEnum iesRet = iesNoAction;
	
	if(!m_state.pFilePatch)
	{
		// create FilePatch object
		if((pError = m_riServices.CreatePatcher(*&(m_state.pFilePatch))) != 0)
		{
			Message(imtError,*pError);
			return iesFailure;
		}
	}
	Assert(m_state.pFilePatch);

	// check if file is part of Assembly
	MsiString strComponentId = riParams.GetMsiString(ComponentId);
	if(!strComponentId.TextSize() || m_pAssemblyCacheTable == 0)
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfAssemblyPatch")));
		return iesFailure;
	}

	//
	// STEP 1: create/retrieve assemblycacheitem object for this file's assembly
	//

	MsiString strCopyTargetFileName = riParams.GetMsiString(TargetName);

	PAssemblyCacheItem pASM(0);
	bool fManifest = riParams.IsNull(IsManifest) ? false: true;
	iatAssemblyType iatAT = iatNone;
	if((iesRet = GetAssemblyCacheItem(*strComponentId, *&pASM, iatAT)) != iesSuccess)
		return iesRet;

	//
	// STEP 2: retrieve cached state for this file
	//

	// FileState index for assembly files is ComponentID + FileName
	MsiString strIndex = strComponentId;
	strIndex += strCopyTargetFileName;
	
	icfsEnum icfsFileState = (icfsEnum)0;
	MsiString strTempLocation;
	int cRemainingPatches = 0;
	int cRemainingPatchesToSkip = 0;
	Bool fRes = GetFileState(*strIndex, &icfsFileState, &strTempLocation, &cRemainingPatches, &cRemainingPatchesToSkip);

	if(!fRes || !(icfsFileState & icfsPatchFile))
	{
		// don't patch file
		DEBUGMSG1(TEXT("Skipping all patches for assembly '%s'.  File does not need to be patched."),
					 (const ICHAR*)strIndex);
		return iesSuccess;
	}

	Assert(cRemainingPatches > 0);
	
	if(cRemainingPatchesToSkip > 0)
	{
		// skip this patch, but reset cached file state first
		cRemainingPatches--;
		cRemainingPatchesToSkip--;

		DEBUGMSG3(TEXT("Skipping this patch for assembly '%s'.  Number of remaining patches to skip for this file: '%d'.  Number of total remaining patches: '%d'."),
					 (const ICHAR*)strIndex, (const ICHAR*)(INT_PTR)cRemainingPatchesToSkip, (const ICHAR*)(INT_PTR)cRemainingPatches);

		if((pError = CacheFileState(*strIndex, 0, 0, 0, &cRemainingPatches, &cRemainingPatchesToSkip)) != 0)
			return FatalError(*pError);

		return iesSuccess;
	}
	

	if(strTempLocation.TextSize() == 0)
	{
		// error - there must be an intermediate copy of an assembly file to patch.  we won't patch the 
		// file directly in the GAC
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfAssemblyPatch")));
		return iesFailure;
	}

	Assert(cRemainingPatches > 0);

	DEBUGMSG4(TEXT("FUSION PATCHING: Patching assembly file '%s' from component '%s'.  Intermediate file: '%s', remaining patches (including this one): %d"),
				 (const ICHAR*)strCopyTargetFileName, (const ICHAR*)strComponentId, (const ICHAR*)strTempLocation,
				 (const ICHAR*)(INT_PTR)cRemainingPatches);

	PMsiPath pPatchTargetPath(0);
	MsiString strPatchTargetFileName;
	
	// file was actually copied to temp location.  this is the copy we want to apply the patch against
	if((pError = m_riServices.CreateFilePath(strTempLocation,*&pPatchTargetPath,*&strPatchTargetFileName)) != 0)
		return FatalError(*pError);

	unsigned int cbFileSize = riParams.GetInteger(TargetSize);
	bool fVitalFile = (riParams.GetInteger(FileAttributes) & msidbFileAttributesVital) != 0;
	bool fVitalPatch = (riParams.GetInteger(PatchAttributes) & msidbPatchAttributesNonVital) == 0;

	// dispatch ActionData message
	IMsiRecord& riActionData = GetSharedRecord(3);
	AssertNonZero(riActionData.SetMsiString(1, *strCopyTargetFileName));
	AssertNonZero(riActionData.SetInteger(3, cbFileSize));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;
	
	//
	// STEP 3: create output file with patch and target files
	//

	PMsiPath pTempFolder(0);
	if((iesRet = GetBackupFolder(pPatchTargetPath, *&pTempFolder)) != iesSuccess)
		return iesRet;

	MsiString strOutputFileName;
	MsiString strOutputFileFullPath;
	if((iesRet = ApplyPatchCore(*pPatchTargetPath, *pTempFolder, *strPatchTargetFileName,
										 riParams, *&strOutputFileName, *&strOutputFileFullPath)) != iesSuccess)
	{
		return iesRet;
	}

	//
	// STEP 4: either setup output file for next patch, or copy output file into the GAC
	//
	
	MsiString strNewTempLocation;
	if(iesRet == iesSuccess)
	{
		if(cRemainingPatches > 1)
		{
			// there is at least one more patch to be done on this file
			// therefor we will reset the temporary name for this file to be the patch output file
			// but won't overwrite the original file yet
			strNewTempLocation = strOutputFileFullPath;
		}
		else
		{
			// this is the last patch - time to finally overwrite the original file
			
			// we always need to handle rollback.  we wouldn't if a previous filecopy operation wrote to the same
			// target that we are copying over now, but that should never happen since when patching will happen
			// filecopy should be writing to an intermediate file
			Assert(strTempLocation.TextSize() || (icfsFileState & icfsFileNotInstalled));

			iesRet = CopyASM(*pTempFolder, *strOutputFileName, *pASM, *strCopyTargetFileName, fManifest,
								  fTrue, fVitalFile ? iehShowNonIgnorableError : iehShowIgnorableError, ielfElevateSource);

			if(iesRet == iesSuccess)
			{
				CElevate elevate;
				// done copying file into GAC, now remove the output file
				if((pError = pTempFolder->RemoveFile(strOutputFileName)) != 0) // non-critical error
				{
					Message(imtInfo,*pError);
				}
			}
		}
	}
	else
	{
		CElevate elevate;
		// remove output file if failure
		if((pError = pTempFolder->RemoveFile(strOutputFileName)) != 0) // non-critical error
		{
			Message(imtInfo,*pError);
		}

		if(fVitalPatch == false)
		{
			// failed to apply vital patch - return success to allow script to continue
			iesRet = iesSuccess;
		}
	}

	// if we patched a temp file, remove that file
	if(strTempLocation.TextSize())
	{
		if((pError = pPatchTargetPath->RemoveFile(strPatchTargetFileName)) != 0) // non-critical error
		{
			Message(imtInfo,*pError);
		}
	}

	//
	// STEP 5: reset cached file state
	//         one fewer remaining patch now, and we may either have a new temporary location, or no temporary location
	//

	cRemainingPatches--;
	Assert(cRemainingPatchesToSkip == 0);
	if((pError = CacheFileState(*strIndex, 0, strNewTempLocation, 0, &cRemainingPatches, 0)) != 0)
		return FatalError(*pError);

	return iesRet;
}

iesEnum CMsiOpExecute::GetAssemblyCacheItem(const IMsiString& ristrComponentId,
														  IAssemblyCacheItem*& rpiASM,
														  iatAssemblyType& iatAT)
{
	PMsiCursor pCacheCursor = m_pAssemblyCacheTable->CreateCursor(fFalse);
	pCacheCursor->SetFilter(iColumnBit(m_colAssemblyMappingComponentId));
	AssertNonZero(pCacheCursor->PutString(m_colAssemblyMappingComponentId, ristrComponentId));
	if(pCacheCursor->Next())
	{
		// a fusion component
		rpiASM = static_cast<IAssemblyCacheItem*>(CMsiDataWrapper::GetWrappedObject(PMsiData(pCacheCursor->GetMsiData(m_colAssemblyMappingASM))));
		iatAT = (iatAssemblyType)pCacheCursor->GetInteger(m_colAssemblyMappingAssemblyType);
		if(!rpiASM) // no interface created as yet, create the interface
		{
			// create the assembly interface
			PAssemblyCache pCache(0);
			HRESULT hr;
			if(iatAT == iatURTAssembly)
				hr = FUSION::CreateAssemblyCache(&pCache, 0);
			else
			{
				Assert(iatAT == iatWin32Assembly);
				hr = SXS::CreateAssemblyCache(&pCache, 0);
			}
			if(!SUCCEEDED(hr))
			{
				return FatalError(*PMsiRecord(PostAssemblyError(ristrComponentId.GetString(), hr, TEXT(""), TEXT("CreateAssemblyCache"), MsiString(pCacheCursor->GetString(m_colAssemblyMappingAssemblyName)), iatAT)));
			}

			hr = pCache->CreateAssemblyCacheItem(0, NULL, &rpiASM, NULL);
			if(!SUCCEEDED(hr))
			{
				return FatalError(*PMsiRecord(PostAssemblyError(ristrComponentId.GetString(), hr, TEXT("IAssemblyCache"), TEXT("CreateAssemblyCacheItem"), MsiString(pCacheCursor->GetString(m_colAssemblyMappingAssemblyName)), iatAT)));
			}

			//add the interface to the table for future use
			AssertNonZero(pCacheCursor->PutMsiData(m_colAssemblyMappingASM, PMsiDataWrapper(CreateMsiDataWrapper(rpiASM))));
			AssertNonZero(pCacheCursor->Update());
		}

		Assert(rpiASM);
		return iesSuccess;
	}
	else
	{
		DispatchError(imtError, Imsg(idbgOpOutOfSequence),
						  *MsiString(*TEXT("ixfAssemblyCopy"))); //!!
		return iesFailure;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\fdidll.c ===
/*
 *  FDIDLL.C -- FDI interface using CABINET.DLL
 *
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1997
 *  All Rights Reserved.
 *
 *  Author:
 *      Mike Sliger
 *
 *  History:
 *      21-Jan-1997 msliger Initial version
 *      24-Jan-1997 msliger Changed to public include file
 *      18-Sep-1997 malcolmh Changed to support UNICODE
 *
 *  Overview:
 *      This code is a wrapper which provides access to the actual FDI code
 *      in CABINET.DLL.  CABINET.DLL dynamically loads/unloads as needed.
 */
 
#include <windows.h>

#include "fdi.h"

static HINSTANCE hCabinetDll;   /* DLL module handle */

/* pointers to the functions in the DLL */

static HFDI (FAR DIAMONDAPI *pfnFDICreate)(
        PFNALLOC            pfnalloc,
        PFNFREE             pfnfree,
        PFNOPEN             pfnopen,
        PFNREAD             pfnread,
        PFNWRITE            pfnwrite,
        PFNCLOSE            pfnclose,
        PFNSEEK             pfnseek,
        int                 cpuType,
        PERF                perf);
static BOOL (FAR DIAMONDAPI *pfnFDIIsCabinet)(
        HFDI                hfdi,
        INT_PTR             hf,
        PFDICABINETINFO     pfdici);
static BOOL (FAR DIAMONDAPI *pfnFDICopy)(
        HFDI                hfdi,
        char                *pszCabinet,
        char                *pszCabPath,
        int                 flags,
        PFNFDINOTIFY        pfnfdin,
        PFNFDIDECRYPT       pfnfdid,
        void                *pvUser);
static BOOL (FAR DIAMONDAPI *pfnFDIDestroy)(
        HFDI                hfdi);


/*
 *  FDICreate -- Create an FDI context
 *
 *  See fdi_int.h for entry/exit conditions.
 */

HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf)
{
    HFDI hfdi;

    hCabinetDll = LoadLibrary(TEXT("CABINET"));
    if (hCabinetDll == NULL)
    {
        return(NULL);
    }

    pfnFDICreate = (void *) GetProcAddress(hCabinetDll,"FDICreate");
    pfnFDICopy = (void *) GetProcAddress(hCabinetDll,"FDICopy");
    pfnFDIIsCabinet = (void *) GetProcAddress(hCabinetDll,"FDIIsCabinet");
    pfnFDIDestroy = (void *) GetProcAddress(hCabinetDll,"FDIDestroy");

    if ((pfnFDICreate == NULL) ||
        (pfnFDICopy == NULL) ||
        (pfnFDIIsCabinet == NULL) ||
        (pfnFDIDestroy == NULL))
    {
        FreeLibrary(hCabinetDll);

        return(NULL);
    }

    hfdi = pfnFDICreate(pfnalloc,pfnfree,
            pfnopen,pfnread,pfnwrite,pfnclose,pfnseek,cpuType,perf);
    if (hfdi == NULL)
    {
        FreeLibrary(hCabinetDll);
    }

    return(hfdi);
}


/*
 *  FDIIsCabinet -- Determines if file is a cabinet, returns info if it is
 *
 *  See fdi_int.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi,
                                 INT_PTR         hf,
                                 PFDICABINETINFO pfdici)
{
    if (pfnFDIIsCabinet == NULL)
    {
        return(FALSE);
    }

    return(pfnFDIIsCabinet(hfdi,hf,pfdici));
}


/*
 *  FDICopy -- extracts files from a cabinet
 *
 *  See fdi_int.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            char         *pszCabinet,
                            char         *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void         *pvUser)
{
    if (pfnFDICopy == NULL)
    {
        return(FALSE);
    }

    return(pfnFDICopy(hfdi,pszCabinet,pszCabPath,flags,pfnfdin,pfnfdid,pvUser));
}


/*
 *  FDIDestroy -- Destroy an FDI context
 *
 *  See fdi_int.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi)
{
    BOOL rc;

    if (pfnFDIDestroy == NULL)
    {
        return(FALSE);
    }

    rc = pfnFDIDestroy(hfdi);
    if (rc == TRUE)
    {
        FreeLibrary(hCabinetDll);
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\fcache.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       fcache.cpp
//
//--------------------------------------------------------------------------

#include "precomp.h"
#include "_fcache.h"
#include "_msiutil.h"

#ifdef _WIN64
#define MSI_ALIGNMENT_PADDING 7
#else
#define MSI_ALIGNMENT_PADDING 0
#endif


const int cchMaxFeatureId = 130; //!!
const int cHashBitsDefault = 11;
const int cHashBins = 1 << (cHashBitsDefault-1);

bool CFeatureCache::GetState(const ICHAR* szProduct, const ICHAR* szFeature, INSTALLSTATE& riState)
{
#ifdef DEBUG
	ICHAR rgchDebug[1024];
#endif

	EnsureCacheSemaphore();
	if (!m_hSemaphore)
	{
		Assert(0);
		return false;
	}

	extern CSharedCount g_SharedCount;

	// initialize the pointer to the global invalidation count
	// need to prevent simultaneous initialization
	DWORD dw = WaitForSingleObject(m_hSemaphore, INFINITE);
	if (dw != WAIT_OBJECT_0)
	{
		Assert(dw == WAIT_TIMEOUT);
		return false;
	}
	bool fInit = g_SharedCount.Initialize(&m_iInvalidateCount);
	ReleaseSemaphore(m_hSemaphore, 1, 0);
	if(!fInit)
		return false;

	// have we done an install?
	if (m_iInvalidateCount != g_SharedCount.GetCurrentCount())
	{
		Invalidate();
		m_iInvalidateCount = g_SharedCount.GetCurrentCount();
	}

	dw = WaitForSingleObject(m_hSemaphore, INFINITE);
	if (dw != WAIT_OBJECT_0)
	{
		Assert(dw == WAIT_TIMEOUT);
		return false;
	}

	MsiFeatureCacheEntry* pEntry = (MsiFeatureCacheEntry*)(*m_ppHead);
	ICHAR rgchProductFeature[cchProductCodePacked + cchMaxFeatureId + 1];

	Assert(IStrLen(szProduct) == cchProductCodePacked);
	memcpy(rgchProductFeature, szProduct, (cchProductCodePacked+1)*sizeof(ICHAR));
	IStrCat(rgchProductFeature, szFeature);
	
	unsigned short usHash = HashString(rgchProductFeature);

	int cEntries = 0;

	for (;;)
	{
		if (usHash == pEntry->usHash && 0 == IStrComp(rgchProductFeature, (ICHAR*)((char*)&pEntry->isFeatureState + sizeof(INSTALLSTATE))))
		{
			riState = pEntry->isFeatureState;
#ifdef DEBUG
			wsprintf(rgchDebug, TEXT("MSI: FEATURECACHE: Found: %s/%s with state: %d"), szProduct, szFeature, riState);
			DEBUGMSGV(rgchDebug);
#endif
			ReleaseSemaphore(m_hSemaphore, 1, 0);

			return true;
		}

		if ((char*)pEntry == (*m_ppTail))
			break;
		
		pEntry = (MsiFeatureCacheEntry*)((char*)pEntry + pEntry->cbNextEntryOffset);
	};

#ifdef DEBUG
		wsprintf(rgchDebug, TEXT("MSI: FEATURECACHE: Not found: %s/%s"), szProduct, szFeature);
		DEBUGMSGV(rgchDebug);
#endif

	ReleaseSemaphore(m_hSemaphore, 1, 0);

	return false;
}

inline bool CFeatureCache::FAddressIsInCache(const char* pAddress)
{
	if ((pAddress >= m_rgCache) && (pAddress <= m_pCacheEnd))
		return true;
	else
		return false;
}

bool CFeatureCache::Insert(const ICHAR* szProduct, const ICHAR* szFeature, INSTALLSTATE isState)
// In most cases our new entry will be inserted after the tail entry in the cache.
// If there's not enough room after the tail, however, we'll have to invalidate some
// entries at the head of the cache to make room for the new entry. Additionally, if the tail is
// very close to the end of the cache's memory block then we might have to "wrap around" and
// start the new entry at the beginning of the block.
//
// Here are the cases worth noting:
//
///////////////////////////////////////////////////////////////////////
//
// Case 1: enough room at the tail -- no wrapping (head < tail)
//
// before: [ {      }{     }{     }{        }              ]
//           ^head                 ^tail
//
// new entry: {XXXXXXX}
//
// action required: Place entry after the tail entry. Move tail to point to the new entry.
//
// after:  [ {      }{     }{     }{        }{XXXXXXX}     ]
//           ^head                           ^tail
//
///////////////////////////////////////////////////////////////////////
//
// Case 2: enough room at the tail -- wrapping required (head < tail)
//
// before: [        {      }{      }{        }{        }   ]
//                  ^head                     ^tail
//
// new entry: {XXXXXX}
//
// action required: Place entry at the beginning of the cache's block. Update
//                  tail's 'next' index to point to new entry. Move tail to 
//                  point to the new entry.
//
// after:  [{XXXXXX}{      }{      }{        }{        }   ]
//          ^tail   ^head
//
///////////////////////////////////////////////////////////////////////
//
// Case 3: enough room at the tail -- no wrapping (head > tail)
//
// before: [{       }                                  {   }]
//          ^tail                                      ^head
//
// new entry: {XXXXXX}
//
// action required: Place entry after the tail entry. Move tail to point to new entry.
//
// after:  [{       }{XXXXXX}                          {   }]
//                   ^tail                             ^head
//
///////////////////////////////////////////////////////////////////////
//
// Case 4: not enough room at the tail -- no wrapping
//
// before: [{       }{      }   {      }{        }{        }]
//                   ^tail      ^head
//
// new entry: {XXXXXX}
//
// action required: Keeping moving the head forward one entry until there's enough room
//                  to place the new entry after the tail. Place the new entry after the 
//                  tail entry. Move tail to point to the new entry.
//
// after:  [{       }{      }{XXXXXX}   {        }{        }]
//                           ^tail      ^head
//
///////////////////////////////////////////////////////////////////////
//
// Case 5: not enough room at the tail -- wrapping required
//
// before: [  {       }{      }   {      }{        }{      }  ]
//            ^head                                 ^tail
//
// new entry: {XXXXXX}
//
// action required: Keep moving the head forward one entry until there's enough room
//                  to place the new entry at the front of the block.Place the new
//                  entry at the front of the block. Update tail's 'next' entry to
//                  point to the new entry. Move tail to point to the new entry. 
//
// after:  [{XXXXXX}   {      }   {      }{        }{      }  ]
//          ^tail      ^head                        ^tail
//
///////////////////////////////////////////////////////////////////////
{
    if ( ! szProduct || ! szFeature )
        return false;

	EnsureCacheSemaphore();
	if (!m_hSemaphore)
	{
		Assert(0);
		return false;
	}

	DWORD dw = WaitForSingleObject(m_hSemaphore, 2*1000); // wait for 2 seconds
	if (dw != WAIT_OBJECT_0)
	{
		Assert(dw == WAIT_TIMEOUT);
		return false;
	}

	extern CSharedCount g_SharedCount;
	bool fInit = g_SharedCount.Initialize(&m_iInvalidateCount);
	ReleaseSemaphore(m_hSemaphore, 1, 0);
	if(!fInit)
		return false;

	// have we done an install?
	if (m_iInvalidateCount != g_SharedCount.GetCurrentCount())
	{
		Invalidate();
		m_iInvalidateCount = g_SharedCount.GetCurrentCount();
	}

	dw = WaitForSingleObject(m_hSemaphore, 2*1000); // wait for 2 seconds
	if (dw != WAIT_OBJECT_0)
	{
		Assert(dw == WAIT_TIMEOUT);
		return false;
	}

#ifdef DEBUG
	ICHAR rgchDebug[1024];
#endif

#ifdef DEBUG
	wsprintf(rgchDebug, TEXT("MSI: FEATURECACHE: Inserting: %s/%s with state: %d"), szProduct, szFeature, (int)isState);
	DEBUGMSGV(rgchDebug);
#endif

L_Start:

	if (!FAddressIsInCache(*m_ppHead))
	{
		AssertSz(0, "Corrupted feature cache -- head is not in cache");
		UnguardedInvalidate();
	}
	
	if (!FAddressIsInCache(*m_ppTail))
	{
		AssertSz(0, "Corrupted feature cache -- tail is not in cache");
		UnguardedInvalidate();
	}

	// calculate the size of the new entry

	int cchFeature = IStrLen(szFeature);
	int cbString   = cchFeature*sizeof(ICHAR) + cchProductCodePacked*sizeof(ICHAR) + 1*sizeof(ICHAR);
	int cbNewEntry = cbString + sizeof(MsiFeatureCacheEntry);
	
	// On Win64, add extra bytes to the end so that the next feature is aligned
	// at an 8-byte boundary and thus prevent alignment faults
	cbNewEntry = ((cbNewEntry + MSI_ALIGNMENT_PADDING)/(MSI_ALIGNMENT_PADDING + 1)) * (MSI_ALIGNMENT_PADDING + 1);
	
	bool fWrapped  = false;
	
	// for convenient reference below

	const char* pEndOfTail = ((*m_ppTail) + ((MsiFeatureCacheEntry*)(*m_ppTail))->cbNextEntryOffset); 
	
	// covers cases 1, 2, 3, 4

	MsiFeatureCacheEntry* pNewEntry = (MsiFeatureCacheEntry*)pEndOfTail;

	// determine whether we enough free space at the tail end of the cache to add the new entry

	int cbFreeSpace;
	
	if ((*m_ppTail) >= (*m_ppHead))
	{
		// there are two possible locations for free space, denoted by "*":
		//
		// [*************{   }{   }{      }**************]
		// ^m_rgCache    ^head     ^tail  ^end-of-tail   ^m_pCacheEnd
		//

		// first look for space between the end of the tail and the end of the block

		Assert((INT_PTR)(m_pCacheEnd - pEndOfTail) <= INT_MAX);		//--merced: we typecast from ptr64 to int32 below, it better be in the int32 range.
		cbFreeSpace = (int)(m_pCacheEnd - pEndOfTail);				//--merced: okay to typecast.

		if (cbFreeSpace < cbNewEntry)
		{
			// next look for space between the start of the block and the head

			pNewEntry = (MsiFeatureCacheEntry*)m_rgCache;
			Assert((INT_PTR)((*m_ppHead) - m_rgCache) <= INT_MAX);	//--merced: we typecast from ptr64 to int32 below, it better be in the int32 range.
			cbFreeSpace = (int)((*m_ppHead) - m_rgCache);
			fWrapped  = true;
		}
	}
	else // (*m_ppTail) < (*m_ppHead)
	{
		// there's one possible location for free space, denoted by "*":
		//
		// [{   }{   }{ }**********{      }{     }{     }]
		// ^m_rgCache ^tail        ^head                 ^m_pCacheEnd
		//

		Assert((INT_PTR)((*m_ppHead) - pEndOfTail) <= INT_MAX);		//--merced: we typecast from ptr64 to int32 below, it better be in the int32 range.
		cbFreeSpace = (int)((*m_ppHead) - pEndOfTail);
	}

	int cbAvailable = 0;

	if (cbFreeSpace < cbNewEntry) // cases 4, 5
	{
		// we need to make room for this new entry

		MsiFeatureCacheEntry* pEntry = (MsiFeatureCacheEntry*)(*m_ppHead);

		while ((*m_ppHead) != (*m_ppTail))
		{
			// Invalidate this head entry so it's inaccessible

			((MsiFeatureCacheEntry*)((*m_ppHead)))->usHash = 0;

			// calculate how much space we'll free by bumping the head

			int cbNextEntryOffset = ((MsiFeatureCacheEntry*)((*m_ppHead)))->cbNextEntryOffset;
			
			if (cbNextEntryOffset > 0)
			{
				// we'll bump the head forward so the space freed is equal to the amount
				// we'll bump the head plus the space preceding the head that was already
				// free.

				Assert((INT_PTR)(cbNextEntryOffset + cbFreeSpace) <= INT_MAX);	//--merced: we typecast from ptr64 to int32 below, it better be in the int32 range.
				cbAvailable += (int)(cbNextEntryOffset + cbFreeSpace);
			}
			else if (cbNextEntryOffset < 0)
			{
				Assert((*m_ppTail) < (*m_ppHead));

				// we'll bump the head backward (it'll wrap around to the front of the block)
				// so the free space is equal to the amount of space between the 
				// head and the end of the block

				Assert((INT_PTR)(m_pCacheEnd - pEndOfTail) <= INT_MAX);			//--merced: we typecast from ptr64 to int32 below, it better be in the int32 range.
				cbAvailable = (int)(m_pCacheEnd - pEndOfTail);
			}
			else // cbNextEntryOffset == 0
			{
				// something has gone horribly awry. our offset should never be 0.
				// we'll invalidate the cache and do the insert again

				AssertSz(0, "Corrupted feature cache -- cbNextEntryOffset==0");
				UnguardedInvalidate();
				goto L_Start;
			}
			
			// Bump the head 1 entry (note: this may cause the head to 
			// move from near the end of the block back around to near the beginning)
			
			(*m_ppHead) += cbNextEntryOffset;

			if (!FAddressIsInCache(*m_ppHead))
			{
				AssertSz(0, "Corrupted feature cache -- head is not in cache");
				UnguardedInvalidate();
				goto L_Start;
			}

			// If we've freed enough bytes then we can stop

			if (cbAvailable >= cbNewEntry)
			{
				break;
			}

			cbFreeSpace = 0; // we've already accounted for any free space

			// if we wrapped around to the front of the block then we need to reset our count
			// and place our next entry at the front of the block

			if (cbNextEntryOffset < 0)
			{
				Assert((INT_PTR)((*m_ppHead) - m_rgCache) <= INT_MAX);			//--merced: we typecast from ptr64 to int32 below, it better be in the int32 range.
				cbAvailable = (int)((*m_ppHead) - m_rgCache);
				pNewEntry = (MsiFeatureCacheEntry*)m_rgCache;
			}
		}

		if (cbAvailable < cbNewEntry) // we couldn't free enough room for the entry
		{
			ReleaseSemaphore(m_hSemaphore, 1, 0);
			return false;
		}
	}


	// create the new entry

	pNewEntry->cbNextEntryOffset = (short)cbNewEntry;
	pNewEntry->isFeatureState    = isState;
	ICHAR* szProductFeature      = (ICHAR*)((char*)&(pNewEntry->isFeatureState) + sizeof(INSTALLSTATE));

	Assert(IStrLen(szProduct) == cchProductCodePacked);
	
	if ((szProductFeature + cchProductCodePacked + cchFeature + 1) > (ICHAR*)m_pCacheEnd)
	{
		AssertSz(0, "Corrupted feature cache -- entry will go beyond the cache end");
		UnguardedInvalidate();
		goto L_Start;
	}
	
	memcpy(szProductFeature, szProduct, cchProductCodePacked*sizeof(ICHAR));
	memcpy(szProductFeature+cchProductCodePacked, szFeature, (cchFeature+1)*sizeof(ICHAR));
		
	if (fWrapped)
	{
		((MsiFeatureCacheEntry*)(*m_ppTail))->cbNextEntryOffset = (short)(m_rgCache - (*m_ppTail));
	}

	(*m_ppTail) = (char*)pNewEntry;

	pNewEntry->usHash = HashString(szProductFeature); // do this last so this cache entry won't be accessed until it's complete
	ReleaseSemaphore(m_hSemaphore, 1, 0);
	return true;
}

unsigned short CFeatureCache::HashString(const ICHAR* sz)
{
	ICHAR ch;
	unsigned int iHash = 0;
	int iHashBins = cHashBins;
	int iHashMask = iHashBins - 1;
	while ((ch = *sz++) != 0)
	{
		iHash <<= 1;
		if (iHash & iHashBins)
			iHash -= iHashMask;
		iHash ^= ch;
	}

	iHash++; // offset hash by 1 so that we never return 0.
	return (unsigned short)iHash;
}

extern bool __stdcall TestAndSet(int* pi); // from action.cpp

void CFeatureCache::Invalidate()
{
	DEBUGMSG(TEXT("FEATURECACHE: Entering Invalidate"));
	EnsureCacheSemaphore();
	if (!m_hSemaphore)
	{
		Assert(0);
		return;
	}

	DWORD dw = WaitForSingleObject(m_hSemaphore, INFINITE);
	if (dw != WAIT_OBJECT_0)
	{
		Assert(0);
		return;
	}

	UnguardedInvalidate();

	ReleaseSemaphore(m_hSemaphore, 1, 0);

#ifdef DEBUG
	DebugDump();
#endif
}

void CFeatureCache::UnguardedInvalidate()
{
	// WARNING -- anyone calling this function must first have acquired
	// our semaphore

	//	DEBUGMSG(TEXT("FEATURECACHE: Entering Invalidate"));

#ifdef DEBUG
	#define lDeadSpaceCnst	0xdedededeUL 
	memset(m_rgCache, lDeadSpaceCnst, cbCacheSize);  //!!
#endif
//	DEBUGMSG(TEXT("FEATURECACHE: Invalidating cache"));

	(*m_ppHead) = (*m_ppTail) = m_rgCache;
	
	((MsiFeatureCacheEntry*)(*m_ppTail))->cbNextEntryOffset = 0;
	((MsiFeatureCacheEntry*)(*m_ppTail))->usHash = 0;

#ifdef DEBUG
	DebugDump();
#endif
}

// function to create the cache semaphor in a protected manner
void CFeatureCache::EnsureCacheSemaphore()
{
	if(!TestAndSet(&m_fSemaphoreCreated))
	{
		// semaphore has not been previously created
		Assert(!m_hSemaphore);
		m_hSemaphore = CreateSemaphore(0, 1, 1, 0);
	}
	else
	{
		// semaphore already set OR in the process of being set by another thread
		// wait for other thread to complete the creation of the semaphore
		while(!m_hSemaphore)
		{
			DEBUGMSG(TEXT("FEATURECACHE: waiting till other thread creates semaphore"));
			Sleep(1);
		}
	}
}

void CFeatureCache::Destroy()
{
	if(m_hSemaphore)
		CloseHandle(m_hSemaphore);
}

#ifdef DEBUG
void CFeatureCache::DebugDump()
{
	ICHAR rgchBuffer[512];
	DEBUGMSGV(TEXT("MSI: FEATURE CACHE DUMP -----------------"));
	wsprintf(rgchBuffer, TEXT("MSI: Cache size: %d bytes"), cbCacheSize);
	DEBUGMSGV(rgchBuffer);

#if 0
	DEBUGMSGV("Cache contents (unformatted):");

	int c = 0;
	while (c < cbCacheSize)
	{
		wsprintf(rgchBuffer, "%02X ", *(unsigned char*)(m_rgCache+c));
		DEBUGMSGV(rgchBuffer);

		if (c%20 == 0)
			DEBUGMSGV("\r\n");

		c += sizeof(char);
	}
#endif
	DEBUGMSGV(TEXT("MSI:"));
	DEBUGMSGV(TEXT("MSI:"));
	DEBUGMSGV(TEXT("MSI: Cache contents (formatted):"));

	MsiFeatureCacheEntry* pEntry = (MsiFeatureCacheEntry*)(*m_ppHead);

	int cEntries = 0;

	for (;;)
	{
		wsprintf(rgchBuffer, TEXT("MSI: Offset: %i  Hash: %6u  Feature state: %i   String: %s"), pEntry->cbNextEntryOffset,
			pEntry->usHash, pEntry->usHash ? pEntry->isFeatureState : 0, pEntry->usHash ? (ICHAR*)((char*)&pEntry->isFeatureState + sizeof(INSTALLSTATE)) : TEXT(""));
		DEBUGMSGV(rgchBuffer);
		cEntries++;
		
		if ((char*)pEntry == (*m_ppTail))
			break;
		
		pEntry = (MsiFeatureCacheEntry*)((char*)pEntry + pEntry->cbNextEntryOffset);
	};

	wsprintf(rgchBuffer, TEXT("MSI: Cache entries: %d"), cEntries);
	DEBUGMSGV(rgchBuffer);
	DEBUGMSGV(TEXT("MSI: END FEATURE CACHE DUMP -------------"));
}
#endif


bool CFeatureCache::IsInternallyConsistent()
{
	return true;
}

#ifdef DEBUG
unsigned int CFeatureCache::GetEntryOverhead()
{
	return sizeof(MsiFeatureCacheEntry);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\fdisvr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       fdisvr.cpp
//
//--------------------------------------------------------------------------

//														
// File: fdisvsr.cpp
// Purpose: Implements the FDI Server thread
// Notes:
//____________________________________________________________________________

//////////////////////////////////////////////////////////////////////////////
// Includes and #defines
//////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "_assert.h"
#include "callback.h"
#include "fdisvr.h"
#include "notify.h"
#include "_dgtlsig.h"

//////////////////////////////////////////////////////////////////////////////
// Global data
//////////////////////////////////////////////////////////////////////////////

// We use events for starting\blocking threads in Win32
static HANDLE		s_hInterfaceEvent=INVALID_HANDLE_VALUE;
static HANDLE		s_hServerEvent=INVALID_HANDLE_VALUE;

HANDLE g_hCallbackInterfaceEvent = NULL;
HANDLE g_hCallbackServerEvent = NULL;

// Pointer to shared FDI data -- this is what we use to exchange information between
// the FDI Server and the FDI Interface
FDIShared*          g_pFDIs = NULL; // Not static because callback.cpp needs access

// Handle to FDI
static HFDI			g_hfdi = NULL;

// Error data structures
ERF					g_erf;					// Errors from FDI
FDIServerResponse	g_fdirCallbackError;	// Additional errors from our callbacks
HANDLE              g_hCurDestFile;         // Handle to destination file currently open
IStream* g_pDestFile;				        // Handle to destination stream of Assembly currently open


//////////////////////////////////////////////////////////////////////////////
// Forward function declarations
//////////////////////////////////////////////////////////////////////////////

int					Initialize();
FDIServerCommand	ProcessNextEvent();	
FDIServerCommand	CheckFDIs();
void				DoOpenCabinet();
void				DoClose();
void				DoExtractFileFromCabinet();
void				MainEventLoop();
void				Finish();

//////////////////////////////////////////////////////////////////////////////
// externs function declarations
//////////////////////////////////////////////////////////////////////////////
extern Bool StartFdiImpersonating(bool fNonWrapperCall);
extern void StopFdiImpersonating(bool fNonWrapperCall);


	/* M A I N   /   S T A R T  F D I  S E R V E R*/
/*----------------------------------------------------------------------------
	%%Function: Main / StartFDIServer

	This is the entry-point to the FDI server.This function is started as a
	separate thread by the copy object.
----------------------------------------------------------------------------*/
DWORD WINAPI StartFDIServer(LPVOID fdis)
{
	// Initialize g_pFDIs with pointer to the FDI Interface objects internal
	// shared data
	OLE32::CoInitialize(0);
	g_pFDIs = (FDIShared*)fdis;
	g_pFDIs->fdir = fdirNoResponse;
	
	if (Initialize())
	{
		MainEventLoop();
	}
	else
	{
		// Set an error so we know we failed
		g_pFDIs->fdir = fdirServerDied;
	}

	Finish();
	OLE32::CoUninitialize();
	return 0;
}

/* I N I T I A L I Z E*/
/*----------------------------------------------------------------------------
	%%Function: Initialize
	
	Establishes an FDI context.
----------------------------------------------------------------------------*/
int Initialize()
{
	if (s_hServerEvent == INVALID_HANDLE_VALUE)
	{
		s_hServerEvent = OpenEvent(EVENT_ALL_ACCESS, 0, TEXT("MsiFDIServer"));
		if (!s_hServerEvent)
			return 0;
		else
			MsiRegisterSysHandle(s_hServerEvent);
	}
	if (s_hInterfaceEvent == INVALID_HANDLE_VALUE)
	{
		s_hInterfaceEvent = OpenEvent(EVENT_ALL_ACCESS, 0, TEXT("MsiFDIInterface"));
		if (!s_hInterfaceEvent)
			return 0;
		else
			MsiRegisterSysHandle(s_hInterfaceEvent);
	}

	// Get a handle to an FDI context
	g_hfdi = FDICreate(pfnalloc, pfnfree, pfnopen, 
				     pfnread, pfnwrite, pfnclose,
					 pfnseek, cpuUNKNOWN, &g_erf);

	if (g_pFDIs->fServerIsImpersonated)
		StartFdiImpersonating(false /*wrapper call*/);

	return (g_hfdi != NULL);
}


/* P R O C E S S  N E X T  E V E N T*/
/*----------------------------------------------------------------------------
	%%Function: ProcessNextEvent

	Waits for a command from the FDI interface, and then processes the command.
	
	Returns the FDI server command that was processed.
	Doesn't reset g_pFDIs->fdic
----------------------------------------------------------------------------*/
FDIServerCommand ProcessNextEvent()
{
	// Wait for the FDI Interface to send us an event
	SetEvent(s_hServerEvent);
	DWORD dw = WaitForSingleObject(s_hInterfaceEvent, INFINITE);
	// See if there was any thing for us to do
	return CheckFDIs();
}

/* D O  O P E N  C A B I N E T*/
/*----------------------------------------------------------------------------
	%%Function: DoOpenCabinet

	Opens the cabinet specified by g_pFDIs->achCabinetName and 
	g_pFDIs->achCabinetPath. 
	
	g_pFDIs->fdir is set with the server's response.

----------------------------------------------------------------------------*/
void DoOpenCabinet()
{
	BOOL	fCopyOK;					// FDICopy return value
	ICHAR	achLastCabinetName[256];	// Copy of last cabinet name

	g_pFDIs->fPendingExtract = 0; // No pending extracts


	// FDICopy returns only when it has finished copying all the files
	// beginning in the cabinet we pointed it at.  However, we don't
	// want to return until we've finished an entire *set* of cabinets.
	// So we keep a copy of the last cabinet that we opened, and if we ended
	// up in a different cabinet we know that there are possibly more files
	// in this last cabinet that have not been extracted by FDICopy(), so we
	// call FDICopy() on the last cabinet again.
	// Note: g_pFDIs->achCabinetName will change when FDICopy() requests a 
	// new cabinet (in callback.cpp)
	BOOL fFdiError = FALSE;
	do
	{
		if (g_pFDIs->fSignatureRequired)
		{
			// verify the signature on the CAB to open.
			MsiString strCAB = g_pFDIs->achCabinetPath;
			strCAB += g_pFDIs->achCabinetName;
			
			HRESULT hrWVT = S_OK;
			icsrCheckSignatureResult icsr;

			if (!g_pFDIs->piSignatureCert)
			{
				// something bad has happened!!  The Cert is required, but it is null here
				AssertSz(0, "The certificate is required, but it is null here!");
				g_pFDIs->fdir = fdirBadSignature;
				return;
			}

			icsr = MsiVerifyNonPackageSignature(*strCAB, INVALID_HANDLE_VALUE, *(g_pFDIs->piSignatureCert), g_pFDIs->piSignatureHash, hrWVT);
			
			// if the cabinet signature verifies or crypto is not installed on the machine, we will continue with our attempt to 
			// crack open the cabinet
			//   MsiVerifyNonPackageSignature handles posting to the EventLog in the crypto not installed case
			if (icsrTrusted != icsr && icsrMissingCrypto != icsr)
			{
				// there are 2 different error messages, 1 for Signature Missing, 1 for Invalid Signature
				// we must distinguish here and store the value for the eventual post of the error

				if (icsrNoSignature == icsr) // cabinet did not have signature
					g_pFDIs->fdir = fdirMissingSignature;
				else // cabinet's signature was invalid
					g_pFDIs->fdir = fdirBadSignature;
				
				// store the WVT return code (helps with error message)
				g_pFDIs->hrWVT = hrWVT;
				return;
			}
		}

		g_pFDIs->fdir = fdirNetError;

		// Keep copy of cabinet we're opening
		IStrCopy(achLastCabinetName, g_pFDIs->achCabinetName);

		// FDI forgets to initialize erfOper on re-entry, so we've got to
		g_erf.erfOper = FDIERROR_NONE;

		fCopyOK = FDICopy(g_hfdi,
						const_cast<char*>((const char*) CConvertString(g_pFDIs->achCabinetName)),
						const_cast<char*>((const char*) CConvertString(g_pFDIs->achCabinetPath)),
						0,		// Flags currently appear to be unused.
						fdinotify,
						NULL,	// No decryption routine supplied
						NULL);

		// Our host is done copying files out of the current cabinet, so we can
		// exit now.
		if (!fCopyOK && g_fdirCallbackError == fdirClose)
		{
			DoClose();
			break;
		}

		if (g_fdirCallbackError == fdirUserAbort || g_fdirCallbackError == fdirNetError)
			break;

		// If we had some kind of error we want to get out of this loop - but if g_fdirCallbackError is
		// fdirNeedNextCabinet && erfOper is FDIERROR_USER_ABORT, this is NOT an error - we just need
		// to switch to the next cabinet.
		if ((!fCopyOK) && g_fdirCallbackError != fdirNeedNextCabinet || (g_erf.erfOper != FDIERROR_NONE &&
			g_erf.erfOper != FDIERROR_USER_ABORT))
		{
			fFdiError = TRUE;
			break;
		}
	} while (IStrComp(achLastCabinetName, g_pFDIs->achCabinetName));
	// If all was fine and dandy, ie.
	//	1. There are no files that were requested but not extracted
	//		(g_pFDIs->fPendinfExtract == 0)
	//	2. FDI returned no Errors (g_erf.erfOper == FDIERROR_NONE)
	//	3. Our user aborted with fdicClose and FDI reports FDIERROR_USER_ABORT
	// then we return fdirSuccessfulCompletion
	if (g_fdirCallbackError == fdirUserAbort)
	{
		g_pFDIs->fdir = fdirUserAbort;
	}
	else if (g_fdirCallbackError == fdirNetError)
	{
		g_pFDIs->fdir = fdirNetError;
	}
	else if (!g_pFDIs->fPendingExtract && !fFdiError) 
	{
		g_pFDIs->fdir = fdirSuccessfulCompletion;
	}
	else
	{ 
		// Okay, some kind of error
		// If we had a pending extract and didn't get a create, write or read error
		// then that means that we simply scanned through the whole cabinet
		// ie. a missing file
		if ((g_pFDIs->fPendingExtract) && (g_fdirCallbackError == fdirNoResponse) && fCopyOK)
		{
			g_pFDIs->fdir = fdirFileNotFound;
		}
		else
		{
			// Determine error return code from fdirCallbackError and g_erf.erfOper
			HandleError();
		}
	}
}


/* D O  C L O S E*/
/*----------------------------------------------------------------------------
	%%Function: DoClose

	Destroys the FDI context.
	
	g_pFDIs->fdir is set to fdirSuccessfulCompletion

----------------------------------------------------------------------------*/
void DoClose()
{
	if (g_hfdi)
	{
		FDIDestroy(g_hfdi);
		g_hfdi = NULL;
	}
	g_pFDIs->fdir = fdirSuccessfulCompletion;
}

/* D O  E X T R A C T  F I L E  F R O M  C A B I N E T*/
/*----------------------------------------------------------------------------
	%%Function: DoExtractFileFromCabinet

	We're only supposed to receive this inside an FDICopy call!
----------------------------------------------------------------------------*/
void DoExtractFileFromCabinet()
{
	g_pFDIs->fdir = fdirNoCabinetOpen;
}

/* C H E C K  F D I S*/
/*----------------------------------------------------------------------------
	%%Function: CheckFDIs

	Processes a pending FDI command, if there is one.
----------------------------------------------------------------------------*/
FDIServerCommand CheckFDIs()
{
	if (g_pFDIs)
	{
		//NotifyUser("FDI Server: Checking for command");
		switch (g_pFDIs->fdic)
		{
			case fdicOpenCabinet:
			{
				DoOpenCabinet();
				break;
			}
			case fdicClose:
			case fdicCancel:
			{
				DoClose();
				break;
			}
			case fdicExtractFile:
			{
				DoExtractFileFromCabinet();
				break;
			}
			case fdicNoCommand:
			{
				break;
			}
			default:
			{
				// ought to crash and burn horribly if we ever get here
				NotifyUser("FDI Server:Illegal FDI command received");
				g_pFDIs->fdir = fdirIllegalCommand;
			}
		}
		return g_pFDIs->fdic;
	}
	else return fdicNoCommand;
}

/* M A I N  E V E N T  L O O P*/
/*----------------------------------------------------------------------------
	%%Function: MainEventLoop

	Processes events until the FDI server is given the "close" 
	command.
----------------------------------------------------------------------------*/
void MainEventLoop()
{
	FDIServerCommand fdic;

	do
	{
		fdic = ProcessNextEvent();
		// Clear command now that we've handled it
		g_pFDIs->fdic = fdicNoCommand;
	} while (fdic != fdicClose);
}


/* F I N I S H */
/*----------------------------------------------------------------------------
	%%Function: Finish

	Does any necessary cleanup before the server is shut down.
----------------------------------------------------------------------------*/
void Finish()
{	
	if (g_pFDIs->fServerIsImpersonated)
			StopFdiImpersonating(false /*wrapper call*/);

	if (g_pFDIs->hClientToken != INVALID_HANDLE_VALUE)
		AssertNonZero(MsiCloseSysHandle(g_pFDIs->hClientToken));
	if (g_pFDIs->hImpersonationToken != INVALID_HANDLE_VALUE)
		AssertNonZero(MsiCloseSysHandle(g_pFDIs->hImpersonationToken));

	g_pFDIs->hClientToken = INVALID_HANDLE_VALUE;
	g_pFDIs->hImpersonationToken = INVALID_HANDLE_VALUE;

	SetEvent(s_hServerEvent);

	// We must reset the event handles, because FDIServer
	// can be launched again via automation without 
	// unloading the Services DLL.
	if (s_hInterfaceEvent != INVALID_HANDLE_VALUE)
	{
		AssertNonZero(MsiCloseSysHandle(s_hInterfaceEvent));
		s_hInterfaceEvent = INVALID_HANDLE_VALUE;
	}
	if (s_hServerEvent != INVALID_HANDLE_VALUE)
	{
		AssertNonZero(MsiCloseSysHandle(s_hServerEvent));
		s_hServerEvent = INVALID_HANDLE_VALUE;
	}

	if (g_hCallbackInterfaceEvent != NULL)
	{
		AssertNonZero(MsiCloseSysHandle(g_hCallbackInterfaceEvent));
		g_hCallbackInterfaceEvent = NULL;
	}
	if (g_hCallbackServerEvent != NULL)
	{
		AssertNonZero(MsiCloseSysHandle(g_hCallbackServerEvent));
		g_hCallbackServerEvent = NULL;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\imemory.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       imemory.cpp
//
//--------------------------------------------------------------------------

//
// File: imemory.cpp
// Purpose: CMsiMalloc implementation
// Owner: davidmck
// Notes:
//
//CMsiMalloc: Memory handling object


#include "precomp.h"
#include "services.h"
#include "imemory.h"
#include <typeinfo.h>
#include <stdlib.h>
#include "_service.h"

#if (!defined(MAC) && defined(DEBUG))
#include "imagehlp.h"
#endif //!MAC && DEBUG

#include "kjalloc.h"

#define STATIC_LIB_DEF	1

#include "msoalloc.h"


//____________________________________________________________________________
//
// CMsiMalloc definition - here so this can be a member of services
//____________________________________________________________________________

#ifdef DEBUG

#define cBlockBuckets		512
#define cSkipBits			7		// Bits to skip for hashing
#define cHashBits			9		// Bits to use for hashing
#define maskHashBits		0x1ff

#define cDeadSpace	4

#define cFuncTrace	5

typedef struct _MBH	{			// Memory block header
	unsigned long	rgaddr[cFuncTrace];	// Address from which the allocation occurred
	struct _MBH *pmbhNext;		// Linked list of memory blocks
	const type_info *pti;		// Pointer to the type_info block that
					// this object is the type of. 0 if not object
	long cbAlloc;		// Size of the allocation
	long lRequest;		// Which memory allocation was this
	BOOL fObject;		// Is this an object with a vtable to be faked
					// at free time
	BOOL fRTTI;			// Can we look at the RTTI info for this object
	BOOL fLeakReported;	// Has an error already been reported
	BOOL fCorruptionReported;	// Has a corruption error been reported
	unsigned long lDeadSpace[cDeadSpace];// Longs to buffer the header from the memory
					// Used by darwin
	} MBH;
#endif //DEBUG

class CMsiMalloc : 
				public IMsiMalloc
#ifdef DEBUG
				, public IMsiDebugMalloc
#endif //DEBUG
				
{
 public:   // implemented virtual functions
	HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long   __stdcall AddRef();
	unsigned long   __stdcall Release();
	void*         	__stdcall Alloc(unsigned long cb);
	void*         	__stdcall AllocObject(unsigned long cb);
	void          	__stdcall Free(void* pv);
	void			__stdcall FreeObject(void *pv);
	void*         	__stdcall AllocEx(unsigned long cb, unsigned long *plAddr);
	void*         	__stdcall AllocObjectEx(unsigned long cb, unsigned long *plAddr, bool fRTTI);
	void			__stdcall FreeAllocator();
	void            __stdcall HandleOutOfMemory();
#ifdef DEBUG
	BOOL			__stdcall FAllBlocksFreed(void);
 public:	// implemented in IMsiDebugMalloc
	void		    __stdcall SetDebugFlags(int gpfMemDebug);
	void		  	__stdcall ReturnBlockInfoPv(void *pv, TCHAR *pszInfo, int cchSzInfo);
	BOOL			__stdcall FGetFunctionNameFromAddr(unsigned long lAddr, char *pszFnName, unsigned long *pdwDisp);
	BOOL			__stdcall FCheckBlock(void *pv);
	int		   	 	__stdcall GetDebugFlags();
	BOOL			__stdcall FCheckAllBlocks();
	unsigned long	__stdcall GetSizeOfBlock(void *pv);
#endif //DEBUG
	
 public:  // constructor/destructor
	CMsiMalloc();
#ifdef DEBUG
	~CMsiMalloc();
#endif //DEBUG
  	void *operator new(size_t cb) { return AllocSpc(cb); }
 	void operator delete(void *pv) {FreeSpc(pv); }
	BOOL	m_fInitOfficeHeap;
#ifdef DEBUG
 	BOOL	m_fKeepMemory;		// Do we keep the freed memory around
 	BOOL	m_fLogAllocs;		// Do we log allocations
 	BOOL	m_fCheckOnAlloc;	// Do we check all current blocks when allocating a new one
 	BOOL	m_fCheckOnFree;		// Do we check all current blocks when freeing a block
 	bool	m_fNoPreflightInit;	// True when we don't want to initialize before we need it.
#endif //DEBUG
protected:	// State data
	int     m_iRefCnt;
#ifdef DEBUG
 	MBH*	m_pmbhFreed;		// Pointer to the free list
 	long	m_lcbTotal;			// Total memory allocated
 	long	m_cBlocksCur;		// How many blocks are currently allocated
 	long	m_cBlocksTotal;		// How many blocks have we allocated since start
#endif //DEBUG 	
private:
#ifdef DEBUG
					// Removes the block of memory from the linked list. 
					// Returns true if it found it
	BOOL			FRemoveBlock(MBH* pmbh);	 
	BOOL			FWasFreed(MBH *pmbh);
	void			__stdcall FreeProc(void *pv, unsigned long *lAddr, bool fObject);
	void*			__stdcall AllocProc(unsigned long cb, unsigned long *plAddr);
	void			__stdcall ReturnBlockInfo(MBH *pmbh, TCHAR *szInfo, int cch);
	void			__stdcall SzFromFunctionAddress(TCHAR *szAddress, long lAddress);
	BOOL			__stdcall FCheckMbh(MBH *pmbh);
	BOOL			__stdcall FIsAllocatedBlock(MBH *pmbh);
	void			__stdcall DisplayBlockInfo(MBH *pmbh, const TCHAR *szTitle);
	void 			InitSymbolInfo(bool fLoadModules);
	short			IHashValue(void *);
	void			InsertInMemList(MBH* pmbh);
	CRITICAL_SECTION m_crsMemAccess;
	MBH*	m_rgpmbhBlocks[cBlockBuckets];		// Array of hash buckets
#else
	void			__stdcall FreeProc(void *pv);
	void*			__stdcall AllocProc(unsigned long cb);
#endif //DEBUG
};	

#ifdef DEBUG
static BOOL (__stdcall *pfnMemAlloc)(void** ppMem, int cb, int dg, const CHAR* szFile, int iLine);
#else
static BOOL (__stdcall *pfnMemAlloc)(void** ppMem, int cb, int dg);
#endif // DEBUG
static void (__stdcall *pfnMemFree)(void* pMem, int cb);

MSOEXTERN_C_BEGIN
#ifdef DEBUG
BOOL __stdcall HeapMemAlloc(void** ppMem, int cb, int /*dg*/, const CHAR*, int)
#else
BOOL __stdcall HeapMemAlloc(void** ppMem, int cb, int /*dg*/)
#endif
{
	*ppMem = AllocSpc(cb);
	return *ppMem != NULL ? TRUE : FALSE;
}

void __stdcall HeapMemFree(void* pMem, int /*cb*/)
{
	FreeSpc(pMem);
}
MSOEXTERN_C_END

const int cchTempBuffer = 256;  

#ifdef DEBUG

BOOL FGetFunctionNameFromAddr(unsigned long lAddr, char *pszFnName, unsigned long *pdwDisp);
void FreedClassWarning( void *pThis );
int IClassFromPmbh(MBH *pmbh);

#define lFreeSpaceCnst	0xdeadf00dUL
#define lDeadSpaceCnst	0xdedededeUL
#define lNewSpaceCnst	0xa5

#define cbMBH	(sizeof(MBH))

#define cpfnMax		100
LONG_PTR rgpfnFake[cpfnMax];		//--merced: changed long to LONG_PTR

//
// A list of object classes in order from outer-most to inner-most
// in general, if class A appears before class B, class A adds a reference
// to class B.
//
char *rgszClasses[] = {
		"CMsiCursor",
		"CMsiView",
		"CMsiTable",
		"CCatalogTable",
		"CMsiDatabase",
		"CMsiStorage",
		"CMsiRecord",
		"CMsiRegKey",
		"CMsiString",
		"CMsiStringRef"
};

#define cClasses	(sizeof(rgszClasses)/sizeof(char *))

#else
#define cbMBH	0
// Free proc has only 1 parameter in ship
#define FreeProc(x, y, f)	FreeProc(x)
#define AllocProc(x, y)	AllocProc(x)
#endif //DEBUG

Debug(CMsiDebug vDebug;)
CMsiMalloc	vMalloc;
#ifdef TRACK_OBJECTS
CMsiRefHead g_refHead;
#endif //TRACK_OBJECTS

extern IMsiMalloc *piMalloc;

#ifdef DEBUG
BOOL FCheckAllBlocks()
{
	return vMalloc.FAllBlocksFreed();
}
#endif //DEBUG

void InitializeMsiMalloc()
{
	vMalloc.AddRef();
	piMalloc = &vMalloc;

#ifdef DEBUG

	vMalloc.m_fKeepMemory = GetTestFlag('K');
	vMalloc.m_fLogAllocs = GetTestFlag('M');
	vMalloc.m_fCheckOnAlloc = GetTestFlag('A');
	vMalloc.m_fCheckOnFree = GetTestFlag('F');
	g_fNoPreflightInits = vMalloc.m_fNoPreflightInit = true;

#endif //DEBUG
	if (!vMalloc.m_fInitOfficeHeap)
	{
		InitOfficeHeap();
		vMalloc.m_fInitOfficeHeap = true;
		// on NT >= 5 we will not use Office's memory allocator
#ifdef WIN64
		bool fUseSystemAlloc = true;
#else
		bool fUseSystemAlloc = MinimumPlatform(false, 5, 0) ? true : false;
#endif
		if ( fUseSystemAlloc )
		{
			pfnMemAlloc = HeapMemAlloc;
			pfnMemFree = HeapMemFree;
		}
		else
		{
			pfnMemAlloc = MsoFAllocMemCore;
			pfnMemFree = MsoFreeMem;
		}

	}

}

void FreeMsiMalloc(bool fFatalExit)
{

	if (!fFatalExit)
		vMalloc.Release();
	else
	{
		vMalloc.FreeAllocator();
	}

}

//
// This is an emergency situation
//
void CMsiMalloc::FreeAllocator()
{
	KillRecordCache(fTrue);
#ifdef DEBUG
	int i;
	for ( i = 0 ; i < cBlockBuckets ; i++)
		m_rgpmbhBlocks[i] = 0;
#endif //DEBUG
	MsoFreeAll();
	m_iRefCnt = 0;
	if (m_fInitOfficeHeap)
	{
		EndOfficeHeap();
		m_fInitOfficeHeap = false;
	}
	piMalloc = 0;
	
}

CMsiMalloc::CMsiMalloc()
#ifdef DEBUG
: m_lcbTotal(0), m_cBlocksCur(0), 
	m_cBlocksTotal(0), m_fKeepMemory(0),
	m_pmbhFreed(0)
#endif //DEBUG
{
#ifdef DEBUG
	for (int i = 0 ; i < cpfnMax ; i++)
		rgpfnFake[i] = (LONG_PTR)FreedClassWarning;	//--merced: changed long to LONG_PTR
	InitializeCriticalSection(&m_crsMemAccess);

	for ( i = 0 ; i < cBlockBuckets ; i++)
		m_rgpmbhBlocks[i] = 0;

#endif //DEBUG

	m_fInitOfficeHeap = false;
	m_iRefCnt = 0;
}

#ifdef DEBUG
CMsiMalloc::~CMsiMalloc()
{

	// Need to do this because services has gone away
	g_AssertServices = 0;

	if (m_iRefCnt > 0)
	{
		// AssertSz(false, "CMsiMalloc not released");
		if ( g_scServerContext == scService )  //!! eugend: temporary hack till I figure out how to fix 138538
			FAllBlocksFreed();
	}
	else if (m_iRefCnt < 0)
		AssertSz(false, "CMsiMalloc released too many times");

	g_fFlushDebugLog = false;
	extern int g_rcRows;
	Assert(g_rcRows == 0);
	DeleteCriticalSection(&m_crsMemAccess);
	
}
#endif //DEBUG


HRESULT CMsiMalloc::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IMsiMalloc)
		*ppvObj = (IMsiMalloc *)this;
#ifdef DEBUG
	else if (riid == IID_IMsiDebugMalloc)
		*ppvObj = (IMsiDebugMalloc*)this;
#endif //DEBUG
	else
		return (*ppvObj = 0, E_NOINTERFACE);
	AddRef();
	return NOERROR;
}

unsigned long CMsiMalloc::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiMalloc::Release()
{
#ifdef DEBUG
	if (!m_fNoPreflightInit)
		InitSymbolInfo(false);
#endif //DEBUG
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	Debug(FAllBlocksFreed();)
	if (m_fInitOfficeHeap)
	{
		EndOfficeHeap();
		m_fInitOfficeHeap = false;
	}
	piMalloc = 0;
	return 0;
}

/*********************************************************
*
* Alloc allocates the memory and sets it to 0
*
**********************************************************/
void * CMsiMalloc::Alloc(unsigned long cb)
{
	Debug(GetCallingAddrMember(lCallAddr, cb));

	return AllocProc(cb, lCallAddr);
}

#pragma warning(disable : 4100) // unreferenced formal parameter
void * CMsiMalloc::AllocEx(unsigned long cb, unsigned long *plCallAddr)
{

	return AllocProc(cb, plCallAddr);
}
#pragma warning(3 : 4100)

void * CMsiMalloc::AllocProc(unsigned long cb, unsigned long *plCallAddr)
{
	void *pbNew;

	AssertSz(m_fInitOfficeHeap, "Allocator not initialized");

#ifdef DEBUG
	int cbOrig = cb;

	EnterCriticalSection(&m_crsMemAccess);
	cb += sizeof(MBH) + cDeadSpace * sizeof(long);

	if (m_fCheckOnAlloc)
		FCheckAllBlocks();
#endif //DEBUG

	void* pv;

#ifdef DEBUG
	while (!pfnMemAlloc(&pv, cb+sizeof(MSOSMH), msodgMisc, NULL, __LINE__))
#else
	while (!pfnMemAlloc(&pv, cb+sizeof(MSOSMH), msodgMisc))
#endif
	{
		::HandleOutOfMemory();
	}

	((MSOSMH*)pv)->cb = cb;
	pbNew = ((MSOSMH*)pv)+1;

#ifdef DEBUG
	MBH *pmbh;

	if (pbNew != 0)
	{
		unsigned long UNALIGNED *plFill, *plFillMax;
				
		// Keep up the linked list in the allocator
		pmbh = (MBH *)pbNew;
		pmbh->pti = 0;
		pmbh->cbAlloc = cbOrig;
		pmbh->lRequest = m_cBlocksTotal;
		FillCallStackFromAddr(pmbh->rgaddr, cFuncTrace, 0, plCallAddr);
		pmbh->fObject = false;
		pmbh->fLeakReported = false;
		pmbh->fCorruptionReported = false;
		pmbh->fRTTI = false;
		
		// Fill the space at the front of the block
		for (plFill = &(pmbh->lDeadSpace[0]), 
				plFillMax = plFill + 4;
				plFill < plFillMax ; plFill++)
		{
			*plFill = lDeadSpaceCnst;
		}
		memset((char *)pbNew + cbMBH, lNewSpaceCnst, cbOrig);
			
		for (plFill = (unsigned long *)((char *)pmbh + sizeof(MBH) + cbOrig),
				plFillMax = plFill + cDeadSpace ;
				plFill < plFillMax ;
				plFill++)
		{
			*plFill = lDeadSpaceCnst;
		}

		InsertInMemList(pmbh);

		pbNew = (char *)pbNew + sizeof(MBH);
		m_lcbTotal += cbOrig;
		m_cBlocksCur++;
		m_cBlocksTotal++;

	}

	if (m_fLogAllocs)
	{
		TCHAR szMessage[1024];
#define cCallStackLog	5
		unsigned long rgCallAddr[cCallStackLog];
		
		FillCallStackFromAddr(rgCallAddr, cCallStackLog, 0, plCallAddr);
		
		wsprintf(szMessage, TEXT("Allocation -\t%d\tbytes. Memory Address - \t0x%x\t"),
				cbOrig, pbNew);		
				
		ListSzFromRgpaddr(szMessage, sizeof(szMessage)/sizeof(TCHAR) - lstrlen(szMessage), rgCallAddr, cCallStackLog, false);

		extern IMsiDebug* g_piDebugServices;
		if (g_AssertServices && g_AssertServices->LoggingEnabled())
			g_AssertServices->WriteLog(szMessage);
		else if(g_piDebugServices)
			g_piDebugServices->WriteLog(szMessage);

	}
	LeaveCriticalSection(&m_crsMemAccess);
#endif //DEBUG

	return pbNew;
}

void *CMsiMalloc::AllocObject(unsigned long cb)
{
	Debug(GetCallingAddrMember(lAddr, cb));
	
	void *pvNew = AllocProc(cb, lAddr);

#ifdef DEBUG
	if (pvNew != 0)
	{
		MBH *pmbhNew = (MBH *)((char *)pvNew - cbMBH);

		pmbhNew->fObject = true;
		pmbhNew->fRTTI = false;
	}
#endif //DEBUG
	return pvNew;

}

#pragma warning(disable : 4100) // unreferenced formal parameter
void *CMsiMalloc::AllocObjectEx(unsigned long cb, unsigned long *plAddr, bool fRTTI)
{
	
	void *pvNew = AllocProc(cb, plAddr);

#ifdef DEBUG
	if (pvNew != 0)
	{
		MBH *pmbhNew = (MBH *)((char *)pvNew - cbMBH);

		pmbhNew->fObject = true;
		pmbhNew->fRTTI = fRTTI;
	}
#endif //DEBUG
	return pvNew;

}
#pragma warning(3 : 4100)

void CMsiMalloc::Free(void* pv)
{
#ifdef DEBUG
	GetCallingAddrMember(lCallAddr, pv);
#endif //DEBUG
	FreeProc(pv, lCallAddr, false);
}

//
// FreeObject
//
void CMsiMalloc::FreeObject(void* pv)
{
	
#ifdef DEBUG
	GetCallingAddrMember(lCallAddr, pv);
#endif //DEBUG
	FreeProc(pv, lCallAddr, true);
}

//
// FreeProc -
// Routine to do the freeing, allows Free and Free Object to
// do their thing
//
void CMsiMalloc::FreeProc(void *pv, unsigned long * lAddr, bool fObject)
{
#ifdef DEBUG
	MBH *pmbh;
	unsigned long *plFill, *plFillMax;

	if ((ULONG_PTR)pv < sizeof(MBH))		//--merced: changed unsigned long to ULONG_PTR
	{
		AssertSz(false, "Invalid Pointer");
		return;
	}
			
	pmbh = (MBH *)(((char *)pv) - sizeof(MBH));

	if (m_fLogAllocs)
	{
		TCHAR szMessage[2048];
		TCHAR szInfo[1024];
		unsigned long rgCallAddr[cCallStackLog];
		
		FillCallStackFromAddr(rgCallAddr, cCallStackLog, 0, lAddr);

		szInfo[0] = 0;
		wsprintf(szMessage, TEXT("Freeing memory \t%s\t Address\t0x%x\t"), szInfo, pv);		
				
		ListSzFromRgpaddr(szMessage, sizeof(szMessage)/sizeof(TCHAR) - lstrlen(szMessage), rgCallAddr, cCallStackLog, false);

		extern IMsiDebug* g_piDebugServices;
		if (g_AssertServices && g_AssertServices->LoggingEnabled())
			g_AssertServices->WriteLog(szMessage);
		else if(g_piDebugServices)
			g_piDebugServices->WriteLog(szMessage);

	}

	EnterCriticalSection(&m_crsMemAccess);
	
	if (!FRemoveBlock(pmbh))
		{
		if (FWasFreed(pmbh))
			{
			TCHAR szMessage[1024];
			wsprintf(szMessage,TEXT("Memory doubly freed from %lh"), pmbh->lDeadSpace[0]);
			AssertSz(false, szMessage);
			}
		else
			AssertSz(false, "Invalid block to Free");
		LeaveCriticalSection(&m_crsMemAccess);
		return;
		}

	if (fObject)
		AssertSz(pmbh->fObject, "Non-object freed by Object call");
	else
		AssertSz(!pmbh->fObject, "Object freed by non-object free");

	Assert(FCheckMbh(pmbh));
			
	if (m_fCheckOnFree)
		FCheckAllBlocks();
		
	// Reduce the totals for count of bytes allocated and count of
	// allocated blocks
	m_lcbTotal -= pmbh->cbAlloc;
	m_cBlocksCur--;

	if (fObject && pmbh->fRTTI)
		pmbh->pti = &(typeid(*(IUnknown *)pv));
	
	// Fill up memory with garbage
	for (plFill = (unsigned long *)((char *)pmbh + sizeof(MBH)),
			plFillMax = plFill + (pmbh->cbAlloc/sizeof(unsigned long));
			plFill < plFillMax;
			plFill++)
	{
		*plFill = lFreeSpaceCnst;
	}

	pmbh->pmbhNext = 0;	

	LeaveCriticalSection(&m_crsMemAccess);

	void *pvtbl = pv;

	if (fObject)
		*(LONG_PTR *)pvtbl = (LONG_PTR)&rgpfnFake;		//--merced: changed from long to LONG_PTR (twice)
	
	if (m_fKeepMemory)
	{
		// In this case we don't want to actually free the memory
		pmbh->pmbhNext = m_pmbhFreed;
		m_pmbhFreed = pmbh;
		pmbh->lDeadSpace[0] = *lAddr;
		return;
	}		

	pv = pmbh;
#endif //DEBUG
	

#ifdef WIN
#ifdef GLOBAL_ALLOC
	GlobalFree(pv);
#else
	MSOSMH* psmh = (MSOSMH*)pv - 1;
	pfnMemFree(psmh, psmh->cb+sizeof(MSOSMH));
#endif //GLOBAL_ALLOC
#else
	DisposePtr((char *)pv);
#endif //Win
}

void CMsiMalloc::HandleOutOfMemory()
{

	::HandleOutOfMemory();

}

#ifdef DEBUG
/**************************************************
*
* CMsiMalloc::FRemoveBlock
* Scans the linked list to find the block of memory
*
**************************************************/
BOOL CMsiMalloc::FRemoveBlock(MBH* pmbh)
{
	MBH *pmbhCur;
	MBH **ppmbhOld;

	int iHash = IHashValue(pmbh);
	pmbhCur = m_rgpmbhBlocks[iHash];
	ppmbhOld = &(m_rgpmbhBlocks[iHash]);

	while (pmbhCur != 0)
	{
		if (pmbhCur == pmbh)
		{
			*ppmbhOld = pmbhCur->pmbhNext;
			return true;
		}
		ppmbhOld = &(pmbhCur->pmbhNext);
		pmbhCur = pmbhCur->pmbhNext;
	}

	return false;

}

//
// Returns true if the memory is in the free pool
//
BOOL CMsiMalloc::FWasFreed(MBH* pmbh)
{
	MBH *pmbhCur;

	pmbhCur = m_pmbhFreed;

	while (pmbhCur != 0)
	{
		if (pmbhCur == pmbh)
		{
			return true;
		}
		pmbhCur = pmbhCur->pmbhNext;
	}

	return false;

}


void CMsiMalloc::SetDebugFlags(int grpfMemDebug)
{

	m_fKeepMemory = (grpfMemDebug & bfKeepMem);
	m_fLogAllocs = (grpfMemDebug & bfLogAllocs);
	m_fCheckOnAlloc = (grpfMemDebug & bfCheckOnAlloc);
	m_fCheckOnFree = (grpfMemDebug & bfCheckOnFree);
	g_fNoPreflightInits = m_fNoPreflightInit = ((grpfMemDebug & bfNoPreflightInit) ? true : false);


}

int CMsiMalloc::GetDebugFlags(void)
{
	int t = 0;

	if (m_fKeepMemory)
		t |= bfKeepMem;

	if (m_fLogAllocs)
		t |= bfLogAllocs;

	if (m_fCheckOnAlloc)
		t |= bfCheckOnAlloc;

	if (m_fCheckOnFree)
		t |= bfCheckOnFree;

	return t;
	
}

void CMsiMalloc::InitSymbolInfo(bool fLoadModules)
{
	::InitSymbolInfo(fLoadModules);
}

BOOL CMsiMalloc::FGetFunctionNameFromAddr(unsigned long lAddr, char *pszFnName, unsigned long *pdwDisp)
{
	::FGetFunctionNameFromAddr(lAddr, pszFnName, pdwDisp);

	return false;

}

//
// Searches the rgszClasses array for the class that pmbh is a member of
//
int IClassFromPmbh(MBH *pmbh)
{
	int i;
	const char *pstName;
	
	if (pmbh->fObject && pmbh->fRTTI)
		{
		const type_info& rtyp = typeid(*(IUnknown *)((char *)pmbh + cbMBH));
		pstName = rtyp.name();
		}
	else
		{
		pstName = "class Unknown";
		if (pmbh->pti != 0)
			pstName = pmbh->pti->name();
		}


	for (i = 0 ; i < cClasses ; i++)
	{
		// Skip over the "class " part of the string
		if (!lstrcmpA(pstName+6, rgszClasses[i]))
			break;
	}

	return i;
}

BOOL CMsiMalloc::FAllBlocksFreed()
{
	MBH *pmbh;
	int rgcLeft[cClasses + 1];
	int iClass;
	TCHAR rgchMsg[(cClasses + 2) * 50];	
	TCHAR *pchMsg;
	int ich;
	bool fHaveLeak = false;
	
	//
	// First give a general list of all the blocks left over
	//
	memset(rgcLeft, 0, sizeof(rgcLeft));

	int i;
	
	for (i = 0 ; i < cBlockBuckets ; i++)
	{
		pmbh = m_rgpmbhBlocks[i];

		if (pmbh != 0)
			fHaveLeak = true;
			
		while (pmbh != 0)
		{
			iClass = IClassFromPmbh(pmbh);					
			rgcLeft[iClass]++;
			pmbh = pmbh->pmbhNext;
		}
	}

	if (fHaveLeak)
	{
		ich = wsprintf(rgchMsg, TEXT("Leaked Objects:"));
		pchMsg = rgchMsg + ich;
		for (iClass = 0 ; iClass < cClasses ; iClass++)
		{
			if (rgcLeft[iClass] == 0)
				continue;
			ich = wsprintf(pchMsg, TEXT("\r\n%30hs \t-%3d"), rgszClasses[iClass], rgcLeft[iClass]);
			pchMsg += ich;
		}
		wsprintf(pchMsg, TEXT("\r\n%30s \t-%3d"), TEXT("Unknown"), rgcLeft[iClass]);
//		FailAssertMsg(rgchMsg);
		OutputDebugString(rgchMsg);
		OutputDebugString(TEXT("\r\n"));
	}

	
	// Need to check that all blocks were freed
	fHaveLeak = false;
	for (i = 0 ; i < cBlockBuckets ; i++)
	{
		pmbh = m_rgpmbhBlocks[i];

		while (pmbh != 0)
		{
			fHaveLeak = true;
			if (!pmbh->fLeakReported)
			{
				DisplayBlockInfo(pmbh, (const TCHAR *)TEXT("Memory leak"));
				pmbh->fLeakReported = true;
			}
			pmbh = pmbh->pmbhNext;
		}

	}

	return !fHaveLeak;
}

//
// Routine to display information about the passed in block
//
void CMsiMalloc::DisplayBlockInfo(MBH *pmbh, const TCHAR *szTitle)
{
	TCHAR szMsg[cchTempBuffer * 5];
	TCHAR szInfo[cchTempBuffer * 5];
	TCHAR *pch;
	
	ReturnBlockInfo(pmbh, szInfo, sizeof(szInfo)/sizeof(TCHAR));

	if (lstrlen(szTitle) + lstrlen(szInfo) + 3 > sizeof(szMsg)/sizeof(TCHAR))
		pch = szInfo;
	else
	{
		wsprintf(szMsg, TEXT("%s\r\n%s"), szTitle, szInfo);
		pch = szMsg;
	}
//	FailAssertMsg(pch);
	OutputDebugString(pch);
	OutputDebugString(TEXT("\r\n"));
}

void CMsiMalloc::ReturnBlockInfoPv(void *pv, TCHAR *pszInfo, int cchSzInfo)
{
	MBH *pmbh;

	pmbh = (MBH *)(((char *)pv) - cbMBH);
	
	ReturnBlockInfo(pmbh, pszInfo, cchSzInfo);

}

void CMsiMalloc::ReturnBlockInfo(MBH *pmbh, TCHAR *szInfo, int cchSzInfo)
{
	const IMsiString *piString;
	const char *pstName;
	const TCHAR *pchString;
#ifdef WIN
	MEMORY_BASIC_INFORMATION memInfo;
#endif //WIN

	BOOL fSaveLog = m_fLogAllocs;
	m_fLogAllocs = false;
	
	if (pmbh->fObject && pmbh->fRTTI)
		{
		IMsiData *pData = 0;
		IMsiRecord *pRec = 0;
		
		pRec = dynamic_cast<IMsiRecord *>((IUnknown *)((char *)pmbh + cbMBH));
		if (pRec != 0 && g_AssertServices != 0)
		{
			const IMsiString& riString = pRec->FormatText(fTrue);
			piString = &riString;
		}
		else
		{
			pData = dynamic_cast<IMsiData *>((IUnknown *)((char *)pmbh + cbMBH));
			if (pData != 0)
			{
				piString = &pData->GetMsiStringValue();
				VirtualQuery((void *)piString, &memInfo, sizeof(memInfo));
				if (memInfo.State == MEM_FREE)
					piString = MsiString(*TEXT(""));	
			}
			else
				piString = MsiString(*TEXT(""));	
		}
		const type_info& rtyp = typeid(*(IUnknown *)((char *)pmbh + cbMBH));
		pstName = rtyp.name();
		}
	else
		{
		piString = MsiString(*TEXT(""));
		pstName = "Unknown";
		if (pmbh->pti != 0)
			pstName = pmbh->pti->name();
		}

	TCHAR szAddress[cchTempBuffer * cFuncTrace];

	szAddress[0] = 0;
	ListSzFromRgpaddr(szAddress, sizeof(szAddress)/sizeof(TCHAR), pmbh->rgaddr, cFuncTrace, true);
	pchString = piString->GetString();

	// For some odd reason we are getting freed memory pages in here
	VirtualQuery(pchString, &memInfo, sizeof(memInfo));
	if (memInfo.State == MEM_FREE)
		pchString = TEXT("");

	static const TCHAR pvFormat[] = TEXT("%d bytes at 0x%x allocated from:\r\n%sObject type:%hs\r\nObject string: [%s]\r\nAllocation Request: %d");

	// See if we are small enough to fit in the string, assume that the address is 8 characters,
	// the size is 6 characters, the request number is 6 characters
	if ((sizeof(pvFormat)/sizeof(TCHAR) + 6 + 8 + lstrlen(szAddress) + lstrlenA(pstName) + lstrlen(pchString) + 6)
			> cchSzInfo)
	{
		// If not large enough, assume that we have enough space without the list of addresses
		szAddress[0] = 0;
	}
	
	wsprintf(szInfo, pvFormat, 
					pmbh->cbAlloc, ((char *)pmbh) + cbMBH, szAddress, 
					pstName, pchString, pmbh->lRequest);

	piString->Release();
	m_fLogAllocs = fSaveLog;
}

void CMsiMalloc::SzFromFunctionAddress(TCHAR *szAddress, long lAddress)
{
	::SzFromFunctionAddress(szAddress, lAddress);
}

BOOL CMsiMalloc::FCheckMbh(MBH *pmbh)
{
	unsigned long UNALIGNED *plFill, *plFillMax;

	// Ensure that the dead space has not been trashed in front
	for (plFill = &(pmbh->lDeadSpace[0]), 
			plFillMax = plFill + 4;
			plFill < plFillMax ; plFill++)
	{
		if (*plFill != lDeadSpaceCnst)
			return false;
	}

	// ... in back
	for (plFill = (unsigned long *)((char *)pmbh + sizeof(MBH) + pmbh->cbAlloc),
			plFillMax = plFill + cDeadSpace ;
			plFill < plFillMax ;
			plFill++)
	{
		if (*plFill != lDeadSpaceCnst)
			return false;
	}

	return true;
}


BOOL CMsiMalloc::FCheckBlock(void *pv)
{
	MBH *pmbh;

	if ((ULONG_PTR)pv < sizeof(MBH))		//--merced: changed unsigned long to ULONG_PTR
	{
		return false;
	}
			
	pv = ((char *)pv) - sizeof(MBH);
	pmbh = (MBH *)pv;

	if (!FIsAllocatedBlock(pmbh))
		return false;

	return FCheckMbh(pmbh);
	
}

unsigned long CMsiMalloc::GetSizeOfBlock(void *pv)
{
	MBH *pmbh;

	if ((ULONG_PTR)pv < sizeof(MBH))	//--merced: changed unsigned long to ULONG_PTR
	{
		return 0;
	}
			
	pv = ((char *)pv) - sizeof(MBH);
	pmbh = (MBH *)pv;

	if (!FIsAllocatedBlock(pmbh))
		return 0;

	return pmbh->cbAlloc;
	
}

//
// Returns true if this is actually an allocated block from
// our memory allocation
//
BOOL CMsiMalloc::FIsAllocatedBlock(MBH *pmbh)
{
	MBH *pmbhCur;

	int iHash = IHashValue(pmbh);
	pmbhCur = m_rgpmbhBlocks[iHash];

	while (pmbhCur != 0)
	{
		if (pmbhCur == pmbh)
		{
			return true;
		}
		pmbhCur = pmbhCur->pmbhNext;
	}

	return false;

}

BOOL CMsiMalloc::FCheckAllBlocks(void)
{
	MBH *pmbhCur;
	BOOL fAllOk = true;
	
	int i;

	for (i = 0 ; i < cBlockBuckets ; i++)
	{
		pmbhCur = m_rgpmbhBlocks[i];

		while (pmbhCur != 0)
		{
			if (!pmbhCur->fCorruptionReported && !FCheckMbh(pmbhCur))
			{
				fAllOk = false;
				DisplayBlockInfo(pmbhCur, TEXT("Memory Corrupt"));
				pmbhCur->fCorruptionReported = true;
			}
			pmbhCur = pmbhCur->pmbhNext;
		}
	}
	
	return fAllOk;

}

//
// Calculates the hash value for a given pointer value
//
short CMsiMalloc::IHashValue(void *pv)
{
	short ival;
	long	bits;

	bits = ((LONG_PTR)pv) >> cSkipBits;			//!!merced: changed long to LONG_PTR. This'll probably affect the shift bits.
	
	ival = bits & maskHashBits;

	bits = bits >> cHashBits;

	ival = ival ^ (bits & maskHashBits);

	return ival;


}

//
// Inserts the memory block into the hash table of values
//
void CMsiMalloc::InsertInMemList(MBH* pmbh)
{
	short iHash;

	iHash = IHashValue(pmbh);

	pmbh->pmbhNext = m_rgpmbhBlocks[iHash];
	m_rgpmbhBlocks[iHash] = pmbh;

}


//
// Routine to assert when a freed class pointer is reused
//
void FreedClassWarning(void *pThis)
{
	MBH *pmbh;
	TCHAR szMsg[cchTempBuffer * 6];
	TCHAR szInfo[cchTempBuffer * 5];


	pmbh = (MBH *)(((char *)pThis) - sizeof(MBH));

	// Otherwise we'll try to do a dynamic cast, bad idea on freed object
	pmbh->fObject = false;
	
	vMalloc.ReturnBlockInfoPv(pThis, szInfo, sizeof(szInfo)/sizeof(TCHAR));
	// We know the additional text is smaller than cchTempBuffer, so no need to check szMsg size
	wsprintf(szMsg, TEXT("%s\r\n%s"), TEXT("Calling through freed vtable."), szInfo);
	FailAssertMsg(szMsg);
}

#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\iconfig.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       iconfig.cpp
//
//--------------------------------------------------------------------------

/* iconfig.cpp - IMsiConfigurationManager implementaIon

Currently this is built into the MSIENG.DLL for the initial implementation.
However, this prevents multiple processes from accessing the config database.
Eventually this code should be implemented as a daemon application,
that can also process remote OLE commands.
____________________________________________________________________________*/


//!! FIX -- suppressLFN on path creations?

#include "precomp.h" 
#include "_assert.h"
#include "iconfig.h"
#include "vertrust.h"
//#include "msi.h"
#include "_msinst.h"
#include "_srcmgmt.h"
#include "_camgr.h"
#include <winnls.h> // GetLocaleInfo
#include "_engine.h"
#include "EventLog.h"
#include "aclapi.h"
#include "resource.h"

const GUID IID_IMsiConfigurationManager    = GUID_IID_IMsiConfigurationManager;
const GUID IID_IMsiConfigManagerAsServer   = GUID_IID_IMsiConfigManagerAsServer;
const GUID IID_IMsiServer                  = GUID_IID_IMsiServer;
#ifdef DEBUG
const GUID IID_IMsiConfigManagerDebug      = GUID_IID_IMsiConfigManagerDebug;
const GUID IID_IMsiConfigMgrAsServerDebug  = GUID_IID_IMsiConfigMgrAsServerDebug;
#endif

// standard guids defined in uuid.lib which we do not link to
const GUID IID_IGlobalInterfaceTable =     { 0x00000146, 0x0000, 0x0000, { 0xC0, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x46 } };
const GUID CLSID_StdGlobalInterfaceTable = { 0x00000323, 0x0000, 0x0000, { 0xC0, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x46 } };

// macro wrapper for IMsiRecord* errors
#define RETURN_ERROR_RECORD(function)\
                            {\
                                IMsiRecord* piError = function;    \
                                if(piError)                        \
                                    return piError;                 \
                            }


extern INSTALLSTATE GetComponentClientState(const ICHAR* szUserId, const ICHAR* szProductSQUID, const ICHAR* szComponentSQUID, CAPITempBufferRef<ICHAR>& rgchComponentRegValue, DWORD& dwValueType, iaaAppAssignment* piaaAsgnType);
extern INSTALLSTATE GetComponentPath(const ICHAR* szUserId, const ICHAR* szProductSQUID, const ICHAR* szComponentSQUID, ICHAR* lpPathBuf, DWORD *pcchBuf, bool fFromDescriptor, CRFSCachedSourceInfo& pCacheInfo, int iDetectMode, const ICHAR* rgchComponentRegValue, DWORD dwValueType, ICHAR* lpPathBuf2, DWORD* pcchBuf2, DWORD* pdwLastErrorOnFileDetect);
extern CRFSCachedSourceInfo g_RFSSourceCache;  
  
extern Bool ConstructNetSourceListEntry(IMsiPath& riPath, const IMsiString*& rpiDriveLetter, const IMsiString*& rpiUNC,
                                                     const IMsiString*& rpiRelativePath);

extern DWORD GetProductAssignmentType(const ICHAR* szProductSQUID, iaaAppAssignment& riType);

IMsiRecord* SetLastUsedSourceCore(IMsiServices& riServices,
                                             const ICHAR* szProductCodeGUID, const ICHAR* szPath, Bool fAddToList, Bool fPatch,
                                             const IMsiString** ppiRawSource,
                                             const IMsiString** ppiIndex,
                                             const IMsiString** ppiType,
                                             const IMsiString** ppiSource,
                                             const IMsiString** ppiSourceListKey,
                                             const IMsiString** ppiSourceListSubKey,
                                             bool fVerificationOnly,
                                             bool fFirstInstall, 
                                             bool* pfSourceAllowed);

// this is the lifetime of the service after an install finishes, in 100ns increments.
// the initial timer value (on service start) is in module.h
const LONGLONG iServiceShutdownTime = ((LONGLONG)(10 * 60)  * (LONGLONG)(1000 * 1000 * 10));

//____________________________________________________________________________
//
// CMsiConfigurationManager definitions
//____________________________________________________________________________

class CMsiConfigurationManager : public IMsiConfigurationManager
{
 public:
    // IMsiConfigurationManager implemented virtual functions
    // order of function declarations is for clarity only, vtable order
    // is defined by IMsiConfigurationManager class.
    HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long   __stdcall AddRef();
    unsigned long   __stdcall Release();

    // -- Misc --
    IMsiServices&   __stdcall GetServices();
    iesEnum         __stdcall InstallFinalize(iesEnum iesState, IMsiMessage& riMessage, boolean fUserChangedDuringInstall);
    int             __stdcall DoInstall(ireEnum ireProductCode, const ICHAR* szProduct, const ICHAR* szAction, const ICHAR* szCommandLine,
                                                    const ICHAR* szLogFile, int iLogMode, boolean fFlushEachLine, IMsiMessage& riMessage, iioEnum iioOptions);
    IMsiRecord*     __stdcall RegisterUser(const ICHAR* szProductCode, const ICHAR* szUserName,
                                                        const ICHAR* szCompany, const ICHAR* szProductID);
    boolean         __stdcall RecordShutdownReason();
    boolean         __stdcall Reboot();
    void            __stdcall EnableReboot(boolean fRunScriptElevated, const IMsiString& ristrProductName);
    IMsiRecord*     __stdcall RemoveRunOnceEntry(const ICHAR* szEntry);
    boolean         __stdcall CleanupTempPackages(IMsiMessage& riMessage);
	void            __stdcall SetShutdownTimer(HANDLE hTimer);


    // -- CustomActionServer --
    CMsiCustomActionManager* __stdcall GetCustomActionManager();
	void            __stdcall CreateCustomActionManager(bool fRemapHKCU);
    UINT            __stdcall RegisterCustomActionServer(icacCustomActionContext* picacContext, const unsigned char *rgchCookie, const int cbCookie, IMsiCustomAction* piCustomAction, unsigned long *pdwProcessId, IMsiRemoteAPI **piRemoteAPI, DWORD* pdwPrivileges);
    UINT            __stdcall ShutdownCustomActionServer();
    IMsiCustomAction* __stdcall CreateCustomActionProxy(const icacCustomActionContext icacDesiredContext, const unsigned long dwProcessId, IMsiRemoteAPI *pRemoteApi, const WCHAR* pvEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, int *pcbCookie, HANDLE *hServerProcess, unsigned long *dwServerProcessId, bool fClientOwned, bool fRemapHKCU);
    UINT            __stdcall CreateCustomActionServer(const icacCustomActionContext icacContext, const unsigned long dwClientProcessId, IMsiRemoteAPI *piRemoteAPI, const WCHAR* pvEnvironment, DWORD cchEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, int *cbCookie, IMsiCustomAction **piCustomAction, unsigned long *dwServerProcessId);

    // -- SourceList API --
    UINT            __stdcall SourceListClearByType(const ICHAR* szProductCode, const ICHAR* szUserName, isrcEnum istSource);
    UINT            __stdcall SourceListAddSource(const ICHAR* szProductCode, const ICHAR* szUserName, isrcEnum isrcType, const ICHAR* szSource);
    UINT            __stdcall SourceListClearLastUsed(const ICHAR* szProductCode, const ICHAR* szUserName);

	// -- Internal SourceList --
	IMsiRecord*     __stdcall SetLastUsedSource(const ICHAR* szProductCode, const ICHAR* szPath, boolean fAddToList, boolean fPatch);
	IMsiRecord*     __stdcall SetLastUsedSource(const ICHAR* szProductCode, const ICHAR* szPath, Bool fAddToList, Bool fPatch,
															  const IMsiString** ppiRawSource,
															  const IMsiString** ppiIndex,
															  const IMsiString** ppiType,
															  const IMsiString** ppiSource,
															  const IMsiString** ppiSourceListKey,
															  const IMsiString** ppiSourceListSubKey);
	// -- Scripts -- 
	iesEnum         __stdcall RunScript(const ICHAR* szScriptFile, IMsiMessage& riMessage,
													IMsiDirectoryManager* piDirectoryManager, boolean fRollbackEnabled);

    // -- Rollback --
    IMsiRecord*     __stdcall RegisterRollbackScript(const ICHAR* szScriptFile);
    IMsiRecord*     __stdcall UnregisterRollbackScript(const ICHAR* szScriptFile);
    IMsiRecord*     __stdcall GetRollbackScriptEnumerator(MsiDate date, Bool fAfter, IEnumMsiString*& rpiEnumScripts);
    IMsiRecord*     __stdcall DisableRollbackScripts(Bool fDisable);
    IMsiRecord*     __stdcall RollbackScriptsDisabled(Bool& rfDisabled);

    // -- Components --
    IMsiRecord*     __stdcall RegisterComponent(const IMsiString&, const IMsiString&, INSTALLSTATE, const IMsiString&, unsigned int, int)
	{
		//!! obselete
		Assert(0);
		return 0;
	}
    IMsiRecord*     __stdcall UnregisterComponent(  const IMsiString& , const IMsiString& )
	{
		//!! obselete
		Assert(0);
		return 0;
	}

    // -- Folders --
    IMsiRecord*     __stdcall RegisterFolder(IMsiPath& riPath, Bool fExplicitCreation);
    IMsiRecord*     __stdcall IsFolderRemovable(IMsiPath& riPath, Bool fExplicit, Bool& fRemovable);
    IMsiRecord*     __stdcall UnregisterFolder(IMsiPath& riPath);
#ifdef CONFIGDB

    // -- Files --
    icdrEnum       __stdcall RegisterFile(const ICHAR* szFolder, const ICHAR* szFile, const ICHAR* szComponentId);
    icdrEnum       __stdcall UnregisterFile(const ICHAR* szFolder, const ICHAR* szFile, const ICHAR* szComponentId);
#endif
    void           __stdcall ChangeServices(IMsiServices& riServices);

 public: // constructor/destructor
    void *operator new(size_t cb) { return AllocSpc(cb); }
    void operator delete(void * pv) { FreeSpc(pv); }
    CMsiConfigurationManager(IMsiServices& riServices);
 public: // helper functions for use by CEnumRemovableFolders and CMsiConfigurationManager
    static iesEnum InstallFinalize(iesEnum iesState, CMsiConfigurationManager& riConman, IMsiMessage& riMessage, boolean fUserChangedDuringInstall);
 protected: // IMsiConfigurationManager data
  ~CMsiConfigurationManager();  // protected to prevent creation on stack
    CMsiRef<iidMsiConfigurationManager>           m_Ref;
    int           m_iOpenCount;
    IMsiServices* m_piServices;  // must release after destruction
#ifdef CONFIGDB
    IMsiConfigurationDatabase* m_piConfigurationDatabase;
#endif
    bool          m_fElevatedRebootAllowed;
	MsiString      m_strProductNeedingReboot;
 private:

    // Internal version of function for recording shutdown reason.
    boolean         __stdcall RecordShutdownReasonInternal();
	 
    // prevent warnings and copy
    void operator = (const CMsiConfigurationManager&){}

	// shutdown timer in service (owned by main service thread) to reactivate
	// on destruction.
	HANDLE                   m_hShutdownTimer;

    // manage the custom action manager for the service process
    CRITICAL_SECTION         m_csCAManager;
    IGlobalInterfaceTable*   m_piGIT;
    CMsiCustomActionManager* m_pCustomActionManager;

    // the service also acts as a registration system for all servers regardless
    // of client. Only one server can register at a time.
    HANDLE                   m_hCARegistered;
    CRITICAL_SECTION         m_csCreateProxy;

    // even within the restriction that only one action can be created at one time,
    // only one server can be trying to register at any one time. Otherwise our
    // security is weaker because two actions could register at once (last one
    // wins)
    CRITICAL_SECTION         m_csRegisterAction;

    // this information is what is needed to correctly recognize and register a
    // CA server
    struct {
        unsigned char            m_rgchWaitingCookie[iRemoteAPICookieSize];
        icacCustomActionContext  m_icacWaitingContext;
        IMsiCustomAction*        m_piCustomAction;
        DWORD                    m_dwProcessId;
        DWORD                    m_dwRemoteCookie;
        DWORD                    m_dwGITCookie;
		DWORD                    m_dwPrivileges;
		bool                     m_fImpersonatedIsSystem;
    } m_CustomServerInfo;
        
};


//____________________________________________________________________________
//
// CEnumRollbackScripts definition
//____________________________________________________________________________

class CEnumRollbackScripts : public IEnumMsiString
{
 public:  // implemented virtuals
    HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
    unsigned long __stdcall AddRef();
    unsigned long __stdcall Release();
    HRESULT __stdcall Next(unsigned long cFetch, const IMsiString** rgpi, unsigned long* pcFetched);
    HRESULT __stdcall Skip(unsigned long cSkip);
    HRESULT __stdcall Reset();
    HRESULT __stdcall Clone(IEnumMsiString** ppiEnum);
 public:  // construct/destructor
    CEnumRollbackScripts(const MsiDate date,
                                const Bool fAfter,
                               IMsiServices& riServices);
    void* ConstructedOK() {return m_piEnum;}
 protected:
  ~CEnumRollbackScripts();  // protected to prevent creation on stack
    unsigned long   m_iRefCnt;
    Bool            m_fDone;
    Bool            m_fAfter;
    PMsiServices    m_pServices;
    PMsiRegKey      m_pRollbackKey;
    MsiDate         m_date;
    IEnumMsiString* m_piEnum;
};

//____________________________________________________________________________
//
// CMsiConfigurationManager implementation
//____________________________________________________________________________

// Global instance of configuration manager

CMsiConfigurationManager* g_piConfigManager = 0;

// External factory called from OLE class factories

IMsiConfigurationManager* CreateConfigurationManager()
{
        
    if (g_piConfigManager)
        return (IMsiConfigurationManager*)(g_piConfigManager->AddRef(), g_piConfigManager);

    IMsiServices* piServices = ENG::LoadServices();
    if (piServices == 0)
        return 0;
    g_piConfigManager = new CMsiConfigurationManager(*piServices);
    if (g_piConfigManager == 0)
        ENG::FreeServices();
    return (IMsiConfigurationManager*)g_piConfigManager;
}

IMsiConfigurationManager* CreateConfigManagerAsServer()
{
    IMsiConfigurationManager* piConfigMgr = CreateConfigurationManager();
    if (piConfigMgr)
    {
        if ((g_fWin9X == false) && RunningAsLocalSystem())
        {
            g_scServerContext = scService;
            DEBUGMSG("Running as a service.");
        }
        else
        {
            g_scServerContext = scServer;
            DEBUGMSG("Running as a server.");
        }
    }
    return piConfigMgr;
}

CMsiConfigurationManager::CMsiConfigurationManager(IMsiServices& riServices)
 : m_piServices(&riServices), m_fElevatedRebootAllowed(false), m_piGIT(NULL),
   m_pCustomActionManager(NULL), m_hShutdownTimer(INVALID_HANDLE_VALUE)
{
    // We don't hold a ref to services, we must call ENG::FreeServices() at end
//  SetAllocator(&riServices);
    g_cInstances++;
    InitializeCriticalSection(&m_csCreateProxy);
    InitializeCriticalSection(&m_csCAManager);
    InitializeCriticalSection(&m_csRegisterAction);
    m_CustomServerInfo.m_rgchWaitingCookie[0] = 0;
    m_CustomServerInfo.m_icacWaitingContext = icacNext;
    Debug(m_Ref.m_pobj = this);  // factory does not do QueryInterface, no aggregation
}

CMsiConfigurationManager::~CMsiConfigurationManager()

{
//  ReleaseAllocator();

	// custom action servers should have been shut down by the message context shutdown code.
	// but shut them down here as well in case an advertise script creates one without an engine.
	ShutdownCustomActionServer();

    DeleteCriticalSection(&m_csCreateProxy);
    DeleteCriticalSection(&m_csCAManager);
    DeleteCriticalSection(&m_csRegisterAction);
    g_piConfigManager = 0;
    g_cInstances--;

	// if in the service, reset the timer to enable shutdown. There can only be 
	// one config manager in the service, and when it is destroyed, the process
	// should allow shutdowns. The g_cInstances count will often be 1 at this
	// point because services are released by the config manager Release() call
	// after this destructor is called. 
	if (g_scServerContext == scService && m_hShutdownTimer != INVALID_HANDLE_VALUE)
	{
		LARGE_INTEGER liDueTime = {0,0};
		liDueTime.QuadPart = -iServiceShutdownTime;
		KERNEL32::SetWaitableTimer(m_hShutdownTimer, &liDueTime, 0, NULL, NULL, FALSE);
	}
}

HRESULT CMsiConfigurationManager::QueryInterface(const IID& riid, void** ppvObj)
{
    if (MsGuidEqual(riid, IID_IUnknown))
        return (*ppvObj = (IUnknown*)this, AddRef(), NOERROR);
    else if (MsGuidEqual(riid, IID_IMsiServer))
        return (*ppvObj = (IMsiServer*)this, AddRef(), NOERROR);
    else if (MsGuidEqual(riid, IID_IMsiConfigurationManager)
#ifdef DEBUG
     || MsGuidEqual(riid, IID_IMsiConfigManagerDebug)
     || ((g_scServerContext == scService || g_scServerContext == scServer) && MsGuidEqual(riid, IID_IMsiConfigMgrAsServerDebug))
#endif //DEBUG
     || ((g_scServerContext == scService || g_scServerContext == scServer) && MsGuidEqual(riid, IID_IMsiConfigManagerAsServer)))
        return (*ppvObj = (IMsiConfigurationManager*)this, AddRef(), NOERROR);
    else
        return (*ppvObj = 0, E_NOINTERFACE);
}

unsigned long CMsiConfigurationManager::AddRef()
{
    AddRefTrack();
    return ++m_Ref.m_iRefCnt;
}

unsigned long CMsiConfigurationManager::Release()
{
    ReleaseTrack();
    if (--m_Ref.m_iRefCnt != 0)
        return m_Ref.m_iRefCnt;
    delete this;
    ENG::FreeServices();
    if (g_scServerContext != scClient)
    {
        Assert(g_cInstances == 0);
        g_cInstances = 0; // in case engine thread crashed we still want our instance count to go to 0
        WIN::PostQuitMessage(0); // give the service a chance to die if it wants to
    }
    return 0;
}

IMsiServices& CMsiConfigurationManager::GetServices()
//----------------------------------------------
{
    return (m_piServices->AddRef(), *m_piServices);
}

int CMsiConfigurationManager::DoInstall(ireEnum ireProductCode, const ICHAR* szProduct, const ICHAR* szAction, const ICHAR* szCommandLine,
                                                     const ICHAR* szLogFile, int iLogMode, boolean fFlushEachLine, IMsiMessage& riMessage, iioEnum iioOptions)
{
    Assert(FMutexExists(szMsiExecuteMutex));
    CEngineMainThreadData threadData(ireProductCode, szProduct, szAction, szCommandLine, iioOptions);
    if(szLogFile && *szLogFile)
    {
        // used only for reference
        IStrCopy(g_szClientLogFile,szLogFile);
        g_dwClientLogMode = iLogMode;
        g_fClientFlushEachLine = fFlushEachLine ? true : false;
    }
    SetDiagnosticMode(); // make sure mode is set correctly in case mode set before g_dwClientLogMode set

    return g_MessageContext.RunInstall(threadData, (iuiEnum)iuiDefault, &riMessage); //?? is iuiDefault correct?

//FUTURE: should reset client log settings like this: - BENCH 10-7-98
/*  if(szLogFile && *szLogFile)
    {
        // reset
        g_szClientLogFile[0] = 0;
        g_dwClientLogMode = 0;
    }
*/
}

iesEnum CMsiConfigurationManager::RunScript(const ICHAR* szScriptFile, IMsiMessage& riMessage,
														  IMsiDirectoryManager* piDirectoryManager, boolean fRollbackEnabled)
//----------------------------------------------
{
    iesEnum iesResult = iesNoAction;
    // check in progress key - if one doesn't exist, or this product isn't marked in-progress, error
    MsiString strInProgressProductId;
    CTempBuffer<ICHAR,39> rgchProductId;
	PMsiRecord pInProgressInfo(0);
    PMsiRecord pError = GetInProgressInstallInfo(*m_piServices, *&pInProgressInfo);
    if(pError || !pInProgressInfo || (strInProgressProductId = pInProgressInfo->GetMsiString(ipiProductKey), (strInProgressProductId.TextSize() == 0)))
    {
        // error: called RunScript when not in progress
        pError = PostError(Imsg(idbgRunScriptInstallNotInProgress));
        riMessage.Message(imtError, *pError);
        iesResult = iesFailure;
    }
    // check if the product for this script is marked in progress
/* //!! breaks for nested install that are not merged
//!! only called from CMsiEngine::InstallFinalize (via proxy), where we've already checked/set inprogress
//!! If we need another check here, we should pass in the outermost product code
//!! rather than pulling it out of the script (which is a slow operation anyway)
    else if((MsiGetProductInfoFromScript(szScriptFile,rgchProductId,0,0,0,0,0,0)) != ERROR_SUCCESS)
    {
        pError = PostError(Imsg(idbgNoProductIdInScript),szScriptFile);
        riMessage.Message(imtError, *pError);
        iesResult = iesFailure;
    }
    else if(strInProgressProductId.Compare(iscExactI,rgchProductId) == 0)
    {
        pError = PostError(Imsg(idbgDifferentProductInProgress),(const ICHAR*)rgchProductId,
                                 (const ICHAR*)strInProgressProductId);
        riMessage.Message(imtError, *pError);
        iesResult = iesFailure;
    }
*/
	else
	{
		Assert(IsImpersonating()); // should be impersonating at this point
		PMsiExecute pExecute = ::CreateExecutor(*this, riMessage, piDirectoryManager, (Bool)fRollbackEnabled);
		// we will elevate if necessary within RunScript
		iesResult = pExecute->RunScript(szScriptFile, false);
        if(iesResult == iesUnsupportedScriptVersion)
            iesResult = iesFailure;
    }

    return iesResult;
}

IMsiRecord* CMsiConfigurationManager::DisableRollbackScripts(Bool fDisable)
{
    // open rollback script regkey
    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine);
    PMsiRegKey pRollbackKey = &pLocalMachine->CreateChild(MsiString(szMsiRollbackScriptsKey));

    if(fDisable)
    {
        CElevate elevate;
        return pRollbackKey->SetValue(szMsiRollbackScriptsDisabled, *MsiString(TEXT("#1")));
    }
    else
    {
        CElevate elevate;
        return pRollbackKey->RemoveValue(szMsiRollbackScriptsDisabled, 0);
    }
}

IMsiRecord* CMsiConfigurationManager::RollbackScriptsDisabled(Bool& fDisabled)
{
    // open rollback script regkey
    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine);
    PMsiRegKey pRollbackKey = &pLocalMachine->CreateChild(MsiString(szMsiRollbackScriptsKey));

    // if Disabled value exists, scripts are disabled
    return pRollbackKey->ValueExists(szMsiRollbackScriptsDisabled, fDisabled);
}

IMsiRecord* CMsiConfigurationManager::RegisterRollbackScript(const ICHAR* szScriptFile)
//----------------------------------------------
{
    // open rollback script regkey
    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine);
    PMsiRegKey pRollbackKey = &pLocalMachine->CreateChild(MsiString(szMsiRollbackScriptsKey));

    Bool fExists;

#ifdef DEBUG
    RETURN_ERROR_RECORD(pRollbackKey->ValueExists(szScriptFile, fExists));
    AssertSz(!fExists, "Registering a rollback script that is already registered.");
#endif

    RETURN_ERROR_RECORD(pRollbackKey->ValueExists(szMsiRollbackScriptsDisabled, fExists));
    AssertSz(!fExists, "Registering a rollback script when scripts are marked disabled.");
    if(fExists)
    {
        // remove "disabled" value
        CElevate elevate;
        RETURN_ERROR_RECORD(pRollbackKey->RemoveValue(szMsiRollbackScriptsDisabled, 0));
    }

    // register the script
    MsiString strDate = TEXT("#");
    strDate += ENG::GetCurrentDateTime();

    {
        CElevate elevate;
        RETURN_ERROR_RECORD(pRollbackKey->SetValue(szScriptFile, *strDate));
    }
    return 0;
}

IMsiRecord* CMsiConfigurationManager::UnregisterRollbackScript(const ICHAR* szScriptFile)
//----------------------------------------------
{
    // open rollback script regkey
    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine);
    PMsiRegKey pRollbackKey = &pLocalMachine->CreateChild(MsiString(szMsiRollbackScriptsKey));

#ifdef DEBUG
    Bool fExists;
    RETURN_ERROR_RECORD(pRollbackKey->ValueExists(szScriptFile, fExists));
    AssertSz(fExists, "Unregistering a rollback script that isn't registered.");
#endif

    {
        CElevate elevate;
        // unregister the script
        RETURN_ERROR_RECORD(pRollbackKey->RemoveValue(szScriptFile, 0));
    }
    return 0;
}

IMsiRecord* CMsiConfigurationManager::GetRollbackScriptEnumerator(MsiDate date, Bool fAfter, IEnumMsiString*& rpiEnumScripts)
//----------------------------------------------
{
    CEnumRollbackScripts* piEnum = new CEnumRollbackScripts(date,
        fAfter, *m_piServices);

    if (piEnum && !piEnum->ConstructedOK())
        piEnum->Release(), piEnum = 0;
    rpiEnumScripts = piEnum;
    return piEnum ? 0 : PostError(Imsg(idbgEnumRollback));
}

iesEnum InstallFinalize(iesEnum iesState, CMsiConfigurationManager& riConman, IMsiMessage& riMessage, boolean fUserChangedDuringInstall)
{
    return riConman.InstallFinalize(iesState, riConman, riMessage, fUserChangedDuringInstall);
}

iesEnum CMsiConfigurationManager::InstallFinalize(iesEnum iesState, CMsiConfigurationManager& riConman, IMsiMessage& riMessage, boolean fUserChangedDuringInstall)
{
    iesEnum iesResult = iesNoAction;
    PMsiRecord pError(0);
	PMsiRecord pInProgressInfo(0);
	pError = GetInProgressInstallInfo(*riConman.m_piServices, *&pInProgressInfo);

    if(pError != 0 || !pInProgressInfo || !MsiString(pInProgressInfo->GetMsiString(ipiProductKey)).TextSize())
    {
        // error: called installfinalize when not in progress
        pError = PostError(Imsg(idbgInstallNotInProgress));
        riMessage.Message(imtError, *pError);
        iesResult = iesFailure;
    }
    else
    {
#ifdef CONFIGDB
        if (riConman.m_piConfigurationDatabase)
        {
            if (iesState == iesSuccess)
            {
                PMsiRecord pError = riConman.m_piConfigurationDatabase->Commit();
                if (pError)
                    riMessage.Message(imtWarning, *pError);  //!! remap error? fatal?
            }
            riConman.m_piConfigurationDatabase->Release();
            riConman.m_piConfigurationDatabase = 0;
        }
#endif
		MsiString strTimeStamp = pInProgressInfo->GetMsiString(ipiTimeStamp);
		MsiDate date = (MsiDate)(int)strTimeStamp;

    //!! must set m_irlRollbackLevel before calling RollbackFinalize(),
    //!! but can't call DoMachineVsUserInitialization() as the product info record is not set yet
    //!! it will be set when processing the rollback script, but that doesn't help to determine the mode now
    //!! seems best to pass in the mode that was used to generate the script, but that will requires some changes

		// elevation state for rollback stored in script header
		{
			PMsiExecute pExecute = ::CreateExecutor(riConman, riMessage,
																 0, /* DirectoryManager not required during rollback */
																 fTrue); // rollback enabled
			iesResult = pExecute->RollbackFinalize(iesState, date, (fUserChangedDuringInstall) ? true : false); //!! what if this fails????
		}
	
	}
	return iesResult;
}

iesEnum CMsiConfigurationManager::InstallFinalize(iesEnum iesState, IMsiMessage& riMessage, boolean fUserChangedDuringInstall)
//----------------------------------------------
{
    return InstallFinalize(iesState, *this, riMessage, fUserChangedDuringInstall);
}

boolean CMsiConfigurationManager::RecordShutdownReasonInternal()
{
	boolean fRet = true;
	
	DEBUGMSGE(EVENTLOG_INFORMATION_TYPE, EVENTLOG_TEMPLATE_REBOOT_TRIGGERED,(const ICHAR*)m_strProductNeedingReboot);

	if(MinimumPlatformWindowsNT51())
	{
		ICHAR szErrorString[1024];
		unsigned int iCodepage = MsiLoadString(g_hInstance, IDS_INITIATED_SYSTEM_RESTART, szErrorString, sizeof(szErrorString)/sizeof(ICHAR), 0);
		if (!iCodepage)
		{
			AssertSz(0, TEXT("Missing IDS_INITIATED_SYSTEM_RESTART error string"));
			IStrCopy(szErrorString, TEXT("The Windows Installer initiated a system restart to complete or continue the configuration of '%s'..")); // should never happen - two periods in intentional
		}

		// assume the expanded string will be less than 1024 - so we use wsprintf
		CTempBuffer<ICHAR, MAX_PATH + 256> rgchExpandedErrorString;
		rgchExpandedErrorString.SetSize(IStrLen(szErrorString)+m_strProductNeedingReboot.TextSize()+1);
		wsprintf((ICHAR *)rgchExpandedErrorString, szErrorString, (const ICHAR*)m_strProductNeedingReboot);

#ifdef UNICODE
		SHUTDOWN_REASON sr = {sizeof(SHUTDOWN_REASON),
							  EWX_REBOOT,
							  REASON_SWINSTALL,
							  SR_EVENT_INITIATE_CLEAN,
							  FALSE,
							  (ICHAR *)rgchExpandedErrorString};

		fRet = (USER32::RecordShutdownReason(&sr)) ? true : false;
#endif
	}
	
	return fRet;
}


boolean CMsiConfigurationManager::RecordShutdownReason()
{
	CElevate elevate;
	boolean fRet = true;
	
	//
	// When not on Win9X, do not log shutdown request unless the caller has shutdown privileges and 
	// there is a pending reboot.
	//
	if (!g_fWin9X && (!IsClientPrivileged(SE_SHUTDOWN_NAME) || 0 == m_strProductNeedingReboot.TextSize()))
		return false;
	
	return this->RecordShutdownReasonInternal();
}

boolean CMsiConfigurationManager::Reboot()
{
	// the stub for the config manager impersonates via COM impersonation to correctly 
	// authenticate the user when called from the client. 
    BOOL fRet = TRUE;

    bool fReboot = false;
    
    if (g_fWin9X)
    {
        fReboot = true; // always allowed to reboot on Win9X
    }
    else
    {
        if (m_fElevatedRebootAllowed)
        {
            fReboot = true; // we've already been told that we're allowed to reboot
        }
        else
        {
            // Check to see whether the client has the reboot privilege enabled.
            fReboot = IsClientPrivileged(SE_SHUTDOWN_NAME);
        }
    }
        
    if(fReboot)
    {
        CElevate elevate;
        g_MessageContext.DisableTimeout();
        fRet = g_fWin9X || AcquireTokenPrivilege(SE_SHUTDOWN_NAME);
        if (fRet)
        {
            //
            // Call the internal version which does not check the client token for existence of shutdown privileges
            // before recording the shutdown reason, since the only way we can end up here is if the client does not 
            // have shutdown privileges and due to which it ends up passing the reboot request over to the service.
            //
            this->RecordShutdownReasonInternal();
            if ((MinimumPlatformWindowsNT51()) && (GetLoggedOnUserCountXP() > 1))
            {
                //
                // On WindowsXP and higher, ExitWindowsEx puts up a dialog if there is more than one user logged on to
                // the system. Since we are running inside the service here which always runs in session 0, the message
                // box will pop-up on the desktop of session 0. However, on TS/FUS machines, the user who initiated the
                // reboot via an install might be on a different session and therefore the dialog will not be visible to
                // the user and will be percieved as a hang. This defeats the purpose of putting up the dialog from
                // ExitWindowsEx since the dialog warns the user that there are multiple users logged on to the machine
                // who might lose data if the machine is restarted.
                //
                // Also note that we really want to minimize the scenarios where InitiateSystemShutdown is called. This
                // is because InitiateSystemShutdown does not work reliably in all scenarios. One of the cases where it is
                // known to fail is if the API is called during the install of a package in winlogon. InitiateSystemShutdown
                // needs to bind to a named pipe and the binding fails with ERROR_NOT_READY during winlogon. Now, the only
                // way a package might get installed during winlogon is through group policy which means that the machine
                // is a part of a domain and therefore FUS is disabled and therefore there will only be one user on the
                // system in the Pro SKUs and therefore this code will end up calling ExitWindowsEx rather than
                // InitiateSystemShutdown and thus succeed.
                //
                // Also note that in the winlogon case, the shutdown from the client process will not happen because
                // winlogon installs the package while impersonating the user and uses a restricted impersonation token
                // which does not have the shutdown privilege.
                //
                fRet = ADVAPI32::InitiateSystemShutdown(NULL, NULL, 0, FALSE, TRUE);
            }
            else
            {
                fRet = ExitWindowsEx (EWX_REBOOT, 0);
            }
        }
        g_MessageContext.EnableTimeout();
        return fRet == TRUE;
    }
    else
    {
        return FALSE;
    }
}

void CMsiConfigurationManager::EnableReboot(boolean fRunScriptElevated, const IMsiString& ristrProductName)
{
    if (fRunScriptElevated)
        m_fElevatedRebootAllowed = true;

	 m_strProductNeedingReboot = ristrProductName;
	 ristrProductName.AddRef();
}

IMsiRecord* CMsiConfigurationManager::SetLastUsedSource(const ICHAR* szProductCode, const ICHAR* szPath, boolean fAddToList, boolean fPatch)
{
	CCoImpersonate impersonate;
	return SetLastUsedSource(szProductCode, szPath, fAddToList ? fTrue : fFalse, fPatch ? fTrue : fFalse, 0, 0, 0, 0, 0, 0);
}

IMsiRecord* CMsiConfigurationManager::SetLastUsedSource(const ICHAR* szProductCodeGUID, const ICHAR* szPath, Bool fAddToList, Bool fPatch,
                                                                          const IMsiString** ppiRawSource,
                                                                          const IMsiString** ppiIndex,
                                                                          const IMsiString** ppiType,
                                                                          const IMsiString** ppiSource,
                                                                          const IMsiString** ppiSourceListKey,
                                                                          const IMsiString** ppiSourceListSubKey)
{
    return SetLastUsedSourceCore(*m_piServices, szProductCodeGUID, szPath, fAddToList, fPatch, ppiRawSource, ppiIndex, ppiType, ppiSource, ppiSourceListKey, ppiSourceListSubKey, false, false, 0);
}

bool FSourceIsAllowed(IMsiServices& riServices, bool fFirstInstall, const ICHAR* szProductCodeGUID, const ICHAR* szPath, Bool fPatch)
{
	bool fSourceAllowed;

	PMsiRecord pError = SetLastUsedSourceCore(riServices, szProductCodeGUID, szPath, fFalse, fPatch,
															0, 0, 0, 0, 0, 0, true, fFirstInstall, &fSourceAllowed);

    if(pError || fSourceAllowed == false)
        return false;
    else
        return true;
}

IMsiRecord* SetLastUsedSourceCore(IMsiServices& riServices,
                                             const ICHAR* szProductCodeGUID, const ICHAR* szPath, Bool fAddToList, Bool fPatch,
                                             const IMsiString** ppiRawSource,
                                             const IMsiString** ppiIndex,
                                             const IMsiString** ppiType,
                                             const IMsiString** ppiSource,
                                             const IMsiString** ppiSourceListKey,
                                             const IMsiString** ppiSourceListSubKey,
                                             bool fVerificationOnly,
                                             bool fFirstInstall,
                                             bool* pfSourceAllowed)
{
	if(pfSourceAllowed)
		*pfSourceAllowed = false;
	
	// pack the GUID
	ICHAR szProductCodeSQUID[cchProductCodePacked + 1] = TEXT("");

	if (szProductCodeGUID && *szProductCodeGUID)
	{
		//!! should be error
		AssertNonZero(PackGUID(szProductCodeGUID, szProductCodeSQUID));
	}

	Assert((ppiRawSource && ppiIndex && ppiType && ppiSource && ppiSourceListSubKey) ||
			 (!ppiRawSource && !ppiIndex && !ppiType && !ppiSource && !ppiSourceListSubKey));

    DEBUGMSG("Entering CMsiConfigurationManager::SetLastUsedSource.");

    PMsiPath pPath(0);
    RETURN_ERROR_RECORD(riServices.CreatePath(szPath, *&pPath));

    IMsiRecord* piError = 0;
    const ICHAR* szSubKey;
    isfEnum isf;
    
    MsiString strLastUsedType;
    PMsiVolume pVolume = &pPath->GetVolume();
    idtEnum idt = pVolume->DriveType();

    if (pVolume->IsURLServer())
        idt = idtNextEnum; // use idtNext enum to represent URL

    switch (idt)
    {
    case idtCDROM:   // fall through
    case idtFloppy:  // fall through
//!!    case idtRemovable:
        szSubKey = szSourceListMediaSubKey;
        isf = isfMedia;
        strLastUsedType = MsiString(MsiChar(chMediaSource));
        break;
    default:
    case idtUnknown: // fall through
    case idtRAMDisk: //??
        Assert(0);
    case idtFixed:   // fall through
    case idtRemote:  // fall through
        szSubKey = szSourceListNetSubKey;
        isf = isfNet;
        strLastUsedType = MsiString(MsiChar(chNetSource));
        break;
    case idtNextEnum:
        szSubKey = szSourceListURLSubKey;
        isf = isfURL;
        strLastUsedType = MsiString(MsiChar(chURLSource));
        break;
    }
    
    MsiString strSourceListSubKey;

    MsiString strSourceListKey = _szGPTProductsKey;
    strSourceListKey += MsiString(MsiChar(chRegSep));
    strSourceListKey += MsiString(szProductCodeSQUID);  
    strSourceListKey += MsiString(MsiChar(chRegSep));
    strSourceListKey += szSourceListSubKey;

    strSourceListSubKey = strSourceListKey + MsiString(MsiChar(chRegSep));
    strSourceListSubKey += szSubKey;

    CRegHandle HKey;
    LONG lResult;

    // if a media source, check policies before bothering to check labels, etc. Media are allowed if
    // DisableMedia is not set, and its a first install or AllowLockdownBrowse is set or
    // the product is safe for source actions
    if (isf == isfMedia)
    {
        bool fMediaAllowed = (GetIntegerPolicyValue(szDisableMediaValueName, fFalse) != 1) &&
            (fFirstInstall || GetIntegerPolicyValue(szAllowLockdownMediaValueName, fTrue) == 1 ||
             SafeForDangerousSourceActions(szProductCodeGUID));
        if (!fMediaAllowed)
        {
            DEBUGMSG(TEXT("Warning: rejected media source due to system policy."));
            return 0;
        }
    }


    // if this is a first-time install, there's no sourcelist to check against
    Bool fSourceIsInList = fFalse;
    unsigned int uiMaxIndex = 0;
    MsiString strSetIndex;
    MsiString strNewSource;
    PMsiRegKey pSourceListSubKey(0);
    PMsiRegKey pSourceListKey(0);
    if (!fFirstInstall)
    {
        if (fVerificationOnly == false)
        {
            CElevate elevate;
            if ((lResult = OpenSourceListKeyPacked(szProductCodeSQUID, fPatch, HKey, fTrue, false)) != ERROR_SUCCESS)
                return PostError(Imsg(idbgSrcOpenSourceListKey), lResult);
        }
        else
        {
            if ((lResult = OpenSourceListKeyPacked(szProductCodeSQUID, fPatch, HKey, fFalse, false)) != ERROR_SUCCESS)
                return PostError(Imsg(idbgSrcOpenSourceListKey), lResult);
        }
    
        pSourceListKey = &riServices.GetRootKey((rrkEnum)(int)HKey);
        pSourceListSubKey = &pSourceListKey->CreateChild(szSubKey);
        
    //  MsiString strNewURL;
        MsiString strLabel, strNewLabel;
    
        if (isf == isfNet || isf == isfURL)
        {
            strNewSource = szPath; // Note: we assume that the caller has passed us a source with the correct volume pref
        }
        else if (isf == isfMedia)
        {
            // SetLastUsedSource should always refresh the volume properties for media in case the disk in the
            // drive has been changed since the volume object was created.
            PMsiVolume pVolume(&pPath->GetVolume());
            pVolume->DiskNotInDrive();
            strNewLabel = pVolume->VolumeLabel();
        }
    
        PEnumMsiString pEnumString(0);
    
        if (pSourceListKey && (piError = pSourceListSubKey->GetValueEnumerator(*&pEnumString)) != 0)
            return piError;
    
        MsiString strSource;
        if (pSourceListKey)
        {
            for (;;)
            {
                MsiString strIndex;
                HRESULT hRes = pEnumString->Next(1, &strIndex, 0);
                if (S_FALSE == hRes)
                {
                    break;
                }
                else if (S_OK == hRes)
                {
                    MsiString strUnexpandedSource;
                    if ((piError = pSourceListSubKey->GetValue(strIndex, *&strUnexpandedSource)) != 0)
                        return piError;
    
                    if (strUnexpandedSource.Compare(iscStart, TEXT("#%")))
                    {
                        strUnexpandedSource.Remove(iseFirst, 2); // remove REG_EXPAND_SZ token
                        ENG::ExpandEnvironmentStrings(strUnexpandedSource, *&strSource);
                    }
                    else
                        strSource = strUnexpandedSource;
    
                    int iIndex = strIndex;
                    if (iIndex > uiMaxIndex)
                        uiMaxIndex = iIndex;
    
                    if (isf == isfNet)
                    {
                        MsiString strPath = pPath->GetPath();
                        if (!strSource.Compare(iscEnd, szRegSep))
                            strPath.Remove(iseLast, 1);
    
                        if (strPath.Compare(iscExactI, strSource))
                        {
                            strSetIndex     = strIndex;
                            fSourceIsInList = fTrue;
                            break;
                        }
                    }
                    else if (isf == isfMedia)
                    {
                        strLabel = strSource.Extract(iseUpto, ';');
                        if (strLabel.Compare(iscExactI, strNewLabel))
                        {
                            strSetIndex     = strIndex;
                            fSourceIsInList = fTrue;
                            break;
                        }
                    }
                    else // isf == isfURL
                    {
                        if (strSource.Compare(iscExact, strNewSource))
                        {
                            strSetIndex     = strIndex;
                            fSourceIsInList = fTrue;
                            break;
                        }
                    }
                }
                else
                {
                    break;
                }
            }
        }
        DEBUGMSG1(TEXT("Specifed source is%s already in a list."), !fSourceIsInList ? TEXT(" not") : TEXT(""));
    
        if (ppiRawSource)
        {
            *ppiRawSource = &CreateString();
            *ppiIndex     = &CreateString();
            *ppiType      = &CreateString();
            *ppiSource    = &CreateString();
    
            strSourceListSubKey.ReturnArg(*ppiSourceListSubKey);
            strSourceListKey.ReturnArg(*ppiSourceListKey);
        }
    }

    // Check that this source type is allowed.
    CAPITempBuffer<ICHAR, 4> rgchValidSourceTypes;
    GetStringPolicyValue(szSearchOrderValueName, fFalse, rgchValidSourceTypes);

    const ICHAR* pchSourceType = rgchValidSourceTypes;
    Bool fValidSourceType = fFalse;
    while (*pchSourceType)
    {
        isfEnum isfValid;
        AssertNonZero(MapSourceCharToIsf(*pchSourceType, isfValid));
        if (isf == isfValid)
        {
            fValidSourceType = fTrue;
            break;
        }
        pchSourceType++;
    }

    if (!fValidSourceType)
    {
        DEBUGMSG2(TEXT("Warning: rejected invalid source type for source '%s' (product: %s)"), szPath, szProductCodeGUID);
        return 0;
    }

    // Check whether the user is allowed to add new sources
    // never if DisableBrowse is set. Otherwise, only if admin or non-elevated install. or
    // AllowLockdownBrowse is set.
    bool fAllowAdditionOfNewSources = true;
     
    // first-time installs do not respect the DisableBrowse policy (because by definition its
    // a new source)
    if (!fFirstInstall)
    {
        fAllowAdditionOfNewSources = (GetIntegerPolicyValue(szDisableBrowseValueName, fTrue) != 1) &&
            ((GetIntegerPolicyValue(szAllowLockdownBrowseValueName, fTrue) == 1) ||
             SafeForDangerousSourceActions(szProductCodeGUID));
    }

#ifdef DEBUG
    if (GetEnvironmentVariable(TEXT("MSI_ALWAYS_RESPECT_DISABLE_BROWSE"), 0, 0))
    {
        fAllowAdditionOfNewSources= (GetIntegerPolicyValue(szDisableBrowseValueName, fTrue) != 1);
    }
#endif

    DEBUGMSG1(TEXT("Adding new sources is%s allowed."), fAllowAdditionOfNewSources ? TEXT("") : TEXT(" not"));

    if ((!fAllowAdditionOfNewSources && fSourceIsInList) || fAllowAdditionOfNewSources)
    {

        if(pfSourceAllowed)
            *pfSourceAllowed = true;
    
        if(fVerificationOnly == false)
        {
            if (fAddToList && !fSourceIsInList)
            {
                if (isf == isfNet || isf == isfURL)
                {
                    // strNewSource is already set correctly
                }
                else if (isf == isfMedia)
                {
                    // nothing to add for media sources
                }

                strSetIndex = (int)(uiMaxIndex + 1);
                if (ppiSource)
                {
                    strNewSource.ReturnArg(*ppiSource);
                }
                else
                {
                    MsiString strValue = TEXT("#%"); // REG_EXPAND_SZ
                    strValue += strNewSource;
                    CElevate elevate;
                    AssertRecord(pSourceListSubKey->SetValue(strSetIndex, *strValue));
                }
                DEBUGMSG2(TEXT("Added new source '%s' with index '%s'"), (const ICHAR*)strNewSource, (const ICHAR*)strSetIndex);
            }

            // Set source as LastUsedSource
            if (ppiRawSource)
            {
                MsiString(pPath->GetPath()).ReturnArg(*ppiRawSource);
                strSetIndex.ReturnArg(*ppiIndex);
                strLastUsedType.ReturnArg(*ppiType);
            }
            else
            {
                // elevate so we can open the key for write if necessary
                {
                    CElevate elevate;

                    MsiString strLastUsedSource = strLastUsedType;
                    strLastUsedSource += MsiChar(';');
                    strLastUsedSource += strSetIndex;
                    strLastUsedSource += MsiChar(';');
                    strLastUsedSource += MsiString(pPath->GetPath());

                    AssertRecord(pSourceListKey->SetValue(szLastUsedSourceValueName, *strLastUsedSource));
                }
            }
            DEBUGMSG1(TEXT("Set LastUsedSource to: %s."), (const ICHAR*)MsiString(pPath->GetPath()));
            DEBUGMSG1(TEXT("Set LastUsedType to: %s."),   (const ICHAR*)strLastUsedType);
            DEBUGMSG1(TEXT("Set LastUsedIndex to: %s."),  (const ICHAR*)strSetIndex);
        }
    }
#ifdef DEBUG
    else
    {
        DEBUGMSG2(TEXT("Warning: rejected attempt to add new source '%s' (product: %s)"), szPath, szProductCodeGUID);
    }
#endif

    return 0;
}

IMsiRecord* CMsiConfigurationManager::RegisterUser(const ICHAR* szProductKey, const ICHAR* szUserName,
                                                                    const ICHAR* szCompany, const ICHAR* szProductID)
{
    CElevate elevate; // elevate to write to our key - should already be elevated, but just in case

	PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine, ibtCommon);
#ifdef UNICODE

	MsiString			strKey = szMsiUserDataKey;
	ICHAR				szSID[cchMaxSID];
	ICHAR				szSQUID[cchGUIDPacked + 1];
	iaaAppAssignment	iType;
	DWORD				dwError;
	

	// Get sid. Depending on the product assignment type, this is either
	// user sid or machine sid.

	if(!PackGUID(szProductKey, szSQUID))
	{
		return PostError(Imsg(idbgOpInvalidParam), (int)ERROR_INVALID_PARAMETER);;
	}
	
	dwError = GetProductAssignmentType(szSQUID, iType);
	if(ERROR_SUCCESS != dwError)
	{
		return PostError(Imsg(idbgGetProductAssignmentTypeFailed), (int)dwError);
	}
	if(iType == iaaMachineAssign)
	{
		// Product is installed for machine. Use machine sid.
		IStrCopy(szSID, szLocalSystemSID);
	}
	else
	{
		dwError = GetCurrentUserStringSID(szSID);
	
		if(ERROR_SUCCESS != dwError)
		{
			return PostError(Imsg(idbgOpGetUserSID), (int)dwError);
		}
	}

	strKey += szRegSep;
	strKey += szSID;
	strKey += szRegSep;
	strKey += szMsiProductsSubKey;
	strKey += szRegSep;
	strKey += MsiString(GetPackedGUID(szProductKey));
	strKey += szRegSep;
	strKey += szMsiInstallPropertiesSubKey;
	
    PMsiRecord pError(0);
    
    PMsiStream pSecurityDescriptor(0);
    if ((pError = GetSecureSecurityDescriptor(*m_piServices, *&pSecurityDescriptor)) != 0)
        return pError;
    
    PMsiRegKey pUninstallKey = &pLocalMachine->CreateChild(strKey, pSecurityDescriptor);
#else
    // there is no multi-user on Win9X - use the global uninstall key location
    PMsiRecord pError(0);
	MsiString strKey = szMsiUninstallProductsKey_legacy;
	strKey += szRegSep;
	strKey += szProductKey;
    PMsiRegKey pUninstallKey = &pLocalMachine->CreateChild(strKey, 0);
#endif
    if(szUserName && *szUserName)
    {
        pError = pUninstallKey->SetValue(szUserNameValueName,*MsiString(szUserName));
        if(pError)
            return pError;
    }

    if(szCompany && *szCompany)
    {
        pError = pUninstallKey->SetValue(szOrgNameValueName, *MsiString(szCompany));
        if(pError)
            return pError;
    }

    if(szProductID && *szProductID)
    {
        pError = pUninstallKey->SetValue(szPIDValueName,     *MsiString(szProductID));
        if(pError)
            return pError;
    }
    
    return 0;
}

IMsiRecord* CMsiConfigurationManager::RemoveRunOnceEntry(const ICHAR* szEntry)
{
    if(!szEntry || !*szEntry)
    {
        Assert(0);
        return 0;
    }
    
    CElevate elevate; // elevate to delete value from RunOnceEntries key

    IMsiRecord* piError = 0;

    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine);
    PMsiRegKey pRunOnceKey = &pLocalMachine->CreateChild(szMsiRunOnceEntriesKey);

    return pRunOnceKey->RemoveValue(szEntry, 0);
}

extern iesEnum RemoveFolder(IMsiPath& riPath, Bool fForeign, Bool fExplicitCreation,
                                     IMsiConfigurationManager& riConfigManager, IMsiMessage& riMessage);

boolean CMsiConfigurationManager::CleanupTempPackages(IMsiMessage& riMessage)
{
    CElevate elevate; // elevate entire routine

    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine);
    PMsiRegKey pTempPackagesKey = &pLocalMachine->CreateChild(szMsiTempPackages);

    PMsiRecord pError(0);
    

    Bool fKeyExists = fFalse;
    if((pError = pTempPackagesKey->Exists(fKeyExists)) != 0)
    {
        AssertRecordNR(pError);
        return false;
    }

    if(!fKeyExists)
    {
        // no key, nothing to do
        return true;
    }
        
    PEnumMsiString pEnum(0);
    if((pError = pTempPackagesKey->GetValueEnumerator(*&pEnum)) != 0)
    {
        AssertRecordNR(pError);
        return false;
    }
    
    MsiString strFilePath;
    while((pEnum->Next(1, &strFilePath, 0)) == S_OK)
    {
        MsiString strValue;
        if((pError = pTempPackagesKey->GetValue(strFilePath,*&strValue)) != 0)
        {
            AssertRecordNR(pError);
            continue;
        }

        int iOptions = 0;
        if(strValue.TextSize() > 1)
        {
            // skip past '#' for integer values
            strValue.Remove(iseIncluding, '#');
            iOptions = strValue;
            if(iOptions == iMsiNullInteger)
                iOptions = 0;
        }

        PMsiPath pPath(0);
        MsiString strFileName;
        if((pError = m_piServices->CreateFilePath(strFilePath, *&pPath, *&strFileName)) != 0)
        {
            AssertRecordNR(pError);
            continue;
        }

        // first, remove file - ignore error
        DEBUGMSG1(TEXT("Post-install cleanup: removing installer file '%s'"), strFilePath);
        if((pError = pPath->RemoveFile(strFileName)) != 0)
        {
            AssertRecordNR(pError);
            continue;
        }
        
        // next, if options say so, try to remove the folder
        if(iOptions & TEMPPACKAGE_DELETEFOLDER)
        {
            DEBUGMSG1(TEXT("Post-install cleanup: removing installer folder '%s' (if empty)"), MsiString(pPath->GetPath()));

            // ignore error
            RemoveFolder(*pPath, fFalse, fFalse, *this, riMessage);
        }

    }

    // finally, remove key
    if((pError = pTempPackagesKey->Remove()) != 0)
    {
        AssertRecordNR(pError);
        return false;
    }
    
    return true;
}


///////////////////////////////////////////////////////////////////////
// save the specified timer off for reset on shutdown.
void CMsiConfigurationManager::SetShutdownTimer(HANDLE hTimer)
{
	m_hShutdownTimer = hTimer;
}


#ifdef CONFIGDB
icdrEnum CMsiConfigurationManager::RegisterFile(const ICHAR* szFolder, const ICHAR* szFile, const ICHAR* szComponentId)
{
    return m_piConfigurationDatabase ? m_piConfigurationDatabase->InsertFile(szFolder, szFile, szComponentId) : icdrNotOpen;
}

icdrEnum CMsiConfigurationManager::UnregisterFile(const ICHAR* szFolder, const ICHAR* szFile, const ICHAR* szComponentId)
{
    return m_piConfigurationDatabase ? m_piConfigurationDatabase->RemoveFile(szFolder, szFile, szComponentId) : icdrNotOpen;
}
#endif

IMsiRecord* GetComponentPath(IMsiServices& riServices, const ICHAR* szUserId, const IMsiString& riProductKey, 
								     const IMsiString& riComponentCode, 
									  IMsiRecord *& rpiRec,
									  iaaAppAssignment* piaaAsgnType)
												   
//----------------------------------------------
{
    INSTALLSTATE isStaticState  = INSTALLSTATE_UNKNOWN;
    INSTALLSTATE isDynamicState = INSTALLSTATE_UNKNOWN;
    INSTALLSTATE isReturnState  = INSTALLSTATE_UNKNOWN;

    ICHAR szProductKeyPacked[cchProductCode  + 1];
    ICHAR szComponentIdPacked[cchComponentId + 1];

    AssertNonZero(PackGUID(riProductKey.GetString(),    szProductKeyPacked));
    AssertNonZero(PackGUID(riComponentCode.GetString(), szComponentIdPacked));

    rpiRec = &riServices.CreateRecord(icmlcrEnumCount);
	// Get static state 
	CAPITempBuffer<ICHAR, MAX_PATH> rgchComponentRegValue;
	DWORD dwValueType;		
	isStaticState = GetComponentClientState(szUserId, szProductKeyPacked, szComponentIdPacked, rgchComponentRegValue, dwValueType, piaaAsgnType);
	rpiRec->SetInteger(icmlcrINSTALLSTATE_Static, (int)isStaticState);
	
	if (isStaticState == INSTALLSTATE_UNKNOWN)
	{
		rpiRec->SetString(icmlcrFile, TEXT(""));
		rpiRec->SetInteger(icmlcrINSTALLSTATE, (int)INSTALLSTATE_UNKNOWN);
		return 0;
	}
	rpiRec->SetString(icmlcrRawFile, (const ICHAR*)rgchComponentRegValue);
    if (REG_MULTI_SZ == dwValueType)
    {
        const ICHAR* pch = rgchComponentRegValue;
        while (*pch++)
            ;

        rpiRec->SetString(icmlcrRawAuxPath, pch);
    }
	
	// Get dynamic state
	CTempBuffer<ICHAR, MAX_PATH> rgchFile;  // same initial buffer size as that in ::GetComponentPath
	DWORD cchFile = rgchFile.GetSize();     // actual buffer size in chars passed in, including room for null
    CTempBuffer<ICHAR, MAX_PATH> rgchRegPath;  // same initial buffer size as that in ::GetComponentPath
    DWORD cchRegPath = rgchRegPath.GetSize();     // actual buffer size in chars passed in, including room for null
	MsiString strKeyPath;
    MsiString strRegKeyPath;
	DWORD dwLastError = ERROR_FUNCTION_FAILED;

	for (int c=1; c <= 3; c++)  // retry if buffer too small, ::GetComponentPath may process reg data before copying
	{
		// Always use the process-level RFS cache for engine/services based calls.
		isDynamicState = ::GetComponentPath(szUserId, szProductKeyPacked, szComponentIdPacked, rgchFile, &cchFile, false, g_RFSSourceCache, DETECTMODE_VALIDATEPATH, rgchComponentRegValue, dwValueType, rgchRegPath, &cchRegPath, &dwLastError);

		if (INSTALLSTATE_MOREDATA == isDynamicState)
		{
			rgchFile.SetSize(++cchFile);  // adjust buffer size for char count + 1 for null terminator
            rgchRegPath.SetSize(++cchRegPath);  // adjust buffer size for char count + 1 for null terminator
		}
		else 
		{
			strKeyPath = (const ICHAR*)rgchFile;
            strRegKeyPath = (const ICHAR*)rgchRegPath;
			if ((INSTALLSTATE_DEFAULT == isDynamicState) || (INSTALLSTATE_LOCAL == isDynamicState) || (INSTALLSTATE_ABSENT == isDynamicState))
			{

                // have we refcounted in the SharedDll registry

                if(rgchComponentRegValue[1] == chSharedDllCountToken) // we have refcounted in the registry
                    rpiRec->SetInteger(icmlcrSharedDllCount, fTrue);
            }
            break;
        }
    }

    if ((isDynamicState == INSTALLSTATE_ABSENT) || (isDynamicState == INSTALLSTATE_UNKNOWN))
    {
        isReturnState = INSTALLSTATE_ABSENT;
    }
    else if (isDynamicState == INSTALLSTATE_SOURCE || isDynamicState == INSTALLSTATE_LOCAL || isDynamicState == INSTALLSTATE_NOTUSED)
    {
        isReturnState = isDynamicState;
    }
    else if (isDynamicState == INSTALLSTATE_DEFAULT)
    {
        isReturnState = isStaticState;
    }
    else
    {
        AssertSz(0, "Unexpected dynamic component state");
        isReturnState = INSTALLSTATE_UNKNOWN;
    }

	rpiRec->SetMsiString(icmlcrFile, *strKeyPath);
    if(strRegKeyPath.TextSize())
        rpiRec->SetMsiString(icmlcrAuxPath, *strRegKeyPath);
	rpiRec->SetInteger(icmlcrINSTALLSTATE, isReturnState);
	rpiRec->SetInteger(icmlcrLastErrorOnFileDetect, dwLastError);
	return 0;	
}

IMsiRecord* CMsiConfigurationManager::RegisterFolder(IMsiPath& riPath, Bool fExplicitCreation)
//----------------------------------------------
{
    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine);
    PMsiRegKey pFoldersKey = &pLocalMachine->CreateChild(szMsiFoldersKey);
    
    MsiString strFolderPath;
    RETURN_ERROR_RECORD(riPath.GetFullUNCFilePath(TEXT(""),*&strFolderPath));
    MsiString strValue;
    if (fExplicitCreation)
        strValue = *TEXT("1");

    {
        CElevate elevate;
        RETURN_ERROR_RECORD(pFoldersKey->SetValue(strFolderPath, *strValue));
    }
    return 0;
}

IMsiRecord* CMsiConfigurationManager::IsFolderRemovable(IMsiPath& riPath, Bool fExplicit, Bool& fRemovable)
//----------------------------------------------
{
    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine);
    PMsiRegKey pFoldersKey = &pLocalMachine->CreateChild(szMsiFoldersKey);
    
    MsiString strFolder;
    RETURN_ERROR_RECORD(riPath.GetFullUNCFilePath(TEXT(""),*&strFolder));

    Bool fExists;
    RETURN_ERROR_RECORD(pFoldersKey->ValueExists(strFolder, fExists));
    
    fRemovable = fFalse;

    if (fExists)
    {
        if (fExplicit)
        {
            fRemovable = fTrue;
        }
        else
        {
            MsiString strData;
            RETURN_ERROR_RECORD(pFoldersKey->GetValue(strFolder, *&strData));
            fRemovable = (strData.TextSize() == 0) ? fTrue : fFalse;
        }
    }
    
    return 0;
}

IMsiRecord* CMsiConfigurationManager::UnregisterFolder(IMsiPath& riPath)
//----------------------------------------------
{
    PMsiRegKey pLocalMachine = &m_piServices->GetRootKey(rrkLocalMachine);
    PMsiRegKey pFoldersKey = &pLocalMachine->CreateChild(szMsiFoldersKey);

    MsiString strFolder;
    RETURN_ERROR_RECORD(riPath.GetFullUNCFilePath(TEXT(""),*&strFolder));
    {
        CElevate elevate;
        RETURN_ERROR_RECORD(pFoldersKey->RemoveValue(strFolder, 0));
    }
    return 0;
}

void CMsiConfigurationManager::ChangeServices(IMsiServices& riServices)
{

    m_piServices = &riServices;

}

//____________________________________________________________________________
//
// CEnumRollbackScripts implementation
//____________________________________________________________________________

CEnumRollbackScripts::CEnumRollbackScripts(const MsiDate date,
                                                         const Bool fAfter,
                                                            IMsiServices& riServices)
    : m_iRefCnt(1), m_fDone(fFalse),
      m_pServices(&riServices),
      m_piEnum(0), m_pRollbackKey(0),
      m_date(date), m_fAfter(fAfter)
{
    PMsiRecord pError(0);

    riServices.AddRef();

    PMsiRegKey pLocalMachine = &riServices.GetRootKey(rrkLocalMachine);
    m_pRollbackKey = &pLocalMachine->CreateChild(MsiString(szMsiRollbackScriptsKey));
    
    if (pError = m_pRollbackKey->GetValueEnumerator(m_piEnum))
    {
        m_piEnum = 0;
        return;
    }
}

CEnumRollbackScripts::~CEnumRollbackScripts()
{
    if (m_piEnum)
        m_piEnum->Release();
}

HRESULT CEnumRollbackScripts::QueryInterface(const IID& riid, void** ppvObj)
{
    if (riid == IID_IUnknown || riid == IID_IEnumMsiString)
        return (*ppvObj = this, AddRef(), NOERROR);
    else
        return (*ppvObj = 0, E_NOINTERFACE);
}

unsigned long CEnumRollbackScripts::AddRef()
{
    return ++m_iRefCnt;
}

unsigned long CEnumRollbackScripts::Release()
{
    if (--m_iRefCnt != 0)
        return m_iRefCnt;
    delete this;
    return 0;
}

HRESULT CEnumRollbackScripts::Next(unsigned long cFetch, const IMsiString** rgpi, unsigned long* pcFetched)
{
    PMsiRecord pError(0);
    PMsiRecord pFetched(0);
    int cFetched = 0;
    unsigned long cRequested = cFetch;

    while(cFetch)
    {
        MsiString strScriptFile = 0;
        HRESULT hRes = m_piEnum->Next(1, &strScriptFile, 0);
        if (S_FALSE == hRes)
            break;
        else if (S_OK != hRes)
            return E_FAIL;

        MsiString strDate;
        pError = m_pRollbackKey->GetValue(strScriptFile, *&strDate);
        if (pError != 0)
            return E_FAIL;

        strDate.Remove(iseFirst, 1);
        if (m_fAfter && ((MsiDate)(int)strDate < m_date))
            continue;
        else if (!m_fAfter && ((MsiDate)((int)strDate > m_date)))
            continue;

        strDate += TEXT("#");
        strDate += strScriptFile;
        strDate.ReturnArg(*rgpi);

        rgpi++;
        cFetch--;
        cFetched++;
    }
    
    if (pcFetched)
        *pcFetched = cFetched;  
    return (cFetched == cRequested  ? S_OK : S_FALSE);
}

HRESULT CEnumRollbackScripts::Skip(unsigned long cSkip)
{
    PMsiRecord pFetched(0);
    PMsiRecord pError(0);
    while (cSkip)
    {
        MsiString strScriptFile;
        HRESULT hRes = m_piEnum->Next(1, &strScriptFile, 0);
        if (hRes == S_FALSE)
            break;
        else if (hRes == E_FAIL)
            return E_FAIL;

        MsiString strDate;
        pError = m_pRollbackKey->GetValue(strScriptFile, *&strDate);
        if (pError != 0)
            return E_FAIL;

        strDate.Remove(iseFirst, 1);
        if (m_fAfter && ((MsiDate)(int)strDate < m_date))
            continue;
        else if (!m_fAfter && ((MsiDate)((int)strDate > m_date)))
            continue;

        cSkip--;
    }
    return cSkip ? S_FALSE : NOERROR;
}

HRESULT CEnumRollbackScripts::Reset()
{
    PMsiRecord pError(0);
    m_fDone = fFalse;

    m_piEnum->Release();
    
    if (pError = m_pRollbackKey->GetValueEnumerator(m_piEnum))
    {
        m_piEnum = 0;
        return E_FAIL;
    }

    return NOERROR;
}

HRESULT CEnumRollbackScripts::Clone(IEnumMsiString** ppiEnum)
{
    CEnumRollbackScripts* piEnum = new CEnumRollbackScripts(m_date,
        m_fAfter, *m_pServices);
    if (piEnum && !piEnum->ConstructedOK())
        delete piEnum, piEnum = 0;
    return ((*ppiEnum = piEnum) != 0) ? NOERROR: E_OUTOFMEMORY;
}

UINT CMsiConfigurationManager::SourceListClearByType(const ICHAR* szProductCode, const ICHAR* szUserName, isrcEnum isrcType)
{
    CCoImpersonate impersonate;
    DISPLAYACCOUNTNAME(TEXT("After impersonating in service for SourceList API: "));
    
    //!! future support more than just isrcNet
    if (isrcType != isrcNet)
    {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD dwResult;
    CMsiSourceList SourceList;
    bool fMachine = (!szUserName || !*szUserName);
    if (ERROR_SUCCESS != (dwResult = SourceList.OpenSourceList(/*fVerifyOnly=*/false, fMachine, szProductCode, szUserName)))
        return dwResult;
    return SourceList.ClearListByType(isrcType);
}

UINT CMsiConfigurationManager::SourceListAddSource(const ICHAR* szProductCode, const ICHAR* szUserName, isrcEnum isrcType,
                                         const ICHAR* szSource)
{
    CCoImpersonate impersonate;
    DISPLAYACCOUNTNAME(TEXT("After impersonating in service for SourceList API: "));
    
    //!! future support more than just isrcNet
    if (isrcType != isrcNet)
    {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD dwResult;
    CMsiSourceList SourceList;
    bool fMachine = (!szUserName || !*szUserName);
    if (ERROR_SUCCESS != (dwResult = SourceList.OpenSourceList(/*fVerifyOnly=*/false, fMachine, szProductCode, szUserName)))
        return dwResult;

    dwResult = SourceList.AddSource(isrcType, szSource);
    return dwResult;
}

UINT CMsiConfigurationManager::SourceListClearLastUsed(const ICHAR* szProductCode, const ICHAR* szUserName)
{
    CCoImpersonate impersonate;
    DISPLAYACCOUNTNAME(TEXT("After impersonating in service for SourceListAPI:"));

    DWORD dwResult;
    CMsiSourceList SourceList;
    bool fMachine = (!szUserName || !*szUserName);
    if (ERROR_SUCCESS != (dwResult = SourceList.OpenSourceList(/*fVerifyOnly=*/false, fMachine, szProductCode, szUserName)))
        return dwResult;

    dwResult = SourceList.ClearLastUsed();
    return dwResult;
}

// CreateCustomActionProxy spawns the custom action server process, waits for it to register, then returns
// a proxy interface to the caller. This function is responsible for creating the appropriate process token
// in the requested security context, generating the cookie, storing the outgoing RemoteAPI and process
// information for the registration function to pass to the client, and passing the resulting cookie and
// process information to the caller. Must be impersonating when making this call.
IMsiCustomAction* CMsiConfigurationManager::CreateCustomActionProxy(const icacCustomActionContext icacDesiredContext, const unsigned long dwProcessId, 
	IMsiRemoteAPI *pRemoteAPI, const WCHAR* pvEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, int *pcbCookie, 
	HANDLE *phServerProcess, unsigned long *pdwServerProcessId, bool fClientOwned, bool fRemapHKCU)
{
	Assert(IsImpersonating(true));
	
	// only one thread can be creating a custom action proxy at a time. Calls by additional threads
	// must block. This prevents additional CA threads from creating extra processes because the
	// first one is still starting up and hasn't gotten back to us yet. 
	EnterCriticalSection(&m_csCreateProxy);

    // ensure that we have a GIT pointer
    if (!m_piGIT)
    {
        if (S_OK != OLE32::CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&m_piGIT))
        {
            LeaveCriticalSection(&m_csCreateProxy);
            return NULL;
        }
    }

    // we cannot rely on OLE to create the custom action server interface for us, becuase it will create
    // the process as the owner of the desktop, which is not necessarily the user who is running the install.
    // Therefore, we explicitly call CreateProcessAsUser providing a cookie, and wait for the custom action
    // server to connect back to the service identifying itself as the correct process and providing the
    // IMsiCustomAction interface for itself.
    HANDLE hTokenPrimary = 0;
	
	// prepare the appropriate token by duplicating either our impersonation token or the process token. It
	// is the responsibility of the callER to ensure that elevated contexts are appropriate with respect
	// to the install session and security policies, as this function does not do any safety checks beyond
	// "are we the service"

	bool fElevateCustomActionServer = (g_scServerContext == scService && ((icacDesiredContext == icac64Elevated) || (icacDesiredContext == icac32Elevated)));

	if (fElevateCustomActionServer)
	{
		//
		// SAFER: elevated custom action server does not need to be marked inert since process
		//        running as local_system is not subject to SAFER policy
		//

		// elevate this block to ensure rights to the system process token
		{
			CElevate elevate;

            HANDLE	hTokenService = 0;

            // work with a duplicate of our process token so we don't make any permanent changes            
            if (OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hTokenService) && hTokenService)
            {           
                // if this call fails, set hTokenPrimary to 0, which causes us to drop out later
                if (!ADVAPI32::DuplicateTokenEx(hTokenService, MAXIMUM_ALLOWED, 0, SecurityAnonymous, TokenPrimary, &hTokenPrimary))
                {
                    hTokenPrimary = 0;
                }
                CloseHandle(hTokenService);
            }
        }
                
        // on NT5 systems, the token used to create the process must have the appropriate session information
        // inside or UI thrown by the CA will pop up on the console. On NT4 we don't support remote installs,
        // and the TokenSessionId information is inaccessible anyway.
        if (g_iMajorVersion >= 5)
        {
            // open the thread token. This may be called via COM while an install is in progress, so
            // we can't assume that the token from GetUserToken() is the right token
            HANDLE hTokenUser = 0;

            // TRUE for OpenAsSelf argument makes call as system to ensure that we have access.
            if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hTokenUser))
            {
                // failed to get user information. Its better to fail completely than to continue and allow
                // the custom action to open a security hole by throwing UI from an elevated process to a
                // different session. Setting hTokenPrimary to 0 causes a failure later
                CloseHandle(hTokenPrimary);
                hTokenPrimary = 0;
            }
            else
            {
                DWORD dwSessionId = 0;
                DWORD cbResult = 0;

				// elevate this block to provide write access to the primary token.
				CElevate elevate;
				
				// grab the session ID from the users token and place it in the duplicate service token
				if (!GetTokenInformation(hTokenUser, (TOKEN_INFORMATION_CLASS)TokenSessionId, &dwSessionId, sizeof(DWORD), &cbResult) ||
					!SetTokenInformation(hTokenPrimary, (TOKEN_INFORMATION_CLASS)TokenSessionId, &dwSessionId, sizeof(DWORD)))
				{
					// failed to set session information. Its better to fail completely than to continue and allow
					// the custom action to open a security hole by throwing UI from an elevated process to a 
					// different session.
					CloseHandle(hTokenPrimary);
					hTokenPrimary = 0;
				}
				
				CloseHandle(hTokenUser);
			}
		}
	}
	else
	{
		//
		// SAFER: must mark token inert so that executing custom actions are not subject to SAFER
		//        policy check.  We already indicated we trusted the package
		//

		// open the thread token. This may be called via COM while an install is in progress, so 
		// we can't assume that the token from GetUserToken() is the right token
		HANDLE hTokenUser = 0;


        // TRUE for OpenAsSelf argument makes call as process token (system) to ensure that we have access
        if(OpenThreadToken(GetCurrentThread(), TOKEN_DUPLICATE, TRUE, &hTokenUser))
        {       
			if (MinimumPlatformWindowsNT51())
			{
				// we must first duplicate the token so that we have a proper primary token for CreateProcessAsUser
				// upon success, we'll mark the token INERT

				HANDLE hTokenDup = 0;
				if (0 == ADVAPI32::DuplicateTokenEx(hTokenUser, MAXIMUM_ALLOWED, 0, SecurityAnonymous, TokenPrimary, &hTokenDup))
				{
					CloseHandle(hTokenDup);
					hTokenDup = 0;
				}

				// normally we would try to create this using ADVAPI32::ComputeAccessTokenFromCodeAuthzLevel, but there's
				// no guarantee that the global message context is available.  Therefore we use CreateRestrictedToken
				// to explicitly mark the token inert, but we don't disable any privileges
				if (hTokenDup && 0 == ADVAPI32::CreateRestrictedToken(hTokenDup, SANDBOX_INERT, 0, NULL, 0, NULL, 0, NULL, &hTokenPrimary))
				{
					CloseHandle(hTokenPrimary);
					hTokenPrimary = 0;
				}
				if (hTokenDup)
					CloseHandle(hTokenDup);
			}
			else
			{
				if (0 == ADVAPI32::DuplicateTokenEx(hTokenUser, MAXIMUM_ALLOWED, 0, SecurityAnonymous, TokenPrimary, &hTokenPrimary))
				{
					CloseHandle(hTokenPrimary);
					hTokenPrimary = 0;
				}
			}            CloseHandle(hTokenUser);
        }
    }

    // if for any reason we were unable to create the primary token or assign it the appropriate session
    // id, we won't be able to run the action securely.
    if (!hTokenPrimary)
    {
        DEBUGMSGV("Failed to create primary token while spawning Custom Action Server.");
        LeaveCriticalSection(&m_csCreateProxy);
        return NULL;
    }

    // generate a cookie to use in authenticating the the custom action server.
    m_CustomServerInfo.m_rgchWaitingCookie[0] = 0;

    // if crypto failed, generate a pseudo-random cookie. note that using srand/rand/time
    // requires linking in a non-trivial part of the standard c library, so instead, we
    // use RtlRandom, which is a pseudo-random number generator implemented by NT.
    DEBUGMSGV("Generating random cookie.");
    ULONG ulSeed = GetTickCount();
    for (int iCookieByte = 0; iCookieByte < iRemoteAPICookieSize; iCookieByte++)
        m_CustomServerInfo.m_rgchWaitingCookie[iCookieByte] = static_cast<unsigned char>(NTDLL::RtlRandom(&ulSeed) % 255);

    // generate a command line and working dir
    MsiString strWorkingDir = 0;
    MsiString strExecutable = 0;
    CTempBuffer<ICHAR, MAX_PATH> szWorkingDir;
    CTempBuffer<ICHAR, 2*MAX_PATH+2*iRemoteAPICookieSize+2> szCommandLine;
    
    // Get the appropriate working directory based on the bitness.

    // get the full path to the appropriate copy of msiexec.exe (32 or 64)
    // and the appropriate working directory based on the bitness.
    PMsiRecord piError = 0;
    if (icacDesiredContext == icac64Elevated || icacDesiredContext == icac64Impersonated)
    {
        piError = GetServerPath(*m_piServices, /*fUNC=*/false, /*f64Bit=*/true, *&strExecutable);
        MsiGetSystemDirectory(szWorkingDir, MAX_PATH, /*bAlwaysReturnWOW64Dir=*/ FALSE);
    }
    else
    {
        piError = GetServerPath(*m_piServices, /*fUNC=*/false, /*f64Bit=*/false, *&strExecutable);
        MsiGetSystemDirectory(szWorkingDir, MAX_PATH, /*bAlwaysReturnWOW64Dir=*/ TRUE);
    }
        
    // msiexec.exe command line parsing expects the executable to be first on the command line
    // so even though we explicitly provide the executable path, we need to provide it as part
    // of the command line as well.
    IStrCopy(szCommandLine, strExecutable);

    //!!future should change this to something that isn't OLE-overloaded
    IStrCat(szCommandLine, TEXT(" -Embedding "));

    // convert the cookie to a set of chars (hex encoding, in 4-bit chunks, high4 then low4)
    CTempBuffer<ICHAR, 2*iRemoteAPICookieSize+1> rgchCookieString;
    const ICHAR rgchHex[]=TEXT("0123456789ABCDEF");
    for (int iCookieByte=0; iCookieByte < iRemoteAPICookieSize; iCookieByte++)
    {
        rgchCookieString[2*iCookieByte] = rgchHex[m_CustomServerInfo.m_rgchWaitingCookie[iCookieByte] / 0x10];
        rgchCookieString[2*iCookieByte+1] = rgchHex[m_CustomServerInfo.m_rgchWaitingCookie[iCookieByte] % 0x10];
    }
    rgchCookieString[2*iRemoteAPICookieSize] = 0;

    IStrCat(szCommandLine, rgchCookieString);

	// pass the client-owned state to the server so it can correctly pass foreground rights
	// back to the client.
	HANDLE hServerResumeEvent = INVALID_HANDLE_VALUE;
	if (fClientOwned)
	{
		IStrCat(szCommandLine, TEXT(" C"));
	}
	else if (fElevateCustomActionServer)
	{
		if (fRemapHKCU)
			IStrCat(szCommandLine, TEXT(" M "));
		else
			IStrCat(szCommandLine, TEXT(" E "));
	
		// if attempting to elevate the custom action server we'll need to create
		// a named global event to get the CA server to wait for its thread token
		// before loading the registry hive.
		SECURITY_ATTRIBUTES EventAttributes;
		EventAttributes.nLength = sizeof(EventAttributes);
		EventAttributes.bInheritHandle = FALSE;
		if (ERROR_SUCCESS == GetSecureSecurityDescriptor(reinterpret_cast<char**>(&EventAttributes.lpSecurityDescriptor), fFalse, fFalse))
		{
			ICHAR rgchName[20] = TEXT("");
			int chFirstChar = 0;
			if (MinimumPlatformWindows2000())
			{
				IStrCopy(rgchName, TEXT("Global\\"));
				chFirstChar = 7;
			}
			IStrCopy(&rgchName[chFirstChar], TEXT("MSI"));
			chFirstChar+=3;
			for (int iEventID=0; iEventID < 0xFFFF; iEventID++)
			{
				rgchName[chFirstChar]   = rgchHex[(iEventID & 0xF000) >> 12];
				rgchName[chFirstChar+1] = rgchHex[(iEventID & 0x0F00) >> 8];
				rgchName[chFirstChar+2] = rgchHex[(iEventID & 0x00F0) >> 4];
				rgchName[chFirstChar+3] = rgchHex[(iEventID & 0x000F)];
				rgchName[chFirstChar+4] = 0;

				// elevate to set system as owner of event
				DWORD dwLastError = 0;
				{
					CElevate elevate;
					hServerResumeEvent = CreateEvent(&EventAttributes, TRUE, FALSE, rgchName);

					// must grab last error before elevate destructor
					dwLastError = GetLastError();
				}

				// event handle returned, ensure that the event didn't already exist
				if (hServerResumeEvent != 0 && hServerResumeEvent != INVALID_HANDLE_VALUE)
				{
					if (dwLastError == ERROR_ALREADY_EXISTS)
					{
						WIN::CloseHandle(hServerResumeEvent);
						hServerResumeEvent = 0;
					}
					else 
						break;
				}
			}
			IStrCat(szCommandLine, rgchName);
		}
		if (!hServerResumeEvent || hServerResumeEvent == INVALID_HANDLE_VALUE)
		{
			DEBUGMSGV("Failed to create Custom Action Server wake event.");
			WIN::CloseHandle(hTokenPrimary);
			LeaveCriticalSection(&m_csCreateProxy);
			return NULL;
		}
	}

    // create an unnamed event to wait on. (non-inheritable, auto-reset, initially unsignaled)
    // the registration thread signals this event when registration is completed
    m_hCARegistered = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!m_hCARegistered)
    {
        DEBUGMSGV("Failed to create Custom Action Server event.");
        WIN::CloseHandle(hTokenPrimary);
		if (hServerResumeEvent != INVALID_HANDLE_VALUE)
			WIN::CloseHandle(hServerResumeEvent);
        LeaveCriticalSection(&m_csCreateProxy);
        return NULL;
    }
    
    // create the process as the desired user
    PROCESS_INFORMATION pi;
    STARTUPINFO si;

    // init the structures to all 0
    memset(&si, 0, sizeof(si));
    si.cb        = sizeof(si);

    // set STARTUPINFO.lpDesktop to WinSta0\Default. When combined with the TS sessionID from the
    // token, this places any UI on the visible desktop of the appropriate session.
    si.lpDesktop=TEXT("WinSta0\\Default");
    {       
        CSIDAccess SIDAccess[3];

        SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
        SID_IDENTIFIER_AUTHORITY siaWorld   = SECURITY_WORLD_SID_AUTHORITY;

        // LocalSystem and Admins always have full access to the process
        if ((!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(SIDAccess[0].pSID))) ||
            (!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(SIDAccess[1].pSID))))
        {
            return 0;
        }
        SIDAccess[0].dwAccessMask = PROCESS_ALL_ACCESS;
        SIDAccess[1].dwAccessMask = PROCESS_ALL_ACCESS;

        // if an elevated context, don't give the user any access to the process at all, otherwise, give
        // the user all access except WRITE on the DACL, memory reads, memory writes, and procinfo change
        int cSD = 2;
        char rgchSID[cbMaxSID];             
        if (g_scServerContext != scService || (icacDesiredContext == icac64Impersonated) || (icacDesiredContext == icac32Impersonated))
        {
            // open the thread token. This may be called via COM while an install is in progress, so
            // we can't assume that the token from GetUserToken() is the right token
            HANDLE hTokenUser = 0;

            // TRUE for OpenAsSelf argument makes call with process token (system) to ensure that we have access.
            if(OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hTokenUser))
            {       
                if (ERROR_SUCCESS == GetUserSID(hTokenUser, rgchSID))
                {
                    // add the user token to the end of the array and increment the count of SIDs so the ACL
                    // functions pick up the new SID.
                    SIDAccess[2].pSID = (SID*)rgchSID;
                    cSD++;
                    
                    // tell the CSIDAccess class not to free the user's SID, as its a static array managed by
                    // the vertrust functions
                    SIDAccess[2].pSID.FreeSIDOkay(false);
					SIDAccess[2].dwAccessMask = PROCESS_ALL_ACCESS & ~(WRITE_DAC | WRITE_OWNER | PROCESS_SET_INFORMATION);
					//
					// Lock down process on x86 further to enhance our security
					// model. This cannot be done on IA64 because the kernel's
					// CreateThread calls themselves try to read PEB32 from the
					// virtual memory. So if the user is denied these rights,
					// NtReadVirtualMemory fails with ACCESS_DENIED and as a 
					// result CreateThread returns ERROR_MAX_THRDS_REACHED.

#ifndef _WIN64
					if (!g_fWinNT64)
					{
						SIDAccess[2].dwAccessMask &= (~(PROCESS_VM_WRITE | PROCESS_VM_READ));
					}
#endif // _WIN64

                }
                CloseHandle(hTokenUser);
            }
        }

        // set the "waiting context" to the desired context. RegisterCustomAction only accepts
        // incoming connections for one context at a time (internally this is enforced
        // via the critical section in this method) and must reject registrations for the wrong
        // context, even if the cookie matches.
        m_CustomServerInfo.m_icacWaitingContext = icacDesiredContext;

        // store the RemoteAPI interface. This interface is passed back to the client. Don't forget to marshal
        // to the registration thread via the GIT
        if (S_OK != m_piGIT->RegisterInterfaceInGlobal(pRemoteAPI, IID_IMsiRemoteAPI, &m_CustomServerInfo.m_dwRemoteCookie))
        {
            DEBUGMSGV("Unable to register RemoteAPI in GIT for registration.");
            WIN::CloseHandle(hTokenPrimary);
			if (hServerResumeEvent != INVALID_HANDLE_VALUE)
				WIN::CloseHandle(hServerResumeEvent);
            LeaveCriticalSection(&m_csCreateProxy);
            return NULL;
        }

		// process id to pass to CA server. This is the process id of the eventual interface client
		// and is used by the CA server in its main thread to watch for client death and clean up
		// when the requesting process dies
		m_CustomServerInfo.m_dwProcessId = dwProcessId;

		// privilige bitmap to pass to CA server. For client-owned servers, this tells the server
		// what privileges need to be disabled before actions can run
		m_CustomServerInfo.m_dwPrivileges = dwPrivileges;

		// per bug 196384, we will create the process suspended for elevated custom actions so that we may
		// add the user token as the thread token.  we'll then resume the process thread.  this will allow
		// us to properly map HKCU
		BOOL fProcessCreated = false;

		// must elevate this block or CSecurityDescription won't be able to set the owner of the process to LOCALSYSTEM
		// and CreateProcess will fail
		{
			HANDLE	hTokenUser = INVALID_HANDLE_VALUE;
			// TRUE for OpenAsSelf argument makes call as process token (system) to ensure that we have access
			// error case checked below.
			if (!OpenThreadToken(GetCurrentThread(), MSI_TOKEN_ALL_ACCESS, TRUE, &hTokenUser))
			{
				DEBUGMSGV("Unable to grab user token for impersonation.");
				WIN::CloseHandle(hTokenPrimary);
				if (hServerResumeEvent != INVALID_HANDLE_VALUE)
					WIN::CloseHandle(hServerResumeEvent);
				m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
				m_CustomServerInfo.m_dwRemoteCookie = 0;
				LeaveCriticalSection(&m_csCreateProxy);
				return NULL;
			}

			// Check if the "user" is actually system. In that case, the registration code must
			// be ready to accept elevated servers when requesting impersonated servers.
			m_CustomServerInfo.m_fImpersonatedIsSystem = fClientOwned && IsLocalSystemToken(hTokenUser);

			CElevate elevate;
			CSecurityDescription secdesc((PSID) SIDAccess[0].pSID, (PSID) NULL, SIDAccess, cSD);
			if (secdesc.isValid())
			{
				DWORD dwCreationFlags = NORMAL_PRIORITY_CLASS;
				void* pvCreationEnvironment = NULL;
				if (fClientOwned)
				{
					Assert(!g_fWin9X);
					dwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;
					pvCreationEnvironment = const_cast<void*>(reinterpret_cast<const void*>(pvEnvironment));
				}

				fProcessCreated = ADVAPI32::CreateProcessAsUser(hTokenPrimary, strExecutable, szCommandLine, (LPSECURITY_ATTRIBUTES) secdesc, (LPSECURITY_ATTRIBUTES)0, FALSE,
					dwCreationFlags, pvCreationEnvironment, szWorkingDir, (LPSTARTUPINFO)&si, (LPPROCESS_INFORMATION)&pi);
				DEBUGMSGV2(TEXT("Created Custom Action Server with PID %d (0x%X)."), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(pi.dwProcessId)), reinterpret_cast<const ICHAR *>(static_cast<UINT_PTR>(pi.dwProcessId)));
				
				if (fElevateCustomActionServer && fProcessCreated)
				{
					if (hTokenUser != INVALID_HANDLE_VALUE)
					{
						SetThreadToken(&pi.hThread, hTokenUser);
						WIN::CloseHandle(hTokenUser);
						hTokenUser = INVALID_HANDLE_VALUE;
					}
					
					// resume the suspended process
					if (!SetEvent(hServerResumeEvent))
					{
						// something bad happened...
						// we'll clean up the zombie process and return NULL
						AssertSz(0, "Unable to resume the suspended thread in CreateCustomActionProxy!");
						TerminateProcess(pi.hProcess, 0);
						WIN::CloseHandle(pi.hProcess);
						WIN::CloseHandle(hTokenPrimary);
						if (hServerResumeEvent != INVALID_HANDLE_VALUE)
							WIN::CloseHandle(hServerResumeEvent);
						m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
						m_CustomServerInfo.m_dwRemoteCookie = 0;
						LeaveCriticalSection(&m_csCreateProxy);
						return NULL;
					}
				}
				WIN::CloseHandle(pi.hThread);
			}
			else
			{
				AssertSz(0, "Created an invalid security descriptor in CreateCustomActionProxy!");
				if (hTokenUser != INVALID_HANDLE_VALUE)
					WIN::CloseHandle(hTokenUser);
				WIN::CloseHandle(hTokenPrimary);
				if (hServerResumeEvent != INVALID_HANDLE_VALUE)
					WIN::CloseHandle(hServerResumeEvent);
				m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
				m_CustomServerInfo.m_dwRemoteCookie = 0;
				LeaveCriticalSection(&m_csCreateProxy);
				return NULL;
			}
			if (hTokenUser != INVALID_HANDLE_VALUE)
				WIN::CloseHandle(hTokenUser);
		}
		
		WIN::CloseHandle(hTokenPrimary);
		if (!fProcessCreated)
		{
			DEBUGMSGV("Failed to create Custom Action Server.");
			m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
			m_CustomServerInfo.m_dwRemoteCookie = 0;
			if (hServerResumeEvent != INVALID_HANDLE_VALUE)
				WIN::CloseHandle(hServerResumeEvent);
			LeaveCriticalSection(&m_csCreateProxy);
			return NULL;
		}
	}

    // wait until the custom action server checks back with us and is authenticated, or until it the child
    // process dies. Must pump messages here or we won't be able to handle incoming requests
    HANDLE rghWaitArray[2] = {pi.hProcess, m_hCARegistered};
    for(;;)
    {
        DWORD iWait = WIN::MsgWaitForMultipleObjects(2, rghWaitArray, FALSE, INFINITE, QS_ALLINPUT);
        if (iWait == WAIT_OBJECT_0 + 2)
        {       
            // window message, need to pump until the queue is clear
            MSG msg;
            while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
            {
                WIN::TranslateMessage(&msg);
                WIN::DispatchMessage(&msg);
            }
            continue;
        }
        else if (iWait == WAIT_OBJECT_0 + 1)
        {
            // m_hCARegistered was signaled, registration was successful
            break;
        }
        else if (iWait == WAIT_OBJECT_0)
        {
            // because the process is first in the wait array, WAIT_OBJECT_0 means the
            // process died before it was authenticated. Close m_hCARegistered so
            // the registration function isn't left in a state where it will accept
            // an incoming server registration.
			DEBUGMSG("CA Server Process has terminated.");
            WIN::CloseHandle(m_hCARegistered);
            WIN::CloseHandle(pi.hProcess);
			if (hServerResumeEvent != INVALID_HANDLE_VALUE)
				WIN::CloseHandle(hServerResumeEvent);
            m_hCARegistered = 0;
            m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
            m_CustomServerInfo.m_dwRemoteCookie = 0;
            LeaveCriticalSection(&m_csCreateProxy);
            return NULL;
        }
        else if (iWait == 0xFFFFFFFF) // should be the same on 64bit;
        {
            // error
            AssertSz(0, "Error in MsgWait");
            WIN::CloseHandle(m_hCARegistered);
            WIN::CloseHandle(pi.hProcess);
			if (hServerResumeEvent != INVALID_HANDLE_VALUE)
				WIN::CloseHandle(hServerResumeEvent);
            m_hCARegistered = 0;
            m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
            m_CustomServerInfo.m_dwRemoteCookie = 0;
            LeaveCriticalSection(&m_csCreateProxy);
            return NULL;
        }
        else if (iWait == WAIT_TIMEOUT)
        {
            // our current wait period is forever, but if that changes, this could happen.
            DEBUGMSGV("Custom Action Server never connected to service.");
            WIN::CloseHandle(m_hCARegistered);
            WIN::CloseHandle(pi.hProcess);
			if (hServerResumeEvent != INVALID_HANDLE_VALUE)
				WIN::CloseHandle(hServerResumeEvent);
            m_hCARegistered = 0;
            m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
            m_CustomServerInfo.m_dwRemoteCookie = 0;
            LeaveCriticalSection(&m_csCreateProxy);
            return 0;
        }
    }
    WIN::CloseHandle(m_hCARegistered);
	if (hServerResumeEvent != INVALID_HANDLE_VALUE)
		WIN::CloseHandle(hServerResumeEvent);
    m_hCARegistered = 0;

    // store the process handle. DO NOT close the handle. This ensures that the handle remains
    // valid even if the process dies, because a process id isn't reused until all process handles
    // have been released.
    if (phServerProcess)
        *phServerProcess = pi.hProcess;

    // and ProcessId
    if (pdwServerProcessId)
        *pdwServerProcessId = pi.dwProcessId;

    // RemoteAPI can be released from the GIT, the client process now has a refcount to keep it alive
    m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie);
    m_CustomServerInfo.m_dwRemoteCookie = 0;
    
    // if the caller wants the cookie, copy it to their provided buffer
    if (pcbCookie && rgchCookie && *pcbCookie >= iRemoteAPICookieSize)
    {
        *pcbCookie = iRemoteAPICookieSize;
        memcpy(rgchCookie, m_CustomServerInfo.m_rgchWaitingCookie, iRemoteAPICookieSize);
    }

    // grab the custom action interface, and then dispose of the entry in the GIT
    IMsiCustomAction* piCustomAction = NULL;
    m_piGIT->GetInterfaceFromGlobal(m_CustomServerInfo.m_dwGITCookie, IID_IMsiCustomAction, reinterpret_cast<void **>(&piCustomAction));
    m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwGITCookie);

    // don't need this GIT anymore
    m_piGIT->Release();
    m_piGIT = 0;
    m_CustomServerInfo.m_dwGITCookie = 0;
    
    LeaveCriticalSection(&m_csCreateProxy);
    return piCustomAction;
}

// destroys the custom action server in the ConfigManager, releasing any servers if necessary.
UINT CMsiConfigurationManager::ShutdownCustomActionServer()
{
    EnterCriticalSection(&m_csCreateProxy);
    if (m_pCustomActionManager)
    {
        m_pCustomActionManager->ShutdownCustomActionServer();
        delete m_pCustomActionManager;
        m_pCustomActionManager = 0;
    }
    LeaveCriticalSection(&m_csCreateProxy);
    return ERROR_SUCCESS;
};

// public interface call used to broker a request for a server between the client and the server.
// for security reasons, this call only accepts impersonated context requests.
UINT CMsiConfigurationManager::CreateCustomActionServer(const icacCustomActionContext icacContext, const unsigned long dwClientProcessId,
    IMsiRemoteAPI *piRemoteAPI, const WCHAR* pvEnvironment, DWORD cchEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, 
	int *cbCookie, IMsiCustomAction **piCustomAction, unsigned long *dwServerProcessId)
{
    // fail immediately if any arguments are bad
    if (!piCustomAction || !piRemoteAPI || !rgchCookie || !cbCookie || !dwServerProcessId)
        return ERROR_INVALID_PARAMETER;

    // if there won't be enough space for the cookie, fail immediately
    if (*cbCookie < iRemoteAPICookieSize)
        return ERROR_MORE_DATA;

    // clients are only allowed to create impersonated contexts
    if (icacContext != icac64Impersonated && icacContext != icac32Impersonated)
        return ERROR_ACCESS_DENIED;

	// verify that the environment block is doubly-null terminated
	if ((cchEnvironment < 2) ||
		(pvEnvironment[cchEnvironment-1] != L'\0') ||
		(pvEnvironment[cchEnvironment-2] != L'\0'))
		return ERROR_INVALID_PARAMETER;

	{
		// must impersonate the client to create the appropriate custom action server
		CCoImpersonate impersonate;	

		// because we are only creating an impersonated server, no remapping of HKCU is needed
		// since it will always be the right one
		
		// need to pass back processId of CA server for tracking by the client. Because the ProcessId could be 
		// reissued if the process dies, the client must ensure that the ProcessId is valid by verifying that
		// the custom action COM interface is still connected AFTER openining a process handle to the provided
		// process id. 
		if (piCustomAction)
			*piCustomAction = CreateCustomActionProxy(icacContext, dwClientProcessId, piRemoteAPI, pvEnvironment, dwPrivileges, rgchCookie, cbCookie, NULL, dwServerProcessId, true, /* fRemapHKCU = */ false);
	}

	return ERROR_SUCCESS;
}


// public interface call used by the server to register itself with the service (and thus indirectly the
// client if it is a brokered request). Only one context is active at a time, so incorming registration
// for a different context is immediately rejected. Context is verified by impersonating the client and
// checking the token, so the client must be making the call at Identify level or greater.
UINT CMsiConfigurationManager::RegisterCustomActionServer(icacCustomActionContext* picacContext, const unsigned char *rgchCookie, const int cbCookie, IMsiCustomAction *piCustomAction, unsigned long *pdwProcessId, IMsiRemoteAPI **piRemoteAPI, DWORD *pdwPrivileges)
{
    CCoImpersonate impersonate;

	if (!picacContext)
		return ERROR_INVALID_PARAMETER;
    
    EnterCriticalSection(&m_csRegisterAction);

    // if we aren't expecting a server or already have the required registration, don't accept any more calls.
    if (!m_hCARegistered || m_CustomServerInfo.m_dwGITCookie)
    {
        DEBUGMSGV("Custom Action Server rejected - Invalid Context.");
        LeaveCriticalSection(&m_csRegisterAction);
        return ERROR_ACCESS_DENIED;
    }
    
    // we must ensure that the process calling us is in the appropriate context. If we mix up 32 and 64 bit, nothing
    // bad will happen except that the install will fail. However we must ensure that we aren't registering a user
    // process as the elevated server. We do this by impersonating the client and then checking the token identity
    icacCustomActionContext icacTrueContext = icac32Impersonated;
    HANDLE hToken;
    if (WIN::OpenThreadToken(WIN::GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
    {
        icacTrueContext = IsLocalSystemToken(hToken) ? icac32Elevated : icac32Impersonated;
        WIN::CloseHandle(hToken);
    }
	
	// if the client is localsystem, the CA server could be reporting itself as elevated when it is actually
	// filling the role of the impersonated server. In that scenario, these security checks are not applicable.
	// For non-client owned processes, we simply consolidate the impersonated server into the elevated server.
	if (!m_CustomServerInfo.m_fImpersonatedIsSystem)
	{
		if ((icacTrueContext == icac32Elevated     && (m_CustomServerInfo.m_icacWaitingContext == icac32Impersonated || m_CustomServerInfo.m_icacWaitingContext == icac64Impersonated)) ||
			(icacTrueContext == icac32Impersonated && (m_CustomServerInfo.m_icacWaitingContext == icac32Elevated     || m_CustomServerInfo.m_icacWaitingContext == icac64Elevated)))
		{
			DEBUGMSGV("Custom Action Server rejected - Mismatched Context.");
			LeaveCriticalSection(&m_csRegisterAction);
			return ERROR_ACCESS_DENIED;
		}
	
		// reconcile the desired context with what the process tells us it is
		if (*picacContext != m_CustomServerInfo.m_icacWaitingContext)
		{
			DEBUGMSGV("Custom Action Server rejected - Wrong Context.");
			LeaveCriticalSection(&m_csRegisterAction);
			return ERROR_ACCESS_DENIED;
		}
	}
    
    // the client process thinks that its our CustomActionServer. We need to validate the cookie to check
    // and then store this ICustomAction pointer for use in requesting objects off of it.
    if (cbCookie != iRemoteAPICookieSize)
    {
        DEBUGMSGV("Custom Action Server rejected - Invalid Cookie.");
        LeaveCriticalSection(&m_csRegisterAction);
        return ERROR_ACCESS_DENIED;
    }

    for (int iCookieByte = 0; iCookieByte < iRemoteAPICookieSize; iCookieByte++)
    {
        if (rgchCookie[iCookieByte] != m_CustomServerInfo.m_rgchWaitingCookie[iCookieByte])
        {
            DEBUGMSGV("Custom Action Server rejected - Invalid Cookie.");
            LeaveCriticalSection(&m_csRegisterAction);
            return ERROR_ACCESS_DENIED;
        }
    }

    // another thread is waiting on the interface pointer to run the custom action,
    // but marshaled interface pointers are only valid inside the apartment that
    // the initial proxy is created in. The thread that spawned the CA process is blocked
    // waiting for the result, and is running in a different apartment. In order for
    // the proxy to be available to the blocked thread, it must be marshaled
    // by registering it in the COM GIT
    if (S_OK != m_piGIT->RegisterInterfaceInGlobal(piCustomAction, IID_IMsiCustomAction, &m_CustomServerInfo.m_dwGITCookie))
    {
        LeaveCriticalSection(&m_csRegisterAction);
        return ERROR_FUNCTION_FAILED;
    }

    LPCSTR pszType = NULL;
    switch (m_CustomServerInfo.m_icacWaitingContext)
    {
        case icac32Impersonated:
            pszType = "32bit Impersonated";
            break;
        case icac32Elevated:
            pszType = "32bit Elevated";
            break;
        case icac64Impersonated:
            pszType = "64bit Impersonated";
            break;
        default:
            pszType = "64bit Elevated";
            break;
    }   
    DEBUGMSG1("Hello, I'm your %s custom action server.", pszType);

    // need to return the RemoteAPI, Privileges and the ProcessId to the client at this point
    if (pdwProcessId)
        *pdwProcessId = m_CustomServerInfo.m_dwProcessId;
	if (pdwPrivileges)
		*pdwPrivileges = m_CustomServerInfo.m_dwPrivileges;
    if (piRemoteAPI)
    {
        if (S_OK != m_piGIT->GetInterfaceFromGlobal(m_CustomServerInfo.m_dwRemoteCookie, IID_IMsiRemoteAPI, reinterpret_cast<void **>(piRemoteAPI)))
        {
            m_piGIT->RevokeInterfaceFromGlobal(m_CustomServerInfo.m_dwGITCookie);
            m_CustomServerInfo.m_dwGITCookie = 0;
            LeaveCriticalSection(&m_csRegisterAction);
            return ERROR_FUNCTION_FAILED;
        }
    }

	// if the client is localsystem, the CA server could be reporting itself as elevated when it is actually
	// filling the role of the impersonated server for the client. In that scenario, inform the CA server of its true job.
	if (m_CustomServerInfo.m_fImpersonatedIsSystem)
	{
		if (m_CustomServerInfo.m_icacWaitingContext == icac32Impersonated && *picacContext == icac32Elevated)
		{
			*picacContext = icac32Impersonated;
		}
		else if (m_CustomServerInfo.m_icacWaitingContext == icac64Impersonated && *picacContext == icac64Elevated)
			*picacContext = icac64Impersonated;
	}

    // wake up the main thread that is trying to run the custom action
    AssertNonZero(SetEvent(m_hCARegistered));
    LeaveCriticalSection(&m_csRegisterAction);

    return ERROR_SUCCESS;
}

// create a custom action manager if needed
// this function might be called by more than one thread, so it has to ensure that
// we never end up with more than one manager
void CMsiConfigurationManager::CreateCustomActionManager(bool fRemapHKCU)
{
	// script execution could occur more than once (install script, then rollback script), etc
	// so the custom action manager might have already been created.  there's nothing wrong with that
	EnterCriticalSection(&m_csCreateProxy);
	if (!m_pCustomActionManager)
		m_pCustomActionManager = new CMsiCustomActionManager(fRemapHKCU);
	LeaveCriticalSection(&m_csCreateProxy);
}

// returns the existing custom action manager object
CMsiCustomActionManager* CMsiConfigurationManager::GetCustomActionManager()
{
	AssertSz(m_pCustomActionManager, TEXT("Custom action manager has not yet been created!!"));
	return m_pCustomActionManager;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\fileactn.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       fileactn.cpp
//
//--------------------------------------------------------------------------

/*__________________________________________________________________________

  fileactn.cpp - Implementation of core engine File actions
____________________________________________________________________________*/

#include "precomp.h"
#include "engine.h"
#include "_engine.h"
#include "_assert.h"
#include "_srcmgmt.h"
#include "_dgtlsig.h"
#include "tables.h" // table and column name definitions

// #define LOG_COSTING // Testing only

const GUID IID_IMsiCostAdjuster = GUID_IID_IMsiCostAdjuster;



static Bool IsFileActivityEnabled(IMsiEngine& riEngine)
{
	int iInstallMode = riEngine.GetMode();
	if (!(iInstallMode & iefOverwriteNone) &&
		!(iInstallMode & iefOverwriteOlderVersions) &&
		!(iInstallMode & iefOverwriteEqualVersions) &&
		!(iInstallMode & iefOverwriteDifferingVersions) &&
		!(iInstallMode & iefOverwriteCorruptedFiles) &&
		!(iInstallMode & iefOverwriteAllFiles))
	{
		return fFalse;
	}
	return fTrue;
}

static Bool IsRegistryActivityEnabled(IMsiEngine& riEngine)
{
	int iInstallMode = riEngine.GetMode();
	if (!(iInstallMode & iefInstallMachineData) &&
		!(iInstallMode & iefInstallUserData))
	{
		return fFalse;
	}
	return fTrue;
}

static Bool IsShortcutActivityEnabled(IMsiEngine& riEngine)
{
	int iInstallMode = riEngine.GetMode();
	if (!(iInstallMode & iefInstallShortcuts))
	{
		return fFalse;
	}
	return fTrue;
}

const int iBytesPerTick = 32768;
const int iReservedFileAttributeBits = msidbFileAttributesReserved1 |
													msidbFileAttributesReserved2 |
													msidbFileAttributesReserved3 |
													msidbFileAttributesReserved4;

static Bool FShouldDeleteFile(iisEnum iisInstalled, iisEnum iisAction);

CMsiFileBase::CMsiFileBase(IMsiEngine& riEngine) :
	m_riEngine(riEngine),m_riServices(*(riEngine.GetServices())),m_pFileRec(0)
{
	m_riEngine.AddRef();
}

CMsiFileBase::~CMsiFileBase()
{
	m_riServices.Release();
	m_riEngine.Release();
}

IMsiRecord* CMsiFileBase::GetTargetPath(IMsiPath*& rpiDestPath)
/*-------------------------------------------------------------------------------
--------------------------------------------------------------------------------*/
{
	if (!m_pFileRec)
		return PostError(Imsg(idbgFileTableEmpty));

	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	return pDirectoryMgr->GetTargetPath(*MsiString(m_pFileRec->GetMsiString(ifqDirectory)),rpiDestPath);
}


IMsiRecord* CMsiFileBase::GetFileRecord( void )
/*----------------------------------------------
------------------------------------------------*/
{
	if (m_pFileRec)
		m_pFileRec->AddRef();
	return m_pFileRec;
}

IMsiRecord* CMsiFileBase::GetExtractedTargetFileName(IMsiPath& riPath, const IMsiString*& rpistrFileName)
{
	Assert(m_pFileRec);
	Bool fLFN = ((m_riEngine.GetMode() & (iefSuppressLFN)) == 0 && riPath.SupportsLFN()) ? fTrue : fFalse;
	return m_riServices.ExtractFileName(m_pFileRec->GetString(ifqFileName), fLFN, rpistrFileName);
}


CMsiFile::CMsiFile(IMsiEngine& riEngine) : 
	CMsiFileBase(riEngine),
	m_pFileView(0)
{
}

CMsiFile::~CMsiFile()
{
}

static const ICHAR szSqlFile[] =
	TEXT("SELECT `FileName`,`Version`,`State`,`File`.`Attributes`,`TempAttributes`,`File`,`FileSize`,`Language`,`Sequence`,`Directory_`, ")
	TEXT("`Installed`,`Action`,`Component`, `ForceLocalFiles`, `ComponentId` FROM `File`,`Component` WHERE `Component`=`Component_`")
	TEXT(" AND `File`=?");

IMsiRecord* CMsiFile::ExecuteView(const IMsiString& riFileKeyString)
/*-------------------------------------------------------------------
-------------------------------------------------------------------*/
{
	IMsiRecord* piErrRec;

	if (m_pFileView)
	{
		// A non-view all query is already active
		PMsiRecord pExecRec(&m_riServices.CreateRecord(1));
		pExecRec->SetMsiString(1, riFileKeyString);
		if ((piErrRec = m_pFileView->Execute(pExecRec)) != 0)
			return piErrRec;
		return 0;		
	}
	
	piErrRec = m_riEngine.OpenView(szSqlFile, ivcFetch, *&m_pFileView);
	if (piErrRec)
		return piErrRec;

	PMsiRecord pExecRec(&m_riServices.CreateRecord(1));
	pExecRec->SetMsiString(1, riFileKeyString);
	if ((piErrRec = m_pFileView->Execute(pExecRec)) != 0)
		return piErrRec;

	return 0;
}


IMsiRecord* CMsiFile::FetchFile(const IMsiString& riFileKeyString)
/*-------------------------------------------------------------------------------
--------------------------------------------------------------------------------*/
{
	IMsiRecord* piErrRec = ExecuteView(riFileKeyString);
	if (piErrRec)
		return piErrRec;

	m_pFileRec = m_pFileView->Fetch();
#ifdef DEBUG
	if (m_pFileRec)
		Assert(m_pFileRec->GetFieldCount() >= ifqNextEnum - 1);
#endif
	return 0;
}


CMsiFileInstall::CMsiFileInstall(IMsiEngine& riEngine) : 
	CMsiFileBase(riEngine)
{
	m_piView = 0;
	m_fInitialized = false;
}

CMsiFileInstall::~CMsiFileInstall()
{
		
	if (m_piView)
	{
		m_piView->Release();
		m_piView = 0;
	}

}

IMsiRecord* CMsiFileInstall::Initialize()
{
	IMsiRecord* piErr;
	
	if (m_fInitialized)
		return 0;
		
	piErr = m_riEngine.CreateTempActionTable(ttblFile);

	if (piErr)
		return piErr;

	m_fInitialized = true;

	return 0;

}

IMsiRecord* CMsiFileInstall::TotalBytesToCopy(unsigned int& uiTotalBytesToCopy)
/*-------------------------------------------------------------------
Returns a count of bytes of all files that are expected to be copied
when the current file query is acted upon.
-------------------------------------------------------------------*/
{
	uiTotalBytesToCopy = 0;
	
	IMsiRecord* piErr;
	
	if (!m_fInitialized)
	{
		piErr = Initialize();

		if (piErr)
			return piErr;
	}

	PMsiTable pTable(0);
	PMsiDatabase pDatabase = m_riEngine.GetDatabase();
		
	piErr = pDatabase->LoadTable(*MsiString(*sztblFileAction), 0, *&pTable);
	if (piErr)
	{
		if(piErr->GetInteger(1) == idbgDbTableUndefined)
		{
			piErr->Release();
			AssertSz(fFalse, "FileAction table not created");
			return 0;
		}
		else
			return piErr;
	}
	int colState, colFileSize, colAction;
#ifdef DEBUG
	int colFileKey;

	AssertNonZero(colFileKey = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFile_colFile)));
#endif //DEBUG
	AssertNonZero(colState = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colState)));
	AssertNonZero(colFileSize = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colFileSize)));
	AssertNonZero(colAction = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colAction)));	

	PMsiCursor pCursor = pTable->CreateCursor(fFalse);
	
	while (pCursor->Next())
	{
#ifdef DEBUG
		const ICHAR* szDebug = (const ICHAR *)MsiString(pCursor->GetString(colFileKey));
#endif //DEBUG
		// Only those files whose "shouldInstall" state is true will
		// actually be copied during script execution.
		if (pCursor->GetInteger(colState) == fTrue && pCursor->GetInteger(colAction) == iisLocal)
		{
			int iFileSize = pCursor->GetInteger(colFileSize);
			uiTotalBytesToCopy += iFileSize;
		}
	}
	return 0;
}

static const ICHAR* szFetchInstall = 
	TEXT("SELECT `File`.`FileName`,`Version`,`File`.`State`,`File`.`Attributes`,`TempAttributes`,`File`.`File`,`File`.`FileSize`,`Language`,`Sequence`, `Directory_`, ")
	TEXT("`Installed`,`FileAction`.`Action`,`File`.`Component_`,`FileAction`.`ForceLocalFiles`, `ComponentId` FROM `File`,`FileAction` WHERE `File`.`File`=`FileAction`.`File`")
	TEXT(" ORDER BY `Sequence`, `Directory_`");

IMsiRecord* CMsiFileInstall::FetchFile()
/*-------------------------------------------------------------------------------
--------------------------------------------------------------------------------*/
{
	IMsiRecord* piErrRec;
	
	if (m_piView == 0)
	{
		if (!m_fInitialized)
		{
			piErrRec = Initialize();

			if (piErrRec)
				return piErrRec;
		}

		piErrRec = m_riEngine.OpenView(szFetchInstall, ivcFetch, *&m_piView);
		if (piErrRec)
			return piErrRec;

		piErrRec = m_piView->Execute(0);
		if (piErrRec)
			return piErrRec;
	}

	m_pFileRec = m_piView->Fetch();
#ifdef DEBUG
	if (m_pFileRec)
		Assert(m_pFileRec->GetFieldCount() >= ifqNextEnum - 1);
#endif

	return 0;
}

CMsiFileRemove::CMsiFileRemove(IMsiEngine& riEngine) :
	m_riEngine(riEngine),m_riServices(*(riEngine.GetServices())), m_pFileRec(0)
{
	m_riEngine.AddRef();
	m_fInitialized = false;
	m_fEmpty = false;
	m_piCursor = 0;
	m_piCursorFile = 0;
}

CMsiFileRemove::~CMsiFileRemove()
{
	m_riEngine.Release();
	m_riServices.Release();
	if (m_piCursor)
	{
		m_piCursor->Release();
		m_piCursor = 0;
	}
	
		
	if (m_piCursorFile)
	{
		m_piCursorFile->Release();
		m_piCursorFile = 0;
	}

}


IMsiRecord* CMsiFileRemove::Initialize()
{
	IMsiRecord* piErr;

	if (m_fInitialized)
		return 0;
		
	piErr = m_riEngine.CreateTempActionTable(ttblFile);

	if (piErr)
		return piErr;

	// Initialize the column arrays
	PMsiTable pTable(0);
	PMsiDatabase pDatabase = m_riEngine.GetDatabase();
	
	piErr = pDatabase->LoadTable(*MsiString(*sztblFile), 0, *&pTable);
	if (piErr)
	{
		if(piErr->GetInteger(1) == idbgDbTableUndefined)
		{
			piErr->Release();
			m_fEmpty = true;
			return 0;
		}
		else
			return piErr;
	}
	
	AssertNonZero(m_colFileName = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFile_colFileName)));
	
	AssertNonZero(m_colFileKey = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFile_colFile)));

	piErr = pDatabase->LoadTable(*MsiString(*sztblFileAction), 0, *&pTable);
	if (piErr)
	{
		return piErr;
	}
	
	AssertNonZero(m_colFileActionDir = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colDirectory)));
	AssertNonZero(m_colFileActKey = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFile_colFile)));
	AssertNonZero(m_colFileActAction = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colAction)));
	AssertNonZero(m_colFileActInstalled = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colInstalled)));
	AssertNonZero(m_colFileActComponentId = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colComponentId)));

	m_fInitialized = true;
	
	return 0;
}

IMsiRecord* CMsiFileRemove::TotalFilesToDelete(unsigned int& uiTotalFileCount)
/*-------------------------------------------------------------------
Returns a count of all files that are expected to be deleted when the
current file query is acted upon.
-------------------------------------------------------------------*/
{
	IMsiRecord* piErr;
	uiTotalFileCount = 0;

	if (!m_fInitialized)
	{
		piErr = Initialize();
		if (piErr)
			return piErr;
	}
		
	PMsiTable pTable(0);
	PMsiDatabase pDatabase = m_riEngine.GetDatabase();
		
	piErr = pDatabase->LoadTable(*MsiString(*sztblFileAction), 0, *&pTable);
	if (piErr)
	{
		if(piErr->GetInteger(1) == idbgDbTableUndefined)
		{
			piErr->Release();
			m_fEmpty = true;
			return 0;
		}
		else
			return piErr;
	}
	
	int colInstalled, colAction;
#ifdef DEBUG
	int colFileKey;

	AssertNonZero(colFileKey = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFile_colFile)));
#endif //DEBUG
	AssertNonZero(colInstalled = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colInstalled)));
	AssertNonZero(colAction = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFileAction_colAction)));

	PMsiCursor pCursor = pTable->CreateCursor(fFalse);
	
	// Determine the number of files to delete
	// set up the progress bar accordingly.
	while (pCursor->Next())
	{
#ifdef DEBUG
		const ICHAR* szDebug = (const ICHAR *)MsiString(pCursor->GetString(colFileKey));
#endif //DEBUG
		if (FShouldDeleteFile((iisEnum)pCursor->GetInteger(colInstalled), (iisEnum)pCursor->GetInteger(colAction)))
			uiTotalFileCount++;
	}
	return 0;
}


IMsiRecord* CMsiFileRemove::FetchFile(IMsiRecord*& rpiRecord)
/*-------------------------------------------------------------------------------
--------------------------------------------------------------------------------*/
{
	IMsiRecord* piErr;

	rpiRecord = 0;
	//
	// If it's not already created, we need a cursor on the 
	// file action table
	if (m_piCursor == 0)
	{
		if (!m_fInitialized)
		{
			piErr = Initialize();
			if (piErr)
				return piErr;
		}
		
		if (m_fEmpty)
		{
			return 0;
		}
		
		PMsiTable pTable(0);
		PMsiDatabase pDatabase = m_riEngine.GetDatabase();

		// Since we've already initialized, m_fEmpty should be set or 
		// we actually have a file action table and file table
		piErr = pDatabase->LoadTable(*MsiString(*sztblFileAction), 0, *&pTable);
		if (piErr)
		{
			return piErr;
		}

		m_piCursor = pTable->CreateCursor(fFalse);

		piErr = pDatabase->LoadTable(*MsiString(*sztblFile), 0, *&pTable);
		if (piErr)
		{
			return piErr;
		}

		m_piCursorFile = pTable->CreateCursor(fFalse);
		m_piCursorFile->SetFilter(iColumnBit(m_colFileKey));
	}

	while (m_piCursor->Next())
	{
		//
		// See if this is a file that meets our criteria or not
		if (!FShouldDeleteFile((iisEnum)m_piCursor->GetInteger(m_colFileActInstalled), (iisEnum)m_piCursor->GetInteger(m_colFileActAction)))
			continue;			

		m_piCursorFile->Reset();
		m_piCursorFile->PutInteger(m_colFileKey, m_piCursor->GetInteger(m_colFileActKey));
		if (m_piCursorFile->Next())
		{
			rpiRecord = &CreateRecord(ifqrNextEnum - 1);
			rpiRecord->SetMsiString(ifqrFileName,    *MsiString(m_piCursorFile->GetString(m_colFileName)));
			rpiRecord->SetMsiString(ifqrDirectory,   *MsiString(m_piCursor->GetString(m_colFileActionDir)));
			rpiRecord->SetMsiString(ifqrComponentId, *MsiString(m_piCursor->GetString(m_colFileActComponentId)));
			break;
		}
		else
		{
			AssertSz(fFalse, "Missing file from the file table");
		}

	}

	m_pFileRec = rpiRecord;
	if (rpiRecord != 0)
		rpiRecord->AddRef();

	return 0;
}

IMsiRecord* CMsiFileRemove::GetExtractedTargetFileName(IMsiPath& riPath, const IMsiString*& rpistrFileName)
{
	Assert(m_pFileRec);
	Bool fLFN = ((m_riEngine.GetMode() & (iefSuppressLFN)) == 0 && riPath.SupportsLFN()) ? fTrue : fFalse;
	return m_riServices.ExtractFileName(m_pFileRec->GetString(ifqrFileName), fLFN, rpistrFileName);
}



// End of CMsiFileAll //


/*---------------------------------------------------------------------------
	Local functions for use by File Actions
---------------------------------------------------------------------------*/

static IMsiRecord* PlaceFileOnInUseList(IMsiEngine& riEngine, const IMsiString& riFileNameString, const IMsiString& riFilePathString)
/*---------------------------------------------------------------------------
Throws the given file/path in a table of "files in use".
-----------------------------------------------------------------------------*/
{
	PMsiTable pFileInUseTable(0);
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	int iColFileName,iColFilePath;
	if (pDatabase->FindTable(*MsiString(sztblFilesInUse)) == itsUnknown)
	{
		IMsiRecord* piErrRec = pDatabase->CreateTable(*MsiString(*sztblFilesInUse),5,*&pFileInUseTable);
		if (piErrRec)
			return piErrRec;

		Assert(pFileInUseTable);
		iColFileName = pFileInUseTable->CreateColumn(icdPrimaryKey + icdString,*MsiString(*sztblFilesInUse_colFileName));
		iColFilePath = pFileInUseTable->CreateColumn(icdPrimaryKey + icdString,*MsiString(*sztblFilesInUse_colFilePath));
		pDatabase->LockTable(*MsiString(*sztblFilesInUse),fTrue);
	}
	else
	{
		pDatabase->LoadTable(*MsiString(*sztblFilesInUse),0,*&pFileInUseTable);
		Assert(pFileInUseTable);
		iColFileName = pFileInUseTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFilesInUse_colFileName));
		iColFilePath = pFileInUseTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFilesInUse_colFilePath));
	}

	Assert(pFileInUseTable);
	PMsiCursor pCursor = pFileInUseTable->CreateCursor(fFalse);
	Assert(pCursor);
	Assert(iColFileName > 0 && iColFilePath > 0);
	AssertNonZero(pCursor->PutString(iColFileName,riFileNameString));
	AssertNonZero(pCursor->PutString(iColFilePath,riFilePathString));
	AssertNonZero(pCursor->Assign());
	return 0;
}

static int GetInstallModeFlags(IMsiEngine& riEngine,int iFileAttributes)
/*----------------------------------------------------------------
Local function that returns the install mode bit flags currently
associated with the given IMsiEngine object.  These flags are
defined by the icm* bit constants in engine.h.

The bit flags returned can be associated with a specific file
by passing that file's attributes (defined by iff* bit constants
in engine.h) in the iFileAttributes parameter.  Currently, the
only file attribute bit that makes any difference is iffChecksum:
if this bit is not set, then the iefOverwriteCorrupted will not
be set in the returned installmode flags, regardless of the 
current Reinstall mode(s).
-----------------------------------------------------------------*/
{
	// InstallMode flags are in the upper 16 bits of the engine mode
	int fInstallModeFlags = riEngine.GetMode() & 0xFFFF0000;
	if (!(iFileAttributes & msidbFileAttributesChecksum))
		fInstallModeFlags &= ~icmOverwriteCorruptedFiles;
	return fInstallModeFlags;
}


static IMsiRecord* GetFinalFileSize(IMsiEngine& riEngine,IMsiRecord& riFileRec,unsigned int& ruiFinalFileSize)
/*----------------------------------------------------------------------------
Returns the final,unclustered,file size for the file specified by riFileRec.

- The required fields in this record are specified by the ifq* enum in CMsiFile.
- The value returned in ruiFinalFileSize is valid only if GetFileInstallState
	was called previously with the same record, and no fields have modified
	since the call.
- If the ifqState field of riFileRec indicates that this file will overwrite
	the existing file (if any), then the new file's unclustered size will be
	returned; otherwise, the unclustered size of the existing file will be
	returned.
------------------------------------------------------------------------------*/
{
	PMsiPath pDestPath(0);
	IMsiRecord* piErrRec;
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	piErrRec = pDirectoryMgr->GetTargetPath(*MsiString(riFileRec.GetMsiString(CMsiFile::ifqDirectory)),*&pDestPath);
	if (piErrRec)
		return piErrRec;

	ruiFinalFileSize = 0;
	if (riFileRec.GetInteger(CMsiFile::ifqState) == fTrue)
		ruiFinalFileSize = riFileRec.GetInteger(CMsiFile::ifqFileSize);
	else
	{
		MsiString strFileName(riFileRec.GetMsiString(CMsiFile::ifqFileName));
		Bool fExists;
		piErrRec = pDestPath->FileExists(strFileName,fExists);
		if (piErrRec)
			return piErrRec;

		Assert(fExists);
		piErrRec = pDestPath->FileSize(strFileName,ruiFinalFileSize);
		if (piErrRec)
			return piErrRec;
	}
	return 0;
}

static Bool FShouldDeleteFile(iisEnum iisInstalled, iisEnum iisAction)
/*-------------------------------------------------------------------------
Determines whether the file whose iisInstalled and iisAction states
will be deleted
--------------------------------------------------------------------------*/
{
	if (((iisAction == iisAbsent) || (iisAction == iisFileAbsent) || (iisAction == iisHKCRFileAbsent) || (iisAction == iisSource)) && (iisInstalled == iisLocal))
		return fTrue;
	else
		return fFalse;
}


IMsiRecord* GetFileInstallState(IMsiEngine& riEngine,IMsiRecord& riFileRec,
										  IMsiRecord* piCompanionFileRec, /* if set, riFileRec is for parent */
										  unsigned int* puiExistingClusteredSize, Bool* pfInUse,
										  ifsEnum* pifsState, bool fIgnoreCompanionParentAction, bool fIncludeHashCheck, int *pfVersioning)
/*-------------------------------------------------------------------------
Determines whether the file whose information is specified in riFileRec
should be installed.  The required fields in this record are specified
by the ifq* enum in CMsiFile.  An ideal record to pass to
GetFileInstallState is that returned by CMsiFile::GetFileRecord(), but
a record returned by any query whose SELECT fields match ifq* is fine and
dandy.

- The intended destination path for the file is determined by the directory
property name given in the ifqDirectory field.

- If the file should be installed, fTrue will be returned in the ifqState
field of riFileRec.

- If the file is determined to be a companion file, the itfaCompanion bit
will be set in the ifqTempAttributes field of riFileRec.

- if piCompanionFileRec is set, the file information given in riFileRec
is assumed to refer to the parent of a companion file, which the information
given in piCompanionFileRec is the information for the companion file.
In this case, the version checking will be altered such that ifqState will be returned as 
fTrue if the existing file (if any) is of an equal or lesser version.  Plus the file
hash check may be made against the companion file.

- if fIgnoreCompanionParentAction is true, the ifqState field of riFileRec
will NOT be dependent upon whether the companion parent's component is
installed/is being installed - only the version check will count.

- If there is an existing file with the specified name in the file's
directory, the existing clustered size of that file will be returned in
uiExistingClusteredSize, and if that existing file is in use, fTrue will
be returned in fInUse.  Either of these parameters can be passed as NULL
if the caller doesn't care about these values.
--------------------------------------------------------------------------*/
{
	PMsiPath pDestPath(0);
	IMsiRecord* piErrRec;
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiServices pServices(riEngine.GetServices());
	piErrRec = pDirectoryMgr->GetTargetPath(*MsiString(riFileRec.GetMsiString(CMsiFile::ifqDirectory)),*&pDestPath);
	if (piErrRec)
		return piErrRec;

	PMsiPath pCompanionDestPath(0);
	if(piCompanionFileRec)
	{
		piErrRec = pDirectoryMgr->GetTargetPath(*MsiString(piCompanionFileRec->GetMsiString(CMsiFile::ifqDirectory)),*&pCompanionDestPath);
		if (piErrRec)
			return piErrRec;
	}
	
	int fInstallModeFlags = GetInstallModeFlags(riEngine,riFileRec.GetInteger(CMsiFile::ifqAttributes));
	if (piCompanionFileRec)
		fInstallModeFlags |= icmCompanionParent;

	MD5Hash hHash;
	MD5Hash* pHash = 0;
	if(fIncludeHashCheck)
	{
		bool fHashInfo = false;
		IMsiRecord* piHashFileRec = piCompanionFileRec ? piCompanionFileRec : &riFileRec;
		
		piErrRec = riEngine.GetFileHashInfo(*MsiString(piHashFileRec->GetMsiString(CMsiFile::ifqFileKey)),
														piHashFileRec->GetInteger(CMsiFile::ifqFileSize), hHash, fHashInfo);
		if(piErrRec)
			return piErrRec;
		
		if(fHashInfo)
			pHash = &hHash;
	}

	ifsEnum ifsState;
	Bool fShouldInstall = fFalse;

	if(piCompanionFileRec)
	{
		piErrRec = pDestPath->GetCompanionFileInstallState(*MsiString(riFileRec.GetMsiString(CMsiFile::ifqFileName)),
																*MsiString(riFileRec.GetMsiString(CMsiFile::ifqVersion)),
																*MsiString(riFileRec.GetMsiString(CMsiFile::ifqLanguage)),
																*pCompanionDestPath,
																*MsiString(piCompanionFileRec->GetMsiString(CMsiFile::ifqFileName)),
																pHash, ifsState, fShouldInstall, puiExistingClusteredSize,
																pfInUse, fInstallModeFlags, pfVersioning);
	}
	else
	{
		piErrRec = pDestPath->GetFileInstallState(*MsiString(riFileRec.GetMsiString(CMsiFile::ifqFileName)),
																*MsiString(riFileRec.GetMsiString(CMsiFile::ifqVersion)),
																*MsiString(riFileRec.GetMsiString(CMsiFile::ifqLanguage)),
																pHash, ifsState, fShouldInstall, puiExistingClusteredSize,
																pfInUse, fInstallModeFlags, pfVersioning);
	}

	if (piErrRec)
		return piErrRec;

	if (pifsState) *pifsState = ifsState;
	if (ifsState ==	ifsCompanionSyntax || ifsState == ifsCompanionExistsSyntax)
	{
		AssertSz(!piCompanionFileRec, "Chained companion files detected");
		
		CMsiFile objFile(riEngine);
		MsiString strParentFileKey(riFileRec.GetMsiString(CMsiFile::ifqVersion));
		piErrRec = objFile.FetchFile(*strParentFileKey);
		if (piErrRec)
			return piErrRec;

		fShouldInstall = fFalse;
		PMsiRecord pParentRec(objFile.GetFileRecord());
		if (pParentRec == 0)
			// Bad companion file reference
			return PostError(Imsg(idbgDatabaseTableError));

		// get parent path
		PMsiPath pParentPath(0);
		if((piErrRec = objFile.GetTargetPath(*&pParentPath)) != 0)
			return piErrRec;

		// extract appropriate file name from short|long pair and put back in pParentRec
		MsiString strParentFileName;
		if((piErrRec = objFile.GetExtractedTargetFileName(*pParentPath,*&strParentFileName)) != 0)
			return piErrRec;
		AssertNonZero(pParentRec->SetMsiString(CMsiFile::ifqFileName,*strParentFileName));
		
		if (pParentRec->GetInteger(CMsiFile::ifqAction) == iisLocal ||
			pParentRec->GetInteger(CMsiFile::ifqInstalled) == iisLocal ||
			fIgnoreCompanionParentAction)
		{
			// no hash check on companion parent; hash check on companion is dependent upon whether
			// we should be using a hash check (for component mgmt -- NO, for installation of file -- YES; ...
			// fIncludeHashCheck should already be set appropriately for us)
			piErrRec = GetFileInstallState(riEngine,*pParentRec,&riFileRec,0,0,0,
													 /* fIgnoreCompanionParentAction=*/ false,
													 /* fIncludeHashCheck=*/ fIncludeHashCheck, pfVersioning);
			if (piErrRec)
				return piErrRec;
			fShouldInstall = (Bool) pParentRec->GetInteger(CMsiFile::ifqState);
		}

		// Mark as a companion for future reference, if not already marked
		int iTempAttributes = riFileRec.GetInteger(CMsiFile::ifqTempAttributes);
		if (!(iTempAttributes & itfaCompanion))
		{
			iTempAttributes |= itfaCompanion;
			riFileRec.SetInteger(CMsiFile::ifqTempAttributes,iTempAttributes);

			MsiString strComponent(riFileRec.GetMsiString(CMsiFile::ifqComponent));
			MsiString strParentComponent(pParentRec->GetMsiString(CMsiFile::ifqComponent));
			if (strComponent.Compare(iscExact,strParentComponent) == 0)
			{
				// cost-link the companion's component to the companion parent's component
				// so the companion component will get recosted whenever the directory or select
				// state of the parent component changes.
				PMsiSelectionManager pSelectionMgr(riEngine, IID_IMsiSelectionManager);
				piErrRec = pSelectionMgr->RegisterCostLinkedComponent(*strParentComponent,*strComponent);
				if (piErrRec)
					return piErrRec;
			} 
		}
	}
	riFileRec.SetInteger(CMsiFile::ifqState,fShouldInstall);
	return 0;
}

/*---------------------------------------------------------------------------
	InstallFiles costing/action
---------------------------------------------------------------------------*/

class CMsiFileCost : public IMsiCostAdjuster
{
public:
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	const IMsiString& __stdcall GetMsiStringValue() const;
	int           __stdcall GetIntegerValue() const;
#ifdef USE_OBJECT_POOL
	unsigned int  __stdcall GetUniqueId() const;
	void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall Reset();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);
public:  // constructor
	CMsiFileCost(IMsiEngine& riEngine);
protected:
	virtual ~CMsiFileCost();  // protected to prevent creation on stack
	IMsiEngine& m_riEngine;
	PMsiView m_pCostView;

	IMsiTable*  m_piRemoveFilePathTable;
	IMsiCursor* m_piRemoveFilePathCursor;
	int         m_colRemoveFilePath;
	int         m_colRemoveFilePathComponent;
	int			m_colRemoveFilePathMode;
private:

	IMsiRecord* CheckRemoveFileList(const IMsiString& riFullPathString, const IMsiString& riComponentString, Bool& fOnList);
	int     m_iRefCnt;
	Bool	m_fRemoveFilePathTableMissing;
#ifdef USE_OBJECT_POOL
	unsigned int  m_iCacheId;
#endif //USE_OBJECT_POOL
};

CMsiFileCost::CMsiFileCost(IMsiEngine& riEngine) : m_riEngine(riEngine), m_pCostView(0)
{
	m_iRefCnt = 1;
	m_riEngine.AddRef();
	m_piRemoveFilePathTable = 0;
	m_piRemoveFilePathCursor = 0;
	m_fRemoveFilePathTableMissing = fFalse;
#ifdef USE_OBJECT_POOL
	m_iCacheId = 0;
#endif //USE_OBJECT_POOL
}


CMsiFileCost::~CMsiFileCost()
{
	if (m_piRemoveFilePathCursor)
		m_piRemoveFilePathCursor->Release();

	if (m_piRemoveFilePathTable)
		m_piRemoveFilePathTable->Release();

	m_riEngine.Release();

	RemoveObjectData(m_iCacheId);
}

HRESULT CMsiFileCost::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IMsiCostAdjuster)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CMsiFileCost::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiFileCost::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;

	delete this;
	return 0;
}

const IMsiString& CMsiFileCost::GetMsiStringValue() const
{
	return g_MsiStringNull;
}

int CMsiFileCost::GetIntegerValue() const
{
	return 0;
}

#ifdef USE_OBJECT_POOL
unsigned int CMsiFileCost::GetUniqueId() const
{
	return m_iCacheId;
}

void CMsiFileCost::SetUniqueId(unsigned int id)
{
	Assert(m_iCacheId == 0);
	m_iCacheId = id;
}
#endif //USE_OBJECT_POOL

IMsiRecord*   CMsiFileCost::Initialize()
//------------------------------------
{
	// cost-link any global assembly components to the windows folder
	PMsiTable pAssemblyTable(0);
	IMsiRecord* piError = 0;
	PMsiDatabase pDatabase(m_riEngine.GetDatabase());

	if ((piError = pDatabase->LoadTable(*MsiString(sztblMsiAssembly),0,*&pAssemblyTable)) != 0)
	{
		if (piError->GetInteger(1) == idbgDbTableUndefined)
		{
			piError->Release();
			return 0;
		}
		else
			return piError;
	}

	MsiStringId idWindowsFolder = pDatabase->EncodeStringSz(IPROPNAME_WINDOWS_FOLDER);
	AssertSz(idWindowsFolder != 0, "WindowsFolder property not set in database");
	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);

	PMsiTable pComponentTable(0);
	PMsiCursor pComponentCursor(0);
	int colComponent = 0;
	int colDirectory = 0;

	if ((piError = pDatabase->LoadTable(*MsiString(sztblComponent),0,*&pComponentTable)) != 0)
	{
		if (piError->GetInteger(1) == idbgDbTableUndefined)
		{
			piError->Release();
			return 0;
		}
		else
			return piError;
	}

	pComponentCursor = pComponentTable->CreateCursor(fFalse);
	colComponent = pComponentTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colComponent));
	colDirectory = pComponentTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colDirectory));

	iatAssemblyType iatAT = iatNone;
	while (pComponentCursor->Next())
	{
		if (idWindowsFolder == pComponentCursor->GetInteger(colDirectory))
			continue; // no need to cost link since this component is already going to the Windows Folder

		if ((piError = m_riEngine.GetAssemblyInfo(*MsiString(pComponentCursor->GetString(colComponent)), iatAT, 0, 0)) != 0)
			return piError;

		// iatNone, iatURTAssemblyPvt or iatWin32AssemblyPvt do not require cost linking
		if (iatWin32Assembly == iatAT || iatURTAssembly == iatAT)
		{
			// cost link component to the WindowsFolder
			if ((piError = pSelectionMgr->RegisterComponentDirectoryId(pComponentCursor->GetInteger(colComponent),idWindowsFolder)) != 0)
				return piError;
		}
	}

	return 0;
}

IMsiRecord* CMsiFileCost::Reset()
//------------------------------------------
{
	return 0;
}

static const ICHAR sqlFileCost[] =
	TEXT("SELECT `FileName`,`Version`,`State`,`File`.`Attributes`,`TempAttributes`,`File`,`FileSize`,`Language`,`Sequence`,`Directory_`,")
	TEXT("`Installed`,`Action`,`Component` FROM `File`,`Component` WHERE `Component`=`Component_` AND `Component_`=? AND `Directory_`=?");

static const ICHAR sqlFileCostGlobalAssembly[] =
	TEXT("SELECT `FileName`,`Version`,`State`,`File`.`Attributes`,`TempAttributes`,`File`,`FileSize`,`Language`,`Sequence`,`Directory_`,")
	TEXT("`Installed`,`Action`,`Component` FROM `File`,`Component` WHERE `Component`=`Component_` AND `Component_`=?");

IMsiRecord* CMsiFileCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost, 
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
//--------------------------------------
{
	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;
	IMsiRecord* piErrRec;

	if (!IsFileActivityEnabled(m_riEngine))
		return 0;
	
	iatAssemblyType iatAT = iatNone;
	MsiString strAssemblyName;
	if ((piErrRec = m_riEngine.GetAssemblyInfo(riComponentString, iatAT, &strAssemblyName, 0)) != 0)
		return piErrRec;

	bool fGlobalAssembly = false;
	if (iatWin32Assembly == iatAT || iatURTAssembly == iatAT)
		fGlobalAssembly = true;

	if (m_pCostView == 0)
	{
		if ((piErrRec = m_riEngine.OpenView(fGlobalAssembly ? sqlFileCostGlobalAssembly : sqlFileCost, ivcEnum(ivcFetch|ivcUpdate), *&m_pCostView)) != 0)
		{
				// If either file or component table missing, nothing to do
			if (piErrRec->GetInteger(1) == idbgDbQueryUnknownTable)
			{
				piErrRec->Release();
				return 0;
			}
			else
				return piErrRec;
		}
	}
	else
		m_pCostView->Close();

	PMsiServices pServices(m_riEngine.GetServices());
	PMsiRecord pExecRecord(&pServices->CreateRecord(2));
	pExecRecord->SetMsiString(1, riComponentString);
	pExecRecord->SetMsiString(2,riDirectoryString);
	if ((piErrRec = m_pCostView->Execute(pExecRecord)) != 0)
		return piErrRec;

	PMsiPath pDestPath(0);
	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	piErrRec = pDirectoryMgr->GetTargetPath(riDirectoryString,*&pDestPath);
	if (piErrRec)
			return piErrRec;

	PMsiRecord pFileRec(0);

	// cost normally if component is private or without assemblies
	if (!fGlobalAssembly)
	{
		while (pFileRec = m_pCostView->Fetch())
		{

	#ifdef DEBUG
			ICHAR rgchFileName[256];
			MsiString strDebug(pFileRec->GetMsiString(CMsiFile::ifqFileName));
			strDebug.CopyToBuf(rgchFileName,255);
	#endif

			// extract appropriate name from short|long pair and put back in pFileRec
			MsiString strFileNamePair(pFileRec->GetMsiString(CMsiFile::ifqFileName));

			Bool fLFN = ((m_riEngine.GetMode() & iefSuppressLFN) == 0 && pDestPath->SupportsLFN()) ? fTrue : fFalse;
			MsiString strFileName;
			if((piErrRec = pServices->ExtractFileName(strFileNamePair,fLFN,*&strFileName)) != 0)
				return piErrRec;
			AssertNonZero(pFileRec->SetMsiString(CMsiFile::ifqFileName,*strFileName));
			
			unsigned int uiExistingClusteredSize;
			Bool fInUse;

			// Check existing file versioning only if file is not already marked
			// to be deleted by RemoveFile table.
			MsiString strFullFilePath;
			piErrRec = pDestPath->GetFullFilePath(strFileName,*&strFullFilePath);
			if (piErrRec)
				return piErrRec;
			Bool fOnList;
			piErrRec = CheckRemoveFileList(*strFullFilePath, riComponentString, fOnList);
			if (piErrRec)
				return piErrRec;
			if (fOnList)
			{
				fInUse = fFalse;
				uiExistingClusteredSize = 0;
				pFileRec->SetInteger(CMsiFile::ifqState,fTrue);
			}
			else
			{
				piErrRec = GetFileInstallState(m_riEngine, *pFileRec, /* piCompanionFileRec=*/ 0,
														 &uiExistingClusteredSize, &fInUse, 0,
														 /* fIgnoreCompanionParentAction=*/ false,
														 /* fIncludeHashCheck=*/ true, NULL);
				if (piErrRec)
					return piErrRec;
			}

			// put combined name back - can't update persistent data
			AssertNonZero(pFileRec->SetMsiString(CMsiFile::ifqFileName,*strFileNamePair));
			if ((piErrRec = m_pCostView->Modify(*pFileRec, irmUpdate)) != 0)
				return piErrRec;

			// iisAbsent costs
			iNoRbRemoveCost -= uiExistingClusteredSize;

			// iisSource costs
			if (pFileRec->GetInteger(CMsiFile::ifqInstalled) == iisLocal)
				iNoRbSourceCost -= uiExistingClusteredSize;

			// iisLocal costs
			if (pFileRec->GetInteger(CMsiFile::ifqState) == fTrue)
			{
				unsigned int uiNewClusteredSize;
				if ((piErrRec = pDestPath->ClusteredFileSize(pFileRec->GetInteger(CMsiFile::ifqFileSize),
					uiNewClusteredSize)) != 0)
					return piErrRec;
				iLocalCost += uiNewClusteredSize;
				iNoRbLocalCost += uiNewClusteredSize;
				iARPLocalCost += uiNewClusteredSize;
				iNoRbARPLocalCost += uiNewClusteredSize;
				if (!fInUse)
				{
					iNoRbLocalCost -= uiExistingClusteredSize;
					iNoRbARPLocalCost -= uiExistingClusteredSize;
				}

	#ifdef LOG_COSTING
				ICHAR rgch[300];
				wsprintf(rgch,TEXT("File: %s; Local cost: %i"),(const ICHAR*) strFullFilePath, iLocalCost * 512);
				DEBUGMSG(rgch);
	#endif
			}

			iisEnum iisAction = (iisEnum)pFileRec->GetInteger(CMsiFile::ifqAction);
			iisEnum iisInstalled = (iisEnum)pFileRec->GetInteger(CMsiFile::ifqInstalled);
			Bool fShouldInstall = (Bool)pFileRec->GetInteger(CMsiFile::ifqState);

			if (!fShouldInstall && iisAction == iisLocal && iisInstalled == iisAbsent)
			{
				// per bug 182012, even though we aren't installing the file, we still need to include the cost
				// of the file for the estimated install size.

				// we add in the cost of the existing file for the ARP cost (since this file isn't installed,
				// the rollback and no rollback costs are the same)
				iARPLocalCost += uiExistingClusteredSize;
				iNoRbARPLocalCost += uiExistingClusteredSize;
			}

			// file in use
			if(fAddFileInUse && fInUse &&                               // file in use, and we should add to list
				((iisAction == iisLocal && fShouldInstall) ||            // will install file local OR
				 FShouldDeleteFile(iisInstalled, iisAction)))  // will remove file
			{
				piErrRec = PlaceFileOnInUseList(m_riEngine, *strFileName,
														  *MsiString(pDestPath->GetPath()));
				if(piErrRec)
					return piErrRec;
			}
		}
	}
	else // component is installing assembly to GAC
	{
		// global assembly cost is attributed to the WindowsFolder
		if (riDirectoryString.Compare(iscExact,IPROPNAME_WINDOWS_FOLDER) == 0)
			return 0;

		// create the assembly name object
		LPCOLESTR szAssemblyName;
#ifndef UNICODE
		CTempBuffer<WCHAR, 1024>  rgchAssemblyNameUNICODE;
		ConvertMultiSzToWideChar(*strAssemblyName, rgchAssemblyNameUNICODE);
		szAssemblyName = rgchAssemblyNameUNICODE;
#else
		szAssemblyName = strAssemblyName;
#endif

		HRESULT hr;
		PAssemblyCache pCache(0);
		if(iatAT == iatURTAssembly)
			hr = FUSION::CreateAssemblyCache(&pCache, 0);
		else
		{
			Assert(iatAT == iatWin32Assembly);
			hr = SXS::CreateAssemblyCache(&pCache, 0);
		}
		bool fAssemblyInstalled = false;
		if(SUCCEEDED(hr))
		{
			// NOTE: At some point, QueryAssemblyInfo is supposed to also provide the disk cost of the installed assembly
			// For now, we just determine whether or not it is installed
			hr = pCache->QueryAssemblyInfo(0, szAssemblyName, NULL);

			if(SUCCEEDED(hr)) 
			{
				// assembly is installed
				fAssemblyInstalled = true;
			}
		} 
		else
		{
			if(iatAT == iatURTAssembly) // if cannot find fusion, assume we are bootstrapping, hence assume no assembly installed
			{
				PMsiRecord(PostAssemblyError(riComponentString.GetString(), hr, TEXT(""), TEXT("CreateAssemblyCache"), strAssemblyName, iatAT));
				DEBUGMSG(TEXT("ignoring fusion interface error, assuming we are bootstrapping"));
			}
			else
				return PostAssemblyError(riComponentString.GetString(), hr, TEXT(""), TEXT("CreateAssemblyCache"), strAssemblyName, iatAT);
		}

		// for all files that are part of this assembly
		// note that assembly files have atomic operations and are managed as a unit
		// therefore, all files will be installed or all files will not be installed
		unsigned int uiTotalClusteredSize = 0;
		iisEnum iisAction = (iisEnum)iMsiNullInteger;
		iisEnum iisInstalled = (iisEnum)iMsiNullInteger;

		while (pFileRec = m_pCostView->Fetch())
		{
			unsigned int uiClusteredSize = 0;
			if ((piErrRec = pDestPath->ClusteredFileSize(pFileRec->GetInteger(CMsiFile::ifqFileSize), uiClusteredSize)) != 0)
				return piErrRec;

			uiTotalClusteredSize += uiClusteredSize;

			if (iMsiNullInteger == iisAction)
				iisAction = (iisEnum)pFileRec->GetInteger(CMsiFile::ifqAction);
			if (iMsiNullInteger == iisInstalled)
				iisInstalled = (iisEnum)pFileRec->GetInteger(CMsiFile::ifqInstalled);
		}

		// determine the costs
		if (fAssemblyInstalled)
		{
			iLocalCost += uiTotalClusteredSize;
			iNoRbSourceCost -= uiTotalClusteredSize;
			iNoRbRemoveCost -= uiTotalClusteredSize;

			// determine ARP costs, special case
			if (iisAction == iisLocal && iisInstalled == iisAbsent)
			{
				iARPLocalCost += uiTotalClusteredSize;
				iNoRbARPLocalCost += uiTotalClusteredSize;
			}
		}
		else // !fAssemblyInstalled
		{
			iLocalCost += uiTotalClusteredSize;
			iNoRbLocalCost += uiTotalClusteredSize;
			iARPLocalCost += uiTotalClusteredSize;
			iNoRbARPLocalCost += uiTotalClusteredSize;
		}
	}// end global assembly cost calculation

	return 0;
}



IMsiRecord* CMsiFileCost::CheckRemoveFileList(const IMsiString& riFullPathString, const IMsiString& riComponentString, Bool& fOnList)
{
	fOnList = fFalse;
	if (m_fRemoveFilePathTableMissing)
		return 0;

	IMsiRecord* piErrRec;
	if (m_piRemoveFilePathTable == 0)
	{
		PMsiDatabase pDatabase(m_riEngine.GetDatabase());
		piErrRec = pDatabase->LoadTable(*MsiString(*sztblRemoveFilePath),0, m_piRemoveFilePathTable);
		if (piErrRec)
		{
			if (piErrRec->GetInteger(1) == idbgDbTableUndefined)
			{
				piErrRec->Release();
				m_fRemoveFilePathTableMissing = fTrue;
				return 0;
			}
			else
				return piErrRec;
		}

		m_piRemoveFilePathCursor = m_piRemoveFilePathTable->CreateCursor(fFalse);
		Assert(m_piRemoveFilePathCursor);

		m_colRemoveFilePath = m_piRemoveFilePathTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblRemoveFilePath_colPath));
		m_colRemoveFilePathComponent = m_piRemoveFilePathTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblRemoveFilePath_colComponent));
		m_colRemoveFilePathMode = m_piRemoveFilePathTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblRemoveFilePath_colRemoveMode));
	}

	MsiString strUpperFullPath;
	riFullPathString.UpperCase(*&strUpperFullPath);
	m_piRemoveFilePathCursor->Reset();
	m_piRemoveFilePathCursor->SetFilter(iColumnBit(m_colRemoveFilePath));
	m_piRemoveFilePathCursor->PutString(m_colRemoveFilePath,*strUpperFullPath);
	if (m_piRemoveFilePathCursor->Next())
	{
		iisEnum iisAction;
		PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
		MsiString strRemoveComponent = m_piRemoveFilePathCursor->GetString(m_colRemoveFilePathComponent);
		piErrRec = pSelectionMgr->GetComponentStates(*strRemoveComponent,NULL, &iisAction);
		if (piErrRec)
			return piErrRec;

		if (iisAction == iisLocal || iisAction == iisAbsent)
		{
			int iMode = m_piRemoveFilePathCursor->GetInteger(m_colRemoveFilePathMode);
			if (iisAction == iisLocal && (iMode & msidbRemoveFileInstallModeOnInstall) ||
				iisAction == iisAbsent && (iMode & msidbRemoveFileInstallModeOnRemove))
			{
				fOnList = fTrue;
			}
		}

		if (strRemoveComponent.Compare(iscExact,riComponentString.GetString()) == 0)
		{
			piErrRec = pSelectionMgr->RegisterCostLinkedComponent(*strRemoveComponent,riComponentString);
			if (piErrRec)
				return piErrRec;
		}
	}

	return 0;
}

// InstallFiles Media Table query enums
enum mfnEnum
{
	mfnLastSequence = 1,
	mfnDiskPrompt,
	mfnVolumeLabel,
	mfnCabinet,
	mfnSource,
	mfnDiskId,
	mfnNextEnum
};

Bool IsCachedPackage(IMsiEngine& riEngine, const IMsiString& riPackage, Bool fPatch, const ICHAR* szCode)
{
	PMsiRecord pErrRec = 0;
	PMsiServices pServices(riEngine.GetServices());

	Bool fCached = fFalse;
	
	// get local package path
	CTempBuffer<ICHAR, MAX_PATH> rgchLocalPackage;
	if (fPatch)
	{
		if (!GetPatchInfo(szCode, INSTALLPROPERTY_LOCALPACKAGE, 
							rgchLocalPackage))
		{
			return fFalse;
		}
	}
	else
	{
		MsiString strProductKey;
		if (szCode)
			strProductKey = szCode;
		else
			strProductKey = riEngine.GetProductKey();

		if (!GetProductInfo(strProductKey, INSTALLPROPERTY_LOCALPACKAGE, 
							rgchLocalPackage))
		{
			return fFalse;
		}
	}

	PMsiPath pDatabasePath(0);
	PMsiPath pLocalPackagePath(0);
	MsiString strDatabaseName;
	MsiString strLocalPackageName;
	ipcEnum ipc;

	if (((pErrRec = pServices->CreateFilePath(riPackage.GetString(), *&pDatabasePath, *&strDatabaseName)) == 0) &&
		 ((pErrRec = pServices->CreateFilePath(rgchLocalPackage, *&pLocalPackagePath, *&strLocalPackageName)) == 0) &&
		((pErrRec = pDatabasePath->Compare(*pLocalPackagePath, ipc)) == 0))
	{
		fCached = (ipc == ipcEqual && strDatabaseName.Compare(iscExactI,strLocalPackageName)) ? fTrue : fFalse;
	}

	return fCached;
}


iesEnum ExecuteChangeMedia(IMsiEngine& riEngine, IMsiRecord& riMediaRec, IMsiRecord& riParamsRec, const IMsiString& ristrTemplate, 
						   unsigned int cbPerTick, const IMsiString& ristrFirstVolLabel)
{
	iesEnum iesExecute;
	PMsiServices pServices(riEngine.GetServices());
	
	// Disk prompt string is created by formatting disk name from media table
	// into the DiskPrompt property template.
	PMsiRecord pPromptRec(&pServices->CreateRecord(2));
	pPromptRec->SetMsiString(0, ristrTemplate);
	pPromptRec->SetMsiString(2, *MsiString(riEngine.GetPropertyFromSz(IPROPNAME_DISKPROMPT)));
	pPromptRec->SetMsiString(0,*MsiString(pPromptRec->FormatText(fFalse)));
	pPromptRec->SetMsiString(1, *MsiString(riMediaRec.GetMsiString(mfnDiskPrompt)));

	riParamsRec.ClearData();

	MsiString strMediaLabel = riMediaRec.GetString(mfnVolumeLabel);
	bool fIsFirstPhysicalDisk = false;
	if(strMediaLabel.Compare(iscExact,ristrFirstVolLabel.GetString()))
	{
		// we are looking at the first Media table record
		// we allow the first disk's volume label to not match the real volume label
		// this is for authoring simplicity with single-volume installs

		// in first-run we use the IPROPNAME_CURRENTMEDIAVOLUMELABEL property, which will
		// be set if we're running from media

		// in maintenance-mode we need to use the label that was stored in the registry source
		// list for this product (if there is one)

		fIsFirstPhysicalDisk = true;
		if (riEngine.GetMode() & iefMaintenance)
		{
			// Media label from sourcelist is always what we want - even if its blank
			strMediaLabel = GetDiskLabel(*pServices, riMediaRec.GetInteger(mfnDiskId), MsiString(riEngine.GetPropertyFromSz(IPROPNAME_PRODUCTCODE)));
		}
		else // first-run
		{
			// if CURRENTMEDIAVOLUMELABEL is an empty string, it means we aren't running from Media - just use label from Media table
			// if CURRENTMEDIAVOLUMELABEL is szBlankVolumeLabelToken, the Media has a blank label
			MsiString strReplacementLabel = riEngine.GetPropertyFromSz(IPROPNAME_CURRENTMEDIAVOLUMELABEL);
			if (strReplacementLabel.TextSize() && !strReplacementLabel.Compare(iscExact, strMediaLabel))
			{
				if (strReplacementLabel.Compare(iscExact, szBlankVolumeLabelToken))
					strMediaLabel = g_MsiStringNull;
				else
					strMediaLabel = strReplacementLabel;
			}
		}
	}
	
	riParamsRec.SetMsiString(IxoChangeMedia::MediaVolumeLabel,*strMediaLabel);
	riParamsRec.SetMsiString(IxoChangeMedia::MediaPrompt,*MsiString(pPromptRec->FormatText(fFalse)));
	riParamsRec.SetInteger(IxoChangeMedia::BytesPerTick,cbPerTick);
	riParamsRec.SetInteger(IxoChangeMedia::IsFirstPhysicalMedia,fIsFirstPhysicalDisk ? 1 : 0);
	
	MsiString strMediaCabinet(riMediaRec.GetMsiString(mfnCabinet));
	if (strMediaCabinet.TextSize() == 0)
	{
		riParamsRec.SetInteger(IxoChangeMedia::CopierType,ictFileCopier);
	}
	else 
	{	
		PMsiRecord pErrRec(0);
	
		// cabinet copy
		if (strMediaCabinet.Compare(iscStart,TEXT("#")))
		{
			// cabinet is in stream of storage object

			MsiString strModuleName, strSubStorageList;
			strMediaCabinet = strMediaCabinet.Extract(iseLast, strMediaCabinet.TextSize() - 1);
			
			// is storage our database or an external storage?
			MsiString strSourceProp = riMediaRec.GetMsiString(mfnSource); // could be null
			
			// is storage top-level or a substorage?
			if(!strSourceProp.TextSize() &&  // storage not defined by an arbitrary property - if it were
														// it would be a top-level storage
				*(const ICHAR*)MsiString(riEngine.GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE)) == ':') // sub-storage
			{
				// sub-storage: cabinets will be in the sub-storage even if we are using the cached msi
				// since we only drop cabinets from the top-level storage when caching

				PMsiDatabase pDatabase(riEngine.GetDatabase());
				PMsiStorage pStorage(0);
				if(pDatabase)
					pStorage = pDatabase->GetStorage(1);
				
				if(!pStorage)
				{
					pErrRec = PostError(Imsg(idbgMissingStorage));
					return riEngine.FatalError(*pErrRec);
				}

				pErrRec = pStorage->GetSubStorageNameList(*&strModuleName, *&strSubStorageList);
				if(pErrRec)
					return riEngine.FatalError(*pErrRec);

				Assert(strModuleName.TextSize() && strSubStorageList.TextSize());
			}
			else
			{
				// storage is top-level

				if(!strSourceProp.TextSize())
				{
					if(riEngine.FChildInstall())
					{
						// if child is merged, DATABASE may not exist during file copy (since its temporary)
						strSourceProp = *IPROPNAME_ORIGINALDATABASE; 
					}
					else
					{
						strSourceProp = *IPROPNAME_DATABASE;
					}
				}

				MsiString strDatabasePath = riEngine.GetProperty(*strSourceProp);
				
				// by default, module name is path to database we are running
				strModuleName = strDatabasePath;

				// If we're in maintenance mode (or applying a patch that changes the product code)
				// then it's possible we are running from a cached database
				// If the source of our cabinets is a cached database then the cabinets won't be there.
				MsiString strPatchedProductKey = riEngine.GetPropertyFromSz(IPROPNAME_PATCHEDPRODUCTCODE);
				if (strPatchedProductKey.TextSize() || riEngine.GetMode() & iefMaintenance)
				{
					// if we are in maintenance mode, the current product has a cached msi and that's the one
					// we'd be using.  if not in maintenance mode, we must be patching a product to a new product
					// code and we may be using the cached msi belonging to the old product
					MsiString strProductKeyForCachedPackage;
					if(riEngine.GetMode() & iefMaintenance)
						strProductKeyForCachedPackage = riEngine.GetProductKey();
					else
						strProductKeyForCachedPackage = strPatchedProductKey;
						
					// Check whether our cabinets are in the cached database
					if (IsCachedPackage(riEngine, *strDatabasePath, fFalse, strProductKeyForCachedPackage))
					{
						// running from source package
						// if a child install, we'll resolve the source here
						// if not a child install, postpone source resolution to script execution
						if(riEngine.FChildInstall())
						{
							if ((pErrRec = ENG::GetSourcedir(*PMsiDirectoryManager(riEngine, IID_IMsiDirectoryManager), *&strModuleName)) != 0)
							{
								if (pErrRec->GetInteger(1) == imsgUser)
									return iesUserExit;
								else
									return riEngine.FatalError(*pErrRec);
							}
						}
						else
						{
							// not a child install - include path with "unresolved source" token
							strModuleName = szUnresolvedSourceRootTokenWithBS;
						}
						
						strModuleName += MsiString(riEngine.GetPackageName());
					}
				}
			}
			AssertNonZero(riParamsRec.SetMsiString(IxoChangeMedia::ModuleFileName,*strModuleName));
			AssertNonZero(riParamsRec.SetMsiString(IxoChangeMedia::ModuleSubStorageList,*strSubStorageList));
			AssertNonZero(riParamsRec.SetInteger(IxoChangeMedia::CopierType,ictStreamCabinetCopier));
		}
		else
		{
			// cabinet is in file
			riParamsRec.SetInteger(IxoChangeMedia::CopierType,ictFileCabinetCopier);

			// external cabs always live at IPROPNAME_SOURCEDIR
			// the Media.Source column can contain a different property, but that's only
			// supported for patches, which currently only use embedded cabs

			// if a child install, get full path to cabinet
			if(riEngine.FChildInstall())
			{
				PMsiPath pCabinetSourcePath(0);
				PMsiDirectoryManager pDirectoryManager(riEngine, IID_IMsiDirectoryManager);

				if ((pErrRec = GetSourcedir(*pDirectoryManager, *&pCabinetSourcePath)) != 0)
				{
					if (pErrRec->GetInteger(1) == imsgUser)
						return iesUserExit;
					else
						return riEngine.FatalError(*pErrRec); //?? Is this error return OK?
				}

				MsiString strCabinetPath;
				if((pErrRec = pCabinetSourcePath->GetFullFilePath(strMediaCabinet,*&strCabinetPath)) != 0)
					return riEngine.FatalError(*pErrRec);

				strMediaCabinet = strCabinetPath;
			}
			else
			{
				// just pass cabinet name in script - will resolve source during script execution
				MsiString strTemp = szUnresolvedSourceRootTokenWithBS;
				strTemp += strMediaCabinet;
				strMediaCabinet = strTemp;
			}

			// check the DigitalSignature table for signature information on this CAB. 
			PMsiStream pHash(0);
			PMsiStream pCertificate(0);
			MsiString strObject(riMediaRec.GetInteger(mfnDiskId));
			MsiString strMedia(sztblMedia);
			switch (GetObjectSignatureInformation(riEngine, *strMedia, *strObject, *&pCertificate, *&pHash))
			{
			case iesNoAction:
				// this cab does not require a signature
				riParamsRec.SetInteger(IxoChangeMedia::SignatureRequired, 0);
				break;
			case iesFailure:
				// problem with the authored signature information. Must fail for security reasons.
				return iesFailure;
			case iesSuccess:
			{
				// a signature is required on this cab. 
				riParamsRec.SetInteger(IxoChangeMedia::SignatureRequired, 1);
				riParamsRec.SetMsiData(IxoChangeMedia::SignatureCert, pCertificate);
				riParamsRec.SetMsiData(IxoChangeMedia::SignatureHash, pHash);
				break;
			}
			default:
				AssertSz(0, "Unknown return type from GetObjectSignatureInformation");
				break;
			}			
		}
	}
	
	riParamsRec.SetMsiString(IxoChangeMedia::MediaCabinet,*strMediaCabinet);
	if ((iesExecute = riEngine.ExecuteRecord(ixoChangeMedia,riParamsRec)) != iesSuccess)
		return iesExecute;

	return iesSuccess;
}


const ICHAR sqlMediaSequence[] = 
TEXT("SELECT `LastSequence`, `DiskPrompt`,%s,`Cabinet`, `DiskId` FROM `Media` ORDER BY `DiskId`");

const ICHAR sqlMediaSequenceWithSource[] = 
TEXT("SELECT `LastSequence`, `DiskPrompt`,%s,`Cabinet`,`Source`, `DiskId` FROM `Media` ORDER BY `DiskId`");

// local fn used by OpenMediaView
// returns fTrue is the Media table has a column called "Source"
Bool FMediaSourceColumn(IMsiEngine& riEngine)
{
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiTable pColumnCatalogTable = pDatabase->GetCatalogTable(1);
	PMsiCursor pColumnCatalogCursor = pColumnCatalogTable->CreateCursor(fFalse);
	pColumnCatalogCursor->SetFilter(iColumnBit(1 /*cccTable*/) | iColumnBit(3 /*cccName*/));
	AssertNonZero(pColumnCatalogCursor->PutString(1 /*cccTable*/,*MsiString(*TEXT("Media"))));
	AssertNonZero(pColumnCatalogCursor->PutString(3 /*cccName*/,*MsiString(*TEXT("Source"))));
	if(pColumnCatalogCursor->Next())
		return fTrue;
	else
		return fFalse;
}

// open a view on the media table - use mfnEnum with fetched records
IMsiRecord* OpenMediaView(IMsiEngine& riEngine, IMsiView*& rpiView, const IMsiString*& rpistrFirstVolLabel)
{
	Bool fMediaSourceColumn = FMediaSourceColumn(riEngine);
	
	ICHAR szQuery[256];
	if(fMediaSourceColumn)
		wsprintf(szQuery, sqlMediaSequenceWithSource, TEXT("`VolumeLabel`"));
	else
		wsprintf(szQuery, sqlMediaSequence, TEXT("`VolumeLabel`"));

	PMsiView pView(0);
	IMsiRecord* piError = riEngine.OpenView(szQuery,ivcFetch,rpiView);
	if(piError)
		return piError;

	piError = rpiView->Execute(0);
	if(piError)
		return piError;

	// need to return the first diskID in the out param - fetch first rec, read diskID, re-execute
	PMsiRecord pRec = rpiView->Fetch();
	if(pRec)
	{
		MsiString(pRec->GetMsiString(mfnVolumeLabel)).ReturnArg(rpistrFirstVolLabel);
	}

	piError = rpiView->Execute(0);
	if(piError)
		return piError;

	// NOTE: ExecuteChangeMedia now special cases records with the first disks VolumeLabel to
	// possibly override the authored media label

	return 0;
}




// Internal action - called only from InstallFiles
iesEnum InstallProtectedFiles(IMsiEngine& riEngine)
{
	PMsiServices pServices(riEngine.GetServices());
	PMsiRecord pRec = &pServices->CreateRecord(1);
	iuiEnum iui;
	if (g_scServerContext == scClient)
		iui = g_MessageContext.GetUILevel();
	else
		iui = (iuiEnum)riEngine.GetPropertyInt(*MsiString(*IPROPNAME_CLIENTUILEVEL)); 
	bool fAllowUI = (iui == iuiNone) ? false : true;
	pRec->SetInteger(IxoInstallProtectedFiles::AllowUI, fAllowUI);
	return riEngine.ExecuteRecord(ixoInstallProtectedFiles, *pRec);
}

static bool ShouldCheckCRC(const bool fPropertySet,
									const iisEnum iisAction,
									const int iFileAttributes)
{
	if ( fPropertySet && iisAction == iisLocal && 
		  (iFileAttributes & msidbFileAttributesChecksum) == msidbFileAttributesChecksum )
		return true;
	else
		return false;
}

const ICHAR sqlPatchesOld[] =
TEXT("SELECT `Patch`.`File_`, `Patch`.`Header`, `Patch`.`Attributes`, NULL FROM `Patch` WHERE `Patch`.`File_` = ? AND `Patch`.`Sequence` > ?")
TEXT("ORDER BY `Patch`.`Sequence`");

const ICHAR sqlPatchesNew[] =
TEXT("SELECT `Patch`.`File_`, `Patch`.`Header`, `Patch`.`Attributes`, `Patch`.`StreamRef_` FROM `Patch` WHERE `Patch`.`File_` = ? AND `Patch`.`Sequence` > ?")
TEXT("ORDER BY `Patch`.`Sequence`");

enum pteEnum // Patch table query enum
{
	pteFile = 1,
	pteHeader,
	pteAttributes,
	pteStreamRef
};

const ICHAR sqlMsiPatchHeaders[] =
TEXT("SELECT `Header` FROM `MsiPatchHeaders` WHERE `StreamRef` = ?");

const ICHAR sqlBypassSFC[] =
TEXT("SELECT `File_` FROM `MsiSFCBypass` WHERE `File_` = ?");

const ICHAR sqlPatchOldAssemblies[] =
TEXT("SELECT `MsiPatchOldAssemblyFile`.`Assembly_` FROM `MsiPatchOldAssemblyFile` WHERE  `MsiPatchOldAssemblyFile`.`File_` = ?");

iesEnum InstallFiles(IMsiEngine& riEngine)
{
	if (!IsFileActivityEnabled(riEngine))
		return InstallProtectedFiles(riEngine);

	PMsiServices pServices(riEngine.GetServices());
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	Assert(pDirectoryMgr);
	int fMode = riEngine.GetMode();

	PMsiRecord pErrRec(0);
	PMsiRecord pRecParams = &pServices->CreateRecord(IxoChangeMedia::Args);
	iesEnum iesExecute;

	Bool fAdmin = (riEngine.GetMode() & iefAdmin) ? fTrue : fFalse;

	// Create our file manager, and order by directory if we're not installing
	// from compression cabinets.
	CMsiFileInstall objFile(riEngine);

	unsigned int cbTotalCost;
	pErrRec = objFile.TotalBytesToCopy(cbTotalCost);
	if (pErrRec)
	{
		// If File table is missing, not an error;
		// simply nothing to do
		if (pErrRec->GetInteger(1) == idbgDbQueryUnknownTable)
		{
			iesExecute = InstallProtectedFiles(riEngine); 
			return iesExecute == iesSuccess ? iesNoAction : iesExecute;
		}
		else
			return riEngine.FatalError(*pErrRec);
	}

	if(cbTotalCost)
	{
		pRecParams->ClearData();
		pRecParams->SetInteger(IxoProgressTotal::Total, cbTotalCost);
		pRecParams->SetInteger(IxoProgressTotal::Type, 0); // 0: separate progress and action data messages
		pRecParams->SetInteger(IxoProgressTotal::ByteEquivalent, 1);
		if ((iesExecute = riEngine.ExecuteRecord(ixoProgressTotal, *pRecParams)) != iesSuccess)
			return iesExecute;
	}

	// Open media table
	PMsiView pMediaView(0);
	MsiString strFirstVolumeLabel;
	pErrRec = OpenMediaView(riEngine,*&pMediaView,*&strFirstVolumeLabel);
	if (pErrRec)
	{
		if (pErrRec->GetInteger(1) == idbgDbQueryUnknownTable)
			pErrRec = PostError(Imsg(idbgMediaTableRequired));

		return riEngine.FatalError(*pErrRec);
	}

	pErrRec = pMediaView->Execute(0);
	if (pErrRec)
		return riEngine.FatalError(*pErrRec);

	Bool fSuppressLFN = riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;

	PMsiPath pDestPath(0);
	PMsiVolume pSourceVol(0); // used only for oem installs
	PMsiVolume pDestVol(0);
	MsiString strSourceDirKey;
	MsiString strDestName;
	MsiString strDestPath;
	MsiString strSourcePath; // may be a relative sub-path

	// LockPermissions table is optional, so politely degrade the functionality
	BOOL fUseACLs = fFalse;
	BOOL fDestSupportsACLs = fFalse;

	int iFileCopyCount = 0;
	int iMediaEnd = 0;  // set to 0 to force media table fetch
	ictEnum ictCurrentMediaType = ictNextEnum;

	PMsiView pviewLockObjects(0);

	if	(	g_fWin9X || fAdmin ||
				(itsUnknown == PMsiDatabase(riEngine.GetDatabase())->FindTable(*MsiString(*TEXT("LockPermissions")))) ||
				(pErrRec = riEngine.OpenView(sqlLockPermissions, ivcFetch, *&pviewLockObjects))
			)
	{
		if (pErrRec)
		{
			int iError = pErrRec->GetInteger(1);
			riEngine.FatalError(*pErrRec);
		}
	}
	else
	{
		fUseACLs = fTrue;
	}
	
	PMsiRecord precLockExecute(&pServices->CreateRecord(2));
	AssertNonZero(precLockExecute->SetMsiString(1, *MsiString(*sztblFile)));

	// open Patch table view - used to grab patch headers for ixoFileCopy ops
	PMsiRecord pPatchViewExecute = &pServices->CreateRecord(2);
	PMsiView pPatchView(0);
	pErrRec = riEngine.OpenView(sqlPatchesNew, ivcFetch, *&pPatchView);
	if (pErrRec)
	{
		if (idbgDbQueryUnknownColumn == pErrRec->GetInteger(1))
		{
			// try old schema patch
			pErrRec = riEngine.OpenView(sqlPatchesOld, ivcFetch, *&pPatchView);
		}

		if (pErrRec && pErrRec->GetInteger(1) != idbgDbQueryUnknownTable
			//!! next line temp
			&& pErrRec->GetInteger(1) != idbgDbQueryUnknownColumn)
			return riEngine.FatalError(*pErrRec);
	}
	// if pPatchView set, we have a patch table, otherwise we don't

	// open MsiPatchOldAssemblyFile table view
	PMsiRecord pPatchOldAssemblyFileViewExecute(0);
	PMsiView   pPatchOldAssemblyFileView(0);
	
	if(pPatchView)
	{
		pPatchOldAssemblyFileViewExecute = &::CreateRecord(1);
		pErrRec = riEngine.OpenView(sqlPatchOldAssemblies, ivcFetch, *&pPatchOldAssemblyFileView);
		if(pErrRec && pErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pErrRec);
	}


	MsiString strDiskPromptTemplate = riEngine.GetErrorTableString(imsgPromptForDisk);

	
	bool fMoveFileForOEMs = false;
	// for oem installs, resolve source now (it is already available during an OEM install)
	// and save off the volume so we can tell when the source and target volumes are the same
	if ( g_MessageContext.IsOEMInstall() )
	{
		PMsiPath pSourcePath(0); 
		
		if ((pErrRec = GetSourcedir(*pDirectoryMgr, *&pSourcePath)) != 0)
		{
			if (pErrRec->GetInteger(1) == imsgUser)
				return iesUserExit;
			else
				return riEngine.FatalError(*pErrRec);
		}

		pSourceVol = &(pSourcePath->GetVolume());
	}
	
	int iSourceTypeForChildInstalls = -1; // we resolve the source now for child installs
													  // (as opposed to during script generation for normal installs)
	PMsiPath pSourceRootForChildInstall(0);
	bool fCheckCRC = 
		MsiString(riEngine.GetPropertyFromSz(IPROPNAME_CHECKCRCS)).TextSize() ? true : false;

	PMsiRecord pBypassSFCExecute = &pServices->CreateRecord(1);
	PMsiView pBypassSFCView(0);
	if (!g_fWin9X)
	{
		pErrRec = riEngine.OpenView(sqlBypassSFC, ivcFetch, *&pBypassSFCView);
		if (pErrRec && pErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pErrRec);
	}

	// attempt to open view on MsiPatchHeaders table
	PMsiView pMsiPatchHeadersView(0);
	pErrRec = riEngine.OpenView(sqlMsiPatchHeaders, ivcFetch, *&pMsiPatchHeadersView);
	if (pErrRec && pErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
		return riEngine.FatalError(*pErrRec);


	for(;;)
	{
		pErrRec = objFile.FetchFile();
		if (pErrRec)
			return riEngine.FatalError(*pErrRec);

		PMsiRecord pFileRec(objFile.GetFileRecord());
		if (!pFileRec)
		{
			if (iFileCopyCount > 0)
			{
				// Ok, we're done processing all files in the File table.
				// If there are any Media table entries left unprocessed,
				// flush out ChangeMedia operations for each, in case the
				// last file copied was split across disk(s). Otherwise,
				// we'll never change disks to finish copying the last
				// part(s) of the split file.
				PMsiRecord pMediaRec(0);
				while ((pMediaRec = pMediaView->Fetch()) != 0)
				{
					iesExecute = ExecuteChangeMedia(riEngine, *pMediaRec, *pRecParams, *strDiskPromptTemplate, iBytesPerTick, *strFirstVolumeLabel);
					if (iesExecute != iesSuccess)
						return iesExecute;
				}
			}
			break;
		}

#ifdef DEBUG
		const ICHAR* szFileName = pFileRec->GetString(CMsiFile::ifqFileName);
		const ICHAR* szComponent = pFileRec->GetString(CMsiFile::ifqComponent);
#endif //DEBUG

		iisEnum iisAction = (iisEnum) pFileRec->GetInteger(CMsiFile::ifqAction);
		if (iisAction != iisLocal && iisAction != iisSource)
			continue;
		
		int iAttributes = pFileRec->GetInteger(CMsiFile::ifqAttributes) & (~iReservedFileAttributeBits);

		bool fFileIsCompressedInChildInstall = false;
		bool fSourceIsLFNInChildInstall = false;
		if(riEngine.FChildInstall())
		{
			if(iSourceTypeForChildInstalls == -1)
			{	
				pErrRec = pDirectoryMgr->GetSourceRootAndType(*&pSourceRootForChildInstall,
																			 iSourceTypeForChildInstalls);
				if(pErrRec)
				{
					if (pErrRec->GetInteger(1) == imsgUser)
						return iesUserExit;
					else
						return riEngine.FatalError(*pErrRec);
				}

				fSourceIsLFNInChildInstall = FSourceIsLFN(iSourceTypeForChildInstalls,
																		*pSourceRootForChildInstall);
			}

			fFileIsCompressedInChildInstall = FFileIsCompressed(iSourceTypeForChildInstalls,
																				 iAttributes);
		}

		MsiString strFileDir(pFileRec->GetString(CMsiFile::ifqDirectory));

		// set destination folder, but only if necessary
		if (strDestName.Compare(iscExact, strFileDir) == 0 || !pDestPath)
		{
			strDestName = strFileDir;
			pErrRec = pDirectoryMgr->GetTargetPath(*strDestName,*&pDestPath);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
			if (pDestPath == 0)
			{
				pErrRec = PostError(Imsg(idbgNoProperty), *strDestName);
				return riEngine.FatalError(*pErrRec);
			}
			fDestSupportsACLs = PMsiVolume(&pDestPath->GetVolume())->FileSystemFlags() & FS_PERSISTENT_ACLS;

			strDestPath = pDestPath->GetPath();
			pRecParams->ClearData();
			pRecParams->SetMsiString(IxoSetTargetFolder::Folder,*strDestPath);
			if ((iesExecute = riEngine.ExecuteRecord(ixoSetTargetFolder, *pRecParams)) != iesSuccess)
				return iesExecute;

			if ( g_MessageContext.IsOEMInstall() )
			{
				pDestVol = &(pDestPath->GetVolume());
				AssertSz(pDestVol, TEXT("Couldn't get pDestVol in InstallFiles"));
				if ( pDestVol && pSourceVol && pDestVol->DriveType() == idtFixed &&
					  pDestVol->VolumeID() && pDestVol->VolumeID() == pSourceVol->VolumeID() )
					fMoveFileForOEMs = true;
				else
					fMoveFileForOEMs = false;
			}
		}
		
		// check for redirected file - compound file key
		MsiString strFileKey(pFileRec->GetMsiString(CMsiFile::ifqFileKey));
		MsiString strSourceFileKey(strFileKey);  // with any compound key suffix removed
		if (((const ICHAR*)strSourceFileKey)[strSourceFileKey.TextSize() - 1] == ')')
		{
			CMsiFile objSourceFile(riEngine);
			AssertNonZero(strSourceFileKey.Remove(iseFrom, '('));
			pErrRec = objSourceFile.FetchFile(*strSourceFileKey);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
			PMsiRecord pSourceFileRec = objSourceFile.GetFileRecord();
			strFileDir = pSourceFileRec->GetMsiString(CMsiFile::ifqDirectory);
		}
		
		// set source folder, but only if necessary
		if(strSourceDirKey.Compare(iscExact, strFileDir) == 0)
		{
			strSourceDirKey = strFileDir;

			pErrRec = 0;
			// for nested installs, use full source path (may mean source is resolve prematurely)
			// for non-nested installs, postpone source resolution to script execution
			if(riEngine.FChildInstall())
			{
				Assert(iSourceTypeForChildInstalls >= 0);
				Assert(pSourceRootForChildInstall);
				
				if((iSourceTypeForChildInstalls & msidbSumInfoSourceTypeCompressed) &&
					pSourceRootForChildInstall)
				{
					strSourcePath = pSourceRootForChildInstall->GetPath();
				}
				else
				{
					PMsiPath pSourcePath(0);
					pErrRec = pDirectoryMgr->GetSourcePath(*strSourceDirKey, *&pSourcePath);
					if (pErrRec)
					{
						return riEngine.FatalError(*pErrRec);
					}
					strSourcePath = pSourcePath->GetPath();
				}				
			}
			else
			{
				pErrRec = pDirectoryMgr->GetSourceSubPath(*strSourceDirKey, true, *&strSourcePath);
				if (pErrRec)
				{
					return riEngine.FatalError(*pErrRec);
				}
			}
			
			pRecParams->ClearData();
			AssertNonZero(pRecParams->SetMsiString(IxoSetSourceFolder::Folder,*strSourcePath));
			if ((iesExecute = riEngine.ExecuteRecord(ixoSetSourceFolder, *pRecParams)) != iesSuccess)
				return iesExecute;
		}

		int iTempAttributes = pFileRec->GetInteger(CMsiFile::ifqTempAttributes);
		// If this file was identified as having a companion parent (during costing),
		// we've got to execute an ixoSetCompanionParent operation before file copy.
		bool fSetCompanionParent = false;
		DWORD dwDummy;
		if ( g_MessageContext.IsOEMInstall() && 
			  !ParseVersionString(pFileRec->GetString(CMsiFile::ifqVersion), dwDummy, dwDummy) )
			fSetCompanionParent = true;
		else if (iTempAttributes & itfaCompanion)
			fSetCompanionParent = true;
		if ( fSetCompanionParent )
		{
			using namespace IxoSetCompanionParent;
			MsiString strParent(pFileRec->GetMsiString(CMsiFile::ifqVersion));
			CMsiFile objParentFile(riEngine);
			pErrRec = objParentFile.FetchFile(*strParent);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);

			PMsiPath pParentPath(0);
			pErrRec = objParentFile.GetTargetPath(*&pParentPath);
			if (pErrRec)
			{
				if (pErrRec->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return riEngine.FatalError(*pErrRec);
			}

			PMsiRecord pParentRec(objParentFile.GetFileRecord());

			MsiString strParentFileName;
			if((pErrRec = objParentFile.GetExtractedTargetFileName(*pParentPath, *&strParentFileName)) != 0)
				return riEngine.FatalError(*pErrRec);
			
			pRecParams->ClearData();
			pRecParams->SetMsiString(IxoSetCompanionParent::ParentPath,*MsiString(pParentPath->GetPath()));
			pRecParams->SetMsiString(IxoSetCompanionParent::ParentName,*strParentFileName);
			pRecParams->SetMsiString(IxoSetCompanionParent::ParentVersion,
											 *MsiString(pParentRec->GetString(CMsiFile::ifqVersion)));
			pRecParams->SetMsiString(IxoSetCompanionParent::ParentLanguage,
											 *MsiString(pParentRec->GetString(CMsiFile::ifqLanguage)));
			if ((iesExecute = riEngine.ExecuteRecord(ixoSetCompanionParent, *pRecParams)) != iesSuccess)
				return iesExecute;
		}

		pFileRec->SetMsiString(CMsiFile::ifqDirectory, *strDestPath);

		// If iFileSequence is past the end of the current media, switch to
		// the next disk.  Use a loop in case the file we want isn't on the
		// next consecutive disk.
		int iFileSequence = pFileRec->GetInteger(CMsiFile::ifqSequence);
		Assert(iFileSequence > 0);
		while (iFileSequence > iMediaEnd)
		{
			PMsiRecord pMediaRec(pMediaView->Fetch());
			if (pMediaRec == 0)
			{
				pErrRec = PostError(Imsg(idbgMissingMediaTable), *MsiString(sztblFile), *strFileKey);
				return riEngine.FatalError(*pErrRec);
			}
			iMediaEnd = pMediaRec->GetInteger(mfnLastSequence);

			// Always execute the ChangeMedia operation for each Media table entry, even
			// if the next file we want is not on the very next disk - we don't want
			// to miss a ChangeMedia for a split file that needs the next disk (even if
			// we don't have any other files to copy on that next disk).  If it turns out
			// that we don't need to copy any files at all from a particular disk, no
			// problem - the execute operations won't prompt for a disk that isn't needed.
			
			iesExecute = ExecuteChangeMedia(riEngine, *pMediaRec, *pRecParams, *strDiskPromptTemplate, iBytesPerTick, *strFirstVolumeLabel);
			if (iesExecute != iesSuccess)
				return iesExecute;

			ictCurrentMediaType = (ictEnum) pRecParams->GetInteger(IxoChangeMedia::CopierType);
		}

#ifdef DEBUG
		ICHAR rgchFileKey[256];
		strFileKey.CopyToBuf(rgchFileKey,255);
#endif

		// extract appropriate name from short|long pair for target file
		MsiString strDestFileName;
		if((pErrRec = objFile.GetExtractedTargetFileName(*pDestPath,*&strDestFileName)) != 0)
			return riEngine.FatalError(*pErrRec);

		// is this file part of a fusion assembly?
		MsiString strComponentKey = pFileRec->GetMsiString(CMsiFile::ifqComponent);
		iatAssemblyType iatType = iatNone;
		MsiString strManifest;
		if((pErrRec = riEngine.GetAssemblyInfo(*strComponentKey, iatType, 0, &strManifest)) != 0)
			return riEngine.FatalError(*pErrRec);

		bool fAssemblyFile = false;
		if(iatType == iatURTAssembly || iatType == iatWin32Assembly)
		{
			fAssemblyFile = true;
		}

		long cPatchHeaders = 0;
		long cOldAssemblies = 0;

		if(pPatchView)
		{
			AssertNonZero(pPatchViewExecute->SetMsiString(1,*strSourceFileKey));
			AssertNonZero(pPatchViewExecute->SetInteger(2,iFileSequence));
			if((pErrRec = pPatchView->Execute(pPatchViewExecute)) != 0 ||
				(pErrRec = pPatchView->GetRowCount(cPatchHeaders)) != 0)
				return riEngine.FatalError(*pErrRec);

			if(fAssemblyFile && pPatchOldAssemblyFileView)
			{
				AssertNonZero(pPatchOldAssemblyFileViewExecute->SetMsiString(1,*strSourceFileKey));
				if((pErrRec = pPatchOldAssemblyFileView->Execute(pPatchOldAssemblyFileViewExecute)) != 0 ||
					(pErrRec = pPatchOldAssemblyFileView->GetRowCount(cOldAssemblies)) != 0)
					return riEngine.FatalError(*pErrRec);
			}

		}

		PMsiRecord pRecCopy(0);
		int iPatchHeadersStart = 0;
		
		if(false == fAssemblyFile)
		{
			// create record and set args specific to IxoFileCopy
			
			using namespace IxoFileCopy;
			pRecCopy = &pServices->CreateRecord(Args-1+cPatchHeaders);

			iPatchHeadersStart = VariableStart;

			int fInstallModeFlags = GetInstallModeFlags(riEngine,iAttributes);
			if (iisAction == iisSource)
				fInstallModeFlags |= icmRunFromSource;
			else if(iisAction == iisLocal && !pFileRec->IsNull(CMsiFile::ifqForceLocalFiles))
				fInstallModeFlags |= icmOverwriteAllFiles;
			if ( g_MessageContext.IsOEMInstall() && iisAction == iisLocal && fMoveFileForOEMs )
				fInstallModeFlags |= icmRemoveSource;
			pRecCopy->SetInteger(InstallMode,fInstallModeFlags);
			pRecCopy->SetMsiString(Version,*MsiString(pFileRec->GetMsiString(CMsiFile::ifqVersion)));
			pRecCopy->SetMsiString(Language,*MsiString(pFileRec->GetMsiString(CMsiFile::ifqLanguage)));
			pRecCopy->SetInteger(CheckCRC, ShouldCheckCRC(fCheckCRC, iisAction, iAttributes));

			MD5Hash hHash;
			bool fHashInfo = false;
			pErrRec = riEngine.GetFileHashInfo(*strFileKey, /* dwFileSize=*/ 0, hHash, fHashInfo);
			if(pErrRec)
				return riEngine.FatalError(*pErrRec);
			
			if(fHashInfo)
			{
				AssertNonZero(pRecCopy->SetInteger(HashOptions, hHash.dwOptions));
				AssertNonZero(pRecCopy->SetInteger(HashPart1,   hHash.dwPart1));
				AssertNonZero(pRecCopy->SetInteger(HashPart2,   hHash.dwPart2));
				AssertNonZero(pRecCopy->SetInteger(HashPart3,   hHash.dwPart3));
				AssertNonZero(pRecCopy->SetInteger(HashPart4,   hHash.dwPart4));
			}
		}
		else
		{
			// create record and set args specific to IxoAssemblyCopy

			using namespace IxoAssemblyCopy;
			pRecCopy = &pServices->CreateRecord(Args-1+cPatchHeaders+cOldAssemblies);

			// is this file the manifest file?
			if(strManifest.Compare(iscExact, strFileKey))
			{
				pRecCopy->SetInteger(IsManifest, fTrue); // need to know the manifest file during assembly installation
			}

			iPatchHeadersStart = VariableStart;
			int iOldAssembliesStart = iPatchHeadersStart + cPatchHeaders;
			
			if(cOldAssemblies)
			{
				int iIndex = iOldAssembliesStart;
				PMsiRecord pOldAssemblyFetch(0);
				while((pOldAssemblyFetch = pPatchOldAssemblyFileView->Fetch()) != 0)
				{
					MsiString strOldAssembly = pOldAssemblyFetch->GetMsiString(1);

					// get the assembly name
					MsiString strOldAssemblyName;
					pErrRec = riEngine.GetAssemblyNameSz(*strOldAssembly, iatType, true, *&strOldAssemblyName);
					if(pErrRec)
						return riEngine.FatalError(*pErrRec);

					AssertNonZero(pRecCopy->SetMsiString(iIndex++, *strOldAssemblyName));

#ifdef DEBUG				
					DEBUGMSG2(TEXT("OldAssembly fetch: Assembly = '%s', Name = '%s'"),
								 (const ICHAR*)strOldAssembly, (const ICHAR*)strOldAssemblyName);
#endif //DEBUG
				}

				if(pPatchOldAssemblyFileView)
					pPatchOldAssemblyFileView->Close();

				AssertNonZero(pRecCopy->SetInteger(OldAssembliesCount, cOldAssemblies));
				AssertNonZero(pRecCopy->SetInteger(OldAssembliesStart, iOldAssembliesStart));
			}
		
			AssertNonZero(pRecCopy->SetMsiString(ComponentId,*MsiString(pFileRec->GetMsiString(CMsiFile::ifqComponentId))));
		}
			
		{
			// now set the args in the record that are shared between
			// IxoFileCopy and IxoAssemblyCopy

			Assert(IxoFileCopyCore::SourceName         == IxoFileCopy::SourceName         && IxoFileCopyCore::SourceName         == IxoAssemblyCopy::SourceName);
			Assert(IxoFileCopyCore::SourceCabKey       == IxoFileCopy::SourceCabKey       && IxoFileCopyCore::SourceCabKey       == IxoAssemblyCopy::SourceCabKey);
			Assert(IxoFileCopyCore::DestName           == IxoFileCopy::DestName           && IxoFileCopyCore::DestName           == IxoAssemblyCopy::DestName);
			Assert(IxoFileCopyCore::Attributes         == IxoFileCopy::Attributes         && IxoFileCopyCore::Attributes         == IxoAssemblyCopy::Attributes);
			Assert(IxoFileCopyCore::FileSize           == IxoFileCopy::FileSize           && IxoFileCopyCore::FileSize           == IxoAssemblyCopy::FileSize);
			Assert(IxoFileCopyCore::PerTick            == IxoFileCopy::PerTick            && IxoFileCopyCore::PerTick            == IxoAssemblyCopy::PerTick);
			Assert(IxoFileCopyCore::IsCompressed       == IxoFileCopy::IsCompressed       && IxoFileCopyCore::IsCompressed       == IxoAssemblyCopy::IsCompressed);
			Assert(IxoFileCopyCore::VerifyMedia        == IxoFileCopy::VerifyMedia        && IxoFileCopyCore::VerifyMedia        == IxoAssemblyCopy::VerifyMedia);
			Assert(IxoFileCopyCore::ElevateFlags       == IxoFileCopy::ElevateFlags       && IxoFileCopyCore::ElevateFlags       == IxoAssemblyCopy::ElevateFlags);
			Assert(IxoFileCopyCore::TotalPatches       == IxoFileCopy::TotalPatches       && IxoFileCopyCore::TotalPatches       == IxoAssemblyCopy::TotalPatches);
			Assert(IxoFileCopyCore::PatchHeadersStart  == IxoFileCopy::PatchHeadersStart  && IxoFileCopyCore::PatchHeadersStart  == IxoAssemblyCopy::PatchHeadersStart);
			Assert(IxoFileCopyCore::SecurityDescriptor == IxoFileCopy::SecurityDescriptor && IxoFileCopyCore::SecurityDescriptor == IxoAssemblyCopy::Empty);

			Assert(pRecCopy);

			using namespace IxoFileCopyCore;

			if(cPatchHeaders)
			{
				int iIndex = iPatchHeadersStart;
				PMsiRecord pPatchFetch(0);

				PMsiRecord pMsiPatchHeadersExecute = &pServices->CreateRecord(1);
				PMsiRecord pMsiPatchHeadersFetch(0);

				while((pPatchFetch = pPatchView->Fetch()) != 0)
				{
	#ifdef DEBUG
					const ICHAR* szFile = pPatchFetch->GetString(pteFile);
	#endif //DEBUG
					if (fFalse == pPatchFetch->IsNull(pteHeader))
					{
						AssertNonZero(pRecCopy->SetMsiData(iIndex++, PMsiData(pPatchFetch->GetMsiData(pteHeader))));
					}
					else // patch row hit OLE stream name limit, header is in the MsiPatchHeaders table
					{
						if (pPatchFetch->IsNull(pteStreamRef) == fTrue)
						{
							pErrRec = PostError(Imsg(idbgTableDefinition), *MsiString(sztblPatch));
							return riEngine.FatalError(*pErrRec);
						}

						if (!pMsiPatchHeadersView)
						{
							// Patch table row is set up to reference MsiPatchHeaders table, but the MsiPatchHeaders table is missing
							pErrRec = PostError(Imsg(idbgBadForeignKey), *MsiString(pPatchFetch->GetMsiString(pteStreamRef)), *MsiString(*sztblPatch_colStreamRef),*MsiString(*sztblPatch));
							return riEngine.FatalError(*pErrRec);
						}

						pMsiPatchHeadersView->Close();
						AssertNonZero(pMsiPatchHeadersExecute->SetMsiString(1, *MsiString(pPatchFetch->GetMsiString(pteStreamRef))));
						if ((pErrRec = pMsiPatchHeadersView->Execute(pMsiPatchHeadersExecute)) != 0)
							return riEngine.FatalError(*pErrRec);
						if (!(pMsiPatchHeadersFetch = pMsiPatchHeadersView->Fetch()))
						{
							// bad foreign key, can't find row in MsiPatchHeaders table
							pErrRec = PostError(Imsg(idbgBadForeignKey), *MsiString(pPatchFetch->GetMsiString(pteStreamRef)), *MsiString(*sztblPatch_colStreamRef),*MsiString(*sztblPatch));
							return riEngine.FatalError(*pErrRec);
						}
#ifdef DEBUG
						Assert(pMsiPatchHeadersFetch->IsNull(1) == fFalse);
#endif//DEBUG
						AssertNonZero(pRecCopy->SetMsiData(iIndex++, PMsiData(pMsiPatchHeadersFetch->GetMsiData(1))));
					}
				}
			
				AssertNonZero(pRecCopy->SetInteger(TotalPatches, cPatchHeaders));
				AssertNonZero(pRecCopy->SetInteger(PatchHeadersStart, iPatchHeadersStart));
			}

			if(pPatchView)
				pPatchView->Close();

			if(riEngine.FChildInstall())
			{
				MsiString strSourceNameForChildInstall;
				pErrRec = pServices->ExtractFileName(pFileRec->GetString(CMsiFile::ifqFileName),
																 ToBool(fSourceIsLFNInChildInstall),
																 *&strSourceNameForChildInstall);
				if(pErrRec)
					return riEngine.FatalError(*pErrRec);

				AssertNonZero(pRecCopy->SetMsiString(SourceName,*strSourceNameForChildInstall));
			}
			else
			{
				AssertNonZero(pRecCopy->SetMsiString(SourceName,
																 *MsiString(pFileRec->GetMsiString(CMsiFile::ifqFileName))));
			}

			AssertNonZero(pRecCopy->SetMsiString(SourceCabKey,*strSourceFileKey));

			PMsiStream pSD(0);
			if (fUseACLs && fDestSupportsACLs)
			{
				// generate security descriptor
				AssertNonZero(precLockExecute->SetMsiString(2, *strFileKey));
				pErrRec = pviewLockObjects->Execute(precLockExecute);
				if (pErrRec)
					return riEngine.FatalError(*pErrRec);

				pErrRec = GenerateSD(riEngine, *pviewLockObjects, precLockExecute, *&pSD);
				if (pErrRec)
					return riEngine.FatalError(*pErrRec);

				if ((pErrRec = pviewLockObjects->Close()))
					return riEngine.FatalError(*pErrRec);
				
				
				AssertNonZero(pRecCopy->SetMsiData(SecurityDescriptor, pSD));
			}
			else
				AssertNonZero(pRecCopy->SetNull(SecurityDescriptor));

			// Set up the rest of the CopyTo file parameter record
			pRecCopy->SetMsiString(DestName,*strDestFileName);
			pRecCopy->SetInteger(Attributes,iAttributes);
			pRecCopy->SetInteger(FileSize,pFileRec->GetInteger(CMsiFile::ifqFileSize));
			if(riEngine.FChildInstall())
			{
				pRecCopy->SetInteger(IsCompressed, fFileIsCompressedInChildInstall ? 1 : 0);
			}
			pRecCopy->SetInteger(PerTick,iBytesPerTick);
			pRecCopy->SetInteger(VerifyMedia, fTrue);

			if (pBypassSFCView)
			{
				AssertNonZero(pBypassSFCExecute->SetMsiString(1, *strFileKey));
				pErrRec = pBypassSFCView->Execute(pBypassSFCExecute);
				if (pErrRec)
					return riEngine.FatalError(*pErrRec);
				PMsiRecord pFetch = pBypassSFCView->Fetch();
			
				if (pFetch)
				{
					AssertNonZero(pRecCopy->SetInteger(ElevateFlags, ielfBypassSFC));
				}
			}
		}

		if ((iesExecute = riEngine.ExecuteRecord(fAssemblyFile ? ixoAssemblyCopy : ixoFileCopy, *pRecCopy)) != iesSuccess)
			return iesExecute;
		iFileCopyCount++;
	}

	// Always top off InstallFiles by emitting the InstallProtectedFiles Opcode (even if no
	// ixoFileCopy Opcodes were generated, since other previous actions, such as MoveFiles,
	// may have generated ixoFileCopy operations)
	return InstallProtectedFiles(riEngine);
}

bool FFileIsCompressed(int iSourceType, int iFileAttributes)
{
	bool fZeroLengthFileInstall = (iFileAttributes & (msidbFileAttributesNoncompressed | msidbFileAttributesCompressed))
												== (msidbFileAttributesNoncompressed | msidbFileAttributesCompressed);

	bool fAdminImage = (iSourceType & msidbSumInfoSourceTypeAdminImage) ? true : false;
	
	bool fCompressedSource = (iSourceType & msidbSumInfoSourceTypeCompressed) ? true : false;
		
	return ((fCompressedSource && (iFileAttributes & msidbFileAttributesNoncompressed) == 0) ||
			  (!fAdminImage && !fCompressedSource && !fZeroLengthFileInstall && (iFileAttributes & msidbFileAttributesCompressed)) ||
			  (iFileAttributes & msidbFileAttributesPatchAdded)) ? true : false;
}

bool FSourceIsLFN(int iSourceType, IMsiPath& riPath)
{
	if(((iSourceType & msidbSumInfoSourceTypeSFN) == 0) && riPath.SupportsLFN())
		return true;
	else
		return false;
}


/*---------------------------------------------------------------------------
	RemoveFiles costing/action
---------------------------------------------------------------------------*/
class CMsiRemoveFileCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall Reset();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost, 
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);

public:  // constructor
	CMsiRemoveFileCost(IMsiEngine& riEngine);
protected:
	~CMsiRemoveFileCost();
private:
	enum icrlEnum
	{
		icrlCompileInit,
		icrlCompileDisable,
		icrlCompileDynamic,
		icrlNextEnum
	};
	IMsiRecord* Initialize(Bool fInit);
	IMsiRecord* AddToRemoveFilePathTable(const IMsiString& riPathString, const IMsiString& riComponentString, int iRemoveMode);
	IMsiRecord* RemoveComponentFromRemoveFilePathTable(const IMsiString& riComponentString);
	IMsiRecord* CompileRemoveList(const IMsiString& riComponentString, const IMsiString& riDirectoryString);
	IMsiRecord* GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost, icrlEnum icrlCompileMode);
};
CMsiRemoveFileCost::CMsiRemoveFileCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine){}
CMsiRemoveFileCost::~CMsiRemoveFileCost(){}


IMsiRecord* CMsiRemoveFileCost::Reset()
//------------------------------------------
{
	if (m_piRemoveFilePathCursor)
	{
		m_piRemoveFilePathCursor->Reset();
		while (m_piRemoveFilePathCursor->Next())
		{
			m_piRemoveFilePathCursor->Delete();
		}
	}

	return Initialize(/*fInit=*/ fFalse);
}

IMsiRecord* CMsiRemoveFileCost::Initialize()
//------------------------------------------
{
	return Initialize(/*fInit=*/ fTrue);
}


static const ICHAR sqlInitRemoveFiles[] = TEXT("SELECT `Component_`,`DirProperty` FROM `RemoveFile`");

IMsiRecord* CMsiRemoveFileCost::Initialize(Bool fInit)
//------------------------------------------
{

	enum initmfEnum
	{
		initrfComponent = 1,
		initrfDirProperty,
		initrfNextEnum
	};
	PMsiView pView(0);
	IMsiRecord* piErrRec = m_riEngine.OpenView(sqlInitRemoveFiles, ivcFetch, *&pView);
	if (piErrRec)
	{
		if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return piErrRec;
		else
		{
			piErrRec->Release();
			return 0;
		}
	}

	if ((piErrRec = pView->Execute(0)) != 0)
		return piErrRec;

	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	for(;;)
	{
		PMsiRecord pViewRec(pView->Fetch());
		if (!pViewRec)
			break;

		MsiString strComponent(pViewRec->GetMsiString(initrfComponent));
		MsiString strDirProperty(pViewRec->GetMsiString(initrfDirProperty));
		if (fInit)
		{
			piErrRec = pSelectionMgr->RegisterComponentDirectory(*strComponent, *strDirProperty);
			if (piErrRec)
				return piErrRec;
		}
		else
		{
			MsiString strPath(m_riEngine.GetProperty(*strDirProperty));
			if (strPath.TextSize())
			{
				piErrRec = CompileRemoveList(*strComponent, *strDirProperty);
				if (piErrRec)
					return piErrRec;
			}
		}

	}
	return 0;
}

IMsiRecord* CMsiRemoveFileCost::CompileRemoveList(const IMsiString& riComponentString, const IMsiString& riDirectoryString)
{

	Bool fAddFileInUse = fFalse;
	int iRemoveCost, iNoRbRemoveCost, iLocalCost, iLocalNoRbCost, iSourceCost, iNoRbSourceCost, iARPLocalCost, iNoRbARPLocalCost;

	return GetDynamicCost(riComponentString, riDirectoryString, fAddFileInUse, iRemoveCost, iNoRbRemoveCost, iLocalCost,
							iLocalNoRbCost, iSourceCost, iNoRbSourceCost, iARPLocalCost, iNoRbARPLocalCost, icrlCompileInit);
}


IMsiRecord* CMsiRemoveFileCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
{
	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	icrlEnum icrlCompileMode = pSelectionMgr->IsCostingComplete() ? icrlCompileDynamic : icrlCompileDisable;
	return GetDynamicCost(riComponentString, riDirectoryString, fAddFileInUse, iRemoveCost, iNoRbRemoveCost, 
		                  iLocalCost, iNoRbLocalCost, iSourceCost, iNoRbSourceCost, iARPLocalCost, iNoRbARPLocalCost, icrlCompileMode);
}
										

IMsiRecord* ExtractUnvalidatedFileName(const ICHAR *szFileName, Bool fLFN, const IMsiString*& rpistrExtractedFileName)
/*----------------------------------------------------------------------------
Extracts a short or long file name, based on fLFN, from szFileName. szFileName 
is of the form-> shortFileName OR longFileName OR shortFileName|longFileName. 
Unlike the ExtractFileName services function, this one does not validate
the syntax of the filename.
----------------------------------------------------------------------------*/
{
	const chFileNameSeparator = '|';
	MsiString strCombinedFileName(szFileName);
	MsiString strFileName = strCombinedFileName.Extract(fLFN ? iseAfter : iseUpto, chFileNameSeparator);
	strFileName.ReturnArg(rpistrExtractedFileName);
	return NOERROR;
}


static const ICHAR sqlRemoveFileCost[] = 
	TEXT("SELECT `FileName`,`InstallMode` FROM `RemoveFile` WHERE `Component_`=? AND `DirProperty`=?");

static const ICHAR sqlShortRemoveFileCost[] =
	TEXT("SELECT `FileName`,NULL FROM `RemoveFile` WHERE `Component_`=? AND `DirProperty`=?");

IMsiRecord* CMsiRemoveFileCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost, icrlEnum icrlCompileMode)
//--------------------------------------------
{

	enum irfcEnum
	{
		irfcFileName = 1,
		irfcInstallMode = 2,
		irfcNextEnum
	};

	iRemoveCost = iNoRbRemoveCost = iLocalCost = iSourceCost = iNoRbLocalCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;
	if (!IsFileActivityEnabled(m_riEngine))
		return 0;
	
	// Walk through every file in the RemoveFile table that is tied to riComponentString.
	PMsiServices pServices(m_riEngine.GetServices());
	IMsiRecord* piErrRec;

	if (!m_pCostView)
	{
		if ((piErrRec = m_riEngine.OpenView(sqlRemoveFileCost, ivcFetch, *&m_pCostView)) != 0)
		{
			if (piErrRec->GetInteger(1) == idbgDbQueryUnknownColumn)
			{
				piErrRec->Release();
				piErrRec = m_riEngine.OpenView(sqlShortRemoveFileCost, ivcFetch, *&m_pCostView);
			}
			if (piErrRec)
				return piErrRec;
		}
	}
	else
		m_pCostView->Close();


#ifdef DEBUG
	const ICHAR* szComponent = riComponentString.GetString();
	const ICHAR* szDirectory = riDirectoryString.GetString();
#endif
	PMsiRecord pExecRecord(&pServices->CreateRecord(2));
	pExecRecord->SetMsiString(1, riComponentString);
	pExecRecord->SetMsiString(2,riDirectoryString);
	if ((piErrRec = m_pCostView->Execute(pExecRecord)) != 0)
		return piErrRec;

	PMsiPath pDestPath(0);
	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	piErrRec = pDirectoryMgr->GetTargetPath(riDirectoryString,*&pDestPath);
	if (piErrRec)
	{
		if (piErrRec->GetInteger(1) == idbgDirPropertyUndefined)
		{
			piErrRec->Release();
			return 0;
		}
		else
			return piErrRec;
	}

	Assert(pDestPath);
	if (icrlCompileMode == icrlCompileDynamic)
	{
		piErrRec = RemoveComponentFromRemoveFilePathTable(riComponentString);
		if (piErrRec)
			return piErrRec;
	}

	PMsiRecord pFileRec(0);
	while (pFileRec = m_pCostView->Fetch())
	{
		Bool fLFN = ((m_riEngine.GetMode() & iefSuppressLFN) == fFalse && pDestPath->SupportsLFN()) ? fTrue : fFalse;
		MsiString strWildcardName;
		MsiString strWildcardNamePair = pFileRec->GetMsiString(irfcFileName);
		piErrRec = ExtractUnvalidatedFileName(strWildcardNamePair,fLFN, *&strWildcardName);
		if (piErrRec)
			return piErrRec;

		MsiString strFullFilePath(pDestPath->GetPath());
		strFullFilePath += strWildcardName;
		WIN32_FIND_DATA fdFileData;
		Bool fNextFile = fFalse;
		HANDLE hFindFile = FindFirstFile(strFullFilePath,&fdFileData);
		if (hFindFile == INVALID_HANDLE_VALUE)
			continue;

		int iMode = pFileRec->GetInteger(irfcInstallMode);
		if (iMode == iMsiNullInteger)
			iMode = msidbRemoveFileInstallModeOnInstall;
		do
		{
			// Make sure we haven't located a directory
			if ((fdFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
			{
				unsigned int uiFileSize,uiClusteredSize;

				if (icrlCompileMode != icrlCompileInit)
				{
					piErrRec = pDestPath->FileSize(fdFileData.cFileName,uiFileSize);
					if (piErrRec)
						return piErrRec;
					piErrRec = pDestPath->ClusteredFileSize(uiFileSize,uiClusteredSize);
					if (piErrRec)
						return piErrRec;

					if (iMode & msidbRemoveFileInstallModeOnInstall)
					{
						iNoRbLocalCost -= uiClusteredSize;
						iNoRbSourceCost -= uiClusteredSize;
						iNoRbARPLocalCost -= uiClusteredSize;
					}
					if (iMode & msidbRemoveFileInstallModeOnRemove)
					{
						iNoRbRemoveCost -= uiClusteredSize;
					}

					Bool fInUse;
					piErrRec = pDestPath->FileInUse(fdFileData.cFileName,fInUse);
					if(piErrRec)
						return piErrRec;
					if(fAddFileInUse && fInUse)
					{
						piErrRec = PlaceFileOnInUseList(m_riEngine, *MsiString(fdFileData.cFileName),
																  *MsiString(pDestPath->GetPath()));
						if(piErrRec)
							return piErrRec;
					}

				}

				if (icrlCompileMode != icrlCompileDisable)
				{	// Add files to be removed to list for reference by CMsiFileCost
					MsiString strFullPath;
					piErrRec = pDestPath->GetFullFilePath(fdFileData.cFileName,*&strFullPath);
					if (piErrRec)
						return piErrRec;
	
					piErrRec = AddToRemoveFilePathTable(*strFullPath, riComponentString, iMode);
					if (piErrRec)
						return piErrRec;
				}

			}
			fNextFile = FindNextFile(hFindFile,&fdFileData) ? fTrue : fFalse;
			if (!fNextFile)
				AssertNonZero(FindClose(hFindFile));
		}while (fNextFile);
	}
	return 0;
}



IMsiRecord* CMsiRemoveFileCost::AddToRemoveFilePathTable(const IMsiString& riPathString, const IMsiString& riComponentString, int iRemoveMode)
{
	if (m_piRemoveFilePathTable == 0)
	{
		PMsiDatabase pDatabase(m_riEngine.GetDatabase());
		const int iInitialRows = 5;
		IMsiRecord* piErrRec = pDatabase->CreateTable(*MsiString(*sztblRemoveFilePath),iInitialRows,
			m_piRemoveFilePathTable);
		if (piErrRec)
			return piErrRec;

		AssertNonZero(m_colRemoveFilePath = m_piRemoveFilePathTable->CreateColumn(icdString + icdPrimaryKey,
			*MsiString(*sztblRemoveFilePath_colPath)));
		AssertNonZero(m_colRemoveFilePathComponent = m_piRemoveFilePathTable->CreateColumn(icdString,
			*MsiString(*sztblRemoveFilePath_colComponent)));

		AssertNonZero(m_colRemoveFilePathMode = m_piRemoveFilePathTable->CreateColumn(icdLong,
			*MsiString(*sztblRemoveFilePath_colRemoveMode)));

		m_piRemoveFilePathCursor = m_piRemoveFilePathTable->CreateCursor(fFalse);
		Assert(m_piRemoveFilePathCursor);
	}

	MsiString strUpperFullPath;
	riPathString.UpperCase(*&strUpperFullPath);
	m_piRemoveFilePathCursor->SetFilter(0);
	m_piRemoveFilePathCursor->PutString(m_colRemoveFilePath,*strUpperFullPath);
	m_piRemoveFilePathCursor->PutString(m_colRemoveFilePathComponent,riComponentString);
	m_piRemoveFilePathCursor->PutInteger(m_colRemoveFilePathMode, iRemoveMode);
	AssertNonZero(m_piRemoveFilePathCursor->Assign());
	return 0;
}


IMsiRecord* CMsiRemoveFileCost::RemoveComponentFromRemoveFilePathTable(const IMsiString& riComponentString)
{
	if (!m_piRemoveFilePathTable)
		return 0;

	Assert(m_piRemoveFilePathCursor);
	m_piRemoveFilePathCursor->Reset();
	m_piRemoveFilePathCursor->SetFilter(iColumnBit(m_colRemoveFilePathComponent));
	m_piRemoveFilePathCursor->PutString(m_colRemoveFilePathComponent,riComponentString);
	while (m_piRemoveFilePathCursor->Next())
	{
		m_piRemoveFilePathCursor->Delete();
	}
	return 0;
}


iesEnum RemoveForeignFoldersCore(IMsiEngine& riEngine, IMsiTable& riRemoveFileTable, IMsiPath* piFolderToRemove)
// This function will spit out ixoFolderRemove opcodes for files in the RemoveFile table that have a non-null
// _Path field, which should be those that are to be removed. This function should be called with piFolderToRemove
// set to 0. It will then recursively call itself, ensuring that it spits out
// the op for a child folder before it spits out the op for the child's parent.
{
	static int iPathColumn = 0;
	static int iFileNameColumn = 0;
	if (iPathColumn == 0)
	{
		PMsiDatabase pDatabase = riEngine.GetDatabase();
		iPathColumn     = riRemoveFileTable.GetColumnIndex(pDatabase->EncodeStringSz(sztblRemoveFile_colPath));
		iFileNameColumn = riRemoveFileTable.GetColumnIndex(pDatabase->EncodeStringSz(sztblRemoveFile_colFileName));
		Assert(iPathColumn);
		Assert(iFileNameColumn);
	}

	PMsiCursor pCursor = riRemoveFileTable.CreateCursor(fFalse);
	pCursor->SetFilter(iColumnBit(iFileNameColumn));
	pCursor->PutNull(iFileNameColumn);


	// Iterate through the RemoveFiles table. If this is the top-level call then we call ourself again 
	// with every folder we encounter. If this is not the top-level call then we only call ourself
	// again if the folder we encounter is a child of the folder to remove. After we've removed all
	// the children we remove the folder.
	while (pCursor->Next())
	{
		PMsiPath pFetchedPath = (IMsiPath*)pCursor->GetMsiData(iPathColumn);
		if (!pFetchedPath)
			continue;

		Bool fCallRemoveForeignFoldersCore = fFalse;

		if (piFolderToRemove == 0) // top level call
			fCallRemoveForeignFoldersCore = fTrue;
		else
		{
			PMsiRecord pErrRec(0);
			ipcEnum ipc;
			if ((pErrRec = piFolderToRemove->Compare(*pFetchedPath, ipc)) != 0)
				return riEngine.FatalError(*pErrRec);

			if (ipc == ipcChild)
			{
				DEBUGMSG2(TEXT("Removing child folder of %s (child: %s)"), MsiString(piFolderToRemove->GetPath()), MsiString(pFetchedPath->GetPath()));
				fCallRemoveForeignFoldersCore = fTrue;
			}
		}

		if (fCallRemoveForeignFoldersCore)
		{
			AssertNonZero(pCursor->PutNull(iPathColumn));
			AssertNonZero(pCursor->Update()); // remove path so we don't process this folder again

			iesEnum iesRet = RemoveForeignFoldersCore(riEngine, riRemoveFileTable, pFetchedPath); // remove the child first
			if (iesRet != iesSuccess && iesRet != iesNoAction)
				return iesRet;
		}
	}

	if (piFolderToRemove != 0) // the top-level call doesn't remove anything; it just recursively calls this function w/ every folder
	{
		// Remove ourself
		DEBUGMSG1(TEXT("Removing foreign folder: %s"), (const ICHAR*)MsiString(piFolderToRemove->GetPath()));
		PMsiRecord pRecParams = &CreateRecord(IxoFolderRemove::Args);
		pRecParams->ClearData();
		pRecParams->SetMsiString(IxoFolderRemove::Folder,*MsiString(piFolderToRemove->GetPath()));
		pRecParams->SetInteger(IxoFolderRemove::Foreign, 1);
		iesEnum iesRet;
		if ((iesRet = riEngine.ExecuteRecord(ixoFolderRemove, *pRecParams)) != iesSuccess)
			return iesRet;
	}

	return iesSuccess;
}

static const ICHAR sqlRemoveForeignFiles[] =
	TEXT("SELECT `FileName`,`DirProperty`,`InstallMode`,`Action` FROM `RemoveFile`,`Component` WHERE `Component`=`Component_` AND `FileName` IS NOT NULL")
	TEXT(" ORDER BY `DirProperty`");

static const ICHAR sqlShortRemoveForeignFiles[] =
	TEXT("SELECT `FileName`,`DirProperty`,NULL,`Action` FROM `RemoveFile`,`Component` WHERE `Component`=`Component_` AND `FileName` IS NOT NULL")
	TEXT(" ORDER BY `DirProperty`");

static const ICHAR sqlRemoveForeignFolders[] =
	TEXT("SELECT `_Path`, `DirProperty`,`InstallMode`,`Action` FROM `RemoveFile`,`Component` WHERE `FileName` IS NULL AND `Component`=`Component_` ");

static const ICHAR sqlShortRemoveForeignFolders[] =
	TEXT("SELECT `_Path`, `DirProperty`,NULL,`Action` FROM `RemoveFile`,`Component` WHERE `FileName` IS NULL AND `Component`=`Component_` ");

iesEnum RemoveForeignFilesOrFolders(IMsiEngine& riEngine, Bool fFolders)
{


	// RemoveForeignFiles query
	enum irffEnum
	{
		irffFileNameOrPath = 1,
		irffDirProperty,
		irffInstallMode,
		irffAction,
		irffNextEnum
	};

	using namespace IxoFileRemove;

	iesEnum iesExecute;
	PMsiRecord pErrRec(0);
	PMsiServices pServices(riEngine.GetServices());

	// Open the RemoveFile table, if present. This table is optional, so its
	// absence is not an error.
	PMsiView pRemoveView(0);
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiTable pRemoveFileTable(0);

	pErrRec = pDatabase->LoadTable(*MsiString(sztblRemoveFile), 1, *&pRemoveFileTable);

	if (pErrRec == 0)
	{
		if (fFolders)
			AssertNonZero(pRemoveFileTable->CreateColumn(icdTemporary|icdNullable|icdObject, *MsiString(*sztblRemoveFile_colPath))); // to hold our path objects

		pErrRec = riEngine.OpenView(fFolders ? sqlRemoveForeignFolders : sqlRemoveForeignFiles, ivcEnum(ivcFetch|ivcUpdate), *&pRemoveView);
		if (pErrRec)
		{
			if (pErrRec->GetInteger(1) == idbgDbQueryUnknownColumn)
			{
				pErrRec = riEngine.OpenView(fFolders ? sqlShortRemoveForeignFolders : sqlShortRemoveForeignFiles, ivcEnum(ivcFetch|ivcUpdate), *&pRemoveView);
			}
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
		}
	}
	else if (pErrRec->GetInteger(1) != idbgDbTableUndefined)
	{
		return riEngine.FatalError(*pErrRec);
	}
	if (!pRemoveView)
		return iesNoAction;

	pErrRec = pRemoveView->Execute(0);
	if (pErrRec)
		return riEngine.FatalError(*pErrRec);

	Bool fSuppressLFN = riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;
	PMsiRecord pRecParams = &pServices->CreateRecord(6);

	// If we're removing files we will pass through the RemoveFile table twice - first to compile the
	// total cost, then to execute the remove actions

	// If we're removing folders we'll pass through the RemoveFile table once, setting the
	// _Path column of each folder we're to remove. We'll then call RemoveForeignFoldersCore to
	// do the work of removing the folders.

	unsigned int iFileOrFolderCount = 0;
	Bool fCompile = fTrue;
	MsiString strDestPath;
	MsiString strDestProperty;
	int iTotalPasses = fFolders ? 1 : 2;
	for (;iTotalPasses > 0;iTotalPasses--)
	{
		for(;;)
		{
			PMsiRecord pFileOrFolderRec(pRemoveView->Fetch());
			if (!pFileOrFolderRec)
				break;

			iisEnum iisAction = (iisEnum) pFileOrFolderRec->GetInteger(irffAction);
			int iMode = pFileOrFolderRec->GetInteger(irffInstallMode);
			if (iMode == iMsiNullInteger)
				iMode = msidbRemoveFileInstallModeOnInstall;
			if (iMode & msidbRemoveFileInstallModeOnInstall && (iisAction == iisLocal || iisAction == iisSource) ||
				(iMode & msidbRemoveFileInstallModeOnRemove && iisAction == iisAbsent))
			{
				if (fFolders)
				{
					PMsiPath pPath(0);
					strDestProperty = pFileOrFolderRec->GetMsiString(irffDirProperty);

					if ((pErrRec = pDirectoryMgr->GetTargetPath(*strDestProperty, *&pPath)) != 0)
					{
						strDestPath = riEngine.GetProperty(*strDestProperty);

						if (strDestPath.TextSize())
						{
							if ((pErrRec = pServices->CreatePath(strDestPath, *&pPath)) != 0)
								return riEngine.FatalError(*pErrRec);
						}
					}
					
					if (pPath != 0)
					{
						iFileOrFolderCount++;
					
						AssertNonZero(pFileOrFolderRec->SetMsiData(irffFileNameOrPath, (const IMsiData*)(IMsiPath*)pPath));

						if ((pErrRec = pRemoveView->Modify(*pFileOrFolderRec, irmUpdate)) != 0)
							return riEngine.FatalError(*pErrRec);
					}
				}
				else // !fFolders
				{
					// Get target path object
					if (!strDestProperty.Compare(iscExact, pFileOrFolderRec->GetString(irffDirProperty)))
					{
						strDestProperty = pFileOrFolderRec->GetMsiString(irffDirProperty);
						strDestPath = riEngine.GetProperty(*strDestProperty);
						if (!fCompile && strDestPath.TextSize())
						{
							pRecParams->ClearData();
							pRecParams->SetMsiString(IxoSetTargetFolder::Folder,*strDestPath);
							if ((iesExecute = riEngine.ExecuteRecord(ixoSetTargetFolder, *pRecParams)) != iesSuccess)
								return iesExecute;
						}
					}

					// We'll find and delete every file that matches the wildcard filename
					// (which can include * and ? wildcards).
					if (!strDestPath.TextSize())
						continue;

					PMsiPath pDestPath(0);
 					pErrRec = pServices->CreatePath(strDestPath, *&pDestPath);
					if (pErrRec)
						return riEngine.FatalError(*pErrRec);

					Bool fLFN = ((riEngine.GetMode() & iefSuppressLFN) == fFalse && pDestPath->SupportsLFN()) ? fTrue : fFalse;
					MsiString strWildcardName;
					MsiString strWildcardNamePair = pFileOrFolderRec->GetMsiString(irffFileNameOrPath);
					pErrRec = ExtractUnvalidatedFileName(strWildcardNamePair,fLFN,*&strWildcardName);
					if (pErrRec)
						return riEngine.FatalError(*pErrRec);

					MsiString strFullFilePath(pDestPath->GetPath());
					strFullFilePath += strWildcardName;
					Bool fNextFile = fFalse;
					WIN32_FIND_DATA fdFileData;
					HANDLE hFindFile = FindFirstFile(strFullFilePath,&fdFileData);
					if (hFindFile == INVALID_HANDLE_VALUE)
						continue;

					do
					{
						// Make sure we haven't located a directory
						if ((fdFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
						{
							if (fCompile)
							{
								iFileOrFolderCount++;
							}
							else
							{
								pRecParams->ClearData();
								pRecParams->SetString(FileName,fdFileData.cFileName);
								if ((iesExecute = riEngine.ExecuteRecord(ixoFileRemove, *pRecParams)) != iesSuccess)
									return iesExecute;
							}
						}
						fNextFile = FindNextFile(hFindFile,&fdFileData) ? fTrue : fFalse;
						if (!fNextFile)
							AssertNonZero(FindClose(hFindFile));
					}while (fNextFile);
				}
			}
		} 
		
		if (iFileOrFolderCount == 0)
		{
			// we have no files/folders ... abort
			iTotalPasses = 0;
			break;
		}

		if (fFolders || fCompile)
		{
			pRecParams->ClearData();
			pRecParams->SetInteger(IxoProgressTotal::Total, iFileOrFolderCount);
			pRecParams->SetInteger(IxoProgressTotal::Type, 1);
			pRecParams->SetInteger(IxoProgressTotal::ByteEquivalent, ibeRemoveFiles);
			if ((iesExecute = riEngine.ExecuteRecord(ixoProgressTotal, *pRecParams)) != iesSuccess)
				return iesExecute;
		}

		if (fFolders)
		{
			DEBUGMSG1(TEXT("Counted %d foreign folders to be removed."), (const ICHAR*)(INT_PTR)iFileOrFolderCount);
			return RemoveForeignFoldersCore(riEngine, *pRemoveFileTable, 0);
		}
		else if (fCompile)
		{
			// Re-execute the query for the execution phase
			strDestProperty = TEXT("");
			fCompile = fFalse;
			pRemoveView->Close();
			pErrRec = pRemoveView->Execute(0);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
		}// Next pass
	}

	return iesSuccess;
}


iesEnum RemoveFiles(IMsiEngine& riEngine)
{
	// If none of the install bits involving files are set,
	// this action doesn't need to do anything.
	if (!IsFileActivityEnabled(riEngine))
		return iesSuccess;

	iesEnum iesForeignResult = RemoveForeignFilesOrFolders(riEngine, /*fFolders = */ fFalse);
	Bool fSuppressLFN = riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;

	iesEnum iesExecute = iesSuccess;
	PMsiRecord pErrRec(0);
	PMsiView pRemoveView(0);
	PMsiServices pServices(riEngine.GetServices());
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	
	// Determine the total count of all files to delete, and
	// set up the progress bar accordingly.
	unsigned int uiFileCount = 0;
	CMsiFileRemove objFile(riEngine);
	
	pErrRec = objFile.TotalFilesToDelete(uiFileCount);
	if (pErrRec)
	{
		// If file table is missing, not an error - just no
		// installed files to remove
		if (pErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pErrRec);
	}

	if (iesForeignResult != iesSuccess && iesForeignResult != iesNoAction) // !! this wasn't the previous behavior; previously we'd ignore the foreign result if there were implicit removals to be done
		return iesForeignResult; 

	if (uiFileCount != 0)
	{
		PMsiRecord pRecParams = &pServices->CreateRecord(6);
		pRecParams->ClearData();
		pRecParams->SetInteger(IxoProgressTotal::Total, uiFileCount);
		pRecParams->SetInteger(IxoProgressTotal::Type, 1); // 1: use ActionData as progress
		pRecParams->SetInteger(IxoProgressTotal::ByteEquivalent, ibeRemoveFiles);
		if ((iesExecute = riEngine.ExecuteRecord(ixoProgressTotal, *pRecParams)) != iesSuccess)
			return iesExecute;

		MsiString strDestProperty;
		PMsiPath pDestPath(0);

		// Remove installed files
		using namespace IxoFileRemove;
		for(;;)
		{
			PMsiRecord pDeleteRec(0);
			pErrRec = objFile.FetchFile(*&pDeleteRec);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
				
			if (!pDeleteRec)
				break;


			// cache current destination for performance
			if (!strDestProperty.Compare(iscExact, pDeleteRec->GetString(CMsiFileRemove::ifqrDirectory)))
			{
				strDestProperty = pDeleteRec->GetMsiString(CMsiFileRemove::ifqrDirectory);
				pErrRec = pDirectoryMgr->GetTargetPath(*strDestProperty,*&pDestPath);
				if (pErrRec)
					return riEngine.FatalError(*pErrRec);
				if (pDestPath == 0)
				{
					pErrRec = PostError(Imsg(idbgNoProperty),*strDestProperty);
					return riEngine.FatalError(*pErrRec);
				}
				MsiString strDestPath = pDestPath->GetPath();
				pRecParams->ClearData();
				pRecParams->SetMsiString(IxoSetTargetFolder::Folder,*strDestPath);
				if ((iesExecute = riEngine.ExecuteRecord(ixoSetTargetFolder, *pRecParams)) != iesSuccess)
					return iesExecute;
			}

			MsiString strFileName;
			if((pErrRec = objFile.GetExtractedTargetFileName(*pDestPath,*&strFileName)) != 0)
				return riEngine.FatalError(*pErrRec);
			AssertNonZero(pDeleteRec->SetMsiString(CMsiFileRemove::ifqrFileName,*strFileName));
			
			pRecParams->ClearData();
			pRecParams->SetString(FileName,strFileName);
			pRecParams->SetMsiString(ComponentId,*MsiString(pDeleteRec->GetMsiString(CMsiFileRemove::ifqrComponentId)));
			if ((iesExecute = riEngine.ExecuteRecord(ixoFileRemove, *pRecParams)) != iesSuccess)
				return iesExecute;
		}
	}

	if (iesExecute != iesSuccess && iesExecute != iesNoAction)
		return iesExecute; 

	return RemoveForeignFilesOrFolders(riEngine, /*fFolders = */ fTrue);
}



/*---------------------------------------------------------------------------
	MoveFiles costing/action
---------------------------------------------------------------------------*/
class CMsiMoveFileCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);
public:  // constructor
	CMsiMoveFileCost(IMsiEngine& riEngine);
protected:
	~CMsiMoveFileCost();
private:
	enum imfEnum
	{
		imfSourceName = 1,
		imfDestName,
		imfSourceProperty,
		imfDestProperty,
		imfOptions,
		imfNextEnum
	};
};
CMsiMoveFileCost::CMsiMoveFileCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine){}
CMsiMoveFileCost::~CMsiMoveFileCost(){}

static const ICHAR sqlInitMoveFiles[] =
	TEXT("SELECT `Component_`,`SourceFolder`,`DestFolder` FROM `MoveFile`");


IMsiRecord* CMsiMoveFileCost::Initialize()
//----------------------------------------
{
	enum imfInitEnum
	{
		imfInitComponent = 1,
		imfInitSourceFolder,
		imfInitDestFolder,
		imfInitNextEnum
	};
	PMsiView pMoveView(0);
	IMsiRecord* piErrRec = m_riEngine.OpenView(sqlInitMoveFiles, ivcFetch, *&pMoveView);
	if (piErrRec)
	{
		if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return piErrRec;
		else
		{
			piErrRec->Release();
			return 0;
		}
	}

	if ((piErrRec = pMoveView->Execute(0)) != 0)
		return piErrRec;

	for(;;)
	{
		PMsiRecord pMoveRec(pMoveView->Fetch());
		if (!pMoveRec)
			break;

		MsiString strComponent(pMoveRec->GetMsiString(imfInitComponent));
		MsiString strSourceFolder(pMoveRec->GetMsiString(imfInitSourceFolder));
		MsiString strDestFolder(pMoveRec->GetMsiString(imfInitDestFolder));
		PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
		piErrRec = pSelectionMgr->RegisterComponentDirectory(*strComponent,*strSourceFolder);
		if (piErrRec)
			return piErrRec;
		piErrRec = pSelectionMgr->RegisterComponentDirectory(*strComponent,*strDestFolder);
		if (piErrRec)
			return piErrRec;
	}
	return 0;
}


static const ICHAR sqlMoveFileCost[] =
	TEXT("SELECT `SourceName`,`DestName`,`SourceFolder`,`DestFolder`,`Options` FROM `MoveFile` WHERE `Component_`=?");

IMsiRecord* CMsiMoveFileCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
//------------------------------------------
{
	enum imfcEnum
	{
		imfcSourceName = 1,
		imfcDestName,
		imfcSourceFolder,
		imfcDestFolder,
		imfcOptions,
		imfcNextEnum
	};
	
	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;
	if (!IsFileActivityEnabled(m_riEngine))
		return 0;
	

	IMsiRecord* piErrRec;
	if (!m_pCostView)
	{
		piErrRec = m_riEngine.OpenView(sqlMoveFileCost, ivcFetch, *&m_pCostView);
		if (piErrRec)
			return piErrRec;
	}
	else
		m_pCostView->Close();

	PMsiServices pServices(m_riEngine.GetServices());
	PMsiRecord pExecRecord(&pServices->CreateRecord(1));
	pExecRecord->SetMsiString(1, riComponentString);
	if ((piErrRec = m_pCostView->Execute(pExecRecord)) != 0)
		return piErrRec;

	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);

	for(;;)
	{
		PMsiRecord pFileRec(m_pCostView->Fetch());
		if (!pFileRec)
			break;

		Bool fCostSource = fFalse;
		Bool fCostDest = fFalse;
		MsiString strSourceFolder(pFileRec->GetMsiString(imfcSourceFolder));
		if (riDirectoryString.Compare(iscExact,strSourceFolder))
			fCostSource = fTrue;

		MsiString strDestFolder(pFileRec->GetMsiString(imfcDestFolder));
		if (riDirectoryString.Compare(iscExact,strDestFolder))
			fCostDest = fTrue;

		if (fCostSource == fFalse && fCostDest == fFalse)
			continue;

		// Get source and target path objects - if either are undefined, there's
		// no work to do, so go on to the next record.
		Bool fSuppressLFN = m_riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;
		PMsiPath pSourcePath(0);
		MsiString strSourcePath(m_riEngine.GetProperty(*strSourceFolder));
		if (strSourcePath.TextSize() == 0)
			continue;

		piErrRec = pServices->CreatePath(strSourcePath,*&pSourcePath);
		if (piErrRec)
			return piErrRec;

		PMsiPath pDestPath(0);
		piErrRec = pDirectoryMgr->GetTargetPath(*strDestFolder,*&pDestPath);
		if (piErrRec)
		{
			if (piErrRec->GetInteger(1) == idbgDirPropertyUndefined)
			{
				piErrRec->Release();
				continue;
			}
			else
				return piErrRec;
		}

		// Get source filename
		MsiString strSourceName(pFileRec->GetMsiString(imfcSourceName));
		if (strSourceName.TextSize() == 0)
		{
			strSourceName = pSourcePath->GetEndSubPath();
			pSourcePath->ChopPiece();
		}

		// We'll find and cost every file that matches the source name
		// (which can include * and ? wildcards).
		Bool fNextFile = fFalse;
		Bool fFindFirst = fTrue;
		MsiString strFullFilePath(pSourcePath->GetPath());
		strFullFilePath += strSourceName;
		WIN32_FIND_DATA fdFileData;
		HANDLE hFindFile = FindFirstFile(strFullFilePath,&fdFileData);
		if (hFindFile == INVALID_HANDLE_VALUE)
			continue;

		do
		{
			// Make sure we haven't located a directory
			if ((fdFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
			{
				strSourceName = fdFileData.cFileName;
				MsiString strDestName(pFileRec->GetMsiString(imfcDestName));
				if (!fFindFirst || strDestName.TextSize() == 0)
					strDestName = strSourceName;
				else
				{
					MsiString strDestNamePair = strDestName;
					Bool fLFN = ((m_riEngine.GetMode() & iefSuppressLFN) == 0 && pDestPath->SupportsLFN()) ? fTrue : fFalse;
					piErrRec = pServices->ExtractFileName(strDestNamePair,fLFN,*&strDestName);
					if (piErrRec)
						return piErrRec;
				}

				MsiString strVersion;
				MsiString strLanguage;
				piErrRec = pSourcePath->GetFileVersionString(strSourceName, *&strVersion);
				if (piErrRec)
				{
					if (piErrRec->GetInteger(1) == imsgSharingViolation)
					{
						// Couldn't get the version of the source file.  We'll have to 
						// assume the file is unversioned.
						piErrRec->Release();
						piErrRec = 0;
					}
					else
						return piErrRec;
				}
				else
				{
					piErrRec = pSourcePath->GetLangIDStringFromFile(strSourceName,*&strLanguage);
					if (piErrRec)
						return piErrRec;
				}

				int fInstallModeFlags = GetInstallModeFlags(m_riEngine,0);
				unsigned int uiExistingClusteredSize;
				Bool fInUse;
				ifsEnum ifsState;
				Bool fShouldInstall = fFalse;
				if ((piErrRec = pDestPath->GetFileInstallState(*strDestName,*strVersion,*strLanguage,
																			  /* pHash=*/ 0, ifsState,fShouldInstall,
																			  &uiExistingClusteredSize,&fInUse,fInstallModeFlags,
																			  NULL)) != 0)
					return piErrRec;

				int iMoveOptions = pFileRec->GetInteger(imfOptions);
				if (fCostDest && fShouldInstall)
				{
					Assert(fdFileData.nFileSizeHigh == 0);
					unsigned int uiNewClusteredSize;
					if ((piErrRec = pDestPath->ClusteredFileSize(fdFileData.nFileSizeLow, uiNewClusteredSize)) != 0)
						return piErrRec;
					iLocalCost += uiNewClusteredSize;
					iSourceCost += uiNewClusteredSize;
					iARPLocalCost += uiNewClusteredSize;
					iNoRbLocalCost += uiNewClusteredSize;
					iNoRbSourceCost += uiNewClusteredSize;
					iNoRbARPLocalCost += uiNewClusteredSize;
					if (!fInUse)
					{
						iNoRbLocalCost -= uiExistingClusteredSize;
						iNoRbSourceCost -= uiExistingClusteredSize;
						iNoRbARPLocalCost -= uiExistingClusteredSize;
					}
				
					if(iMoveOptions & msidbMoveFileOptionsMove)
					{
						Assert(fdFileData.nFileSizeHigh == 0);
						unsigned int uiSourceClusteredSize;
						if ((piErrRec = pSourcePath->ClusteredFileSize(fdFileData.nFileSizeLow, uiSourceClusteredSize)) != 0)
							return piErrRec;
						iLocalCost -= uiSourceClusteredSize;
						iNoRbLocalCost -= uiSourceClusteredSize;
						iSourceCost -= uiSourceClusteredSize;
						iNoRbSourceCost -= uiSourceClusteredSize;
						iARPLocalCost -= uiSourceClusteredSize;
						iNoRbARPLocalCost -= uiSourceClusteredSize;
					}

					// file in use
					if(fAddFileInUse && fInUse)
					{
						piErrRec = PlaceFileOnInUseList(m_riEngine, *strDestName,
																  *MsiString(pDestPath->GetPath()));
						if(piErrRec)
							return piErrRec;
					}
				}
			}
			fNextFile = FindNextFile(hFindFile,&fdFileData) ? fTrue : fFalse;
			if (!fNextFile)
				AssertNonZero(FindClose(hFindFile));
			fFindFirst = fFalse;
		}while (fNextFile);
	} 

	return 0;
}



const ICHAR sqlMoveFiles[] =
TEXT("SELECT `SourceName`,`DestName`,`SourceFolder`,`DestFolder`,`Options`,`Action` FROM `MoveFile`,`Component` WHERE `Component`=`Component_`");

enum imfEnum
{
	imfSourceName = 1,
	imfDestName,
	imfSourceFolder,
	imfDestFolder,
	imfOptions,
	imfAction,
	imfNextEnum
};

iesEnum MoveFiles(IMsiEngine& riEngine)
{
	
	if (!IsFileActivityEnabled(riEngine))
		return iesSuccess;

	iesEnum iesExecute;
	PMsiRecord pErrRec(0);
	PMsiServices pServices(riEngine.GetServices());

	// Open the MoveFile table, if present. This table is optional, so its
	// absence is not an error.
	PMsiView pMoveView(0);
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	if (pDatabase->FindTable(*MsiString(sztblMoveFile)) != itsUnknown)
	{
		pErrRec = riEngine.OpenView(sqlMoveFiles, ivcFetch, *&pMoveView);
		if (pErrRec)
			return riEngine.FatalError(*pErrRec);
	}
	if (!pMoveView)
		return iesSuccess;

	pErrRec = pMoveView->Execute(0);
	if (pErrRec)
		return riEngine.FatalError(*pErrRec);

	// We found the MoveFile table. Prepare for the move!
	Bool fSuppressLFN = riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;
	PMsiRecord pRecParams = &pServices->CreateRecord(IxoFileCopy::Args);

	// We will pass through the MoveFile table twice - first to compile the
	// total cost, then to execute the move actions
	unsigned int cbTotalCost = 0;
	unsigned int cbPerTick = 0;
	Bool fCompile = fTrue;
	for (int iTotalPasses = 2;iTotalPasses > 0;iTotalPasses--)
	{
		for(;;)
		{
			PMsiRecord pFileRec(pMoveView->Fetch());
			if (!pFileRec)
				break;

			iisEnum iisAction = (iisEnum) pFileRec->GetInteger(imfAction);
			if (iisAction != iisLocal && iisAction != iisSource)
				continue;

			// Get source and target path objects - if either are undefined,
			// do nothing, just go on to the next record.
			PMsiPath pSourcePath(0);
			MsiString strSourceFolder(pFileRec->GetMsiString(imfSourceFolder));
			MsiString strSourcePath(riEngine.GetProperty(*strSourceFolder));
			if (strSourcePath.TextSize() == 0)
				continue;

			pErrRec = pServices->CreatePath(strSourcePath,*&pSourcePath);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);

			PMsiPath pDestPath(0);
			MsiString strDestFolder(pFileRec->GetMsiString(imfDestFolder));
			pErrRec = pDirectoryMgr->GetTargetPath(*strDestFolder,*&pDestPath);
			if (pErrRec)
			{
				// If destination dir property was never defined, just go on.
				if (pErrRec->GetInteger(1) == idbgDirPropertyUndefined)
				{
					pErrRec = 0;
					continue;
				}
				else
				{
					return riEngine.FatalError(*pErrRec);
				}
			}

			// Source source filename
			MsiString strSourceName(pFileRec->GetString(imfSourceName));
			if (strSourceName.TextSize() == 0)
			{
				strSourceName = pSourcePath->GetEndSubPath();
				pSourcePath->ChopPiece();
			}

			Bool fMoveAcrossVolumes = (PMsiVolume(&pSourcePath->GetVolume()) == 
				                       PMsiVolume(&pDestPath->GetVolume())) ? fFalse : fTrue;

			// We'll find and move/copy every file that matches the source name
			// (which can include * and ? wildcards).
			Bool fNextFile = fFalse;
			Bool fFindFirst = fTrue;
			MsiString strFullFilePath(pSourcePath->GetPath());
			strFullFilePath += strSourceName;
			WIN32_FIND_DATA fdFileData;
			HANDLE hFindFile = FindFirstFile(strFullFilePath,&fdFileData);
			if (hFindFile == INVALID_HANDLE_VALUE)
				continue;

			do
			{
				// Make sure we haven't located a directory
				if ((fdFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
				{
					Assert(fdFileData.nFileSizeHigh == 0);
					unsigned int uiFileSize = fdFileData.nFileSizeLow;
					if (fCompile)
					{
						cbTotalCost += uiFileSize;
					}
					else
					{
						int iMoveOptions = pFileRec->GetInteger(imfOptions);

						// Set up the source name
						strSourceName = fdFileData.cFileName;

						// Set up the destination name
						MsiString strDestName(pFileRec->GetString(imfDestName));
						if (!fFindFirst || strDestName.TextSize() == 0)
							strDestName = strSourceName;
						else
						{
							MsiString strDestNamePair = strDestName;
							Bool fLFN = ((riEngine.GetMode() & iefSuppressLFN) == 0 && pDestPath->SupportsLFN()) ? fTrue : fFalse;
							pErrRec = pServices->ExtractFileName(strDestNamePair,fLFN,*&strDestName);
							if (pErrRec)
								return riEngine.FatalError(*pErrRec);
						}

						// Set up the ixoFileCopy source folder
						pRecParams->ClearData();
						pRecParams->SetMsiString(IxoSetSourceFolder::Folder,*MsiString(pSourcePath->GetPath()));
						if ((iesExecute = riEngine.ExecuteRecord(ixoSetSourceFolder, *pRecParams)) != iesSuccess)
							return iesExecute;

						pRecParams->ClearData();
						pRecParams->SetMsiString(IxoSetTargetFolder::Folder,*MsiString(pDestPath->GetPath()));
						if ((iesExecute = riEngine.ExecuteRecord(ixoSetTargetFolder, *pRecParams)) != iesSuccess)
							return iesExecute;

						// Set up the ixoFileCopy record
						using namespace IxoFileCopy;
						int iAttributes = fdFileData.dwFileAttributes;

						if(iAttributes == FILE_ATTRIBUTE_NORMAL)
							// set to 0, this value is interpreted as something else by CMsiFileCopy::CopyTo
							iAttributes = 0;
						
						MsiString strVersion;
						MsiString strLanguage;
						pErrRec = pSourcePath->GetFileVersionString(strSourceName, *&strVersion);
						if (pErrRec)
						{
							// If the source file is in-use, we'll have to assume it's unversioned
							// and move on (if it's still in-use at file copy time, we'll put up an
							// error/retry message then).
							if (pErrRec->GetInteger(1) != imsgSharingViolation)
								return riEngine.FatalError(*pErrRec);
						}
						else
						{
							pErrRec = pSourcePath->GetLangIDStringFromFile(strSourceName, *&strLanguage);
							if (pErrRec)
								return riEngine.FatalError(*pErrRec);
						}

						pRecParams->ClearData();
						pRecParams->SetString(SourceName,strSourceName);
						pRecParams->SetString(DestName,strDestName);
						pRecParams->SetInteger(Attributes,iAttributes &~ msidbFileAttributesPatchAdded); // remove PatchAdded bit for MoveFiles
						pRecParams->SetInteger(FileSize,uiFileSize);
						pRecParams->SetString(Version,strVersion);
						pRecParams->SetString(Language,strLanguage);
						pRecParams->SetInteger(InstallMode, icmOverwriteOlderVersions | ((iMoveOptions & msidbMoveFileOptionsMove) ? icmRemoveSource : 0));
						pRecParams->SetInteger(PerTick,cbPerTick); 
						pRecParams->SetInteger(IsCompressed, 0); // always uncompressed
						pRecParams->SetInteger(VerifyMedia, fFalse);

						if ((iesExecute = riEngine.ExecuteRecord(ixoFileCopy, *pRecParams)) != iesSuccess)
							return iesExecute;
					}
				}
				fNextFile = FindNextFile(hFindFile,&fdFileData) ? fTrue : fFalse;
				if (!fNextFile)
					AssertNonZero(FindClose(hFindFile));
				fFindFirst = fFalse;
			}while (fNextFile);
		} 
		// Re-execute the query for the execution phase
		if (fCompile)
		{
			fCompile = fFalse;
			pMoveView->Close();
			pErrRec = pMoveView->Execute(0);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
			if(cbTotalCost)
			{
				cbPerTick = iBytesPerTick;
				pRecParams->ClearData();
				pRecParams->SetInteger(IxoProgressTotal::Total, cbTotalCost);
				pRecParams->SetInteger(IxoProgressTotal::Type, 0); // 0: separate progress and action data messages
				pRecParams->SetInteger(IxoProgressTotal::ByteEquivalent, 1);
				if ((iesExecute = riEngine.ExecuteRecord(ixoProgressTotal, *pRecParams)) != iesSuccess)
					return iesExecute;
			}
		}// Next pass
	}

	return iesSuccess;
}


/*---------------------------------------------------------------------------
	DuplicateFiles costing/action
---------------------------------------------------------------------------*/
class CMsiDuplicateFileCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);
public:  // constructor
	CMsiDuplicateFileCost(IMsiEngine& riEngine);
protected:
	~CMsiDuplicateFileCost();
private:
};
CMsiDuplicateFileCost::CMsiDuplicateFileCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine){}
CMsiDuplicateFileCost::~CMsiDuplicateFileCost(){}

static const ICHAR sqlInitDupFiles[] =
	TEXT("SELECT `DuplicateFile`.`Component_`,`File`.`Component_`,`DestFolder` FROM `DuplicateFile`,`File` WHERE `File_`=`File`");

static const ICHAR sqlInitDupNullDest[] =
	TEXT("SELECT `Directory_` FROM `Component` WHERE `Component`=?");

IMsiRecord* CMsiDuplicateFileCost::Initialize()
//-------------------------------------------
{

	enum idfInitEnum
	{
		idfInitComponent = 1,
		idfInitFileComponent,
		idfInitDestFolder,
		idfInitNextEnum
	};
	PMsiView pView(0);
	IMsiRecord* piErrRec = m_riEngine.OpenView(sqlInitDupFiles, ivcFetch, *&pView);
	if (piErrRec)
	{
		if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return piErrRec;
		else
		{
			piErrRec->Release();
			return 0;
		}
	}

	if ((piErrRec = pView->Execute(0)) != 0)
		return piErrRec;

	PMsiView pCompView(0);
	piErrRec = m_riEngine.OpenView(sqlInitDupNullDest, ivcFetch, *&pCompView);
	if (piErrRec)
	{
		if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return piErrRec;
		else
		{
			piErrRec->Release();
			return 0;
		}
	}

	PMsiRecord pCompRec(0);

	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	for(;;)
	{
		PMsiRecord pRec(pView->Fetch());
		if (!pRec)
			break;
		
		// close component view so we can re-execute to find directory of this duplicate file's component
		pCompView->Close();
		if ((piErrRec = pCompView->Execute(pRec)) != 0)
			return piErrRec;
		pCompRec = pCompView->Fetch();
		if (!pCompRec)
			break;

		MsiString strComponent(pRec->GetMsiString(idfInitComponent));
		MsiString strFileComponent(pRec->GetMsiString(idfInitFileComponent));
		MsiString strDestFolder(pRec->GetMsiString(idfInitDestFolder));
		// NULL destFolder is allowed -- in this case goes as dir of component
		//  specified in DuplicateFile table Component column
		if (strDestFolder.TextSize() == 0)
		{
			strDestFolder = pCompRec->GetMsiString(1);
		}
		piErrRec = pSelectionMgr->RegisterComponentDirectory(*strComponent,*strDestFolder);
		if (piErrRec)
			return piErrRec;

		if (strComponent.Compare(iscExact,strFileComponent) == 0)
		{
			piErrRec = pSelectionMgr->RegisterCostLinkedComponent(*strFileComponent,*strComponent);
			if (piErrRec)
				return piErrRec;
		}

	}
	return 0;
}

static const ICHAR sqlCostDupFiles[] =
	TEXT("SELECT `File_`,`DestName`,`DestFolder`,`Directory_`,`Action`,`Installed` FROM `DuplicateFile`,`Component` WHERE `Component`=`Component_` ")
	TEXT("AND `Component_`=?");

IMsiRecord* CMsiDuplicateFileCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
//-----------------------------------------------
{
	enum idfEnum
	{
		idfFileKey = 1,
		idfDestName,
		idfDestFolder,
		idfComponentDestFolder,
		idfAction,
		idfInstalled,
		idfNextEnum
	};

	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;
	if (!IsFileActivityEnabled(m_riEngine))
		return 0;
	
	// DuplicateFile cost adjuster will never get registered
	// and called unless the DuplicateFile table is present.
	IMsiRecord* piErrRec;
	if (!m_pCostView)
	{
		piErrRec = m_riEngine.OpenView(sqlCostDupFiles, ivcFetch, *&m_pCostView);
		if (piErrRec)
			return piErrRec;
	}
	else
		m_pCostView->Close();

	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	PMsiServices pServices(m_riEngine.GetServices());
	PMsiRecord pExecRec(&pServices->CreateRecord(2));
	pExecRec->SetMsiString(1, riComponentString);
	pExecRec->SetMsiString(2, riDirectoryString);
	if ((piErrRec = m_pCostView->Execute(pExecRec)) != 0)
		return piErrRec;

	for(;;)
	{
		PMsiRecord pDupRec(m_pCostView->Fetch());
		if (!pDupRec)
			break;

		// Our source file is a File Table entry
		MsiString strFileKey(pDupRec->GetMsiString(idfFileKey));
		CMsiFile objSourceFile(m_riEngine);
		piErrRec = objSourceFile.FetchFile(*strFileKey);
		if (piErrRec)
			return piErrRec;

		// If our source file is not installed, and isn't going to
		// be installed, then we can't duplicate it.
		PMsiRecord pSourceRec(objSourceFile.GetFileRecord());
		if (!pSourceRec)
			return PostError(Imsg(idbgFileTableEmpty));

		iisEnum iisSourceAction = (iisEnum) pSourceRec->GetInteger(CMsiFile::ifqAction);
		iisEnum iisSourceInstalled = (iisEnum) pSourceRec->GetInteger(CMsiFile::ifqInstalled);
		if (iisSourceAction == iisLocal || (iisSourceAction == iMsiNullInteger && iisSourceInstalled == iisLocal))
		{
			// Determine our source path
			PMsiPath pSourcePath(0);
			piErrRec = objSourceFile.GetTargetPath(*&pSourcePath);
			if (piErrRec)
				return piErrRec;
			
			// Determine our destination path
			MsiString strDestFolder(pDupRec->GetMsiString(idfDestFolder));
			if (strDestFolder.TextSize() == 0)
				strDestFolder = pDupRec->GetMsiString(idfComponentDestFolder);
			if (0 == riDirectoryString.Compare(iscExact,strDestFolder))
				continue;
			PMsiPath pDestPath(0);
			piErrRec = pDirectoryMgr->GetTargetPath(*strDestFolder,*&pDestPath);
			if (piErrRec)
					return piErrRec;

			// get source file name and put back in pSourceRec
			MsiString strSourceName;
			if((piErrRec = objSourceFile.GetExtractedTargetFileName(*pSourcePath,*&strSourceName)) != 0)
				return piErrRec;
			AssertNonZero(pSourceRec->SetMsiString(CMsiFile::ifqFileName,*strSourceName));

			// If our source file is not going to overwrite the existing file (if any), then the
			// existing file's size becomes the size of our source file.
			ifsEnum ifsState;
			piErrRec = GetFileInstallState(m_riEngine, *pSourceRec, /* piCompanionFileRec=*/ 0,0,0,
				&ifsState, /* fIgnoreCompanionParentAction=*/ false, /* fIncludeHashCheck=*/ false, NULL);
			if (piErrRec)
				return piErrRec;

			// Ok, if our source file isn't already present, AND it isn't going to be installed
			// (according to GetFileInstallState), we can't duplicate it.
			if (ifsState == ifsAbsent && pSourceRec->GetInteger(CMsiFile::ifqState) == fFalse)
				continue;

			unsigned int uiSourceFileSize;
			piErrRec = GetFinalFileSize(m_riEngine, *pSourceRec, uiSourceFileSize);
			if (piErrRec)
				return piErrRec;
			
			// Now we must check the install state of our potentially duplicated file;
			// we can do this by modifying the appropriate fields in pSourceRec and
			// then calling GetFileInstallState again.
			MsiString strDestNamePair = pDupRec->GetString(idfDestName);
			MsiString strDestName;
			if (strDestNamePair.TextSize())
			{
				Bool fLFN = ((m_riEngine.GetMode() & iefSuppressLFN) == 0 && pDestPath->SupportsLFN()) ? fTrue : fFalse;
				if((piErrRec = pServices->ExtractFileName(strDestNamePair,fLFN,*&strDestName)) != 0)
					return piErrRec;
				AssertNonZero(pSourceRec->SetMsiString(CMsiFile::ifqFileName,*strDestName));
			}
			else
				strDestName = strSourceName;

			// check to see if we are a noop -- duplicating same file to same directory
			MsiString strFileDir = pSourceRec->GetString(CMsiFile::ifqDirectory);
			if (strSourceName.Compare(iscExact, strDestName) && strFileDir.Compare(iscExact, strDestFolder))
			{
				// duplicateFile.Filename = sourceFile.Filename
				// duplicateFile.Dest = sourceFile.Directory
				// noop
				continue;
			}

			pSourceRec->SetMsiString(CMsiFile::ifqDirectory,*strDestFolder);

			Bool fInUse;
			unsigned int uiExistingDestClusteredSize;
			piErrRec = GetFileInstallState(m_riEngine, *pSourceRec, /* piCompanionFileRec=*/ 0, 
				                           &uiExistingDestClusteredSize,&fInUse,0,
													/* fIgnoreCompanionParentAction=*/ false,
													/* fIncludeHashCheck=*/ false, NULL);
			if (piErrRec)
				return piErrRec;

			// iisAbsent costs
			iNoRbRemoveCost -= uiExistingDestClusteredSize;

			// iisSource costs
			if (pDupRec->GetInteger(idfInstalled) == iisLocal)
				iNoRbSourceCost -= uiExistingDestClusteredSize;

			// iisLocal costs
			if (pSourceRec->GetInteger(CMsiFile::ifqState) == fTrue)
			{
				unsigned int uiDestClusteredSize;
				if ((piErrRec = pDestPath->ClusteredFileSize(uiSourceFileSize, uiDestClusteredSize)) != 0)
					return piErrRec;
				iLocalCost += uiDestClusteredSize;
				iNoRbLocalCost += uiDestClusteredSize;
				iARPLocalCost += uiDestClusteredSize;
				iNoRbARPLocalCost += uiDestClusteredSize;
				if (!fInUse)
				{
					iNoRbLocalCost -= uiExistingDestClusteredSize;
					iNoRbARPLocalCost -= uiExistingDestClusteredSize;
				}
			}

			// file in use
			if(fAddFileInUse && fInUse && iisSourceAction == iisLocal) //!! check remove?????????
			{
				piErrRec = PlaceFileOnInUseList(m_riEngine, *strDestName,
														  *MsiString(pDestPath->GetPath()));
				if(piErrRec)
					return piErrRec;
			}
		}
	}
	return 0;
}



iesEnum DuplicateFiles(IMsiEngine& riEngine)
{
	if (!IsFileActivityEnabled(riEngine))
		return iesSuccess;

	const ICHAR sqlDupFiles[] =
	TEXT("SELECT `File_`,`DestName`,`DestFolder`,`Action`,`Directory_` FROM `DuplicateFile`,`Component` WHERE `Component`=`Component_`");

	enum idfEnum
	{
		idfFileKey = 1,
		idfDestName,
		idfDestFolder,
		idfAction,
		idfComponentDestFolder,
		idfNextEnum
	};

	iesEnum iesExecute;
	PMsiRecord pErrRec(0);
	PMsiServices pServices(riEngine.GetServices());

	// Open the DuplicateFile table, if present. This table is optional, so its
	// absence is not an error.
	PMsiView pView(0);
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	if (pDatabase->FindTable(*MsiString(*sztblDuplicateFile)) != itsUnknown)
	{
		pErrRec = riEngine.OpenView(sqlDupFiles, ivcFetch, *&pView);
		if (pErrRec)
			return riEngine.FatalError(*pErrRec);
	}
	if (!pView)
		return iesSuccess;

	pErrRec = pView->Execute(0);
	if (pErrRec)
		return riEngine.FatalError(*pErrRec);

	PMsiRecord pRecParams = &pServices->CreateRecord(IxoFileCopy::Args);

	// We will pass through the DupFile table twice - first to compile the
	// total cost, then to execute the dup actions
	unsigned int cbTotalCost = 0;
	unsigned int cbPerTick = 0;
	Bool fCompile = fTrue;
	Bool fSuppressLFN = riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;
	bool fCheckCRC = 
		MsiString(riEngine.GetPropertyFromSz(IPROPNAME_CHECKCRCS)).TextSize() ? true : false;
	for (int iTotalPasses = 2;iTotalPasses > 0;iTotalPasses--)
	{
		for(;;)
		{
			PMsiRecord pDupRec(pView->Fetch());
			if (!pDupRec)
				break;

			iisEnum iisAction = (iisEnum) pDupRec->GetInteger(idfAction);
			if (iisAction != iisLocal)
				continue;

			// Our source file is a File Table entry
			MsiString strFileKey(pDupRec->GetMsiString(idfFileKey));
			CMsiFile objSourceFile(riEngine);
			pErrRec = objSourceFile.FetchFile(*strFileKey);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);

			// If our source file is not installed, and isn't going to
			// be installed, then we can't duplicate it.
			PMsiRecord pSourceRec(objSourceFile.GetFileRecord());
			if (!pSourceRec)
				break;

			iisEnum iisSourceAction = (iisEnum) pSourceRec->GetInteger(CMsiFile::ifqAction);
			iisEnum iisSourceInstalled = (iisEnum) pSourceRec->GetInteger(CMsiFile::ifqInstalled);
			if (iisSourceAction == iisLocal || (iisSourceAction == iMsiNullInteger && iisSourceInstalled == iisLocal))
			{
				if (fCompile)
				{
					cbTotalCost += pSourceRec->GetInteger(CMsiFile::ifqFileSize);
					continue;
				}
			}
			else
				continue;

			// Our source path will be the destination path that the source
			// file was copied to.
			PMsiPath pSourcePath(0);
			pErrRec = objSourceFile.GetTargetPath(*&pSourcePath);
			if (pErrRec)
			{
				if (pErrRec->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return riEngine.FatalError(*pErrRec);
			}

			// get the extracted source file name.
			MsiString strSourceName;
			if((pErrRec = objSourceFile.GetExtractedTargetFileName(*pSourcePath,*&strSourceName)) != 0)
				return riEngine.FatalError(*pErrRec);

			// Determine our destination path
			MsiString strDestFolder(pDupRec->GetMsiString(idfDestFolder));
			if (strDestFolder.TextSize() == 0)
				strDestFolder = pDupRec->GetMsiString(idfComponentDestFolder);

			PMsiPath pDestPath(0);
			pErrRec = pDirectoryMgr->GetTargetPath(*strDestFolder,*&pDestPath);
			if (pErrRec)
			{
				// If destination dir property was never defined, just go on.
				if (pErrRec->GetInteger(1) == idbgDirPropertyUndefined)
				{
					pErrRec = 0;
					continue;
				}
				else
					return riEngine.FatalError(*pErrRec);
			}

			// Set up the ixoFileCopy source folder
			pRecParams->ClearData();
			pRecParams->SetMsiString(IxoSetSourceFolder::Folder,*MsiString(pSourcePath->GetPath()));
			if ((iesExecute = riEngine.ExecuteRecord(ixoSetSourceFolder, *pRecParams)) != iesSuccess)
				return iesExecute;

			// Set up the destination name and folder - if no destination given,
			// we use the source name.
			MsiString strDestName;
			MsiString strDestNamePair = pDupRec->GetString(idfDestName);
			if (strDestNamePair.TextSize() == 0)
				strDestName = strSourceName;
			else
			{
				Bool fLFN = ((riEngine.GetMode() & iefSuppressLFN) == 0 && pDestPath->SupportsLFN()) ? fTrue : fFalse;
				if((pErrRec = pServices->ExtractFileName(strDestNamePair,fLFN,*&strDestName)) != 0)
					return riEngine.FatalError(*pErrRec);
			}

			pRecParams->ClearData();
			pRecParams->SetMsiString(IxoSetTargetFolder::Folder,*MsiString(pDestPath->GetPath()));
			if ((iesExecute = riEngine.ExecuteRecord(ixoSetTargetFolder, *pRecParams)) != iesSuccess)
				return iesExecute;

			// Set up the ixoFileCopy record
			int iAttributes = pSourceRec->GetInteger(CMsiFile::ifqAttributes);
			using namespace IxoFileCopy;
			pRecParams->ClearData();
			pRecParams->SetString(SourceName,strSourceName);
			pRecParams->SetString(DestName,strDestName);
			pRecParams->SetInteger(Attributes,iAttributes &~ msidbFileAttributesPatchAdded); // remove PatchAdded bit for DuplicateFiles
			pRecParams->SetInteger(FileSize,pSourceRec->GetInteger(CMsiFile::ifqFileSize));
			pRecParams->SetString(Version,MsiString(pSourceRec->GetMsiString(CMsiFile::ifqVersion)));
			pRecParams->SetString(Language,MsiString(pSourceRec->GetMsiString(CMsiFile::ifqLanguage)));
			pRecParams->SetInteger(InstallMode, icmOverwriteOlderVersions);
			pRecParams->SetInteger(PerTick,cbPerTick); 
			pRecParams->SetInteger(IsCompressed, 0); // always uncompressed
			pRecParams->SetInteger(VerifyMedia, fFalse);
			pRecParams->SetInteger(CheckCRC, ShouldCheckCRC(fCheckCRC, iisAction, iAttributes));
			if ((iesExecute = riEngine.ExecuteRecord(ixoFileCopy, *pRecParams)) != iesSuccess)
				return iesExecute;

		} 
		// Re-execute the query for the execution phase
		if (fCompile)
		{
			fCompile = fFalse;
			pView->Close();
			pErrRec = pView->Execute(0);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
			if(cbTotalCost)
			{
				pRecParams->ClearData();
				cbPerTick = iBytesPerTick;
				pRecParams->SetInteger(IxoProgressTotal::Total, cbTotalCost);
				pRecParams->SetInteger(IxoProgressTotal::Type, 0); // 0: separate progress and action data messages
				pRecParams->SetInteger(IxoProgressTotal::ByteEquivalent, 1);
				if ((iesExecute = riEngine.ExecuteRecord(ixoProgressTotal, *pRecParams)) != iesSuccess)
					return iesExecute;
			}
		}
	}// Next pass

	return iesSuccess;
}


/*---------------------------------------------------------------------------
	RemoveDuplicateFiles action
---------------------------------------------------------------------------*/
iesEnum RemoveDuplicateFiles(IMsiEngine& riEngine)
{
	if (!IsFileActivityEnabled(riEngine))
		return iesSuccess;

	const ICHAR sqlDupFiles[] =
	TEXT("SELECT `File_`,`DestName`,`DestFolder`,`Action`, `Directory_` FROM `DuplicateFile`,`Component` WHERE `Component`=`Component_`");

	enum idfEnum
	{
		idfFileKey = 1,
		idfDestName,
		idfDestFolder,
		idfAction,
		idfComponentDestFolder,
		idfNextEnum
	};

	iesEnum iesExecute;
	PMsiRecord pErrRec(0);
	PMsiServices pServices(riEngine.GetServices());
	Bool fSuppressLFN = riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;

	// Open the DuplicateFile table, if present. This table is optional, so its
	// absence is not an error.
	PMsiView pView(0);
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	if (pDatabase->FindTable(*MsiString(*sztblDuplicateFile)) != itsUnknown)
	{
		pErrRec = riEngine.OpenView(sqlDupFiles, ivcFetch, *&pView);
		if (pErrRec)
			return riEngine.FatalError(*pErrRec);
	}
	if (!pView)
		return iesSuccess;

	pErrRec = pView->Execute(0);
	if (pErrRec)
		return riEngine.FatalError(*pErrRec);

	PMsiRecord pRecParams = &pServices->CreateRecord(10);

	// We will pass through the DupFile table twice - first to compile the
	// total number of files to delete, then to delete 'em.
	unsigned int uiTotalCount = 0;
	Bool fCompile = fTrue;
	for (int iTotalPasses = 2;iTotalPasses > 0;iTotalPasses--)
	{
		for(;;)
		{
			PMsiRecord pDupRec(pView->Fetch());
			if (!pDupRec)
				break;

			iisEnum iisAction = (iisEnum) pDupRec->GetInteger(idfAction);
			if (iisAction != iisAbsent && iisAction != iisFileAbsent && iisAction != iisHKCRFileAbsent && iisAction != iisSource)
				continue;

			if (fCompile)
			{
				uiTotalCount++;
				continue;
			}

			// Determine our destination path, and set the target folder
			MsiString strDestFolder(pDupRec->GetMsiString(idfDestFolder));
			if (strDestFolder.TextSize() == 0)
				strDestFolder = pDupRec->GetMsiString(idfComponentDestFolder);

			PMsiPath pDestPath(0);
			pErrRec = pDirectoryMgr->GetTargetPath(*strDestFolder,*&pDestPath);
			if (pErrRec)
			{
				// If destination dir property was never defined, just go on.
				if (pErrRec->GetInteger(1) == idbgDirPropertyUndefined)
				{
					pErrRec = 0;
					continue;
				}
				else
					return riEngine.FatalError(*pErrRec);
			}

			pRecParams->ClearData();
			pRecParams->SetMsiString(IxoSetTargetFolder::Folder,*MsiString(pDestPath->GetPath()));
			if ((iesExecute = riEngine.ExecuteRecord(ixoSetTargetFolder, *pRecParams)) != iesSuccess)
				return iesExecute;

			// Set up the destination name - if no destination given,
			// we use the source name - then send off the FileRemove record.
			MsiString strDestNamePair(pDupRec->GetString(idfDestName));
			if (strDestNamePair.TextSize() == 0)
			{
				// use file name from source file record
				MsiString strFileKey(pDupRec->GetMsiString(idfFileKey));
				CMsiFile objSourceFile(riEngine);
				pErrRec = objSourceFile.FetchFile(*strFileKey);
				if (pErrRec)
					return riEngine.FatalError(*pErrRec);

				PMsiRecord pSourceRec(objSourceFile.GetFileRecord());
				if (!pSourceRec)
					break;

				strDestNamePair = pSourceRec->GetString(CMsiFile::ifqFileName);
			}
			// extract appropriate name from short|long pair
			Bool fLFN = ((riEngine.GetMode() & iefSuppressLFN) == 0 && pDestPath->SupportsLFN()) ? fTrue : fFalse;
			MsiString strDestName;
			if((pErrRec = pServices->ExtractFileName(strDestNamePair,fLFN,*&strDestName)) != 0)
				return riEngine.FatalError(*pErrRec);

			pRecParams->ClearData();
			pRecParams->SetString(IxoFileRemove::FileName,strDestName);
			if ((iesExecute = riEngine.ExecuteRecord(ixoFileRemove, *pRecParams)) != iesSuccess)
				return iesExecute;

		} 
		// Re-execute the query for the execution phase
		if (fCompile)
		{
			fCompile = fFalse;
			pView->Close();
			pErrRec = pView->Execute(0);
			if (pErrRec)
				return riEngine.FatalError(*pErrRec);
			if(uiTotalCount)
			{
				pRecParams->ClearData();
				pRecParams->SetInteger(IxoProgressTotal::Total, uiTotalCount);
				pRecParams->SetInteger(IxoProgressTotal::Type, 1); // ActionData progress
				pRecParams->SetInteger(IxoProgressTotal::ByteEquivalent, ibeRemoveFiles);
				if ((iesExecute = riEngine.ExecuteRecord(ixoProgressTotal, *pRecParams)) != iesSuccess)
					return iesExecute;
			}
		}
	}// Next pass

	return iesSuccess;
}




/*---------------------------------------------------------------------------
	Cost adjuster for all registry actions
---------------------------------------------------------------------------*/
class CMsiRegistryCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iARPNoRbLocalCost);
public:  // constructor
	CMsiRegistryCost(IMsiEngine& riEngine);
protected:
	~CMsiRegistryCost();
private:
	IMsiRecord* LinkToWindowsFolder(const ICHAR* szTable);
	void AdjustRegistryCost(int& iLocalCost);
	TRI		m_tHasTypeLibCostColumn;
	PMsiView	m_pViewTypeLibCost;
	int         m_colRegistryRoot;
	int         m_colRegistryKey;
	int         m_colRegistryRegistry;
	int         m_colRegistryName;
	int         m_colRegistryValue;
	int         m_colRegistryComponent;
	IMsiTable*  m_piRegistryTable;
	IMsiCursor* m_piRegistryCursor;
	
};

CMsiRegistryCost::CMsiRegistryCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine), m_pViewTypeLibCost(0)
{
	m_tHasTypeLibCostColumn = tUnknown;
	m_piRegistryTable = 0;
	m_piRegistryCursor = 0;
}

CMsiRegistryCost::~CMsiRegistryCost()
{

	if (m_piRegistryTable != 0)
	{
		m_piRegistryTable->Release();
		m_piRegistryTable = 0;
	}

	if (m_piRegistryCursor != 0)
	{
		m_piRegistryCursor->Release();
		m_piRegistryCursor = 0;
	}
}

static const ICHAR szComponent[] = TEXT("Component_");

IMsiRecord* CMsiRegistryCost::LinkToWindowsFolder(const ICHAR* szRegTable)
//----------------------------------------------------
{

	PMsiTable pTable(0);
	PMsiCursor pCursor(0);	
	IMsiRecord* piError = 0;
	int icolComponent;
	PMsiDatabase pDatabase(m_riEngine.GetDatabase());
	
	if((piError = pDatabase->LoadTable(*MsiString(szRegTable),0,*&pTable)) != 0)
	{
		if (piError->GetInteger(1) == idbgDbTableUndefined)
		{
			piError->Release();
			return 0;
		}
		else
			return piError;
	}
	pCursor = pTable->CreateCursor(fFalse);
	icolComponent = pTable->GetColumnIndex(pDatabase->EncodeStringSz(szComponent));


	MsiStringId idWindowsFolder = pDatabase->EncodeStringSz(IPROPNAME_WINDOWS_FOLDER);
	AssertSz(idWindowsFolder != 0, "WindowsFolder property not set in database");
	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	MsiStringId idLast = 0;
	
	while(pCursor->Next())
	{
		MsiStringId idComponent = pCursor->GetInteger(icolComponent);
		if (idComponent != idLast)
		{
			piError = pSelectionMgr->RegisterComponentDirectoryId(idComponent,idWindowsFolder);
			if (piError)
				return piError;
			idLast = idComponent;
		}
	}
	return 0;
}


const ICHAR szRegistryRegistry[]    = TEXT("Registry");
const ICHAR szRegistryRoot[]        = TEXT("Root");
const ICHAR szRegistryKey[]         = TEXT("Key");
const ICHAR szRegistryValue[]       = TEXT("Value");
const ICHAR szRegistryName[]        = TEXT("Name");

IMsiRecord* CMsiRegistryCost::Initialize()
//-------------------------------------------
{
	IMsiRecord* piErrRec;
	PMsiDatabase pDatabase(m_riEngine.GetDatabase());

	if((piErrRec = pDatabase->LoadTable(*MsiString(sztblRegistry),0,*&m_piRegistryTable)) != 0)
	{
		if (piErrRec->GetInteger(1) == idbgDbTableUndefined)
		{
			piErrRec->Release();
			piErrRec = 0;
		}
		else
			return piErrRec;
	}
	else
	{
		m_piRegistryCursor = m_piRegistryTable->CreateCursor(fFalse);
		m_colRegistryRoot = m_piRegistryTable->GetColumnIndex(pDatabase->EncodeStringSz(szRegistryRoot));
		m_colRegistryKey = m_piRegistryTable->GetColumnIndex(pDatabase->EncodeStringSz(szRegistryKey));
		m_colRegistryName = m_piRegistryTable->GetColumnIndex(pDatabase->EncodeStringSz(szRegistryName));
		m_colRegistryValue = m_piRegistryTable->GetColumnIndex(pDatabase->EncodeStringSz(szRegistryValue));
		m_colRegistryRegistry = m_piRegistryTable->GetColumnIndex(pDatabase->EncodeStringSz(szRegistryRegistry));
		m_colRegistryComponent = m_piRegistryTable->GetColumnIndex(pDatabase->EncodeStringSz(szComponent));		
	}
	
	if ((piErrRec = LinkToWindowsFolder(TEXT("Registry"))) != 0)
		return piErrRec;
	if ((piErrRec = LinkToWindowsFolder(TEXT("Class"))) != 0)
		return piErrRec;
	if ((piErrRec = LinkToWindowsFolder(TEXT("Extension"))) != 0)
		return piErrRec;
	if ((piErrRec = LinkToWindowsFolder(TEXT("TypeLib"))) != 0)
		return piErrRec;
	
	//!! Costing is not available yet for the AppId table
	return 0;
}

const int iRegistrySourceCostFudgeFactor = 100;

static const ICHAR sqlRegCost2[] = TEXT("SELECT `Root`,`Key`,`Name` FROM `Registry` WHERE `Registry`=?");

IMsiRecord* CMsiRegistryCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool /*fAddFileInUse*/, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
//------------------------------------------
{
	// initialise all costs to 0
	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;

	if (!IsRegistryActivityEnabled(m_riEngine))
		return 0;

	// the registry cost is attributed to the windows folder
	if (riDirectoryString.Compare(iscExact,IPROPNAME_WINDOWS_FOLDER) == 0)
		return 0;

	IMsiRecord* piErrRec = 0;

	// as a fix for bug 318875, only perform dynamic costing if the component is not installed local
	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	IMsiTable* piComponentTable = pSelectionMgr->GetComponentTable();

	PMsiDatabase pDatabase = m_riEngine.GetDatabase();
	if (piComponentTable)
	{
		int colComponentKey, colComponentInstalled;
		colComponentKey = piComponentTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colComponent));
		colComponentInstalled = piComponentTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colInstalled));

		PMsiCursor pComponentCursor(piComponentTable->CreateCursor(fFalse));
		pComponentCursor->SetFilter(iColumnBit(colComponentKey));
		pComponentCursor->PutString(colComponentKey,riComponentString);
		if (pComponentCursor->Next())
		{
			iisEnum iisInstalled = (iisEnum) pComponentCursor->GetInteger(colComponentInstalled);
			if (iisLocal == iisInstalled || iisSource == iisInstalled)
			{
				piComponentTable->Release();
				return 0; // no cost since component is already installed and registry keys/values have already been written
			}
		}
		piComponentTable->Release();
	}

	// the registry table	
	int iCostIndividual = 0;

	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	// the execute record
	PMsiServices pServices(m_riEngine.GetServices());


	if (m_piRegistryCursor)
	{
		m_piRegistryCursor->Reset();
		m_piRegistryCursor->SetFilter(iColumnBit(m_colRegistryComponent));
		m_piRegistryCursor->PutString(m_colRegistryComponent, riComponentString);

		while(m_piRegistryCursor->Next())
		{
			iCostIndividual += MsiString(m_piRegistryCursor->GetString(m_colRegistryKey)).TextSize();
			iCostIndividual += MsiString(m_piRegistryCursor->GetString(m_colRegistryName)).TextSize();
			iCostIndividual += MsiString(m_piRegistryCursor->GetString(m_colRegistryValue)).TextSize();
		}

		iSourceCost += iCostIndividual;
		iNoRbSourceCost += iCostIndividual;
		iLocalCost  += iCostIndividual;
		iNoRbLocalCost += iCostIndividual;
		iARPLocalCost += iCostIndividual;
		iNoRbARPLocalCost += iCostIndividual;
	}


	// the typelib table, cost if TypeLib.Cost column is present
	iCostIndividual = 0;
	enum itcEnum
	{
		itcCost = 1,
		itcNextEnum
	};

	if (m_tHasTypeLibCostColumn == tUnknown)
	{
		PMsiView pView(0);
		static const ICHAR sqlFindCostColumn[] = TEXT("SELECT `_Columns`.`Name` FROM `_Columns` WHERE `Table` = 'TypeLib' AND `_Columns`.`Name` = 'Cost'");
		piErrRec = m_riEngine.OpenView(sqlFindCostColumn, ivcFetch, *&pView);
		if (piErrRec)
			return piErrRec;

		if ((piErrRec = pView->Execute(0)) != 0)
			return piErrRec;

		m_tHasTypeLibCostColumn =  (PMsiRecord(pView->Fetch()) != 0) ? tTrue : tFalse; // If fetch returns, the Cost column is present
	}

	PMsiRecord pExecRec(&pServices->CreateRecord(1));
	pExecRec->SetMsiString(1, riComponentString);

	if(m_tHasTypeLibCostColumn == tTrue) // the Cost column is present
	{
		if (m_pViewTypeLibCost == 0)
		{		
			static const ICHAR sqlTypeLibCost[] = TEXT("SELECT `Cost` FROM `TypeLib` WHERE `Component_`=?");
			piErrRec = m_riEngine.OpenView(sqlTypeLibCost, ivcFetch, *&m_pViewTypeLibCost);
			if (piErrRec)
				return piErrRec;
		}
		
		if ((piErrRec = m_pViewTypeLibCost->Execute(pExecRec)) != 0)
		{
			AssertZero(m_pViewTypeLibCost->Close());
			return piErrRec;
		}

		PMsiRecord pTypeLibRec(0);
		while((pTypeLibRec= m_pViewTypeLibCost->Fetch()) != 0)
		{
			if(!pTypeLibRec->IsNull(itcCost))
				iCostIndividual += pTypeLibRec->GetInteger(itcCost);
		}

		iSourceCost += iCostIndividual;
		iNoRbSourceCost += iCostIndividual;
		iLocalCost  += iCostIndividual;
		iNoRbLocalCost += iCostIndividual;
		iARPLocalCost += iCostIndividual;
		iNoRbARPLocalCost += iCostIndividual;
		AssertZero(PMsiRecord(m_pViewTypeLibCost->Close()));
	}

	// the component table - for component and client registration
	iCostIndividual = 0;
	enum iccEnum
	{
		iccComponentId=1,
		iccKeyPath,
		iccAction,
		iccDirectory,
		iccAttributes,
		iccNextEnum
	};
	static const ICHAR sqlComponentCost[]    = TEXT(" SELECT `ComponentId`, `KeyPath`, `Action`, `Directory_`, `Attributes`    FROM `Component` WHERE `Component` = ?");

	if (!m_pCostView)
	{
		piErrRec = m_riEngine.OpenView(sqlComponentCost, ivcFetch, *&m_pCostView);
		if (piErrRec)
			return piErrRec;
	}

	if ((piErrRec = m_pCostView->Execute(pExecRec)) != 0)
		return piErrRec;

	PMsiRecord pComponentRec(0);

	int iLocalCostIndividual = 0;
	int iSourceCostIndividual = 0;
	while((pComponentRec = m_pCostView->Fetch()) != 0)
	{
		iLocalCostIndividual  += MsiString(pComponentRec->GetMsiString(iccComponentId)).TextSize();
		iSourceCostIndividual += MsiString(pComponentRec->GetMsiString(iccComponentId)).TextSize();

		// file, registry or folder
		MsiString strKeyPathKey = pComponentRec->GetMsiString(iccKeyPath);
		PMsiPath pPath(0);
		MsiString strKeyPath;
		if(strKeyPathKey.TextSize()) // file or registry
		{
			if(pComponentRec->GetInteger(iccAttributes) & icaRegistryKeyPath) // registry key path
			{

				enum ircEnum{
					ircRoot,
					ircKey,
					ircName,
				};
				PMsiView pView1(0);
				piErrRec = m_riEngine.OpenView(sqlRegCost2, ivcFetch, *&pView1);
				PMsiRecord pExecRec1(&pServices->CreateRecord(1));
				pExecRec1->SetMsiString(1, *strKeyPathKey);
				if ((piErrRec = pView1->Execute(pExecRec1)) != 0)
					return piErrRec;
				PMsiRecord pRegistryRec(0);

				if((pRegistryRec = pView1->Fetch()) != 0)
				{
					int iCostIndividual = MsiString(pRegistryRec->GetMsiString(ircRoot)).TextSize();
					iCostIndividual += MsiString(pRegistryRec->GetMsiString(ircKey)).TextSize();
					iCostIndividual += MsiString(pRegistryRec->GetMsiString(ircName)).TextSize();
					iLocalCostIndividual += iCostIndividual;
					iSourceCostIndividual +=  iCostIndividual;
				}
			}
			else if (pComponentRec->GetInteger(iccAttributes) & icaODBCDataSource) // ODBC Data source
			{
				//FUTURE: should cost these?
			}
			else
			{

				CMsiFile objFile(m_riEngine);
				piErrRec = objFile.FetchFile(*strKeyPathKey);
				if (piErrRec)
					return piErrRec;

				// local cost
				// get destination path
				if((piErrRec = objFile.GetTargetPath(*&pPath)) != 0)
					return piErrRec;

				// extract appropriate file name from short|long pair
				MsiString strFileName;
				if((piErrRec = objFile.GetExtractedTargetFileName(*pPath, *&strFileName)) != 0)
					return piErrRec;
				if ((piErrRec = pPath->GetFullFilePath(strFileName, *&strKeyPath)) != 0)
					return piErrRec;
				iLocalCostIndividual += strKeyPath.TextSize();

				// source cost
				iSourceCostIndividual += iRegistrySourceCostFudgeFactor;
			}
		}
		else // folder
		{
			if ((piErrRec = pDirectoryMgr->GetTargetPath(*MsiString(pComponentRec->GetMsiString(iccDirectory)),*&pPath)) != 0)
				return piErrRec;
			iLocalCostIndividual += strKeyPath.TextSize();
			iSourceCostIndividual += iRegistrySourceCostFudgeFactor;
		}

		// add client registering cost, product code size + state
		iLocalCostIndividual  += MsiString(m_riEngine.GetProductKey()).TextSize() + sizeof(INSTALLSTATE);
		iSourceCostIndividual += MsiString(m_riEngine.GetProductKey()).TextSize() + sizeof(INSTALLSTATE);

	}

	iSourceCost += iLocalCostIndividual;
	iNoRbSourceCost += iLocalCostIndividual;
	iLocalCost  += iSourceCostIndividual;
	iNoRbLocalCost += iLocalCostIndividual;
	iARPLocalCost += iSourceCostIndividual;
	iNoRbARPLocalCost += iLocalCostIndividual;

	// the class table
	iCostIndividual = 0;
	enum ioc
	{
		iocClass=1,
		iocProgID,
		iocDescription,
		iocContext,
		iocFeature,
		iocComponentId,
		iocInsertable,
		iocAppId,
		iocTypeMask,
		iocDefInprocHandler,
	};
	// make sure the table exists
	if(pDatabase->GetTableState(sztblClass, itsTableExists))// the Class table is present
	{
		static const ICHAR sqlClassSQL[] = TEXT("SELECT `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`,  null, `AppId_`, `FileTypeMask`, `DefInprocHandler`  FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND (`Feature`.`Action` = 1 OR `Feature`.`Action` = 2) AND `Component` = ?");

		PMsiView pView(0);
		if ((piErrRec = m_riEngine.OpenView(sqlClassSQL, ivcFetch, *&pView)) != 0)
			return piErrRec;
		if ((piErrRec = pView->Execute(pExecRec)) != 0)
			return piErrRec;

		PMsiRecord piClassRec(0);
		while((piClassRec = pView->Fetch()) != 0)
		{
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocClass)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocProgID)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocDescription)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocContext)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocFeature)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocComponentId)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocInsertable)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocAppId)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocTypeMask)).TextSize();
			iCostIndividual += MsiString(piClassRec->GetMsiString(iocDefInprocHandler)).TextSize();
			iCostIndividual += MsiString(m_riEngine.GetProductKey()).TextSize();
		}
		iSourceCost += iCostIndividual;
		iNoRbSourceCost += iCostIndividual;
		iLocalCost  += iCostIndividual;
		iNoRbLocalCost += iCostIndividual;
		iARPLocalCost += iCostIndividual;
		iNoRbARPLocalCost += iCostIndividual;
	}

	// the extension - verb - mime table
	iCostIndividual = 0;
	enum iecEnum
	{
		iecExtension=1,
		iecProgId,
		iecShellNew,
		iecShellNewValue,
		iecComponentId,
		iecFeature,
		iecNextEnum
	};
	// make sure the table exists
	if(pDatabase->GetTableState(sztblExtension, itsTableExists))// the Extension table is present
	{
		static const ICHAR sqlExtensionSQL[] = TEXT("SELECT `Extension`, `ProgId_`, null, null, `Feature_`, `ComponentId` FROM `Extension`, `Component`, `Feature`  WHERE `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND (`Feature`.`Action` = 1 OR `Feature`.`Action` = 2) AND `Component` = ?");
		PMsiView pView(0);
		if ((piErrRec = m_riEngine.OpenView(sqlExtensionSQL, ivcFetch, *&pView)) != 0)
			return piErrRec;
		if ((piErrRec = pView->Execute(pExecRec)) != 0)
			return piErrRec;

		PMsiRecord piExtensionRec(0);
		while((piExtensionRec = pView->Fetch()) != 0)
		{
			iCostIndividual  += MsiString(piExtensionRec->GetMsiString(iecExtension)).TextSize();
			iCostIndividual  += MsiString(piExtensionRec->GetMsiString(iecProgId)).TextSize();
			iCostIndividual  += MsiString(piExtensionRec->GetMsiString(iecShellNew)).TextSize();
			iCostIndividual  += MsiString(piExtensionRec->GetMsiString(iecShellNewValue)).TextSize();
			iCostIndividual  += MsiString(piExtensionRec->GetMsiString(iecComponentId)).TextSize();
			iCostIndividual  += MsiString(piExtensionRec->GetMsiString(iecFeature)).TextSize();
			iCostIndividual  += MsiString(m_riEngine.GetProductKey()).TextSize();

			PMsiView pView1(0);
			PMsiRecord pExecRec1(&pServices->CreateRecord(1));
			// get the cost from the verb table
			if(pDatabase->FindTable(*MsiString(sztblVerb)) != itsUnknown)// the Verb table is present
			{
				enum ivcEnum
				{
					ivcVerb=1,
					ivcCommand,
					ivcArgument,
					ivcNextEnum
				};

				const ICHAR sqlExtensionExSQL[] =  TEXT("SELECT `Verb`, `Command`, `Argument` FROM `Verb` WHERE `Extension_` = ?");
				if ((piErrRec = m_riEngine.OpenView(sqlExtensionExSQL, ivcFetch, *&pView1)) != 0)
					return piErrRec;
				pExecRec1->SetMsiString(1, *MsiString(piExtensionRec->GetMsiString(iecExtension)));
				if ((piErrRec = pView1->Execute(pExecRec1)) != 0)
					return piErrRec;
				PMsiRecord piExtensionExRec(0);
				while((piExtensionExRec = pView1->Fetch()) != 0)
				{
					iCostIndividual  += MsiString(piExtensionExRec->GetMsiString(ivcVerb)).TextSize();
					iCostIndividual  += MsiString(piExtensionExRec->GetMsiString(ivcCommand)).TextSize();
					iCostIndividual  += MsiString(piExtensionExRec->GetMsiString(ivcArgument)).TextSize();
				}
			}

			// get the cost from the mime table
			if(pDatabase->FindTable(*MsiString(sztblMIME)) != itsUnknown)// the MIME table is present
			{
				enum imcEnum
				{
					imcContentType=1,
					imcExtension=1,
					imcClassId=1,

				};
				const ICHAR sqlExtensionEx2SQL[] =  TEXT("SELECT `ContentType`, `Extension_`, `CLSID` FROM `MIME` WHERE `Extension_` = ?");
				if ((piErrRec = m_riEngine.OpenView(sqlExtensionEx2SQL, ivcFetch, *&pView1)) != 0)
					return piErrRec;
				if ((piErrRec = pView1->Execute(pExecRec1)) != 0)
					return piErrRec;
				PMsiRecord piExtensionEx2Rec(0);
				while((piExtensionEx2Rec = pView1->Fetch()) != 0)
				{
					iCostIndividual  += MsiString(piExtensionEx2Rec->GetMsiString(imcContentType)).TextSize();
					iCostIndividual  += MsiString(piExtensionEx2Rec->GetMsiString(imcExtension)).TextSize();
					iCostIndividual  += MsiString(piExtensionEx2Rec->GetMsiString(imcClassId)).TextSize();
				}
			}
		}
		iSourceCost += iCostIndividual;
		iNoRbSourceCost += iCostIndividual;
		iLocalCost  += iCostIndividual;
		iNoRbLocalCost += iCostIndividual;
		iARPLocalCost += iCostIndividual;
		iNoRbARPLocalCost += iCostIndividual;
	}

	AdjustRegistryCost(iSourceCost);
	AdjustRegistryCost(iNoRbSourceCost);
	AdjustRegistryCost(iLocalCost);
	AdjustRegistryCost(iNoRbLocalCost);
	AdjustRegistryCost(iRemoveCost);
	AdjustRegistryCost(iNoRbRemoveCost);
	AdjustRegistryCost(iARPLocalCost);
	AdjustRegistryCost(iNoRbARPLocalCost);
	return 0;
}



void CMsiRegistryCost::AdjustRegistryCost(int& iLocalCost)
//------------------------------------------
{
	if(m_riEngine.GetPropertyInt(*MsiString(*IPROPNAME_VERSIONNT)) != iMsiNullInteger)
		iLocalCost *= 2;// the registry is UNICODE on NT

	// GetDynamicCost expects cost values to be returned as multiples of iMsiMinClusterSize
	iLocalCost = (iLocalCost + iMsiMinClusterSize - 1) / iMsiMinClusterSize;
}

/*-------------------------------------------------------------------------------
	SFPCatalogCost cost adjuster (InstallSFPCatalogFile action is in shared.cpp)
---------------------------------------------------------------------------------*/
class CMsiSFPCatalogCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);
public:  // constructor
	CMsiSFPCatalogCost(IMsiEngine& riEngine);
protected:
	~CMsiSFPCatalogCost();
private:
	IMsiTable*  m_piFeatureComponentsTable; // we hold onto the table to keep in memory and control lifetime of our insert temporaries
	IMsiTable*  m_piComponentTable; // we hold onto the table to keep in memory and control lifetime of our insert temporaries
	int			m_colComponentKey;
	int         m_colComponentDirectory;
	int         m_colComponentAttributes;
	MsiString   m_strComponent; // name of dummy component to which attributing cost

	IMsiRecord* GenerateDummyComponent();
};

CMsiSFPCatalogCost::CMsiSFPCatalogCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine), m_strComponent(0),
										m_piFeatureComponentsTable(0), m_piComponentTable(0), m_colComponentKey(0),
										m_colComponentDirectory(0), m_colComponentAttributes(0)
{
}

CMsiSFPCatalogCost::~CMsiSFPCatalogCost()
{
	if (m_piFeatureComponentsTable)
	{
		m_piFeatureComponentsTable->Release();
		m_piFeatureComponentsTable = 0;
	}
	if (m_piComponentTable)
	{
		m_piComponentTable->Release();
		m_piComponentTable = 0;
	}
}


static const ICHAR szSFPCostComponentName[] = TEXT("__SFPCostComponent");

IMsiRecord* CMsiSFPCatalogCost::GenerateDummyComponent()
{
	if (!m_piComponentTable)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	// create a unique name to represent the SFPCatalogCost "dummy" component
	IMsiRecord* piErrRec = 0;
	int iMaxTries = 100;
	int iSuffix = 65;
	const int cchMaxComponentTemp=40;
	int cchT;
	
	PMsiCursor pComponentCursor(m_piComponentTable->CreateCursor(fFalse));
	Assert(pComponentCursor);

	do
	{
		// Max size is 2 chars for __, cchMaxComponentTemp and 11 chars for max 
		// int and trailing null
		ICHAR rgch[2+cchMaxComponentTemp+11];
		IStrCopy(rgch, TEXT("__"));
		memcpy(&rgch[2], szSFPCostComponentName, (cchT = min(lstrlen(szSFPCostComponentName), cchMaxComponentTemp)) * sizeof(ICHAR));
		ltostr(&rgch[2 + cchT], iSuffix++);
		m_strComponent = rgch;

		// prepare cursor for insert of dummy component
		// SFPCatalog files are installed to the WindowsFolder (this has been set as the
		// directory of the dummy component).

		pComponentCursor->Reset();
		pComponentCursor->PutString(m_colComponentKey, *m_strComponent);
		pComponentCursor->PutString(m_colComponentDirectory, *(MsiString(*IPROPNAME_WINDOWS_FOLDER)));
		pComponentCursor->PutInteger(m_colComponentAttributes, 0);

		iMaxTries--;

	}while (pComponentCursor->InsertTemporary() == fFalse && iMaxTries > 0);

	if (iMaxTries == 0)
		return PostError(Imsg(idbgBadSubcomponentName), *m_strComponent);

	return 0;
}

static const ICHAR szSFPCostFeatureSQL[] = TEXT("SELECT `FeatureComponents`.`Feature_`,`FeatureComponents`.`Component_` FROM `FeatureComponents`, `File`, `FileSFPCatalog` WHERE `File`.`File`=`FileSFPCatalog`.`File_` AND `FeatureComponents`.`Component_`=`File`.`Component_`");
static const ICHAR szSFPCostFeatureMapSQL[] = TEXT("INSERT INTO `FeatureComponents` (`Feature_`,`Component_`) VALUES (?, ?) TEMPORARY");

IMsiRecord* CMsiSFPCatalogCost::Initialize()
{
	enum ifccEnum
	{
		ifccFeature=1,
		ifccComponent=2
	};

	// load Component table
	PMsiDatabase pDatabase(m_riEngine.GetDatabase());
	IMsiRecord* piErrRec = pDatabase->LoadTable(*MsiString(*sztblComponent),0,m_piComponentTable);
	if (piErrRec)
	{
		// nothing to do if Component table missing
		if (idbgDbTableUndefined == piErrRec->GetInteger(1))
		{
			piErrRec->Release();
			piErrRec = 0;
		}
		return piErrRec;
	}
	m_colComponentKey = m_piComponentTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colComponent));
	m_colComponentDirectory = m_piComponentTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colDirectory));
	m_colComponentAttributes = m_piComponentTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colAttributes));

	// load FeatureComponents table
	piErrRec = pDatabase->LoadTable(*MsiString(*sztblFeatureComponents),0,m_piFeatureComponentsTable);
	if (piErrRec)
	{
		// nothing to do if FeatureComponents table missing
		if (idbgDbTableUndefined == piErrRec->GetInteger(1))
		{
			piErrRec->Release();
			piErrRec = 0;
		}
		return piErrRec;
	}
		
	// create the dummy component to store the SFPCatalog cost
	if ((piErrRec = GenerateDummyComponent()) != 0)
		return piErrRec;

	// we're going to assign the "dummy" component to every feature containing
	// a component that contains a file that installs a catalog.  This will then
	// look like a shared component and cost will be attributed to each feature
	// (as are shared components) in the UI; although cost is only attributed
	// once per volume in actuality.
	PMsiView pInsertView(0);
	if (0 != (piErrRec = m_riEngine.OpenView(szSFPCostFeatureMapSQL, ivcFetch, *&pInsertView)))
		return piErrRec;

	PMsiView pFeatureCView(0);
	if (0 != (piErrRec = m_riEngine.OpenView(szSFPCostFeatureSQL, ivcFetch, *&pFeatureCView)))
	{
		// File table is missing, nothing to do.
		if (idbgDbQueryUnknownTable == piErrRec->GetInteger(1))
		{
			piErrRec->Release();
			piErrRec = 0;
		}
		return piErrRec;
	}
	if (0 != (piErrRec = pFeatureCView->Execute(0)))
		return piErrRec;

	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);

	PMsiRecord pFeatureRec(0);
	while ((pFeatureRec = pFeatureCView->Fetch()) != 0)
	{
		// cost link our dummy component to the file's component
		// so that we may recost when the file's component action state changes.
		// this is due to the weirdness of catalog files which "break" our
		// current component rules -- feature linking can't be done because the 
		// component state is set after feature linked components have been recosted
		// ... which won't help us here
		if (0 != (piErrRec = pSelectionMgr->RegisterCostLinkedComponent(*MsiString(pFeatureRec->GetMsiString(ifccComponent)), *m_strComponent)))
			return piErrRec;
		
		// map our dummy component to the file component's feature
		// if the insert fails, fine, the mapping already exists.
		pFeatureRec->SetMsiString(ifccComponent, *m_strComponent);
		piErrRec = pInsertView->Execute(pFeatureRec);
		if (piErrRec)
			piErrRec->Release();
		pInsertView->Close();
	}

	return 0;
}

static const ICHAR szSFPCostSQL[] =
		TEXT("SELECT DISTINCT `SFPCatalog`,`Catalog` FROM `SFPCatalog`,`File`,`FileSFPCatalog`,`Component`")
		TEXT(" WHERE `Component`.`Action`=1 AND `File`.`Component_`=`Component`.`Component`")
		TEXT(" AND `File`.`File`=`FileSFPCatalog`.`File_` AND `SFPCatalog`.`SFPCatalog`=`FileSFPCatalog`.`SFPCatalog_`");

IMsiRecord* CMsiSFPCatalogCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
											   Bool /*fAddFileInUse*/, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
											   int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
{
	enum isfpcEnum
	{
		isfpcSFPCatalog=1,
		isfpcCatalog
	};

	// initialize all costs to zero
	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;

	// ignore request if we are not costing our dummy component
	if (0 == riComponentString.Compare(iscExact, m_strComponent))
		return 0;

	// - SFPCatalogs are only installed if file is installed local
	// - The only cost we worry about is the local cost.
	// - SFPCatalogs are never removed (i.e. they are permanent)
	// - SFPCatalogs are never run-from-source
	PMsiView pView(0);
	IMsiRecord* piErrRec = m_riEngine.OpenView(szSFPCostSQL, ivcFetch, *&pView);
	if (0 != piErrRec)
	{
		if (piErrRec->GetInteger(1) == idbgDbTableUndefined)
		{
			piErrRec->Release();
			piErrRec = 0;
		}
		return piErrRec;
	}
	if (0 != (piErrRec = pView->Execute(0)))
		return piErrRec;

	PMsiRecord pCatalogRec(0);

	// we really don't know how they store catalog files on Millennium
	// ...so, we're going to roundup to the nearest cluster what the size
	// will be on the WindowsFolder volume.
	// create the path to the WindowsFolder (indirectly gets the volume)
	PMsiPath pDestPath(0);
	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	piErrRec = pDirectoryMgr->GetTargetPath(riDirectoryString,*&pDestPath);
	if (piErrRec)
		return piErrRec;

	while ((pCatalogRec = pView->Fetch()) != 0)
	{
		// obtain catalog stream
		PMsiData pCatalogData = pCatalogRec->GetMsiData(isfpcCatalog);
		IMsiStream* piStream;
		unsigned int cbStream = 0;
		if (pCatalogData->QueryInterface(IID_IMsiStream, (void**)&piStream) == NOERROR)
		{
			cbStream = piStream->GetIntegerValue();
			piStream->Release();
		}

		// convert our byte size to the clustered file size
		unsigned int uiClusteredSize=0;
		if ((piErrRec = pDestPath->ClusteredFileSize(cbStream, uiClusteredSize)) != 0)
			return piErrRec;

		iLocalCost += uiClusteredSize;
		iARPLocalCost += uiClusteredSize;
	}

	// we can't easily determine if a catalog already exists (must stream to a file and then try
	// to copy it); in short, it's ugly and slow, so we'll have to live with iNoRbLocalCost being
	// equal to iLocalCost until they provide us some API hook to determine the current catalog
	// file size (and whether it already exists)
	iNoRbLocalCost = iLocalCost;
	iNoRbARPLocalCost = iARPLocalCost;
	
	return 0;
}

/*---------------------------------------------------------------------------
	Shortcuts cost adjuster
---------------------------------------------------------------------------*/
class CMsiShortcutCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);
public:  // constructor
	CMsiShortcutCost(IMsiEngine& riEngine);
protected:
	~CMsiShortcutCost();
private:
	IMsiRecord* GetTargetFileRecord(const IMsiString& riTargetString, IMsiRecord *& rpiFileRec);
};
CMsiShortcutCost::CMsiShortcutCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine){}
CMsiShortcutCost::~CMsiShortcutCost(){}


IMsiRecord* CMsiShortcutCost::GetTargetFileRecord(const IMsiString& riTargetString, IMsiRecord *& rpiFileRec)
/*--------------------------------------------------------------
If the given target string resolves to a file in the file table,
a record containing a CMsiFile info block will be returned as
the function result, with a NULL value in field 0).  If an error
occurs (i.e. a nonexistent file table reference is given), an
error record is returned. Otherwise, the return value will be
NULL.
---------------------------------------------------------------*/
{
	rpiFileRec = 0;
	MsiString strTarget(riTargetString.GetMsiStringValue());
	if (strTarget.Compare(iscStart,TEXT("[#")) && strTarget.Compare(iscEnd,TEXT("]")))
	{
		strTarget.Remove(iseFirst, 2);
		strTarget.Remove(iseEnd,1);
		GetSharedEngineCMsiFile(pobjFile, m_riEngine);
		IMsiRecord* piErrRec = pobjFile->FetchFile(*strTarget);
		if (piErrRec)
			return piErrRec;
		else
			rpiFileRec = pobjFile->GetFileRecord();
	}
	return 0;
}


IMsiRecord* CMsiShortcutCost::Initialize()
//-------------------------------------------
{
	static const ICHAR* szComponent = TEXT("Component_");
	static const ICHAR* szTarget = TEXT("Target");
	static const ICHAR* szDirectory = TEXT("Directory_");

	PMsiTable pTable(0);
	PMsiCursor pCursor(0);	
	IMsiRecord* piErrRec = 0;
	int icolComponent, icolTarget, icolDirectory;
	PMsiDatabase pDatabase(m_riEngine.GetDatabase());
	
	if((piErrRec = pDatabase->LoadTable(*MsiString(sztblShortcut),0,*&pTable)) != 0)
	{
		if (piErrRec->GetInteger(1) == idbgDbTableUndefined)
		{
			piErrRec->Release();
			return 0;
		}
		else
			return piErrRec;
	}
	pCursor = pTable->CreateCursor(fFalse);
	
	icolComponent = pTable->GetColumnIndex(pDatabase->EncodeStringSz(szComponent));
	icolTarget = pTable->GetColumnIndex(pDatabase->EncodeStringSz(szTarget));
	icolDirectory = pTable->GetColumnIndex(pDatabase->EncodeStringSz(szDirectory));

	
	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	while(pCursor->Next())
	{
		MsiStringId idComponent = pCursor->GetInteger(icolComponent);
		MsiStringId idDestFolder = pCursor->GetInteger(icolDirectory);
		piErrRec = pSelectionMgr->RegisterComponentDirectoryId(idComponent,idDestFolder);
		if (piErrRec)
			return piErrRec;

		MsiString strTarget(pCursor->GetString(icolTarget));
		IMsiRecord* piFileRec = 0;
		IMsiRecord* piErrRec = GetTargetFileRecord(*strTarget, piFileRec);
		MsiString strComponent(pDatabase->DecodeString(idComponent));
		if (piErrRec)
			return piErrRec;
			
		if (piFileRec)
		{
			MsiString strFileComponent(piFileRec->GetMsiString(CMsiFile::ifqComponent));
			piFileRec->Release();

			if (strComponent.Compare(iscExact,strFileComponent) == 0)
			{
				if ((piErrRec = pSelectionMgr->RegisterCostLinkedComponent(*strFileComponent,*strComponent)) != 0)
					return piErrRec;
			}
		}
		else if(strTarget.Compare(iscStart, TEXT("[")) == 0)
		{
			// Must be a reference to a feature
			if ((piErrRec = pSelectionMgr->RegisterFeatureCostLinkedComponent(*strTarget,*strComponent)) != 0)
				return piErrRec;
		}

	}
	return 0;
}


IMsiRecord* CMsiShortcutCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
//------------------------------------------
{
	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;
	if (!IsShortcutActivityEnabled(m_riEngine))
		return 0;


	static const ICHAR sqlShortcutCost[] =
	TEXT("SELECT `Name`, `Target`,`Directory_` FROM `Shortcut` WHERE `Component_`=? AND `Directory_`=?");
	
	enum iscEnum
	{
		iscShortcutName = 1,
		iscTarget,
		iscDirectory,
		iscNextEnum
	};

	const int iShortcutSize = 1000; // estimate of disk cost for shortcut creation
	IMsiRecord* piErrRec;
	if (!m_pCostView)
	{
		piErrRec = m_riEngine.OpenView(sqlShortcutCost, ivcFetch, *&m_pCostView);
		if (piErrRec)
			return piErrRec;
	}
	else
		m_pCostView->Close();

	PMsiServices pServices(m_riEngine.GetServices());
	PMsiRecord pExecRec(&pServices->CreateRecord(2));
	pExecRec->SetMsiString(1, riComponentString);
	pExecRec->SetMsiString(2, riDirectoryString);
	if ((piErrRec = m_pCostView->Execute(pExecRec)) != 0)
		return piErrRec;

	for(;;)
	{
		PMsiRecord pQueryRec(m_pCostView->Fetch());
		if (!pQueryRec)
			break;

		// Our new shortcut will overwrite any existing shortcut
		PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
		PMsiPath pDestPath(0);
		if ((piErrRec = pDirectoryMgr->GetTargetPath(*MsiString(pQueryRec->GetMsiString(iscDirectory)),*&pDestPath)) != 0)
			return piErrRec; 
		Bool fLFN = ((m_riEngine.GetMode() & iefSuppressLFN) == 0 && pDestPath->SupportsLFN()) ? fTrue : fFalse;
		MsiString strShortcutName;
		if((piErrRec = pServices->ExtractFileName(pQueryRec->GetString(iscShortcutName),fLFN,*&strShortcutName)) != 0)
			return piErrRec;

		ifsEnum ifsExistingState;
		Bool fShouldInstall;
		unsigned int uiExistingFileSize;
		Bool fInUse;
		piErrRec = pDestPath->GetFileInstallState(*strShortcutName,*MsiString(*TEXT("")),*MsiString(*TEXT("")),
																/* pHash=*/ 0, ifsExistingState,
																fShouldInstall,&uiExistingFileSize, &fInUse, icmOverwriteAllFiles, NULL);

		// iisAbsent costs
		iNoRbRemoveCost -= uiExistingFileSize;

		// iisLocal costs
		unsigned int uiDestClusteredSize;
		if ((piErrRec = pDestPath->ClusteredFileSize(iShortcutSize, uiDestClusteredSize)) != 0)
			return piErrRec;
		iLocalCost += uiDestClusteredSize;
		iSourceCost += uiDestClusteredSize;
		iARPLocalCost += uiDestClusteredSize;
		iNoRbLocalCost += uiDestClusteredSize;
		iNoRbSourceCost += uiDestClusteredSize;
		iNoRbARPLocalCost += uiDestClusteredSize;
		if (!fInUse)
		{
			iNoRbLocalCost -= uiExistingFileSize;
			iNoRbSourceCost -= uiExistingFileSize;
			iNoRbARPLocalCost -= uiExistingFileSize;
		}

		// file in use
		if(fAddFileInUse && fInUse)
		{
			piErrRec = PlaceFileOnInUseList(m_riEngine, *strShortcutName, *MsiString(pDestPath->GetPath()));
			if(piErrRec)
				return piErrRec;
		}
	}
	return 0;
}



/*---------------------------------------------------------------------------
	WriteIniFile cost adjuster
---------------------------------------------------------------------------*/
class CMsiIniFileCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);
public:  // constructor
	CMsiIniFileCost(IMsiEngine& riEngine);
protected:
	~CMsiIniFileCost();
private:
	//	IMsiRecord* GetDiffFileCost(const IMsiString& riDirectoryString, const ICHAR* szFile, unsigned int& riAddCost, unsigned int& riRemoveCost);
};
CMsiIniFileCost::CMsiIniFileCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine){}
CMsiIniFileCost::~CMsiIniFileCost(){}



IMsiRecord* CMsiIniFileCost::Initialize()
//-------------------------------------------
{
	const ICHAR sqlInitIniFile[] = TEXT("SELECT `Component_`,`DirProperty` FROM `IniFile`");	

	enum iifInitEnum
	{
		iifInitComponent = 1,
		iifInitDirectory,
		iifInitNextEnum
	};
	PMsiView pView(0);
	IMsiRecord* piErrRec = m_riEngine.OpenView(sqlInitIniFile, ivcFetch, *&pView);
	if (piErrRec)
	{
		if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return piErrRec;
		else
		{
			piErrRec->Release();
			return 0;
		}
	}

	if ((piErrRec = pView->Execute(0)) != 0)
		return piErrRec;

	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	for(;;)
	{
		PMsiRecord pRec(pView->Fetch());
		if (!pRec)
			break;

		MsiString strComponent(pRec->GetMsiString(iifInitComponent));
		MsiString strDirectory;
		if(!pRec->IsNull(iifInitDirectory))
			strDirectory = (pRec->GetMsiString(iifInitDirectory));
		else
			strDirectory = *IPROPNAME_WINDOWS_FOLDER;
		piErrRec = pSelectionMgr->RegisterComponentDirectory(*strComponent,*strDirectory);
		if (piErrRec)
			return piErrRec;
	}
	return 0;
}


IMsiRecord* CMsiIniFileCost::GetDynamicCost(const IMsiString& /*riComponentString*/, const IMsiString& /*riDirectoryString*/,
										 Bool /*fAddFileInUse*/, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
//------------------------------------------
{
	// no IniFile costing has been performed ever (even in Darwin 1.0) and this was not compelling
	// enough to add for later versions of Darwin

	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;
	return 0;
}

/*
BEGIN: CODE THAT HAS BEEN TURNED OFF SINCE DARWIN 1.0, part of CMsiIniFileCost::GetDynamicCost

	const ICHAR sqlIniFileCost[] =
	TEXT("SELECT `FileName`, `Section`,`Key`, `Value` FROM `IniFile` WHERE `Component_`=? AND `DirProperty`=? ORDER BY `FileName`");

	enum idfEnum
	{
		idcFileName = 1,
		idcSection,
		idcKey,
		idcValue,
		idcNextEnum
	};
	
	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = 0;
	IMsiRecord* piErrRec;
	if (!m_pCostView)
	{
		IMsiRecord* piErrRec = m_riEngine.OpenView(sqlIniFileCost, ivcFetch, *&m_pCostView);
		if (piErrRec)
		{
			if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
				return piErrRec;
			else
			{
				piErrRec->Release();
				return 0;
			}
		}
	}
	else
		m_pCostView->Close();

	PMsiServices pServices(m_riEngine.GetServices());
	PMsiRecord pExecRec(&pServices->CreateRecord(2));
	pExecRec->SetMsiString(1, riComponentString);
	pExecRec->SetMsiString(2, riDirectoryString);
	if ((piErrRec = m_pCostView->Execute(pExecRec)) != 0)
		return piErrRec;

	return 0; //!! Until debugged!

	PMsiRecord pIniFileRec(0);
	MsiString strFileName;
	unsigned int iAddCost = 0;
	unsigned int iDelCost = 0;
	for(;;)
	{
		pIniFileRec = m_pCostView->Fetch();
		if(pIniFileRec && strFileName.Compare(iscExact, pIniFileRec->GetString(idcFileName)))
		{
			// we are still on the old file
			iAddCost += MsiString(pIniFileRec->GetMsiString(idcSection)).TextSize();
			iAddCost += MsiString(pIniFileRec->GetMsiString(idcKey)).TextSize();
			iAddCost += MsiString(pIniFileRec->GetMsiString(idcValue)).TextSize();
			iDelCost = iAddCost;
		}
		else
		{
			if(strFileName.TextSize())
			{
				// adjust for cluster size
				if((piErrRec = GetDiffFileCost(riDirectoryString, strFileName, iAddCost, iDelCost)) != 0)
					return piErrRec;
				iLocalCost += iAddCost;
				iNoRbLocalCost += iAddCost;
				iSourceCost += iAddCost;
				iNoRbSourceCost += iAddCost;
				iRemoveCost -= iDelCost; // remove cost is negative
				iNoRbRemoveCost -= iDelCost;
				iAddCost = 0;
				iDelCost = 0;
			}
			if(!pIniFileRec)
				break;
			strFileName = pIniFileRec->GetMsiString(idcFileName);
		}
	}
	return 0;
}


IMsiRecord* CMsiIniFileCost::GetDiffFileCost(const IMsiString& riDirectoryString, const ICHAR* szFile, unsigned int& riAddCost, unsigned int& riRemoveCost)
{
	PMsiDirectoryManager piDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	unsigned int iExistingCost = 0;
	unsigned int iExistingClusteredCost = 0;
	PMsiPath piPath(0);
	IMsiRecord* piErrRec;
	if ((piErrRec = piDirectoryMgr->GetTargetPath(riDirectoryString,*&piPath)) != 0)
		return piErrRec;
	Bool fExists;
	piErrRec = piPath->FileExists(szFile,fExists);
	if (piErrRec)
		return piErrRec;

	if(fExists != fFalse)
	{
		piErrRec = piPath->FileSize(szFile,iExistingCost);
		if (piErrRec)
			return piErrRec;
		if ((piErrRec = piPath->ClusteredFileSize(iExistingCost,iExistingClusteredCost)) != 0)
			return piErrRec;
	}
	riAddCost = riAddCost + iExistingCost;
	if ((piErrRec = piPath->ClusteredFileSize(riAddCost,riAddCost)) != 0)
		return piErrRec;
	riAddCost = riAddCost - iExistingClusteredCost;

	if(iExistingCost >= riRemoveCost)
	{
		riRemoveCost = iExistingCost - riRemoveCost;
		{
			if ((piErrRec = piPath->ClusteredFileSize(riRemoveCost,riRemoveCost)) != 0)
				return piErrRec;
			Assert(iExistingClusteredCost > riRemoveCost);
			riRemoveCost = iExistingClusteredCost - riRemoveCost;
		}
	}
	else
		riRemoveCost = 0;// may be missing the ini file, hence may not get back any space
	return 0;
}

  END: CODE THAT HAS BEEN TURNED OFF SINCE DARWIN 1.0
*/



const ICHAR szIndicGrouping[] = TEXT("3;2;0");

void RetrieveNumberFormat(NUMBERFMT *psNumFmt)
/*---------------------------------------------------------------------------------------------
 helper function to obtain number formatting information for formatting the KB value
 used in the OutOfDiskSpace error messages.  These are whole number values so we don't
 want to use any decimals (1496.00 looks ugly!)

 the remaining information in the NUMBERFMT structure is based upon the current user's
 locale.  All WI system information is displayed in the user's locale and not the package
 language

  -NegativeOrder is REG_SZ with a number of 0,1,2,3, or 4
  -Grouping is REG_SZ of #;0 or #;2;0 where # is in range 0-9 (int value is in range 0-9 or 32)
------------------------------------------------------------------------------------------------*/
{
	if (!psNumFmt)
		return;

	ICHAR szDecSep[5] = {0};
	ICHAR szThousandSep[5] = {0};
	ICHAR szGrouping[6] = {0};
	ICHAR szNegativeOrder[2] = {0};

	// retrieve locale info
	AssertNonZero(GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, szDecSep, sizeof(szDecSep)/sizeof(ICHAR)));
	AssertNonZero(GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szThousandSep, sizeof(szThousandSep)/sizeof(ICHAR)));
	AssertNonZero(GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szGrouping, sizeof(szGrouping)/sizeof(ICHAR)));
	AssertNonZero(GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_INEGNUMBER, szNegativeOrder, sizeof(szNegativeOrder)/sizeof(ICHAR)));

	// no digits with decimal or leading zero
	psNumFmt->NumDigits = 0;
	psNumFmt->LeadingZero = 0;

	// use proper separators for locale
	psNumFmt->lpDecimalSep = new ICHAR[5];
	if (psNumFmt->lpDecimalSep)
		lstrcpy(psNumFmt->lpDecimalSep, szDecSep);
	psNumFmt->lpThousandSep = new ICHAR[5];
	if (psNumFmt->lpThousandSep)
		lstrcpy(psNumFmt->lpThousandSep, szThousandSep);

	psNumFmt->NegativeOrder = *szNegativeOrder - '0';
	if (psNumFmt->NegativeOrder > 4)
		psNumFmt->NegativeOrder = 1; // default -- invalid entry

	// determine grouping
	if (0 == lstrcmp(szGrouping, szIndicGrouping))
		psNumFmt->Grouping = 32; // indic language
	else if (*szGrouping - '0' < 0 || *szGrouping - '0' > 9)
		psNumFmt->Grouping = 3; // default -- invalid entry
	else
		psNumFmt->Grouping = *szGrouping - '0';
}

IMsiRecord* PostOutOfDiskSpaceError(IErrorCode iErr, const ICHAR* szPath, int iVolCost, int iVolSpace)
/*-----------------------------------------------------------------------------------------------------
 Helper function for setting up the OutOfDiskSpace error
-------------------------------------------------------------------------------------------------------*/
{
	// format space requirements
	NUMBERFMT sNumFmt;
	memset((void*)&sNumFmt, 0x00, sizeof(NUMBERFMT));
	RetrieveNumberFormat(&sNumFmt);

	MsiString strVolSpace(iVolSpace);
	int cchRequired = GetNumberFormat(LOCALE_USER_DEFAULT, 0, (const ICHAR*)strVolSpace, &sNumFmt, NULL, 0);
	ICHAR *szVolSpace = new ICHAR[cchRequired];
	if (szVolSpace)
		AssertNonZero(GetNumberFormat(LOCALE_USER_DEFAULT, 0, (const ICHAR*)strVolSpace, &sNumFmt, szVolSpace, cchRequired));
	MsiString strVolCost(iVolCost);
	cchRequired = GetNumberFormat(LOCALE_USER_DEFAULT, 0, (const ICHAR*)strVolCost, &sNumFmt, NULL, 0);
	ICHAR *szVolCost = new ICHAR[cchRequired];
	if (szVolCost)
		AssertNonZero(GetNumberFormat(LOCALE_USER_DEFAULT, 0, (const ICHAR*)strVolCost, &sNumFmt, szVolCost, cchRequired));

	// set error
	IMsiRecord* piErrRec = PostError(iErr, szPath, szVolCost, szVolSpace);

	// cleanup
	if (szVolSpace)
		delete [] szVolSpace;
	if (szVolCost)
		delete [] szVolCost;
	if (sNumFmt.lpDecimalSep)
		delete [] sNumFmt.lpDecimalSep;
	if (sNumFmt.lpThousandSep)
		delete [] sNumFmt.lpThousandSep;

	return piErrRec;
}

extern iesEnum ResolveSource(IMsiEngine& riEngine);

/*---------------------------------------------------------------------------
	InstallValidate action
---------------------------------------------------------------------------*/
iesEnum InstallValidate(IMsiEngine& riEngine)
{
	PMsiServices pServices(riEngine.GetServices());
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiSelectionManager pSelectionMgr(riEngine, IID_IMsiSelectionManager);
	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;

	PMsiRecord pProgress = &pServices->CreateRecord(2);
	PMsiRecord pErrRec(0);
	PMsiRecord pFileInUseLogRecord = &pServices->CreateRecord(6);


	// If in verbose mode, log the final feature/component states
	if (FDiagnosticModeSet(dmVerboseDebugOutput|dmVerboseLogging))
	{
		const ICHAR sqlLog[][80] = {TEXT(" SELECT `Feature`, `Action`, `ActionRequested`, `Installed` FROM `Feature`"),
			                        TEXT(" SELECT `Component`, `Action`, `ActionRequest`, `Installed` FROM `Component`")};
		const ICHAR szLogType[][12] = {TEXT("Feature"),TEXT("Component")};
		const ICHAR szState[][15] = {TEXT("Absent"),TEXT("Local"),TEXT("Source"),TEXT("Reinstall"),
			                         TEXT("Advertise"),TEXT("Current"),TEXT("FileAbsent"), TEXT(""), TEXT(""), TEXT(""), TEXT(""),
									 TEXT("HKCRAbsent"), TEXT("HKCRFileAbsent"), TEXT("Null")};

		const int iMappedNullInteger = 13;
		PMsiRecord pLogRec(0);
		PMsiView pView(0);
		for (int x = 0;x < 2;x++)
		{
			pErrRec = riEngine.OpenView(sqlLog[x], ivcFetch, *&pView);
			if (!pErrRec)
			{
				pErrRec = pView->Execute(0);
				if (!pErrRec)
				{

					while((pLogRec = pView->Fetch()) != 0)
					{
						ICHAR rgch[256];
						
						MsiString strKey = pLogRec->GetMsiString(1);
						int iAction = pLogRec->GetInteger(2);
						if (iAction == iMsiNullInteger) iAction = iMappedNullInteger;

						int iActionRequested = (iisEnum) pLogRec->GetInteger(3);
						if (iActionRequested == iMsiNullInteger) iActionRequested = iMappedNullInteger;

						int iInstalled = (iisEnum) pLogRec->GetInteger(4);
						if (iInstalled == iMsiNullInteger) iInstalled = iMappedNullInteger;

						wsprintf(rgch, TEXT("%s: %s; Installed: %s;   Request: %s;   Action: %s"), 
							szLogType[x],(const ICHAR*) strKey, szState[iInstalled], szState[iActionRequested], szState[iAction]);
						DEBUGMSGV(rgch);
					
					}
				}
				pView->Close();
			}
		}
	}

	Bool fRetry = fTrue;
	if ( !g_MessageContext.IsOEMInstall() )
	{
	// there's little point in doing these checks for OEM installs since they shouldn't be
	// running any app while blasting software on the machines and they know that there
	// is enough room on the drive(s).

	// if any files are in use, give the user a chance to free them up before continuing.

	riEngine.SetMode(iefCompileFilesInUse, fTrue);

	do
	{
		if (fRetry)
		{
			Bool fCancel;
			if ((pErrRec = pSelectionMgr->RecostAllComponents(fCancel)) != 0)
			{
				int iErr = pErrRec->GetInteger(1);
				if (iErr == imsgUser)
					return iesUserExit;
				// If Selection mgr not active, there's simply no costing to do
				if (iErr != idbgSelMgrNotInitialized)
					return riEngine.FatalError(*pErrRec);
			}
			if (fCancel)
				return iesUserExit;
		}

		fRetry = fFalse;
		if (pDatabase->FindTable(*MsiString(sztblFilesInUse)) != itsUnknown)
		{
			PMsiTable pFileInUseTable = 0;
			pDatabase->LoadTable(*MsiString(*sztblFilesInUse),0,*&pFileInUseTable);
			int iColFileName = pFileInUseTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFilesInUse_colFileName));
			int iColFilePath = pFileInUseTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblFilesInUse_colFilePath));
			int iColProcessID = pFileInUseTable->CreateColumn(
												icdPrimaryKey + icdNullable + icdLong,
												*MsiString(*sztblFilesInUse_colProcessID));
			int iColWindowTitle = pFileInUseTable->CreateColumn(
												icdPrimaryKey + icdNullable + icdString,
												*MsiString(*sztblFilesInUse_colWindowTitle));
			Assert(iColFileName > 0 && iColFilePath > 0 && iColWindowTitle > 0);
			Assert(pFileInUseTable);
			PMsiCursor pFileInUseCursor = pFileInUseTable->CreateCursor(fFalse);
			Assert(pFileInUseCursor);
			PMsiCursor pFileInUseSearchCursor = pFileInUseTable->CreateCursor(fFalse);
			Assert(pFileInUseSearchCursor);
			pFileInUseSearchCursor->SetFilter(iColumnBit(iColProcessID) | iColumnBit(iColWindowTitle));

			// Assume initial maximum number of modules in use (two record fields per module).
			// We'll grow the message record below if estimate is too small.

			// structure to ensure that we call Services::GetModuleUsage on entry and exit of scope
			// this release the internal Services CDetect object that is holding on to tons of
			// allocated space (possibly stale, hence the call on constructor as well)

			struct CEnsureReleaseFileUseObj{
				CEnsureReleaseFileUseObj(IMsiServices& riServices): m_riServices(riServices)
				{
					StartAfresh();
				}
				~CEnsureReleaseFileUseObj()
				{
					StartAfresh();
				}
				void StartAfresh()
				{
					PEnumMsiRecord pEnumModule(0);
					AssertRecord(m_riServices.GetModuleUsage(g_MsiStringNull,*&pEnumModule));
				}
				IMsiServices& m_riServices;
			};

			Assert(pServices);
			CEnsureReleaseFileUseObj EnsureReleaseFileUseObj(*pServices);

			PMsiRecord pFileInUseRecord(0);
			const int iModuleFieldAllocSize = 8;
			int iModuleFieldCount = 0;
			while (pFileInUseCursor->Next())
			{
				if(riEngine.ActionProgress() == imsCancel)
					return iesUserExit;

				MsiString strTitle(pFileInUseCursor->GetString(iColWindowTitle));
				int iProcess = pFileInUseCursor->GetInteger(iColProcessID);
				if ( iProcess != iMsiNullInteger || strTitle.TextSize() )
					// temporary row we've added below
					continue;
				
				MsiString strFileName(pFileInUseCursor->GetString(iColFileName));
				MsiString strFilePath(pFileInUseCursor->GetString(iColFilePath));
				MsiString strProcessName = strFilePath;
				PEnumMsiRecord pEnumModule(0);
				pErrRec = pServices->GetModuleUsage(*strFileName,*&pEnumModule);
				if (pErrRec)
				{
					if (riEngine.Message(imtInfo, *pErrRec) == imsCancel)
						return iesUserExit;
				}
				else if (pEnumModule)
				{
					PMsiRecord pRecProcess(0);
					while (pEnumModule->Next(1, &pRecProcess, 0) == S_OK)
					{
						MsiString strProcessName(pRecProcess->GetString(1));
						MsiString strProcessFileName;
#ifdef _WIN64	// !merced
						HWND hWnd = (HWND)pRecProcess->GetHandle(3);				//--merced: changed from <int iWnd> to <HWND hWnd>
#else
						HWND hWnd = (HWND)pRecProcess->GetInteger(3);				//--merced: changed from <int iWnd> to <HWND hWnd>
#endif
						int iProcId = pRecProcess->GetInteger(2);

						ICHAR szTitle[256];
						szTitle[0] = 0;
						if (hWnd != (HWND)((INT_PTR)iMsiNullInteger))
							GetWindowText(hWnd,szTitle,255);					//--merced: 4312 int to ptr

						if (hWnd != (HWND)((INT_PTR)iMsiNullInteger) &&						//--merced: added (HWND)
							(DWORD)iProcId != WIN::GetCurrentProcessId() && // don't display ourselves in FileInUse dialog
							(DWORD)iProcId != (DWORD)riEngine.GetPropertyInt(*MsiString(*IPROPNAME_CLIENTPROCESSID))) // dont display client
						{
							strProcessFileName = strProcessName.Extract(iseAfter,chDirSep);
							if( (strProcessFileName.Compare(iscStartI, TEXT("explorer")) == 0)    // don't display if window owner is explorer.exe
								&& (strProcessFileName.Compare(iscStartI, TEXT("msiexec")) == 0)) // don't display ourselves, PID Only catches service on NT, on 95 concurrent installs																						
																					  // If other cases are found, they go here
							{
								strTitle = szTitle;
								// check if the current window title and process #
								// had already been added to pFileInUseRecord
								pFileInUseSearchCursor->Reset();
								AssertNonZero(pFileInUseSearchCursor->PutString(iColFileName,
																								*strFileName));
								AssertNonZero(pFileInUseSearchCursor->PutString(iColFilePath,
																								*strFilePath));
								AssertNonZero(pFileInUseSearchCursor->PutInteger(iColProcessID,
																								iProcId));
								AssertNonZero(pFileInUseSearchCursor->PutString(iColWindowTitle,
																								*strTitle));
								if ( !pFileInUseSearchCursor->Next() )
								{
									// The current window title is not present in pFileInUseRecord.
									// We add a new row that if we will find later on we know
									// that this process had already been reported.
									AssertNonZero(pFileInUseCursor->PutInteger(iColProcessID,
																							iProcId));
									AssertNonZero(pFileInUseCursor->PutString(iColWindowTitle,
																							*strTitle));
									AssertNonZero(pFileInUseCursor->Insert());
									// If initial estimate too low, grow the record.
									if (iModuleFieldCount % iModuleFieldAllocSize == 0)
									{
										PMsiRecord pNewRecord = &pServices->CreateRecord(iModuleFieldCount + iModuleFieldAllocSize);
										for (int i = 0; iModuleFieldCount && i <= iModuleFieldCount; i++)
											pNewRecord->SetString(i,pFileInUseRecord->GetString(i));
										pFileInUseRecord = pNewRecord;

										// Put a description string for the files-in-use dialog in the zeroth field
										if (iModuleFieldCount == 0)
										{
											pFileInUseRecord->SetMsiString(0, *MsiString(riEngine.GetErrorTableString(imsgFileInUseDescription)));
										}
									}

									pFileInUseRecord->SetMsiString(++iModuleFieldCount,*strProcessName); 
									pFileInUseRecord->SetString(++iModuleFieldCount,szTitle);
								}
							}
						}
						if (FDiagnosticModeSet(dmLogging))
						{
							AssertNonZero(pFileInUseLogRecord->ClearData());
							ISetErrorCode(pFileInUseLogRecord,Imsg(imsgFileInUseLog));
							AssertNonZero(pFileInUseLogRecord->SetMsiString(2,*strFilePath));
							AssertNonZero(pFileInUseLogRecord->SetMsiString(3,*strFileName));
							AssertNonZero(pFileInUseLogRecord->SetMsiString(4,*strProcessName));
							AssertNonZero(pFileInUseLogRecord->SetInteger(5,iProcId));
							AssertNonZero(pFileInUseLogRecord->SetString(6,szTitle)); // could be empty string
							riEngine.Message(imtInfo,*pFileInUseLogRecord);
						}
					}
				}
			}
			if (pFileInUseRecord)
			{
				DEBUGMSG1(TEXT("%d application(s) had been reported to have files in use."),
							 (const ICHAR*)(INT_PTR)(iModuleFieldCount/2));
				imsEnum imsReturn = riEngine.Message(imtFilesInUse, *pFileInUseRecord);
				pFileInUseCursor->Reset();
				while (pFileInUseCursor->Next())
				{
					pFileInUseCursor->Delete();
				}

				if (imsReturn == imsRetry) // IDRETRY
				{
					Bool fUnlocked = pDatabase->LockTable(*MsiString(sztblFilesInUse),fFalse);
					Assert(fUnlocked == fTrue);
					fRetry = fTrue;
				}
				else if (imsReturn == imsCancel) // IDCANCEL
					return iesUserExit;

				// Anything else (IDIGNORE, for instance) means we just go on (no retry)
			}
		}
	}while (fRetry);

	riEngine.SetMode(iefCompileFilesInUse, fFalse);

	// verify that each target volume has enough space for the install
	// If not, a fatal error will be produced.
	fRetry = fTrue;
	while(fRetry)
	{
		if(riEngine.ActionProgress() == imsCancel)
			return iesUserExit;
		Bool fOutOfNoRbDiskSpace;
		Bool fOutOfSpace;
		Bool fUserCancelled = fFalse;
		
		fOutOfSpace = pSelectionMgr->DetermineOutOfDiskSpace(&fOutOfNoRbDiskSpace, &fUserCancelled);
		if (fUserCancelled)
			return iesUserExit;
			
		if(fOutOfSpace == fTrue)
		{
			PMsiTable pVolTable = pSelectionMgr->GetVolumeCostTable();
			if (pVolTable)
			{
				PMsiCursor pVolCursor = pVolTable->CreateCursor(fFalse);
				Assert (pVolCursor);
				int iColSelVolumeObject = pVolTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblVolumeCost_colVolumeObject));
				int iColSelVolumeCost = pVolTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblVolumeCost_colVolumeCost));
				int iColSelNoRbVolumeCost = pVolTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblVolumeCost_colNoRbVolumeCost));
				Assert(iColSelVolumeObject > 0);
				Assert(iColSelVolumeCost > 0);
				fRetry = fFalse; // if no volumes report out of space we will break out of loop
				while (fRetry == fFalse && pVolCursor->Next())
				{
					PMsiVolume pVolume = (IMsiVolume*) pVolCursor->GetMsiData(iColSelVolumeObject);
					Assert(pVolume);
					
					// Disk cost numbers are stored in multiples of 512 bytes, so divide by 2 for KB 
					int iVolCost = (pVolCursor->GetInteger(iColSelVolumeCost))/2;
					int iNoRbVolCost = (pVolCursor->GetInteger(iColSelNoRbVolumeCost))/2;
					int iVolSpace = (pVolume->FreeSpace())/2;
					if (iVolCost > iVolSpace)
					{
						// Check to see if there would be enough space to install were rollback to be turned off.
						MsiString strRollbackPrompt = riEngine.GetPropertyFromSz(IPROPNAME_PROMPTROLLBACKCOST);
						bool fRbCostSilent = strRollbackPrompt.Compare(iscExactI,IPROPVALUE_RBCOST_SILENT) ? true : false;
						bool fRbCostFail = strRollbackPrompt.Compare(iscExactI,IPROPVALUE_RBCOST_FAIL) ? true : false;
						imtEnum imtOptions = imtEnum(imtOk);
						MsiString strPath(pVolume->GetPath());
						if (fOutOfNoRbDiskSpace == fTrue || fRbCostFail)
						{	// Fail whether there's no space with rollback turned off or not.
							imtOptions = imtEnum(imtRetryCancel | imtOutOfDiskSpace);
							pErrRec = PostOutOfDiskSpaceError(Imsg(imsgOutOfDiskSpace), (const ICHAR*)strPath, fRbCostSilent ? iNoRbVolCost : iVolCost, iVolSpace);
						}
						else if (fRbCostSilent)
						{	// Silently disable rollback
							fRetry = fFalse;
							riEngine.SetMode(iefRollbackEnabled, fFalse);
							pErrRec = 0;
						}
						else
						{	// IPROPNAME_PROMPTROLLBACKCOST either not defined, or anything but IPROPVALUE_RBCOST_FAIL or
							// IPROPVALUE_RBCOST_SILENT, so default to prompting the user.
							imtOptions = imtEnum(imtAbortRetryIgnore | imtOutOfDiskSpace);
							pErrRec = PostOutOfDiskSpaceError(Imsg(imsgOutOfRbDiskSpace), (const ICHAR*)strPath, iVolCost, iVolSpace);
						}
	
						if (pErrRec)
						{
							switch(riEngine.Message(imtOptions, *pErrRec))
							{
							case imsCancel:
							case imsAbort:
								pErrRec = PostError(Imsg(imsgConfirmCancel));
								switch(riEngine.Message(imtEnum(imtUser+imtYesNo+imtDefault2), *pErrRec))
								{
								case imsNo:
									fRetry = fTrue;
									break;
								default: // imsNone, imsYes
									return iesUserExit;
								};
								break;
							case imsRetry:
								fRetry = fTrue;
								break;
							case imsIgnore:
								fRetry = fFalse;
								riEngine.SetMode(iefRollbackEnabled, fFalse);
								break;
							default: // imsNone
								return iesFailure;
							}
						}
					}
				}
			}
			else
			{
				// no volume table even though DetermineOutOfDiskSpace failed
				AssertSz(0,TEXT("Couldn't get volume table in InstallValidate"));
				break;
			}
		}
		else // not out of disk space
			break;
	}

	} // endif IsOEMInstall
		
	bool fRemoveAll = false;

	// If the "REMOVE" property is not already set to all-uppercase "ALL", set it to that
	// value if it is currently mixed-case "All", OR if all features are being removed.
	// This will allow actions following InstallValidate to use a condition of "REMOVE=ALL"
	// to conclusively fire if the entire product is being removed.
	MsiString strRemoveValue = riEngine.GetPropertyFromSz(IPROPNAME_FEATUREREMOVE);
	if (!strRemoveValue.Compare(iscExact, IPROPVALUE_FEATURE_ALL))
	{
		if (strRemoveValue.Compare(iscExactI, IPROPVALUE_FEATURE_ALL) || !FFeaturesInstalled(riEngine, fFalse))
		{
			AssertNonZero(riEngine.SetProperty(*MsiString(*IPROPNAME_FEATUREREMOVE), *MsiString(*IPROPVALUE_FEATURE_ALL)));
			fRemoveAll = true;
		}
	}
	else
	{
		fRemoveAll = true;
	}

	// for certain packages, we need to call the ResolveSource action at this point if we are not
	// performing a full uninstall
	if(false == fRemoveAll &&
		riEngine.FPerformAppcompatFix(iacsForceResolveSource))
	{
		DEBUGMSG(TEXT("Resolving source for application compatibility with this install."));
		iesEnum iesRet = ResolveSource(riEngine);
		if(iesRet != iesSuccess)
			return iesRet;
	}
	
	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;
		
	return iesSuccess;
}


/*---------------------------------------------------------------------------
	ReserveCost costing (there is no ReserveCost action
---------------------------------------------------------------------------*/
class CMsiReserveCost : public CMsiFileCost
{
public:
	IMsiRecord*   __stdcall Initialize();
	IMsiRecord*   __stdcall GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool fAddFileInUse, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost);
public:  // constructor
	CMsiReserveCost(IMsiEngine& riEngine);
protected:
	~CMsiReserveCost();
private:
};
CMsiReserveCost::CMsiReserveCost(IMsiEngine& riEngine) : CMsiFileCost(riEngine){}
CMsiReserveCost::~CMsiReserveCost(){}


IMsiRecord* CMsiReserveCost::Initialize()
//-------------------------------------------
{
	const ICHAR sqlInitReserveCost[] =
	TEXT("SELECT `Component_`,`ReserveFolder` FROM `ReserveCost`");

	enum ircInitEnum
	{
		ircInitComponent = 1,
		ircReserveFolder,
		ircInitNextEnum
	};
	PMsiView pView(0);
	IMsiRecord* piErrRec = m_riEngine.OpenView(sqlInitReserveCost, ivcEnum(ivcFetch|ivcUpdate), *&pView);
	if (piErrRec)
	{
		if(piErrRec->GetInteger(1) != idbgDbQueryUnknownTable)
			return piErrRec;
		else
		{
			piErrRec->Release();
			return 0;
		}
	}

	if ((piErrRec = pView->Execute(0)) != 0)
		return piErrRec;

	PMsiSelectionManager pSelectionMgr(m_riEngine, IID_IMsiSelectionManager);
	for(;;)
	{
		PMsiRecord pRec(pView->Fetch());
		if (!pRec)
			break;

		MsiString strComponent(pRec->GetMsiString(ircInitComponent));
		MsiString strReserveFolder(pRec->GetMsiString(ircReserveFolder));
		if (strReserveFolder.TextSize())
		{
			piErrRec = pSelectionMgr->RegisterComponentDirectory(*strComponent,*strReserveFolder);
			if (piErrRec)
				return piErrRec;
		}
	}
	return 0;
}


IMsiRecord* CMsiReserveCost::GetDynamicCost(const IMsiString& riComponentString, const IMsiString& riDirectoryString,
										 Bool /*fAddFileInUse*/, int& iRemoveCost, int& iNoRbRemoveCost, int& iLocalCost,
										 int& iNoRbLocalCost, int& iSourceCost, int& iNoRbSourceCost, int& iARPLocalCost, int& iNoRbARPLocalCost)
//------------------------------------------
{
	const ICHAR sqlReserveCost[] =
	TEXT("SELECT `ReserveFolder`,`Directory_`,`ReserveLocal`,`ReserveSource` FROM `ReserveCost`,`Component` WHERE `Component`=`Component_` ")
	TEXT("AND Component_=?");

	enum idfEnum
	{
		ircReserveFolder = 1,
		ircComponentDir,
		ircLocalCost,
		ircSourceCost,
		idfNextEnum
	};

	iRemoveCost = iNoRbRemoveCost = iLocalCost = iNoRbLocalCost = iSourceCost = iNoRbSourceCost = iARPLocalCost = iNoRbARPLocalCost = 0;

	// ReserveCost cost adjuster will never get registered
	// and called unless the ReserveCost table is present.
	IMsiRecord* piErrRec;
	if (!m_pCostView)
	{
		piErrRec = m_riEngine.OpenView(sqlReserveCost, ivcFetch, *&m_pCostView);
		if (piErrRec)
			return piErrRec;
	}
	else
		m_pCostView->Close();

	PMsiDirectoryManager pDirectoryMgr(m_riEngine, IID_IMsiDirectoryManager);
	PMsiServices pServices(m_riEngine.GetServices());
	PMsiRecord pExecRec(&pServices->CreateRecord(1));
	pExecRec->SetMsiString(1, riComponentString);
	if ((piErrRec = m_pCostView->Execute(pExecRec)) != 0)
		return piErrRec;

	for(;;)
	{
		PMsiRecord pReserveRec(m_pCostView->Fetch());
		if (!pReserveRec)
			break;

		// If no ReserveFolder given in the table, use the component's directory
		MsiString strReserveFolder(pReserveRec->GetMsiString(ircReserveFolder));
		if (strReserveFolder.TextSize() == 0)
			strReserveFolder = pReserveRec->GetMsiString(ircComponentDir);

		if (riDirectoryString.Compare(iscExact,strReserveFolder) == 0)
			continue;

		PMsiPath pReservePath(0);
		piErrRec = pDirectoryMgr->GetTargetPath(*strReserveFolder,*&pReservePath);
		if (piErrRec)
			return piErrRec;

		unsigned int uiClusteredSize;
		// Local costs
		if ((piErrRec = pReservePath->ClusteredFileSize(pReserveRec->GetInteger(ircLocalCost), uiClusteredSize)) != 0)
			return piErrRec;
		iLocalCost += uiClusteredSize;
		iNoRbLocalCost += uiClusteredSize;

		iARPLocalCost += uiClusteredSize;
		iNoRbARPLocalCost += uiClusteredSize;

		iRemoveCost -= uiClusteredSize;
		iNoRbRemoveCost -= uiClusteredSize;

		// Source costs
		if ((piErrRec = pReservePath->ClusteredFileSize(pReserveRec->GetInteger(ircSourceCost), uiClusteredSize)) != 0)
			return piErrRec;
		iSourceCost += uiClusteredSize;
		iNoRbSourceCost += uiClusteredSize;
	}
	return 0;
}

/*---------------------------------------------------------------------------
	FileCost action
---------------------------------------------------------------------------*/
iesEnum FileCost(IMsiEngine& riEngine)
{
	if ((riEngine.GetMode() & iefSecondSequence) && g_scServerContext == scClient)
	{
		DEBUGMSG("Skipping FileCost: action already run in this engine.");
		return iesNoAction;
	}

	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiServices pServices(riEngine.GetServices());
	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;

	// Register a RemoveFile cost adjuster only if the RemoveFile
	// table is present.  If so, must be registered before File cost adjuster
	PMsiRecord pErrRec(0);
	PMsiSelectionManager pSelectionMgr(riEngine, IID_IMsiSelectionManager);
	if (pDatabase->FindTable(*MsiString(sztblRemoveFile)) != itsUnknown)
	{
		PMsiCostAdjuster pRemoveFileCostAdjuster = new CMsiRemoveFileCost(riEngine);
		if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pRemoveFileCostAdjuster))
			return riEngine.FatalError(*pErrRec);
	}

	// File cost adjuster
	PMsiCostAdjuster pFileCostAdjuster = new CMsiFileCost(riEngine);
	if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pFileCostAdjuster))
		return riEngine.FatalError(*pErrRec);

	// Registry cost adjuster
	PMsiCostAdjuster pRegistryCostAdjuster = new CMsiRegistryCost(riEngine);
	if ((pErrRec = pSelectionMgr->RegisterCostAdjuster(*pRegistryCostAdjuster)) != 0)
		return riEngine.FatalError(*pErrRec);

	// Register an IniFile cost adjuster only if the IniFile
	// table is present
	if (pDatabase->FindTable(*MsiString(sztblIniFile)) != itsUnknown)
	{
		PMsiCostAdjuster pIniFileCostAdjuster = new CMsiIniFileCost(riEngine);
		if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pIniFileCostAdjuster))
			return riEngine.FatalError(*pErrRec);
	}

	// Register a MoveFile cost adjuster only if the MoveFile
	// table is present
	if (pDatabase->FindTable(*MsiString(sztblMoveFile)) != itsUnknown)
	{
		PMsiCostAdjuster pMoveFileCostAdjuster = new CMsiMoveFileCost(riEngine);
		if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pMoveFileCostAdjuster))
			return riEngine.FatalError(*pErrRec);
	}

	// Register a DuplicateFile cost adjuster only if the DuplicateFile
	// table is present
	if (pDatabase->FindTable(*MsiString(sztblDuplicateFile)) != itsUnknown)
	{
		PMsiCostAdjuster pDupFileCostAdjuster = new CMsiDuplicateFileCost(riEngine);
		if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pDupFileCostAdjuster))
			return riEngine.FatalError(*pErrRec);
	}

	// Register a ReserveCost cost adjuster only if the ReserveCost
	// table is present
	if (pDatabase->FindTable(*MsiString(sztblReserveCost)) != itsUnknown)
	{
		PMsiCostAdjuster pReserveCostAdjuster = new CMsiReserveCost(riEngine);
		if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pReserveCostAdjuster))
			return riEngine.FatalError(*pErrRec);
	}

	// Register a Shortcut cost adjuster only if the Shortcut
	// table is present
	if (pDatabase->FindTable(*MsiString(sztblShortcut)) != itsUnknown)
	{
		PMsiCostAdjuster pShortcutCostAdjuster = new CMsiShortcutCost(riEngine);
		if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pShortcutCostAdjuster))
			return riEngine.FatalError(*pErrRec);
	}

	// Register a SFPCatalog cost adjuster only if the SFPCatalog and FileSFPCatalog tables
	// are present and system is Win9X > Millennium
	if ((pDatabase->FindTable(*MsiString(sztblSFPCatalog)) != itsUnknown) 
		&& (pDatabase->FindTable(*MsiString(sztblFileSFPCatalog)) != itsUnknown)
		&& (MinimumPlatform(true, 4, 90)))
	{
		PMsiCostAdjuster pSFPCatalogCostAdjuster = new CMsiSFPCatalogCost(riEngine);
		if (pErrRec = pSelectionMgr->RegisterCostAdjuster(*pSFPCatalogCostAdjuster))
			return riEngine.FatalError(*pErrRec);
	}

	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;

	return iesSuccess;
}

/*---------------------------------------------------------------------------
	PatchFiles action - applies patch to selected files
---------------------------------------------------------------------------*/

enum ipfqEnum
{
	ipfqFile = 1,
	ipfqFileName,
	ipfqFileSize,
	ipfqDirectory,
	ipfqPatchSize,
	ipfqFileAttributes,
	ipfqPatchAttributes,
	ipfqPatchSequence,
	ipfqFileSequence,
	ipfqComponent,
	ipfqComponentId,
	ipfqNextEnum,
};

static const ICHAR sqlPatchFiles[] =
TEXT("SELECT `File`,`FileName`,`FileSize`,`Directory_`,`PatchSize`,`File`.`Attributes`,`Patch`.`Attributes`,`Patch`.`Sequence`,`File`.`Sequence`,`Component`.`Component`,`Component`.`ComponentId` ")
TEXT("FROM `File`,`Component`,`Patch` ")
TEXT("WHERE `File`=`File_` AND `Component`=`Component_` AND `Action`=1 ")
TEXT("ORDER BY `Patch`.`Sequence`");

iesEnum PatchFiles(IMsiEngine& riEngine)
{
	PMsiServices pServices(riEngine.GetServices());
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	Assert(pDirectoryMgr);
	int fMode = riEngine.GetMode();

	PMsiRecord pErrRec(0);

	// open the views
	PMsiView pMediaView(0);
	PMsiView pPatchView(0);
	MsiString strFirstVolumeLabel;
	
	if((pErrRec = OpenMediaView(riEngine, *&pMediaView, *&strFirstVolumeLabel))       != 0 ||
		(pErrRec = pMediaView->Execute(0))                                   != 0 ||
		(pErrRec = riEngine.OpenView(sqlPatchFiles, ivcFetch, *&pPatchView)) != 0 ||
		(pErrRec = pPatchView->Execute(0))                                   != 0)
	{
		if(pErrRec->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		else
			return riEngine.FatalError(*pErrRec);
	}

	PMsiRecord pRecord(0); // fetched records
	
	int cExecuteFields = IxoPatchApply::Args;
	if(cExecuteFields < IxoAssemblyPatch::Args)
		cExecuteFields = IxoAssemblyPatch::Args;
	PMsiRecord pExecuteRecord = &pServices->CreateRecord(cExecuteFields); // passed to Engine::ExecuteRecord

	iesEnum iesExecute = iesNoAction; // return from Engine::ExecuteRecord

	// determine total size of all files to patch, used for progress
	unsigned int cbTotalCost = 0;
	while((pRecord = pPatchView->Fetch()) != 0)
	{
		Assert(pRecord->GetInteger(ipfqFileSize != iMsiNullInteger));
		Assert(pRecord->GetInteger(ipfqPatchSize != iMsiNullInteger));
		cbTotalCost += pRecord->GetInteger(ipfqFileSize);
		cbTotalCost += pRecord->GetInteger(ipfqPatchSize);
	}

	// set progress total
	unsigned int cbPerTick =0;
	if(cbTotalCost)
	{
		pExecuteRecord->ClearData();
		pExecuteRecord->SetInteger(1, cbTotalCost);
		pExecuteRecord->SetInteger(2, 0); // 0: separate progress and action data messages
		pExecuteRecord->SetInteger(IxoProgressTotal::ByteEquivalent, 1);
		if ((iesExecute = riEngine.ExecuteRecord(ixoProgressTotal,*pExecuteRecord)) != iesSuccess)
			return iesExecute;
	}

	if((pErrRec = pPatchView->Execute(0)) != 0)
		return riEngine.FatalError(*pErrRec);
		
	// start fetching records
	int iFilePatchCount = 0;
	int iMediaEnd = 0;  // set to 0 to force media table fetch
	MsiString strDiskPromptTemplate = riEngine.GetErrorTableString(imsgPromptForDisk);
	bool fCheckCRC = 
		MsiString(riEngine.GetPropertyFromSz(IPROPNAME_CHECKCRCS)).TextSize() ? true : false;
	for(;;)
	{
		pRecord = pPatchView->Fetch();
		if (!pRecord)
		{
			if (iFilePatchCount > 0)
			{
				// Ok, we're done processing all files in the File table.
				// If there are any Media table entries left unprocessed,
				// flush out ChangeMedia operations for each, in case the
				// last file copied was split across disk(s). Otherwise,
				// we'll never change disks to finish copying the last
				// part(s) of the split file.
				PMsiRecord pMediaRec(0);
				while ((pMediaRec = pMediaView->Fetch()) != 0)
				{
					iesExecute = ExecuteChangeMedia(riEngine,*pMediaRec,*pExecuteRecord,*strDiskPromptTemplate,cbPerTick,*strFirstVolumeLabel);
					if (iesExecute != iesSuccess)
						return iesExecute;
				}
			}
			break;
		}
		
		// get full file path of target file
		PMsiPath pTargetPath(0);
		if((pErrRec = pDirectoryMgr->GetTargetPath(*MsiString(pRecord->GetMsiString(ipfqDirectory)),
																 *&pTargetPath)) != 0)
			return riEngine.FatalError(*pErrRec);

		Bool fLFN = ((riEngine.GetMode() & iefSuppressLFN) == 0 && pTargetPath->SupportsLFN()) ? fTrue : fFalse;
		MsiString strFileName;
		if((pErrRec = pServices->ExtractFileName(MsiString(pRecord->GetMsiString(ipfqFileName)),
															  fLFN,*&strFileName)) != 0)
			return riEngine.FatalError(*pErrRec);

		MsiString strFileFullPath;
		if((pErrRec = pTargetPath->GetFullFilePath(strFileName, *&strFileFullPath)) != 0)
			return riEngine.FatalError(*pErrRec);
		
		// if patch sequence number is less than file sequence number, skip the patch
		// it means the file doesn't need the patch, since it is assumed to be newer or equal to what
		// the patch would change it to
		int iPatchSequence = pRecord->GetInteger(ipfqPatchSequence);
		int iFileSequence  = pRecord->GetInteger(ipfqFileSequence);
		Assert(iPatchSequence != iMsiNullInteger && iFileSequence != iMsiNullInteger);
		if(iPatchSequence < iFileSequence)
		{
			DEBUGMSG3(TEXT("Skipping patch for file '%s' because patch is older than file. Patch sequence number: %d, File sequence number: %d"),
						 (const ICHAR*)strFileFullPath, (const ICHAR*)(INT_PTR)iPatchSequence, (const ICHAR*)(INT_PTR)iFileSequence);
			continue;
		}

		// If iPatchSequence is past the end of the current media, switch to
		// the next disk.  Use a loop in case the file we want isn't on the
		// next consecutive disk.
		Assert(iPatchSequence > 0);
		while (iPatchSequence > iMediaEnd)
		{
			PMsiRecord pMediaRec(pMediaView->Fetch());
			if (pMediaRec == 0)
			{
				pErrRec = PostError(Imsg(idbgMissingMediaTable), *MsiString(sztblPatch),
					*MsiString(pRecord->GetString(ipfqFile)));
				return riEngine.FatalError(*pErrRec);
			}
			iMediaEnd = pMediaRec->GetInteger(mfnLastSequence);

			// Always execute the ChangeMedia operation for each Media table entry, even
			// if the next file we want is not on the very next disk - we don't want
			// to miss a ChangeMedia for a split file that needs the next disk (even if
			// we don't have any other files to copy on that next disk).  If it turns out
			// that we don't need to copy any files at all from a particular disk, no
			// problem - the execute operations won't prompt for a disk that isn't needed.
			
			// for patching, don't execute the ChangeMedia operation if we haven't gotten to the
			// media with the first patch file on it
			if(iFilePatchCount > 0 || iPatchSequence <= iMediaEnd)
			{
				iesExecute = ExecuteChangeMedia(riEngine,*pMediaRec,*pExecuteRecord,*strDiskPromptTemplate,cbPerTick,*strFirstVolumeLabel);
				if (iesExecute != iesSuccess)
					return iesExecute;
			}
		}

		// set up ixoPatchApply record

		// is this file part of a fusion assembly?
		MsiString strComponentKey = pRecord->GetMsiString(ipfqComponent);
		iatAssemblyType iatType = iatNone;
		MsiString strManifest;
		if((pErrRec = riEngine.GetAssemblyInfo(*strComponentKey, iatType, 0, &strManifest)) != 0)
			return riEngine.FatalError(*pErrRec);

		bool fAssemblyFile = false;
		if(iatType == iatURTAssembly || iatType == iatWin32Assembly)
		{
			fAssemblyFile = true;
		}
		
		MsiString strSourceFileKey(pRecord->GetMsiString(ipfqFile));
		if (((const ICHAR*)strSourceFileKey)[strSourceFileKey.TextSize() - 1] == ')') // check for compound key
			AssertNonZero(strSourceFileKey.Remove(iseFrom, '('));

		
		// set fields shared by IxoPatchApply and IxoAssemblyPatch
		{
			Assert(IxoFilePatchCore::PatchName       == IxoPatchApply::PatchName       && IxoFilePatchCore::PatchName       == IxoAssemblyPatch::PatchName);
			Assert(IxoFilePatchCore::TargetName      == IxoPatchApply::TargetName      && IxoFilePatchCore::TargetName      == IxoAssemblyPatch::TargetName);
			Assert(IxoFilePatchCore::PatchSize       == IxoPatchApply::PatchSize       && IxoFilePatchCore::PatchSize       == IxoAssemblyPatch::PatchSize);
			Assert(IxoFilePatchCore::TargetSize      == IxoPatchApply::TargetSize      && IxoFilePatchCore::TargetSize      == IxoAssemblyPatch::TargetSize);
			Assert(IxoFilePatchCore::PerTick         == IxoPatchApply::PerTick         && IxoFilePatchCore::PerTick         == IxoAssemblyPatch::PerTick);
			Assert(IxoFilePatchCore::IsCompressed    == IxoPatchApply::IsCompressed    && IxoFilePatchCore::IsCompressed    == IxoAssemblyPatch::IsCompressed);
			Assert(IxoFilePatchCore::FileAttributes  == IxoPatchApply::FileAttributes  && IxoFilePatchCore::FileAttributes  == IxoAssemblyPatch::FileAttributes);
			Assert(IxoFilePatchCore::PatchAttributes == IxoPatchApply::PatchAttributes && IxoFilePatchCore::PatchAttributes == IxoAssemblyPatch::PatchAttributes);
			
			using namespace IxoPatchApply;
			pExecuteRecord->ClearData();
			AssertNonZero(pExecuteRecord->SetMsiString(PatchName,*strSourceFileKey));
			AssertNonZero(pExecuteRecord->SetInteger(TargetSize,pRecord->GetInteger(ipfqFileSize)));
			AssertNonZero(pExecuteRecord->SetInteger(PatchSize,pRecord->GetInteger(ipfqPatchSize)));
			AssertNonZero(pExecuteRecord->SetInteger(PerTick,cbPerTick));
			AssertNonZero(pExecuteRecord->SetInteger(FileAttributes,pRecord->GetInteger(ipfqFileAttributes)));
			AssertNonZero(pExecuteRecord->SetInteger(PatchAttributes,pRecord->GetInteger(ipfqPatchAttributes)));
		}

		if(fAssemblyFile)
		{
			using namespace IxoAssemblyPatch;
			AssertNonZero(pExecuteRecord->SetMsiString(TargetName,*strFileName));
			AssertNonZero(pExecuteRecord->SetMsiString(ComponentId,*MsiString(pRecord->GetMsiString(ipfqComponentId))));

			// is this file the manifest file?
			if(strManifest.Compare(iscExact, strSourceFileKey))
			{
				pExecuteRecord->SetInteger(IsManifest, fTrue); // need to know the manifest file during assembly installation
			}

		}
		else
		{
			using namespace IxoPatchApply;
			AssertNonZero(pExecuteRecord->SetMsiString(TargetName,*strFileFullPath));
			AssertNonZero(pExecuteRecord->SetInteger(CheckCRC,ShouldCheckCRC(fCheckCRC, iisLocal, pRecord->GetInteger(ipfqFileAttributes))));
		}

		if((iesExecute = riEngine.ExecuteRecord(fAssemblyFile ? ixoAssemblyPatch : ixoPatchApply,
															 *pExecuteRecord)) != iesSuccess)
		{
			return iesExecute;
		}

		iFilePatchCount++;
	}

	return iesSuccess;
}

/*---------------------------------------------------------------------------
	CreateFolders and RemoveFolders actions
---------------------------------------------------------------------------*/
const ICHAR szCreateFolderTable[] = TEXT("CreateFolder");
const ICHAR sqlCreateFolders[] =
	TEXT("SELECT `CreateFolder`.`Directory_`, `ComponentId` FROM `CreateFolder`, `Component`")
	TEXT(" WHERE `Component_` = `Component` AND (`Action` = 1 OR `Action` = 2)");
const ICHAR sqlRemoveFolders[] =
	TEXT("SELECT `CreateFolder`.`Directory_`, `ComponentId` FROM `CreateFolder`, `Component`")
	TEXT(" WHERE `Component_` = `Component` AND (`Action` = 0)");

enum icfqEnum
{
	icfqFolder = 1,
	icfqComponent,
};

static iesEnum CreateOrRemoveFolders(IMsiEngine& riEngine, const ICHAR* sqlQuery, ixoEnum ixoOpCode)
{
	iesEnum iesRet = iesNoAction;
	if(PMsiDatabase(riEngine.GetDatabase())->FindTable(*MsiString(*szCreateFolderTable)) == itsUnknown)
		return iesNoAction;

	PMsiServices pServices(riEngine.GetServices());
	PMsiView pView(0);
	PMsiRecord pError(riEngine.OpenView(sqlQuery, ivcFetch, *&pView));
	if (!pError)
		pError = pView->Execute(0);
	if (pError)
		return riEngine.FatalError(*pError);

	Bool fUseACLs = fFalse;
	PMsiView pviewLockObjects(0);
	PMsiRecord precLockExecute(0);
	if (	g_fWin9X || 
			(riEngine.GetMode() & iefAdmin) || // don't use ACLs on Admin mode
			(itsUnknown == PMsiDatabase(riEngine.GetDatabase())->FindTable(*MsiString(*TEXT("LockPermissions")))) ||
			(pError = riEngine.OpenView(sqlLockPermissions, ivcFetch, *&pviewLockObjects)))
	{
		if (pError)
				return riEngine.FatalError(*pError);
	}
	else
		fUseACLs = fTrue;
	
	if (fUseACLs)
	{
		precLockExecute = &pServices->CreateRecord(2);
		AssertNonZero(precLockExecute->SetMsiString(1, *MsiString(*szCreateFolderTable)));
	}


	PMsiRecord pParams(&pServices->CreateRecord(IxoFolderCreate::Args));
	PMsiRecord pRecord(0);
	while ((pRecord = pView->Fetch()) != 0)       
	{
		MsiString strFolder(pRecord->GetMsiString(icfqFolder));

		PMsiStream pSD(0);

		if (fUseACLs && (ixoFolderCreate == ixoOpCode))
		{
			// generate security descriptor
			AssertNonZero(precLockExecute->SetMsiString(2, *strFolder));
			pError = pviewLockObjects->Execute(precLockExecute);
			if (pError)
				return riEngine.FatalError(*pError);

			pError = GenerateSD(riEngine, *pviewLockObjects, precLockExecute, *&pSD);
			if (pError)
				return riEngine.FatalError(*pError);

			if ((pError = pviewLockObjects->Close()))
				return riEngine.FatalError(*pError);
			
			AssertNonZero(pParams->SetMsiData(IxoFolderCreate::SecurityDescriptor, pSD));
		}


		// folder locations are stored in properties after DirectoryInitialize
		AssertNonZero(pParams->SetMsiString(IxoFolderCreate::Folder,
														*MsiString(riEngine.GetProperty(*strFolder))));
		AssertNonZero(pParams->SetInteger(IxoFolderCreate::Foreign, 0));

		if((iesRet = riEngine.ExecuteRecord(ixoOpCode, *pParams)) != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}

iesEnum CreateFolders(IMsiEngine& riEngine)
{
	return ::CreateOrRemoveFolders(riEngine, sqlCreateFolders, ixoFolderCreate);
}

iesEnum RemoveFolders(IMsiEngine& riEngine)
{
	return ::CreateOrRemoveFolders(riEngine, sqlRemoveFolders, ixoFolderRemove);
}

/*---------------------------------------------------------------------------
	InstallAdminPackage action - 
		Copies database to Admin install point, update summary info and strips
		out cabinets and digital signature

    OR

		Patches admin package by persisting transforms and updating suminfo props
---------------------------------------------------------------------------*/

const ICHAR szDigitalSignatureStream[] = TEXT("\005DigitalSignature");
const ICHAR sqlAdminPatchTransforms[] = TEXT("SELECT `PatchId`, `PackageName`, `TransformList`, `TempCopy`, `SourcePath` FROM `#_PatchCache` ORDER BY `Sequence`");

enum aptEnum
{
	aptPatchId = 1,
	aptPackageName,
	aptTransformList,
	aptTempCopy,
	aptSourcePath,
};

iesEnum InstallAdminPackage(IMsiEngine& riEngine)
{
	iesEnum iesRet;
	PMsiRecord pRecErr(0);
	PMsiServices pServices(riEngine.GetServices());
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiDirectoryManager pDirectoryManager(riEngine, IID_IMsiDirectoryManager);

	Bool fSuppressLFN = riEngine.GetMode() & iefSuppressLFN ? fTrue : fFalse;

	Bool fPatch = MsiString(riEngine.GetPropertyFromSz(IPROPNAME_PATCH)).TextSize() ? fTrue : fFalse;

	MsiString strDbFullFilePath = riEngine.GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE);
	MsiString strDbTargetFullFilePath;

	// nested installs in substorages will get copied with the parent storage
	// but we need to process the summaryinfo changes if the files are copied
	bool fSubstorage = false;
	if (*(const ICHAR*)strDbFullFilePath == ':')  // substorage for nested install
		fSubstorage = true;
	else if(PathType(strDbFullFilePath) != iptFull)
	{
		pRecErr = PostError(Imsg(idbgPropValueNotFullPath),*MsiString(*IPROPNAME_ORIGINALDATABASE),*strDbFullFilePath);
		return riEngine.FatalError(*pRecErr);
	}

	if(fPatch)
	{
		// apply and persist a set of transforms to the existing database
		PMsiView pView(0);
		if((pRecErr = riEngine.OpenView(sqlAdminPatchTransforms, ivcFetch, *&pView)) == 0 &&
			(pRecErr = pView->Execute(0)) == 0)
		{	
			using namespace IxoDatabasePatch;

			PMsiRecord pFetchRecord(0);
			while((pFetchRecord = pView->Fetch()) != 0)
			{
				MsiString strPatchId = pFetchRecord->GetMsiString(aptPatchId);
				MsiString strTempCopy = pFetchRecord->GetMsiString(aptTempCopy);
				MsiString strTransformList = pFetchRecord->GetMsiString(aptTransformList);
				Assert(strPatchId.TextSize());
				Assert(strTempCopy.TextSize());
				Assert(strTransformList.TextSize());

				// create storage on patch to access imbedded streams
				PMsiStorage pPatchStorage(0);
				if ((pRecErr = pServices->CreateStorage(strTempCopy, ismReadOnly, *&pPatchStorage)) != 0)
				{
					return riEngine.FatalError(*pRecErr); //!! new error?
				}

				const ICHAR* pchTransformList = strTransformList;
				int cCount = 0;
				while(*pchTransformList != 0)
				{
					cCount++;
					while((*pchTransformList != 0) && (*pchTransformList++ != ';'));
				}

				PMsiRecord pExecuteRecord = &pServices->CreateRecord(DatabasePath+cCount);
				PMsiRecord pTempFilesRecord = &pServices->CreateRecord(cCount);

				// set database path
				AssertNonZero(pExecuteRecord->SetMsiString(IxoDatabasePatch::DatabasePath,*strDbFullFilePath));
				
				cCount = DatabasePath + 1;
				int iTempFilesIndex = 1;
				while(strTransformList.TextSize() != 0)
				{
					MsiString strTransform = strTransformList.Extract(iseUpto, ';');

					PMsiStream pStream(0);
					Bool fStorageTransform = fFalse;
					Bool fPatchTransform = fFalse;
					if(*(const ICHAR*)strTransform == STORAGE_TOKEN)
						fStorageTransform = fTrue;

					if(*((const ICHAR*)strTransform + (fStorageTransform ? 1 : 0)) == PATCHONLY_TOKEN)
						fPatchTransform = fTrue;

					if(!fPatchTransform) // only persist non-patch transforms to admin package
					{
						PMsiPath pTempPath(0);
						MsiString strTempName;
						MsiString strTempFileFullPath;
						if(!fStorageTransform)
						{
							// cache the transform
							if(pRecErr = pServices->CreateFileStream(strTransform, fFalse, *&pStream))
							{
								//!! reformat error message?
								break;
							}
						}
						else // transform is in the storage
						{
							if(pRecErr = pServices->CreatePath(MsiString(GetTempDirectory()),
																		  *&pTempPath))
								break;
							
							// need to elevate when writing to secured folder
							{
								CElevate elevate;
								
								if(pRecErr = pTempPath->TempFileName(0,0,fTrue,*&strTempName, 0))
									break;

								if(pRecErr = pTempPath->GetFullFilePath(strTempName,*&strTempFileFullPath))
									break;
								
								AssertNonZero(pTempFilesRecord->SetMsiString(iTempFilesIndex++, *strTempFileFullPath));

								PMsiStorage pTransformStorage(0);
								if(pRecErr = pPatchStorage->OpenStorage(((const ICHAR*)strTransform)+1,ismReadOnly,
																				  *&pTransformStorage))
									break;

								PMsiStorage pTransformFileStorage(0);
								if(pRecErr = pServices->CreateStorage(strTempFileFullPath,ismCreate,
																				 *&pTransformFileStorage))
									break;

								if(pRecErr = pTransformStorage->CopyTo(*pTransformFileStorage,0))
									break;

								if(pRecErr = pTransformFileStorage->Commit())
									break;

								pTransformFileStorage = 0; // release so that a stream can be opened
								
								// cache the transform
								if(pRecErr = pServices->CreateFileStream(strTempFileFullPath, fFalse, *&pStream))
									break;

								// end elevate block
							}
						}

						AssertNonZero(pExecuteRecord->SetMsiData(cCount++, pStream));
					}
					
					strTransformList.Remove(iseFirst, strTransform.CharacterCount());
					if((*(const ICHAR*)strTransformList == ';'))
						strTransformList.Remove(iseFirst, 1);
				}
				
				if(!pRecErr)
				{
					if((iesRet = riEngine.ExecuteRecord(ixoDatabasePatch,*pExecuteRecord)) != iesSuccess)
						return iesRet;
				}

				pExecuteRecord = 0; // releases hold on any temp files

				// remove any temp transform files
				{
					CElevate elevate; // need to elevate to delete files from secured folder
					for(int i = 1; i < iTempFilesIndex; i++)
						AssertNonZero(WIN::DeleteFile(pTempFilesRecord->GetString(i)));
				}
			
				if(pRecErr)
					return riEngine.FatalError(*pRecErr);
			}	
		}
		else if(pRecErr->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pRecErr);

		// update summary info properties in admin package
		using namespace IxoSummaryInfoUpdate;
		
		MsiString strNewPackageCode = riEngine.GetPropertyFromSz(IPROPNAME_PATCHNEWPACKAGECODE);
		MsiString strNewSummarySubject = riEngine.GetPropertyFromSz(IPROPNAME_PATCHNEWSUMMARYSUBJECT);
		MsiString strNewSummaryComments = riEngine.GetPropertyFromSz(IPROPNAME_PATCHNEWSUMMARYCOMMENTS);
			
		PMsiRecord pUpdateSumInfoRec = &pServices->CreateRecord(IxoSummaryInfoUpdate::Args);
		AssertNonZero(pUpdateSumInfoRec->SetMsiString(Database, *strDbFullFilePath));
		AssertNonZero(pUpdateSumInfoRec->SetMsiString(Revision, *strNewPackageCode));
		AssertNonZero(pUpdateSumInfoRec->SetMsiString(Subject, *strNewSummarySubject));
		AssertNonZero(pUpdateSumInfoRec->SetMsiString(Comments, *strNewSummaryComments));

		if((iesRet = riEngine.ExecuteRecord(ixoSummaryInfoUpdate,*pUpdateSumInfoRec)) != iesSuccess)
			return iesRet;
		
	}
	else if (!fSubstorage)  //!! temporary until logic implemented
	{
		// copy database to network image

		MsiString strDbName;
		PMsiPath pSourcePath(0);
		if((pRecErr = pServices->CreateFilePath(strDbFullFilePath,*&pSourcePath,*&strDbName)) != 0)
			return riEngine.FatalError(*pRecErr);

		PMsiPath pTargetPath(0);
		if((pRecErr = pDirectoryManager->GetTargetPath(*MsiString(*IPROPNAME_TARGETDIR),*&pTargetPath)) != 0)
			return riEngine.FatalError(*pRecErr);
		if((pRecErr = pTargetPath->GetFullFilePath(strDbName,*&strDbTargetFullFilePath)) != 0)
			return riEngine.FatalError(*pRecErr);
		
		// Open media table
		PMsiView pMediaView(0);
		MsiString strFirstVolumeLabel;
		pRecErr = OpenMediaView(riEngine,*&pMediaView,*&strFirstVolumeLabel);
		if (pRecErr)
		{
			if (pRecErr->GetInteger(1) == idbgDbQueryUnknownTable)
				pRecErr = PostError(Imsg(idbgMediaTableRequired));

			return riEngine.FatalError(*pRecErr);
		}
		pRecErr = pMediaView->Execute(0);
		if (pRecErr)
			return riEngine.FatalError(*pRecErr);

		PMsiRecord pMediaRec(0);
		PMsiRecord pChangeMediaParams = &pServices->CreateRecord(IxoChangeMedia::Args);
		pMediaRec = pMediaView->Fetch();
		if(!pMediaRec)
		{
			pRecErr = PostError(Imsg(idbgMediaTableRequired));
				return riEngine.FatalError(*pRecErr);
		}
		MsiString strDiskPromptTemplate = riEngine.GetErrorTableString(imsgPromptForDisk);
		if((iesRet = ExecuteChangeMedia(riEngine, *pMediaRec, *pChangeMediaParams, *strDiskPromptTemplate, iBytesPerTick, *strFirstVolumeLabel)) != iesSuccess)
			return iesRet;

		MsiString strStreams;
		CreateCabinetStreamList(riEngine, *&strStreams);

		using namespace IxoDatabaseCopy;
		PMsiRecord pDatabaseCopyParams = &pServices->CreateRecord(Args);
		AssertNonZero(pDatabaseCopyParams->SetMsiString(DatabasePath, *strDbFullFilePath));
		AssertNonZero(pDatabaseCopyParams->SetMsiString(CabinetStreams, *strStreams));
		AssertNonZero(pDatabaseCopyParams->SetMsiString(AdminDestFolder, *MsiString(riEngine.GetPropertyFromSz(IPROPNAME_TARGETDIR))));
		if((iesRet = riEngine.ExecuteRecord(ixoDatabaseCopy, *pDatabaseCopyParams)) != iesSuccess)
			return iesRet;

		// admin property stream
		const ICHAR chDelimiter = TEXT(';');
		MsiString strAdminPropertiesName(*IPROPNAME_ADMIN_PROPERTIES);
		MsiString strAdminProperties(riEngine.GetProperty(*strAdminPropertiesName));

		riEngine.SetProperty(*MsiString(*IPROPNAME_ISADMINPACKAGE),*MsiString(TEXT("1")));
		if (strAdminProperties.TextSize())
			strAdminProperties += MsiChar(chDelimiter);
		strAdminProperties += *MsiString(*IPROPNAME_ISADMINPACKAGE);

		// provide new summary information for copied database
		using namespace IxoSummaryInfoUpdate;
		PMsiRecord pSummary = &pServices->CreateRecord(IxoSummaryInfoUpdate::Args);
		if (PMsiVolume(&pSourcePath->GetVolume())->DriveType() == idtCDROM)
		{
			// set MEDIAPACKAGEPATH so it can be put in the admin property stream below
			MsiString strRelativePath = pSourcePath->GetRelativePath();
			riEngine.SetProperty(*MsiString(*IPROPNAME_MEDIAPACKAGEPATH), *strRelativePath);
			if (strAdminProperties.TextSize())
				strAdminProperties += MsiChar(chDelimiter);
			
			strAdminProperties += *MsiString(*IPROPNAME_MEDIAPACKAGEPATH);
		}

		int iSourceType = msidbSumInfoSourceTypeAdminImage;
		if(PMsiVolume(&pTargetPath->GetVolume())->SupportsLFN() == fFalse || fSuppressLFN != fFalse)
			iSourceType |= msidbSumInfoSourceTypeSFN;
		
		MsiDate idDateTime = ENG::GetCurrentDateTime();
		pSummary->SetMsiString(Database, *strDbTargetFullFilePath);
		/*pSummary->SetNull(LastUpdate);*/ //!! why isn't this set? what is its purpose? - BENCH
		pSummary->SetMsiString(LastAuthor, *MsiString(riEngine.GetPropertyFromSz(IPROPNAME_LOGONUSER)));
		pSummary->SetInteger(InstallDate, idDateTime);
		pSummary->SetInteger(SourceType, iSourceType);
		if((iesRet = riEngine.ExecuteRecord(ixoSummaryInfoUpdate, *pSummary)) != iesSuccess)
			return iesRet;

		// generate new admin property stream
		
		// set DISABLEMEDIA in the AdminProperties stream if running against a compressed package that doesn't require
		// 1.5 MSI and the MSINODISABLEMEDIA property is not set
		int iMinInstallerVersion = riEngine.GetPropertyInt(*MsiString(IPROPNAME_VERSIONDATABASE));
		if ((iMinInstallerVersion == iMsiStringBadInteger || iMinInstallerVersion < 150) &&
			 MsiString(riEngine.GetProperty(*MsiString(IPROPNAME_MSINODISABLEMEDIA))).TextSize() == 0 &&
			 riEngine.GetMode() & iefCabinet)
		{
			riEngine.SetPropertyInt(*MsiString(*IPROPNAME_DISABLEMEDIA), 1);
			if (strAdminProperties.TextSize())
				strAdminProperties += MsiChar(chDelimiter);
			strAdminProperties += *MsiString(*IPROPNAME_DISABLEMEDIA);
		}

		// Note that we pass through *all* properties specified, not just the ones
		// that have changed.  This allows external tools better access to the available
		// values.
		if (strAdminProperties.TextSize())
		{
			using namespace IxoStreamAdd;

			PMsiRecord pAdminParams = &pServices->CreateRecord(IxoStreamAdd::Args);
			Assert(pAdminParams);

			AssertNonZero(pAdminParams->SetMsiString(File, *strDbTargetFullFilePath));
			AssertNonZero(pAdminParams->SetMsiString(Stream, *strAdminPropertiesName));

			// build command line string, and pass in as data.
			MsiString strData;
			MsiString strProperty;
			MsiString strPropertyValue;
			MsiString strSegment;

			while(strAdminProperties.TextSize())
			{
				strProperty = strAdminProperties.Extract(iseUpto, chDelimiter);
				strData += strProperty;
				strPropertyValue = riEngine.GetProperty(*strProperty);

				strData += TEXT("=\"");
				strPropertyValue = riEngine.GetProperty(*strProperty);

				MsiString strEscapedValue;
				while (strPropertyValue.TextSize()) // Escape quotes. Change all instances of " to ""
				{
					strSegment = strPropertyValue.Extract(iseIncluding, '\"');
					strEscapedValue += strSegment;
					if (!strPropertyValue.Remove(iseIncluding, '\"'))
						break;
					strEscapedValue += TEXT("\"");
				}
				strData += strEscapedValue;
				strData += TEXT("\" ");

				if (!strAdminProperties.Remove(iseIncluding, chDelimiter))
					break;
			}

			PMsiStream pData(0);
			char* pbData;
			// copy the data string into a UNICODE stream.

#ifdef UNICODE
			int cchData = strData.TextSize();
			pbData = pServices->AllocateMemoryStream((cchData+1) * sizeof(ICHAR), *&pData);
			Assert(pbData && pData);
			memcpy(pbData, (const ICHAR*) strData, cchData * sizeof(ICHAR));
			((ICHAR*)pbData)[cchData] = 0; // null terminate
#else
			int cchWideNeeded = WIN::MultiByteToWideChar(CP_ACP, 0, (const ICHAR*) strData, -1, 0, 0);
			pbData = pServices->AllocateMemoryStream(cchWideNeeded*sizeof(WCHAR), *&pData);
			WIN::MultiByteToWideChar(CP_ACP, 0, (const ICHAR*) strData, -1, (WCHAR*) pbData, cchWideNeeded);
#endif
			AssertNonZero(pAdminParams->SetMsiData(Data, pData));
			if (iesSuccess != (iesRet = riEngine.ExecuteRecord(ixoStreamAdd, *pAdminParams)))
				return iesRet;
		}
	}

	if (fPatch || !fSubstorage)
	{
		// remove digital signature stream if present
		PMsiStorage pStorage = pDatabase->GetStorage(1);
		PMsiStream pDgtlSig(0);
		pRecErr = pStorage->OpenStream(szDigitalSignatureStream, /* fWrite = */fFalse, *&pDgtlSig);
		if (pRecErr)
		{
			if (idbgStgStreamMissing == pRecErr->GetInteger(1))
			{
				// MSI does not have a digital signature, so release error and ignore
				pRecErr->Release();
			}
			else
				return riEngine.FatalError(*pRecErr);
		}
		else // MSI has a digital signature
		{
			// execute record to remove stream
			using namespace IxoStreamsRemove;
			PMsiRecord pRemoveDgtlSig = &pServices->CreateRecord(IxoStreamsRemove::Args);
			Assert(pRemoveDgtlSig); // fail??

			AssertNonZero(pRemoveDgtlSig->SetMsiString(File, fPatch ? *strDbFullFilePath : *strDbTargetFullFilePath));
			AssertNonZero(pRemoveDgtlSig->SetMsiString(Streams, *MsiString(szDigitalSignatureStream)));

			if((iesRet = riEngine.ExecuteRecord(ixoStreamsRemove, *pRemoveDgtlSig)) != iesSuccess)
			return iesRet;
		}
	}

	
	return iesSuccess;
}

/*---------------------------------------------------------------------------
	IsolateComponents action
---------------------------------------------------------------------------*/

const IMsiString& CompositeKey(const IMsiString& riKey, const IMsiString& riComponent)
{
	ICHAR rgchBuf[512]; // current limits are 72 chars for both strings
	AssertNonZero(wsprintf(rgchBuf, TEXT("%s(%s)"), riKey.GetString(), riComponent.GetString()) < sizeof(rgchBuf)/sizeof(ICHAR));
	MsiString strRet = rgchBuf;
	return strRet.Return();
}

IMsiStream* CreateStreamOnMemory(const char* pbReadOnly, unsigned int cbSize);

const ICHAR sqlPatchFetchOld[] = TEXT("SELECT `File_`,`Sequence`,`PatchSize`,`Attributes`, NULL FROM `Patch` WHERE File_ = ?");
const ICHAR sqlPatchInsertOld[] = TEXT("SELECT `File_`,`Sequence`,`PatchSize`,`Attributes`,`Header` FROM `Patch`");

const ICHAR sqlPatchFetchNew[] = TEXT("SELECT `File_`,`Sequence`,`PatchSize`,`Attributes`, NULL, `StreamRef_` FROM `Patch` WHERE File_ = ?");
const ICHAR sqlPatchInsertNew[] = TEXT("SELECT `File_`,`Sequence`,`PatchSize`,`Attributes`,`Header`,`StreamRef_` FROM `Patch`");

iesEnum IsolateComponents(IMsiEngine& riEngine)
{
	if ((riEngine.GetMode() & iefSecondSequence) && g_scServerContext == scClient)
	{
		DEBUGMSG("Skipping IsolateComponents: action already run in this engine.");
		return iesNoAction;
	}

	PMsiRecord pError(0);
	PMsiServices pServices(riEngine.GetServices());
	PMsiDatabase pDatabase(riEngine.GetDatabase());

	// Check for existence of IsolatedComponent table
	if (!pDatabase->GetTableState(TEXT("IsolatedComponent"), itsTableExists))
		return iesNoAction;

	// Prepare views on the various tables up front for efficiency
	PMsiView pIsolateView(0);
	PMsiView pComponentView(0);
	PMsiView pFileView(0);
	PMsiView pFileKeyView(0);
	PMsiView pFeatureView1(0);
	PMsiView pFeatureView2(0);
	PMsiView pBindView(0);
	PMsiView pPatchFetchView(0);
	PMsiView pPatchInsertView(0);
	bool fUsedOldPatchSchema = false;

	if ((pError = pDatabase->OpenView(TEXT("SELECT `Component_Shared`,`Component_Application` FROM `IsolatedComponent`"), ivcFetch, *&pIsolateView)) != 0
	 || (pError = pDatabase->OpenView(TEXT("SELECT `Component`,`RuntimeFlags`,`KeyPath`, `Attribut