TES)
                	Error(1, L"the xml file cannot overwrite an existing file");
                
                continue;
            }
        }

        // We suppose that the next arguments are the volumes
        bParsingVolumes = true;

        // Add the volume to the list of snapshotting volumes
        // Make sure that the volume name is valid
        bool bAdded = false;
        if (!AddVolume(*ppwszCurrentArg, bAdded)) {
            wprintf(L"\nError while parsing the command line:\n"
                L"\t%s is not a valid option or a mount point [0x%08lx]\n\n",
                *ppwszCurrentArg, GetLastError() );
            PrintUsage();
        }

        // Check if the same volume is added twice
        if (!bAdded) {
            wprintf(L"\nError while parsing the command line:\n"
                L"\tThe volume %s is specified twice\n\n", *ppwszCurrentArg );
            PrintUsage();
        }
    }

    // Check if we added at least one volume
    if ((m_nVolumesCount == 0) && !m_bComponentSelectionEnabled) {
        wprintf(L"\nError while parsing the command line:\n"
            L"\t- You should specify at least one volume or enable component selection\n\n");
        PrintUsage();
    }
}


// Add the given volume by the contained path
void CVssSampleRequestor::AddVolumeForComponent(
    IN IVssWMFiledesc* pFileDesc
    )
{
    // Get the component path
	CComBSTR bstrPath;
	CHECK_SUCCESS(pFileDesc->GetPath(&bstrPath));
	
	// Trying to find the volume that will contain the path.
	WCHAR wszExpandedPath[MAX_TEXT_BUFFER];
    if (!ExpandEnvironmentStringsW(bstrPath, wszExpandedPath, MAX_TEXT_BUFFER))
        Error( 1, L"\nExpandEnvironmentStringsW(%s, %s, %u) failed with [0x%08lx]\n",
            bstrPath, wszExpandedPath, MAX_TEXT_BUFFER, GetLastError());

	// Eliminate one by one the terminating folder names, until we reach an existing path.
	// Then get the volume name for that path
	WCHAR wszMountPoint[MAX_TEXT_BUFFER];
	while(true) {
        if (GetVolumePathNameW(wszExpandedPath, wszMountPoint, MAX_TEXT_BUFFER))
            break;
        if (GetLastError() != ERROR_FILE_NOT_FOUND)
            Error( 1, L"\nGetVolumePathNameW(%s, wszMountPoint, MAX_TEXT_BUFFER) failed with [0x%08lx]\n",
                wszExpandedPath, GetLastError());
        WCHAR* pwszLastBackslashIndex = wcsrchr(wszExpandedPath, L'\\');
        if (!pwszLastBackslashIndex)
            Error( 1, L"\nCannot find anymore a backslash in path %s. \n"
                L"The original path %s seems invalid.\n", wszExpandedPath, bstrPath);
        // Eliminate the last folder name
        pwszLastBackslashIndex[0] = L'\0';
    }

    // Add the volume, if possible
    bool bAdded = false;
    if (!AddVolume( wszMountPoint, bAdded ))
            Error( 1, L"\nUnexpected error: cannot add volume %s to the snapshot set.\n", wszMountPoint);
   	wprintf (L"          [Volume %s (that contains the file) %s marked as a candidate for snapshot]\n",
   	    wszMountPoint, bAdded? L"is": L"is already");
}


// Add the given volume in the list of potential candidates for snapshots
// - Returns "false" if the volume does not correspond to a real mount point
//   (and GetLastError() will contain the correct Win32 error code)
// - Sets "true" in the bAdded parameter if the volume is actually added
bool CVssSampleRequestor::AddVolume(
    IN WCHAR* pwszVolume,
    OUT bool & bAdded
    )
{
    // Initialize [out] parameters
    bAdded = false;

    // Check if the volume represents a real mount point
    WCHAR wszVolumeName[MAX_TEXT_BUFFER];
    if (!GetVolumeNameForVolumeMountPoint(pwszVolume, wszVolumeName, MAX_TEXT_BUFFER))
        return false; // Invalid volume

    // Check if the volume is already added.
    for (INT nIndex = 0; nIndex < m_nVolumesCount; nIndex++)
        if (!wcscmp(wszVolumeName, m_ppwszVolumeNamesList[nIndex]))
            return true; // Volume already added. Stop here.

    // Check if we exceeded the maximum number of volumes
    if (m_nVolumesCount == MAX_VOLUMES)
        Error( 1, L"Maximum number of volumes exceeded");

    // Create a copy of the volume
    WCHAR* pwszNewVolume = _wcsdup(pwszVolume);
    if (pwszNewVolume == NULL)
        Error( 1, L"Memory allocation error");

    // Create a copy of the volume name
    WCHAR* pwszNewVolumeName = _wcsdup(wszVolumeName);
    if (pwszNewVolumeName == NULL) {
        free(pwszNewVolume);
        Error( 1, L"Memory allocation error");
    }

    // Add the volume in our internal list of snapshotted volumes
    m_ppwszVolumesList[m_nVolumesCount] = pwszNewVolume;
    m_ppwszVolumeNamesList[m_nVolumesCount] = pwszNewVolumeName;
    m_nVolumesCount++;
    bAdded = true;

    return true;
}


// This function displays the formatted message at the console and throws
// The passed return code will be returned by vsreq.exe
void CVssSampleRequestor::Error(
    IN  INT nReturnCode,
    IN  const WCHAR* pwszMsgFormat,
    IN  ...
    )
{
    va_list marker;
    va_start( marker, pwszMsgFormat );
    vwprintf( pwszMsgFormat, marker );
    va_end( marker );

    // throw that return code.
    throw(nReturnCode);
}


///////////////////////////////////////////////////////////////////////////////
// Utility functions


// Print a file description object
void CVssSampleRequestor::PrintFiledesc (IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription)
{
    CComBSTR bstrPath;
    CComBSTR bstrFilespec;
    CComBSTR bstrAlternate;
    bool     bRecursive = false;

    CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
    CHECK_SUCCESS(pFiledesc->GetFilespec (&bstrFilespec));
    CHECK_NOFAIL(pFiledesc->GetRecursive(&bRecursive));
    CHECK_NOFAIL(pFiledesc->GetAlternateLocation(&bstrAlternate));

    wprintf (L"%s\n"
        L"          Path = %s\n"
        L"          Filespec = %s\n"
        L"          Recursive = %s\n",
        wszDescription,
        bstrPath,
        bstrFilespec,
        bRecursive ? L"yes" : L"no");

    if (bstrAlternate && wcslen (bstrAlternate) > 0)
    	wprintf(L"          Alternate Location = %s\n", bstrAlternate);
}


// Convert a usage type into a string
LPCWSTR CVssSampleRequestor::GetStringFromUsageType (VSS_USAGE_TYPE eUsageType)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eUsageType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszRetString = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszRetString = L"SystemService";       break;
	case VSS_UT_USERDATA:            pwszRetString = L"UserData";            break;
	case VSS_UT_OTHER:               pwszRetString = L"Other";               break;
					
	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a source type into a string
LPCWSTR CVssSampleRequestor::GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eSourceType)
	{
	case VSS_ST_TRANSACTEDDB:    pwszRetString = L"TransactionDb";    break;
	case VSS_ST_NONTRANSACTEDDB: pwszRetString = L"NonTransactionDb"; break;
	case VSS_ST_OTHER:           pwszRetString = L"Other";            break;

	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a restore method into a string
LPCWSTR CVssSampleRequestor::GetStringFromRestoreMethod (VSS_RESTOREMETHOD_ENUM eRestoreMethod)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eRestoreMethod)
	{
	case VSS_RME_RESTORE_IF_NOT_THERE:          pwszRetString = L"RestoreIfNotThere";          break;
	case VSS_RME_RESTORE_IF_CAN_REPLACE:        pwszRetString = L"RestoreIfCanReplace";        break;
	case VSS_RME_STOP_RESTORE_START:            pwszRetString = L"StopRestoreStart";           break;
	case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION: pwszRetString = L"RestoreToAlternateLocation"; break;
	case VSS_RME_RESTORE_AT_REBOOT:             pwszRetString = L"RestoreAtReboot";            break;
	case VSS_RME_CUSTOM:                        pwszRetString = L"Custom";                     break;

	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a writer restore method into a string
LPCWSTR CVssSampleRequestor::GetStringFromWriterRestoreMethod (VSS_WRITERRESTORE_ENUM eWriterRestoreMethod)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eWriterRestoreMethod)
	{
	case VSS_WRE_NEVER:            pwszRetString = L"RestoreNever";           break;
	case VSS_WRE_IF_REPLACE_FAILS: pwszRetString = L"RestoreIfReplaceFailsI"; break;
	case VSS_WRE_ALWAYS:           pwszRetString = L"RestoreAlways";          break;

	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a component type into a string
LPCWSTR CVssSampleRequestor::GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eComponentType)
	{
	case VSS_CT_DATABASE:  pwszRetString = L"Database";  break;
	case VSS_CT_FILEGROUP: pwszRetString = L"FileGroup"; break;

	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a failure type into a string
LPCWSTR CVssSampleRequestor::GetStringFromFailureType(HRESULT hrStatus)
{
    LPCWSTR pwszFailureType = L"";

    switch (hrStatus)
	{
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:        pwszFailureType = L"VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT";    break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:              pwszFailureType = L"VSS_E_WRITERERROR_OUTOFRESOURCES";          break;
	case VSS_E_WRITERERROR_TIMEOUT:                     pwszFailureType = L"VSS_E_WRITERERROR_TIMEOUT";                 break;
	case VSS_E_WRITERERROR_NONRETRYABLE:                pwszFailureType = L"VSS_E_WRITERERROR_NONRETRYABLE";            break;
	case VSS_E_WRITERERROR_RETRYABLE:                   pwszFailureType = L"VSS_E_WRITERERROR_RETRYABLE";               break;
	case VSS_E_BAD_STATE:                               pwszFailureType = L"VSS_E_BAD_STATE";                           break;
	case VSS_E_PROVIDER_ALREADY_REGISTERED:             pwszFailureType = L"VSS_E_PROVIDER_ALREADY_REGISTERED";         break;
	case VSS_E_PROVIDER_NOT_REGISTERED:                 pwszFailureType = L"VSS_E_PROVIDER_NOT_REGISTERED";             break;
	case VSS_E_PROVIDER_VETO:                           pwszFailureType = L"VSS_E_PROVIDER_VETO";                       break;
	case VSS_E_PROVIDER_IN_USE:				            pwszFailureType = L"VSS_E_PROVIDER_IN_USE";                     break;
	case VSS_E_OBJECT_NOT_FOUND:						pwszFailureType = L"VSS_E_OBJECT_NOT_FOUND";                    break;						
	case VSS_S_ASYNC_PENDING:							pwszFailureType = L"VSS_S_ASYNC_PENDING";                       break;
	case VSS_S_ASYNC_FINISHED:						    pwszFailureType = L"VSS_S_ASYNC_FINISHED";                      break;
	case VSS_S_ASYNC_CANCELLED:						    pwszFailureType = L"VSS_S_ASYNC_CANCELLED";                     break;
	case VSS_E_VOLUME_NOT_SUPPORTED:					pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED";                break;
	case VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER:		pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER";    break;
	case VSS_E_OBJECT_ALREADY_EXISTS:					pwszFailureType = L"VSS_E_OBJECT_ALREADY_EXISTS";               break;
	case VSS_E_UNEXPECTED_PROVIDER_ERROR:				pwszFailureType = L"VSS_E_UNEXPECTED_PROVIDER_ERROR";           break;
	case VSS_E_CORRUPT_XML_DOCUMENT:				    pwszFailureType = L"VSS_E_CORRUPT_XML_DOCUMENT";                break;
	case VSS_E_INVALID_XML_DOCUMENT:					pwszFailureType = L"VSS_E_INVALID_XML_DOCUMENT";                break;
	case VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED:       pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED";   break;
	case VSS_E_FLUSH_WRITES_TIMEOUT:                    pwszFailureType = L"VSS_E_FLUSH_WRITES_TIMEOUT";                break;
	case VSS_E_HOLD_WRITES_TIMEOUT:                     pwszFailureType = L"VSS_E_HOLD_WRITES_TIMEOUT";                 break;
	case VSS_E_UNEXPECTED_WRITER_ERROR:                 pwszFailureType = L"VSS_E_UNEXPECTED_WRITER_ERROR";             break;
	case VSS_E_SNAPSHOT_SET_IN_PROGRESS:                pwszFailureType = L"VSS_E_SNAPSHOT_SET_IN_PROGRESS";            break;
	case VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED:     pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED"; break;
	case VSS_E_WRITER_INFRASTRUCTURE:	 		        pwszFailureType = L"VSS_E_WRITER_INFRASTRUCTURE";               break;
	case VSS_E_WRITER_NOT_RESPONDING:			        pwszFailureType = L"VSS_E_WRITER_NOT_RESPONDING";               break;
    case VSS_E_WRITER_ALREADY_SUBSCRIBED:		        pwszFailureType = L"VSS_E_WRITER_ALREADY_SUBSCRIBED";           break;
	
	case NOERROR:
	default:
	    break;
	}

    return (pwszFailureType);
}


// Convert a writer status into a string
LPCWSTR CVssSampleRequestor::GetStringFromWriterStatus(VSS_WRITER_STATE eWriterStatus)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eWriterStatus)
	{
	case VSS_WS_STABLE:                    pwszRetString = L"STABLE";                  break;
	case VSS_WS_WAITING_FOR_FREEZE:        pwszRetString = L"WAITING_FOR_FREEZE";      break;
	case VSS_WS_WAITING_FOR_THAW:          pwszRetString = L"WAITING_FOR_THAW";        break;
    case VSS_WS_WAITING_FOR_POST_SNAPSHOT: pwszRetString = L"WAITING_FOR_POST_SNAPSHOT"; break;
	case VSS_WS_WAITING_FOR_BACKUP_COMPLETE:    pwszRetString = L"WAITING_FOR_BACKUP_COMPLETION";  break;
	case VSS_WS_FAILED_AT_IDENTIFY:        pwszRetString = L"FAILED_AT_IDENTIFY";      break;
	case VSS_WS_FAILED_AT_PREPARE_BACKUP:  pwszRetString = L"FAILED_AT_PREPARE_BACKUP";break;
	case VSS_WS_FAILED_AT_PREPARE_SNAPSHOT:    pwszRetString = L"FAILED_AT_PREPARE_SNAPSHOT";  break;
	case VSS_WS_FAILED_AT_FREEZE:          pwszRetString = L"FAILED_AT_FREEZE";        break;
	case VSS_WS_FAILED_AT_THAW:			   pwszRetString = L"FAILED_AT_THAW";          break;
    case VSS_WS_FAILED_AT_POST_SNAPSHOT:   pwszRetString = L"FAILED_AT_POST_SNAPSHOT"; break;
    case VSS_WS_FAILED_AT_BACKUP_COMPLETE: pwszRetString = L"FAILED_AT_BACKUP_COMPLETE"; break;
    case VSS_WS_FAILED_AT_PRE_RESTORE:     pwszRetString = L"FAILED_AT_PRE_RESTORE"; break;
    case VSS_WS_FAILED_AT_POST_RESTORE:    pwszRetString = L"FAILED_AT_POST_RESTORE"; break;
	default:
	    break;
	}

    return (pwszRetString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\samples\requestor\vsreq.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	vsreq.cpp
**
**
** Abstract:
**
**	Sample program to
**      - obtain and display the Writer metadata.
**      - create a snapshot set
**
** Author:
**
**	Adi Oltean      [aoltean]       05-Dec-2000
**
**  The sample is based on the Metasnap test program  written by Michael C. Johnson.
**
**
** Revision History:
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "vsreq.h"


///////////////////////////////////////////////////////////////////////////////
// Processing functions

CVssSampleRequestor::CVssSampleRequestor()
{
    // Initialize data members
    m_bCoInitializeSucceeded = false;
    m_bBootableSystemState = false;
    m_bComponentSelectionEnabled = false;
    m_pBackupComponents = NULL;
    m_nVolumesCount = 0;
    m_hr = S_OK;
    m_pwszXmlFile = NULL;
    m_pXmlFile = NULL;

    // For safety
    for (int nIndex=0; nIndex<MAX_VOLUMES; nIndex++) {
        m_ppwszVolumesList[nIndex] = NULL;
        m_ppwszVolumeNamesList[nIndex] = NULL;
    }

    // Print display header
    wprintf(L"\nVSS Requestor Sample application, version 1.0\n");
}


CVssSampleRequestor::~CVssSampleRequestor()
{
    // Deallocate some internal strings
    free(m_pwszXmlFile);

    // delete the allocated volumes
    for (int nIndex=0; nIndex<m_nVolumesCount; nIndex++) {
        free(m_ppwszVolumesList[nIndex]);
        free(m_ppwszVolumeNamesList[nIndex]);
    }

    // Close the Xml file
    if (m_pXmlFile)
        fclose(m_pXmlFile);

    // Releasing backup components prior to the CoUninitialize call
    m_pBackupComponents = NULL;

    // Unloading the COM library
    if (m_bCoInitializeSucceeded)
        CoUninitialize();
}


void CVssSampleRequestor::Initialize()
{
    wprintf (L"\n----------------- Initializing ---------------------\n");

    // Initialize COM library
    CHECK_NOFAIL(CoInitializeEx (NULL, COINIT_MULTITHREADED));
	m_bCoInitializeSucceeded = true;
    wprintf (L"COM library initialized.\n");

    // Initialize COM security
    CHECK_SUCCESS
		(
		CoInitializeSecurity
			(
			NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
			-1,                                  //  IN LONG                         cAuthSvc,
			NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
			NULL,                                //  IN void                        *pReserved1,
			RPC_C_AUTHN_LEVEL_PKT_PRIVACY,           //  IN DWORD                        dwAuthnLevel,
			RPC_C_IMP_LEVEL_IDENTIFY,         //  IN DWORD                        dwImpLevel,
			NULL,                                //  IN void                        *pAuthList,
			EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
			NULL                                 //  IN void                        *pReserved3
			)
		);
    wprintf (L"COM security initialized.\n");

    // Open the Xml file
    if (m_pwszXmlFile) {
        m_pXmlFile = _wfopen( m_pwszXmlFile, L"w");
        if (!m_pXmlFile)
            Error(1, L"\nError creating/opening the file %s\n", m_pwszXmlFile);
        wprintf (L"XML results file created: %s\n", m_pwszXmlFile);
    }

    // Create the Backup components object
	CHECK_NOFAIL(CreateVssBackupComponents(&m_pBackupComponents));
    wprintf (L"Backup components object created.\n");

    // Initialize the backup components object for backup
	CHECK_NOFAIL(m_pBackupComponents->InitializeForBackup());
	CHECK_SUCCESS(m_pBackupComponents->SetBackupState(
        m_bComponentSelectionEnabled, m_bBootableSystemState, VSS_BT_FULL, false));
    wprintf (L"Backup components object initialized for backup operations.\n");
}


void CVssSampleRequestor::CreateSnapshotSet()
{
    CComPtr<IVssAsync> pAsync;
    VSS_ID pSnapshotsArray[MAX_VOLUMES];
    VSS_ID SnapshotSetId = GUID_NULL;

   memset(pSnapshotsArray, 0, sizeof(pSnapshotsArray));
   
    wprintf (L"\n---------- Starting backup/snapshot ----------------\n");

    // Starting a new snapshot set
    wprintf(L"Starting a new Snapshot Set\n");	
    CHECK_SUCCESS(m_pBackupComponents->StartSnapshotSet(&SnapshotSetId));
    wprintf(L"Snapshot Set created with ID = " WSTR_GUID_FMT L"\n", GUID_PRINTF_ARG(SnapshotSetId));

    // Add volumes to the snapshot set
    wprintf(L"Adding volumes to the Snapshot Set: \n");
    for (INT nIndex = 0; nIndex < m_nVolumesCount; nIndex++)
    {
		// Get the volume containing the path
        wprintf(L"\t- Adding volume containing %s ... ", m_ppwszVolumesList[nIndex] );

		// Add the volume to the snapshot set
        CHECK_SUCCESS(m_pBackupComponents->AddToSnapshotSet(m_ppwszVolumesList[nIndex],
            GUID_NULL, &(pSnapshotsArray[nIndex])));
        wprintf( L"OK\n");
    }

    wprintf (L"\n------------ Creating the snapshot -----------------\n");

    // Prepare for backup
    wprintf(L"Starting asynchronous PrepareForBackup. Please wait...\n");	
    HRESULT hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->PrepareForBackup(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));
	CHECK_NOFAIL((hr));
    wprintf(L"Asynchronous PrepareForBackup finished.\n");	

    // Gather writer status
    GatherWriterStatus(L"after PrepareForBackup");

    // Create the snapshot
    wprintf(L"\nStarting asynchronous DoSnapshotSet. Please wait...\n");	
    hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->DoSnapshotSet(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));
	CHECK_NOFAIL((hr));
    wprintf(L"Asynchronous DoSnapshotSet finished.\n");	

    // Gather writer status
    GatherWriterStatus(L"after DoSnapshotSet");

    wprintf(L"Snapshot set created\n");
    for (INT nIndex = 0; nIndex < m_nVolumesCount; nIndex++)
    {
        if (pSnapshotsArray[nIndex] == GUID_NULL)
            continue;
        VSS_SNAPSHOT_PROP prop;
        memset(&prop, 0, sizeof(prop));
        
        CHECK_SUCCESS(m_pBackupComponents->GetSnapshotProperties(pSnapshotsArray[nIndex], &prop));
        wprintf(L"\t- The snapshot on volume %s resides at %s\n",
            m_ppwszVolumesList[nIndex], prop.m_pwszSnapshotDeviceObject);
        ::VssFreeSnapshotProperties(&prop);
    }
}


void CVssSampleRequestor::BackupComplete()
{
	unsigned cWriterComponents = 0;
	CComPtr<IVssAsync> pAsync;

    wprintf (L"\n------------ Completing backup phase ---------------\n");

	CHECK_SUCCESS(m_pBackupComponents->GetWriterComponentsCount(&cWriterComponents));

    // If component selection enabled,
    if (m_bComponentSelectionEnabled)
    {
		wprintf(L"Setting the succeeded state for the following components:\n");
        // For each component, mark the completion state as succeeded
    	for(unsigned iWriter = 0; iWriter < cWriterComponents; iWriter++)
        {
    	    CComPtr<IVssWriterComponentsExt> pWriter;
    	    CHECK_SUCCESS(m_pBackupComponents->GetWriterComponents(iWriter, &pWriter));

    	    unsigned cComponents = 0;
    	    CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
    	    VSS_ID idWriter = GUID_NULL, idInstance= GUID_NULL;
    	    CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));
    	    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
    		{
        		CComPtr<IVssComponent> pComponent;
        		CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
        				
        		VSS_COMPONENT_TYPE ct = VSS_CT_UNDEFINED;
        		CComBSTR bstrLogicalPath;
        		CComBSTR bstrComponentName;

        		CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
        		CHECK_SUCCESS(pComponent->GetComponentType(&ct));
        		CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
        		wprintf(L"\t- %s\n", (LPWSTR)bstrComponentName);
        		
        		CHECK_SUCCESS(m_pBackupComponents->SetBackupSucceeded (idInstance,
        							idWriter,
        							ct,
        							bstrLogicalPath,
        							bstrComponentName,
        							true));
    		}
        }
		wprintf(L"\n");
    }

    // Save the XML file, if needed
    // The contents will be needed at restore, in the InitializeForRestore method.
    if (m_pXmlFile) {
    	CComBSTR bstrXML;
    	CHECK_SUCCESS(m_pBackupComponents->SaveAsXML(&bstrXML));
    	fwprintf( m_pXmlFile, L"%s", (WCHAR*)bstrXML);
        wprintf(L"XML results written in %s\n", m_pwszXmlFile);	
    }

	// Send the BackupComplete event
    wprintf(L"\nStarting asynchronous BackupComplete. Please wait...\n");	
    HRESULT hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->BackupComplete(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));
	CHECK_NOFAIL((hr));
    wprintf(L"Asynchronous BackupComplete finished.\n");	

    // Gather writer status
    GatherWriterStatus(L"after BackupComplete");
}


// Gather writera metadata and select components for backup, if needed
void CVssSampleRequestor::GatherWriterMetadata()
{
	unsigned cWriters = 0;
	CComPtr<IVssAsync> pAsync;
	
    wprintf (L"\n---------- Gathering writer metadata ---------------\n");
	
    wprintf(L"Starting asynchronous GatherWriterMetadata. Please wait...\n");	
    HRESULT hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->GatherWriterMetadata(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));
	CHECK_NOFAIL((hr));
    wprintf(L"Asynchronous GatherWriterMetadata finished.\n");	
	
	CHECK_NOFAIL  (m_pBackupComponents->GetWriterMetadataCount (&cWriters));
    wprintf(L"Number of writers that responded: %u\n", cWriters);	
	
	for (unsigned iWriter = 0; iWriter < cWriters; iWriter++)
	{
		CComPtr<IVssExamineWriterMetadata> pMetadata;
		
		VSS_ID          idInstance = GUID_NULL;
		VSS_ID          idInstanceT = GUID_NULL;
		VSS_ID          idWriter = GUID_NULL;
		CComBSTR        bstrWriterName;
		VSS_USAGE_TYPE  usage = VSS_UT_UNDEFINED;
		VSS_SOURCE_TYPE source= VSS_ST_UNDEFINED;
		unsigned        cIncludeFiles = 0, cExcludeFiles = 0, cComponents = 0;
		CComBSTR        bstrPath;
		CComBSTR        bstrFilespec;
		CComBSTR        bstrAlternate;
		CComBSTR        bstrDestination;
		
		CHECK_SUCCESS (m_pBackupComponents->GetWriterMetadata(iWriter, &idInstance, &pMetadata));
		
		CHECK_SUCCESS (pMetadata->GetIdentity (&idInstanceT,
			&idWriter,
			&bstrWriterName,
			&usage,
			&source));
		
		wprintf (L"\n*** WriterName = %s\n\n"
			L"    WriterId   = "WSTR_GUID_FMT L"\n"
			L"    InstanceId = "WSTR_GUID_FMT L"\n"
			L"    UsageType  = %d (%s)\n"
			L"    SourceType = %d (%s)\n",
			bstrWriterName,
			GUID_PRINTF_ARG(idWriter),
			GUID_PRINTF_ARG(idInstance),
			usage,
			GetStringFromUsageType (usage),
			source,
			GetStringFromSourceType (source));
		
		CHECK_SUCCESS(pMetadata->GetFileCounts (&cIncludeFiles,
			&cExcludeFiles,
			&cComponents));
		
		for(unsigned i = 0; i < cIncludeFiles; i++)
		{
			CComPtr<IVssWMFiledesc> pFiledesc;
			CHECK_SUCCESS (pMetadata->GetIncludeFile (i, &pFiledesc));
			PrintFiledesc(pFiledesc, L"\n    Include File");
		}
		
		
		for(i = 0; i < cExcludeFiles; i++)
		{
			CComPtr<IVssWMFiledesc> pFiledesc;
			CHECK_SUCCESS (pMetadata->GetExcludeFile (i, &pFiledesc));
			PrintFiledesc (pFiledesc, L"\n    Exclude File");
		}
		
		
		for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
			CComPtr<IVssWMComponent> pComponent;
			PVSSCOMPONENTINFO pInfo = NULL;
			
			CHECK_SUCCESS (pMetadata->GetComponent      (iComponent, &pComponent));
			CHECK_SUCCESS (pComponent->GetComponentInfo (&pInfo));
			
			wprintf (L"\n"
				L"    Component %d, type = %d (%s)\n"
				L"        LogicalPath = %s\n"
				L"        Name        = %s\n"
				L"        Caption     = %s\n",
				iComponent,
				pInfo->type,
				GetStringFromComponentType (pInfo->type),
				pInfo->bstrLogicalPath,
				pInfo->bstrComponentName,
				pInfo->bstrCaption);
			
			wprintf (L"        RestoreMetadata        = %s\n"
				L"        NotifyOnBackupComplete = %s\n"
				L"        Selectable             = %s\n",
				pInfo->bRestoreMetadata        ? L"yes" : L"no",
				pInfo->bNotifyOnBackupComplete ? L"yes" : L"no",
				pInfo->bSelectable             ? L"yes" : L"no");
			
            // If specified, add this component to the backup
            // Remark: A real backup app will first get from the user the list of components to be added
			if (m_bComponentSelectionEnabled) {
        		CHECK_SUCCESS(m_pBackupComponents->AddComponent(idInstance,
    						  idWriter,
    						  pInfo->type,
    						  pInfo->bstrLogicalPath,
    						  pInfo->bstrComponentName));
        		
    			wprintf (L"        [Component %d was added to the backup]\n", iComponent);
			}
			
			for(i = 0; i < pInfo->cFileCount; i++)
			{
				CComPtr<IVssWMFiledesc> pFiledesc;
				CHECK_SUCCESS (pComponent->GetFile (i, &pFiledesc));
				PrintFiledesc (pFiledesc, L"        FileGroupFile");

	                // If we add the component, snapshot also the volume on which the file reside
				if (m_bComponentSelectionEnabled)
       		             AddVolumeForComponent(pFiledesc);
			}
			
			for(i = 0; i < pInfo->cDatabases; i++)
			{
				CComPtr<IVssWMFiledesc> pFiledesc;
				CHECK_SUCCESS (pComponent->GetDatabaseFile (i, &pFiledesc));
				PrintFiledesc (pFiledesc, L"        DatabaseFile");
				
	                // If we add the component, snapshot also the volume on which the file reside
				if (m_bComponentSelectionEnabled)
       		             AddVolumeForComponent(pFiledesc);				
			}
			
			
			for(i = 0; i < pInfo->cLogFiles; i++)
			{
				CComPtr<IVssWMFiledesc> pFiledesc;
				CHECK_SUCCESS (pComponent->GetDatabaseLogFile (i, &pFiledesc));
				PrintFiledesc (pFiledesc, L"        DatabaseLogFile");

       	         // If we add the component, snapshot also the volume on which the file reside
				if (m_bComponentSelectionEnabled)
            			        AddVolumeForComponent(pFiledesc);
			}
			
			pComponent->FreeComponentInfo (pInfo);
		}
		
		VSS_RESTOREMETHOD_ENUM method = VSS_RME_UNDEFINED;
		CComBSTR bstrUserProcedure;
		CComBSTR bstrService;
		VSS_WRITERRESTORE_ENUM writerRestore = VSS_WRE_UNDEFINED;
		unsigned cMappings = 0;
		bool bRebootRequired = false;
		
		CHECK_NOFAIL (pMetadata->GetRestoreMethod (&method,
			&bstrService,
			&bstrUserProcedure,
			&writerRestore,
			&bRebootRequired,
			&cMappings));
		
		wprintf (L"\n"
			L"    Restore method = %d (%s)\n"
			L"    Service        = %s\n"
			L"    User Procedure = %s\n"
			L"    WriterRestore  = %d (%s)\n"
			L"    RebootRequired = %s\n",
			method,
			GetStringFromRestoreMethod (method),
			bstrService,
			bstrUserProcedure,
			writerRestore,
			GetStringFromWriterRestoreMethod (writerRestore),
			bRebootRequired ? L"yes" : L"no");
		
		for(i = 0; i < cMappings; i++)
		{
			CComPtr<IVssWMFiledesc> pFiledesc;
			CHECK_SUCCESS (pMetadata->GetAlternateLocationMapping (i, &pFiledesc));
			PrintFiledesc (pFiledesc, L"    AlternateMapping");
		}
	}
		
    // Gather writer status
    GatherWriterStatus(L"after GatherWriterMetadata");

	CHECK_SUCCESS (m_pBackupComponents->FreeWriterMetadata());
}


void CVssSampleRequestor::GatherWriterStatus(
    IN  LPCWSTR wszWhen
    )
{
       unsigned cWriters = 0;
	CComPtr<IVssAsync> pAsync;

    wprintf (L"\nGathering writer status %s... ", wszWhen);
    HRESULT hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->GatherWriterStatus(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));
	CHECK_NOFAIL((hr));
	CHECK_NOFAIL(m_pBackupComponents->GetWriterStatusCount(&cWriters));
    wprintf (L"%d writers responded\n", cWriters);

    for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
	{
    	VSS_ID idInstance = GUID_NULL;
    	VSS_ID idWriter= GUID_NULL;
    	VSS_WRITER_STATE eWriterStatus = VSS_WS_UNKNOWN;
    	CComBSTR bstrWriter;
    	HRESULT hrWriterFailure = S_OK;

    	CHECK_SUCCESS(m_pBackupComponents->GetWriterStatus (iWriter,
    					     &idInstance,
    					     &idWriter,
    					     &bstrWriter,
    					     &eWriterStatus,
    					     &hrWriterFailure));

        WCHAR wszWriterFailure[MAX_TEXT_BUFFER];
        memset(wszWriterFailure, 0, sizeof(wszWriterFailure));
        
        if (hrWriterFailure)
            _snwprintf(wszWriterFailure, MAX_TEXT_BUFFER - 1, L" Writer error code: %s [0x%08lx]", 
                GetStringFromFailureType(hrWriterFailure), hrWriterFailure);
        else
            wszWriterFailure[0] = L'\0';

    	wprintf (L"\t- %s status for writer '%s'. %s\n",
    		 GetStringFromWriterStatus(eWriterStatus), bstrWriter, wszWriterFailure);
    }

    m_pBackupComponents->FreeWriterStatus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\betest\compont.h ===
#ifndef _COMPONTH_
#define _COMPONTH_

#include "vs_hash.hxx"

class CWriterComponentsSelection
{
public:
	// Construction Destruction
	CWriterComponentsSelection();
	~CWriterComponentsSelection();

	// methods
	void SetWriter
		(
		IN VSS_ID WriterId
		);
	
	HRESULT AddSelectedComponent
		(
		IN WCHAR* pwszComponentLogicalPath
		);

       HRESULT AddSelectedSubcomponent
            (
            IN WCHAR* pwszSubcomponentLogicalPath
            );
       
	BOOL IsComponentSelected
		(
		IN WCHAR* pwszComponentLogicalPath,
		IN WCHAR* pwszComponentName
		);

        BOOL IsSubcomponentSelected
            (
            IN WCHAR* pwszSubcomponentLogicalPath,
            IN WCHAR* pwszSubcomponentName
            );

        UINT GetComponentsCount()
            { return m_uNumComponents; }

        UINT GetSubcomponentsCount()
            { return m_uNumSubcomponents; }        

        const WCHAR* const * GetComponents()
            { return m_ppwszComponentLogicalPaths; }
        
        const WCHAR* const * GetSubcomponents()
            { return m_ppwszSubcomponentLogicalPaths; }            
private:        
    HRESULT AddSelected(IN WCHAR* pwszLogicalPath, WCHAR**& ppwszLogicalPaths, UINT& uSize);
    BOOL IsSelected(IN WCHAR* pwszLogicalPath, IN WCHAR* pwszName, IN WCHAR** pwszLogicalPaths,
                             IN  UINT uSize);
    
    VSS_ID            m_WriterId;
    UINT                m_uNumComponents;
    WCHAR**         m_ppwszComponentLogicalPaths;
    UINT                m_uNumSubcomponents;
    WCHAR**         m_ppwszSubcomponentLogicalPaths;
	
};


class CWritersSelection :
	public IUnknown            // Must be the FIRST base class since we use CComPtr<CVssSnapshotSetObject>

{
protected:
	// Construction Destruction
	CWritersSelection();
	~CWritersSelection();
	
public:
	// Creation
	static CWritersSelection* CreateInstance();

	// Chosen writers & components management
	STDMETHOD(BuildChosenComponents)
		(
		WCHAR *pwszComponentsFileName
		);
	
	BOOL IsComponentSelected
		(
		IN VSS_ID WriterId,
		IN WCHAR* pwszComponentLogicalPath,
		IN WCHAR* pwszComponentName
		);

	BOOL IsSubcomponentSelected
		(
		IN VSS_ID WriterId,
		IN WCHAR* pwszComponentLogicalPath,
		IN WCHAR* pwszComponentName
		);

    const WCHAR* const * GetComponents
            (
            IN VSS_ID WriterId
            );
    const WCHAR* const * GetSubcomponents
            (
            IN VSS_ID WriterId
            );

    const UINT GetComponentsCount
            (
            IN VSS_ID WriterId
            );
    const UINT GetSubcomponentsCount
            (
            IN VSS_ID WriterId
            );
        
	// IUnknown
	STDMETHOD(QueryInterface)(REFIID iid, void** pp);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	
private:
	// Chosen writers
	CVssSimpleMap<VSS_ID, CWriterComponentsSelection*> m_WritersMap;
	
    // For life management
	LONG 	m_lRef;
};

#endif	// _COMPONTH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\samples\requestor\vsreq.h ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	    vsreq.h
**
**
** Abstract:
**
**	Sample program to
**      - obtain and display the Writer metadata.
**      - create a snapshot set
**
** Author:
**
**	Adi Oltean      [aoltean]       05-Dec-2000
**
**  The sample is based on the Metasnap test program  written by Michael C. Johnson.
**
**
** Revision History:
**
**--
*/

/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/

#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string.h>

#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>


#include <oleauto.h>

#define ATLASSERT(_condition)

#include <atlconv.h>
#include <atlbase.h>

extern CComModule _Module;
#include <atlcom.h>


///////////////////////////////////////////////////////////////////////////////
// Useful macros 

#define WSTR_GUID_FMT  L"{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}"

#define GUID_PRINTF_ARG( X )                                \
    (X).Data1,                                              \
    (X).Data2,                                              \
    (X).Data3,                                              \
    (X).Data4[0], (X).Data4[1], (X).Data4[2], (X).Data4[3], \
    (X).Data4[4], (X).Data4[5], (X).Data4[6], (X).Data4[7]


// Execute the given call and check that the return code must be S_OK
#define CHECK_SUCCESS( Call )                                                                           \
    {                                                                                                   \
        m_hr = Call;                                                                                    \
        if (m_hr != S_OK)                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, m_hr, GetStringFromFailureType(m_hr));                       \
    }

#define CHECK_NOFAIL( Call )                                                                            \
    {                                                                                                   \
        m_hr = Call;                                                                                    \
        if (FAILED(m_hr))                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, m_hr, GetStringFromFailureType(m_hr));                       \
    }


///////////////////////////////////////////////////////////////////////////////
// Constants

const MAX_VOLUMES       = 64;
const MAX_TEXT_BUFFER   = 512;


///////////////////////////////////////////////////////////////////////////////
// Main class


class CVssSampleRequestor
{
// Constructors& destructors
public:
    CVssSampleRequestor();
    ~CVssSampleRequestor();

// Attributes
public:

// Operations
public:

    // Initialize internal members
    void Initialize();

    // Parse command line arguments 
    void ParseCommandLine(
        IN  INT nArgsCount,
        IN  WCHAR ** ppwszArgsArray
        );

    // Creates a snapshot set
    void CreateSnapshotSet();

    // Completes the backup
    void BackupComplete();

    void GatherWriterMetadata();

    void GatherWriterStatus(
        IN  LPCWSTR wszWhen
        );

// Private methods:
private:
    LPCWSTR GetStringFromUsageType (VSS_USAGE_TYPE eUsageType);
    LPCWSTR GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType);
    LPCWSTR GetStringFromRestoreMethod (VSS_RESTOREMETHOD_ENUM eRestoreMethod);
    LPCWSTR GetStringFromWriterRestoreMethod (VSS_WRITERRESTORE_ENUM eWriterRestoreMethod);
    LPCWSTR GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType);
    LPCWSTR GetStringFromFailureType (HRESULT hrStatus);
    LPCWSTR GetStringFromWriterStatus(VSS_WRITER_STATE eWriterStatus);

    void PrintUsage();
    void Error(INT nReturnCode, const WCHAR* pwszMsgFormat, ...);
    void PrintFiledesc (IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription);

    void AddVolumeForComponent( IN IVssWMFiledesc* pFileDesc );
    bool AddVolume( IN WCHAR* pwszVolume, OUT bool & bAdded );

// Implementation
private:
    CComPtr<IVssBackupComponents>   m_pBackupComponents;
    bool        m_bCoInitializeSucceeded;
    bool        m_bBootableSystemState;
    bool        m_bComponentSelectionEnabled;
    INT         m_nVolumesCount;
    WCHAR*      m_ppwszVolumesList[MAX_VOLUMES];
    WCHAR*      m_ppwszVolumeNamesList[MAX_VOLUMES];
    HRESULT     m_hr;
    WCHAR*      m_pwszXmlFile;
    FILE*       m_pXmlFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\betest\cwriter.h ===
//
//  ATL debugging support turned on at debug version
//  BUGBUG: the ATL thunking support is not enable yet in IA64
//  When this will be enabled then enable it here also!
//
#ifdef _DEBUG
#ifdef _M_IX86
#define _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_QI
#define _ATL_DEBUG_REFCOUNT
#endif
#endif // _DEBUG

class CTestVssWriter : public CVssWriter
    {
public:
    enum
        {
        x_bitWaitIdentify = 1,
        x_bitWaitPrepareForBackup = 2,
        x_bitWaitPostSnapshot = 4,
        x_bitWaitBackupComplete = 8,
        x_bitWaitPreRestore = 16,
        x_bitWaitPostRestore = 32,
        x_bitWaitPrepareSnapshot = 64,
        x_bitWaitFreeze = 128,
        x_bitWaitThaw = 256,
        x_bitWaitAbort = 512,
        x_RestoreTestOptions_RestoreIfNotThere = 1
        };

    CTestVssWriter(bool bRestoreTest, bool bTestNewInterfaces, LONG lWait, LONG lRestoreTestOptions) :
        m_lWait(lWait),
        m_bRestoreTest(bRestoreTest),
        m_bTestNewInterfaces(bTestNewInterfaces),
        m_lRestoreTestOptions(lRestoreTestOptions),
        m_rghOpen(NULL),
        m_chOpen(0),
        m_chOpenMax(0)
        {
        }

    ~CTestVssWriter()
        {
        for(UINT ih = 0; ih < m_chOpen; ih++)
            CloseHandle(m_rghOpen[ih]);

        delete m_rghOpen;
        }


    void Initialize();

    virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

    virtual bool STDMETHODCALLTYPE OnPrepareBackup(IN IVssWriterComponents *pComponent);

    virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

    virtual bool STDMETHODCALLTYPE OnFreeze();

    virtual bool STDMETHODCALLTYPE OnThaw();

    virtual bool STDMETHODCALLTYPE OnAbort();
    virtual bool STDMETHODCALLTYPE OnPostSnapshot(IN IVssWriterComponents *pComponent);


    virtual bool STDMETHODCALLTYPE OnBackupComplete(IN IVssWriterComponents *pComponent);

    virtual bool STDMETHODCALLTYPE OnBackupShutdown(IN VSS_ID SnapshotSetId);

    virtual bool STDMETHODCALLTYPE OnPreRestore(IN IVssWriterComponents *pComponent);

    virtual bool STDMETHODCALLTYPE OnPostRestore(IN IVssWriterComponents *pComponent);
private:
    bool DoNewInterfacesTestIdentify(IVssCreateWriterMetadata* pMetadata);

    bool DoRestoreTestIdentify(IN IVssCreateWriterMetadata *pMetadata);
    bool DoRestoreTestPrepareBackup(IN IVssWriterComponents *pComponents);
    bool DoRestoreTestPreRestore(IN IVssWriterComponents *pComponents);
    bool DoRestoreTestPostRestore(IN IVssWriterComponents *pComponents);
    void DoAddComponent
        (
        IVssCreateWriterMetadata *pMetadata,
        LPCWSTR wszComponentName,
        LPCWSTR wszRootDirectory,
        LPCWSTR wszSubdirectory,
        LPCWSTR wszFilespec,
        LPCWSTR wszAlternateDirectory,
        bool selectable,
        bool selectableForRestore,
        LONG attributes
        );

    void CreateDirectoryName(LPWSTR buf);
    void CreateComponentFilesA(LPCWSTR buf, bool bKeepOpen);
    void CreateComponentFilesB(LPCWSTR buf, bool bKeepOpen);
    void CreateComponentFilesC(LPCWSTR buf, bool bKeepOpen);
    void VerifyComponentFilesA(LPCWSTR buf);
    void VerifyComponentFilesB(LPCWSTR buf);
    void VerifyComponentFilesC(LPCWSTR buf);

    void DoCreateFile
            (
            LPCWSTR wszPath,
            LPCWSTR wszFilename,
            DWORD length,
            bool bKeepOpen
            );

    void DoVerifyFile(LPCWSTR wszPath, LPCWSTR wszFilename, DWORD length);

    LONG m_lWait;
    LONG m_lRestoreTestOptions;
    bool m_bRestoreTest;
    bool m_bTestNewInterfaces;
    HANDLE *m_rghOpen;
    UINT m_chOpen;
    UINT m_chOpenMax;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\betest\compont.cpp ===
#include "stdafx.hxx"
#include "vs_idl.hxx"
#include "vswriter.h"
#include "vsbackup.h"
#include "compont.h"
#include <debug.h>
#include <cwriter.h>
#include <lmshare.h>
#include <lmaccess.h>
#include <time.h>

//
//  CWriterComponentsSelection class
//

CWriterComponentsSelection::CWriterComponentsSelection()
{
    m_WriterId = GUID_NULL;
    m_uNumComponents = 0;
    m_uNumSubcomponents = 0;
    m_ppwszComponentLogicalPaths = NULL;
    m_ppwszSubcomponentLogicalPaths = NULL;    
}

CWriterComponentsSelection::~CWriterComponentsSelection()
{
    if ((m_uNumComponents > 0) && (m_ppwszComponentLogicalPaths != NULL))
        {
        for (UINT i=0; i<m_uNumComponents; i++)
            {
            if (m_ppwszComponentLogicalPaths[i] != NULL)
                {
                free(m_ppwszComponentLogicalPaths[i]);
                m_ppwszComponentLogicalPaths[i] = NULL;
                }
            }

        free(m_ppwszComponentLogicalPaths);
        m_ppwszComponentLogicalPaths = NULL;
        m_uNumComponents = 0;
        }

    if ((m_uNumSubcomponents > 0) && (m_ppwszSubcomponentLogicalPaths != NULL))
        {
        for (UINT i=0; i<m_uNumSubcomponents; i++)
            {
            if (m_ppwszSubcomponentLogicalPaths[i] != NULL)
                {
                free(m_ppwszSubcomponentLogicalPaths[i]);
                m_ppwszSubcomponentLogicalPaths[i] = NULL;
                }
            }

        free(m_ppwszSubcomponentLogicalPaths);
        m_ppwszSubcomponentLogicalPaths = NULL;
        m_uNumSubcomponents = 0;
        }    
}



void CWriterComponentsSelection::SetWriter
    (
    IN VSS_ID WriterId
    )
{
    m_WriterId = WriterId;
}

HRESULT CWriterComponentsSelection::AddSelectedComponent
    (
    IN WCHAR* pwszComponentLogicalPath
    )
{
    return AddSelected(pwszComponentLogicalPath, m_ppwszComponentLogicalPaths, m_uNumComponents);
}

HRESULT CWriterComponentsSelection::AddSelectedSubcomponent
    (
    IN WCHAR* pwszSubcomponentLogicalPath
    )
{
    return AddSelected(pwszSubcomponentLogicalPath, m_ppwszSubcomponentLogicalPaths, m_uNumSubcomponents);
}

HRESULT CWriterComponentsSelection::AddSelected
    (
    IN WCHAR* pwszLogicalPath, 
    WCHAR**& pwszLogicalPaths, 
    UINT& uSize
    )
{
    if (m_WriterId == GUID_NULL)
        {
        // Don't allow adding components to NULL writer...
        return E_UNEXPECTED;
        }

    if (pwszLogicalPath == NULL)
        {
        return E_INVALIDARG;
        }

    // A more clever implementation would allocate memory in chuncks, but this is just a test program...
    PWCHAR *ppwzTemp = (PWCHAR *) realloc(pwszLogicalPaths, (uSize+1) * sizeof (PWCHAR));
    if (ppwzTemp != NULL)
        {
        pwszLogicalPaths = ppwzTemp;
        pwszLogicalPaths[uSize] = NULL;
        }
    else
        {
        return E_OUTOFMEMORY;
        }

    pwszLogicalPaths[uSize] = (PWCHAR) malloc((wcslen(pwszLogicalPath) + 1) * sizeof (WCHAR));
    if (pwszLogicalPaths[uSize] != NULL)
        {
        wcscpy(pwszLogicalPaths[uSize], pwszLogicalPath);
        uSize++;
        }
    else
        {
        return E_OUTOFMEMORY;
        }

    return S_OK;
}

    BOOL CWriterComponentsSelection::IsComponentSelected
        (
        IN WCHAR* pwszComponentLogicalPath,
        IN WCHAR* pwszComponentName
        )
    {
        return IsSelected(pwszComponentLogicalPath, pwszComponentName, 
                    m_ppwszComponentLogicalPaths, m_uNumComponents);
    }

BOOL CWriterComponentsSelection::IsSubcomponentSelected
    (
    IN WCHAR* pwszSubcomponentLogicalPath,
    IN WCHAR* pwszSubcomponentName
    )
{
    return IsSelected(pwszSubcomponentLogicalPath, pwszSubcomponentName, 
                m_ppwszSubcomponentLogicalPaths, m_uNumSubcomponents);
}

BOOL CWriterComponentsSelection::IsSelected(IN WCHAR* pwszLogicalPath, IN WCHAR* pwszName, 
                        IN WCHAR** pwszLogicalPaths, IN  UINT uSize)
{
   if (m_WriterId == GUID_NULL)
        {
        // Don't allow query for NULL writer...
        return FALSE;
        }
    if (uSize <= 0)
        {
        return FALSE;
        }

    // A component matches if:
    //  1. The selection criteria is on the logical-path of the leaf component  OR
    //  2. The selection criteria is <full-logical-path>\<component-name>
    //  3. The selction criteria is component-name (only if logical-path is NULL)

    for (UINT i=0; i<uSize; i++)
        {
        DWORD dwLen;

        if (pwszLogicalPaths[i] == NULL)
            {
            continue;
            }

        dwLen = (DWORD)wcslen(pwszLogicalPaths[i]);

        if (pwszLogicalPath != NULL)
            {
            // Case 1.
            if (_wcsnicmp(pwszLogicalPaths[i], pwszLogicalPath, dwLen) == 0 &&
                 pwszName == NULL)
                {
                return TRUE;
                }

            // Case 2.
            if (pwszName == NULL)
                {
                continue;
                }
            WCHAR* pwszTemp = wcsrchr(pwszLogicalPaths[i], L'\\');
            if (pwszTemp == NULL)
                {
                continue;
                }
            if ((pwszTemp != pwszLogicalPaths[i]) && (*(pwszTemp+1) != '\0'))
                {
                dwLen = (DWORD)(pwszTemp - pwszLogicalPaths[i]);
                if ( (dwLen == wcslen(pwszLogicalPath)) &&
                     (_wcsnicmp(pwszLogicalPaths[i], pwszLogicalPath, dwLen) == 0) &&
                     (wcscmp(pwszTemp+1, pwszName) == 0) )
                    {
                    return TRUE;
                    }
                }
            }
        else
            {
            // Case 3.
            if (pwszName == NULL)
                {
                continue;
                }
            if (_wcsnicmp(pwszLogicalPaths[i], pwszName, dwLen) == 0)
                {
                return TRUE;
                }
            }
        }

    return FALSE;
}

//
//  CWritersSelection class
//

CWritersSelection::CWritersSelection()
{
    m_lRef = 0;
}

CWritersSelection::~CWritersSelection()
{
    // Cleanup the Map
    for(int nIndex = 0; nIndex < m_WritersMap.GetSize(); nIndex++)
        {
        CWriterComponentsSelection* pComponentsSelection = m_WritersMap.GetValueAt(nIndex);
        if (pComponentsSelection)
            {
            delete pComponentsSelection;
            }
        }

    m_WritersMap.RemoveAll();
}

CWritersSelection* CWritersSelection::CreateInstance()
{
    CWritersSelection* pObj = new CWritersSelection;

    return pObj;
}

STDMETHODIMP CWritersSelection::QueryInterface(
    IN  REFIID iid,
    OUT void** pp
    )
{
    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
    return S_OK;
}


ULONG CWritersSelection::AddRef()
{
    return ::InterlockedIncrement(&m_lRef);
}


ULONG CWritersSelection::Release()
{
    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We assume that we always allocate this object on the heap!
    return l;
}


STDMETHODIMP CWritersSelection::BuildChosenComponents
    (
    WCHAR *pwszComponentsFileName
    )
{
    HRESULT hr = S_OK;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    DWORD dwBytesToRead = 0;
    DWORD dwBytesRead;

    // Create the file
    hFile = CreateFile(pwszComponentsFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        {
        DWORD dwLastError = GetLastError();
        wprintf(L"Invalid components file, CreateFile returned = %lu\n", dwLastError);
        return HRESULT_FROM_WIN32(dwLastError);
        }

    if ((dwBytesToRead = GetFileSize(hFile, NULL)) <= 0)
        {
        CloseHandle(hFile);
        DWORD dwLastError = GetLastError();
        wprintf(L"Invalid components file, GetFileSize returned = %lu\n", dwLastError);
        return HRESULT_FROM_WIN32(dwLastError);
        }

    if (dwBytesToRead > 0x100000)
        {
        CloseHandle(hFile);
        wprintf(L"Invalid components file, Provide a file with a size of less than 1 MB\n");
        return E_FAIL;
        }

    char * pcBuffer = (PCHAR) malloc (dwBytesToRead);
    if (! pcBuffer)
        {
        CloseHandle(hFile);
        return E_OUTOFMEMORY;
        }

    // Read the components info
    if (! ReadFile(hFile, (LPVOID)pcBuffer, dwBytesToRead, &dwBytesRead, NULL))
        {
        DWORD dwLastError = GetLastError();
        CloseHandle(hFile);
        free (pcBuffer);
        wprintf(L"Invalid components file, ReadFile returned = %lu\n", dwLastError);
        return HRESULT_FROM_WIN32(dwLastError);
        }

    CloseHandle(hFile);

    if (dwBytesToRead != dwBytesRead)
        {
        free (pcBuffer);
        wprintf(L"Components selection file is supposed to have %lu bytes but only %lu bytes are read\n", dwBytesToRead, dwBytesRead);
        return E_FAIL;
        }

    // Allocate a buffer to work with
    WCHAR * pwcBuffer = (PWCHAR) malloc ((dwBytesToRead+1) * sizeof(WCHAR));
    if (! pwcBuffer)
        {
        free (pcBuffer);
        return E_OUTOFMEMORY;
        }

    // Simple pasring, assume ANSI, Format:
    // "writer1-id": "component1.1-name", "component1.2-name",...        ; "writer2-id": "component2.1-name", ...
    CWriterComponentsSelection* pWriterComponents = NULL;

    try
        {
        VSS_ID WriterId = GUID_NULL;
        BOOL bBeforeWriter = TRUE;
        BOOL bBeforeComponents = TRUE;
        BOOL bInString = FALSE;
        char* pcStart = NULL;

        for (char* pcCurrent = pcBuffer; pcCurrent < (pcBuffer+dwBytesToRead); pcCurrent++)
            {
            switch (*pcCurrent)
                {
                case ':':
                    if (bBeforeWriter && !bInString)
                        {
                        bBeforeWriter = FALSE;
                        }
                    else if (bBeforeComponents && !bInString)
                        {
                        bBeforeComponents = FALSE;
                        }
                    else if (!bInString)
                        {
                        throw(E_FAIL);
                        }
                    break;

                case ';':
                    if (bBeforeWriter || bInString)
                        {
                        throw(E_FAIL);
                        }
                    else
                        {
                        // If we have a valid writer - add it to the map
                        if ((pWriterComponents != NULL) && (WriterId != GUID_NULL))
                            {
                            if (!m_WritersMap.Add(WriterId, pWriterComponents)) 
                                {
                                delete pWriterComponents;
                                throw E_OUTOFMEMORY;
                                }

                            pWriterComponents = NULL;
                            WriterId = GUID_NULL;
                            }

                        bBeforeWriter = TRUE;
                        }
                    break;

                case ',':
                    if (bBeforeWriter || bInString)
                        {
                        throw(E_FAIL);
                        }
                    break;

                case '"':
                    if (! bInString)
                        {
                        // Mark string-start for later
                        pcStart = pcCurrent + 1;
                        }
                    else if (pcStart == pcCurrent)
                        {
                        // empty string - skip it
                        }
                    else
                        {
                        // String ends - convert to WCHAR and process
                        DWORD dwSize = (DWORD)mbstowcs(pwcBuffer, pcStart, pcCurrent - pcStart);
                        pwcBuffer[dwSize] = NULL;
                        if (dwSize <= 0)
                            {
                            throw(E_FAIL);
                            }

                        if (bBeforeWriter)
                            {
                            // If before-writer - must be a writer GUID
                            HRESULT hrConvert = CLSIDFromString(pwcBuffer, &WriterId);
                            if ((! SUCCEEDED(hrConvert)) && (hrConvert != REGDB_E_WRITEREGDB))
                                {
                                wprintf(L"A writer id in the components selection file is in invalid GUID format\n");
                                throw(E_FAIL);
                                }

                            if (pWriterComponents != NULL)
                                {
                                // Previous writer info was not ended correctly
                                throw(E_FAIL);
                                }

                            pWriterComponents = new CWriterComponentsSelection;
                            if (pWriterComponents == NULL)
                                {
                                throw(E_OUTOFMEMORY);
                                }
                            pWriterComponents->SetWriter(WriterId);
                            }
                        else if (bBeforeComponents)
                            {
                            // Must be a component logical-path , name or logical-path\name
                            if (pWriterComponents != NULL)
                                {
                                pWriterComponents->AddSelectedComponent(pwcBuffer);
                                }
                            }
                        else 
                            {
                            // Must be a component logical-path , name or logical-path\name
                            if (pWriterComponents != NULL)
                                {
                                pWriterComponents->AddSelectedSubcomponent(pwcBuffer);
                                }                            
                            }
                        }

                    // Flip in-string flag
                    bInString = (! bInString);

                    break;

                case ' ':
                    break;

                case '\n':
                case '\t':
                case '\r':
                    if (bInString)
                        {
                        throw(E_FAIL);
                        }

                    break;

                default:
                    if (! bInString)
                        {
                        throw(E_FAIL);
                        }

                    break;

                }
            }
         }

    catch (HRESULT hrParse)
        {
        hr = hrParse;

        if (hr == E_FAIL)
            {
            wprintf(L"Invalid format of components selection file\n");
            }

        if (pWriterComponents != NULL)
            {
            // Error int he middle of writer-components creation (not added to the map yet...)
            delete pWriterComponents;
            }
        }

    free (pcBuffer);
    free (pwcBuffer);

    return hr;
}
    
BOOL CWritersSelection::IsComponentSelected
    (
    IN VSS_ID WriterId,
    IN WCHAR* pwszComponentLogicalPath,
    IN WCHAR* pwszComponentName
    )
{
    CWriterComponentsSelection* pWriterComponents = m_WritersMap.Lookup(WriterId);
    if (pWriterComponents == NULL)
        {
        // No component is selected for this writer
        return FALSE;
        }

    // There are components selected for this writer, check if this specific one is selected
    return pWriterComponents->IsComponentSelected(pwszComponentLogicalPath, pwszComponentName);
}

BOOL CWritersSelection::IsSubcomponentSelected
    (
    IN VSS_ID WriterId,
    IN WCHAR* pwszComponentLogicalPath,
    IN WCHAR* pwszComponentName
    )
{
    CWriterComponentsSelection* pWriterComponents = m_WritersMap.Lookup(WriterId);
    if (pWriterComponents == NULL)
        {
        // No component is selected for this writer
        return FALSE;
        }

    // There are subccomponents selected for this writer, check if this specific one is selected
    return pWriterComponents->IsSubcomponentSelected(pwszComponentLogicalPath, pwszComponentName);
}

const WCHAR* const * CWritersSelection::GetComponents
    (
    IN VSS_ID WriterId
    )
{
    CWriterComponentsSelection* pWriterComponents = m_WritersMap.Lookup(WriterId);
    if (pWriterComponents == NULL)
        {
        return NULL;
        }

    return pWriterComponents->GetComponents();
}

const WCHAR* const * CWritersSelection::GetSubcomponents
    (
    IN VSS_ID WriterId
    )
{
    CWriterComponentsSelection* pWriterComponents = m_WritersMap.Lookup(WriterId);
    if (pWriterComponents == NULL)
        {
        return NULL;
        }

    return pWriterComponents->GetSubcomponents();
}

const UINT CWritersSelection::GetComponentsCount
    (
    IN VSS_ID WriterId
    )
{
    CWriterComponentsSelection* pWriterComponents = m_WritersMap.Lookup(WriterId);
    if (pWriterComponents == NULL)
        {
        return NULL;
        }

    return pWriterComponents->GetComponentsCount();
}

const UINT CWritersSelection::GetSubcomponentsCount
    (
    IN VSS_ID WriterId
    )
{
    CWriterComponentsSelection* pWriterComponents = m_WritersMap.Lookup(WriterId);
    if (pWriterComponents == NULL)
        {
        return NULL;
        }

    return pWriterComponents->GetSubcomponentsCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\betest\cwriter.cpp ===
#include "stdafx.hxx"
#include "vs_idl.hxx"
#include "vswriter.h"
#include "vsbackup.h"
#include "vs_seh.hxx"
#include "vs_trace.hxx"
#include "compont.h"
#include <debug.h>
#include <cwriter.h>
#include <lmshare.h>
#include <lmaccess.h>
#include <time.h>


#define IID_PPV_ARG( Type, Expr ) IID_##Type, reinterpret_cast< void** >( static_cast< Type** >( Expr ) )
#define SafeQI( Type, Expr ) QueryInterface( IID_PPV_ARG( Type, Expr ) )

static BYTE x_rgbIcon[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
static unsigned x_cbIcon = 10;


static VSS_ID s_WRITERID =
    {
    0xc0577ae6, 0xd741, 0x452a,
    0x8c, 0xba, 0x99, 0xd7, 0x44, 0x00, 0x8c, 0x04
    };

static LPCWSTR s_WRITERNAME = L"BeTest Writer";

LPCWSTR GetStringFromRestoreType(_VSS_RESTORE_TYPE eRestoreType)
	{
	LPCWSTR pwszRetString = L"UNDEFINED";

	switch(eRestoreType)
		{
		case VSS_RTYPE_BY_COPY: pwszRetString = L"ByCopy"; break;
		case VSS_RTYPE_IMPORT: pwszRetString = L"Import"; break;
		case VSS_RTYPE_OTHER:pwszRetString = L"Other"; break;

		default:
		    break;
		}

	return (pwszRetString);
	}

void CTestVssWriter::Initialize()
    {
    HRESULT hr;

    CHECK_SUCCESS(CVssWriter::Initialize
                    (
                    s_WRITERID,
                    s_WRITERNAME,
                    VSS_UT_USERDATA,
                    VSS_ST_OTHER
                    ));
    }

bool STDMETHODCALLTYPE CTestVssWriter::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
    {
    HRESULT hr;

    wprintf(L"\n\n***OnIdentify***\n");
    if(m_bTestNewInterfaces)
	 return DoNewInterfacesTestIdentify(pMetadata);
    
    if (m_bRestoreTest)
        return DoRestoreTestIdentify(pMetadata);

    if (m_lWait & x_bitWaitIdentify)
        {
        wprintf(L"\nWaiting 30 seconds in OnIdentify.\n\n");
        Sleep(30000);
        }


    CHECK_SUCCESS(pMetadata->AddExcludeFiles
                        (
                        L"%systemroot%\\config",
                        L"*.tmp",
                        true
                        ));

    CHECK_SUCCESS(pMetadata->AddComponent
                        (
                        VSS_CT_DATABASE,
                        L"\\mydatabases",
                        L"db1",
                        L"this is my main database",
                        x_rgbIcon,
                        x_cbIcon,
                        true,
                        true,
                        true
                        ));

    CHECK_SUCCESS(pMetadata->AddDatabaseFiles
                    (
                    L"\\mydatabases",
                    L"db1",
                    L"e:\\databases",
                    L"foo1.db"
                    ));

    CHECK_SUCCESS(pMetadata->AddDatabaseFiles
                    (
                    L"\\mydatabases",
                    L"db1",
                    L"e:\\databases",
                    L"foo2.db"
                    ));


    CHECK_SUCCESS(pMetadata->AddDatabaseLogFiles
                    (
                    L"\\mydatabases",
                    L"db1",
                    L"e:\\logs",
                    L"foo.log"
                    ));

    CHECK_SUCCESS(pMetadata->SetRestoreMethod
                    (
                    VSS_RME_RESTORE_IF_NOT_THERE,
                    NULL,
                    NULL,
                    VSS_WRE_ALWAYS,
                    true
                    ));

    CHECK_SUCCESS(pMetadata->AddAlternateLocationMapping
                    (
                    L"c:\\databases",
                    L"*.db",
                    false,
                    L"e:\\databases\\restore"
                    ));

    CHECK_SUCCESS(pMetadata->AddAlternateLocationMapping
                    (
                    L"d:\\logs",
                    L"*.log",
                    false,
                    L"e:\\databases\\restore"
                    ));


    return true;
    }

bool DoPrepareBackupDatabase(IVssComponent* pComponent)
    {
    HRESULT hr;
    
    CComBSTR bstrLogicalPath;
    CComBSTR bstrComponentName;
    CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
    CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));

    wprintf
    (
    L"Backing up database %s\\%s.\n",
    bstrLogicalPath,
    bstrComponentName
    );
    
    WCHAR buf[100];
    wsprintf (buf, L"backupTime = %d\n", (INT) time(NULL));

    CHECK_SUCCESS(pComponent->SetBackupMetadata(buf));
    wprintf(L"\nBackupMetadata=%s\n", buf);

    CComBSTR bstrPreviousStamp;
    CHECK_NOFAIL(pComponent->GetPreviousBackupStamp(&bstrPreviousStamp));
    if (bstrPreviousStamp)
        wprintf(L"Previous stamp = %s\n", bstrPreviousStamp);

    CComBSTR bstrBackupOptions;
    CHECK_NOFAIL(pComponent->GetBackupOptions(&bstrBackupOptions));
    if (bstrBackupOptions)
        wprintf(L"Backup options = %s\n", bstrBackupOptions);

    WCHAR wszBackupStamp[32];
    swprintf(wszBackupStamp, L"B-%d-", clock());
    CHECK_SUCCESS(pComponent->SetBackupStamp(wszBackupStamp));
    wprintf(L"Backup stamp = %s\n\n", wszBackupStamp);

    return true;
    }

bool DoPrepareBackupFilegroup(IVssComponent* pComponent)
    {
    HRESULT hr;
    
    CComBSTR bstrLogicalPath;
    CComBSTR bstrComponentName;
    CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
    CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));

    wprintf
    (
    L"Backing up filegroup %s\\%s.\n",
    bstrLogicalPath,
    bstrComponentName
    );

    return true;
    }

bool STDMETHODCALLTYPE CTestVssWriter::OnPrepareBackup(IN IVssWriterComponents *pWriterComponents)
    {
    HRESULT hr;

    wprintf(L"\n\n***OnPrepareBackup***\n");
    if (m_bRestoreTest)
        return DoRestoreTestPrepareBackup(pWriterComponents);
    

    if (m_lWait & x_bitWaitPrepareForBackup)
        {
        wprintf(L"\nWaiting 10 seconds in PrepareForBackup.\n\n");
        Sleep(10000);
        }

    unsigned cComponents;
    LPCWSTR wszBackupType;
    switch(GetBackupType())
        {
        default:
            wszBackupType = L"undefined";
            break;

        case VSS_BT_FULL:
            wszBackupType = L"full";
            break;

        case VSS_BT_INCREMENTAL:
            wszBackupType = L"incremental";
            break;

        case VSS_BT_DIFFERENTIAL:
            wszBackupType = L"differential";
            break;

        case VSS_BT_LOG:
            wszBackupType = L"log";
            break;

        case VSS_BT_COPY:
            wszBackupType = L"copy";
            break;

        case VSS_BT_OTHER:
            wszBackupType = L"other";
            break;
        }

    wprintf(L"\n\n***OnPrepareBackup****\nBackup Type = %s\n", wszBackupType);

    wprintf
        (
        L"AreComponentsSelected = %s\n",
        AreComponentsSelected() ? L"yes" : L"no"
        );

    wprintf
        (
        L"BootableSystemStateBackup = %s\n\n",
        IsBootableSystemStateBackedUp() ? L"yes" : L"no"
        );

    CHECK_SUCCESS(pWriterComponents->GetComponentCount(&cComponents));
    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
        {
        CComPtr<IVssComponent> pComponent;
        VSS_COMPONENT_TYPE ct;

        CHECK_SUCCESS(pWriterComponents->GetComponent(iComponent, &pComponent));
        CHECK_SUCCESS(pComponent->GetComponentType(&ct));

        wprintf(L"Current backup context is 0x%x\n", GetContext());

        if (ct == VSS_CT_DATABASE)
             DoPrepareBackupDatabase(pComponent);
	 else
	      DoPrepareBackupFilegroup(pComponent);
    	}

    
    return true;
    }

bool STDMETHODCALLTYPE CTestVssWriter::OnPrepareSnapshot()
    {
    wprintf(L"\n\n***OnPrepareSnapshot***\n");

    if (m_lWait & x_bitWaitPrepareSnapshot)
        {
        wprintf(L"\nWaiting 10 seconds in PrepareSnapshot.\n\n");
        Sleep(10000);
        }

    if (!m_bRestoreTest)
        IsPathAffected(L"e:\\foobar");

    wprintf(L"Current backup context is 0x%x\n", GetContext());

    return true;
    }


bool STDMETHODCALLTYPE CTestVssWriter::OnFreeze()
    {
    wprintf(L"\n\n***OnFreeze***\n");

    if (m_lWait & x_bitWaitFreeze)
        {
        wprintf(L"\nWaiting 10 seconds in Freeze.\n\n");
        Sleep(10000);
        }

    wprintf(L"Current backup context is 0x%x\n", GetContext());

    return true;
    }

bool STDMETHODCALLTYPE CTestVssWriter::OnThaw()
    {
    wprintf(L"\n\n***OnThaw***\n");

    if (m_lWait & x_bitWaitThaw)
        {
        wprintf(L"\nWaiting 10 seconds in PrepareThaw.\n\n");
        Sleep(10000);
        }

    wprintf(L"Current backup context is 0x%x\n", GetContext());

    return true;
    }

bool STDMETHODCALLTYPE CTestVssWriter::OnBackupComplete(IN IVssWriterComponents *pWriterComponents)
    {
    HRESULT hr;

    wprintf(L"\n\n***OnBackupComplete***\n");

    wprintf(L"Current backup context is 0x%x\n", GetContext());
    
    if (m_bRestoreTest)
        return true;

    if (m_lWait & x_bitWaitBackupComplete)
        {
        wprintf(L"\nWaiting 30 seconds in BackupComplete.\n\n");
        Sleep(30000);
        }

    unsigned cComponents;
    CHECK_SUCCESS(pWriterComponents->GetComponentCount(&cComponents));
    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
        {
        CComPtr<IVssComponent> pComponent;
        VSS_COMPONENT_TYPE ct;
        CComBSTR bstrLogicalPath;
        CComBSTR bstrComponentName;
        bool bBackupSucceeded;

    
        CHECK_SUCCESS(pWriterComponents->GetComponent(iComponent, &pComponent));
        CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
        CHECK_SUCCESS(pComponent->GetComponentType(&ct));
        CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
        CHECK_SUCCESS(pComponent->GetBackupSucceeded(&bBackupSucceeded));
        if (ct == VSS_CT_DATABASE)
        	wprintf(L"Database ");
        else
        	wprintf(L"FileGroup ");
        wprintf
            (
            L"%s\\%s backup %s.\n",
            bstrLogicalPath,
            bstrComponentName,
            bBackupSucceeded ? L"succeeded" : L"failed"
            );

        CComBSTR bstrMetadata;
        CHECK_NOFAIL(pComponent->GetBackupMetadata(&bstrMetadata));
        wprintf(L"backupMetadata=%s\n", bstrMetadata);
        }


    return true;
    }

bool STDMETHODCALLTYPE CTestVssWriter::OnBackupShutdown(IN VSS_ID SnapshotSetId)
  {
  if (!m_bTestNewInterfaces)
  	return true;

  wprintf(L"OnBackupShutdown called for snapshot-set id " WSTR_GUID_FMT L"\n", 
  	 GUID_PRINTF_ARG(SnapshotSetId));

  return true;
  }

bool STDMETHODCALLTYPE CTestVssWriter::OnPreRestore(IN IVssWriterComponents *pWriter)
    {
    if (m_bTestNewInterfaces)
    	{
    	VSS_RESTORE_TYPE type = GetRestoreType();
    	wprintf(L"\nRestore type is %s\n", GetStringFromRestoreType(type));
    	}
    
    wprintf(L"\n\n***OnPreRestore***\n");
    if (m_bRestoreTest)
        return DoRestoreTestPreRestore(pWriter);


    if (m_lWait & x_bitWaitPreRestore)
        {
        wprintf(L"\nWaiting 10 seconds in PreRestore.\n\n");
        Sleep(10000);
        }

    HRESULT hr;

    UINT cComponents;
    CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
    for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
        {
        CComPtr<IVssComponent> pComponent;

        CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));

        PrintRestoreSubcomponents(pComponent);

        CComBSTR bstrBackupMetadata;
        CHECK_NOFAIL(pComponent->GetBackupMetadata(&bstrBackupMetadata));

        if (bstrBackupMetadata)
            wprintf(L"BackupMetadata=%s\n", bstrBackupMetadata);

        WCHAR buf[100];
        wsprintf (buf, L"restoreTime = %d", (INT) time(NULL));

        CHECK_SUCCESS(pComponent->SetRestoreMetadata(buf));
        wprintf(L"\nRestoreMetadata=%s\n", buf);

        CComBSTR bstrRestoreOptions;
        bool bAdditionalRestores;
        bool bSelectedForRestore;
        CHECK_SUCCESS(pComponent->GetAdditionalRestores(&bAdditionalRestores));
        CHECK_SUCCESS(pComponent->IsSelectedForRestore(&bSelectedForRestore));
        CHECK_NOFAIL(pComponent->GetRestoreOptions(&bstrRestoreOptions));
        wprintf(L"SelectedForRestore=%s\n", bSelectedForRestore ? L"Yes" : L"No");
        wprintf(L"Additional restores=%s\n", bAdditionalRestores ? L"Yes" : L"No");
        if (bstrRestoreOptions)
            wprintf(L"Restore options=%s\n", bstrRestoreOptions);

        ULONG type = clock() % 47;
        VSS_RESTORE_TARGET rt;

        if (type >= 15 && type < 30 && IsPartialFileSupportEnabled())
            rt = VSS_RT_DIRECTED;
        else if (type >= 30 && type < 40)
            rt = VSS_RT_ORIGINAL;
        else
            rt = VSS_RT_ALTERNATE;

        wprintf(L"restore target = %s\n", WszFromRestoreTarget(rt));
        CHECK_SUCCESS(pComponent->SetRestoreTarget(rt));
        if (rt == VSS_RT_DIRECTED)
            {
            CHECK_SUCCESS(pComponent->AddDirectedTarget
                                (
                                L"e:\\databases",
                                L"foo1.db",
                                L"0x8000:0x10000",
                                L"e:\\newdatabases",
                                L"copy1.db",
                                L"0x0000:0x10000"
                                ));

            CHECK_SUCCESS(pComponent->AddDirectedTarget
                                (
                                L"e:\\databases",
                                L"foo2.db",
                                L"0x4000:0x1000",
                                L"e:\\newdatabases",
                                L"copy1.db",
                                L"0x0000:0x1000"
                                ));

            PrintDirectedTargets(pComponent);

            if (m_bTestNewInterfaces)
                PrintNewTargets(pComponent);
            }

        wprintf(L"\n");

        CHECK_SUCCESS(pComponent->SetPreRestoreFailureMsg(L"PreRestore Successfully Completed."));
        }

    return true;
    }

bool STDMETHODCALLTYPE CTestVssWriter::OnPostRestore(IN IVssWriterComponents *pWriter)
    {
    wprintf(L"\n\n***OnPostRestore***\n");
    if (m_bRestoreTest)
        return DoRestoreTestPostRestore(pWriter);

    if (m_lWait & x_bitWaitPostRestore)
        {
        wprintf(L"\nWaiting 10 seconds in PostRestore.\n\n");
        Sleep(10000);
        }

    HRESULT hr;

    UINT cComponents;
    CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
    for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
        {
        CComPtr<IVssComponent> pComponent;

        CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));

        VSS_RESTORE_TARGET rt;
        CHECK_SUCCESS(pComponent->GetRestoreTarget(&rt));
        wprintf(L"RestoreTarget = %s\n", WszFromRestoreTarget(rt));
        if (rt == VSS_RT_DIRECTED)
            PrintDirectedTargets(pComponent);

        VSS_FILE_RESTORE_STATUS rs;
        CHECK_SUCCESS(pComponent->GetFileRestoreStatus(&rs));
        wprintf(L"RestoreStatus = %s\n", WszFromFileRestoreStatus(rs));

        CComBSTR bstrRestoreMetadata;
        CComBSTR bstrBackupMetadata;
        CHECK_NOFAIL(pComponent->GetRestoreMetadata(&bstrRestoreMetadata));
        CHECK_NOFAIL(pComponent->GetBackupMetadata(&bstrBackupMetadata));
        if (bstrRestoreMetadata)
            wprintf(L"RestoreMetadata=%s\n", bstrRestoreMetadata);

        if (bstrBackupMetadata)
            wprintf(L"BackupMetadata=%s\n", bstrBackupMetadata);

        wprintf(L"\n");

        CHECK_SUCCESS(pComponent->SetPostRestoreFailureMsg(L"PostRestore Successfully Completed."));
        }

    return true;
    }

bool STDMETHODCALLTYPE CTestVssWriter::OnAbort()
    {
    wprintf(L"\n\n***OnAbort***\n\n");
    if (m_lWait & x_bitWaitAbort)
        {
        wprintf(L"\nWaiting 10 seconds in Abort.\n\n");
        Sleep(10000);
        }

    return true;
    }

bool STDMETHODCALLTYPE CTestVssWriter::OnPostSnapshot
    (
    IN IVssWriterComponents *pWriter
    )
    {
    wprintf(L"\n\n***OnPostSnapshot***\n\n");
    if (m_bRestoreTest)
        return true;

    if (m_lWait & x_bitWaitPostSnapshot)
        {
        wprintf(L"\nWaiting 10 seconds in PostSnapshot.\n\n");
        Sleep(10000);
        }

    HRESULT hr;



    if (IsPartialFileSupportEnabled() &&
        GetBackupType() == VSS_BT_DIFFERENTIAL)
        {
        UINT cComponents;

        CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));

        for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
            {
            CComPtr<IVssComponent> pComponent;

            CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
            VSS_COMPONENT_TYPE ct;
            CHECK_SUCCESS(pComponent->GetComponentType(&ct));
            if (ct == VSS_CT_DATABASE)
                {
                CHECK_SUCCESS(pComponent->AddPartialFile
                                    (
                                    L"e:\\databases",
                                    L"foo1.db",
                                    L"0x8000:0x10000, 0x100000:0x2000",
                                    L"Length=0x200000"
                                    ));

                CHECK_SUCCESS(pComponent->AddPartialFile
                                (
                                L"e:\\databases",
                                L"foo2.db",
                                L"0x4000:0x1000",
                                L"Length=0x100000"
                                ));
                }

            PrintPartialFiles(pComponent);

	     if(m_bTestNewInterfaces)
	     	{
	     	::Sleep(1000);
	     	FILETIME time;
	     	CHECK_SUCCESS(CoFileTimeNow(&time));

	     	// add bogus files as differenced files
		CHECK_SUCCESS(pComponent->AddDifferencedFilesByLastModifyTime
			         (
			         L"C:\\",
			         L"Foo",
			         false,
			         time
			         ));

		CHECK_SUCCESS(pComponent->AddDifferencedFilesByLastModifyLSN
			         (
			         L"C:\\",
			         L"Bar",
			         true,
			         L"MYLSNFORMAT"
			         ));

	       if (GetSnapshotDeviceName(NULL, NULL) != E_NOTIMPL)
       	    Error(1, L"GetSnapshotDeviceName should return E_NOTIMPL");
	     }
            }

        }

    return true;
    }

void CTestVssWriter::CreateDirectoryName(LPWSTR buf)
    {
    UINT cwc = ExpandEnvironmentStrings(L"%SystemDrive%", buf, 1024);
    if (cwc == 0)
        {
        DWORD dwErr = GetLastError();
        Error(HRESULT_FROM_WIN32(dwErr), L"ExpandEnvironmentStrings failed with error %d.\n", dwErr);
        }

    wcscat(buf, L"\\BETESTWRITERFILES");
    }


bool CTestVssWriter::DoRestoreTestIdentify(IVssCreateWriterMetadata *pMetadata)
    {
    HRESULT hr;

    WCHAR buf[1024];
    CreateDirectoryName(buf);
    CreateDirectory(buf, NULL);

    CHECK_SUCCESS(pMetadata->SetRestoreMethod
                                (
                                (m_lRestoreTestOptions & x_RestoreTestOptions_RestoreIfNotThere) ?
                                    VSS_RME_RESTORE_IF_NOT_THERE : VSS_RME_RESTORE_IF_CAN_REPLACE,
                                NULL,
                                NULL,
                                VSS_WRE_ALWAYS,
                                false
                                ));

    DoAddComponent(pMetadata, L"a", buf, NULL, L"*.a", L"ALTA", true, true, 0);
    DoAddComponent(pMetadata, L"b", buf, L"b", L"*", L"ALTB", false, true, 0);
    DoAddComponent(pMetadata, L"c", buf, NULL, L"c.*", L"ALTC", true, true, 0);

    
    return true;
    }

bool CTestVssWriter::DoNewInterfacesTestIdentify(IVssCreateWriterMetadata* pMetadata)
    {
    HRESULT hr;

    WCHAR buf[1024];
    CreateDirectoryName(buf);
    CreateDirectory(buf, NULL);
	
    CHECK_SUCCESS(pMetadata->SetRestoreMethod
                                (
                                VSS_RME_RESTORE_IF_NOT_THERE,
                                NULL,
                                NULL,
                                VSS_WRE_ALWAYS,
                                false
                                ));

    CHECK_SUCCESS(pMetadata->SetBackupSchema
		 (VSS_BS_DIFFERENTIAL | VSS_BS_INCREMENTAL | VSS_BS_LOG |
		 VSS_BS_COPY | VSS_BS_TIMESTAMPED | VSS_BS_TIMESTAMPED |
		 VSS_BS_LAST_MODIFY | VSS_BS_LSN | VSS_BS_WRITER_SUPPORTS_NEW_TARGET
		 ));
				
    DoAddComponent(pMetadata, L"a", buf, NULL, L"*.a", L"ALTA", true, true, 0);
    DoAddComponent(pMetadata, L"b", buf, L"b", L"*", L"ALTB", false, true, 0);
    DoAddComponent(pMetadata, L"c", buf, NULL, L"c.*", L"ALTC", true, true, VSS_CF_BACKUP_RECOVERY);

   CHECK_SUCCESS(pMetadata->AddComponentDependency(NULL, L"a", s_WRITERID, NULL, L"b"));
   CHECK_SUCCESS(pMetadata->AddComponentDependency(NULL, L"c", s_WRITERID, NULL, L"a"));

   CHECK_SUCCESS(pMetadata->AddComponent
   	                        (
   	                        VSS_CT_DATABASE,
   	                        NULL,
   	                        L"db1",
   	                        NULL,
   	                        NULL,
   	                        0,
   	                        true,
   	                        true,
   	                        true,
   	                        true
   	                        ));
      CHECK_SUCCESS(pMetadata->AddComponent
   	                        (
   	                        VSS_CT_FILEGROUP,
   	                        NULL,
   	                        L"db2",
   	                        NULL,
   	                        NULL,
   	                        0,
   	                        true,
   	                        true,
   	                        true,
   	                        true
   	                        ));

   CHECK_SUCCESS(pMetadata->AddDatabaseFiles
   				   (
   				   NULL,
   				   L"db1",
 				   buf,
 				   L"*.db1",
 				   VSS_FSBT_FULL_BACKUP_REQUIRED
 				   ));
   CHECK_SUCCESS(pMetadata->AddDatabaseLogFiles
   				   (
   				   NULL,
   				   L"db1",
 				   buf,
 				   L"*.db2",
 				   VSS_FSBT_DIFFERENTIAL_BACKUP_REQUIRED
 				   ));
   CHECK_SUCCESS(pMetadata->AddFilesToFileGroup
      				   (
      				   NULL,
      				   L"db2",
    				   buf,
    				   L"*.db3",
    				   true,
    				   NULL,
    				   VSS_FSBT_INCREMENTAL_BACKUP_REQUIRED
    				   ));
   CHECK_SUCCESS(pMetadata->AddDatabaseFiles
      				   (
      				   NULL,
      				   L"db1",
    				   buf,
    				   L"*.db4",
    				   VSS_FSBT_LOG_BACKUP_REQUIRED
    				   ));
   CHECK_SUCCESS(pMetadata->AddDatabaseLogFiles
      				   (
      				   NULL,
      				   L"db1",
    				   buf,
    				   L"*.db5",
    				   VSS_FSBT_FULL_SNAPSHOT_REQUIRED
    				   ));
   CHECK_SUCCESS(pMetadata->AddFilesToFileGroup
      				   (
      				   NULL,
      				   L"db2",
    				   buf,
    				   L"*.db6",
    				   true,
    				   NULL,
    				   VSS_FSBT_DIFFERENTIAL_SNAPSHOT_REQUIRED
    				   ));
   CHECK_SUCCESS(pMetadata->AddDatabaseFiles
      				   (
      				   NULL,
      				   L"db1",
    				   buf,
    				   L"*.db7",
    				   VSS_FSBT_INCREMENTAL_SNAPSHOT_REQUIRED
    				   ));
   CHECK_SUCCESS(pMetadata->AddDatabaseLogFiles
      				   (
      				   NULL,
      				   L"db1",
    				   buf,
    				   L"*.db8",
    				   VSS_FSBT_LOG_SNAPSHOT_REQUIRED
    				   ));
   CHECK_SUCCESS(pMetadata->AddFilesToFileGroup
      				   (
      				   NULL,
      				   L"db2",
    				   buf,
    				   L"*.db9",
    				   true,
    				   NULL,
    				   VSS_FSBT_ALL_BACKUP_REQUIRED
    				   ));
   
   CHECK_SUCCESS(pMetadata->AddDatabaseFiles
      				   (
      				   NULL,
      				   L"db1",
    				   buf,
    				   L"*.db10",
    				   VSS_FSBT_ALL_SNAPSHOT_REQUIRED
    				   ));

    return true;   
    }

void CTestVssWriter::DoAddComponent
    (
    IVssCreateWriterMetadata *pMetadata,
    LPCWSTR wszComponentName,
    LPCWSTR wszRootDirectory,
    LPCWSTR wszSubdirectory,
    LPCWSTR wszFilespec,
    LPCWSTR wszAlternateDirectory,
    bool bSelectable,
    bool bSelectableForRestore,
    LONG lFlags
    )
    {
    HRESULT hr;
    CComBSTR bstrAlternate;
    bstrAlternate.Append(wszRootDirectory);
    bstrAlternate.Append(L"\\");
    bstrAlternate.Append(wszAlternateDirectory);

    CHECK_SUCCESS(pMetadata->AddComponent
                                (
                                VSS_CT_FILEGROUP,
                                NULL,
                                wszComponentName,
                                NULL,
                                NULL,
                                0,
                                true,
                                true,
                                bSelectable,
                                bSelectableForRestore,
                                lFlags
                                ));

    if (wszSubdirectory == NULL)
        {
        CHECK_SUCCESS(pMetadata->AddFilesToFileGroup
                                    (
                                    NULL,
                                    wszComponentName,
                                    wszRootDirectory,
                                    wszFilespec,
                                    false,
                                    NULL
                                    ));

        CHECK_SUCCESS(pMetadata->AddAlternateLocationMapping
                                        (
                                        wszRootDirectory,
                                        wszFilespec,
                                        false,
                                        bstrAlternate
                                        ));
        }
    else
        {
        CComBSTR bstr;
        bstr.Append(wszRootDirectory);
        bstr.Append(L"\\");
        bstr.Append(wszSubdirectory);
        CHECK_SUCCESS(pMetadata->AddFilesToFileGroup
                                    (
                                    NULL,
                                    wszComponentName,
                                    bstr,
                                    wszFilespec,
                                    true,
                                    NULL
                                    ));

        CHECK_SUCCESS(pMetadata->AddAlternateLocationMapping
                                    (
                                    bstr,
                                    wszFilespec,
                                    true,
                                    bstrAlternate
                                    ));
        }
    }



bool CTestVssWriter::DoRestoreTestPrepareBackup(IVssWriterComponents *pWriterComponents)
    {
    WCHAR buf[1024];
    HRESULT hr;
    unsigned cComponents;

    CreateDirectoryName(buf);
    CHECK_SUCCESS(pWriterComponents->GetComponentCount(&cComponents));
    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
        {
        CComPtr<IVssComponent> pComponent;
        VSS_COMPONENT_TYPE ct;
        CComBSTR bstrLogicalPath;
        CComBSTR bstrComponentName;

        CHECK_SUCCESS(pWriterComponents->GetComponent(iComponent, &pComponent));
        CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
        CHECK_SUCCESS(pComponent->GetComponentType(&ct));
        CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
        if (ct == VSS_CT_FILEGROUP && !bstrLogicalPath && wcslen(bstrComponentName) == 1)
            {
            if (bstrComponentName[0] == L'a')
                CreateComponentFilesA(buf, false);
            else if (bstrComponentName[0] == L'b')
                CreateComponentFilesB(buf, false);
            else if (bstrComponentName[0] == L'c')
                CreateComponentFilesC(buf, false);
            }
        }

    return true;
    }




void CTestVssWriter::CreateComponentFilesA(LPCWSTR buf, bool bKeepOpen)
    {
    DoCreateFile(buf, L"foo.a", 100, bKeepOpen);
    DoCreateFile(buf, L"bar.a", 1000, bKeepOpen);
    DoCreateFile(buf, L"xxx.a", 10000, bKeepOpen);
    }

void CTestVssWriter::VerifyComponentFilesA(LPCWSTR buf)
    {
    CComBSTR bstr;
    bstr.Append(buf);
    bstr.Append(L"\\ALTA");
    DoVerifyFile(bstr, L"foo.a", 100);
    DoVerifyFile(bstr, L"bar.a", 1000);
    DoVerifyFile(bstr, L"xxx.a", 10000);
    wprintf(L"Component a is verified.\n");
    }


void CTestVssWriter::CreateComponentFilesB(LPCWSTR buf, bool bKeepOpen)
    {
    CComBSTR bstr;
    bstr.Append(buf);
    bstr.Append(L"\\b");

    CreateDirectory(bstr, NULL);

    DoCreateFile(bstr, L"a.a", 1000, bKeepOpen);
    DoCreateFile(bstr, L"b.b", 1000, bKeepOpen);

    bstr.Append(L"\\a");
    CreateDirectory(bstr, NULL);
    DoCreateFile(bstr, L"a.a", 10000, bKeepOpen);
    DoCreateFile(bstr, L"b.b", 10000, bKeepOpen);

    bstr.Append(L"\\b");
    CreateDirectory(bstr, NULL);
    DoCreateFile(bstr, L"a.a", 100000, bKeepOpen);
    DoCreateFile(bstr, L"b.b", 100000, bKeepOpen);

    bstr[wcslen(bstr) - 1] = L'c';
    CreateDirectory(bstr, NULL);
    DoCreateFile(bstr, L"a.a", 10, bKeepOpen);
    DoCreateFile(bstr, L"b.b", 10, bKeepOpen);
    }

void CTestVssWriter::VerifyComponentFilesB(LPCWSTR buf)
    {
    CComBSTR bstr;
    bstr.Append(buf);
    bstr.Append(L"\\ALTB");

    DoVerifyFile(bstr, L"a.a", 1000);
    DoVerifyFile(bstr, L"b.b", 1000);

    bstr.Append(L"\\a");
    DoVerifyFile(bstr, L"a.a", 10000);
    DoVerifyFile(bstr, L"b.b", 10000);

    bstr.Append(L"\\b");
    CreateDirectory(bstr, NULL);
    DoVerifyFile(bstr, L"a.a", 100000);
    DoVerifyFile(bstr, L"b.b", 100000);

    bstr[wcslen(bstr) - 1] = L'c';
    DoVerifyFile(bstr, L"a.a", 10);
    DoVerifyFile(bstr, L"b.b", 10);
    wprintf(L"Component b is verified.\n");
    }


void CTestVssWriter::CreateComponentFilesC(LPCWSTR buf, bool bKeepOpen)
    {
    DoCreateFile(buf, L"c.x1", 100, bKeepOpen);
    DoCreateFile(buf, L"c.x2", 1000, bKeepOpen);
    DoCreateFile(buf, L"c.x3", 10000, bKeepOpen);
    }

void CTestVssWriter::VerifyComponentFilesC(LPCWSTR buf)
    {
    CComBSTR bstr;
    bstr.Append(buf);
    bstr.Append(L"\\ALTC");

    DoVerifyFile(bstr, L"c.x1", 100);
    DoVerifyFile(bstr, L"c.x2", 1000);
    DoVerifyFile(bstr, L"c.x3", 10000);
    wprintf(L"Component c is verified.\n");
    }

void CTestVssWriter::DoCreateFile
    (
    LPCWSTR wszPath,
    LPCWSTR wszFilename,
    DWORD length,
    bool bKeepOpen
    )
    {
    CComBSTR bstr;
    bstr.Append(wszPath);
    bstr.Append(L"\\");
    bstr.Append(wszFilename);
    if (bKeepOpen && m_chOpen == m_chOpenMax)
        {
        HANDLE *rghNew = new HANDLE[m_chOpen + 4];
        memcpy(rghNew, m_rghOpen, m_chOpen * sizeof(HANDLE));
        delete m_rghOpen;
        m_rghOpen = rghNew;
        m_chOpenMax = m_chOpen + 4;
        }

    BYTE *buf = new BYTE[length];
    if (buf == NULL)
        Error(E_OUTOFMEMORY, L"Out of memory.\n");

    UINT seed = length + wszFilename[0];
    for(UINT i = 0; i < length; i++, seed++)
        buf[i] = (BYTE) (seed & 0xff);


    HANDLE hFile = CreateFile
                        (
                        bstr,
                        GENERIC_READ|GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        0,
                        NULL
                        );

    if (hFile == INVALID_HANDLE_VALUE)
        {
        DWORD dwErr = GetLastError();
        delete buf;
        Error(HRESULT_FROM_WIN32(dwErr), L"CreateFile failed due to error %d.\n", dwErr);
        }

    DWORD dwWritten;
    if (!WriteFile(hFile, buf, length, &dwWritten, NULL) ||
        dwWritten != length)
        {
        DWORD dwErr = GetLastError();
        delete buf;
        CloseHandle(hFile);
        Error(HRESULT_FROM_WIN32(dwErr), L"Write file failed due to error %d.\n", dwErr);
        }

    delete buf;
    if (bKeepOpen)
        m_rghOpen[m_chOpen++] = hFile;
    else
        CloseHandle(hFile);
    }

void CTestVssWriter::DoVerifyFile
    (
    LPCWSTR wszPath,
    LPCWSTR wszFilename,
    DWORD length
    )
    {
    CComBSTR bstr;
    bstr.Append(wszPath);
    bstr.Append(L"\\");
    bstr.Append(wszFilename);

    HANDLE hFile = CreateFile
                        (
                        bstr,
                        GENERIC_READ|GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

    if (hFile == INVALID_HANDLE_VALUE)
        {
        DWORD dwErr = GetLastError();
        if (dwErr == ERROR_FILE_NOT_FOUND ||
            dwErr == ERROR_PATH_NOT_FOUND)
            Error(E_UNEXPECTED, L"%s was not restored.\n", bstr);
        }

    DWORD dwSize = GetFileSize(hFile, NULL);
    if (dwSize == 0xffffffff)
        {
        DWORD dwErr = GetLastError();
        CloseHandle(hFile);
        Error(HRESULT_FROM_WIN32(dwErr), L"GetFileSize failed due to error %d.\n", dwErr);
        }

    if (dwSize != length)
        {
        CloseHandle(hFile);
        Error(E_UNEXPECTED, L"Failed to restore file %s correctly.\n", bstr);
        }


    BYTE *buf = new BYTE[length];
    if (buf == NULL)
        {
        CloseHandle(hFile);
        Error(E_OUTOFMEMORY, L"Out of memory.\n");
        }

    DWORD dwRead;
    if (!ReadFile(hFile, buf, length, &dwRead, NULL))
        {
        DWORD dwErr = GetLastError();
        delete buf;
        CloseHandle(hFile);
        Error(HRESULT_FROM_WIN32(dwErr), L"Write file failed due to error %d.\n", dwErr);
        }

    CloseHandle(hFile);

    UINT seed = length + wszFilename[0];
    for(UINT i = 0; i < length; i++, seed++)
        {
        if (buf[i] != (BYTE) (seed & 0xff))
            {
            delete buf;
            Error(E_UNEXPECTED, L"Failed to restore file %s correctly.\n", bstr);
            }
        }

    delete buf;
    }


bool CTestVssWriter::DoRestoreTestPreRestore(IVssWriterComponents *pWriterComponents)
    {
    WCHAR buf[1024];
    HRESULT hr;
    unsigned cComponents;
    bool bKeepOpen = (m_lRestoreTestOptions & x_RestoreTestOptions_RestoreIfNotThere) ? false : true;

    CreateDirectoryName(buf);
    CHECK_SUCCESS(pWriterComponents->GetComponentCount(&cComponents));
    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
        {
        CComPtr<IVssComponent> pComponent;
        VSS_COMPONENT_TYPE ct;
        CComBSTR bstrLogicalPath;
        CComBSTR bstrComponentName;
        bool bRestore;

        CHECK_SUCCESS(pWriterComponents->GetComponent(iComponent, &pComponent));
        CHECK_SUCCESS(pComponent->IsSelectedForRestore(&bRestore));
        if (!bRestore)
            continue;

        CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
        CHECK_SUCCESS(pComponent->GetComponentType(&ct));
        CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
        if (ct == VSS_CT_FILEGROUP && !bstrLogicalPath && wcslen(bstrComponentName) == 1)
            {
            if (bstrComponentName[0] == L'a')
                CreateComponentFilesA(buf, bKeepOpen);
            else if (bstrComponentName[0] == L'b')
                CreateComponentFilesB(buf, bKeepOpen);
            else if (bstrComponentName[0] == L'c')
                CreateComponentFilesC(buf, bKeepOpen);
            }

        if (m_bTestNewInterfaces)
        	PrintNewTargets(pComponent);
        }

    return true;
    }


bool CTestVssWriter::DoRestoreTestPostRestore(IVssWriterComponents *pWriterComponents)
    {
    WCHAR buf[1024];
    HRESULT hr;
    unsigned cComponents;

    CreateDirectoryName(buf);
    CHECK_SUCCESS(pWriterComponents->GetComponentCount(&cComponents));
    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
        {
        CComPtr<IVssComponent> pComponent;
        VSS_COMPONENT_TYPE ct;
        CComBSTR bstrLogicalPath;
        CComBSTR bstrComponentName;
        bool bRestore;

        CHECK_SUCCESS(pWriterComponents->GetComponent(iComponent, &pComponent));
        CHECK_SUCCESS(pComponent->IsSelectedForRestore(&bRestore));

        if (!bRestore)
            continue;

        CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
        CHECK_SUCCESS(pComponent->GetComponentType(&ct));
        CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
        if (ct == VSS_CT_FILEGROUP && !bstrLogicalPath && wcslen(bstrComponentName) == 1)
            {
            if (bstrComponentName[0] == L'a')
                VerifyComponentFilesA(buf);
            else if (bstrComponentName[0] == L'b')
                VerifyComponentFilesB(buf);
            else if (bstrComponentName[0] == L'c')
                VerifyComponentFilesC(buf);
            }
        }

    for(UINT ih = 0; ih < m_chOpen; ih++)
        CloseHandle(m_rghOpen[ih]);

    delete m_rghOpen;
    m_chOpen = 0;
    m_chOpenMax = 0;
    m_rghOpen = NULL;
    return true;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\betest\debug.cpp ===
#include "stdafx.hxx"
#include "vss.h"
#include "vswriter.h"
#include "vsbackup.h"
#include <debug.h>
#include <cwriter.h>
#include <lmshare.h>
#include <lmaccess.h>


LPCWSTR GetStringFromFailureType(HRESULT hrStatus)
{
    LPCWSTR pwszFailureType = L"";

    switch (hrStatus)
	{
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:        pwszFailureType = L"VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT";    break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:              pwszFailureType = L"VSS_E_WRITERERROR_OUTOFRESOURCES";          break;
	case VSS_E_WRITERERROR_TIMEOUT:                     pwszFailureType = L"VSS_E_WRITERERROR_TIMEOUT";                 break;
	case VSS_E_WRITERERROR_NONRETRYABLE:                pwszFailureType = L"VSS_E_WRITERERROR_NONRETRYABLE";            break;
	case VSS_E_WRITERERROR_RETRYABLE:                   pwszFailureType = L"VSS_E_WRITERERROR_RETRYABLE";               break;
	case VSS_E_BAD_STATE:                               pwszFailureType = L"VSS_E_BAD_STATE";                           break;
	case VSS_E_PROVIDER_ALREADY_REGISTERED:             pwszFailureType = L"VSS_E_PROVIDER_ALREADY_REGISTERED";         break;
	case VSS_E_PROVIDER_NOT_REGISTERED:                 pwszFailureType = L"VSS_E_PROVIDER_NOT_REGISTERED";             break;
	case VSS_E_PROVIDER_VETO:                           pwszFailureType = L"VSS_E_PROVIDER_VETO";                       break;
	case VSS_E_PROVIDER_IN_USE:				            pwszFailureType = L"VSS_E_PROVIDER_IN_USE";                     break;
	case VSS_E_OBJECT_NOT_FOUND:						pwszFailureType = L"VSS_E_OBJECT_NOT_FOUND";                    break;						
	case VSS_S_ASYNC_PENDING:							pwszFailureType = L"VSS_S_ASYNC_PENDING";                       break;
	case VSS_S_ASYNC_FINISHED:						    pwszFailureType = L"VSS_S_ASYNC_FINISHED";                      break;
	case VSS_S_ASYNC_CANCELLED:						    pwszFailureType = L"VSS_S_ASYNC_CANCELLED";                     break;
	case VSS_E_VOLUME_NOT_SUPPORTED:					pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED";                break;
	case VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER:		pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER";    break;
	case VSS_E_OBJECT_ALREADY_EXISTS:					pwszFailureType = L"VSS_E_OBJECT_ALREADY_EXISTS";               break;
	case VSS_E_UNEXPECTED_PROVIDER_ERROR:				pwszFailureType = L"VSS_E_UNEXPECTED_PROVIDER_ERROR";           break;
	case VSS_E_CORRUPT_XML_DOCUMENT:				    pwszFailureType = L"VSS_E_CORRUPT_XML_DOCUMENT";                break;
	case VSS_E_INVALID_XML_DOCUMENT:					pwszFailureType = L"VSS_E_INVALID_XML_DOCUMENT";                break;
	case VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED:       pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED";   break;
	case VSS_E_FLUSH_WRITES_TIMEOUT:                    pwszFailureType = L"VSS_E_FLUSH_WRITES_TIMEOUT";                break;
	case VSS_E_HOLD_WRITES_TIMEOUT:                     pwszFailureType = L"VSS_E_HOLD_WRITES_TIMEOUT";                 break;
	case VSS_E_UNEXPECTED_WRITER_ERROR:                 pwszFailureType = L"VSS_E_UNEXPECTED_WRITER_ERROR";             break;
	case VSS_E_SNAPSHOT_SET_IN_PROGRESS:                pwszFailureType = L"VSS_E_SNAPSHOT_SET_IN_PROGRESS";            break;
	case VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED:     pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED"; break;
	case VSS_E_WRITER_INFRASTRUCTURE:	 		        pwszFailureType = L"VSS_E_WRITER_INFRASTRUCTURE";               break;
	case VSS_E_WRITER_NOT_RESPONDING:			        pwszFailureType = L"VSS_E_WRITER_NOT_RESPONDING";               break;
    case VSS_E_WRITER_ALREADY_SUBSCRIBED:		        pwszFailureType = L"VSS_E_WRITER_ALREADY_SUBSCRIBED";           break;
	
	case NOERROR:
	default:
	    break;
	}

    return (pwszFailureType);
}


// This function displays the formatted message at the console and throws
// The passed return code will be returned by vsreq.exe
void Error(
    IN  INT nReturnCode,
    IN  const WCHAR* pwszMsgFormat,
    IN  ...
    )
{
    va_list marker;
    va_start( marker, pwszMsgFormat );
    vwprintf( pwszMsgFormat, marker );
    va_end( marker );

	BS_ASSERT(FALSE);
    // throw that return code.
    throw(nReturnCode);
}

// convert VSS_RESTORE_TARGET to string
LPCWSTR WszFromRestoreTarget
	(
	IN VSS_RESTORE_TARGET rt
	)
	{
	switch(rt)
		{
        default:
			return L"Undefined";

        case VSS_RT_ORIGINAL:
			return L"Original";

		case VSS_RT_ALTERNATE:
            return L"Alternate";

        case VSS_RT_DIRECTED:
			return L"Directed";
        }
	}

// convert VSS_FILE_RESTORE_STATUS to string
LPCWSTR WszFromFileRestoreStatus
	(
	IN VSS_FILE_RESTORE_STATUS rs
	)
	{
	switch(rs)
		{
		default:
			return L"Undefined";

        case VSS_RS_NONE:
			return L"None";

		case VSS_RS_ALL:
            return L"All";

		case VSS_RS_FAILED:
            return L"Failed";
        }
	}

void PrintPartialFiles(IVssComponent *pComponent)
	{
	UINT cPartialFiles;
	HRESULT hr;

	CHECK_SUCCESS(pComponent->GetPartialFileCount(&cPartialFiles));
	if (cPartialFiles > 0)
		wprintf(L"\n%d Partial Files:\n\n", cPartialFiles);

	for(UINT iFile = 0; iFile < cPartialFiles; iFile++)
		{
		CComBSTR bstrPath;
		CComBSTR bstrFilename;
		CComBSTR bstrRanges;
		CComBSTR bstrMetadata;

		CHECK_SUCCESS(pComponent->GetPartialFile
							(
							iFile,
							&bstrPath,
							&bstrFilename,
							&bstrRanges,
							&bstrMetadata
							));

        wprintf(L"Path=%s, Name=%s\nRanges=%s\nMetadata=%s\n\n",
				bstrPath, bstrFilename, bstrRanges, bstrMetadata);

        }
	}

void PrintDifferencedFiles(IVssComponent* pComponent)
	{
	UINT cDifferencedFiles;
	HRESULT hr;

	CHECK_SUCCESS(pComponent->GetDifferencedFilesCount(&cDifferencedFiles));
	if (cDifferencedFiles > 0)
		wprintf(L"\n%d Differenced Files:\n\n", cDifferencedFiles);

	for(UINT iDiff = 0; iDiff < cDifferencedFiles; iDiff++)
		{
		CComBSTR bstrPath;
		CComBSTR bstrFilename;
		BOOL bRecursive;
		CComBSTR bstrLSN;
		FILETIME ftLastModify;

		CHECK_SUCCESS(pComponent->GetDifferencedFile
							(
							iDiff,
							&bstrPath,
							&bstrFilename,
							&bRecursive,
							&bstrLSN,
							&ftLastModify
							));

        wprintf(L"Path=%s, Name=%s\nRecursive=%s,LSN=%s\nLastModifyHigh=%x\nLastModifyLow=%x\n\n",
				bstrPath, 
				bstrFilename, 
				(bRecursive) ? L"yes" : L"no",
				bstrLSN, 
				ftLastModify.dwHighDateTime,
				ftLastModify.dwLowDateTime);

        }
	
	}

void PrintNewTargets(IVssComponent *pComponent)
    {
    	UINT cTarget;
	HRESULT hr;

	CHECK_SUCCESS(pComponent->GetNewTargetCount(&cTarget));
	if (cTarget > 0)
		wprintf(L"\n%d New Targets:\n\n", cTarget);

	for(UINT iTarget = 0; iTarget < cTarget; iTarget++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;

		CHECK_SUCCESS(pComponent->GetNewTarget
			(
			iTarget,
			&pFiledesc
			));

		CComBSTR bstrSourcePath;
		CComBSTR bstrFilespec;
		CComBSTR bstrAlt;
		bool bRecursive = false;


		CHECK_SUCCESS(pFiledesc->GetPath(&bstrSourcePath));
		CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
		CHECK_SUCCESS(pFiledesc->GetRecursive(&bRecursive));
		CHECK_SUCCESS(pFiledesc->GetAlternateLocation(&bstrAlt));

		wprintf(L"path = %s\nfilespec = %s\nrecursive = %s\nalternateLocation=%s\n",
			     bstrSourcePath,
			     bstrFilespec,
			     (bRecursive) ?  L"yes" : L"no",
			     bstrAlt
			     );		
        }
}

void PrintDirectedTargets(IVssComponent *pComponent)
	{
	UINT cTarget;
	HRESULT hr;

	CHECK_SUCCESS(pComponent->GetDirectedTargetCount(&cTarget));
	if (cTarget > 0)
		wprintf(L"\n%d Directed Targets:\n\n", cTarget);

	for(UINT iTarget = 0; iTarget < cTarget; iTarget++)
		{
		CComBSTR bstrSourcePath;
		CComBSTR bstrSourceFilespec;
		CComBSTR bstrSourceRanges;
		CComBSTR bstrTargetPath;
		CComBSTR bstrTargetFilespec;
		CComBSTR bstrTargetRanges;


		CHECK_SUCCESS(pComponent->GetDirectedTarget
			(
			iTarget,
			&bstrSourcePath,
			&bstrSourceFilespec,
			&bstrSourceRanges,
			&bstrTargetPath,
			&bstrTargetFilespec,
			&bstrTargetRanges
			));

		wprintf(L"Source Path=%s, Name=%s\nRanges=%s\nTarget Path=%s, Name=%s\nRanges=%s\n",
				bstrSourcePath,
				bstrSourceFilespec,
				bstrSourceRanges,
				bstrTargetPath,
				bstrTargetFilespec,
				bstrTargetRanges);
        }
	}


void PrintRestoreSubcomponents(IVssComponent *pComponent)
	{
	UINT cSub;
	HRESULT hr;

	CHECK_SUCCESS(pComponent->GetRestoreSubcomponentCount(&cSub));
	if (cSub > 0)
		wprintf(L"\n%d Restore Subcomponents:\n\n", cSub);

	for(UINT iSub = 0; iSub < cSub; iSub++)
		{
		CComBSTR bstrLogicalPath;
		CComBSTR bstrComponentName;
		bool bRepair;


		CHECK_SUCCESS(pComponent->GetRestoreSubcomponent
			(
			iSub,
			&bstrLogicalPath,
			&bstrComponentName,
			&bRepair
			));

		wprintf(L"Logical Path=%s, Name=%s, Repair=%s\n",
				bstrLogicalPath,
				bstrComponentName,
				bRepair ? L"Yes" : L"No");
        }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\betest\debug.h ===
// Execute the given call and check that the return code must be S_OK
#define CHECK_SUCCESS( Call )                                                                           \
    {                                                                                                   \
        hr = Call;                                                                                    \
        if (hr != S_OK)                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }

#define CHECK_NOFAIL( Call )                                                                            \
    {                                                                                                   \
        hr = Call;                                                                                    \
        if (FAILED(hr))                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }



void Error(INT nReturnCode, const WCHAR* pwszMsgFormat, ...);
LPCWSTR GetStringFromFailureType(HRESULT hrStatus);
LPCWSTR WszFromRestoreTarget(VSS_RESTORE_TARGET rt);
LPCWSTR WszFromFileRestoreStatus(VSS_FILE_RESTORE_STATUS rs);
void PrintPartialFiles(IVssComponent *pComponent);
void PrintDifferencedFiles(IVssComponent* pComponent);
void PrintNewTargets(IVssComponent *pComponent);
void PrintDirectedTargets(IVssComponent *pComponent);
void PrintRestoreSubcomponents(IVssComponent *pComponent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\betest\main.cpp ===
#include "stdafx.hxx"
#include "vs_idl.hxx"
#include "vss.h"
#include "vswriter.h"
#include "vsbackup.h"
#include "vs_seh.hxx"
#include "vs_trace.hxx"
#include "vscoordint.h"
//#include "vs_debug.hxx"
#include "compont.h"
#include <debug.h>
#include <cwriter.h>
#include <lmshare.h>
#include <lmaccess.h>
#include <time.h>


// Globals
BOOL g_bDebug = TRUE;
BOOL g_bComponentBackup = TRUE;
BOOL g_bBackupOnly = FALSE;
BOOL g_bRestoreOnly = FALSE;
BOOL g_bExcludeTestWriter = FALSE;

WCHAR g_wszBackupDocumentFileName[MAX_PATH];
WCHAR g_wszComponentsFileName[MAX_PATH];
WCHAR g_wszSavedFilesDirectory[MAX_PATH];
LONG g_lWriterWait = 0;
bool g_bRestoreTest = false;
bool g_lRestoreTestOptions = 0;
VSS_BACKUP_TYPE g_BackupType = VSS_BT_DIFFERENTIAL;
bool g_bBootableSystemState = false;
bool g_bTestNewInterfaces = false;

CComPtr<CWritersSelection>  g_pWriterSelection;

void TestSnapshotXML();
void EnumVolumes();

// forward declarations
void CheckStatus(IVssBackupComponents *pvbc, LPCWSTR wszWhen, 
            CSimpleMap<VSS_ID, HRESULT>* failedWriters = NULL);
HRESULT ParseCommnadLine (int argc, WCHAR **argv);
BOOL SaveBackupDocument(CComBSTR &bstr);
BOOL LoadBackupDocument(CComBSTR &bstr);
void LoadMetadataFile
    (
    VSS_ID idInstance,
    IVssExamineWriterMetadata **ppMetadataSaved
    );

void DoCopyFile(LPCWSTR, LPCWSTR);
void RestoreFiles(IVssBackupComponents *pvbc, const CSimpleMap<VSS_ID, HRESULT>& failedWriters);
void SetSubcomponentsSelectedForRestore
    (
    IVssBackupComponents *pvbc,
    VSS_ID idInstance,
    IVssComponent *pComponent
    );


void SaveFiles(IVssBackupComponents *pvbc, VSS_ID *rgSnapshotId, UINT cSnapshots);

bool FindComponent
    (
    IVssExamineWriterMetadata *pMetadata,
    LPCWSTR wszLogicalPath,
    LPCWSTR wszComponentName,
    IVssWMComponent **ppComponent
    );


BOOL AssertPrivilege( LPCWSTR privName )
    {
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if ( OpenProcessToken (GetCurrentProcess(),
               TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,
               &tokenHandle))
    {
    LUID value;

    if ( LookupPrivilegeValue( NULL, privName, &value ) )
        {
        TOKEN_PRIVILEGES newState;
        DWORD            error;

        newState.PrivilegeCount           = 1;
        newState.Privileges[0].Luid       = value;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED;

        /*
         * We will always call GetLastError below, so clear
         * any prior error values on this thread.
         */
        SetLastError( ERROR_SUCCESS );

        stat = AdjustTokenPrivileges (tokenHandle,
                      FALSE,
                      &newState,
                      (DWORD)0,
                      NULL,
                      NULL );

        /*
         * Supposedly, AdjustTokenPriveleges always returns TRUE
         * (even when it fails). So, call GetLastError to be
         * extra sure everything's cool.
         */
        if ( (error = GetLastError()) != ERROR_SUCCESS )
        {
        stat = FALSE;
        }

        if ( !stat )
        {
        wprintf( L"AdjustTokenPrivileges for %s failed with %d",
             privName,
             error );
        }
        }

    DWORD cbTokens;
    GetTokenInformation (tokenHandle,
                 TokenPrivileges,
                 NULL,
                 0,
                 &cbTokens);

    TOKEN_PRIVILEGES *pTokens = (TOKEN_PRIVILEGES *) new BYTE[cbTokens];
    GetTokenInformation (tokenHandle,
                 TokenPrivileges,
                 pTokens,
                 cbTokens,
                 &cbTokens);

    delete pTokens;
    CloseHandle( tokenHandle );
    }


    return stat;
    }


LPCWSTR GetStringFromUsageType (VSS_USAGE_TYPE eUsageType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eUsageType)
    {
    case VSS_UT_BOOTABLESYSTEMSTATE: pwszRetString = L"BootableSystemState"; break;
    case VSS_UT_SYSTEMSERVICE:       pwszRetString = L"SystemService";       break;
    case VSS_UT_USERDATA:            pwszRetString = L"UserData";            break;
    case VSS_UT_OTHER:               pwszRetString = L"Other";               break;

    default:
        break;
    }


    return (pwszRetString);
    }


LPCWSTR GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eSourceType)
    {
    case VSS_ST_TRANSACTEDDB:    pwszRetString = L"TransactionDb";    break;
    case VSS_ST_NONTRANSACTEDDB: pwszRetString = L"NonTransactionDb"; break;
    case VSS_ST_OTHER:           pwszRetString = L"Other";            break;

    default:
        break;
    }


    return (pwszRetString);
    }


LPCWSTR GetStringFromRestoreMethod (VSS_RESTOREMETHOD_ENUM eRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eRestoreMethod)
    {
    case VSS_RME_RESTORE_IF_NOT_THERE:          pwszRetString = L"RestoreIfNotThere";          break;
    case VSS_RME_RESTORE_IF_CAN_REPLACE:        pwszRetString = L"RestoreIfCanReplace";        break;
    case VSS_RME_STOP_RESTORE_START:            pwszRetString = L"StopRestoreStart";           break;
    case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION: pwszRetString = L"RestoreToAlternateLocation"; break;
    case VSS_RME_RESTORE_AT_REBOOT:             pwszRetString = L"RestoreAtReboot";            break;
    case VSS_RME_RESTORE_AT_REBOOT_IF_CANNOT_REPLACE: pwszRetString = L"RestoreAtRebootIfCannotReplace"; break;
    case VSS_RME_CUSTOM:                        pwszRetString = L"Custom";                     break;

    default:
        break;
    }


    return (pwszRetString);
    }


LPCWSTR GetStringFromWriterRestoreMethod (VSS_WRITERRESTORE_ENUM eWriterRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eWriterRestoreMethod)
    {
    case VSS_WRE_NEVER:            pwszRetString = L"RestoreNever";           break;
    case VSS_WRE_IF_REPLACE_FAILS: pwszRetString = L"RestoreIfReplaceFails";  break;
    case VSS_WRE_ALWAYS:           pwszRetString = L"RestoreAlways";          break;

    default:
        break;
    }


    return (pwszRetString);
    }


LPCWSTR GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eComponentType)
    {
    case VSS_CT_DATABASE:  pwszRetString = L"Database";  break;
    case VSS_CT_FILEGROUP: pwszRetString = L"FileGroup"; break;

    default:
        break;
    }


    return (pwszRetString);
    }




void PrintFiledesc(IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription)
    {
    CComBSTR bstrPath;
    CComBSTR bstrFilespec;
    CComBSTR bstrAlternate;
    CComBSTR bstrDestination;
    bool bRecursive;
    DWORD dwTypeMask;
    HRESULT hr;

    CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
    CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
    CHECK_NOFAIL(pFiledesc->GetRecursive(&bRecursive));
    CHECK_NOFAIL(pFiledesc->GetAlternateLocation(&bstrAlternate));
    CHECK_NOFAIL(pFiledesc->GetBackupTypeMask(&dwTypeMask));
	
    wprintf (L"%s\n            Path = %s, Filespec = %s, Recursive = %s, BackupTypeMask = 0x%x\n",
         wszDescription,
         bstrPath,
         bstrFilespec,
         bRecursive ? L"yes" : L"no",
         dwTypeMask);

    if (bstrAlternate && wcslen(bstrAlternate) > 0)
    wprintf(L"            Alternate Location = %s\n", bstrAlternate);
    }



// wait a maximum number of seconds before cancelling the operation
void LoopWait
    (
    IVssAsync *pAsync,
    LONG seconds,
    LPCWSTR wszOperation
    )
    {
    // if debugging, allow one hour before cancelling operation
    if (g_bDebug)
        seconds = 3600;

    if (g_bTestNewInterfaces)
    	{
        HRESULT hr = pAsync->Wait(seconds * 1000);
	 if (hr != E_NOTIMPL)
	 	Error(hr, L"Expected IVssAsyncWait to return E_NOTIMPL for non-infinite argument");	 
    	}
    clock_t start = clock();
    HRESULT hr, hrStatus;
    while(TRUE)
        {
        Sleep(1000);
        CHECK_SUCCESS(pAsync->QueryStatus(&hrStatus, NULL));
        if (hrStatus != VSS_S_ASYNC_PENDING)
            break;

        if (((clock() - start)/CLOCKS_PER_SEC) >= seconds)
            break;
        }

    if (hrStatus == VSS_S_ASYNC_PENDING)
        {
        CHECK_NOFAIL(pAsync->Cancel());
        wprintf(L"Called cancelled for %s.\n", wszOperation);
        }

    CHECK_SUCCESS(pAsync->QueryStatus(&hrStatus, NULL));
    CHECK_NOFAIL(hrStatus);
    }


void  UpdatePartialFileRanges(IVssComponent* pComponent, IVssBackupComponents* pvbc,
	                                   VSS_ID id, VSS_COMPONENT_TYPE ct, BSTR bstrLogicalPath, BSTR bstrName)
    {
    UINT cPartialFiles;
    HRESULT hr;

    CHECK_SUCCESS(pComponent->GetPartialFileCount(&cPartialFiles));

    for(UINT iFile = 0; iFile < cPartialFiles; iFile++)
        {
        CComBSTR bstrPath;
        CComBSTR bstrFilename;
        CComBSTR bstrRanges;
        CComBSTR bstrMetadata;

        CHECK_SUCCESS(pComponent->GetPartialFile
					(
					iFile,
					&bstrPath,
					&bstrFilename,
					&bstrRanges,
					&bstrMetadata
					));

        // always call this function to see what it does if there is no ranges file
        CHECK_SUCCESS(pvbc->SetRangesFilePath(id, ct, bstrLogicalPath, bstrName, iFile,bstrRanges ));
        }
    }

void AddNewTargets(IVssBackupComponents* pvbc, VSS_ID id, VSS_COMPONENT_TYPE ct, BSTR bstrLogicalPath, BSTR bstrName)
    {
    // add a nonsensical new target.  this is usually illegal, but this is a test program...
    pvbc->AddNewTarget(id, ct, bstrLogicalPath, bstrName, L"C:\\", L"foo.txt", false, L"D:\\");
    }

void DoPrepareBackup(IVssBackupComponents *pvbc)
    {
    CComPtr<IVssAsync> pAsync;
    INT nPercentDone;
    HRESULT hrResult;
    HRESULT hr;


    CHECK_SUCCESS(pvbc->PrepareForBackup(&pAsync));
    LoopWait(pAsync, 5, L"PrepareForBackup");
    CHECK_SUCCESS(pAsync->QueryStatus(&hrResult, &nPercentDone));
    CHECK_NOFAIL(hrResult);
    }


void DoSnapshotSet(IVssBackupComponents *pvbc, HRESULT &hrResult)
    {
    CComPtr<IVssAsync> pAsync;
    INT nPercentDone;
    HRESULT hr;

    CHECK_SUCCESS(pvbc->DoSnapshotSet (&pAsync));

    CHECK_SUCCESS(pAsync->Wait());
    CHECK_SUCCESS(pAsync->QueryStatus(&hrResult, &nPercentDone));
    }




void DoBackupComplete(IVssBackupComponents *pvbc)
    {
    CComPtr<IVssAsync> pAsync;
    HRESULT hr;

    CHECK_SUCCESS(pvbc->BackupComplete(&pAsync));
    LoopWait(pAsync, 5, L"BackupComplete");
    }


void DoRestore(IVssBackupComponents *pvbc)
    {
    CComPtr<IVssAsync> pAsync;
    HRESULT hr;

    if (g_bTestNewInterfaces)
        pvbc->SetRestoreState(VSS_RTYPE_OTHER);
    
    pvbc->GatherWriterMetadata(&pAsync);
    LoopWait(pAsync, 60, L"GetherWriterMetadata");
    pAsync = NULL;
    UINT cWriters, iWriter;

    CVssSimpleMap<VSS_ID, DWORD> schemas;
    CHECK_SUCCESS(pvbc->GetWriterMetadataCount(&cWriters));
    for(iWriter = 0; iWriter < cWriters; iWriter++)
        {
        CComPtr<IVssExamineWriterMetadata> pMetadata;
        VSS_ID idInstance, idWriter;
        CComBSTR bstrName;
        VSS_USAGE_TYPE usage;
        VSS_SOURCE_TYPE source;
        
        CHECK_SUCCESS(pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata));

        CHECK_SUCCESS(pMetadata->GetIdentity(&idInstance, &idWriter, &bstrName, &usage, &source));
        
        DWORD schema = 0; 
        CHECK_SUCCESS(pMetadata->GetBackupSchema(&schema));
        schemas.Add(idWriter, schema);    
        }

    UINT cWriterComponents;
    CHECK_SUCCESS(pvbc->GetWriterComponentsCount(&cWriterComponents));
    for(UINT iWriterComponent = 0; iWriterComponent < cWriterComponents; iWriterComponent++)
        {
        CComPtr<IVssWriterComponentsExt> pWriter;

        CHECK_SUCCESS(pvbc->GetWriterComponents(iWriterComponent, &pWriter));
        VSS_ID idInstance;
        VSS_ID idWriter;
        UINT cComponents;
        CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
        CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));

        CComPtr<IVssExamineWriterMetadata> pStoredMetadata;
        if (g_wszSavedFilesDirectory[0] != L'\0')
            LoadMetadataFile(idInstance, &pStoredMetadata);

        
        for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
            {
            CComPtr<IVssComponent> pComponent;

            CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));

            CComBSTR bstrLogicalPath;
            CComBSTR bstrComponentName;
            CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
            CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));

            // For RestoreOnly case, we check if the user provided a component selection
            BOOL bSelected = TRUE;
            if (g_bRestoreOnly && g_pWriterSelection)
                {
                // User provided a valid selection file
                bSelected = g_pWriterSelection->IsComponentSelected(idWriter, bstrLogicalPath, bstrComponentName);
                if (bSelected)
                    {
                    wprintf (L"\n        Component \"%s\" is selected for Restore\n", bstrComponentName);
                    }
                else
                    {
                    wprintf (L"\n        Component \"%s\" is NOT selected for Restore\n", bstrComponentName);
                    }
                }

            // get the matching component from the writer metadata document
            CComPtr<IVssWMComponent> pWriterComponent;
            PVSSCOMPONENTINFO pInfo = NULL;
            bool bSelectable = true, bSelectableForRestore = false;
            if (g_wszSavedFilesDirectory[0] != L'\0')
                {
                BS_VERIFY(FindComponent(pStoredMetadata, bstrLogicalPath, bstrComponentName, &pWriterComponent));
                CHECK_SUCCESS(pWriterComponent->GetComponentInfo(&pInfo));

//                BS_ASSERT(!bSelected || (pInfo->bSelectable || pInfo->bSelectableForRestore));

                bSelectable = pInfo->bSelectable;
                bSelectableForRestore = pInfo->bSelectableForRestore;
                }


            // get the component type
            VSS_COMPONENT_TYPE ct;
            CHECK_SUCCESS(pComponent->GetComponentType(&ct));
            
            if (bSelected)
                {
                hr = pvbc->SetSelectedForRestore
                                        (
                                        idWriter,
                                        ct,
                                        bstrLogicalPath,
                                        bstrComponentName,
                                        true
                                        );
                if (hr == VSS_E_OBJECT_NOT_FOUND)
                    {
                    wprintf(L"component %s\\%s was selected for restore, but the writer no longer "
                               L"exists on the system\n", bstrLogicalPath, bstrComponentName);

                // BUGBUG: huge hack to fix the AD case.   We eventually need to 
                // BUGBUG: do something better here, but this is easiest for now.
                CHECK_SUCCESS(pvbc->SetRestoreOptions(idWriter,
                                                                                    ct,
                                                                                    bstrLogicalPath,
                                                                                    bstrComponentName,
                                                                                    L"RESTORE"
                                                                                    ));
                }
                else
                    {
                    CHECK_SUCCESS(hr);
                    }
                    
//                SetSubcomponentsSelectedForRestore(pvbc, idInstance, pComponent);                
                }


        if (g_wszSavedFilesDirectory[0] != L'\0')
            {
            pWriterComponent->FreeComponentInfo(pInfo);
            pInfo = NULL;
            }
        }

    UINT nSubcomponents = 0;
    const WCHAR* const * ppwszSubcomponents = NULL;
    if (g_bRestoreOnly && g_pWriterSelection)
        {
            nSubcomponents = g_pWriterSelection->GetSubcomponentsCount(idWriter);
            ppwszSubcomponents = g_pWriterSelection->GetSubcomponents(idWriter);
        };
    
    for (UINT iSubcomponent = 0; g_wszSavedFilesDirectory[0] != L'\0' && 
                            iSubcomponent < nSubcomponents; iSubcomponent++)
        {
                // pull apart the logical path and component name
                CComBSTR bstrLogicalPath, bstrComponentName;        
                WCHAR* lastSlash = wcsrchr(ppwszSubcomponents[iSubcomponent], L'\\');
                if (lastSlash != NULL)
                    {
                    *lastSlash = L'\0';
                    bstrLogicalPath = ppwszSubcomponents[iSubcomponent];
                    bstrComponentName = lastSlash + 1;
                    *lastSlash = L'\\';
                    }
                else
                    {
                    bstrComponentName = ppwszSubcomponents[iSubcomponent];
                    }
                
                // look for the closest parent component that has been backed up
               CComBSTR bstrLogicalPathParent;
               CComBSTR bstrComponentNameParent;
               CComPtr<IVssComponent> pCurrentParent;
               unsigned int maxLength = 0;
                for(UINT iParentComponent = 0; iParentComponent  < cComponents; iParentComponent++)
                    {
                    CComPtr<IVssComponent> pParentComponent ;

                    CComBSTR bstrCurrentLPath;
                    CComBSTR bstrCurrentCName;
                    
                    CHECK_SUCCESS(pWriter->GetComponent(iParentComponent, &pParentComponent));

                    CHECK_NOFAIL(pParentComponent->GetLogicalPath(&bstrCurrentLPath));
                    CHECK_SUCCESS(pParentComponent->GetComponentName(&bstrCurrentCName));

                    CComBSTR bstrFullPath = bstrCurrentLPath;
                    if (bstrFullPath)
                        bstrFullPath += L"\\";
                    bstrFullPath += bstrCurrentCName;
                    if (!bstrFullPath)
                        Error(E_OUTOFMEMORY, L"Ran out of memory");

                    // check to see if we've found a parent component that's larger
                    unsigned int currentLength = bstrFullPath.Length();
                    if (bstrLogicalPath && wcsstr(bstrLogicalPath, bstrFullPath) == bstrLogicalPath &&
                        currentLength > maxLength)
                        {
                        bstrLogicalPathParent = bstrCurrentLPath;
                        bstrComponentNameParent = bstrCurrentCName;
                        maxLength = currentLength;
                        pCurrentParent = pParentComponent;
                        }
                    }

                // if maxLength is zero, we're trying to restore a subcomponent for a component
                // that wasn't backed up.
                BS_ASSERT(maxLength > 0);

                wprintf (L"\n        SubComponent \"%s\" is selected for Restore\n", ppwszSubcomponents[iSubcomponent]);
                
                VSS_COMPONENT_TYPE ct;
                CHECK_SUCCESS(pCurrentParent->GetComponentType(&ct));
                
                // the parent component must be selected for restore
                hr = pvbc->SetSelectedForRestore
                                    (
                                     idWriter,
                                     ct,
                                     bstrLogicalPathParent,
                                     bstrComponentNameParent,
                                     true
                                     );
                if (hr != VSS_E_OBJECT_NOT_FOUND)
                    CHECK_SUCCESS(hr);

                
                // BUGBUG: Should check bSelectableForRestore first
                CHECK_SUCCESS(pvbc->AddRestoreSubcomponent
                                        (
                                        idWriter,
                                        ct,
                                        bstrLogicalPathParent,
                                        bstrComponentNameParent,
                                        bstrLogicalPath,
                                        bstrComponentName,
                                        false
                                        ));            
        }
    }

    CHECK_SUCCESS(pvbc->PreRestore(&pAsync));
    LoopWait(pAsync, 600, L"PreRestore");
    pAsync = NULL;

    
    CSimpleMap<VSS_ID, HRESULT> failedWriters;
//    CheckStatus(pvbc, L"After PreRestore");
    CheckStatus(pvbc, L"After PreRestore", &failedWriters);

    for(UINT iWriterComponent = 0; iWriterComponent < cWriterComponents; iWriterComponent++)
        {
        CComPtr<IVssWriterComponentsExt> pWriter;
        VSS_ID idWriter;
        VSS_ID idInstance;

        CHECK_SUCCESS(pvbc->GetWriterComponents(iWriterComponent, &pWriter));
        UINT cComponents;
        CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
        CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));

        for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
            {
            CComPtr<IVssComponent> pComponent;
            CComBSTR bstrLogicalPath;
            CComBSTR bstrComponentName;
            CComBSTR bstrFailureMsg;

            CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
            VSS_COMPONENT_TYPE ct;
            CHECK_SUCCESS(pComponent->GetComponentType(&ct));
            CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
            CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
            CHECK_NOFAIL(pComponent->GetPreRestoreFailureMsg(&bstrFailureMsg));

            VSS_RESTORE_TARGET rt;
            CHECK_SUCCESS(pComponent->GetRestoreTarget(&rt));

            if (bstrFailureMsg || rt != VSS_RT_ORIGINAL)
                {
                wprintf(L"\nComponent Path=%s Name=%s\n",
                        bstrLogicalPath ? bstrLogicalPath : L"",
                        bstrComponentName);

                if (bstrFailureMsg)
                    wprintf(L"\nPreRestoreFailureMsg=%s\n", bstrFailureMsg);

                wprintf(L"restore target = %s\n", WszFromRestoreTarget(rt));
                if (rt == VSS_RT_DIRECTED)
                    PrintDirectedTargets(pComponent);

                wprintf(L"\n");
                }

            // we start off by saying that no files were restored.  we will reset this attribute later
            CHECK_SUCCESS(pvbc->SetFileRestoreStatus(idWriter, ct, bstrLogicalPath, bstrComponentName, VSS_RS_NONE));
            
	     if (g_bTestNewInterfaces)
	     	{
	     	UpdatePartialFileRanges(pComponent, pvbc, idWriter, ct, bstrLogicalPath, bstrComponentName);
	     	PrintPartialFiles(pComponent);
	     	PrintDifferencedFiles(pComponent);

	     	if (schemas.Lookup(idWriter)  & VSS_BS_WRITER_SUPPORTS_NEW_TARGET)
	     		AddNewTargets(pvbc, idWriter, ct, bstrLogicalPath, bstrComponentName);
	     	}
            }

        wprintf(L"\n");
        }

    if (g_wszSavedFilesDirectory[0] != L'\0')
        RestoreFiles(pvbc, failedWriters);

    CHECK_SUCCESS(pvbc->PostRestore(&pAsync));
    LoopWait(pAsync, 600, L"PostRestore");
    pAsync = NULL;

    CheckStatus(pvbc, L"After PostRestore");

    for(UINT iWriterComponent = 0; iWriterComponent < cWriterComponents; iWriterComponent++)
        {
        CComPtr<IVssWriterComponentsExt> pWriter;

        CHECK_SUCCESS(pvbc->GetWriterComponents(iWriterComponent, &pWriter));
        UINT cComponents;
        CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));

        for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
            {
            CComPtr<IVssComponent> pComponent;
            CComBSTR bstrLogicalPath;
            CComBSTR bstrComponentName;
            CComBSTR bstrFailureMsg;

            CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
            VSS_COMPONENT_TYPE ct;
            CHECK_SUCCESS(pComponent->GetComponentType(&ct));
            CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
            CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
            CHECK_NOFAIL(pComponent->GetPostRestoreFailureMsg(&bstrFailureMsg));
            if (bstrFailureMsg)
                {
                wprintf(L"\nComponent Path=%s Name=%s\n",
                        bstrLogicalPath ? bstrLogicalPath : L"",
                        bstrComponentName);

                if (bstrFailureMsg)
                    wprintf(L"\nPostRestoreFailureMsg=%s\n", bstrFailureMsg);

                wprintf(L"\n");
                }
            }
        }

    wprintf(L"\n");
    }


void DoAddToSnapshotSet
    (
    IN IVssBackupComponents *pvbc,
    IN BSTR bstrPath,
    IN LPWSTR wszVolumes,
    VSS_ID *rgpSnapshotId,
    UINT *pcSnapshot
    )
    {
    PWCHAR  pwszPath           = NULL;
    PWCHAR  pwszMountPointName = NULL;
    WCHAR   wszVolumeName [50];
    ULONG   ulPathLength;
    ULONG   ulMountpointBufferLength;
    HRESULT hr;


    ulPathLength = ExpandEnvironmentStringsW (bstrPath, NULL, 0);

    pwszPath = (PWCHAR) malloc (ulPathLength * sizeof (WCHAR));

    ulPathLength = ExpandEnvironmentStringsW (bstrPath, pwszPath, ulPathLength);


    ulMountpointBufferLength = GetFullPathName (pwszPath, 0, NULL, NULL);

    pwszMountPointName = (PWCHAR) malloc (ulMountpointBufferLength * sizeof (WCHAR));

    bool fSuccess = false;
    if (wcslen(pwszPath) >= 3 && pwszPath[1] == L':' && pwszPath[2] == L'\\')
        {
        wcsncpy(pwszMountPointName, pwszPath, 3);
        pwszMountPointName[3] = L'\0';
        fSuccess = true;
        }
    else
        {
        if (GetVolumePathNameW (pwszPath, pwszMountPointName, ulMountpointBufferLength))
            fSuccess = true;
        else
            {
            BS_ASSERT(FALSE);
            printf("GetVolumeMountPointW failed with error %d\nfor path %s.\n", GetLastError(), pwszPath);
            }
        }

    if (fSuccess)
        {
        if (!GetVolumeNameForVolumeMountPointW (pwszMountPointName, wszVolumeName, sizeof (wszVolumeName) / sizeof (WCHAR)))
                printf("GetVolumeNameForVolumeMountPointW failed with error %d\nfor path %s.\n", GetLastError(), wszVolumeName);
        else
            {
//            wprintf(L"EXTRADBG: Volume <%s> <%s> is required for snapshot\n", wszVolumeName, pwszMountPointName);
            if (NULL == wcsstr (wszVolumes, wszVolumeName))
                {
                if (L'\0' != wszVolumes [0])
                    wcscat (wszVolumes, L";");

                wcscat (wszVolumes, wszVolumeName);

                CHECK_SUCCESS
                    (
                    pvbc->AddToSnapshotSet
                        (
                        wszVolumeName,
                        GUID_NULL,
                        &rgpSnapshotId[*pcSnapshot]
                        )
                    );
                wprintf(L"Volume <%s> <%s>\n", wszVolumeName, pwszMountPointName);
                wprintf(L"is added to the snapshot set\n\n");

                *pcSnapshot += 1;
                }
            }
        }

    if (NULL != pwszPath)           free (pwszPath);
    if (NULL != pwszMountPointName) free (pwszMountPointName);
    }

static LPCWSTR s_rgwszStates[] =
    {
    NULL,
    L"STABLE",
    L"WAIT_FOR_FREEZE",
    L"WAIT_FOR_THAW",
    L"WAIT_FOR_POST_SNAPSHOT",
    L"WAIT_FOR_BACKUP_COMPLETE",
    L"FAILED_AT_IDENTIFY",
    L"FAILED_AT_PREPARE_BACKUP",
    L"FAILED_AT_PREPARE_SNAPSHOT",
    L"FAILED_AT_FREEZE",
    L"FAILED_AT_THAW",
    L"FAILED_AT_POST_SNAPSHOT",
    L"FAILED_AT_BACKUP_COMPLETE",
    L"FAILED_AT_PRE_RESTORE",
    L"FAILED_AT_POST_RESTORE"
    };


void CheckStatus(IVssBackupComponents *pvbc, LPCWSTR wszWhen, 
            CSimpleMap<VSS_ID, HRESULT>* failedWriters)
    {
    unsigned cWriters;
    CComPtr<IVssAsync> pAsync;
    HRESULT hr;

    CHECK_NOFAIL(pvbc->GatherWriterStatus(&pAsync));
    CHECK_NOFAIL(pAsync->Wait());
    CHECK_NOFAIL(pvbc->GetWriterStatusCount(&cWriters));


    wprintf(L"\n\nstatus %s (%d writers)\n\n", wszWhen, cWriters);

    for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
    {
    VSS_ID idInstance;
    VSS_ID idWriter;
    VSS_WRITER_STATE status;
    CComBSTR bstrWriter;
    HRESULT hrWriterFailure;

    CHECK_SUCCESS(pvbc->GetWriterStatus (iWriter,
                         &idInstance,
                         &idWriter,
                         &bstrWriter,
                         &status,
                         &hrWriterFailure));

    wprintf (L"Status for writer %s: %s(0x%08lx%s%s)\n",
         bstrWriter,
         s_rgwszStates[status],
         hrWriterFailure,
         SUCCEEDED (hrWriterFailure) ? L"" : L" - ",
         GetStringFromFailureType (hrWriterFailure));

    if (failedWriters && FAILED(hrWriterFailure))
        failedWriters->Add(idInstance, hrWriterFailure);
    }

    
    pvbc->FreeWriterStatus();
    }

void PrintDifferencedFilesForComponents(IVssBackupComponents* pvbc)
    {
    HRESULT hr;
    UINT cWriterComponents;

    CHECK_SUCCESS(pvbc->GetWriterComponentsCount(&cWriterComponents));
    for(UINT iWriterComponent = 0; iWriterComponent < cWriterComponents; iWriterComponent++)
        {
        CComPtr<IVssWriterComponentsExt> pWriter;

        CHECK_SUCCESS(pvbc->GetWriterComponents(iWriterComponent, &pWriter));
        UINT cComponents;
        CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));

        for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
            {
            CComPtr<IVssComponent> pComponent;

            CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));

            CComBSTR bstrLogicalPath;
            CComBSTR bstrComponentName;

            CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
            CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
            UINT cDifferencedFiles;

            CHECK_SUCCESS(pComponent->GetDifferencedFilesCount(&cDifferencedFiles));
            if (cDifferencedFiles > 0)
                {
                wprintf(L"\nDifferenced  files for Component Path=%s Name=%s\n",
                        bstrLogicalPath ? bstrLogicalPath : L"",
                        bstrComponentName);

                PrintDifferencedFiles(pComponent);
                }
        	}
    	}
    }

void PrintPartialFilesForComponents(IVssBackupComponents *pvbc)
    {
    HRESULT hr;
    UINT cWriterComponents;

    CHECK_SUCCESS(pvbc->GetWriterComponentsCount(&cWriterComponents));
    for(UINT iWriterComponent = 0; iWriterComponent < cWriterComponents; iWriterComponent++)
        {
        CComPtr<IVssWriterComponentsExt> pWriter;

        CHECK_SUCCESS(pvbc->GetWriterComponents(iWriterComponent, &pWriter));
        UINT cComponents;
        CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));

        for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
            {
            CComPtr<IVssComponent> pComponent;

            CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));

            CComBSTR bstrLogicalPath;
            CComBSTR bstrComponentName;

            CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
            CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
            UINT cPartialFiles;

            CHECK_SUCCESS(pComponent->GetPartialFileCount(&cPartialFiles));
            if (cPartialFiles > 0)
                {
                wprintf(L"\nPartial files for Component Path=%s Name=%s\n",
                        bstrLogicalPath ? bstrLogicalPath : L"",
                        bstrComponentName);

                PrintPartialFiles(pComponent);
                }
            }
        }
    }

BOOL SaveBackupDocument(CComBSTR &bstr)
    {
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    DWORD dwByteToWrite = (bstr.Length() + 1) * sizeof(WCHAR);
    DWORD dwBytesWritten;

    // Create the file (override if exists)
    hFile = CreateFile(g_wszBackupDocumentFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        {
        return FALSE;
        }

    // Write the XML string
    if (! WriteFile(hFile, (LPVOID)(BSTR)bstr, dwByteToWrite, &dwBytesWritten, NULL))
        {
        CloseHandle(hFile);
        return FALSE;
        }

    CloseHandle(hFile);
    return TRUE;
    }

BOOL LoadBackupDocument(CComBSTR &bstr)
    {
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    DWORD dwBytesToRead = 0;
    DWORD dwBytesRead;

    // Create the file (must exist)
    hFile = CreateFile(g_wszBackupDocumentFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        {
        return FALSE;
        }

    if ((dwBytesToRead = GetFileSize(hFile, NULL)) <= 0)
        {
        CloseHandle(hFile);
        return FALSE;
        }

    WCHAR *pwszBuffer = NULL;
    DWORD dwNofChars = 0;

    if ((dwBytesToRead % sizeof(WCHAR)) != 0)
        {
        CloseHandle(hFile);
        wprintf(L"Invalid file lenght %lu for backup document file\n", dwBytesToRead);
        return FALSE;
        }
    else
        {
        dwNofChars = dwBytesToRead / sizeof(WCHAR);
        }

    pwszBuffer = (PWCHAR) malloc (dwNofChars * sizeof (WCHAR));
    if (! pwszBuffer)
        {
        CloseHandle(hFile);
        wprintf(L"Failed to allocate memory for backup document buffer\n");
        return FALSE;
        }

    // Read the XML string
    if (! ReadFile(hFile, (LPVOID)pwszBuffer, dwBytesToRead, &dwBytesRead, NULL))
        {
        CloseHandle(hFile);
        free (pwszBuffer);
        return FALSE;
        }

    CloseHandle(hFile);

    if (dwBytesToRead != dwBytesRead)
        {
        free (pwszBuffer);
        wprintf(L"Backup document file is supposed to have %lu bytes but only %lu bytes are read\n", dwBytesToRead, dwBytesRead);
        return FALSE;
        }

    // Copy to output bstr
    bstr.Empty();
    if (bstr.Append(pwszBuffer, dwNofChars) != S_OK)     // don't copy the NULL
        {
        free (pwszBuffer);
        wprintf(L"Failed to copy from temporary buffer into Backup Document XML string\n");
        return FALSE;
        }

    return TRUE;
    }

HRESULT ParseCommandLine (int argc, WCHAR **argv)
    {
    HRESULT hr = S_OK;
    int iArg;

    g_wszBackupDocumentFileName[0] = L'\0';
    g_wszComponentsFileName[0] = L'\0';
    g_wszSavedFilesDirectory[0] = L'\0';

    try
        {
        for (iArg=1; iArg<argc; iArg++)
            {
            if ((_wcsicmp(argv[iArg], L"/W") == 0) || (_wcsicmp(argv[iArg], L"-W") == 0))
                {
                iArg++;

                if (iArg >= argc)
                    {
                    wprintf(L"/W switch missing wait-time argument\n");
                    throw(E_INVALIDARG);
                    }
                if (argv[iArg][0] >= L'0' && argv[iArg][0] <= L'9'||
                    argv[iArg][0] >= L'a' && argv[iArg][0] <= L'f')
                    {
                    if (argv[iArg][0] >= L'0' && argv[iArg][0] <= L'9')
                         g_lWriterWait = argv[iArg][0] - L'0';
                     else
                         g_lWriterWait = argv[iArg][0] - L'a' + 10;

                     wprintf(L"Writer wait parameter=%ld.\n", g_lWriterWait);
                    }
                else
                    {
                    wprintf(L"/W switch is followed by invalid wait-time argument\n");
                    throw(E_INVALIDARG);
                    }
                }
            else if ((_wcsicmp(argv[iArg], L"/B") == 0) || (_wcsicmp(argv[iArg], L"-B") == 0))
                {
                g_bBackupOnly = TRUE;
                wprintf(L"Asked to do Backup only\n");
                }
            else if ((_wcsicmp(argv[iArg], L"/R") == 0) || (_wcsicmp(argv[iArg], L"-R") == 0))
                {
                g_bRestoreOnly = TRUE;
                wprintf(L"Asked to do Restore only\n");
                }

            else if ((_wcsicmp(argv[iArg], L"/E") == 0) || (_wcsicmp(argv[iArg], L"-E") == 0))
                {
                g_bExcludeTestWriter = TRUE;
                wprintf(L"Asked to exclude BETEST test writer\n");
                }

            else if ((_wcsicmp(argv[iArg], L"/O") == 0) || (_wcsicmp(argv[iArg], L"-O") == 0))
                {
                g_bBootableSystemState = true;
                wprintf(L"Asked to specify BootableSystemState backup\n");
                }

            else if ((_wcsicmp(argv[iArg], L"/T") == 0) || (_wcsicmp(argv[iArg], L"-T") == 0))
                {
                iArg++;

                if (iArg >= argc)
                    {
                    wprintf(L"/T switch missing backup-type parameter\n");
                    throw(E_INVALIDARG);
                    }

                int nBackupType = _wtoi(argv[iArg]);
                if ((nBackupType <= (int)VSS_BT_UNDEFINED) || (nBackupType > (int)VSS_BT_OTHER))
                    {
                    wprintf(L"backup-type parameter is invalid\n");
                    throw(E_INVALIDARG);
                    }
                g_BackupType = (VSS_BACKUP_TYPE)nBackupType;
                wprintf(L"backup-type to use is %d\n", nBackupType);
                }

            else if ((_wcsicmp(argv[iArg], L"/S") == 0) || (_wcsicmp(argv[iArg], L"-S") == 0))
                {
                iArg++;

                if (iArg >= argc)
                    {
                    wprintf(L"/S switch missing file-name to save/load backup document\n");
                    throw(E_INVALIDARG);
                    }
                if (wcslen(argv[iArg]) >= MAX_PATH - 1)
                    {
                    wprintf(L"Path for file-name to save/load backup document is limited to %d\n", MAX_PATH - 2);
                    throw(E_INVALIDARG);
                    }
                wcscpy(g_wszBackupDocumentFileName, argv[iArg]);
                wprintf(L"File name to save/load Backup Document is \"%s\"\n", g_wszBackupDocumentFileName);
                }

            else if ((_wcsicmp(argv[iArg], L"/D") == 0) || (_wcsicmp(argv[iArg], L"-D") == 0))
                {
                iArg++;

                if (iArg >= argc)
                    {
                    wprintf(L"/D switch missing directory path to save/load backup document\n");
                    throw(E_INVALIDARG);
                    }
                if (wcslen(argv[iArg]) >= MAX_PATH - 2)
                    {
                    wprintf(L"Path to save/restore backup files is limited to %d\n", MAX_PATH - 2);
                    throw(E_INVALIDARG);
                    }
                wcscpy(g_wszSavedFilesDirectory, argv[iArg]);
                if (g_wszSavedFilesDirectory[wcslen(g_wszSavedFilesDirectory)-1] != L'\\')
                    wcscat(g_wszSavedFilesDirectory, L"\\");

                wprintf(L"Directory to save/restore backup files is \"%s\"\n", g_wszSavedFilesDirectory);
                DoCopyFile(NULL, g_wszSavedFilesDirectory);

                // replace test writer so that it tests restore options
                g_bRestoreTest = true;
                }


            else if ((_wcsicmp(argv[iArg], L"/C") == 0) || (_wcsicmp(argv[iArg], L"-C") == 0))
                {
                iArg++;

                if (iArg >= argc)
                    {
                    wprintf(L"/C switch missing file-name to load components selection from\n");
                    throw(E_INVALIDARG);
                    }
                if (wcslen(argv[iArg]) >= MAX_PATH)
                    {
                    wprintf(L"Path for file-name to load components selection is limited to %d\n", MAX_PATH);
                    throw(E_INVALIDARG);
                    }
                wcscpy(g_wszComponentsFileName, argv[iArg]);
                wprintf(L"File name for Components Selection is \"%s\"\n", g_wszComponentsFileName);
                }
	     else if ((_wcsicmp(argv[iArg], L"/N") == 0) || (_wcsicmp(argv[iArg], L"-N") == 0))
	     	{
	     	g_bTestNewInterfaces = true;
		wprintf(L"Asked to test new interfaces\n");
	     	}
            else if ((_wcsicmp(argv[iArg], L"/?") == 0) || (_wcsicmp(argv[iArg], L"-?") == 0))
                {
                // Print help
                wprintf(L"BETEST [/B] [/R] [/E] [/T backup-type] [/S filename] [/C filename] [/D path]\n\n");
                wprintf(L"/B\t\t Performs backup only\n");
                wprintf(L"/R\t\t Performs restore only\n");
                wprintf(L"\t\t Restore-only must be used with /S for a backup document file\n\n");
                wprintf(L"/E\t\t Excludes BETEST test writer\n");
                wprintf(L"/O\t\t Specifies BootableSystemState backup\n");
                wprintf(L"/T\t\t Chooses backup type\n");
                wprintf(L"\t\t <backup-type> parameter should be one of VSS_BACKUP_TYPE\n");
                wprintf(L"\t\t enum values (Look in vss.h for VSS_BACKUP_TYPE type)\n");
                wprintf(L"\t\t Default is VSS_BT_DIFFERENTIAL\n\n");
                wprintf(L"/S filename\t In case of backup, saves the backup document to file\n");
                wprintf(L"\t\t In case of restore-only, loads the backup document from file\n\n");
                wprintf(L"/D path\t In case of backup, saves the files to be backed up to this location.\n");
                wprintf(L"\t\t In case of restore, restores the backed up files from this location.\n\n");
		  wprintf(L"/N Test new backup infrastructure interfaces.\n\n");
                wprintf(L"/C filename\t Selects which components to backup/restore based on the file\n\n");
                wprintf(L"Components selection file format:\n");
                wprintf(L"\"<writer-id>\": \"<component-logical-path>\", ...\"<component-logical-path>\" : '\"<subcomponent-logical-path>,...\";\n\n");
                wprintf(L"\t\twhere several writers may be specified, each one with its own components and subcomponents\n");
                wprintf(L"\t\t<writer-id> is in standard GUID format\n");
                wprintf(L"\t\t<component-logical-path> is either logical-path, logical-path\\component-name\n");
                wprintf(L"\t\tor component-name-only (if there's no logical path)\n\n");
                wprintf(L"For example:\n");
                wprintf(L"\t\t\"{c0577ae6-d741-452a-8cba-99d744008c04}\": \"\\mydatabases\", \"\\mylogfiles\";\n");
                wprintf(L"\t\t\"{f2436e37-09f5-41af-9b2a-4ca2435dbfd5}\" : \"Registry\"  ;\n\n");
                wprintf(L"If no argument is specified, BETEST performs a backup followed by a restore\n");
                wprintf(L"choosing all components reported by all writers\n\n");

                // Set hr such that program terminates
                hr = S_FALSE;
                }
            else
                {
                wprintf(L"Invalid switch\n");
                throw(E_INVALIDARG);
                }
            }

        // Check for invalid combinations
        if (g_bBackupOnly && g_bRestoreOnly)
            {
                wprintf(L"Cannot backup-only and restore-only at the same time...\n");
                throw(E_INVALIDARG);
            }
        if (g_bRestoreOnly && (wcslen(g_wszBackupDocumentFileName) == 0))
            {
                wprintf(L"Cannot restore-only with no backup-document to use.\nUse the /S switch for specifying a file name with backup document from a previous BETEST backup");
                throw(E_INVALIDARG);
            }

        }
    catch (HRESULT hrParse)
        {
        hr = hrParse;
        }

    return hr;
    }

bool IsWriterPath(LPCWSTR wszPath)
    {
    if (wszPath[0] == L'{')
        {
        LPCWSTR wszNext = wcschr(wszPath + 1, L'}');
        if (wszNext == NULL)
            return false;

        if (wszNext - wszPath != 37)
            return false;

        WCHAR buf[39];
        memcpy(buf, wszPath, 38*sizeof(WCHAR));
        buf[38] = L'\0';
        VSS_ID id;

        if (FAILED(CLSIDFromString(buf, &id)))
            return false;

        return wcslen(wszNext) >= 3 &&
               wszNext[1] == L':' &&
               wszNext[2] == L'\\';

        }

    return false;
    }


typedef VSS_ID *PVSS_ID;

bool DoAddComponent
    (
    IVssBackupComponents *pvbc,
    IVssExamineWriterMetadata *pMetadata,
    VSS_ID idInstance,
    VSS_ID idWriter,
    LPCWSTR wszLogicalPath,
    LPCWSTR wszComponentName,
    LPWSTR wszVolumes,
    PVSS_ID &rgpSnapshotId,
    UINT &cSnapshot
    );


// add a child component to the backup components document
bool AddChildComponent
    (
    IVssBackupComponents *pvbc,
    VSS_ID id,
    CComBSTR bstrLogicalPath,
    CComBSTR bstrComponentName,
    LPWSTR wszVolumes,
    PVSS_ID &rgpSnapshotId,
    UINT &cSnapshot
    )
    {
    HRESULT hr;

    UINT cWriters, iWriter;
    CHECK_SUCCESS(pvbc->GetWriterMetadataCount(&cWriters));
    CComPtr<IVssExamineWriterMetadata> pMetadata;
    VSS_ID idInstance = GUID_NULL;

    for(iWriter = 0; iWriter < cWriters; iWriter++)
        {
        CHECK_SUCCESS(pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata));

        VSS_ID idInstanceT;
        VSS_ID idWriter;
        CComBSTR bstrWriterName;
        VSS_USAGE_TYPE usage;
        VSS_SOURCE_TYPE source;

        CHECK_SUCCESS(pMetadata->GetIdentity
                            (
                            &idInstanceT,
                            &idWriter,
                            &bstrWriterName,
                            &usage,
                            &source
                            ));
        if (idWriter == id)
            break;

        pMetadata = NULL;
        }

    if (iWriter > cWriters)
        {
        wprintf(L"Cannot backup component: %s\\%s\nWriter doesn't exist.\n\n", bstrLogicalPath, bstrComponentName);
        return false;
        }


    wprintf(L"Backing up subcomponent: %s\\%s.\n\n", bstrLogicalPath, bstrComponentName);
    return DoAddComponent
                (
                pvbc,
                pMetadata,
                idInstance,
                id,
                bstrLogicalPath,
                bstrComponentName,
                wszVolumes,
                rgpSnapshotId,
                cSnapshot
                );
    }


bool FindComponent
    (
    IVssExamineWriterMetadata *pMetadata,
    LPCWSTR wszLogicalPath,
    LPCWSTR wszComponentName,
    IVssWMComponent **ppComponent
    )
    {
    HRESULT hr;

    UINT cIncludeFiles, cExcludeFiles, cComponents;
    CHECK_SUCCESS(pMetadata->GetFileCounts(
                            &cIncludeFiles,
                            &cExcludeFiles,
                            &cComponents));

    for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
        {
        CComPtr<IVssWMComponent> pComponent;
        CHECK_SUCCESS(pMetadata->GetComponent(iComponent, &pComponent));
        PVSSCOMPONENTINFO pInfo;
        CHECK_SUCCESS(pComponent->GetComponentInfo(&pInfo));
        if (_wcsicmp(wszComponentName, pInfo->bstrComponentName) == 0 &&
            ((wszLogicalPath == NULL &&
              (pInfo->bstrLogicalPath == NULL ||
               wcslen(pInfo->bstrLogicalPath) == 0)) ||
             (wszLogicalPath != NULL &&
              pInfo->bstrLogicalPath != NULL &&
              _wcsicmp(wszLogicalPath, pInfo->bstrLogicalPath) == 0)))
            {
            pComponent->FreeComponentInfo(pInfo);
            break;
            }

        pComponent->FreeComponentInfo(pInfo);
        }

    if (iComponent < cComponents)
        {
        CHECK_SUCCESS(pMetadata->GetComponent(iComponent, ppComponent));
        return true;
        }

    return false;
    }


bool UpdateSnapshotSet
    (
    IVssBackupComponents *pvbc, 
    IVssWMComponent* pComponent, 
    PVSSCOMPONENTINFO pInfo, 
    LPWSTR wszVolumes, 
    PVSS_ID &rgpSnapshotId, 
    UINT &cSnapshot
    )
    {
    HRESULT hr = S_OK;
    
    bool bOneSelected = false;
    for(UINT i = 0; i < pInfo->cFileCount; i++)
       {
       CComPtr<IVssWMFiledesc> pFiledesc;
       CHECK_SUCCESS(pComponent->GetFile(i, &pFiledesc));
       CComBSTR bstrPath;
       CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
       DoAddToSnapshotSet(pvbc, bstrPath, wszVolumes, rgpSnapshotId, &cSnapshot);
       bOneSelected = true;
       PrintFiledesc(pFiledesc, L"        FileGroupFile");
       }

    for(UINT i = 0; i < pInfo->cDatabases; i++)
        {
        CComPtr<IVssWMFiledesc> pFiledesc;
        CHECK_SUCCESS(pComponent->GetDatabaseFile(i, &pFiledesc));

        CComBSTR bstrPath;
        CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
        DoAddToSnapshotSet(pvbc, bstrPath, wszVolumes, rgpSnapshotId, &cSnapshot);
        bOneSelected = true;
        PrintFiledesc(pFiledesc, L"        DatabaseFile");
        }

    for(UINT i = 0; i < pInfo->cLogFiles; i++)
        {
        CComPtr<IVssWMFiledesc> pFiledesc;
        CHECK_SUCCESS(pComponent->GetDatabaseLogFile(i, &pFiledesc));

        CComBSTR bstrPath;
        CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
        DoAddToSnapshotSet(pvbc, bstrPath, wszVolumes, rgpSnapshotId, &cSnapshot);
        bOneSelected = true;
        PrintFiledesc(pFiledesc, L"        DatabaseLogFile");
    }  

    return bOneSelected;
    }

bool DoAddComponent
    (
    IVssBackupComponents *pvbc,
    IVssExamineWriterMetadata *pMetadata,
    VSS_ID idInstance,
    VSS_ID idWriter,
    LPCWSTR wszLogicalPath,
    LPCWSTR wszComponentName,
    LPWSTR wszVolumes,
    PVSS_ID &rgpSnapshotId,
    UINT &cSnapshot
    )
    {
    HRESULT hr;

    // was at least one file selected
    bool bAtLeastOneSelected = false;

    CComPtr<IVssWMComponent> pComponent;
    if (!FindComponent
            (
            pMetadata,
            wszLogicalPath,
            wszComponentName,
            &pComponent
            ))
        {
        wprintf(L"Component is not found: " WSTR_GUID_FMT L":\\%s\\%s",
                GUID_PRINTF_ARG(idWriter),
                wszLogicalPath ? wszLogicalPath : L"",
                wszComponentName);

        return false;
        }

    PVSSCOMPONENTINFO pInfo;
    CHECK_SUCCESS(pComponent->GetComponentInfo(&pInfo));
    hr = pvbc->AddComponent
            (
            idInstance,
            idWriter,
            pInfo->type,
            pInfo->bstrLogicalPath,
            pInfo->bstrComponentName
            );

    if (hr == VSS_E_OBJECT_ALREADY_EXISTS)
        return false;

    CHECK_SUCCESS(hr);

    if (pInfo->type == VSS_CT_DATABASE &&
        pInfo->bstrLogicalPath &&
        wcscmp(pInfo->bstrLogicalPath, L"\\mydatabases") == 0 &&
        wcscmp(pInfo->bstrComponentName, L"db1") == 0)
        {
        CHECK_SUCCESS(pvbc->SetPreviousBackupStamp
                            (
                            idWriter,
                            pInfo->type,
                            pInfo->bstrLogicalPath,
                            pInfo->bstrComponentName,
                            L"LASTFULLBACKUP"
                            ));

        CHECK_SUCCESS(pvbc->SetBackupOptions
                            (
                            idWriter,
                            pInfo->type,
                            pInfo->bstrLogicalPath,
                            pInfo->bstrComponentName,
                            L"DOFASTINCREMENAL"
                            ));
        }


    // add volumes to the current snapshot set
   bAtLeastOneSelected = UpdateSnapshotSet(pvbc, pComponent, pInfo, wszVolumes, rgpSnapshotId, cSnapshot);

    // add volumes to the current snapshot set for all implicitly-selected components
    CComBSTR bstrFullPath = wszLogicalPath;
    if (bstrFullPath)
        bstrFullPath += L"\\";
    bstrFullPath += wszComponentName;
    if (!bstrFullPath)
        Error(E_OUTOFMEMORY, L"Ran out of memory");
    
    UINT cIncludeFiles = 0, cExcludeFiles = 0, cComponents = 0;
    CHECK_SUCCESS(pMetadata->GetFileCounts(&cIncludeFiles, &cExcludeFiles, &cComponents));
    for (UINT iComponent = 0; iComponent < cComponents; iComponent++)
        {
        CComPtr<IVssWMComponent> pCurrent;
        CHECK_SUCCESS(pMetadata->GetComponent(iComponent, &pCurrent));

        PVSSCOMPONENTINFO pCurrentInfo = NULL;
        CHECK_SUCCESS(pCurrent->GetComponentInfo(&pCurrentInfo));
        
        if (pCurrentInfo->bstrLogicalPath &&
            wcsstr(pCurrentInfo->bstrLogicalPath, bstrFullPath) == pCurrentInfo->bstrLogicalPath)
            {
            bAtLeastOneSelected = UpdateSnapshotSet(pvbc, pCurrent, pCurrentInfo, wszVolumes, rgpSnapshotId, cSnapshot)
                                || bAtLeastOneSelected;
            }

        pCurrent->FreeComponentInfo(pCurrentInfo);
        }
    
    if (g_bTestNewInterfaces)
    	{
        for (unsigned i = 0; i < pInfo->cDependencies; i++)
            {
            CComPtr<IVssWMDependency> pDependency;
            CHECK_SUCCESS(pComponent->GetDependency(i, &pDependency));
    
            VSS_ID writerId;
            CComBSTR logicalPath, componentName;
            CHECK_SUCCESS(pDependency->GetWriterId(&writerId));
            CHECK_NOFAIL(pDependency->GetLogicalPath(&logicalPath));
            CHECK_SUCCESS(pDependency->GetComponentName(&componentName));
    
            if (AddChildComponent(pvbc, writerId, logicalPath, componentName, wszVolumes, rgpSnapshotId, cSnapshot))
                bAtLeastOneSelected = TRUE;
            }
    	}
	
    pComponent->FreeComponentInfo(pInfo);
    return bAtLeastOneSelected;
    }

// find component in the backup components document
bool FindComponentInDoc
    (
    IVssBackupComponents *pvbc,
    VSS_ID idWriter,
    LPCWSTR wszLogicalPath,
    LPCWSTR wszComponentName,
    IVssComponent **ppComponent,
    VSS_ID *pidInstance
    )
    {
    HRESULT hr;

    UINT cWriterComponents;
    CHECK_SUCCESS(pvbc->GetWriterComponentsCount(&cWriterComponents));
    for(UINT iWriterComponent = 0; iWriterComponent < cWriterComponents; iWriterComponent++)
        {
        CComPtr<IVssWriterComponentsExt> pWriter;

        CHECK_SUCCESS(pvbc->GetWriterComponents(iWriterComponent, &pWriter));
        VSS_ID idInstanceT;
        VSS_ID idWriterT;
        CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstanceT, &idWriterT));
        if (idWriter == idWriterT)
            {
            UINT cComponents;

            CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
            for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
                {
                CComPtr<IVssComponent> pComponent;

                CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));

                CComBSTR bstrLogicalPath;
                CComBSTR bstrComponentName;
                CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
                CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
                if (_wcsicmp(bstrComponentName, wszComponentName) == 0 &&
                    ((!wszLogicalPath && !bstrLogicalPath) ||
                     (wszLogicalPath && bstrLogicalPath &&
                      _wcsicmp(wszLogicalPath, bstrLogicalPath) == 0)))
                    {
                    CHECK_SUCCESS(pWriter->GetComponent(iComponent, ppComponent));
                    *pidInstance = idInstanceT;
                    return true;
                    }
                }
            }
        }

    return false;
    }



void SetSubcomponentSelectedForRestore
    (
    IVssBackupComponents *pvbc,
    LPCWSTR wszComponentPath,
    LPCWSTR wszComponentName
    )
    {
    HRESULT hr;

    BS_ASSERT(IsWriterPath(wszComponentPath));

    VSS_ID id;
    WCHAR buf[39];

    memcpy(buf, wszComponentPath, 38*sizeof(WCHAR));
    buf[38] = L'\0';
    CLSIDFromString(buf, &id);
    LPCWSTR wszLogicalPath = NULL;
    if (wcslen(wszComponentPath) > 40)
        wszLogicalPath = wszComponentPath + 40;

    CComPtr<IVssComponent> pComponent;
    VSS_ID idInstance;
    if (!FindComponentInDoc
            (
            pvbc,
            id,
            wszLogicalPath,
            wszComponentName,
            &pComponent,
            &idInstance
            ))
        {
        wprintf(L"Subcomponent %s\\%s was not found.\n\n", wszComponentPath, wszComponentName);
        BS_ASSERT(FALSE);
        throw E_UNEXPECTED;
        }

    bool bSelectedForRestore;
    CHECK_SUCCESS(pComponent->IsSelectedForRestore(&bSelectedForRestore))

    // if component is already selected for restore, then do nothing.
    if (!bSelectedForRestore)
        {
        VSS_COMPONENT_TYPE ct;
        CComBSTR bstrLogicalPath;
        CComBSTR bstrComponentName;

        CHECK_SUCCESS(pComponent->GetComponentType(&ct));
        CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
        CHECK_NOFAIL(pComponent->GetComponentName(&bstrComponentName));
        CHECK_SUCCESS(pvbc->SetSelectedForRestore(
                            id,
                            ct,
                            bstrLogicalPath,
                            bstrComponentName,
                            true
                            ));

        SetSubcomponentsSelectedForRestore(pvbc, idInstance, pComponent);
        }
    }

// determine if any subcomponents of a component selected for restore
// should also be selected for restore
void SetSubcomponentsSelectedForRestore
    (
    IVssBackupComponents *pvbc,
    VSS_ID idInstance,
    IVssComponent *pComponent
    )
    {
    HRESULT hr;

    CComPtr<IVssExamineWriterMetadata> pWriterMetadata;
    if (g_wszSavedFilesDirectory[0] == L'\0')
        return;

    LoadMetadataFile(idInstance, &pWriterMetadata);

    CComBSTR bstrLogicalPath;
    CComBSTR bstrComponentName;
    CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
    CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));

    CComPtr<IVssWMComponent> pWMComponent;
    if (!FindComponent
            (
            pWriterMetadata,
            bstrLogicalPath,
            bstrComponentName,
            &pWMComponent
            ))
        {
        wprintf(L"Component %s\\%s cannot be found.\n", bstrLogicalPath, bstrComponentName);
        BS_ASSERT(FALSE);
        throw E_UNEXPECTED;
        }

    PVSSCOMPONENTINFO pInfo;
    CHECK_SUCCESS(pWMComponent->GetComponentInfo(&pInfo));

    unsigned i;
    for(i = 0; i < pInfo->cFileCount; i++)
        {
        CComPtr<IVssWMFiledesc> pFiledesc;
        CHECK_SUCCESS(pWMComponent->GetFile(i, &pFiledesc));

        CComBSTR bstrPath;
        CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
        if (IsWriterPath(bstrPath))
            {
            CComBSTR bstrComponentName;
            CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrComponentName));
            SetSubcomponentSelectedForRestore(pvbc, bstrPath, bstrComponentName);
            }
        }

    for(i = 0; i < pInfo->cDatabases; i++)
        {
        CComPtr<IVssWMFiledesc> pFiledesc;
        CHECK_SUCCESS(pWMComponent->GetDatabaseFile(i, &pFiledesc));

        CComBSTR bstrPath;
        CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
        if (IsWriterPath(bstrPath))
            {
            CComBSTR bstrComponentName;
            CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrComponentName));
            SetSubcomponentSelectedForRestore(pvbc, bstrPath, bstrComponentName);
            }
        }

    for(i = 0; i < pInfo->cLogFiles; i++)
        {
        CComPtr<IVssWMFiledesc> pFiledesc;
        CHECK_SUCCESS(pWMComponent->GetDatabaseLogFile(i, &pFiledesc));

        CComBSTR bstrPath;
        CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
        if (IsWriterPath(bstrPath))
            {
            CComBSTR bstrComponentName;
            CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrComponentName));
            SetSubcomponentSelectedForRestore(pvbc, bstrPath, bstrComponentName);
            }
        }

    pWMComponent->FreeComponentInfo(pInfo);
    }


void TestRevertInterfaces()
    {
   HRESULT hr = S_OK;
    
   CComPtr<IVssBackupComponents> pComp;
   CHECK_SUCCESS(::CreateVssBackupComponents(&pComp));

    if (pComp->RevertToSnapshot(GUID_NULL, true) != E_NOTIMPL)
    	Error(E_NOTIMPL, L"Expected IVssBackupComponents::RevertToSnapshot to return E_NOTIMPL");

    CComPtr<IVssAsync> pAsync;
    if(pComp->QueryRevertStatus(L"C:", &pAsync) != E_NOTIMPL)
    	Error(E_NOTIMPL, L"Expected IVssBackupComponents::QueryRevertStatus  to return E_NOTIMPL");

    CComPtr<IVssCoordinator> pCoord;
    CHECK_SUCCESS(::CoCreateInstance
    		(
    		CLSID_VSSCoordinator,
              NULL,
              CLSCTX_ALL,
              IID_IVssCoordinator,
              (void**)&(pCoord)));

    if (pCoord->RevertToSnapshot(GUID_NULL, true) != E_NOTIMPL)
    	Error(E_NOTIMPL, L"Expected IVssCoordinator::RevertToSnapshot to return E_NOTIMPL");

    if(pCoord->QueryRevertStatus(L"C:", &pAsync) != E_NOTIMPL)
    	Error(E_NOTIMPL, L"Expected IVssCoordinator::QueryRevertStatus  to return E_NOTIMPL");
    
    }

void TestBackupShutdown()
{
  HRESULT hr = S_OK;
  HRESULT hrStatus = S_OK;
  
  VSS_ID* writerInstances = NULL;
  UINT cWriters = 0;
  
  wprintf(L"Testing BackupShutdown interface\n");
  CComPtr<IVssBackupComponents> pComp;
  CHECK_SUCCESS(::CreateVssBackupComponents(&pComp));
  CHECK_SUCCESS(pComp->InitializeForBackup());
  CHECK_SUCCESS(pComp->SetBackupState(false, true, VSS_BT_OTHER, false));
  
  CComPtr<IVssAsync> pAsync; 
  CHECK_SUCCESS(pComp->GatherWriterMetadata(&pAsync));
  CHECK_SUCCESS(pAsync->Wait());
  CHECK_SUCCESS(pAsync->QueryStatus(&hrStatus, NULL));
  CHECK_NOFAIL(hrStatus);
  pAsync = NULL;
  
  VSS_ID idSet, idSnap;
  CHECK_SUCCESS(pComp->StartSnapshotSet(&idSet));
  CHECK_SUCCESS(pComp->AddToSnapshotSet(L"C:\\", GUID_NULL, &idSnap));

  wprintf(L"BackupShutdown should not now be called\n");
  pComp = NULL;

  CHECK_SUCCESS(::CreateVssBackupComponents(&pComp));
  CHECK_SUCCESS(pComp->InitializeForBackup());
  CHECK_SUCCESS(pComp->SetBackupState(false, true, VSS_BT_OTHER, false));
  CHECK_SUCCESS(pComp->GatherWriterMetadata(&pAsync));
  CHECK_SUCCESS(pAsync->Wait());
  CHECK_SUCCESS(pAsync->QueryStatus(&hrStatus, NULL));
  CHECK_NOFAIL(hrStatus);
  pAsync = NULL;
  
  // store a list of writer instances  
  CHECK_SUCCESS(pComp->GetWriterMetadataCount(&cWriters));
  writerInstances = new VSS_ID[cWriters];
  if (writerInstances == NULL)
  	Error(E_OUTOFMEMORY, L"Ran out of memory");

  for (UINT x = 0; x < cWriters; x++)
  	{
  	CComPtr<IVssExamineWriterMetadata> pMeta;
  	CHECK_SUCCESS(pComp->GetWriterMetadata(x, &writerInstances[x], &pMeta));
  	}
  
  CHECK_SUCCESS(pComp->StartSnapshotSet(&idSet));
  CHECK_SUCCESS(pComp->AddToSnapshotSet(L"C:\\", GUID_NULL, &idSnap));
  CHECK_SUCCESS(pComp->PrepareForBackup(&pAsync));
  CHECK_SUCCESS(pAsync->Wait());
  CHECK_SUCCESS(pAsync->QueryStatus(&hrStatus, NULL));
  CHECK_NOFAIL(hrStatus);
  pAsync = NULL;
  CHECK_SUCCESS(pComp->DoSnapshotSet(&pAsync));
  CHECK_SUCCESS(pAsync->Wait());
  CHECK_SUCCESS(pAsync->QueryStatus(&hrStatus, NULL));
  CHECK_NOFAIL(hrStatus);
  pAsync = NULL;
  
  wprintf(L"BackupSutdown should now be called for snapshot-set id " WSTR_GUID_FMT 
  	L"\n", GUID_PRINTF_ARG(idSet));
  pComp = NULL;

  CComPtr<IVssCoordinator> pCoord;
  CHECK_SUCCESS(::CoCreateInstance
   		(
   		CLSID_VSSCoordinator,
              NULL,
              CLSCTX_ALL,
              IID_IVssCoordinator,
              (void**)&(pCoord)));

  CHECK_SUCCESS(pCoord->StartSnapshotSet(&idSet));
  CHECK_SUCCESS(pCoord->AddToSnapshotSet(L"C:\\", GUID_NULL, &idSnap));
  CHECK_SUCCESS(pCoord->SetWriterInstances(cWriters, writerInstances));
  CHECK_SUCCESS(pCoord->DoSnapshotSet(NULL, &pAsync));
  CHECK_SUCCESS(pAsync->Wait());
  CHECK_SUCCESS(pAsync->QueryStatus(&hrStatus, NULL));
  CHECK_NOFAIL(hrStatus);
  pAsync = NULL;
  wprintf(L"BackupSutdown should now be called for snapshot-set id " WSTR_GUID_FMT 
  	L"\n", GUID_PRINTF_ARG(idSet));

  CHECK_SUCCESS(pCoord->StartSnapshotSet(&idSet));
  
  delete [] writerInstances;
}

extern "C" __cdecl wmain(int argc, WCHAR **argv)
    {
    WCHAR wszVolumes[2048];
    wszVolumes[0] = L'\0';

    UINT cSnapshot = 0;
    VSS_ID rgpSnapshotId[64];

    CTestVssWriter *pInstance = NULL;
    bool bCreated = false;
    bool bSubscribed = false;
    HRESULT hrMain = S_OK;
    bool bCoInitializeSucceeded = false;


    HRESULT hr = S_OK;
    CComBSTR bstrXML;
    BOOL bXMLSaved = FALSE;

    // Parse command line arguments
    if (ParseCommandLine(argc, argv) != S_OK)
        {
        // Don't throw since we want to avoid assertions here - we can return safely
        return (3);
        }

    CHECK_SUCCESS(CoInitializeEx(NULL, COINIT_MULTITHREADED));

    // Initialize COM security
    CHECK_SUCCESS
        (
        CoInitializeSecurity
            (
            NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
            -1,                                  //  IN LONG                         cAuthSvc,
            NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
            NULL,                                //  IN void                        *pReserved1,
            RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
            RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
            NULL,                                //  IN void                        *pAuthList,
            EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
            NULL                                 //  IN void                        *pReserved3
            )
        );

    bCoInitializeSucceeded = true;

    if ( !AssertPrivilege( SE_BACKUP_NAME ) )
        {
        wprintf( L"AssertPrivilege returned error, rc:%d\n", GetLastError() );
        return 2;
        }

    // Get chosen components for backup and/or restore
    if (wcslen(g_wszComponentsFileName) > 0)
        {
        g_pWriterSelection = CWritersSelection::CreateInstance();
        if (g_pWriterSelection == NULL)
            {
            wprintf(L"allocation failure\n");
            DebugBreak();
            }

        if (g_pWriterSelection->BuildChosenComponents(g_wszComponentsFileName) != S_OK)
            {
            wprintf(L"Component selection in %s is ignored due to a failure in processing the file\n", g_wszComponentsFileName);
            g_pWriterSelection = 0;
            }
        }

//  EnumVolumes();

//  TestSnapshotXML();

    if (! g_bExcludeTestWriter) {
        pInstance = new CTestVssWriter(g_bRestoreTest, g_bTestNewInterfaces, g_lWriterWait, g_lRestoreTestOptions);
        if (pInstance == NULL)
            {
            wprintf(L"allocation failure\n");
            DebugBreak();
            }

        bCreated = true;
        pInstance->Initialize();
        CHECK_SUCCESS(pInstance->Subscribe());
        bSubscribed = true;
    }

    if (g_bTestNewInterfaces)
    	{
    	TestRevertInterfaces();
    	TestBackupShutdown();
    	}
    
    if (! g_bRestoreOnly)
        {
        CComBSTR strSnapshotSetId = "12345678-1234-1234-1234-1234567890ab";

        CComPtr<IVssBackupComponents> pvbc;

        CHECK_SUCCESS(CreateVssBackupComponents(&pvbc));


        CHECK_SUCCESS(pvbc->InitializeForBackup());
        CHECK_SUCCESS(pvbc->SetBackupState (true,
                            g_bBootableSystemState,
                            g_BackupType,
                            true));


        unsigned cWriters;
        CComPtr<IVssAsync> pAsync;
        CHECK_NOFAIL(pvbc->GatherWriterMetadata(&pAsync));
        LoopWait(pAsync, 30, L"GatherWriterMetadata");
        CHECK_NOFAIL(pvbc->GetWriterMetadataCount(&cWriters));

        VSS_ID id;

        while(TRUE)
            {
            hr = pvbc->StartSnapshotSet(&id);
            if (hr == S_OK)
                break;

            if (hr == VSS_E_SNAPSHOT_SET_IN_PROGRESS)
                Sleep(1000);
            else
                CHECK_SUCCESS(hr);
            }

        BOOL bAtLeastOneSelected = FALSE;

        for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
            {
            CComPtr<IVssExamineWriterMetadata> pMetadata;
            VSS_ID idInstance;

            CHECK_SUCCESS(pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata));
            VSS_ID idInstanceT;
            VSS_ID idWriter;
            CComBSTR bstrWriterName;
            VSS_USAGE_TYPE usage;
            VSS_SOURCE_TYPE source;

            CHECK_SUCCESS(pMetadata->GetIdentity
                    (
                    &idInstanceT,
                    &idWriter,
                    &bstrWriterName,
                    &usage,
                    &source
                    ));

            wprintf (L"\n\n");

            if (memcmp(&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
                {
                wprintf(L"Instance id mismatch\n");
                DebugBreak();
                }

            WCHAR *pwszInstanceId;
            WCHAR *pwszWriterId;
            UuidToString(&idInstance, &pwszInstanceId);
            UuidToString(&idWriter, &pwszWriterId);
            wprintf (L"WriterName = %s\n\n"
                 L"    WriterId   = %s\n"
                 L"    InstanceId = %s\n"
                 L"    UsageType  = %d (%s)\n"
                 L"    SourceType = %d (%s)\n",
                 bstrWriterName,
                 pwszWriterId,
                 pwszInstanceId,
                 usage,
                 GetStringFromUsageType (usage),
                 source,
                 GetStringFromSourceType (source));

            RpcStringFree(&pwszInstanceId);
            RpcStringFree(&pwszWriterId);

            unsigned cIncludeFiles, cExcludeFiles, cComponents;
            CHECK_SUCCESS(pMetadata->GetFileCounts (&cIncludeFiles,
                                &cExcludeFiles,
                                &cComponents));

            CComBSTR bstrPath;
            CComBSTR bstrFilespec;
            CComBSTR bstrAlternate;
            CComBSTR bstrDestination;
            unsigned i;

            for(i = 0; i < cIncludeFiles; i++)
                {
                CComPtr<IVssWMFiledesc> pFiledesc;
                CHECK_SUCCESS(pMetadata->GetIncludeFile(i, &pFiledesc));

                PrintFiledesc(pFiledesc, L"\n    Include File");
                }

            for(i = 0; i < cExcludeFiles; i++)
                {
                CComPtr<IVssWMFiledesc> pFiledesc;
                CHECK_SUCCESS(pMetadata->GetExcludeFile(i, &pFiledesc));
                PrintFiledesc(pFiledesc, L"\n    Exclude File");
                }

	     if (g_bTestNewInterfaces)
	     	{
	     	     DWORD schema = 0;
		     CHECK_SUCCESS(pMetadata->GetBackupSchema(&schema));
	            wprintf(L"        BackupSchema        = 0x%x\n", schema);
	     	}
		 	
            for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
                {
                CComPtr<IVssWMComponent> pComponent;
                PVSSCOMPONENTINFO pInfo;
                CHECK_SUCCESS(pMetadata->GetComponent(iComponent, &pComponent));
                CHECK_SUCCESS(pComponent->GetComponentInfo(&pInfo));
                wprintf (L"\n"
                         L"    Component %d, type = %d (%s)\n"
                         L"        LogicalPath = %s\n"
                         L"        Name        = %s\n"
                         L"        Caption     = %s\n",
                         iComponent,
                         pInfo->type,
                         GetStringFromComponentType (pInfo->type),
                         pInfo->bstrLogicalPath,
                         pInfo->bstrComponentName,
                         pInfo->bstrCaption);


                 wprintf (L"        RestoreMetadata        = %s\n"
                          L"        NotifyOnBackupComplete = %s\n"
                          L"        Selectable             = %s\n"
                          L"        SelectableForRestore = %s\n"
                          L"        ComponentFlags        = 0x%x\n",
                          pInfo->bRestoreMetadata        ? L"yes" : L"no",
                          pInfo->bNotifyOnBackupComplete ? L"yes" : L"no",
                          pInfo->bSelectable             ? L"yes" : L"no",
                          pInfo->bSelectableForRestore ? L"yes" : L"no",
                          pInfo->dwComponentFlags);

		  if (g_bTestNewInterfaces)
		  	{
	                for (unsigned iDependency = 0; iDependency < pInfo->cDependencies; iDependency++)
	                    {
	                        CComPtr<IVssWMDependency> pDependency;
	                        CHECK_NOFAIL(pComponent->GetDependency(iDependency, &pDependency));

	                        VSS_ID writerId;
	                        CComBSTR logicalPath, componentName;
	                        CHECK_SUCCESS(pDependency->GetWriterId(&writerId));
	                        CHECK_NOFAIL(pDependency->GetLogicalPath(&logicalPath));
	                        CHECK_SUCCESS(pDependency->GetComponentName(&componentName));

	                        wprintf (L"        (Dependent Component):              WriterId " WSTR_GUID_FMT L"\n"
	                                    L"                                                           Logical Path %s\n"
	                                    L"                                                           Name %s\n",
	                                    GUID_PRINTF_ARG(writerId),
	                                    logicalPath,
	                                    componentName);
	                    }
		  	}
                
                BOOL bSelected = TRUE;
                if (g_pWriterSelection)
                    {
                    // User provided a valid selection file
                    bSelected = g_pWriterSelection->IsComponentSelected(idWriter, pInfo->bstrLogicalPath, pInfo->bstrComponentName);
                    if (bSelected)
                        {
//                        if (!pInfo->bSelectable && !pInfo->bSelectableForRestore)
//                            {
//                            Error(E_UNEXPECTED, L"\na completely non-selectable component was selected!\n");
//                            }
                        
                        wprintf (L"\n        Component \"%s\" IS selected for Backup\n\n", pInfo->bstrComponentName);
                        }
                    else
                        {
                        wprintf (L"\n        Component \"%s\" is NOT selected for Backup\n\n", pInfo->bstrComponentName);
                        }
                    }

                // only add selectable components to the document
                // BUGBUG: should add non-selectable components only if no selectable ancestor
                if (bSelected)
                    {
                    PVSS_ID rgSnapshotIds = rgpSnapshotId;
                    if (DoAddComponent
                            (
                            pvbc,
                            pMetadata,
                            idInstance,
                            idWriter,
                            pInfo->bstrLogicalPath,
                            pInfo->bstrComponentName,
                            wszVolumes,
                            rgSnapshotIds,
                            cSnapshot
                            ))
                        bAtLeastOneSelected = true;
                    }

                pComponent->FreeComponentInfo(pInfo);
                }

            VSS_RESTOREMETHOD_ENUM method;
            CComBSTR bstrUserProcedure;
            CComBSTR bstrService;
            VSS_WRITERRESTORE_ENUM writerRestore;
            unsigned cMappings;
            bool bRebootRequired;

            CHECK_NOFAIL(pMetadata->GetRestoreMethod (&method,
                                  &bstrService,
                                  &bstrUserProcedure,
                                  &writerRestore,
                                  &bRebootRequired,
                                  &cMappings));


            wprintf (L"\n"
                 L"    Restore method = %d (%s)\n"
                 L"    Service        = %s\n"
                 L"    User Procedure = %s\n"
                 L"    WriterRestore  = %d (%s)\n"
                 L"    RebootRequired = %s\n",
                 method,
                 GetStringFromRestoreMethod (method),
                 bstrService,
                 bstrUserProcedure,
                 writerRestore,
                 GetStringFromWriterRestoreMethod (writerRestore),
                 bRebootRequired ? L"yes" : L"no");

            for(i = 0; i < cMappings; i++)
            {
            CComPtr<IVssWMFiledesc> pFiledesc;

            CHECK_SUCCESS(pMetadata->GetAlternateLocationMapping(i, &pFiledesc));

            PrintFiledesc(pFiledesc, L"AlternateMapping");
            }

            CComBSTR bstrMetadata;
            CHECK_SUCCESS(pMetadata->SaveAsXML(&bstrMetadata));
            CComPtr<IVssExamineWriterMetadata> pMetadataNew;
            CHECK_SUCCESS(CreateVssExamineWriterMetadata(bstrMetadata, &pMetadataNew));
            CHECK_SUCCESS(pMetadataNew->GetIdentity (&idInstanceT,
                              &idWriter,
                              &bstrWriterName,
                              &usage,
                              &source));

            wprintf (L"\n\n");

            if (memcmp(&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
                {
                wprintf(L"Instance id mismatch\n");
                DebugBreak();
                }

            UuidToString(&idInstance, &pwszInstanceId);
            UuidToString(&idWriter, &pwszWriterId);
            wprintf (L"WriterName = %s\n\n"
                 L"    WriterId   = %s\n"
                 L"    InstanceId = %s\n"
                 L"    UsageType  = %d (%s)\n"
                 L"    SourceType = %d (%s)\n",
                 bstrWriterName,
                 pwszWriterId,
                 pwszInstanceId,
                 usage,
                 GetStringFromUsageType (usage),
                 source,
                 GetStringFromSourceType (source));

            RpcStringFree(&pwszInstanceId);
            RpcStringFree(&pwszWriterId);
            }

        //
        // Proceed with backup only if at least one component and one volume was selected for backup
        //
        if (bAtLeastOneSelected)
            {

            DoPrepareBackup(pvbc);

            CheckStatus(pvbc, L"After Prepare Backup");

            HRESULT hrResult;
            DoSnapshotSet(pvbc, hrResult);

            if (FAILED(hrResult))
                {
                wprintf(L"Creating the snapshot failed.  hr = 0x%08lx\n", hrResult);
                CheckStatus(pvbc, L"After Do Snapshot");
                }
            else
                {
                CheckStatus(pvbc, L"After Do Snapshot");

                PrintPartialFilesForComponents(pvbc);
                PrintDifferencedFilesForComponents(pvbc);
                
                SaveFiles(pvbc, rgpSnapshotId, cSnapshot);

                DoBackupComplete(pvbc);
                CheckStatus(pvbc, L"After Backup Complete");

                // Save backup document in a string
                CHECK_SUCCESS(pvbc->SaveAsXML(&bstrXML));
                bXMLSaved = TRUE;

                // Save backup document (XML string) in a file
                if (wcslen(g_wszBackupDocumentFileName) > 0)
                    {
                    if (SaveBackupDocument(bstrXML))
                        {
                        wprintf(L"Backup document saved successfully in %s\n", g_wszBackupDocumentFileName);
                        }
                    else
                        {
                        wprintf(L"Failed to save backup document: SaveBackupDocument returned error %d\n", GetLastError());
                        }
                    }

                // Delete the snapshot set
                LONG lSnapshotsNotDeleted;
                VSS_ID rgSnapshotsNotDeleted[10];

                hr  = pvbc->DeleteSnapshots (id,
                             VSS_OBJECT_SNAPSHOT_SET,
                             false,
                             &lSnapshotsNotDeleted,
                             rgSnapshotsNotDeleted);

                if (FAILED(hr))
                    wprintf(L"Deletion of Snapshots failed.  hr = 0x%08lx\n", hr);
                }
            }
        else
            {
            wprintf(L"\nBackup test is aborted since no component is selected, therefore, there are no volumes added to the snapshot set\n\n");
            }

        CHECK_SUCCESS(pvbc->FreeWriterMetadata());
        }




    // Restore is done if
    //  1. User did not ask backup-only AND
    //  2. User asked restore-only OR user asked both, and backup succeeded
    if (! g_bBackupOnly)
        {
        if (g_bRestoreOnly || bXMLSaved)
            {
            BOOL bXMLLoaded = FALSE;

            // Load XML string only in Restore-only case
            if (g_bRestoreOnly)
                {
                if (LoadBackupDocument(bstrXML))
                    {
                    bXMLLoaded = TRUE;
                    wprintf(L"Backup document was loaded from %s\n", g_wszBackupDocumentFileName);
                    }
                else
                    {
                    wprintf(L"Failed to load backup document: LoadBackupDocument returned error %d\n", GetLastError());
                    }
                }

            // If we have a backup document from current backup or loaded successfully froma previous backup
            if (bXMLSaved || bXMLLoaded)
                {
                // Prepare for restore
                CComPtr<IVssBackupComponents> pvbcRestore;

                CHECK_SUCCESS(CreateVssBackupComponents(&pvbcRestore));
                CHECK_SUCCESS(pvbcRestore->InitializeForRestore(bstrXML));
                wprintf(L"InitializeForRestore succeeded.\n");

                // Do the restore
                DoRestore(pvbcRestore);
                }
            }
        else
            {
            wprintf(L"\nRestore test is not done due to a failure in the preceding Backup test\n\n");
            }
        }

    if (bSubscribed)
        pInstance->Unsubscribe();

    if (bCreated)
        delete pInstance;

    if (FAILED(hrMain))
    wprintf(L"Failed with %08x.\n", hrMain);

    if (bCoInitializeSucceeded)
    CoUninitialize();

    return(0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\betest\voltest.cxx ===
#include "stdafx.hxx"
#include "vss.h"
#include "vswriter.h"
#include "vsbackup.h"
#include <debug.h>
#include <time.h>

#include <vs_inc.hxx>
#include <vsevent.h>
#include <vscoordint.h>
#include <vdslun.h>
#include <vs_wmxml.hxx>
#include <vs_cmxml.hxx>
#include <vs_trace.hxx>

void PrintVolumeInfo(LPWSTR wszVolume)
	{
	wprintf(L"\n\nInformation for volume %s\n\n", wszVolume);
	// get rid of last backslash
	wszVolume[wcslen(wszVolume)-1] = L'\0';

	HANDLE hVol = CreateFile
					(
					wszVolume,
					GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL
					);

    if (hVol == INVALID_HANDLE_VALUE)
		{
		DWORD dwErr = GetLastError();
		wprintf(L"CreateFile of volume failed with error %d.\n", dwErr);
		return;
		}

	WCHAR bufExtents[1024];
	DWORD size;
	BOOL b = DeviceIoControl
			(
			hVol,
			IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
			NULL,
			0,
			(PVOID) bufExtents,
			sizeof(bufExtents),
			&size,
			NULL
			);

    if (!b)
		{
		DWORD dwErr = GetLastError();
		wprintf(L"IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS failed with error %d.\n", dwErr);
		CloseHandle(hVol);
		return;
		}

	VOLUME_DISK_EXTENTS *pDiskExtents = (VOLUME_DISK_EXTENTS *) bufExtents;

	ULONG PrevDiskNo = 0xffffffff;
	printf("# of extents = %d\n\n", pDiskExtents->NumberOfDiskExtents);

	for(UINT iExtent = 0; iExtent < pDiskExtents->NumberOfDiskExtents; iExtent++)
		{
		ULONG DiskNo = pDiskExtents->Extents[iExtent].DiskNumber;
		printf("Extent %d:\nDisk %d, Low=0x%I64lx, Length=0x%I64lx\n\n",
			   iExtent,
		       DiskNo,
               pDiskExtents->Extents[iExtent].StartingOffset,
               pDiskExtents->Extents[iExtent].ExtentLength
			   );

		if (DiskNo != PrevDiskNo)
			{
			PrevDiskNo = DiskNo;
			WCHAR wszbuf[32];
			swprintf(wszbuf, L"\\\\.\\PHYSICALDRIVE%u", DiskNo);
			HANDLE hDisk = CreateFile
								(
								wszbuf,
								GENERIC_READ|GENERIC_WRITE,
								FILE_SHARE_READ,
								NULL,
								OPEN_EXISTING,
								0,
								NULL
								);

            if (hDisk == INVALID_HANDLE_VALUE)
				{
				DWORD dwErr = GetLastError();
				wprintf(L"Cannot open disk %d due to error %d.  Skipping\n", DiskNo, dwErr);
				continue;
				}

			STORAGE_PROPERTY_QUERY query;
			query.PropertyId = StorageDeviceProperty;
			query.QueryType = PropertyStandardQuery;
			BYTE buf[1024];
			DWORD dwSize;

			if (!DeviceIoControl
						(
						hDisk,
						IOCTL_STORAGE_QUERY_PROPERTY,
						&query,
						sizeof(query),
						buf,
						1024,
						&dwSize,
						NULL
						))
                {
				DWORD dwErr = GetLastError();
				if (dwErr != ERROR_NOT_SUPPORTED)
					wprintf(L"IOCTL_STORAGE_QUERY_PROPERTY failed due to error %d.\n", dwErr);

				CloseHandle(hDisk);
				continue;
				}

			STORAGE_DEVICE_DESCRIPTOR *pDesc = (STORAGE_DEVICE_DESCRIPTOR *) buf;
			printf("Information for disk %d.\n\nbus=", DiskNo);

			switch (pDesc->BusType)
                {
				default:
					printf("(other)\n");
					break;
					

				case BusTypeScsi:
					printf("(SCSI)\n");
					break;

				case BusTypeAtapi:
					printf("(ATAPI)\n");
					break;

                case BusTypeAta:
					printf("(ATA)\n");
					break;

				case BusType1394:
					printf("(1394)\n");
					break;

				case BusTypeSsa:
					printf("(SSA)\n");
					break;

				case BusTypeFibre:
					printf("(Fibre)\n");
					break;

				case BusTypeUsb:
					printf("(Usb)\n");
					break;

				case BusTypeRAID:
					printf("(RAID)\n");
					break;
                }

            if (pDesc->VendorIdOffset)
				{
                LPSTR szVendor = (LPSTR)((BYTE *) pDesc + pDesc->VendorIdOffset);
				printf("VendorId: %s\n", szVendor);
                }

			if (pDesc->ProductIdOffset)
                {
				LPSTR szProduct = (LPSTR)((BYTE *) pDesc + pDesc->ProductIdOffset);
				printf("ProductId: %s\n", szProduct);
                }
			if (pDesc->ProductRevisionOffset)
                {
				LPSTR szRevision = (LPSTR)((BYTE *) pDesc + pDesc->ProductRevisionOffset);
				printf("RevisionId: %s\n", szRevision);
                }

			if (pDesc->SerialNumberOffset)
				{
				LPSTR szSerialNo = (LPSTR)((BYTE *) pDesc + pDesc->SerialNumberOffset);
				printf("Serial#: %s\n", szSerialNo);
				}

			query.PropertyId = StorageDeviceIdProperty;
			query.QueryType = PropertyStandardQuery;

			if (!DeviceIoControl
						(
						hDisk,
						IOCTL_STORAGE_QUERY_PROPERTY,
						&query,
						sizeof(query),
						buf,
						1024,
						&dwSize,
						NULL
						))
                {
				DWORD dwErr = GetLastError();
			    if (dwErr != ERROR_NOT_SUPPORTED)
					wprintf(L"IOCTL_STORAGE_QUERY_PROPERTY failed due to error %d.\n", dwErr);

				CloseHandle(hDisk);
				continue;
				}

			STORAGE_DEVICE_ID_DESCRIPTOR *pDevId = (STORAGE_DEVICE_ID_DESCRIPTOR *) buf;
			printf("# of identifiers = %d\n", pDevId->NumberOfIdentifiers);

			STORAGE_IDENTIFIER *pId = (STORAGE_IDENTIFIER *) pDevId->Identifiers;
			for(UINT i = 0; i < pDevId->NumberOfIdentifiers; i++)
				{
				switch(pId->Type)
					{
					default:
						printf("(other) ");
						break;

                    case StorageIdTypeVendorSpecific:
						printf("(vendor specific) ");
						break;

                    case StorageIdTypeVendorId:
						printf("(vendor id) ");
						break;

                    case StorageIdTypeEUI64:
						printf("(EUI64) ");
						break;

                    case StorageIdTypeFCPHName:
						printf("(FCPHName) ");
						break;
                    }

				if (pId->CodeSet == StorageIdCodeSetAscii)
					printf("%s\n", pId->Identifier);
				else
					{
					for(UINT i = 0; i < pId->IdentifierSize; i++)
						{
						printf("%2x ", pId->Identifier[i]);
						if ((i % 16) == 0 && i > 0)
							printf("\n");
						}
					}

				pId = (STORAGE_IDENTIFIER *) ((BYTE *) pId + pId->NextOffset);
				}
				

			CloseHandle(hDisk);
			}
		}
	}



				



void EnumVolumes()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"EnumVolumes");

	HANDLE h = INVALID_HANDLE_VALUE;
	try
		{
		WCHAR volName[1024];

		h = FindFirstVolume(volName, sizeof(volName)/sizeof(WCHAR));
		if (h == INVALID_HANDLE_VALUE)
			{
			DWORD dwErr = GetLastError();
			Error(E_UNEXPECTED, L"FindFirstVolume failed due to error %d.\n", dwErr);
			}

		while(TRUE)
			{
			PrintVolumeInfo(volName);
			if (!FindNextVolume(h, volName, sizeof(volName)/ sizeof(WCHAR)))
				{
				DWORD dwErr = GetLastError();
				if (dwErr == ERROR_NO_MORE_FILES)
					break;
				else
					Error(E_UNEXPECTED, L"Unexpected error %d from FindNextVolume.\n", dwErr);
				}
			}

		if (!FindVolumeClose(h))
			{
			DWORD dwErr = GetLastError();
			Error(E_UNEXPECTED, L"Cannot close volume handle due to error %d.\n", dwErr);
			}

		h = INVALID_HANDLE_VALUE;
		}
	VSS_STANDARD_CATCH(ft)

	if (h != INVALID_HANDLE_VALUE)
		FindClose(h);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\betest\saverest.cpp ===
#include "stdafx.hxx"
//#include "vs_idl.hxx"
#include "vss.h"
#include "vswriter.h"
#include "vsbackup.h"
#include "compont.h"
#include <debug.h>
#include <cwriter.h>
#include <lmshare.h>
#include <lmaccess.h>
#include <time.h>
#include <vs_inc.hxx>

extern WCHAR g_wszSavedFilesDirectory[];

bool FindComponent
    (
    IVssExamineWriterMetadata *pMetadata,
    LPCWSTR wszLogicalPath,
    LPCWSTR wszComponentName,
    IVssWMComponent **ppComponent
    );

typedef struct _SAVE_INFO
    {
    IVssBackupComponents *pvbc;
    IVssComponent *pComponent;
    IVssExamineWriterMetadata *pMetadata;
    CVssSimpleMap<VSS_PWSZ, VSS_PWSZ> mapSnapshots;
    } SAVE_INFO;


void DoCopyFile(LPCWSTR wszSource, LPCWSTR wszDest)
    {
    CComBSTR bstr = wszDest;
    UINT cwc = (UINT) wcslen(wszDest);
    HANDLE hFile;
    LPWSTR wszBuf = new WCHAR[cwc + 1];
    if (wszBuf == NULL)
        Error(E_OUTOFMEMORY, L"Out of Memory");

    while(TRUE)
        {
        LPWSTR wsz = wcsrchr(bstr, L'\\');
        if (wsz == NULL)
            break;

        *wsz = L'\0';

        wcscpy(wszBuf, bstr);
        wcscat(wszBuf, L"\\");

        hFile = CreateFile
                    (
                    wszBuf,
                    GENERIC_READ,
                    FILE_SHARE_READ|FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_BACKUP_SEMANTICS,
                    NULL
                    );

        if (hFile != INVALID_HANDLE_VALUE)
            {
            CloseHandle(hFile);
            break;
            }
        }

    delete wszBuf;

    // add backslash removed previously
    bstr[wcslen(bstr)] = L'\\';

    while(wcslen(bstr) < cwc)
        {
        if (!CreateDirectory(bstr, NULL))
            {
            DWORD dwErr = GetLastError();
            Error(HRESULT_FROM_WIN32(dwErr), L"CreateDirectory failed with error %d.\n", dwErr);
            }

        bstr[wcslen(bstr)] = L'\\';
        }

    if (wszSource)
        {
        if (!CopyFile(wszSource, wszDest, FALSE))
            {
            DWORD dwErr = GetLastError();
            Error(HRESULT_FROM_WIN32(dwErr), L"CopyFile failed with error %d.\n", dwErr);
            }
        }
    }


void SaveFilesMatchingFilespec
    (
    LPCWSTR wszSnapshotPath,
    LPCWSTR wszSavedPath,
    LPCWSTR wszFilespec
    )
    {
    CComBSTR bstrSP = wszSnapshotPath;
    if (bstrSP[wcslen(bstrSP) - 1] != L'\\')
       bstrSP.Append(L"\\");
    bstrSP.Append(wszFilespec);

    WIN32_FIND_DATA findData;
    HANDLE hFile = FindFirstFile(bstrSP, &findData);
    if (hFile == INVALID_HANDLE_VALUE)
        return;

    try
        {
        do
            {
            if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                CComBSTR bstrCP = wszSavedPath;

                bstrSP = wszSnapshotPath;
                if (bstrSP[wcslen(bstrSP) - 1] != L'\\')
                    bstrSP.Append(L"\\");
                bstrSP.Append(findData.cFileName);

                if (bstrCP[wcslen(bstrCP) - 1] != L'\\')
                    bstrCP.Append(L"\\");
                bstrCP.Append(findData.cFileName);

                DoCopyFile(bstrSP, bstrCP);
                }
            } while(FindNextFile(hFile, &findData));

        FindClose(hFile);
        }
    catch(...)
        {
        FindClose(hFile);
        throw;
        }
    }

void RecurseSaveFiles
    (
    LPCWSTR wszSnapshotPath,
    LPCWSTR wszSavedPath,
    LPCWSTR wszFilespec
    )
    {
    CComBSTR bstrSP = wszSnapshotPath;
    bstrSP.Append(L"\\*.*");

    WIN32_FIND_DATA findData;
    HANDLE hFile = FindFirstFile(bstrSP, &findData);
    if (hFile == INVALID_HANDLE_VALUE)
        return;
    try
        {
        do
            {
            if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                if (wcscmp(findData.cFileName, L".") == 0 ||
                    wcscmp(findData.cFileName, L"..") == 0)
                    continue;

                bstrSP = wszSnapshotPath;
                bstrSP.Append(L"\\");
                bstrSP.Append(findData.cFileName);
                CComBSTR bstrCP = wszSavedPath;
                bstrCP.Append(L"\\");
                bstrCP.Append(findData.cFileName);

                SaveFilesMatchingFilespec(bstrSP, bstrCP, wszFilespec);
                RecurseSaveFiles(bstrSP, bstrCP, wszFilespec);
                }
            } while(FindNextFile(hFile, &findData));

        FindClose(hFile);
        }
    catch(...)
        {
        FindClose(hFile);
        throw;
        }
    }

bool BuildSnapshotPath
    (
    SAVE_INFO &info,
    LPCWSTR wszPath,
    CComBSTR &bstrSnapshotPath
    )
    {
    CComBSTR bstrPath((UINT) wcslen(wszPath) + 1);
    CComBSTR bstrVolumePath((UINT) wcslen(wszPath) + 1);

    wcscpy(bstrPath, wszPath);
    if (wszPath[wcslen(wszPath) - 1] != L'\\')
        wcscat(bstrPath, L"\\");

    if (!GetVolumePathName(bstrPath, bstrVolumePath, (UINT) wcslen(wszPath) + 1))
        {
        DWORD dwErr = GetLastError();
        if (dwErr == ERROR_FILENAME_EXCED_RANGE)
            {
            if (wcslen(bstrPath) >= 3 && bstrPath[1] == L':' && bstrPath[2] == L'\\')
                {
                memcpy(bstrVolumePath, bstrPath, 6);
                bstrVolumePath[3] = L'\0';
                }
            else
                Error(HRESULT_FROM_WIN32(dwErr), L"GetVolumePathName failed with error %d\nPath=%s.", dwErr, wszPath);
            }
        else
            Error(HRESULT_FROM_WIN32(dwErr), L"GetVolumePathName failed with error %d\nPath=%s.", dwErr, wszPath);
        }

    WCHAR wszVolumeName[MAX_PATH];

    if (!GetVolumeNameForVolumeMountPoint(bstrVolumePath, wszVolumeName, MAX_PATH))
        return false;

    LPCWSTR wszSnapshotDeviceName = info.mapSnapshots.Lookup(wszVolumeName);
    if (wszSnapshotDeviceName == NULL)
        Error(E_UNEXPECTED, L"Snapshot device does not exist for path %s", wszPath);

    bstrSnapshotPath.Append(wszSnapshotDeviceName);
    bstrSnapshotPath.Append(wszPath + wcslen(bstrVolumePath) - 1);
    return true;
    }


void BuildSavedPath
    (
    LPCWSTR wszPath,
    CComBSTR &bstrSavedPath
    )
    {
    bstrSavedPath.Append(g_wszSavedFilesDirectory);
    bstrSavedPath.Append(L"VOLUME");
    WCHAR wszDrive[2];
    wszDrive[0] = wszPath[0];
    wszDrive[1] = L'\0';
    bstrSavedPath.Append(wszDrive);
    bstrSavedPath.Append(wszPath + 2);
    }

void DoExpandEnvironmentStrings(CComBSTR &bstrPath)
    {
    if (!bstrPath)
        return;

    if (wcschr(bstrPath, L'%') != NULL)
        {
        WCHAR wsz[MAX_PATH];

        UINT cwc = ExpandEnvironmentStrings(bstrPath, wsz, MAX_PATH);
        if (cwc == 0)
            {
            DWORD dwErr = GetLastError();
            Error(HRESULT_FROM_WIN32(dwErr), L"ExpandEnvironmentStrings failed due to error %d.\n", dwErr);
            }
        else if (cwc <= MAX_PATH)
            bstrPath = wsz;
        else
            {
            LPWSTR wszT = new WCHAR[cwc];
            if (!ExpandEnvironmentStrings(bstrPath, wszT, MAX_PATH))
                {
                DWORD dwErr = GetLastError();
                Error(HRESULT_FROM_WIN32(dwErr), L"ExpandEnvironmentStrings failed due to error %d.\n", dwErr);
                }

            bstrPath = wszT;
            }
        }
    }

void SaveDataFiles
    (
    SAVE_INFO &saveInfo,
    IVssWMFiledesc *pFiledesc
    )
    {
    CComBSTR bstrPath;
    CComBSTR bstrFilespec;
    bool bRecursive;
    CComBSTR bstrAlternatePath;
    HRESULT hr;

    CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
    CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
    CHECK_NOFAIL(pFiledesc->GetRecursive(&bRecursive));
    CHECK_NOFAIL(pFiledesc->GetAlternateLocation(&bstrAlternatePath));

    DoExpandEnvironmentStrings(bstrPath);
    DoExpandEnvironmentStrings(bstrAlternatePath);

    CComBSTR bstrSnapshotPath;
    CComBSTR bstrSavedPath;
    if (!BuildSnapshotPath
            (
            saveInfo,
            bstrAlternatePath ? bstrAlternatePath : bstrPath,
            bstrSnapshotPath
            ))
        return;

    BuildSavedPath(bstrPath, bstrSavedPath);
    SaveFilesMatchingFilespec(bstrSnapshotPath, bstrSavedPath, bstrFilespec);
    if (bRecursive)
        RecurseSaveFiles(bstrSnapshotPath, bstrSavedPath, bstrFilespec);
    }



// save data files associated with a component
void SaveComponentFiles
    (
    SAVE_INFO &saveInfo
    )
    {
    HRESULT hr;

    PVSSCOMPONENTINFO pInfo = NULL;
    CComPtr<IVssWMComponent> pComponent;
    CComBSTR bstrComponentLogicalPath;
    CComBSTR bstrComponentName;

    CHECK_NOFAIL(saveInfo.pComponent->GetLogicalPath(&bstrComponentLogicalPath));
    CHECK_SUCCESS(saveInfo.pComponent->GetComponentName(&bstrComponentName));

    // calculate the component's full path
    CComBSTR bstrFullPath = bstrComponentLogicalPath;
    if (bstrFullPath)
        bstrFullPath += L"\\";
    bstrFullPath += bstrComponentName;
    if (!bstrFullPath)
        Error(E_OUTOFMEMORY, L"Ran out of memory");
    
    try
        {
        unsigned cIncludeFiles, cExcludeFiles, cComponents;
        CHECK_SUCCESS(saveInfo.pMetadata->GetFileCounts
                                    (
                                    &cIncludeFiles,
                                    &cExcludeFiles,
                                    &cComponents
                                    ));

        for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
            {
            CHECK_SUCCESS(saveInfo.pMetadata->GetComponent(iComponent, &pComponent));
            CHECK_SUCCESS(pComponent->GetComponentInfo(&pInfo));

            // if the name and logical path match, we want to save the files
            bool bSaveComponent = false;
            bSaveComponent = (wcscmp(pInfo->bstrComponentName, bstrComponentName) == 0) &&
                                                (!bstrComponentLogicalPath && !pInfo->bstrLogicalPath) ||
                                                (bstrComponentLogicalPath && pInfo->bstrLogicalPath &&
                                                wcscmp(bstrComponentLogicalPath, pInfo->bstrLogicalPath) == 0);

            // if this is a subcomponent, we want to save the files
            bSaveComponent = bSaveComponent ||
                                (pInfo->bstrLogicalPath && (wcsstr(pInfo->bstrLogicalPath, bstrFullPath) == pInfo->bstrLogicalPath));
                        
            if (bSaveComponent)
                {
               for(UINT iFile = 0; iFile < pInfo->cFileCount; iFile++)
                   {
                   CComPtr<IVssWMFiledesc> pFiledesc;
                   CHECK_SUCCESS(pComponent->GetFile(iFile, &pFiledesc));
                   SaveDataFiles(saveInfo, pFiledesc);
                   }

               for(iFile = 0; iFile < pInfo->cDatabases; iFile++)
                   {
                   CComPtr<IVssWMFiledesc> pFiledesc;
                   CHECK_SUCCESS(pComponent->GetDatabaseFile(iFile, &pFiledesc));
                   SaveDataFiles(saveInfo, pFiledesc);
                   }

               for(iFile = 0; iFile < pInfo->cLogFiles; iFile++)
                   {
                   CComPtr<IVssWMFiledesc> pFiledesc;
                   CHECK_SUCCESS(pComponent->GetDatabaseLogFile(iFile, &pFiledesc));
                   SaveDataFiles(saveInfo, pFiledesc);
                   }
               }

           pComponent->FreeComponentInfo(pInfo);
           pInfo = NULL;
           pComponent = NULL;
           }
        }
    catch(...)
        {
        pComponent->FreeComponentInfo(pInfo);
        throw;
        }
    }

HANDLE OpenMetadataFile(VSS_ID idInstance, BOOL fWrite)
    {
    // create name of saved metadata file
    CComBSTR bstr;
    CComBSTR bstrId = idInstance;
    bstr.Append(g_wszSavedFilesDirectory);
    bstr.Append(L"WRITER");
    bstr.Append(bstrId);
    bstr.Append(L".xml");

    // create and write metadata file
    HANDLE hFile = CreateFile
                        (
                        bstr,
                        GENERIC_READ|GENERIC_WRITE,
                        0,
                        NULL,
                        fWrite ? CREATE_ALWAYS : OPEN_EXISTING,
                        0,
                        NULL
                        );

    if (hFile == INVALID_HANDLE_VALUE)
        {
        DWORD dwErr = GetLastError();
        Error(HRESULT_FROM_WIN32(dwErr), L"CreateFile failed due to error %d.\n", dwErr);
        }

    return hFile;
    }



void SaveFiles
    (
    IVssBackupComponents *pvbc,
    VSS_ID *rgSnapshotId,
    UINT cSnapshots
    )
    {
    SAVE_INFO saveInfo;
    HRESULT hr;

    unsigned cWriterComponents;
    unsigned cWriters;

    if (g_wszSavedFilesDirectory[0] != L'\0')
        {
        for(UINT iSnapshot = 0; iSnapshot < cSnapshots; iSnapshot++)
            {
            VSS_SNAPSHOT_PROP prop;
            pvbc->GetSnapshotProperties(rgSnapshotId[iSnapshot], &prop);
            CoTaskMemFree(prop.m_pwszOriginatingMachine);
            CoTaskMemFree(prop.m_pwszServiceMachine);
            CoTaskMemFree(prop.m_pwszExposedName);
            CoTaskMemFree(prop.m_pwszExposedPath);
            saveInfo.mapSnapshots.Add(prop.m_pwszOriginalVolumeName, prop.m_pwszSnapshotDeviceObject);
            }
        }

    CHECK_SUCCESS(pvbc->GetWriterComponentsCount(&cWriterComponents));
    CHECK_SUCCESS(pvbc->GetWriterMetadataCount(&cWriters));

    saveInfo.pvbc = pvbc;
    for(unsigned iWriter = 0; iWriter < cWriterComponents; iWriter++)
        {
        CComPtr<IVssWriterComponentsExt> pWriter;
        CComPtr<IVssExamineWriterMetadata> pMetadata = NULL;

        CHECK_SUCCESS(pvbc->GetWriterComponents(iWriter, &pWriter));

        unsigned cComponents;
        CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
        VSS_ID idWriter, idInstance;
        CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));

        if (g_wszSavedFilesDirectory[0] != L'\0')
            {
            for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
                {
                VSS_ID idInstanceMetadata;
                CHECK_SUCCESS(pvbc->GetWriterMetadata(iWriter, &idInstanceMetadata, &pMetadata));
                if (idInstance == idInstanceMetadata)
                    break;

                pMetadata = NULL;
                }

            // save metadata
            CComBSTR bstrMetadata;
            CHECK_SUCCESS(pMetadata->SaveAsXML(&bstrMetadata));

            CVssAutoWin32Handle hFile = OpenMetadataFile(idInstance, true);

            DWORD cbWritten;
            if (!WriteFile(hFile, bstrMetadata, (UINT) wcslen(bstrMetadata)*sizeof(WCHAR), &cbWritten, NULL))
                {
                CloseHandle(hFile);
                DWORD dwErr = GetLastError();
                Error(HRESULT_FROM_WIN32(dwErr), L"WriteFile failed due to error %d.\n", dwErr);
                }

            BS_ASSERT(pMetadata);
            saveInfo.pMetadata = pMetadata;
            }

        for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
            {
            CComPtr<IVssComponent> pComponent;
            CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));

            VSS_COMPONENT_TYPE ct;
            CComBSTR bstrLogicalPath;
            CComBSTR bstrComponentName;

            CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
            CHECK_SUCCESS(pComponent->GetComponentType(&ct));
            CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
            CComBSTR bstrStamp;

            CHECK_NOFAIL(pComponent->GetBackupStamp(&bstrStamp));
            if (bstrStamp)
                wprintf(L"Backup stamp for component %s = %s\n", bstrComponentName, bstrStamp);

            if (g_wszSavedFilesDirectory[0] != L'\0')
                {
                saveInfo.pComponent = pComponent;
                SaveComponentFiles(saveInfo);
                }

            CHECK_SUCCESS
                (
                pvbc->SetBackupSucceeded
                    (
                    idInstance,
                    idWriter,
                    ct,
                    bstrLogicalPath,
                    bstrComponentName,
                    true)
                );
            }
        }
    }

class CRestoreFile
    {
public:
    CRestoreFile(CRestoreFile *pFile)
        {
        m_hDestination = INVALID_HANDLE_VALUE;
        m_pNext = pFile;
        }

    ~CRestoreFile()
        {
        if (m_hDestination != INVALID_HANDLE_VALUE)
            CloseHandle(m_hDestination);
        }

    void SetSourceFile(LPCWSTR wszPath) { m_bstrSourceFile = wszPath; }
    void SetDestinationHandle(HANDLE hFile) { m_hDestination = hFile; }
    void SetDestinationFile(LPCWSTR wszPath) { m_bstrDestinationPath = wszPath; }

    CRestoreFile *m_pNext;
    CComBSTR m_bstrSourceFile;
    CComBSTR m_bstrDestinationPath;
    HANDLE m_hDestination;
    };

typedef struct _ALTERNATE_MAPPING
    {
    CComBSTR bstrPath;
    CComBSTR bstrAlternatePath;
    CComBSTR bstrFilespec;
    bool bRecursive;
    } ALTERNATE_MAPPING;


static const COPYBUFSIZE = 1024 * 1024;

class RESTORE_INFO
    {
public:
    RESTORE_INFO()
        {
        rgMappings = NULL;
        pFile = NULL;
        pCopyBuf = NULL;
        bRebootRequired = false;
        cMappings = 0;
        }


    ~RESTORE_INFO()
        {
        delete [] rgMappings;
        CRestoreFile *pFileT = pFile;
        while(pFileT)
            {
            CRestoreFile *pFileNext = pFileT->m_pNext;
            delete pFileT;
            pFileT = pFileNext;
            }

        delete pCopyBuf;
        }

    VSS_ID idWriter;
    VSS_ID idInstance;
    VSS_COMPONENT_TYPE ct;
    IVssExamineWriterMetadata *pMetadataWriter;
    IVssExamineWriterMetadata *pMetadataSaved;
    IVssBackupComponents *pvbc;
    IVssComponent *pComponent;
    LPCWSTR wszLogicalPath;
    LPCWSTR wszComponentName;
    VSS_RESTOREMETHOD_ENUM method;
    bool bRebootRequired;
    CRestoreFile *pFile;
    unsigned cMappings;
    ALTERNATE_MAPPING *rgMappings;
    BYTE *pCopyBuf;
    };


void CompleteRestore(RESTORE_INFO &info)
    {
    CRestoreFile *pFile = info.pFile;
    while(pFile != NULL)
        {
        if (pFile->m_hDestination != INVALID_HANDLE_VALUE &&
            pFile->m_bstrSourceFile)
            {
            CVssAutoWin32Handle hSource = CreateFile
                                            (
                                            pFile->m_bstrSourceFile,
                                            GENERIC_READ,
                                            FILE_SHARE_READ,
                                            NULL,
                                            OPEN_EXISTING,
                                            0,
                                            NULL
                                            );

             if (hSource == INVALID_HANDLE_VALUE)
                 {
                 DWORD dwErr = GetLastError();
                 Error(HRESULT_FROM_WIN32(dwErr), L"CreateFile failed with error %d.\n", dwErr);
                 }

             DWORD dwSize = GetFileSize(hSource, NULL);
             if (dwSize == 0xffffffff)
                 {
                 DWORD dwErr = GetLastError();
                 Error(HRESULT_FROM_WIN32(dwErr), L"GetFileSize failed with error %d.\n", dwErr);
                 }

             while(dwSize > 0)
                 {
                 DWORD cb = min(COPYBUFSIZE, dwSize);
                 DWORD dwRead, dwWritten;
                 if (!ReadFile(hSource, info.pCopyBuf, cb, &dwRead, NULL))
                     {
                     DWORD dwErr = GetLastError();
                     Error(HRESULT_FROM_WIN32(dwErr), L"ReadFile failed dued to error %d.\n", dwErr);
                     }

                 if (!WriteFile(pFile->m_hDestination, info.pCopyBuf, cb, &dwWritten, NULL) ||
                     dwWritten < cb)
                     {
                     DWORD dwErr = GetLastError();
                     Error(HRESULT_FROM_WIN32(dwErr), L"Write file failed due to error %d.\n", dwErr);
                     }

                 dwSize -= cb;
                 }

             if (!SetEndOfFile(pFile->m_hDestination))
                 {
                 DWORD dwErr = GetLastError();
                 Error(HRESULT_FROM_WIN32(dwErr), L"SetEndOfFile failed due to error %d.\n", dwErr);
                 }
             }

         info.pFile = pFile->m_pNext;
         delete pFile;
         pFile = info.pFile;
         }
     }

void CleanupFailedRestore(RESTORE_INFO &info)
    {
    CRestoreFile *pFile = info.pFile;
    while (pFile != NULL)
        {
        info.pFile = pFile->m_pNext;
        delete pFile;
        pFile = info.pFile;
        }
    }

bool SetupRestoreFile
    (
    RESTORE_INFO &info,
    LPCWSTR wszSavedFile,
    LPCWSTR wszRestoreFile
    )
    {
    CRestoreFile *pFile = new CRestoreFile(info.pFile);

    if (info.method == VSS_RME_RESTORE_TO_ALTERNATE_LOCATION)
        {
        DoCopyFile(wszSavedFile, wszRestoreFile);
        pFile->SetDestinationFile(wszRestoreFile);
        info.pFile = pFile;
        return true;
        }

    // ensure path up to destination file exists
    CComBSTR bstrDestinationPath = wszRestoreFile;
    LPWSTR wsz = wcsrchr(bstrDestinationPath, L'\\');
    *(wsz+1) = L'\0';
    DoCopyFile(NULL, bstrDestinationPath);

    if (info.method == VSS_RME_RESTORE_AT_REBOOT)
        {
        *wsz = L'\0';
        CComBSTR bstrTempFileName((UINT) wcslen(bstrDestinationPath) + MAX_PATH);
        if (!GetTempFileName(bstrDestinationPath, L"TBCK", 0, bstrTempFileName))
            {
            DWORD dwErr = GetLastError();
            Error(HRESULT_FROM_WIN32(dwErr), L"GetTempFileName failed due to error %d.\n", dwErr);
            }

        if (!CopyFile(wszSavedFile, bstrTempFileName, FALSE))
            {
            DWORD dwErr = GetLastError();
            Error(HRESULT_FROM_WIN32(dwErr), L"CopyFile failed due to error %d.\n", dwErr);
            }

        if (!MoveFileEx
            (
            bstrTempFileName,
            wszRestoreFile,
            MOVEFILE_DELAY_UNTIL_REBOOT|MOVEFILE_REPLACE_EXISTING
            ))
            {
            DWORD dwErr = GetLastError();
            Error(HRESULT_FROM_WIN32(dwErr), L"MoveFileEx failed due to error %d.\n", dwErr);
            }

        info.bRebootRequired = true;
        }
    else if (info.method == VSS_RME_RESTORE_IF_NOT_THERE)
        {
        HANDLE hFile = CreateFile
                            (
                            wszRestoreFile,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_NEW,
                            0,
                            NULL
                            );


        // assume if the create fails
        if (hFile == INVALID_HANDLE_VALUE)
            {
            DWORD dwErr = GetLastError();
            if (dwErr == ERROR_FILE_EXISTS)
                return false;
            else
                Error(HRESULT_FROM_WIN32(dwErr), L"CreateFile failed due to error %d.\n", dwErr);
            }

        pFile->SetDestinationHandle(hFile);
        }
    else if (info.method == VSS_RME_RESTORE_IF_CAN_REPLACE)
        {
        HANDLE hFile = CreateFile
                            (
                            wszRestoreFile,
                            GENERIC_WRITE|GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            0,
                            NULL
                            );

        if (hFile == INVALID_HANDLE_VALUE)
            {
            DWORD dwErr = GetLastError();
            if (dwErr == ERROR_SHARING_VIOLATION ||
                dwErr == ERROR_USER_MAPPED_FILE ||
                dwErr == ERROR_LOCK_VIOLATION)
                return false;
            else
                Error(HRESULT_FROM_WIN32(dwErr), L"CreateFile failed due to error %d.\n", dwErr);
            }

        pFile->SetDestinationHandle(hFile);
        pFile->SetSourceFile(wszSavedFile);
        }

    info.pFile = pFile;
    return true;
    }

void TranslateRestorePath
    (
    RESTORE_INFO &info,
    CComBSTR &bstrRP,
    LPCWSTR wszFilename
    )
    {
    ALTERNATE_MAPPING *pMapping = NULL;
    UINT cwc = 0, cwcMapping = 0;

    for(unsigned iMapping = 0; iMapping < info.cMappings; iMapping++)
        {
        pMapping = &info.rgMappings[iMapping];
        cwc = (UINT) wcslen(bstrRP);
        cwcMapping = (UINT) wcslen(pMapping->bstrPath);
        if (cwc < cwcMapping)
            continue;

        if (_wcsnicmp(bstrRP, pMapping->bstrPath, cwcMapping) != 0)
            continue;

        if (cwcMapping != cwc && !pMapping->bRecursive)
            continue;

        BOOL bReplacePath = FALSE;
        LPCWSTR wszFilespec = pMapping->bstrFilespec;
        if (wcscmp(wszFilespec, L"*") == 0 ||
            wcscmp(wszFilespec, L"*.*") == 0)
            bReplacePath = true;
        else if (wcschr(wszFilespec, L'*') == NULL)
            bReplacePath = _wcsicmp(wszFilespec, wszFilename) == 0;
        else if (wcsncmp(wszFilespec, L"*.", 2) == 0)
            {
            LPCWSTR wszSuffix = wcschr(wszFilename, L'.');
            if (wszSuffix == NULL)
                bReplacePath = wcslen(wszFilespec) == 2;
            else
                bReplacePath = _wcsicmp(wszSuffix, wszFilespec + 1) == 0;
            }
        else
            {
            UINT cwcFilespec = (UINT) wcslen(wszFilespec);
            if (cwcFilespec > 2 &&
                _wcsicmp(wszFilespec + cwcFilespec - 2, L".*") == 0)
                {
                if (wcslen(wszFilename) >= cwcFilespec - 1)
                    bReplacePath = _wcsnicmp(wszFilename, wszFilespec, cwcFilespec - 1) == 0;
                }
            }

        if (bReplacePath)
            {
            if (cwcMapping == cwc)
                bstrRP = pMapping->bstrAlternatePath;
            else
                {
                CComBSTR bstr;
                bstr.Append(pMapping->bstrAlternatePath);
                bstr.Append(bstrRP + cwcMapping);
                bstrRP = bstr;
                }

            break;
            }
        }
    }


bool SetupRestoreFilesMatchingFilespec
    (
    RESTORE_INFO &info,
    LPCWSTR wszSourcePath,
    LPCWSTR wszRestorePath,
    LPCWSTR wszFilespec
    )
    {
    CComBSTR bstrSP = wszSourcePath;
    bstrSP.Append(L"\\");
    bstrSP.Append(wszFilespec);
    WIN32_FIND_DATA findData;
    HANDLE hFile = FindFirstFile(bstrSP, &findData);
    if (hFile == INVALID_HANDLE_VALUE)
        return true;

    try
        {
        do
            {
            if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                CComBSTR bstrRP = wszRestorePath;

                bstrSP = wszSourcePath;
                bstrSP.Append(L"\\");
                bstrSP.Append(findData.cFileName);
                if (info.method == VSS_RME_RESTORE_TO_ALTERNATE_LOCATION)
                    TranslateRestorePath(info, bstrRP, findData.cFileName);

                bstrRP.Append(L"\\");
                bstrRP.Append(findData.cFileName);
                if (!SetupRestoreFile(info, bstrSP, bstrRP))
                    return false;
                }
            } while(FindNextFile(hFile, &findData));

        FindClose(hFile);
        }
    catch(...)
        {
        FindClose(hFile);
        throw;
        }

    return true;
    }

bool RecursiveRestoreFiles
    (
    RESTORE_INFO &info,
    LPCWSTR wszSavedPath,
    LPCWSTR wszPath,
    LPCWSTR wszFilespec
    )
    {
    CComBSTR bstrSP = wszSavedPath;
    bstrSP.Append(L"\\*.*");

    WIN32_FIND_DATA findData;
    HANDLE hFile = FindFirstFile(bstrSP, &findData);
    if (hFile == INVALID_HANDLE_VALUE)
        return true;
    try
        {
        do
            {
            if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                if (wcscmp(findData.cFileName, L".") == 0 ||
                    wcscmp(findData.cFileName, L"..") == 0)
                    continue;

                bstrSP = wszSavedPath;
                bstrSP.Append(L"\\");
                bstrSP.Append(findData.cFileName);
                CComBSTR bstrRP = wszPath;
                bstrRP.Append(L"\\");
                bstrRP.Append(findData.cFileName);

                if (!SetupRestoreFilesMatchingFilespec(info, bstrSP, bstrRP, wszFilespec))
                    return false;

                if (!RecursiveRestoreFiles(info, bstrSP, bstrRP, wszFilespec))
                    return false;
                }
            } while(FindNextFile(hFile, &findData));

        FindClose(hFile);
        }
    catch(...)
        {
        FindClose(hFile);
        throw;
        }

    return true;
    }



bool SetupRestoreDataFiles(RESTORE_INFO &info, IVssWMFiledesc *pFiledesc)
    {
    HRESULT hr;
    CComBSTR bstrPath;
    CComBSTR bstrFilespec;
    bool bRecursive;

    CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
    CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
    CHECK_NOFAIL(pFiledesc->GetRecursive(&bRecursive));

    CComBSTR bstrSavedPath;
    BuildSavedPath(bstrPath, bstrSavedPath);
    if (!SetupRestoreFilesMatchingFilespec(info, bstrSavedPath, bstrPath, bstrFilespec))
        return false;

    if (bRecursive)
        return RecursiveRestoreFiles(info, bstrSavedPath, bstrPath, bstrFilespec);

    return true;
    }

bool SetupRestoreDataFilesForComponent(RESTORE_INFO& info, IVssWMComponent* pComponent)
    {
    HRESULT hr = S_OK;
    
    PVSSCOMPONENTINFO pInfo = NULL;
    CHECK_SUCCESS(pComponent->GetComponentInfo(&pInfo));
    
    for(UINT iFile = 0; iFile < pInfo->cFileCount; iFile++)
        {
        CComPtr<IVssWMFiledesc> pFiledesc;
        CHECK_SUCCESS(pComponent->GetFile(iFile, &pFiledesc));
        if (!SetupRestoreDataFiles(info, pFiledesc))
            {
            pComponent->FreeComponentInfo(pInfo);
            return false;
            }
        }

    for(iFile = 0; iFile < pInfo->cDatabases; iFile++)
        {
        CComPtr<IVssWMFiledesc> pFiledesc;
        CHECK_SUCCESS(pComponent->GetDatabaseFile(iFile, &pFiledesc));
        if (!SetupRestoreDataFiles(info, pFiledesc))
            {
            pComponent->FreeComponentInfo(pInfo);
            return false;
            }
        }

    for(iFile = 0; iFile < pInfo->cLogFiles; iFile++)
        {
        CComPtr<IVssWMFiledesc> pFiledesc;
        CHECK_SUCCESS(pComponent->GetDatabaseLogFile(iFile, &pFiledesc));
        if (!SetupRestoreDataFiles(info, pFiledesc))
            {
            pComponent->FreeComponentInfo(pInfo);
            return false;
            }
        }

    pComponent->FreeComponentInfo(pInfo);
    
    return true;
}

void LoadMetadataFile(VSS_ID idInstance, IVssExamineWriterMetadata **ppMetadataSaved)
    {
    HRESULT hr;

    // load saved metadata
    CVssAutoWin32Handle hFile = OpenMetadataFile(idInstance, false);
    DWORD dwSize = GetFileSize(hFile, NULL);
    if (dwSize == 0xffffffff)
        {
        DWORD dwErr = GetLastError();
        Error(HRESULT_FROM_WIN32(dwErr), L"GetFileSize failed with error %d.\n", dwErr);
        }

    CComBSTR bstrXML(dwSize/sizeof(WCHAR));

    DWORD dwRead;
    if(!ReadFile(hFile, bstrXML, dwSize, &dwRead, NULL))
        {
        DWORD dwErr = GetLastError();
        Error(HRESULT_FROM_WIN32(dwErr), L"ReadFile failed with error %d.\n", dwErr);
        }

    // null terminate XML string
    bstrXML[dwSize/sizeof(WCHAR)] = L'\0';

    CHECK_SUCCESS(CreateVssExamineWriterMetadata(bstrXML, ppMetadataSaved));
    }



void RestoreComponentFiles(RESTORE_INFO &info)
    {
    HRESULT hr;
    PVSSCOMPONENTINFO pInfo = NULL;
    CComPtr<IVssWMComponent> pComponent;
    VSS_FILE_RESTORE_STATUS status = VSS_RS_NONE;

    try
        {
        CComBSTR bstrUserProcedure;
        CComBSTR bstrService;
        bool bRebootRequired;
        VSS_WRITERRESTORE_ENUM writerRestore;


        IVssExamineWriterMetadata *pMetadata;
        UINT cIncludeFiles, cExcludeFiles, cComponents;
        CHECK_SUCCESS(info.pMetadataSaved->GetFileCounts(&cIncludeFiles, &cExcludeFiles, &cComponents));
        for (UINT iComponent = 0; iComponent < cComponents; iComponent++)
            {
            CHECK_SUCCESS(info.pMetadataSaved->GetComponent(iComponent, &pComponent));
            CHECK_SUCCESS(pComponent->GetComponentInfo(&pInfo));

            if (wcscmp(pInfo->bstrComponentName, info.wszComponentName) == 0)
                {
                if ((!info.wszLogicalPath && !pInfo->bstrLogicalPath) ||
                    (info.wszLogicalPath && pInfo->bstrLogicalPath &&
                     wcscmp(info.wszLogicalPath, pInfo->bstrLogicalPath) == 0))
                    break;
                }

            pComponent->FreeComponentInfo(pInfo);
            pInfo = NULL;
            pComponent = NULL;
            }

        pMetadata = info.pMetadataSaved;

        BS_ASSERT(pComponent != NULL);



        CHECK_NOFAIL(pMetadata->GetRestoreMethod
                                    (
                                    &info.method,
                                    &bstrService,
                                    &bstrUserProcedure,
                                    &writerRestore,
                                    &bRebootRequired,
                                    &info.cMappings
                                    ));

        // cannot do anything with custom method
        if (info.method == VSS_RME_CUSTOM)
            {
            pComponent->FreeComponentInfo(pInfo);
            return;
            }

        BS_ASSERT(info.method != VSS_RME_STOP_RESTORE_START);
        if (info.rgMappings == NULL)
            {
            if (info.cMappings > 0)
                {
                info.rgMappings = new ALTERNATE_MAPPING[info.cMappings];
                if (info.rgMappings == NULL)
                    Error(E_OUTOFMEMORY, L"OutOfMemory");
                }

            for(unsigned iMapping = 0; iMapping < info.cMappings; iMapping++)
                {
                CComPtr<IVssWMFiledesc> pFiledesc;
                CHECK_SUCCESS(pMetadata->GetAlternateLocationMapping(iMapping, &pFiledesc));
                CHECK_SUCCESS(pFiledesc->GetPath(&info.rgMappings[iMapping].bstrPath));
                DoExpandEnvironmentStrings(info.rgMappings[iMapping].bstrPath);
                CHECK_SUCCESS(pFiledesc->GetAlternateLocation(&info.rgMappings[iMapping].bstrAlternatePath));
                DoExpandEnvironmentStrings(info.rgMappings[iMapping].bstrAlternatePath);
                CHECK_SUCCESS(pFiledesc->GetFilespec(&info.rgMappings[iMapping].bstrFilespec));
                CHECK_SUCCESS(pFiledesc->GetRecursive(&info.rgMappings[iMapping].bRecursive));
                }
            }

        if (info.method == VSS_RME_RESTORE_IF_NOT_THERE ||
            info.method == VSS_RME_RESTORE_IF_CAN_REPLACE)
            {
            if (info.pCopyBuf == NULL)
                {
                info.pCopyBuf = new BYTE[COPYBUFSIZE];
                if (info.pCopyBuf == NULL)
                    Error(E_OUTOFMEMORY, L"Out of Memory");
                }
            }


_retry:
        info.pFile = NULL;
        bool bFailRestore = false;

        // setup restore data files for the current component
        bFailRestore = !SetupRestoreDataFilesForComponent(info, pComponent);

        // setup restore data files for all subcomponents
        UINT cSubcomponents = 0;
        CHECK_SUCCESS(info.pComponent->GetRestoreSubcomponentCount(&cSubcomponents));   
        
        for (UINT iSubcomponent = 0; !bFailRestore && iSubcomponent < cSubcomponents; iSubcomponent++)
            {
            CComBSTR bstrSubLogicalPath, bstrSubName;
            bool foo;
            CHECK_SUCCESS(info.pComponent->GetRestoreSubcomponent(iSubcomponent, &bstrSubLogicalPath, 
                                                                                                            &bstrSubName, &foo));

            CComPtr<IVssWMComponent> pSubcomponent;
            if (!FindComponent(pMetadata, bstrSubLogicalPath, bstrSubName, &pSubcomponent))
                Error(E_UNEXPECTED, L"an invalid subcomponent was selected");

            bFailRestore = !SetupRestoreDataFilesForComponent(info, pSubcomponent);
            }

            // calculate the full path to the current component
            CComBSTR fullPath = info.wszLogicalPath;
            if (fullPath)
                fullPath += L"\\";
            fullPath += info.wszComponentName;
            if (!fullPath)
                Error(E_OUTOFMEMORY, L"Out of memory!");

            // setup restore data files for all subcomponents
            for (UINT iComponent = 0; !cSubcomponents && !bFailRestore && iComponent < cComponents; iComponent++)
                {
                CComPtr<IVssWMComponent> pCurrentComponent;
                PVSSCOMPONENTINFO pCurrentInfo;
                CHECK_SUCCESS(pMetadata->GetComponent(iComponent, &pCurrentComponent));
                CHECK_SUCCESS(pCurrentComponent->GetComponentInfo(&pCurrentInfo));

                if (pCurrentInfo->bstrLogicalPath &&
                     wcsstr(pCurrentInfo->bstrLogicalPath, fullPath) == pCurrentInfo->bstrLogicalPath)
                    {
                    bFailRestore = !SetupRestoreDataFilesForComponent(info, pCurrentComponent);
                    }

                pCurrentComponent->FreeComponentInfo(pCurrentInfo);
                }


        if (!bFailRestore)
            {
            status = VSS_RS_FAILED;
            CompleteRestore(info);
            status = VSS_RS_ALL;
            if (bRebootRequired)
                info.bRebootRequired = true;
            }
        else
            {
            CleanupFailedRestore(info);
            if ((info.method == VSS_RME_RESTORE_IF_NOT_THERE ||
                 info.method == VSS_RME_RESTORE_IF_CAN_REPLACE) &&
                info.cMappings > 0)
                {
                info.method = VSS_RME_RESTORE_TO_ALTERNATE_LOCATION;
                goto _retry;
                }
            }

        pComponent->FreeComponentInfo(pInfo);
        pInfo = NULL;
        pComponent = NULL;
        }
    catch(...)
        {
        pComponent->FreeComponentInfo(pInfo);
        throw;
        }

    CHECK_SUCCESS(info.pvbc->SetFileRestoreStatus
                                (
                                info.idWriter,
                                info.ct,
                                info.wszLogicalPath,
                                info.wszComponentName,
                                status
                                ));

    }


void RestoreFiles(IVssBackupComponents *pvbc, const CSimpleMap<VSS_ID, HRESULT>& failedWriters)
    {
    RESTORE_INFO info;
    HRESULT hr;

    UINT cWriterComponents = 0, cWriters = 0;    
    info.pvbc = pvbc;
    CHECK_SUCCESS(pvbc->GetWriterComponentsCount(&cWriterComponents));
    CHECK_SUCCESS(pvbc->GetWriterMetadataCount(&cWriters));

    info.pvbc = pvbc;
    for(unsigned iWriter = 0; iWriter < cWriterComponents; iWriter++)
        {
        CComPtr<IVssWriterComponentsExt> pWriter;
        CComPtr<IVssExamineWriterMetadata> pMetadata = NULL;
        CComPtr<IVssExamineWriterMetadata> pMetadataSaved = NULL;

        CHECK_SUCCESS(pvbc->GetWriterComponents(iWriter, &pWriter));
            
        unsigned cComponents;
        CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));

        for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
            {
            CComPtr<IVssComponent> pComponent;
            bool bSelectedForRestore = false;
            CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
            CHECK_NOFAIL(pComponent->IsSelectedForRestore(&bSelectedForRestore));
            if (bSelectedForRestore)
                break;

            UINT cSubcomponents = 0;
            CHECK_SUCCESS(pComponent->GetRestoreSubcomponentCount(&cSubcomponents));
            if (cSubcomponents > 0)
                break;
                
            CComBSTR bstrOptions;
            CHECK_NOFAIL(pComponent->GetRestoreOptions(&bstrOptions));
            if (bstrOptions.Length() != 0 && wcscmp(bstrOptions, L"RESTORE") == 0)
                break;
            }

        if (iComponent >= cComponents)
            continue;

        CHECK_SUCCESS(pWriter->GetWriterInfo(&info.idInstance, &info.idWriter));

        for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
            {
            VSS_ID idInstance, idWriter;
            CComBSTR bstrWriterName;
            VSS_USAGE_TYPE usage;
            VSS_SOURCE_TYPE source;

            CHECK_SUCCESS(pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata));
            CHECK_SUCCESS
                (
                pMetadata->GetIdentity
                                (
                                &idInstance,
                                &idWriter,
                                &bstrWriterName,
                                &usage,
                                &source
                                )
                );

            if (idWriter == info.idWriter)
                break;

            pMetadata = NULL;
            }

        // load saved metadata
        LoadMetadataFile(info.idInstance, &pMetadataSaved);

        info.pMetadataWriter = pMetadata;
        info.pMetadataSaved = pMetadataSaved;
        bool bWriterFailed = failedWriters.Lookup(info.idInstance) != NULL;

        for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
            {
            CComPtr<IVssComponent> pComponent;
            CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));

            bool bSelectedForRestore = false;
            CHECK_NOFAIL(pComponent->IsSelectedForRestore(&bSelectedForRestore));

            UINT cSubcomponents = 0;
            CHECK_SUCCESS(pComponent->GetRestoreSubcomponentCount(&cSubcomponents));

            
            if (!bSelectedForRestore && cSubcomponents == 0)
                {
                // BUGBUG: huge hack to fix the AD case.   We eventually need to 
                // BUGBUG: do something better here
                CComBSTR bstrOptions;
                CHECK_NOFAIL(pComponent->GetRestoreOptions(&bstrOptions));
                if (bstrOptions.Length() == 0 || wcscmp(bstrOptions, L"RESTORE") != 0)
                    continue;
                }

            CComBSTR bstrLogicalPath;
            CComBSTR bstrComponentName;

            CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
            CHECK_SUCCESS(pComponent->GetComponentType(&info.ct));
            CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));

            CComBSTR bstrPreRestoreFailure;
            CHECK_NOFAIL(pComponent->GetPreRestoreFailureMsg(&bstrPreRestoreFailure));
            if (bstrPreRestoreFailure)
                {
                wprintf
                    (
                    L"Not restoring Component %s\\%s because PreRestore failed:\n%s\n",
                    bstrLogicalPath,
                    bstrComponentName,
                    bstrPreRestoreFailure
                    );

                continue;
                }
            else if (bWriterFailed)
                {
                wprintf
                    (
                    L"Not restoring Component %s\\%s because PreRestore failed:\n\n",
                    bstrLogicalPath,
                    bstrComponentName
                    );

                continue;
                }

            info.pComponent = pComponent;
            info.wszLogicalPath = bstrLogicalPath;
            info.wszComponentName = bstrComponentName;
            RestoreComponentFiles(info);
            }

        // mappings are on a per writer basis and need to be cleared
        // when advancing to a new writer
        delete [] info.rgMappings;
        info.rgMappings = NULL;
        info.cMappings = 0;
        }


    if (info.bRebootRequired)
        wprintf(L"\n\n!!REBOOT is Required to complete the restore operation.\n\n");
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\betest\snapxml.cxx ===
#include "stdafx.hxx"
#include "vss.h"
#include "vswriter.h"
#include "vsbackup.h"
#include <debug.h>
#include <time.h>
#include <ntddstor.h>

#include <vs_inc.hxx>
#include <vsevent.h>
#include <vdslun.h>
#include <vscoordint.h>
#include <vs_wmxml.hxx>
#include <vs_cmxml.hxx>
#include <vs_trace.hxx>




static VSS_ID x_idSnapSet =
	{
	0xD79FE5AD, 0x767F, 0x4251,
	0xA9, 0x7A, 0x37, 0x37, 0xd0, 0xf9, 0xf7, 0x4f
	};



static VSS_ID x_idSnap1 =
	{
    0x78B049FB, 0x9D12, 0x40A6,
	0x82, 0x6C, 0xED, 0x8A, 0x80, 0x4E, 0xB4, 0xAA
	};

static VSS_ID x_idSnap2 =
	{
	0xE700B0EC, 0xA993, 0x4B1B,
	0xAD, 0xDA, 0xC2, 0xAA, 0x08, 0x53, 0x6F, 0x27
	};

static VSS_ID x_idProv =
	{
	0x587E6660, 0x3FEF, 0x45D6,
	0x8D, 0x91, 0xB1, 0x2E, 0x16, 0xAC, 0x5C, 0x18
	};

void GetAndValidateSnapshots
	(
	IN IVssSnapshotSetDescription *pSnapshotSet,
	OUT IVssSnapshotDescription **ppSnapshot1,
	OUT IVssSnapshotDescription **ppSnapshot2,
	OUT VSS_ID &idSnap1,
	OUT VSS_ID &idSnap2
	)
	{
	HRESULT hr;

	UINT cSnapshots;
	CHECK_SUCCESS(pSnapshotSet->GetSnapshotCount(&cSnapshots));
	if (cSnapshots != 2)
		{
		wprintf(L"Number of snapshots %d is not correct.\n");
		BS_ASSERT(FALSE);
		throw(E_UNEXPECTED);
		}

	VSS_ID idProv;
	CHECK_SUCCESS(pSnapshotSet->GetSnapshotDescription(0, ppSnapshot1));
	CHECK_SUCCESS(pSnapshotSet->GetSnapshotDescription(1, ppSnapshot2));
	CHECK_SUCCESS((*ppSnapshot1)->GetSnapshotId(&idSnap1));
	CHECK_SUCCESS((*ppSnapshot2)->GetSnapshotId(&idSnap2));
	if ((idSnap1 != x_idSnap1 || idSnap2 != x_idSnap2) &&
		(idSnap1 != x_idSnap2 || idSnap2 != x_idSnap1))
		Error(E_UNEXPECTED,
			  L"Snapshots were not added properly.  Added snapshots are:\n"
			  WSTR_GUID_FMT L" and " WSTR_GUID_FMT
			  L"\nFound snapshots are" WSTR_GUID_FMT L" and "
			  WSTR_GUID_FMT L"\n",
			  GUID_PRINTF_ARG(x_idSnap1),
			  GUID_PRINTF_ARG(x_idSnap2),
			  GUID_PRINTF_ARG(idSnap1),
			  GUID_PRINTF_ARG(idSnap2));


	CHECK_SUCCESS((*ppSnapshot1)->GetProviderId(&idProv));
	if (idProv != x_idProv)
		Error(E_UNEXPECTED,
			  L"Provider id was not correct.\n"
			  WSTR_GUID_FMT L" != " WSTR_GUID_FMT L".\n",
			  GUID_PRINTF_ARG(idProv),
			  GUID_PRINTF_ARG(x_idProv));


	CHECK_SUCCESS((*ppSnapshot2)->GetProviderId(&idProv));
	if (idProv != x_idProv)
		Error(E_UNEXPECTED,
			  L"Provider id was not correct.\n"
			  WSTR_GUID_FMT L" != " WSTR_GUID_FMT L".\n",
			  GUID_PRINTF_ARG(idProv),
			  GUID_PRINTF_ARG(x_idProv));

	}


void ValidateSnapshotSet(IVssSnapshotSetDescription *pSnapshotSet)
	{
	HRESULT hr;
	VSS_ID idSnapSet;

	CHECK_SUCCESS(pSnapshotSet->GetSnapshotSetId(&idSnapSet));
	if (idSnapSet != x_idSnapSet)
		Error(E_UNEXPECTED, L"snapshot set id does not match: "
			  WSTR_GUID_FMT L" != " WSTR_GUID_FMT,
			  GUID_PRINTF_ARG(idSnapSet),
			  GUID_PRINTF_ARG(x_idSnapSet));


	CComBSTR bstrDescription;
	CComBSTR bstrMetadata;
	CHECK_SUCCESS(pSnapshotSet->GetDescription(&bstrDescription));
	if (wcscmp(bstrDescription, L"This is a test snapshot set") != 0)
		Error(E_UNEXPECTED, L"Snapshot description is invalid:\n%s", bstrDescription);

	CHECK_SUCCESS(pSnapshotSet->GetMetadata(&bstrMetadata));
	if (wcscmp(bstrMetadata, L"This is some test metadata for the snapshot set.") != 0)
		Error(E_UNEXPECTED, L"Snapshot metadata is invalid:\n%s", bstrMetadata);

	LONG lContext;
	CHECK_SUCCESS(pSnapshotSet->GetContext(&lContext));
	if (lContext != VSS_CTX_BACKUP)
		Error(E_UNEXPECTED, L"Context is invalid. lContext=%d\n", lContext);
	}

VSS_SNAPSHOT_PROP rgSnapshotProp[2];

static UCHAR x_DeviceType1 = 1;
static UCHAR x_DeviceType2 = 2;

static UCHAR x_DeviceTypeModifier1 = 100;
static UCHAR x_DeviceTypeModifier2 = 200;

static ULONGLONG x_rgDiskExtents1[] = {10L, 2000L, 4000L, 1000L};
static UINT x_cDiskExtents1 = 2;

static ULONGLONG x_rgDiskExtents2[] = {100L, 1000L, 2000L, 10000L, 100000L, 4000L};
static UINT x_cDiskExtents2 = 3;

static LPCSTR x_szVendorId1 = "MICROSOFT";
static LPCSTR x_szVendorId2 = "PLATFORMS";

static LPCSTR x_szProductId1 = "LVM";
static LPCSTR x_szProductId2 = "VDS";

static LPCSTR x_szProductRevision1 = "1.0";
static LPCSTR x_szProductRevision2 = "2.1";

static LPCSTR x_szSerialNumber1S = "123987";
static LPCSTR x_szSerialNumber1D = "343434";

static LPCSTR x_szSerialNumber2S = "999999-1111";
static LPCSTR x_szSerialNumber2D = "888888-2222";


static VDS_STORAGE_BUS_TYPE x_busType1 = VDSBusTypeScsi;
static VDS_STORAGE_BUS_TYPE x_busType2 = VDSBusTypeFibre;



static VSS_ID x_idDiskSignature1 =
	{
    0xF1CFF9EC, 0xB0A3, 0x408C,
	0xB5, 0xC9, 0x0C, 0x98, 0xDF, 0xFD, 0xDA, 0xED
	};

static VSS_ID x_idDiskSignature2 =
	{
    0xB33FF922, 0xB0A3, 0x408C,
	0xB5, 0xC9, 0x0C, 0x98, 0xDF, 0xFD, 0xDA, 0xED
	};

static VDS_INTERCONNECT_ADDRESS_TYPE x_rgIAType1S[] = {VDS_IA_FCFS, VDS_IA_FCFS, VDS_IA_FCFS};
static LPCSTR x_rgszAddresses1S[] = {"CAB1.BUS10.SLOT10", "CAB1.BUS20.SLOT30", "CAB20.BUS3.SLOT100"};
static UINT x_cInterconnectAddresses1S = 3;

static VDS_INTERCONNECT_ADDRESS_TYPE x_rgIAType1D[] = {VDS_IA_FCFS, VDS_IA_FCFS, VDS_IA_FCFS};
static LPCSTR x_rgszAddresses1D[] = {"CAB1.BUS1.SLOT10", "CAB1.BUS2.SLOT30", "CAB2.BUS3.SLOT10"};
static UINT x_cInterconnectAddresses1D = 3;


static VDS_INTERCONNECT_ADDRESS_TYPE rgIAType2S[] = {VDS_IA_FCPH};
static LPCSTR x_rgszAddresses2S[] = {"10.1.1.4.BUS1.SLOT10"};
static UINT x_cInterconnectAddresses2S = 1;

static VDS_INTERCONNECT_ADDRESS_TYPE rgIAType2D[] = {VDS_IA_FCPH};
static LPCSTR x_rgszAddresses2D[] = {"100.2.3.8.BUS11.SLOT10"};
static UINT x_cInterconnectAddresses2D = 1;

static STORAGE_IDENTIFIER x_storeid1 = {StorageIdCodeSetBinary, StorageIdTypeVendorId, 8, 0, StorageIdAssocDevice, 0};
static STORAGE_IDENTIFIER x_storeid2 = {StorageIdCodeSetBinary, StorageIdTypeVendorSpecific, 20, 0, StorageIdAssocDevice, 0};
static STORAGE_IDENTIFIER x_storeid3 = {StorageIdCodeSetAscii, StorageIdTypeFCPHName, 32, 0, StorageIdAssocDevice, 0};
static STORAGE_IDENTIFIER x_storeid4 = {StorageIdCodeSetBinary, StorageIdTypeEUI64, 8, 0, StorageIdAssocDevice, 0};

void AddIdentifier(BYTE **ppb, STORAGE_IDENTIFIER *pid, UINT &ib)
	{
	if (pid)
		{
		UINT cb = pid->IdentifierSize + FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);

		memcpy(*ppb, pid, FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier));
		ib += cb;
		((STORAGE_IDENTIFIER *) (*ppb))->NextOffset = (USHORT) ib;
		memset(*ppb + FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier), 0x10, pid->IdentifierSize);
		*ppb += cb;
		}
	}

void BuildStorageIdDescriptor
	(
	STORAGE_DEVICE_ID_DESCRIPTOR **ppstore,
	STORAGE_IDENTIFIER *pid1,
	STORAGE_IDENTIFIER *pid2,
	STORAGE_IDENTIFIER *pid3,
	STORAGE_IDENTIFIER *pid4
	)
	{
	UINT cid = 0;
	UINT cb = FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR, Identifiers);
	if (pid1)
		{
		cid++;
		cb += pid1->IdentifierSize + FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);
		}

	if (pid2)
		{
		cid++;
		cb += pid2->IdentifierSize + FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);
		}

	if (pid3)
		{
		cid++;
		cb += pid3->IdentifierSize + FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);
		}

	if (pid4)
		{
		cid++;
		cb += pid4->IdentifierSize + FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);
		}

	BYTE *pb = new BYTE[cb];
	STORAGE_DEVICE_ID_DESCRIPTOR *pstore = (STORAGE_DEVICE_ID_DESCRIPTOR *) pb;
	pstore->Version = 10;
	pstore->Size = cb;
	pstore->NumberOfIdentifiers = cid;
	pb = pstore->Identifiers;
	UINT ib = FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR, Identifiers);

	AddIdentifier(&pb, pid1, ib);
	AddIdentifier(&pb, pid2, ib);
	AddIdentifier(&pb, pid3, ib);
	AddIdentifier(&pb, pid4, ib);

	BS_ASSERT(ib == cb);
	*ppstore = pstore;
	}

typedef struct _BETEST_LUN_INFO
	{
	UCHAR DeviceType;
	UCHAR DeviceTypeModifier;
	ULONGLONG *rgDiskExtents;
	UINT cDiskExtents;
	LPCSTR szVendorId;
	LPCSTR szProductId;
	LPCSTR szProductRevision;
	LPCSTR szSerialNumberSource;
	LPCSTR szSerialNumberDest;
	VDS_STORAGE_BUS_TYPE busType;
	VSS_ID idDiskSignature;
	VDS_INTERCONNECT_ADDRESS_TYPE *rgiatypeS;
	VDS_INTERCONNECT_ADDRESS_TYPE *rgiatypeD;
	LPCSTR	*rgszIAS;
	LPCSTR *rgszIAD;
	UINT cIAS;
	UINT cIAD;
	STORAGE_DEVICE_ID_DESCRIPTOR *pstoreS;
	STORAGE_DEVICE_ID_DESCRIPTOR *pstoreD;
	} BETEST_LUN_INFO;


void BuildLunInfo (UINT i, BETEST_LUN_INFO &info)
	{
	if (i == 1)
		{
		info.DeviceType = x_DeviceType1;
		info.DeviceTypeModifier = x_DeviceTypeModifier1;
		info.rgDiskExtents = x_rgDiskExtents1;
		info.cDiskExtents = x_cDiskExtents1;
		info.szVendorId = x_szVendorId1;
		info.szProductId = x_szProductId1;
		info.szProductRevision = x_szProductRevision1;
		info.szSerialNumberSource = x_szSerialNumber1S;
		info.szSerialNumberDest = x_szSerialNumber1D;
		info.busType = x_busType1;
		info.idDiskSignature = x_idDiskSignature1;
		info.rgiatypeS = x_rgIAType1S;
		info.rgiatypeD = x_rgIAType1D;
		info.rgszIAS = x_rgszAddresses1S;
		info.rgszIAD = x_rgszAddresses1D;
		info.cIAS = x_cInterconnectAddresses1S;
		info.cIAD = x_cInterconnectAddresses1D;
		BuildStorageIdDescriptor(&info.pstoreS, &x_storeid1, &x_storeid3, NULL, NULL);
		BuildStorageIdDescriptor(&info.pstoreD, &x_storeid1, &x_storeid3, &x_storeid4, NULL);
		}
	else
		{
		info.DeviceType = x_DeviceType2;
		info.DeviceTypeModifier = x_DeviceTypeModifier2;
		info.rgDiskExtents = x_rgDiskExtents2;
		info.cDiskExtents = x_cDiskExtents2;
		info.szVendorId = x_szVendorId2;
		info.szProductId = x_szProductId2;
		info.szProductRevision = x_szProductRevision2;
		info.szSerialNumberSource = x_szSerialNumber2S;
		info.szSerialNumberDest = x_szSerialNumber2D;
		info.busType = x_busType2;
		info.idDiskSignature = x_idDiskSignature2;
		info.rgiatypeS = rgIAType2S;
		info.rgiatypeD = rgIAType2D;
		info.rgszIAS = x_rgszAddresses2S;
		info.rgszIAD = x_rgszAddresses2D;
		info.cIAS = x_cInterconnectAddresses2S;
		info.cIAD = x_cInterconnectAddresses2D;
		BuildStorageIdDescriptor(&info.pstoreS, &x_storeid1, &x_storeid2, NULL, NULL);
		BuildStorageIdDescriptor(&info.pstoreD, &x_storeid1, &x_storeid2, &x_storeid3, &x_storeid4);
		}
	}


void AddLunInfo(IVssLunMapping *pLunMapping, UINT i)
	{
	HRESULT hr;

	CComPtr<IVssLunInformation> pSourceLun;
	CComPtr<IVssLunInformation> pDestLun;
	BETEST_LUN_INFO info;

	BuildLunInfo(i, info);

	CHECK_SUCCESS(pLunMapping->GetSourceLun(&pSourceLun));
	CHECK_SUCCESS(pLunMapping->GetDestinationLun(&pDestLun));

	CHECK_SUCCESS(pSourceLun->SetLunBasicType
					  (
					  info.DeviceType,
					  info.DeviceTypeModifier,
					  true,
					  info.szVendorId,
					  info.szProductId,
					  info.szProductRevision,
					  info.szSerialNumberSource,
					  info.busType
					  ));

	CHECK_SUCCESS(pDestLun->SetLunBasicType
					  (
					  info.DeviceType,
					  info.DeviceTypeModifier,
					  true,
					  info.szVendorId,
					  info.szProductId,
					  info.szProductRevision,
					  info.szSerialNumberDest,
					  info.busType
					  ));

	CHECK_SUCCESS(pSourceLun->SetDiskSignature(info.idDiskSignature));
	CHECK_SUCCESS(pDestLun->SetDiskSignature(info.idDiskSignature));
	for(UINT iExtent = 0; iExtent < info.cDiskExtents; iExtent++)
		CHECK_SUCCESS(pLunMapping->AddDiskExtent
						(
						info.rgDiskExtents[iExtent * 2],
						info.rgDiskExtents[iExtent * 2 + 1]
						));

	for(UINT iIAS = 0; iIAS < info.cIAS; iIAS++)
		CHECK_SUCCESS(pSourceLun->AddInterconnectAddress
							(
							info.rgiatypeS[iIAS],
							0,
							NULL,
							(UINT) (strlen(info.rgszIAS[iIAS]) + 1),
							(const BYTE *) info.rgszIAS[iIAS]
							));

	for(UINT iIAD = 0; iIAD < info.cIAD; iIAD++)
		CHECK_SUCCESS(pDestLun->AddInterconnectAddress
							(
							info.rgiatypeD[iIAD],
							3,
							(BYTE *) "foo",
							(UINT) (strlen(info.rgszIAD[iIAD]) + 1),
							(const BYTE *) info.rgszIAD[iIAD]
							));

	CHECK_SUCCESS(pSourceLun->SetStorageDeviceIdDescriptor(info.pstoreS));
	CHECK_SUCCESS(pDestLun->SetStorageDeviceIdDescriptor(info.pstoreD));
    }

bool cmp_str_eq(LPCSTR sz1, LPCSTR sz2)
	{
	return (sz1 == NULL && sz2 == NULL) ||
	       (sz1 != NULL && sz2 != NULL && strcmp(sz1, sz2) == 0);
	}

void DoCoTaskFree
	(
	LPSTR &str1,
	LPSTR &str2,
	LPSTR &str3,
	LPSTR &str4
	)
	{
	if (str1)
		{
		CoTaskMemFree(str1);
		str1 = NULL;
		}

	if (str2)
		{
		CoTaskMemFree(str2);
		str2 = NULL;
		}

	if (str3)
		{
		CoTaskMemFree(str3);
		str3 = NULL;
		}

	if (str4)
		{
		CoTaskMemFree(str4);
		str4 = NULL;
		}
	}

void ValidateLunInfo(IVssLunMapping *pLunMapping, UINT i)
	{
	HRESULT hr;

	CComPtr<IVssLunInformation> pSourceLun;
	CComPtr<IVssLunInformation> pDestLun;
	BETEST_LUN_INFO info;

	BuildLunInfo(i, info);

	CHECK_SUCCESS(pLunMapping->GetSourceLun(&pSourceLun));
	CHECK_SUCCESS(pLunMapping->GetDestinationLun(&pDestLun));

	UINT cExtents;
	CHECK_SUCCESS(pLunMapping->GetDiskExtentCount(&cExtents));
	if (cExtents != info.cDiskExtents)
		Error(E_UNEXPECTED, L"Invalid number of extents for lun %d", i);

	for(UINT iExtent = 0; iExtent < cExtents; iExtent++)
		{
		ULONGLONG start, length;
		CHECK_SUCCESS(pLunMapping->GetDiskExtent(iExtent, &start, &length));
		if (start != info.rgDiskExtents[iExtent * 2] ||
			length != info.rgDiskExtents[iExtent * 2 + 1])
			Error(E_UNEXPECTED, L"Invalid extent %d for lun %d", iExtent, i);
		}

	LPSTR strVendorId;
	LPSTR strProductId;
	LPSTR strProductRevision;
	LPSTR strSerialNumber;
	VDS_STORAGE_BUS_TYPE busTypeFound;
	UCHAR DeviceTypeFound;
	UCHAR DeviceTypeModifierFound;
	BOOL bCommandQueueing;

	CHECK_SUCCESS(pSourceLun->GetLunBasicType
					  (
					  &DeviceTypeFound,
					  &DeviceTypeModifierFound,
					  &bCommandQueueing,
					  &strVendorId,
					  &strProductId,
					  &strProductRevision,
					  &strSerialNumber,
					  &busTypeFound
					  ));

    if (DeviceTypeFound != info.DeviceType ||
		DeviceTypeModifierFound != info.DeviceTypeModifier ||
		busTypeFound != info.busType ||
		!bCommandQueueing ||
		!cmp_str_eq(strVendorId, info.szVendorId) ||
		!cmp_str_eq(strProductId, info.szProductId) ||
		!cmp_str_eq(strProductRevision, info.szProductRevision) ||
		!cmp_str_eq(strSerialNumber, info.szSerialNumberSource))
		{
		DoCoTaskFree(strVendorId, strProductId, strProductRevision, strSerialNumber);
		Error(E_UNEXPECTED, L"Problem in basic LUN information for source %d.\n", i);
		}

	DoCoTaskFree(strVendorId, strProductId, strProductRevision, strSerialNumber);

	CHECK_SUCCESS(pDestLun->GetLunBasicType
					  (
					  &DeviceTypeFound,
					  &DeviceTypeModifierFound,
					  &bCommandQueueing,
					  &strVendorId,
					  &strProductId,
					  &strProductRevision,
					  &strSerialNumber,
					  &busTypeFound
					  ));

    if (DeviceTypeFound != info.DeviceType ||
		DeviceTypeModifierFound != info.DeviceTypeModifier ||
		busTypeFound != info.busType ||
		!cmp_str_eq(strVendorId, info.szVendorId) ||
		!cmp_str_eq(strProductId, info.szProductId)  ||
		!cmp_str_eq(strProductRevision, info.szProductRevision) ||
		!cmp_str_eq(strSerialNumber, info.szSerialNumberDest))
		{
		DoCoTaskFree(strVendorId, strProductId, strProductRevision, strSerialNumber);
		Error(E_UNEXPECTED, L"Problem in basic LUN information four destination %d.\n", i);
		}

	DoCoTaskFree(strVendorId, strProductId, strProductRevision, strSerialNumber);

	VSS_ID idDiskSignatureFound;

	CHECK_SUCCESS(pSourceLun->GetDiskSignature(&idDiskSignatureFound));
	if (info.idDiskSignature != idDiskSignatureFound)
		Error(E_UNEXPECTED, L"Disk signatures do not match for source %d.\n", i);

	CHECK_SUCCESS(pDestLun->GetDiskSignature(&idDiskSignatureFound));
	if (info.idDiskSignature != idDiskSignatureFound)
		Error(E_UNEXPECTED, L"Disk signatures do not match for destination %d.\n", i);

	UINT cia;

	CHECK_SUCCESS(pSourceLun->GetInterconnectAddressCount(&cia));
	if (cia != info.cIAS)
		Error(E_UNEXPECTED, L"Interconnect address count does not match for source %d", i);

	CHECK_SUCCESS(pDestLun->GetInterconnectAddressCount(&cia));
	if (cia != info.cIAD)
		Error(E_UNEXPECTED, L"Interconnect address count does not match for source %d", i);

	for(UINT iIAS = 0; iIAS < info.cIAS; iIAS++)
		{
		VDS_INTERCONNECT_ADDRESS_TYPE iat;
		LPBYTE pbAddress, pbPort;
		ULONG cbAddress, cbPort;

		CHECK_SUCCESS(pSourceLun->GetInterconnectAddress
						(
						iIAS,
						&iat,
						&cbPort,
						&pbPort,
						&cbAddress,
						&pbAddress
						));
		if (iat != info.rgiatypeS[iIAS] ||
			cbPort != 0 ||
			pbPort != NULL ||
			cbAddress != strlen(info.rgszIAS[iIAS]) + 1 ||
			strcmp((char *) pbAddress, info.rgszIAS[iIAS]) != 0)
			{
			CoTaskMemFree(pbAddress);
			Error(E_UNEXPECTED, L"Interconnect address %d does not match for source %d", iIAS, i);
			}

		if (pbAddress)
			CoTaskMemFree(pbAddress);

		if (pbPort)
			CoTaskMemFree(pbPort);
		}

	for(UINT iIAD = 0; iIAD < info.cIAD; iIAD++)
		{
		VDS_INTERCONNECT_ADDRESS_TYPE iat;
		LPBYTE pbAddress, pbPort;
		ULONG cbAddress, cbPort;

		CHECK_SUCCESS(pDestLun->GetInterconnectAddress
						(
						iIAD,
						&iat,
						&cbPort,
						&pbPort,
						&cbAddress,
						&pbAddress
						));
		if (iat != info.rgiatypeD[iIAD] ||
			cbPort != 3 ||
			memcmp(pbPort, "foo", 3) != 0  ||
			cbAddress != strlen(info.rgszIAD[iIAD]) + 1 ||
			strcmp((char *) pbAddress, info.rgszIAD[iIAD]) != 0)
			{
			CoTaskMemFree(pbAddress);
			CoTaskMemFree(pbPort);
			Error(E_UNEXPECTED, L"Interconnect address %d does not match for destination %d", iIAS, i);
			}

		if (pbPort)
			CoTaskMemFree(pbPort);

		if (pbAddress)
			CoTaskMemFree(pbAddress);
		}


	STORAGE_DEVICE_ID_DESCRIPTOR *pstoreFound;

	CHECK_SUCCESS(pSourceLun->GetStorageDeviceIdDescriptor(&pstoreFound));
	if (memcmp(pstoreFound, info.pstoreS, info.pstoreS->Size) != 0)
		{
		CoTaskMemFree(pstoreFound);
		Error(E_UNEXPECTED, L"Storage device descriptor does not match for source %d", i);
		}

	CoTaskMemFree(pstoreFound);

	CHECK_SUCCESS(pDestLun->GetStorageDeviceIdDescriptor(&pstoreFound));
	if (memcmp(pstoreFound, info.pstoreD, info.pstoreD->Size) != 0)
		{
		CoTaskMemFree(pstoreFound);
		Error(E_UNEXPECTED, L"Storage device descriptor does not match for destination %d", i);
		}

	CoTaskMemFree(pstoreFound);
	}		



void AddLunMappings(IVssSnapshotDescription *pSnapshot)
	{
	HRESULT hr;

	CComPtr<IVssLunMapping> pLunMapping1;
	CComPtr<IVssLunMapping> pLunMapping2;


	CHECK_SUCCESS(pSnapshot->AddLunMapping());
	CHECK_SUCCESS(pSnapshot->AddLunMapping());
	CHECK_SUCCESS(pSnapshot->GetLunMapping(0, &pLunMapping1));
	CHECK_SUCCESS(pSnapshot->GetLunMapping(1, &pLunMapping2));
	AddLunInfo(pLunMapping1, 1);
	AddLunInfo(pLunMapping2, 2);
	}

void ValidateLunMappings(IVssSnapshotDescription *pSnapshot)
	{
	HRESULT hr;

	CComPtr<IVssLunMapping> pLunMapping1;
	CComPtr<IVssLunMapping> pLunMapping2;
	UINT cMappings;

	CHECK_SUCCESS(pSnapshot->GetLunCount(&cMappings));
	if (cMappings != 2)
		Error(E_UNEXPECTED, L"Lun mapping count is incorrect");

	CHECK_SUCCESS(pSnapshot->GetLunMapping(0, &pLunMapping1));
	CHECK_SUCCESS(pSnapshot->GetLunMapping(1, &pLunMapping2));
	ValidateLunInfo(pLunMapping1, 1);
	ValidateLunInfo(pLunMapping2, 2);
	}


void ValidateSnapshot(IVssSnapshotDescription *pSnapshot, UINT iSnapshot)
	{
	HRESULT hr;

	VSS_SNAPSHOT_PROP *pProp = &rgSnapshotProp[iSnapshot];

	VSS_TIMESTAMP timestamp;
	LONG lAttributes;
	CComBSTR bstrOriginatingMachine;
	CComBSTR bstrServiceMachine;
	CComBSTR bstrOriginalVolumeName;
	CComBSTR bstrSnapshotDevice;

	CHECK_SUCCESS(pSnapshot->GetTimestamp(&timestamp));
	if (timestamp != pProp->m_tsCreationTimestamp)
		Error(E_UNEXPECTED, L"Timestamp mismatch on snapshot %d", iSnapshot);

	CHECK_SUCCESS(pSnapshot->GetAttributes(&lAttributes))
	if (lAttributes != pProp->m_lSnapshotAttributes)
		Error(E_UNEXPECTED, L"Attributes mismatch on snapshot %d", iSnapshot);

	CHECK_SUCCESS(pSnapshot->GetOrigin
						(
						&bstrOriginatingMachine,
						&bstrOriginalVolumeName
						));

	CHECK_SUCCESS(pSnapshot->GetServiceMachine
						(
						&bstrServiceMachine
						));

    if (wcscmp(bstrOriginatingMachine, pProp->m_pwszOriginatingMachine) != 0)
		Error(E_UNEXPECTED, L"Originating machine mismatch on snapshot %d.", iSnapshot);

	if (wcscmp(bstrOriginalVolumeName, pProp->m_pwszOriginalVolumeName) != 0)
		Error(E_UNEXPECTED, L"Original volume name mismatch on snapshot %d.", iSnapshot);

    if (wcscmp(bstrServiceMachine, pProp->m_pwszServiceMachine) != 0)
		Error(E_UNEXPECTED, L"Service machine mismatch on snapshot %d.", iSnapshot);

	CHECK_SUCCESS(pSnapshot->GetDeviceName(&bstrSnapshotDevice));
	if (wcscmp(bstrSnapshotDevice, pProp->m_pwszSnapshotDeviceObject) != 0)
		Error(E_UNEXPECTED, L"Snapshot device name mismatch on snapshot %d.", iSnapshot);

	if (iSnapshot == 2)
		{
		CComBSTR bstrExposedShare;
		CComBSTR bstrExposedPath;
		CHECK_SUCCESS(pSnapshot->GetExposure(&bstrExposedShare, &bstrExposedPath));

		if (wcscmp(bstrExposedShare, L"exposed1") != 0)
			Error(E_UNEXPECTED, L"Exposed share mismatch on snapshot %d.", iSnapshot);

		if (wcscmp(bstrExposedPath, L"thePath") != 0)
			Error(E_UNEXPECTED, L"Exposed path mismatch on snapshot %d.", iSnapshot);
		}

	ValidateLunMappings(pSnapshot);
	}

void AddSnapshotData(IVssSnapshotDescription *pSnapshot, UINT iSnapshot)
	{
	HRESULT hr;

	SYSTEMTIME time;

	VSS_SNAPSHOT_PROP *pProp = &rgSnapshotProp[iSnapshot];
	GetSystemTime(&time);
	LONGLONG timestamp;

	timestamp = time.wYear * 400 + time.wMonth * 31 + time.wDay;
	timestamp *= 3600000 * 24;
	timestamp += time.wMilliseconds + time.wSecond * 1000 + time.wMinute*60000+ time.wHour * 3600000;
	pProp->m_tsCreationTimestamp = timestamp;
	pProp->m_pwszSnapshotDeviceObject = iSnapshot == 1 ? L"Snapshot1" : L"Snapshot2";
	pProp->m_pwszOriginalVolumeName = iSnapshot == 1 ? L"Disk1" : L"Disk2";
	pProp->m_lSnapshotAttributes = VSS_CTX_BACKUP;
	WCHAR buf[1024];
	DWORD cb = 1024;
	GetComputerNameEx(ComputerNameDnsFullyQualified, buf, &cb);
	pProp->m_pwszOriginatingMachine = _wcsdup(buf);
    pProp->m_pwszServiceMachine = _wcsdup(buf);
	CHECK_SUCCESS(pSnapshot->SetTimestamp(pProp->m_tsCreationTimestamp));
	CHECK_SUCCESS(pSnapshot->SetAttributes(pProp->m_lSnapshotAttributes));
	CHECK_SUCCESS(pSnapshot->SetOrigin
						(
						pProp->m_pwszOriginatingMachine,
						pProp->m_pwszOriginalVolumeName
						));
	CHECK_SUCCESS(pSnapshot->SetServiceMachine
						(
						pProp->m_pwszServiceMachine
						));

	CHECK_SUCCESS(pSnapshot->SetDeviceName(pProp->m_pwszSnapshotDeviceObject));
	if (iSnapshot == 2)
		CHECK_SUCCESS(pSnapshot->SetExposure(L"exposed1", L"thePath"));

	AddLunMappings(pSnapshot);
	ValidateSnapshot(pSnapshot, iSnapshot);
	}




void TestSnapshotXML()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"TestSnapshotXML");

	HRESULT hr;

	try
		{
		CComPtr<IVssSnapshotSetDescription> pSnapshotSet;

		CHECK_SUCCESS(CreateVssSnapshotSetDescription
						(
						x_idSnapSet,
						VSS_CTX_BACKUP,
						&pSnapshotSet
						));



		CHECK_SUCCESS(pSnapshotSet->SetDescription(L"This is a test snapshot set"));
		CHECK_SUCCESS(pSnapshotSet->SetMetadata(L"This is some test metadata for the snapshot set."));

		ValidateSnapshotSet(pSnapshotSet);

		CHECK_SUCCESS(pSnapshotSet->AddSnapshotDescription(x_idSnap1, x_idProv));
		CHECK_SUCCESS(pSnapshotSet->AddSnapshotDescription(x_idSnap2, x_idProv));

		VSS_ID idSnap1, idSnap2;
		CComPtr<IVssSnapshotDescription> pSnapshot1;
		CComPtr<IVssSnapshotDescription> pSnapshot2;

		GetAndValidateSnapshots(pSnapshotSet, &pSnapshot1, &pSnapshot2, idSnap1, idSnap2);

		AddSnapshotData(pSnapshot1, idSnap1 == x_idSnap1 ? 1 : 2);
		AddSnapshotData(pSnapshot2, idSnap2 == x_idSnap1 ? 1 : 2);
		pSnapshot1 = NULL;
		pSnapshot2 = NULL;

		CComBSTR bstrXML;
		CHECK_SUCCESS(pSnapshotSet->SaveAsXML(&bstrXML));
		pSnapshotSet = NULL;

		CHECK_SUCCESS(LoadVssSnapshotSetDescription(bstrXML, &pSnapshotSet));

		ValidateSnapshotSet(pSnapshotSet);
		GetAndValidateSnapshots(pSnapshotSet, &pSnapshot1, &pSnapshot2, idSnap1, idSnap2);
        ValidateSnapshot(pSnapshot1, idSnap1 == x_idSnap1 ? 1 : 2);
		ValidateSnapshot(pSnapshot2, idSnap2 == x_idSnap1 ? 1 : 2);
		}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		wprintf(L"Snapshot XML test failed with hr = 0x%08lx\n", ft.hr);
	else
		wprintf(L"Snapshot XML test succeeded\n");
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\canceltest\canceltest.cxx ===
#pragma warning(disable:4290)

#include <stdlib.h>
#include <time.h>
#include <Nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wchar.h>
#include <stdio.h>
#include <oleauto.h>
#include <stddef.h>
#include "vs_assert.hxx"
#include <atlbase.h>
#include "vs_idl.hxx"
#include "vswriter.h"
#include "vsbackup.h"
#include "bsstring.hxx"


enum	{
	PrepareForBackup = 0,
	DoSnapshotSet = 1,
	BackupComplete = 2,
	PreRestore = 3,
	PostRestore = 4,
	GatherWriterMetadata = 5,
	GatherWriterStatus = 6,
	MaxOperations = 7
};

const wchar_t* operationCodes[MaxOperations] =	{ L"-pfb",
											  L"-dss",
											  L"-bc",
											  L"-prer",
											  L"-postr",
											  L"-gwm",
											  L"-gws" };
const wchar_t* timeCode = L"-time";

wchar_t* programName = L"canceltest.exe";

void checker(HRESULT error, wchar_t* string);
HRESULT cancelTest(IVssAsync* async, LONG cancelDelay);
HRESULT waitTest(IVssAsync* async);
void parse(int argc, wchar_t* argv[], bool* operations, long& waitTime);
int findParam(wchar_t* findee);
CComBSTR runBackupTest(bool* cancel, long cancelDelay);
void runRestoreTest(bool* cancel, long cancelDelay, CComBSTR xmlData);
const wchar_t* WszFromRestoreMethod(VSS_RESTOREMETHOD_ENUM method);
const wchar_t* WszFromUsageType(VSS_USAGE_TYPE usage);
const wchar_t* GetStringFromWriterStatus(VSS_WRITER_STATE eWriterStatus);
void checkMetadata(IVssBackupComponents* components);
void checkStatus(IVssBackupComponents* components);
CBsString helpString();

extern "C" INT __cdecl wmain(int argc, wchar_t* argv[])
{
	try	{
		bool operations[MaxOperations];
		long waitTime = 0;

		parse(argc, argv, operations, waitTime);

		checker(CoInitializeEx(NULL, COINIT_MULTITHREADED),
				L"CoInitializeEx");

		CComBSTR xmlData = runBackupTest(operations, waitTime);	
		runRestoreTest(operations, waitTime, xmlData);

	}	catch(CBsString thrown)	{
		fwprintf(stderr, thrown);
		exit(1);
	}
}

void parse(int argc, wchar_t* argv[], bool* operations, long& waitTime)
{
	memset(operations, 0, sizeof(bool) * MaxOperations);

	// parse each command-line argument
	for (int x = 1; x < argc; x++)	{
		int index = findParam(argv[x]);
		if (index == -1)	{
			if (wcscmp(argv[x], timeCode) != 0)	{
				CBsString throwString = L"Invalid command line parameter\n\n"+ helpString();
				throw throwString;
			}
			
			if (x == argc - 1)	{
				CBsString throwString = L"no value given for time parameter\n\n" + helpString();
				throw throwString;
			}

			waitTime = wcstol(argv[++x], NULL, 10);
		}	else	{
			operations[index] = true;
		}
	}
}

CBsString helpString()
{
	CBsString help;
	help += L"Usage: ";
	help += programName;
	help += L" [<option-list>]\n\n";

	help += L"[<option-list>] is zero or more of the following options\n";
	help += timeCode;
	help += L" <milliseconds>\tspecify milliseconds to wait before cancelling\n";
	
	help += operationCodes[PrepareForBackup];
	help += L"\t\t\tcancel the asynchronous call to PrepareForBackup\n";

	help += operationCodes[DoSnapshotSet];
	help += L"\t\t\tcancel the asynchronous call to DoSnapshotSet\n";

	help += operationCodes[BackupComplete];
	help += L"\t\t\tcancel the asynchronous call to BackupComplete\n";

	help += operationCodes[PreRestore];
	help += L"\t\t\tcancel the asynchronous call to PreRestore\n";

	help += operationCodes[PostRestore];
	help += L"\t\t\tcancel the asynchronous call to PostRestore\n";

	help += operationCodes[GatherWriterMetadata];
	help += L"\t\t\tcancel the asynchronous calls to GatherWriterMetadata\n";

	help += operationCodes[GatherWriterStatus];
	help += L"\t\t\tcancel the asynchronous calls to GatherWriterStatus\n";

	return help;
}

int findParam(wchar_t* findee)
{
	// find the parameter in the list of accepted parameters
	for (int x = 0; x < MaxOperations; x++)	{
		if (wcscmp(operationCodes[x], findee) == 0)
			return x;
	}

	return -1;
}

// run a backup test
CComBSTR runBackupTest(bool cancel[MaxOperations], long cancelDelay)
{
	CComPtr<IVssBackupComponents> components;
	checker(::CreateVssBackupComponents(&components), L"CreateVssBackupComponents");

	checker(components->InitializeForBackup(), L"InitializeForBackup");
	checker(components->SetBackupState(false, true, VSS_BT_FULL, false), L"SetBackupState");

	CComPtr<IVssAsync> async;
	checker(components->GatherWriterMetadata(&async), L"GatherWriterMetadata");
	checker(cancel[GatherWriterMetadata] ? cancelTest(async, cancelDelay) : waitTest(async), 
			L"GatherWriterMetadata async");

	checkMetadata(components);
	async = NULL;


	VSS_ID setId = GUID_NULL;
	VSS_ID snapshotId = GUID_NULL;


	checker(components->StartSnapshotSet(&setId),
	L"StartSnapshotSet");

	fwprintf(stderr, L"\nWriter Status after SSS \n");
	checker(components->GatherWriterStatus(&async), L"GatherWriterStatus");
	checker(cancel[GatherWriterStatus] ? cancelTest(async, cancelDelay) : waitTest(async),
		L"GatherWriterStatus async");
	checkStatus(components);

	async = NULL;

	checker(components->AddToSnapshotSet(L"C:\\", GUID_NULL, &snapshotId),
		L"AddToSnapshotSet");

	checker(components->PrepareForBackup(&async), L"PrepareForBackup");
	checker(cancel[PrepareForBackup] ? cancelTest(async, cancelDelay) : waitTest(async), 
			L"PrepareForBackup async");

	async = NULL;

	fwprintf(stderr, L"\nWriter Status after PrepareForBackup \n");
	checker(components->GatherWriterStatus(&async), L"GatherWriterStatus");
	checker(cancel[GatherWriterStatus] ? cancelTest(async, cancelDelay) : waitTest(async),
		L"GatherWriterStatus async");
	checkStatus(components);

	async = NULL;

	checker(components->DoSnapshotSet(&async), L"DoSnapshotSet");
	checker(cancel[DoSnapshotSet] ? cancelTest(async, cancelDelay) : waitTest(async),
		L"DoSnapshotSet async");
	async = NULL;

	fwprintf(stderr, L"\nWriter Status after DoSnapshotSet\n");
	checker(components->GatherWriterStatus(&async), L"GatherWriterStatus");
	checker(cancel[GatherWriterStatus] ? cancelTest(async, cancelDelay) : waitTest(async),
		L"GatherWriterStatus async");

	checkStatus(components);

	async = NULL;
	checker(components->BackupComplete(&async), L"BackupComplete");
	checker(cancel[BackupComplete] ? cancelTest(async, cancelDelay) : waitTest(async),
		L"BackupComplete async");

	async = NULL;
	fwprintf(stderr, L"\nWriter Status after BackupComplete\n");
	checker(components->GatherWriterStatus(&async), L"GatherWriterStatus");
	checker(cancel[GatherWriterStatus] ? cancelTest(async, cancelDelay) : waitTest(async),
		L"GatherWriterStatus async");

	checkStatus(components);

	CComBSTR xmlData;
	checker(components->SaveAsXML(&xmlData), L"SaveAsXML");
	
	return xmlData;
}

// run a restore test
void runRestoreTest(bool cancel[MaxOperations], long cancelDelay, CComBSTR xmlData)
{
	CComPtr<IVssBackupComponents> components;
	checker(::CreateVssBackupComponents(&components), L"CreateVssBackupComponents");
	checker(components->InitializeForRestore(xmlData), L"InitializeForRestore");

	CComPtr<IVssAsync> async;
	checker(components->GatherWriterMetadata(&async), L"GatherWriterMetadata");
	checker(cancel[GatherWriterMetadata] ? cancelTest(async, cancelDelay) : waitTest(async), 
			L"GatherWriterMetadata async");

	// select all writer components
	UINT numComponents = 0;
	checker(components->GetWriterComponentsCount(&numComponents), L"numComponents");
	for (UINT x = 0; x < numComponents; x++)	{
		CComPtr<IVssWriterComponentsExt> writerComponents;
		checker(components->GetWriterComponents(x, &writerComponents), L"GetWriterComponents");

		VSS_ID idWriter, idInstance;
        UINT cComponents;
        checker(writerComponents->GetComponentCount(&cComponents), L"GetComponentCount");
        checker(writerComponents->GetWriterInfo(&idInstance, &idWriter), L"GetWriterInfo");

		for (UINT y = 0; y < cComponents; y++)	{
			CComPtr<IVssComponent> writerComponent;
			checker(writerComponents->GetComponent(y, &writerComponent), L"GetComponent");

			CComBSTR logicalPath, name;
			VSS_COMPONENT_TYPE ct;
			checker(writerComponent->GetLogicalPath(&logicalPath), L"GetLogicalPath");
			checker(writerComponent->GetComponentName(&name), L"GetComponentName");
			checker(writerComponent->GetComponentType(&ct), L"GetComponentType");

			checker(components->SetSelectedForRestore(idWriter, ct, logicalPath, name, true),
				L"SetSelectedForRestore");
		}
	}

	async = NULL;
	checker(components->PreRestore(&async), L"GatherWriterMetadata");
	checker(cancel[PreRestore] ? cancelTest(async, cancelDelay) : waitTest(async), 
			L"GatherWriterMetadata async");

	async = NULL;

	fwprintf(stderr, L"\nWriter Status after PreRestore\n");
	checker(components->GatherWriterStatus(&async), L"GatherWriterStatus");
	checker(cancel[GatherWriterStatus] ? cancelTest(async, cancelDelay) : waitTest(async),
		L"GatherWriterStatus async");

	async = NULL;

	checkStatus(components);

	checker(components->PostRestore(&async), L"GatherWriterMetadata");
	checker(cancel[PostRestore] ? cancelTest(async, cancelDelay) : waitTest(async), 
			L"GatherWriterMetadata async");

	async = NULL;

	fwprintf(stderr, L"\nWriter Status after PostRestore\n");
	checker(components->GatherWriterStatus(&async), L"GatherWriterStatus");
	checker(cancel[GatherWriterStatus] ? cancelTest(async, cancelDelay) : waitTest(async),
		L"GatherWriterStatus async");

	checkStatus(components);
}

// check a return code and throw upon failure
inline void checker(HRESULT error, wchar_t* string)
{
	if (FAILED(error))	{
		CBsString error;
		error.Format(L"%s failed with error 0x%08lx", string, error);
		throw error;
	}
}

// wait on an async object
inline HRESULT waitTest(IVssAsync* async)
{
	checker(async->Wait(), L"IVssAsync::Wait");

	HRESULT hr;
	async->QueryStatus(&hr, NULL);

	// convert non-failure state codes to S_OK
	return FAILED(hr) ? hr : S_OK;
}

// cancel an async object
inline HRESULT cancelTest(IVssAsync* async, long cancelDelay)
{
	// put an upper limit on random delays
	const int MaxRandDelay = 1000;

	// wait for the requisite amount of time
	if (cancelDelay != 0)
		::Sleep((cancelDelay > 0) ? cancelDelay : rand() % MaxRandDelay);

	async->Cancel();
	HRESULT hr;
	async->QueryStatus(&hr, NULL);

	// convert non-failure state codes to S_OK
	return FAILED(hr) ? hr : S_OK;
}

void checkMetadata(IVssBackupComponents* components)
{
	UINT numWriters = 0;
	checker(components->GetWriterMetadataCount(&numWriters),
			L"GetWriterMetadataCount");

	for (UINT x = 0; x < numWriters; x++)	{
		VSS_ID instance = GUID_NULL;
		CComPtr<IVssExamineWriterMetadata> examineData;

		checker(components->GetWriterMetadata(x, &instance, &examineData),
				L"GetWriterMetadata");

		VSS_ID outInstance = GUID_NULL, outClass = GUID_NULL;
		BSTR outName;
		VSS_USAGE_TYPE outUsage;
		VSS_SOURCE_TYPE outSource;

		checker(examineData->GetIdentity(&outInstance, &outClass, &outName, &outUsage, &outSource),
			L"GetIdentity");
		BS_ASSERT(outInstance == instance);

		fwprintf (stderr, L"\nWriter name %s\n", outName);
		fwprintf (stderr, L"usage type %s\n", WszFromUsageType(outUsage));
		
		VSS_RESTOREMETHOD_ENUM restoreMethod;
		BSTR service, userProc;
		VSS_WRITERRESTORE_ENUM writerRestore;
		bool reboot;
		UINT mappings;
		checker(examineData->GetRestoreMethod(&restoreMethod, &service, &userProc, &writerRestore, &reboot, &mappings),
			L"GetIdentity");

		fwprintf(stderr, L"restore method %s\n", WszFromRestoreMethod(restoreMethod));
		fwprintf(stderr, L"reboot required %s\n", reboot ? L"true" : L"false");

		UINT includes = 0, excludes = 0, components = 0;
		checker(examineData->GetFileCounts(&includes, &excludes, &components),
			L"GetFileCounts");

		fwprintf(stderr, L"%d include files\n%d exclude files \n%d components\n", includes, excludes, components);

	}
}

void checkStatus(IVssBackupComponents* components)
{
	UINT numWriters = 0;
	checker(components->GetWriterMetadataCount(&numWriters),
			L"GetWriterMetadataCount");

	UINT numStatus = 0;
	checker(components->GetWriterStatusCount(&numStatus),
			L"GetWriterMetadataCount");

	BS_ASSERT(numStatus == numWriters);

	for (UINT x = 0; x < numStatus; x++)	{
		VSS_ID instance, classWriter;
		BSTR writerName;
		VSS_WRITER_STATE state;
		HRESULT failure = S_OK;
		checker(components->GetWriterStatus(x, &instance, &classWriter, &writerName, &state, &failure),
			L"GetWriterStatus");

		fwprintf(stderr, L"\n writer name %s\n", writerName);
		fwprintf(stderr, L"writer status %s\n", GetStringFromWriterStatus(state));
		fwprintf(stderr, L"writer failure 0x%08lx\n", failure);
	}
}

const wchar_t* WszFromUsageType(VSS_USAGE_TYPE usage)
{
    switch(usage)	{
        default:
			throw L"UNKOWN";

        case VSS_UT_OTHER:
            return L"OTHER";

        case VSS_UT_BOOTABLESYSTEMSTATE:
            return L"BOOTABLE_SYSTEM_STATE";

        case VSS_UT_SYSTEMSERVICE:
            return L"SYSTEM_SERVICE";

        case VSS_UT_USERDATA:
            return L"USER_DATA";
        }
}


// convert from restore method to string
const wchar_t* WszFromRestoreMethod(VSS_RESTOREMETHOD_ENUM method)
{
    switch(method)	{
        default:
			return L"UNKNOWN";

        case VSS_RME_RESTORE_IF_NOT_THERE:
            return L"RESTORE_IF_NONE_THERE";

        case VSS_RME_RESTORE_IF_CAN_REPLACE:
            return L"RESTORE_IF_CAN_BE_REPLACED";

        case VSS_RME_STOP_RESTORE_START:
            return L"STOP_RESTART_SERVICE";

        case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION:
            return L"RESTORE_TO_ALTERNATE_LOCATION";

        case VSS_RME_RESTORE_AT_REBOOT:
            return L"REPLACE_AT_REBOOT";

        case VSS_RME_CUSTOM:
            return L"CUSTOM";
        }
}
const wchar_t* GetStringFromWriterStatus(VSS_WRITER_STATE eWriterStatus)
{
    const wchar_t*  pwszRetString = L"UNDEFINED";

    switch (eWriterStatus)
	{
	case VSS_WS_STABLE:                    pwszRetString = L"STABLE";                  break;
	case VSS_WS_WAITING_FOR_FREEZE:        pwszRetString = L"WAITING_FOR_FREEZE";      break;
	case VSS_WS_WAITING_FOR_THAW:          pwszRetString = L"WAITING_FOR_THAW";        break;
    case VSS_WS_WAITING_FOR_POST_SNAPSHOT: pwszRetString = L"WAITING_FOR_POST_SNAPSHOT"; break;
	case VSS_WS_WAITING_FOR_BACKUP_COMPLETE:    pwszRetString = L"WAITING_FOR_BACKUP_COMPLETION";  break;
	case VSS_WS_FAILED_AT_IDENTIFY:        pwszRetString = L"FAILED_AT_IDENTIFY";      break;
	case VSS_WS_FAILED_AT_PREPARE_BACKUP:  pwszRetString = L"FAILED_AT_PREPARE_BACKUP";break;
	case VSS_WS_FAILED_AT_PREPARE_SNAPSHOT:    pwszRetString = L"FAILED_AT_PREPARE_SNAPSHOT";  break;
	case VSS_WS_FAILED_AT_FREEZE:          pwszRetString = L"FAILED_AT_FREEZE";        break;
	case VSS_WS_FAILED_AT_THAW:			   pwszRetString = L"FAILED_AT_THAW";          break;
    case VSS_WS_FAILED_AT_POST_SNAPSHOT:   pwszRetString = L"FAILED_AT_POST_SNAPSHOT"; break;
    case VSS_WS_FAILED_AT_BACKUP_COMPLETE: pwszRetString = L"FAILED_AT_BACKUP_COMPLETE"; break;
    case VSS_WS_FAILED_AT_PRE_RESTORE:     pwszRetString = L"FAILED_AT_PRE_RESTORE"; break;
    case VSS_WS_FAILED_AT_POST_RESTORE:    pwszRetString = L"FAILED_AT_POST_RESTORE"; break;
	default:
	    break;
	}

    return (pwszRetString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\failsnap\failsnap.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	simsnap.cpp
**
**
** Abstract:
**
**	Test program to drive the VSS Writer Shim contained in VssAPI.DLL
**
**
** Author:
**
**	Michael C. Johnson   [mikejohn]        24-May-2000
**
**
** Revision History:
**
**	X-5	MCJ		Michael C. Johnson		18-Sep-2000
**		176860: Add the missing calling convention specifiers
**
**	X-4	MCJ		Michael C. Johnson		23-Jun-2000
**		Set the writer failure status.
**
**	X-3	MCJ		Michael C. Johnson		15-Jun-2000
**		Add some additional event routines and the ability to act
**		as various types of writer.
**
**	X-2	MCJ		Michael C. Johnson		26-May-2000
**		Add some extra tests to validate shim is properly sensitive
**		to volume name array contents.
**--
*/

/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/
#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <assert.h>

#include <vss.h>
#include <vswriter.h>



#define	GET_STATUS_FROM_BOOL(_bSucceeded)	((_bSucceeded)       ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_HANDLE(_handle)		((NULL != (_handle)) ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_POINTER(_ptr)		((NULL != (_ptr))    ? NOERROR : E_OUTOFMEMORY)

#define SIZEOF_ARRAY(_aBase)			(sizeof (_aBase) / sizeof ((_aBase)[0]))



typedef enum FAIL_PHASE
    {
    PHASE_UNDEFINED = 0,
    PHASE_IDENTIFY,
    PHASE_PREPARE_FOR_BACKUP,
    PHASE_PREPARE_FOR_SNAPSHOT,
    PHASE_FREEZE,
    PHASE_THAW,
    PHASE_ABORT,
    PHASE_BACKUP_COMPLETE,
    PHASE_RESTORE
    } FAIL_PHASE;


HRESULT SelectFailureStatus (VOID)
    {
    HRESULT	hrStatus;

    switch (rand () / (RAND_MAX / 5))
	{
	case 0: hrStatus = VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT; break;
	case 1: hrStatus = VSS_E_WRITERERROR_OUTOFRESOURCES;       break;
	case 2: hrStatus = VSS_E_WRITERERROR_TIMEOUT;              break;
	case 3: hrStatus = VSS_E_WRITERERROR_NONRETRYABLE;         break;
	case 4: hrStatus = VSS_E_WRITERERROR_RETRYABLE;            break;

	default:
	    assert (FALSE);
	    break;
	}

    return (hrStatus);
    }



LPCWSTR GetStringFromFailureType (HRESULT hrStatus)
    {
    LPCWSTR pwszFailureType;

    switch (hrStatus)
	{
	case NOERROR:                                pwszFailureType = L"";                     break;
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT: pwszFailureType = L"InconsistentSnapshot"; break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:       pwszFailureType = L"OutOfResources";       break;
	case VSS_E_WRITERERROR_TIMEOUT:              pwszFailureType = L"Timeout";              break;
	case VSS_E_WRITERERROR_NONRETRYABLE:         pwszFailureType = L"Non-Retryable";        break;
	case VSS_E_WRITERERROR_RETRYABLE:            pwszFailureType = L"Retryable";            break;
	default:                                     pwszFailureType = L"UNDEFINED";            break;
	}

    return (pwszFailureType);
    }



LPCWSTR GetStringFromWriterType (VSS_USAGE_TYPE wtWriterType)
    {
    LPCWSTR pwszWriterType;

    switch (wtWriterType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszWriterType = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszWriterType = L"SystemServiceState";  break;
	case VSS_UT_USERDATA:            pwszWriterType = L"UserData";            break;
	case VSS_UT_OTHER:               pwszWriterType = L"Other";               break;
	default:                         pwszWriterType = L"UNDEFINED";           break;
	}

    return (pwszWriterType);
    }



LPCWSTR GetStringFromFailPhase (FAIL_PHASE fpFailPhase)
    {
    LPCWSTR pwszFailPhase;


    switch (fpFailPhase)
	{
	case PHASE_IDENTIFY:             pwszFailPhase = L"Identify";           break;
	case PHASE_PREPARE_FOR_BACKUP:   pwszFailPhase = L"PrepareForBackup";   break;
	case PHASE_PREPARE_FOR_SNAPSHOT: pwszFailPhase = L"PrepareForSnapshot"; break;
	case PHASE_FREEZE:               pwszFailPhase = L"Freeze";             break;
	case PHASE_THAW:                 pwszFailPhase = L"Thaw";               break;
	case PHASE_ABORT:                pwszFailPhase = L"Abort";              break;
	case PHASE_BACKUP_COMPLETE:      pwszFailPhase = L"BackupComplete";     break;
	case PHASE_RESTORE:              pwszFailPhase = L"Restore";            break;
	default:                         pwszFailPhase = L"UNDEFINED";          break;
	}
    
    return (pwszFailPhase);
    }





static volatile BOOL       bContinue   = TRUE;
static volatile FAIL_PHASE fpFailPhase = PHASE_FREEZE;
static volatile BOOL       bHungWriter = FALSE;
static volatile BOOL       dwHungWriterTimeout = 120000;    // Two minutes




class CVssWriterFailSnap : public CVssWriter
	{
public:
	    bool STDMETHODCALLTYPE OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata);
	    bool STDMETHODCALLTYPE OnPrepareBackup (IVssWriterComponents *pIVssWriterComponents);
	    bool STDMETHODCALLTYPE OnPrepareSnapshot ();
	    bool STDMETHODCALLTYPE OnFreeze ();
	    bool STDMETHODCALLTYPE OnThaw ();
	    bool STDMETHODCALLTYPE OnAbort ();
	    bool STDMETHODCALLTYPE OnBackupComplete (IVssWriterComponents *pIVssWriterComponents);
	    bool STDMETHODCALLTYPE OnPostRestore (IVssWriterComponents *pIVssWriterComponents);
};



bool STDMETHODCALLTYPE CVssWriterFailSnap::OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata)
    {
    bool	bPhaseSucceeded = (PHASE_IDENTIFY != fpFailPhase);
    HRESULT	hrStatus        = SelectFailureStatus ();

    if (bPhaseSucceeded)
	{
	hrStatus = pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							    NULL,
							    L"Failsnap Writer Component",
							    L"Failsnap Writer Caption",
							    NULL, // icon
							    0,
							    true,
							    false,
							    false);

	bPhaseSucceeded = SUCCEEDED (hrStatus);
	}


    wprintf (L"\nThreadId 0x%04x - Received event - OnIdentify ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    // simulate a hung writer
    if (!bPhaseSucceeded && bHungWriter)
    {
        wprintf(L"Sleeping %ld seconds\n", dwHungWriterTimeout/1000);
        ::Sleep(dwHungWriterTimeout);
        wprintf(L"Wake up.\n");
    }

    
    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnPrepareBackup (IVssWriterComponents *pIVssWriterComponents)
    {
    bool	bPhaseSucceeded = (PHASE_PREPARE_FOR_BACKUP != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    // simulate a hung writer
    if (!bPhaseSucceeded && bHungWriter)
    {
        wprintf(L"Sleeping %ld seconds\n", dwHungWriterTimeout/1000);
        ::Sleep(dwHungWriterTimeout);
        wprintf(L"Wake up.\n");
    }
    
    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnPrepareSnapshot ()
    {
    bool	bPhaseSucceeded = (PHASE_PREPARE_FOR_SNAPSHOT != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnPrepareSnapshot ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));

    // simulate a hung writer
    if (!bPhaseSucceeded && bHungWriter)
    {
        wprintf(L"Sleeping %ld seconds\n", dwHungWriterTimeout/1000);
        ::Sleep(dwHungWriterTimeout);
        wprintf(L"Wake up.\n");
    }
    
    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnFreeze ()
    {
    bool	bPhaseSucceeded = (PHASE_FREEZE != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnFreeze ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));

    // simulate a hung writer
    if (!bPhaseSucceeded && bHungWriter)
    {
        wprintf(L"Sleeping %ld seconds\n", dwHungWriterTimeout/1000);
        ::Sleep(dwHungWriterTimeout);
        wprintf(L"Wake up.\n");
    }
    
    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnThaw ()
    {
    bool	bPhaseSucceeded = (PHASE_THAW != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnThaw ()%s%s", 
	     GetCurrentThreadId (),
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));

    // simulate a hung writer
    if (!bPhaseSucceeded && bHungWriter)
    {
        wprintf(L"Sleeping %ld seconds\n", dwHungWriterTimeout/1000);
        ::Sleep(dwHungWriterTimeout);
        wprintf(L"Wake up.\n");
    }
    
    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnAbort ()
    {
    bool	bPhaseSucceeded = (PHASE_ABORT != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnAbort ()%s%s",
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));

    // simulate a hung writer
    if (!bPhaseSucceeded && bHungWriter)
    {
        wprintf(L"Sleeping %ld seconds\n", dwHungWriterTimeout/1000);
        ::Sleep(dwHungWriterTimeout);
        wprintf(L"Wake up.\n");
    }
    
    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnBackupComplete (IVssWriterComponents *pIVssWriterComponents)
    {
    bool	bPhaseSucceeded = (PHASE_BACKUP_COMPLETE != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnBackupComplete ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));

    // simulate a hung writer
    if (!bPhaseSucceeded && bHungWriter)
    {
        wprintf(L"Sleeping %ld seconds\n", dwHungWriterTimeout/1000);
        ::Sleep(dwHungWriterTimeout);
        wprintf(L"Wake up.\n");
    }
    
    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnPostRestore (IVssWriterComponents *pIVssWriterComponents)
    {
    bool	bPhaseSucceeded = (PHASE_RESTORE != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnPostRestore ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));

    // simulate a hung writer
    if (!bPhaseSucceeded && bHungWriter)
    {
        wprintf(L"Sleeping %ld seconds\n", dwHungWriterTimeout/1000);
        ::Sleep(dwHungWriterTimeout);
        wprintf(L"Wake up.\n");
    }
    
    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }






static BOOL AssertPrivilege (LPCWSTR privName)
    {
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if (OpenProcessToken (GetCurrentProcess (), TOKEN_ADJUST_PRIVILEGES, &tokenHandle))
	{
        LUID value;

        if (LookupPrivilegeValue (NULL, privName, &value))
	    {
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            /*
            ** We will always call GetLastError below, so clear
            ** any prior error values on this thread.
            */
            SetLastError (ERROR_SUCCESS);

            stat = AdjustTokenPrivileges (tokenHandle,
					  FALSE,
					  &newState,
					  (DWORD)0,
					  NULL,
					  NULL);

            /*
            ** Supposedly, AdjustTokenPriveleges always returns TRUE
            ** (even when it fails). So, call GetLastError to be
            ** extra sure everything's cool.
            */
            if ((error = GetLastError()) != ERROR_SUCCESS)
		{
                stat = FALSE;
		}

            if (!stat)
		{
                wprintf (L"AdjustTokenPrivileges for %s failed with 0x%08X",
			 privName,
			 error);
		}
	    }


        CloseHandle (tokenHandle);
	}

    return stat;
    }



BOOL WINAPI CtrlC_HandlerRoutine (IN DWORD /* dwType */)
	{
	bContinue = FALSE;

	// Mark that the break was handled.
	return TRUE;
	}



extern "C" int __cdecl wmain (int argc, WCHAR *argv[])
    {
    HRESULT		 hrStatus            = NOERROR;
    CVssWriterFailSnap	*pCVssWriterFailSnap = NULL;
    BOOL		 bSucceeded          = FALSE;
    BOOL		 bComInitialized     = FALSE;
    BOOL		 bSubscribed         = FALSE;
    VSS_USAGE_TYPE	 wtWriterType        = VSS_UT_USERDATA;
    const GUID		 guidIdWriter        = {0xd335a99e,
						0x57fb,
						0x4b80,
						    {0x85, 0xb1, 0x15, 0xda, 0xa7, 0xc7, 0x4e, 0x14}};


    srand ((unsigned)time (NULL));

    SetConsoleCtrlHandler(CtrlC_HandlerRoutine, TRUE);

    // Get the "hung writer" flag
    if ((argc >= 3) && (_wcsicmp(argv[1], L"/h") == 0))
    {
        bHungWriter = TRUE;
        swscanf(argv[2], L"%ld", &dwHungWriterTimeout);
        dwHungWriterTimeout *= 1000;
        argc-=2;
        argv+=2;
    }

    if ((argc >= 2) && (wcslen (argv[1]) > 0))
	{
	switch (*argv[1])
	    {
	    case L'I': case L'i': fpFailPhase = PHASE_IDENTIFY;             break;
	    case L'B': case L'b': fpFailPhase = PHASE_PREPARE_FOR_BACKUP;   break;
	    case L'S': case L's': fpFailPhase = PHASE_PREPARE_FOR_SNAPSHOT; break;
	    case L'F': case L'f': fpFailPhase = PHASE_FREEZE;               break;
	    case L'T': case L't': fpFailPhase = PHASE_THAW;                 break;
	    case L'A': case L'a': fpFailPhase = PHASE_ABORT;                break;
	    case L'C': case L'c': fpFailPhase = PHASE_BACKUP_COMPLETE;      break;
	    case L'R': case L'r': fpFailPhase = PHASE_RESTORE;              break;

	    default:
		wprintf (L"\nFAILSNAP [/h seconds] [phase] [writer type]"
			 L"\n\n\tFailPhases"
			 L"\n\t\ti - Identify"
			 L"\n\t\tb - PrepareForBackup"
			 L"\n\t\ts - PrepareForSnapshot"
			 L"\n\t\tf - Freeze                (default)"
			 L"\n\t\tt - Thaw"
			 L"\n\t\ta - Abort"
			 L"\n\t\tc - BackupComplete"
			 L"\n\t\tr - PostRestore"

			 L"\n\n\tWriterTypes"
			 L"\n\t\tb - BootableState writer"
			 L"\n\t\ts - ServiceState writer"
			 L"\n\t\tu - UserData writer       (default)"
			 L"\n\t\to - Other writer"
             L"\n"
             L"\n\t/h - Additionally, hung in the failed state for the specified time."
			 L"\n");



		bContinue = FALSE;
		break;
	    }
	}



    if ((argc >= 3) && (wcslen (argv[2]) > 0))
	{
	switch (*argv[2])
	    {
	    case L'B': case L'b': wtWriterType = VSS_UT_BOOTABLESYSTEMSTATE; break;
	    case L'S': case L's': wtWriterType = VSS_UT_SYSTEMSERVICE;       break;
	    case L'U': case L'u': wtWriterType = VSS_UT_USERDATA;            break;
	    case L'O': case L'o': wtWriterType = VSS_UT_OTHER;               break;

	    default:
		bContinue = FALSE;
		break;
	    }
	}





    if (bContinue)
	{
	wprintf (L"\nSetting up %s writer to fail %s requests (ProcessId 0x%04x)",
		 GetStringFromWriterType (wtWriterType),
		 GetStringFromFailPhase  (fpFailPhase),
		 GetCurrentProcessId ());

/*
	wprintf (L"\nChecking privileges");

	bSubscribed = AssertPrivilege (SE_BACKUP_NAME);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);


	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nAssertPrivilege returned error 0x%08X", hrStatus);
	    }

*/
	}

    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nInitializing COM");

	hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nCoInitialize() returned error 0x%08X", hrStatus);
	    }

	else
	    {
	    bComInitialized = TRUE;
	    }
	}

    if (bContinue && SUCCEEDED (hrStatus))
	{
    	wprintf (L"\nInitializing COM security");

        // Initialize COM security
        hrStatus = CoInitializeSecurity
                (
                NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
                -1,                                  //  IN LONG                         cAuthSvc,
                NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
                NULL,                                //  IN void                        *pReserved1,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY,           //  IN DWORD                        dwAuthnLevel,
                RPC_C_IMP_LEVEL_IDENTIFY,            //  IN DWORD                        dwImpLevel,
                NULL,                                //  IN void                        *pAuthList,
                EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
                NULL                                 //  IN void                        *pReserved3
                );

    	if (FAILED (hrStatus))
    	    {
    	    wprintf (L"\nCoInitialize() returned error 0x%08X", hrStatus);
    	    }
	}

    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nConstructing Writer");

	pCVssWriterFailSnap = new CVssWriterFailSnap;

	if (NULL == pCVssWriterFailSnap)
	    {
	    hrStatus = HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY);

	    wprintf (L"\nFailed to allocate CVssWriterFailSnap : 0x%08X", hrStatus);
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	WCHAR	awchWriterName [256];


	wprintf (L"\nInitialising the writer");

	_snwprintf (awchWriterName, 
		    SIZEOF_ARRAY (awchWriterName), 
		    L"Microsoft Test Writer - FailSnap (%s/%s/0x%04x)",
		    GetStringFromWriterType (wtWriterType),
		    GetStringFromFailPhase  (fpFailPhase),
		    GetCurrentProcessId ());


	hrStatus = pCVssWriterFailSnap->Initialize (guidIdWriter,
						    awchWriterName,
						    wtWriterType,
						    VSS_ST_OTHER);

	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nFailed to initialize the writer : 0x%08X", hrStatus);
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nSubscribing to snapshot events");

	hrStatus = pCVssWriterFailSnap->Subscribe ();

	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nFailed to subscribe to snapshot events : 0x%08X", hrStatus);
	    }

	else
	    {
	    bSubscribed = TRUE;
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nWaiting for snapshot events (or Ctrl-C)");
	
	while (bContinue)
	    {
	    Sleep (100);
	    }
	}



    if (bSubscribed)
	{
	wprintf (L"\nUn-Subscribing from snapshot events");

	pCVssWriterFailSnap->Unsubscribe ();
	}


    if (NULL != pCVssWriterFailSnap)
	{
	wprintf (L"\nDeconstructing Writer");

	delete pCVssWriterFailSnap;
	}


    if (bComInitialized)
	{
	wprintf (L"\nUnInitialising COM");

	CoUninitialize();
	}

    return (hrStatus);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\hwprv\src\hwprv.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module hwprv.hxx | Definition the COM server of the Software Snapshot provider
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.
    aoltean     09/09/1999  dss->vss

--*/


///////////////////////////////////////////////////////////////////////////////
//   Includes
//


#include "stdafx.hxx"
#include <process.h>
#include "initguid.h"

// Generated MIDL header
#include "vss.h"
#include "vdslun.h"
#include "vsprov.h"
#include "vscoordint.h"

#include "resource.h"
#include "vs_inc.hxx"
#include "vssmsg.h"

#include "hwprv.hxx"
#include "hwprv.h"

#include "provider.hxx"

#include <comadmin.h>
#include "comadmin.hxx"

VSS_ID g_ProviderId =
	{
	0x04AAF00B, 0xF272, 0x4449,
	0xAE, 0x63, 0xE8, 0xAC, 0x93, 0x5A, 0x10, 0x2B
	};


VSS_ID g_ProviderVersion =
	{
	0xEE12C84C, 0x9345, 0x4FE8,
	0xBB, 0xA8, 0x67, 0xC1, 0x7D, 0xE4, 0x75, 0x34
	};

/////////////////////////////////////////////////////////////////////////////
// Constants



const WCHAR g_wszAppName[]  = L"MS Test Hardware Snapshot Provider";
const WCHAR g_wszSvcName[]  = L"HwPrv";
const WCHAR g_wszDllName[]  = L"\\HWPRV.DLL";

const MAX_STRING_RESOURCE_LEN = 1024;

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "THWHWPRC"
//
////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//   Static objects
//

CHwPrvSnapshotSrvModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_HardwareTestProvider, CHardwareTestProvider)
END_OBJECT_MAP()


///////////////////////////////////////////////////////////////////////////////////////
//  COM Server registration
//

HRESULT GetDllPathName(
	IN	INT nBufferLength, // Does not include terminating zero character
    IN  LPCWSTR wszDllName,
    OUT LPWSTR wszDllPath
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"GetDllPathName" );

    try
    {
		WCHAR wszDir[MAX_PATH];
        if (!::GetCurrentDirectory(MAX_PATH, wszDir)) {
            ft.LogError(VSS_ERROR_GETTING_CURRENT_DIR, VSSDBG_VSSTEST << HRESULT_FROM_WIN32(GetLastError()) );
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED,
				L"Error on getting the current path. hr = 0x%08lx",
                HRESULT_FROM_WIN32(GetLastError()));
        }

        if ( ::wcslen(wszDir) +
			 ::wcslen(wszDllName) >= (size_t) nBufferLength )
            ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

        ::_snwprintf(wszDllPath, nBufferLength,
				L"%s%s", wszDir, wszDllName);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}

void MakeChangeable(bool fChangeable)
	{
	CVssFunctionTracer ft(VSSDBG_VSSTEST, L"MakeChangeable");

	CVssCOMAdminCatalog     catalog;
	ft.hr = catalog.Attach(g_wszAppName);
	if (ft.HrFailed())
		ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in initializing the catalog object 0x%08lx", ft.hr);

	// Get the list of applications
	CVssCOMCatalogCollection appsList(VSS_COM_APPLICATIONS);
	ft.hr = appsList.Attach(catalog);
	if (ft.HrFailed())
		ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in initializing the apps collection object 0x%08lx", ft.hr);

	CVssCOMApplication application;
	ft.hr = application.AttachByName( appsList, catalog.GetAppName() );
	if (ft.HrFailed())
		ft.LogError(VSS_ERROR_ATTACH_COLL_BY_NAME, VSSDBG_VSSTEST << catalog.GetAppName() << ft.hr);


	// if the application doesn't exist then return
	if (ft.hr == S_FALSE)
		return;

	application.m_bChangeable = fChangeable;
	application.m_bDeleteable = fChangeable;
	ft.hr = appsList.SaveChanges();
	if (ft.HrFailed())
		{
		ft.TraceComError();
		ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in commiting changes. hr = 0x%08lx", ft.hr);
		}
	}

HRESULT RegisterNewCOMApp()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"RegisterNewCOMApp" );

    try
    {
		MakeChangeable(true);
        //
        // Initialize the catalog
        //

        CVssCOMAdminCatalog     catalog;
        ft.hr = catalog.Attach(g_wszAppName);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in initializing the catalog object 0x%08lx", ft.hr);

        //
        //  Create a new application, if doesn't exist yet.
        //

        // Get the list of applications
        CVssCOMCatalogCollection appsList(VSS_COM_APPLICATIONS);
        ft.hr = appsList.Attach(catalog);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in initializing the apps collection object 0x%08lx", ft.hr);

		// Check if the application already exists - to solve the upgrade between different OS versions.
		// If the application doesn't exist then insert a new application
        CVssCOMApplication application;
		ft.hr = application.AttachByName( appsList, catalog.GetAppName() );
		if (ft.HrFailed()) {
            ft.LogError(VSS_ERROR_ATTACH_COLL_BY_NAME, VSSDBG_VSSTEST << catalog.GetAppName() << ft.hr);
		}
		
		if (ft.hr == S_OK)
			{
			// the application exits.  delete it
			LONG lIndex = application.GetIndex();
			BS_ASSERT(lIndex != -1);
			ft.hr = appsList.GetInterface()->Remove(lIndex);
			if (ft.HrFailed())
				{
				ft.LogError(VSS_ERROR_REMOVING_APPLICATION, VSSDBG_COORD << catalog.GetAppName() << ft.hr);
				ft.TraceComError();
				ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"Failure to remove eventcls application object 0x %08lx", ft.hr);
				}

			// commit changes
			ft.hr = appsList.SaveChanges();
			if (ft.HrFailed())
				{
                ft.TraceComError();
				ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"Failure in commiting changes. hr = 0x%08lx", ft.hr);
				}
			ft.hr = application.AttachByName( appsList, catalog.GetAppName() );
			if (ft.HrFailed())
				{
				ft.LogError(VSS_ERROR_ATTACH_COLL_BY_NAME, VSSDBG_COORD << catalog.GetAppName() << ft.hr);
				ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"Failure in initializing the apps collection object 0x%08lx", ft.hr);
				}
			}

		// The application doesn't exist.
		ft.hr = application.InsertInto(appsList);
		if (ft.HrFailed())
			ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in creating a new application object 0x%08lx", ft.hr);

		// Set application name
		application.m_bstrName = catalog.GetAppName();

        // Loads the application description
        WCHAR wszBuffer[MAX_STRING_RESOURCE_LEN];
        if (0 == ::LoadStringW(_Module.GetModuleInstance(),
            IDS_SERVICE_DESCRIPTION, wszBuffer, MAX_STRING_RESOURCE_LEN - 1))
        {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_VSSTEST, HRESULT_FROM_WIN32(GetLastError()),
    			L"Error on loading the app description. [0x%08lx]",
    			HRESULT_FROM_WIN32(GetLastError()));
        }

        CComBSTR bstrAppDescription = wszBuffer;
        if ((LPWSTR)bstrAppDescription == NULL)
            ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error.");
		application.m_bstrDescription = bstrAppDescription;
		
		// Register as Server package
		application.m_lActivation = COMAdminActivationLocal;

		// Commit changes
		ft.hr = appsList.SaveChanges();
		if (ft.HrFailed())
			{
			ft.TraceComError();
			ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in commiting changes. hr = 0x%08lx", ft.hr);
    	    }
		// Make the application a true NT service
//			BS_ASSERT(false);
		ft.hr = catalog.CreateServiceForApplication(g_wszSvcName);
		if (ft.HrFailed())
			{
			BS_ASSERT(false);
			ft.TraceComError();
			ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on installing the service. hr = 0x%08lx", ft.hr);
            }

        //
        //  Insert this component into the application
        //

        WCHAR wszFileName[MAX_PATH];
        ft.hr = GetDllPathName(MAX_PATH - 1, g_wszDllName, wszFileName);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Error in getting the DLL path. hr = 0x%08lx", ft.hr);

        // Install the component
        ft.hr = catalog.InstallComponent(wszFileName, NULL, NULL);
        if (ft.HrFailed()) {
            ft.TraceComError();
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on install the event class. hr = 0x%08lx", ft.hr);
			}

	    BS_ASSERT(ft.hr != S_FALSE);

		MakeChangeable(false);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



///////////////////////////////////////////////////////////////////////////////
//   DLL Entry point
//

//
// The real DLL Entry Point is _DLLMainCrtStartup (initializes global objects and after that calls DllMain
// this is defined in the runtime libaray
//

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        //  Set the correct tracing context. This is an inproc DLL
        g_cDbgTrace.SetContextNum(VSS_CONTEXT_DELAYED_DLL);

        // Set the proper way for displaying asserts
//        ::VssSetDebugReport(VSS_DBG_TO_DEBUG_CONSOLE);

        //  initialize COM module
        _Module.Init(ObjectMap, hInstance);

        //  optimization
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
//   DLL Exports
//


// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}


// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}

HRESULT RegisterProvider()
	{
	CVssFunctionTracer ft(VSSDBG_VSSTEST, L"RegisterProvider");
	try
		{
		CComPtr<IVssAdmin> pAdmin;
		ft.hr = CoCreateInstance
					(
                    CLSID_VSSCoordinator,
					NULL,
					CLSCTX_ALL,
					IID_IVssAdmin,
					(void **) (IVssAdmin **) &pAdmin
					);

       ft.CheckForError(VSSDBG_VSSTEST, L"CoCreateInstance");

	   ft.hr = pAdmin->RegisterProvider
			 		(
					g_ProviderId,
					CLSID_HardwareTestProvider,
					L"HardwareTestProvider",
					VSS_PROV_HARDWARE,
					L"1.0",
					g_ProviderVersion
					);

       ft.CheckForError(VSSDBG_VSSTEST, L"IVssAdmin::RegisterProvider");
	   }
   VSS_STANDARD_CATCH(ft)

   return ft.hr;
   }

HRESULT UnregisterProvider()
	{
	CVssFunctionTracer ft(VSSDBG_VSSTEST, L"UnregisterProvider");
	try
		{
		CComPtr<IVssAdmin> pAdmin;
		ft.hr = CoCreateInstance
					(
                    CLSID_VSSCoordinator,
					NULL,
					CLSCTX_ALL,
					IID_IVssAdmin,
					(void **) (IVssAdmin **) &pAdmin
					);

       ft.CheckForError(VSSDBG_VSSTEST, L"CoCreateInstance");

	   ft.hr = pAdmin->UnregisterProvider(g_ProviderId);
       ft.CheckForError(VSSDBG_VSSTEST, L"IVssAdmin::UnregisterProvider");
	   }
   VSS_STANDARD_CATCH(ft)

   return ft.hr;
   }





					




// DllInstall - install the component into the COM+ catalog.
STDAPI DllInstall(	
	IN	BOOL bInstall,
	IN	LPCWSTR /* pszCmdLine */
)
{
	HRESULT hr = S_OK;

	// Registers the COM+ application
	// This will implicitely call DllRegisterServer
	if (bInstall)
		{
		hr = RegisterNewCOMApp();
		if (SUCCEEDED(hr))
			RegisterProvider();
		}
	else
		UnregisterProvider();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\hwprv\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hwprv.rc
//
#define IDS_PROJNAME                    100
#define IDR_HWPRV                       101
#define IDS_SERVICE_DESCRIPTION         102

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\hwprv\src\provider.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Provider.hxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Brian Berkowitz  [brianb]   05/01/2001

Revision History:

    Name        Date        Comments


--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>

//  Generated MIDL header
#include "vss.h"
#include "vdslun.h"
#include "vsprov.h"
#include "vscoordint.h"
#include "hwprv.h"


#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "vs_reg.hxx"
#include "hwprv.hxx"


#include "provider.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "TSTHWPRC"
//
////////////////////////////////////////////////////////////////////////

CHardwareTestProvider::CHardwareTestProvider () :
    m_SnapshotSetId(GUID_NULL),
    m_maskSnapshotDisks(0),
    m_cDiskIds(0),
    m_pDynamicDiskInfo(NULL)
    {
    for(UINT i = 0; i < 32; i++)
        {
        m_rgpSourceLuns[i] = NULL;
        m_rgpDestinationLuns[i] = NULL;
        }

    memset(m_rgDiskSignatures, 0, sizeof(m_rgDiskSignatures));
    m_bRebuilt = false;
    }

CHardwareTestProvider::~CHardwareTestProvider()
    {
    ClearConfiguration();
    if (m_pDynamicDiskInfo)
        {
        do
            {
            DYNAMIC_DISK_INFO *pNext = m_pDynamicDiskInfo->m_next;
            delete m_pDynamicDiskInfo->m_wszVolumes;
            delete m_pDynamicDiskInfo;
            m_pDynamicDiskInfo = pNext;
            } while(m_pDynamicDiskInfo);
        }
    }


STDMETHODIMP CHardwareTestProvider::OnLoad
    (
    IN      IUnknown* pCallback
    )
    {
    UNREFERENCED_PARAMETER(pCallback);

    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::OnLoad");

    try
        {
        m_cs.Init();

        CVssSafeAutomaticLock lock(m_cs);
        ClearConfiguration();
        LoadConfigurationData();

        // clear various bits of snapshot goo
        m_bHidden = false;
        m_SnapshotSetId = GUID_NULL;
        m_maskSnapshotDisks = 0;
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

STDMETHODIMP CHardwareTestProvider::OnUnload
    (
    IN      BOOL    bForceUnload
    )
    {
    UNREFERENCED_PARAMETER(bForceUnload);

    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::OnUnload");

    CVssSafeAutomaticLock lock(m_cs);

    ClearConfiguration();

    return ft.hr;
    }


    //
    //  IVssHardwareSnapshotProvider
    //

STDMETHODIMP CHardwareTestProvider::FillInLunInfo
    (
    IN VSS_PWSZ wszDevice,
    IN OUT VDS_LUN_INFORMATION *pLunInformation,
    OUT BOOL *pbIsSupported
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CHardwareTestProvider::FillInLunInfo");

    CVssSafeAutomaticLock lock(m_cs);
    m_bRebuilt = false;
    try
        {
        if (pbIsSupported == NULL || pLunInformation == NULL)
            throw(VSSDBG_VSSTEST, E_INVALIDARG, L"NULL output parameter");

        *pbIsSupported = FALSE;
        bool bFound = false;

        RebuildLunInfo();

        for(DWORD iDestLun = 0; iDestLun < m_cDiskIds; iDestLun++)
            {
            if (IsMatchLun(*pLunInformation, *(m_rgpDestinationLuns[iDestLun])))
                {
                bFound = true;
                break;
                }
            }

        if (bFound)
            {
            pLunInformation->m_rgInterconnects = (VDS_INTERCONNECT *) CoTaskMemAlloc(sizeof(VDS_INTERCONNECT));
            if (pLunInformation->m_rgInterconnects == NULL)
                ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

            memset(pLunInformation->m_rgInterconnects, 0, sizeof(VDS_INTERCONNECT));
            pLunInformation->m_cInterconnects = 1;
            pLunInformation->m_rgInterconnects->m_pbAddress = (BYTE *) CoTaskMemAlloc(sizeof(ULONG));
            if (pLunInformation->m_rgInterconnects->m_pbAddress == NULL)
                ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

            pLunInformation->m_rgInterconnects->m_cbAddress = sizeof(ULONG);
            pLunInformation->m_rgInterconnects->m_addressType = VDS_IA_FCPH;
            pLunInformation->m_rgInterconnects->m_pbPort = (BYTE *) CoTaskMemAlloc(sizeof(ULONG));
            if (pLunInformation->m_rgInterconnects->m_pbPort == NULL)
                ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

            *((ULONG *) (pLunInformation->m_rgInterconnects->m_pbPort)) = 0x8828080;
            pLunInformation->m_rgInterconnects->m_cbPort = sizeof(ULONG);
            for(iDestLun = 0; iDestLun < m_cDiskIds; iDestLun++)
                {
                if (IsMatchLun(*pLunInformation, *(m_rgpDestinationLuns[iDestLun])))
                    {
                    *(ULONG *) (pLunInformation->m_rgInterconnects->m_pbAddress) = iDestLun;
                    break;
                    }
                }

            *pbIsSupported = true;
            }
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

STDMETHODIMP CHardwareTestProvider::AreLunsSupported
    (
    IN  LONG lLunCount,
    IN  LONG lContext,
    IN  VSS_PWSZ *rgwszDevices,
    IN OUT  VDS_LUN_INFORMATION *rgLunInformation,
    OUT BOOL *pbIsSupported
    )
    {
    UNREFERENCED_PARAMETER(rgwszDevices);
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::AreLunsSupported");

    CVssSafeAutomaticLock lock(m_cs);
    m_bRebuilt = false;
    try
        {
        if (pbIsSupported == NULL || rgLunInformation == NULL)
            throw(VSSDBG_VSSTEST, E_INVALIDARG, L"NULL output parameter");

        *pbIsSupported = FALSE;
        VDS_LUN_INFORMATION *pLunInformation = rgLunInformation;
        bool bFound = false;

        RebuildLunInfo();

        for(LONG iLun = 0; iLun < lLunCount; iLun++, pLunInformation++)
            {
            bFound = false;
            for(DWORD iSourceLun = 0; iSourceLun < m_cDiskIds; iSourceLun++)
                {
                if (IsMatchLun(*pLunInformation, *(m_rgpSourceLuns[iSourceLun])))
                    {
                    bFound = true;
                    break;
                    }
                }

            if (!bFound)
                break;
            }

        if (bFound)
            {
            pLunInformation = rgLunInformation;
            for(LONG iLun = 0; iLun < lLunCount; iLun++, pLunInformation++)
                {
                pLunInformation->m_rgInterconnects = (VDS_INTERCONNECT *) CoTaskMemAlloc(sizeof(VDS_INTERCONNECT));
                if (pLunInformation->m_rgInterconnects == NULL)
                    ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

                memset(pLunInformation->m_rgInterconnects, 0, sizeof(VDS_INTERCONNECT));
                pLunInformation->m_cInterconnects = 1;
                pLunInformation->m_rgInterconnects->m_pbAddress = (BYTE *) CoTaskMemAlloc(sizeof(ULONG));
                if (pLunInformation->m_rgInterconnects->m_pbAddress == NULL)
                    ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

                pLunInformation->m_rgInterconnects->m_cbAddress = sizeof(ULONG);
                pLunInformation->m_rgInterconnects->m_addressType = VDS_IA_FCPH;
                pLunInformation->m_rgInterconnects->m_pbPort = (BYTE *) CoTaskMemAlloc(sizeof(ULONG));
                if (pLunInformation->m_rgInterconnects->m_pbPort == NULL)
                    ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

                *((ULONG *) (pLunInformation->m_rgInterconnects->m_pbPort)) = 0x8828080;
                pLunInformation->m_rgInterconnects->m_cbPort = sizeof(ULONG);
                for(DWORD iSourceLun = 0; iSourceLun < m_cDiskIds; iSourceLun++)
                    {
                    if (IsMatchLun(*pLunInformation, *(m_rgpSourceLuns[iSourceLun])))
                        {
                        *(ULONG *) (pLunInformation->m_rgInterconnects->m_pbAddress) = iSourceLun;
                        break;
                        }
                    }
                }

            *pbIsSupported = true;
            }
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }


STDMETHODIMP CHardwareTestProvider::BeginPrepareSnapshot
    (
    IN      VSS_ID          SnapshotSetId,
    IN      VSS_ID          SnapshotId,
    IN      LONG            lContext,
    IN      LONG            lLunCount,
    IN OUT  VSS_PWSZ        *rgwszDevices,
    IN      VDS_LUN_INFORMATION *rgLunInformation
    )
    {
    UNREFERENCED_PARAMETER(SnapshotId);
    UNREFERENCED_PARAMETER(rgwszDevices);
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::BeginPrepareSnapshot");

    CVssSafeAutomaticLock lock(m_cs);
    m_bRebuilt = false;
    try
        {
        if (m_SnapshotSetId == GUID_NULL)
            {
            m_lContext = lContext;
            m_SnapshotSetId = SnapshotSetId;
            m_maskSnapshotDisks = 0;
            }

        VDS_LUN_INFORMATION *pLunInformation = rgLunInformation;

        for(LONG iLun = 0; iLun < lLunCount; iLun++, pLunInformation++)
            {
            if (pLunInformation->m_cInterconnects != 1 ||
                pLunInformation->m_rgInterconnects == NULL ||
                pLunInformation->m_rgInterconnects[0].m_cbAddress != sizeof(ULONG) ||
                pLunInformation->m_rgInterconnects[0].m_cbPort != sizeof(ULONG) ||
                *(ULONG *) (pLunInformation->m_rgInterconnects[0].m_pbPort) != 0x8828080)
                ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"Drive not supported");

            ULONG iDisk = *(ULONG *) (pLunInformation->m_rgInterconnects[0].m_pbAddress);
            *(ULONG *) (pLunInformation->m_rgInterconnects[0].m_pbAddress) |= 0x80000000;

            m_maskSnapshotDisks |= 1 << iDisk;
            }
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// free all the components of a VDS_LUN_INFO structure
void CHardwareTestProvider::FreeLunInfo
    (
    IN VDS_LUN_INFORMATION *rgLunInfo,
    UINT cLuns
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssTestHardwareProvider::FreeLunInfo");

    // check if pointer is NULL
    if (rgLunInfo == NULL)
        return;

    // loop through individual luns
    for(DWORD iLun = 0; iLun < cLuns; iLun++)
        {
        // get lun info
        VDS_LUN_INFORMATION *pLun = &rgLunInfo[iLun];

        // free up strings
        if (pLun->m_szVendorId)
            CoTaskMemFree(pLun->m_szVendorId);

        if (pLun->m_szProductId)
            CoTaskMemFree(pLun->m_szProductId);

        if (pLun->m_szProductRevision)
            CoTaskMemFree(pLun->m_szProductRevision);

        if (pLun->m_szSerialNumber)
            CoTaskMemFree(pLun->m_szSerialNumber);


        // point to VDS_STORAGE_DEVICE_ID_DESCRIPTOR
        // get number of VDS_STORAGE_IDENTIFIERs in the descriptor
        ULONG cIds = pLun->m_deviceIdDescriptor.m_cIdentifiers;

        // point to first VDS_STORAGE_IDENTIFIER
        VDS_STORAGE_IDENTIFIER *pvsi = pLun->m_deviceIdDescriptor.m_rgIdentifiers;
        for(ULONG iId = 0; iId < cIds; iId++, pvsi++)
            {
            // free up data for identifier
            if (pvsi->m_rgbIdentifier)
                CoTaskMemFree(pvsi->m_rgbIdentifier);
            }

        // free up array of identifiers
        if (pLun->m_deviceIdDescriptor.m_rgIdentifiers)
            CoTaskMemFree(pLun->m_deviceIdDescriptor.m_rgIdentifiers);

        // point to first VDS_INTERCONNECT
        VDS_INTERCONNECT *pInterconnect = pLun->m_rgInterconnects;

        for(ULONG iInterconnect = 0; iInterconnect < pLun->m_cInterconnects; iInterconnect++, pInterconnect++)
            {
            // free up address if there is one
            if (pInterconnect->m_pbAddress)
                CoTaskMemFree(pInterconnect->m_pbAddress);

            if (pInterconnect->m_pbPort)
                CoTaskMemFree(pInterconnect->m_pbPort);
            }

        // free up array of interconnects
        if (pLun->m_rgInterconnects)
            CoTaskMemFree(pLun->m_rgInterconnects);
        }

    // free up array of lun information
    CoTaskMemFree(rgLunInfo);
    }

void CHardwareTestProvider::CopyString(LPSTR &szCopy, LPCSTR szSource)
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::CopyString");

    if (szSource == NULL)  {
        szCopy = NULL;
        return;
    }
    szCopy = (LPSTR) CoTaskMemAlloc(strlen(szSource) + 1);
    if (szCopy == NULL)
        ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

    strcpy(szCopy, szSource);
    }

void CHardwareTestProvider::CopyBinaryData
    (
    LPBYTE &rgb,
    UINT cbSource,
    const BYTE *rgbSource
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::CopyBinaryData");

    rgb = (BYTE *) CoTaskMemAlloc(cbSource);
    if (rgb == NULL)
        ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

    memcpy(rgb, rgbSource, cbSource);
    }



STDMETHODIMP CHardwareTestProvider::GetTargetLuns
    (
    IN      LONG        lLunCount,
    IN      VSS_PWSZ    *rgwszDevices,
    IN      VDS_LUN_INFORMATION *rgSourceLuns,
    IN OUT  VDS_LUN_INFORMATION *rgDestinationLuns
    )
    {
    UNREFERENCED_PARAMETER(rgwszDevices);
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::GetTargetLuns");

    CVssSafeAutomaticLock lock(m_cs);
    try
        {
        memset(rgDestinationLuns, 0, lLunCount * sizeof(VDS_LUN_INFORMATION));
        for(LONG iLun = 0; iLun < lLunCount; iLun++)
            {
            VDS_LUN_INFORMATION *pLunInfo = NULL;
            for(DWORD iDisk = 0; iDisk < m_cDiskIds; iDisk++)
                {
                if (IsMatchLun(*m_rgpSourceLuns[iDisk], rgSourceLuns[iLun]))
                    pLunInfo = m_rgpDestinationLuns[iDisk];
                }

            if (pLunInfo == NULL)
                ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Can't find source lun");

            VDS_LUN_INFORMATION *pDestLun = &rgDestinationLuns[iLun];
            VDS_LUN_INFORMATION *pSourceLun = &rgSourceLuns[iLun];

            pDestLun->m_BusType = pLunInfo->m_BusType;
            pDestLun->m_DeviceType = pLunInfo->m_DeviceType;
            pDestLun->m_DeviceTypeModifier = pLunInfo->m_DeviceTypeModifier;
            pDestLun->m_bCommandQueueing = pLunInfo->m_bCommandQueueing;
            pDestLun->m_diskSignature = pLunInfo->m_diskSignature;
            CopyString(pDestLun->m_szVendorId, pLunInfo->m_szVendorId);
            CopyString(pDestLun->m_szProductId, pLunInfo->m_szProductId);
            CopyString(pDestLun->m_szProductRevision, pLunInfo->m_szProductRevision);
            CopyString(pDestLun->m_szSerialNumber, pLunInfo->m_szSerialNumber);
            ULONG cIds = pLunInfo->m_deviceIdDescriptor.m_cIdentifiers;
            pDestLun->m_deviceIdDescriptor.m_version = pLunInfo->m_deviceIdDescriptor.m_version;
            pDestLun->m_deviceIdDescriptor.m_cIdentifiers = cIds;
            pDestLun->m_deviceIdDescriptor.m_rgIdentifiers = (VDS_STORAGE_IDENTIFIER *) CoTaskMemAlloc(cIds * sizeof(VDS_STORAGE_DEVICE_ID_DESCRIPTOR));
            memset(pDestLun->m_deviceIdDescriptor.m_rgIdentifiers, 0, cIds * sizeof(VDS_STORAGE_DEVICE_ID_DESCRIPTOR));
            VDS_STORAGE_IDENTIFIER *pSourceId = pLunInfo->m_deviceIdDescriptor.m_rgIdentifiers;
            VDS_STORAGE_IDENTIFIER *pDestId = pDestLun->m_deviceIdDescriptor.m_rgIdentifiers;
            for(ULONG iId = 0; iId < cIds; iId++, pSourceId++, pDestId++)
                {
                memcpy(pDestId, pSourceId, FIELD_OFFSET(VDS_STORAGE_IDENTIFIER, m_rgbIdentifier));
                CopyBinaryData(pDestId->m_rgbIdentifier, pSourceId->m_cbIdentifier, pSourceId->m_rgbIdentifier);
                }

            pDestLun->m_cInterconnects = 1;
            pDestLun->m_rgInterconnects = (VDS_INTERCONNECT *) CoTaskMemAlloc(sizeof(VDS_INTERCONNECT));
            memset(pDestLun->m_rgInterconnects, 0, sizeof(VDS_INTERCONNECT));
            VDS_INTERCONNECT *pDestInterconnect = pDestLun->m_rgInterconnects;
            VDS_INTERCONNECT *pSourceInterconnect = pSourceLun->m_rgInterconnects;
            BS_ASSERT(((*(ULONG *) (pSourceInterconnect->m_pbAddress)) & 0x80000000) != 0)
            pDestInterconnect->m_addressType = VDS_IA_FCPH;
            pDestInterconnect->m_pbAddress = (BYTE *) CoTaskMemAlloc(sizeof(ULONG));
            if (pDestInterconnect->m_pbAddress == NULL)
                ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

            pDestInterconnect->m_cbAddress = sizeof(ULONG);
            *(ULONG *) (pDestInterconnect->m_pbAddress) = iDisk;
            pDestInterconnect->m_pbPort = (BYTE *) CoTaskMemAlloc(sizeof(ULONG));
            if (pDestInterconnect->m_pbPort == NULL)
                ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

            *(ULONGLONG *) (pDestInterconnect->m_pbPort) = 0x9364321;
            pDestInterconnect->m_cbPort = sizeof(ULONG);
            }
        }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        FreeLunInfo(rgDestinationLuns, lLunCount);

    return ft.hr;
    }

STDMETHODIMP CHardwareTestProvider::LocateLuns
    (
    IN      LONG        lLunCount,
    IN      VDS_LUN_INFORMATION *rgSourceLuns
    )
    {
    UNREFERENCED_PARAMETER(lLunCount);
    UNREFERENCED_PARAMETER(rgSourceLuns);
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::LocateLuns");

    CVssSafeAutomaticLock lock(m_cs);
    m_bRebuilt = false;
    try
        {
        CVssAutoWin32Handle hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, L"Global\\VSNAP_START_IMPORT");
        if (hEvent == NULL)
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"CreateEvent");
            }

        CVssAutoWin32Handle hEventComplete = OpenEvent(EVENT_ALL_ACCESS, FALSE, L"Global\\VSNAP_START_IMPORT_COMPLETED");
        if (hEventComplete == NULL)
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"CreateEvent");
            }


        if (!SetEvent(hEvent))
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"SetEvent");
            }

        if (WaitForSingleObject(hEventComplete, INFINITE) == WAIT_FAILED)
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"WaitForSingleObject");
            }
        }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.hr = VSS_E_PROVIDER_VETO;

    return ft.hr;
    }

// perform a device i/o control, growing the buffer if necessary
BOOL CHardwareTestProvider::DoDeviceIoControl
    (
    IN HANDLE hDevice,              // handle
    IN DWORD ioctl,                 // device ioctl to perform
    IN const LPBYTE pbQuery,        // input buffer
    IN DWORD cbQuery,               // size of input buffer
    IN OUT LPBYTE *ppbOut,          // pointer to output buffer
    IN OUT DWORD *pcbOut            // pointer to size of output buffer
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::DoDeviceIoControl");

    // loop in case buffer is too small for query result.
    while(TRUE)
        {
        DWORD dwSize;
        if (*ppbOut == NULL)
            {
            // allocate buffer for result of query
            *ppbOut = new BYTE[*pcbOut];
            if (*ppbOut == NULL)
                ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Couldn't allocate query results buffer");
            }

        // do query
        if (!DeviceIoControl
                (
                hDevice,
                ioctl,
                pbQuery,
                cbQuery,
                *ppbOut,
                *pcbOut,
                &dwSize,
                NULL
                ))
            {
            // query failed
            DWORD dwErr = GetLastError();

            if (dwErr == ERROR_INVALID_FUNCTION ||
                dwErr == ERROR_NOT_SUPPORTED ||
                dwErr == ERROR_NOT_READY)
                return FALSE;


            if (dwErr == ERROR_INSUFFICIENT_BUFFER ||
                dwErr == ERROR_MORE_DATA)
                {
                // buffer wasn't big enough allocate a new
                // buffer of the specified return size
                delete *ppbOut;
                *ppbOut = NULL;
                *pcbOut *= 2;
                continue;
                }

            // all other errors are remapped (and potentially logged)
            ft.hr = HRESULT_FROM_WIN32(dwErr);
            ft.CheckForError(VSSDBG_VSSTEST, L"DeviceIoControl %d");
            }

        break;
        }

    return TRUE;
    }


bool CHardwareTestProvider::BuildLunInfoFromDrive
    (
    IN HANDLE hDrive,
    OUT VDS_LUN_INFORMATION **ppLun,
    OUT DWORD &cPartitions
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::BuildLunInfoFromDrive");

    LPBYTE bufQuery = NULL;
    VDS_LUN_INFORMATION *pLun;
    try
        {
        BOOL b;

        // allocate lun information
        pLun = (VDS_LUN_INFORMATION *) CoTaskMemAlloc(sizeof(VDS_LUN_INFORMATION));
        if (pLun == NULL)
            ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Cannot allocate LUN information array");

        // clear lun information in case we throw
        memset(pLun, 0, sizeof(VDS_LUN_INFORMATION));

        // query to get STORAGE_DEVICE_OBJECT
        STORAGE_PROPERTY_QUERY query;
        DWORD cbQuery = 1024;


        query.PropertyId = StorageDeviceProperty;
        query.QueryType = PropertyStandardQuery;
        b = DoDeviceIoControl
                (
                hDrive,
                IOCTL_STORAGE_QUERY_PROPERTY,
                (LPBYTE) &query,
                sizeof(query),
                (LPBYTE *) &bufQuery,
                &cbQuery
                );

        if (!b)
            {
            delete bufQuery;
            CoTaskMemFree(pLun);
            return false;
            }


        // coerce to STORAGE_DEVICE_DESCRIPTOR
        STORAGE_DEVICE_DESCRIPTOR *pDesc = (STORAGE_DEVICE_DESCRIPTOR *) bufQuery;

        pLun->m_version = VER_VDS_LUN_INFORMATION;
        pLun->m_DeviceType = pDesc->DeviceType;
        pLun->m_DeviceTypeModifier = pDesc->DeviceTypeModifier;
        pLun->m_bCommandQueueing = pDesc->CommandQueueing;

        // copy bus type
        pLun->m_BusType = (VDS_STORAGE_BUS_TYPE) pDesc->BusType;

        // copy in various strings
        if (pDesc->VendorIdOffset)
            CopySDString(&pLun->m_szVendorId, pDesc, pDesc->VendorIdOffset);

        if (pDesc->ProductIdOffset)
            CopySDString(&pLun->m_szProductId, pDesc, pDesc->ProductIdOffset);

        if (pDesc->ProductRevisionOffset)
            CopySDString(&pLun->m_szProductRevision, pDesc, pDesc->ProductRevisionOffset);

        if (pDesc->SerialNumberOffset)
            CopySDString(&pLun->m_szSerialNumber, pDesc, pDesc->SerialNumberOffset);

        // query for STORAGE_DEVICE_ID_DESCRIPTOR
        query.PropertyId = StorageDeviceIdProperty;
        query.QueryType = PropertyStandardQuery;

        if (DoDeviceIoControl
                (
                hDrive,
                IOCTL_STORAGE_QUERY_PROPERTY,
                (LPBYTE) &query,
                sizeof(query),
                (LPBYTE *) &bufQuery,
                &cbQuery
                ))
            {
            // coerce buffer to STORAGE_DEVICE_ID_DESCRIPTOR
            STORAGE_DEVICE_ID_DESCRIPTOR *pDevId = (STORAGE_DEVICE_ID_DESCRIPTOR *) bufQuery;
            CopyStorageDeviceIdDescriptorToLun(pDevId, pLun);
            }

        if (DoDeviceIoControl
                (
                hDrive,
                IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                NULL,
                0,
                (LPBYTE *) &bufQuery,
                &cbQuery
                ))
            {
            // compute signature from layout
            DRIVE_LAYOUT_INFORMATION_EX *pLayout = (DRIVE_LAYOUT_INFORMATION_EX *) bufQuery;
            VSS_ID signature = GUID_NULL;

            cPartitions = pLayout->PartitionCount;

            switch(pLayout->PartitionStyle)
                {
                default:
                    BS_ASSERT(FALSE);
                    break;

                case PARTITION_STYLE_RAW:
                    break;

                case PARTITION_STYLE_GPT:
                    // use GPT DiskId as signature
                    signature = pLayout->Gpt.DiskId;
                    break;

                case PARTITION_STYLE_MBR:
                    // use 32 bit Mbr signature as high part of guid.  Remainder
                    // of guid is 0.
                    signature.Data1 = pLayout->Mbr.Signature;
                    break;
                }

            // save disk signature
            pLun->m_diskSignature = signature;
            }
        }
    VSS_STANDARD_CATCH(ft)

    delete bufQuery;
    if (ft.HrFailed())
        {
        FreeLunInfo(pLun, 1);
        ft.Throw(VSSDBG_VSSTEST, ft.hr, L"Rethrowing");
        }

    *ppLun = pLun;

    return TRUE;
    }



STDMETHODIMP CHardwareTestProvider::OnLunEmpty
    (
    IN VSS_PWSZ wszDevice,
    IN VDS_LUN_INFORMATION *pInfo
    )
    {
    UNREFERENCED_PARAMETER(wszDevice);
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::OnLunEmpty");

    CVssSafeAutomaticLock lock(m_cs);
    try
        {
        for(DWORD iDisk = 0; iDisk < m_cDiskIds; iDisk++)
            {
            if (IsMatchLun(*(m_rgpDestinationLuns[iDisk]), *pInfo))
                break;
            }

        if (iDisk == m_cDiskIds)
            ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"Cannot locate lun");

        // reexpose partitions after lun is freed so we see something change
        DWORD diskId;
        bool bIsDynamic;

        if (TranslateDisk(m_rgDestinationDiskIds[iDisk], diskId, bIsDynamic))
            {
            if (bIsDynamic)
                HideAndExposeDynamicVolumes(m_rgDestinationDiskIds[iDisk], false, true);
            else
                HideAndExposePartitions(diskId, m_rgcDestinationPartitions[iDisk], false, true);
            }

        AddFreedLun(wszDevice);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// IVssProviderCreateSnapshotSet interface
STDMETHODIMP CHardwareTestProvider::EndPrepareSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::EndPrepareSnapshots");
    try
        {
        if (SnapshotSetId != m_SnapshotSetId)
            ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"snapshot set mismatch");
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

STDMETHODIMP CHardwareTestProvider::PreCommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::PreCommitSnapshots");

    CVssSafeAutomaticLock lock(m_cs);
    try
        {
        if (SnapshotSetId != m_SnapshotSetId)
            ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"snapshot set mismatch");
        }
    VSS_STANDARD_CATCH(ft)
    return ft.hr;
    }

STDMETHODIMP CHardwareTestProvider::PreFinalCommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::PreFinalCommitSnapshots");

    CVssSafeAutomaticLock lock(m_cs);
    try
        {
        if (SnapshotSetId != m_SnapshotSetId)
            ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"snapshot set mismatch");
        }
    VSS_STANDARD_CATCH(ft)
    return ft.hr;
    }

STDMETHODIMP CHardwareTestProvider::PostFinalCommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::PostFinalCommitSnapshots");

    CVssSafeAutomaticLock lock(m_cs);
    try
        {
        if (SnapshotSetId != m_SnapshotSetId)
            ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"snapshot set mismatch");
        }
    VSS_STANDARD_CATCH(ft)
    return ft.hr;
    }

STDMETHODIMP CHardwareTestProvider::CommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::CommitSnapshots");

    CVssSafeAutomaticLock lock(m_cs);
    try
        {
        if (SnapshotSetId != m_SnapshotSetId)
            ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"snapshot set mismatch");

        m_bHidden = true;
        LONG mask = 1;
        for(UINT Disk = 0; mask != 0; mask = mask << 1, Disk++)
            {
            if ((m_maskSnapshotDisks & mask) != 0)
                {
                DWORD diskId;
                bool bIsDynamic;

                if (!TranslateDisk(m_rgDestinationDiskIds[Disk], diskId, bIsDynamic))
                    ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"Unexpected error");

                if (bIsDynamic)
                    HideAndExposeDynamicVolumes(m_rgDestinationDiskIds[Disk], true, false);
                else
                    HideAndExposePartitions(diskId, m_rgcDestinationPartitions[Disk], true, false);
                }
            }
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

STDMETHODIMP CHardwareTestProvider::PostCommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId,
    IN      LONG            lSnapshotsCount
    )
    {
    UNREFERENCED_PARAMETER(lSnapshotsCount);

    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::PostCommitSnapshots");

    CVssSafeAutomaticLock lock(m_cs);
    try
        {
        if (SnapshotSetId != m_SnapshotSetId)
            ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"snapshot set mismatch");
        }
    VSS_STANDARD_CATCH(ft)

    m_SnapshotSetId = GUID_NULL;
    m_maskSnapshotDisks = 0;
    m_bHidden = false;

    return ft.hr;
    }

STDMETHODIMP CHardwareTestProvider::AbortSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::AbortSnapshots");

    try
        {
        if (SnapshotSetId != m_SnapshotSetId)
            ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"snapshot set mismatch");

        if (m_bHidden)
            {
            UINT Disk = 0;
            for(LONG mask = 1; mask != 0; mask = mask << 1)
                {
                if ((m_maskSnapshotDisks & mask) != 0)
                    {
                    DWORD diskId;
                    bool bIsDynamic;

                    if (!TranslateDisk(m_rgDestinationDiskIds[Disk], diskId, bIsDynamic))
                        ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"Unexpected error");

                    if (bIsDynamic)
                        HideAndExposeDynamicVolumes(m_rgDestinationDiskIds[Disk], false, true);
                    else
                        HideAndExposePartitions(diskId, m_rgcDestinationPartitions[Disk], false, true);
                    }

                Disk++;
                }
            }

        m_bHidden = false;
        m_SnapshotSetId = GUID_NULL;
        m_maskSnapshotDisks = 0;
        }
    VSS_STANDARD_CATCH(ft)


    return ft.hr;
    }

bool CHardwareTestProvider::cmp_str_eq(LPCSTR sz1, LPCSTR sz2)
    {
    if (sz1 == NULL && sz2 == NULL)
        return true;
    else if (sz1 != NULL && sz2 != NULL)
        {
        while(*sz1 == *sz2 && *sz1 != '\0')
            {
            sz1++;
            sz2++;
            }

        if (*sz1 == *sz2)
            return true;

        if (*sz1 == '\0' && *sz2 == ' ')
            {
            while(*sz2 != '\0')
                {
                if (*sz2 != ' ')
                    return false;

                sz2++;
                }

            return true;
            }
        else if (*sz1 == ' ' && *sz2 == ' ')
            {
            while(*sz1 != '\0')
                {
                if (*sz1 != ' ')
                    return false;

                sz1++;
                }

            return true;
            }

        return false;
        }
    else
        return false;
    }




// determine if two VDS_LUN_INFORMATION structures match
bool CHardwareTestProvider::IsMatchLun
    (
    const VDS_LUN_INFORMATION &info1,
    const VDS_LUN_INFORMATION &info2
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::IsMatchLun");

    if (info1.m_DeviceType != info2.m_DeviceType)
        return false;

    if (info1.m_DeviceTypeModifier != info2.m_DeviceTypeModifier)
        return false;

    if (info1.m_BusType != info2.m_BusType)
        return false;

    if (!cmp_str_eq(info1.m_szSerialNumber, info2.m_szSerialNumber))
        return false;

    if (!cmp_str_eq(info1.m_szVendorId, info2.m_szVendorId))
        return false;

    if (!cmp_str_eq(info1.m_szProductId, info2.m_szProductId))
        return false;

    if (!cmp_str_eq(info1.m_szProductRevision, info2.m_szProductRevision))
        return false;

    if (info1.m_diskSignature != info2.m_diskSignature)
        return false;

    if (!IsMatchDeviceIdDescriptor(info1.m_deviceIdDescriptor, info2.m_deviceIdDescriptor))
        return false;

    return true;
    }


// make sure that the storage device id descriptors match
bool CHardwareTestProvider::IsMatchDeviceIdDescriptor
    (
    IN const VDS_STORAGE_DEVICE_ID_DESCRIPTOR &desc1,
    IN const VDS_STORAGE_DEVICE_ID_DESCRIPTOR &desc2
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::IsMatchDeviceIdDescriptor");

    VDS_STORAGE_IDENTIFIER *pId1 = desc1.m_rgIdentifiers;
    VDS_STORAGE_IDENTIFIER *rgId2 = desc2.m_rgIdentifiers;

    for(ULONG iIdentifier = 0; iIdentifier < desc1.m_cIdentifiers; iIdentifier++, pId1++)
        {
        if (IsConflictingIdentifier(pId1, rgId2, desc2.m_cIdentifiers))
            return false;
        }

    return true;
    }

// determine if there is a conflicting identifier in an array of storage
// identifiers
bool CHardwareTestProvider::IsConflictingIdentifier
    (
    IN const VDS_STORAGE_IDENTIFIER *pId1,
    IN const VDS_STORAGE_IDENTIFIER *rgId2,
    IN ULONG cId2
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::IsConflictingIdentifier");

    const VDS_STORAGE_IDENTIFIER *pId2 = rgId2;

    for(UINT iid = 0; iid < cId2; iid++)
        {
        if (pId1->m_Type == pId2->m_Type)
            {
            if (pId1->m_CodeSet != pId2->m_CodeSet ||
                pId1->m_cbIdentifier != pId2->m_cbIdentifier ||
                memcmp(pId1->m_rgbIdentifier, pId2->m_rgbIdentifier, pId1->m_cbIdentifier) != 0)
                return true;
            }
        }

    return false;
    }

// copy a string from a STORAGE_DEVICE_DESCRIPTOR.  It is returned as a
// CoTaskAllocated string.
void CHardwareTestProvider::CopySDString
    (
    LPSTR *ppszNew,
    STORAGE_DEVICE_DESCRIPTOR *pdesc,
    DWORD offset
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::CopySDString");

    // point to start of string
    LPSTR szId = (LPSTR)((BYTE *) pdesc + offset);
    UINT cwc = (UINT) strlen(szId);
    while(cwc > 0 && szId[cwc-1] == ' ')
        cwc--;

    if (cwc == 0)
        *ppszNew = NULL;
    else
        {
        // allocate string
        *ppszNew = (LPSTR) CoTaskMemAlloc(cwc + 1);
        if (*ppszNew == NULL)
            ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Cannot allocate string.");

        // copy value into string
        memcpy(*ppszNew, szId, cwc);
        (*ppszNew)[cwc] = L'\0';
        }
    }



void CHardwareTestProvider::HideAndExposePartitions
    (
    UINT DiskNo,
    DWORD cPartitions,
    bool fHide,
    bool fExpose
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::HideAndExposePartitions");

    HANDLE rgh[256];
    BS_ASSERT(cPartitions < 256);
    for(UINT i = 0; i < cPartitions; i++)
        rgh[i] = INVALID_HANDLE_VALUE;

    try
        {
        WCHAR volName[128];

        for(UINT i = 0; i < cPartitions; i++)
            {
            swprintf
                (
                volName,
                L"\\\\?\\GlobalRoot\\Device\\Harddisk%d\\Partition%d",
                DiskNo,
                i
                );

            rgh[i] = CreateFile
                        (
                        volName,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

            if (rgh[i] == INVALID_HANDLE_VALUE)
                {
                DWORD dwErr = GetLastError();
                if (dwErr == ERROR_FILE_NOT_FOUND ||
                    dwErr == ERROR_PATH_NOT_FOUND)
                    continue;

                ft.hr = HRESULT_FROM_WIN32(dwErr);
                ft.CheckForError(VSSDBG_VSSTEST, L"CreateFile(VOLUME)");
                }
            }

        DoHideAndExpose(rgh, cPartitions, fHide, fExpose);
        }
    VSS_STANDARD_CATCH(ft)

    for(i = 0; i < cPartitions; i++)
        {
        if (rgh[i] != INVALID_HANDLE_VALUE)
            CloseHandle(rgh[i]);
        }

    }

void CHardwareTestProvider::HideAndExposeDynamicVolumes
    (
    DWORD signature,
    bool fHide,
    bool fExpose
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::HideAndExposeDynamicVolumes");

    HANDLE rgh[256];
    for(UINT i = 0; i < 256; i++)
        rgh[i] = INVALID_HANDLE_VALUE;

    UINT cVolumes = 0;

    try
        {
        DYNAMIC_DISK_INFO *pInfo = m_pDynamicDiskInfo;
        while(pInfo)
            {
            if (pInfo->m_signature == signature)
                break;

            pInfo = pInfo->m_next;
            }

        // if no information is found, then all volumes on the
        // disk are already hidden
        if (!pInfo)
            return;


        LPCWSTR wszVolumes = pInfo->m_wszVolumes;

        while(*wszVolumes)
            {
            BS_ASSERT(cVolumes < 256);
            rgh[cVolumes] = CreateFile
                                (
                                wszVolumes,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

            if (rgh[cVolumes] == INVALID_HANDLE_VALUE)
                {
                DWORD dwErr = GetLastError();
                if (dwErr == ERROR_FILE_NOT_FOUND ||
                    dwErr == ERROR_PATH_NOT_FOUND)
                    {
                    wszVolumes += wcslen(wszVolumes) + 1;
                    continue;
                    }

                ft.hr = HRESULT_FROM_WIN32(dwErr);
                ft.CheckForError(VSSDBG_VSSTEST, L"CreateFile(VOLUME)");
                }

            wszVolumes += wcslen(wszVolumes) + 1;
            cVolumes++;
            }

        DoHideAndExpose(rgh, cVolumes, fHide, fExpose);
        }
    VSS_STANDARD_CATCH(ft)

    for(i = 0; i < cVolumes; i++)
        {
        if (rgh[i] != INVALID_HANDLE_VALUE)
            CloseHandle(rgh[i]);
        }

    }



void CHardwareTestProvider::DoHideAndExpose
    (
    HANDLE *rgh,
    UINT cHandles,
    bool fHide,
    bool fExpose
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::DoHideAndExpose");

    DWORD size;
    VOLUME_GET_GPT_ATTRIBUTES_INFORMATION   getAttributesInfo;

    for(UINT i = 0; i < cHandles; i++)
        {
        if (!DeviceIoControl
                (
                rgh[i],
                IOCTL_VOLUME_GET_GPT_ATTRIBUTES,
                NULL,
                0,
                &getAttributesInfo,
                sizeof(getAttributesInfo),
                &size,
                NULL
                ))
            {
            DWORD dwErr = GetLastError();
            if (dwErr == ERROR_INVALID_FUNCTION)
                continue;

            ft.hr = HRESULT_FROM_WIN32(dwErr);
            ft.CheckForError(VSSDBG_VSSTEST, L"DeviceIoControl(IOCTL_VOLUME_GET_GPT_ATTRIBUTES)");
            }

        if (fHide &&
            (getAttributesInfo.GptAttributes & GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY) == 0)
            {
            // dismount volume before seting read-only bits
            if (!DeviceIoControl
                    (
                    rgh[i],
                    FSCTL_DISMOUNT_VOLUME,
                    NULL,
                    0,
                    NULL,
                    0,
                    &size,
                    NULL
                    ))
                {
                DWORD dwErr = GetLastError();
                if (dwErr == ERROR_INVALID_FUNCTION)
                    continue;

                ft.hr = HRESULT_FROM_WIN32(dwErr);
                ft.CheckForError(VSSDBG_VSSTEST, L"DeviceIoControl(IOCTL_VOLUME_SET_GPT_ATTRIBUTES)");
                }
            }
        }

    for(i = 0; i < cHandles; i++)
        {
        if (rgh[i] != INVALID_HANDLE_VALUE)
            {
            DWORD size;
            VOLUME_GET_GPT_ATTRIBUTES_INFORMATION   getAttributesInfo;
            VOLUME_SET_GPT_ATTRIBUTES_INFORMATION setAttributesInfo;

            if (!DeviceIoControl
                    (
                    rgh[i],
                    IOCTL_VOLUME_GET_GPT_ATTRIBUTES,
                    NULL,
                    0,
                    &getAttributesInfo,
                    sizeof(getAttributesInfo),
                    &size,
                    NULL
                    ))
                {
                DWORD dwErr = GetLastError();
                if (dwErr == ERROR_INVALID_FUNCTION)
                    continue;

                ft.hr = HRESULT_FROM_WIN32(dwErr);
                ft.CheckForError(VSSDBG_VSSTEST, L"DeviceIoControl(IOCTL_VOLUME_GET_GPT_ATTRIBUTES)");
                }

            memset(&setAttributesInfo, 0, sizeof(setAttributesInfo));
            setAttributesInfo.GptAttributes = getAttributesInfo.GptAttributes;
            setAttributesInfo.ApplyToAllConnectedVolumes = TRUE;
            if (fHide)
                {
                setAttributesInfo.GptAttributes |= GPT_BASIC_DATA_ATTRIBUTE_HIDDEN|GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY|GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER;
                if (!DeviceIoControl
                        (
                        rgh[i],
                        IOCTL_VOLUME_SET_GPT_ATTRIBUTES,
                        &setAttributesInfo,
                        sizeof(setAttributesInfo),
                        NULL,
                        0,
                        &size,
                        NULL
                        ))
                    {
                    DWORD dwErr = GetLastError();
                    if (dwErr == ERROR_INVALID_FUNCTION)
                        continue;

                    ft.hr = HRESULT_FROM_WIN32(dwErr);
                    ft.CheckForError(VSSDBG_VSSTEST, L"DeviceIoControl(IOCTL_VOLUME_SET_GPT_ATTRIBUTES)");
                    }
                }

            if (fExpose)
                {
                setAttributesInfo.GptAttributes &= ~GPT_BASIC_DATA_ATTRIBUTE_HIDDEN;
                if (!DeviceIoControl
                        (
                        rgh[i],
                        IOCTL_VOLUME_SET_GPT_ATTRIBUTES,
                        &setAttributesInfo,
                        sizeof(setAttributesInfo),
                        NULL,
                        0,
                        &size,
                        NULL
                        ))
                    {
                    ft.hr = HRESULT_FROM_WIN32(GetLastError());
                    ft.CheckForError(VSSDBG_VSSTEST, L"DeviceIoControl(IOCTL_VOLUME_SET_GPT_ATTRIBUTES)");
                    }
                }
            }
        }
    }


// copy a storage device id descriptor to the VDS_LUN_INFORMATION structure.
// note that lun is modified whether an execption occurs or not.  FreeLunInfo
// will free up any data allocated here.
void CHardwareTestProvider::CopyStorageDeviceIdDescriptorToLun
    (
    IN STORAGE_DEVICE_ID_DESCRIPTOR *pDevId,
    IN VDS_LUN_INFORMATION *pLun
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::CopyStorageDeviceIdDescriptorToLun");

    BS_ASSERT(StorageIdTypeVendorSpecific == VDSStorageIdTypeVendorSpecific);
    BS_ASSERT(StorageIdTypeVendorId == VDSStorageIdTypeVendorId);
    BS_ASSERT(StorageIdTypeEUI64 == VDSStorageIdTypeEUI64);
    BS_ASSERT(StorageIdTypeFCPHName == VDSStorageIdTypeFCPHName);
    BS_ASSERT(StorageIdCodeSetAscii == VDSStorageIdCodeSetAscii);
    BS_ASSERT(StorageIdCodeSetBinary == VDSStorageIdCodeSetBinary);

    // get count of ids
    DWORD cIds = pDevId->NumberOfIdentifiers;

    // copy over version number and count of ids
    pLun->m_deviceIdDescriptor.m_version = pDevId->Version;
    pLun->m_deviceIdDescriptor.m_cIdentifiers = cIds;

    // allocate array of identifiers
    pLun->m_deviceIdDescriptor.m_rgIdentifiers =
        (VDS_STORAGE_IDENTIFIER *) CoTaskMemAlloc(sizeof(VDS_STORAGE_IDENTIFIER) * cIds);

    if (pLun->m_deviceIdDescriptor.m_rgIdentifiers == NULL)
        ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Cannot allocate device id descriptors");

    // clear descriptor.  If we throw, we want to make sure that all pointers
    // are null
    memset(pLun->m_deviceIdDescriptor.m_rgIdentifiers, 0, sizeof(VDS_STORAGE_IDENTIFIER) * cIds);

    // get pointer to first identifier in both STORAGE_DEVICE_ID_DESCRIPTOR and
    // VDS_STORAGE_DEVICE_ID_DESCRIPTOR
    STORAGE_IDENTIFIER *pId = (STORAGE_IDENTIFIER *) pDevId->Identifiers;
    VDS_STORAGE_IDENTIFIER *pvsi = (VDS_STORAGE_IDENTIFIER *) pLun->m_deviceIdDescriptor.m_rgIdentifiers;

    for(UINT i = 0; i < cIds; i++)
        {
        // copy over size of identifier
        pvsi->m_cbIdentifier = pId->IdentifierSize;

        // allocate space for identifier
        pvsi->m_rgbIdentifier = (BYTE *) CoTaskMemAlloc(pvsi->m_cbIdentifier);
        if (pvsi->m_rgbIdentifier == NULL)
            ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Cannot allocate storage identifier");

        // copy type and code set over
        pvsi->m_Type = (VDS_STORAGE_IDENTIFIER_TYPE) pId->Type;
        pvsi->m_CodeSet = (VDS_STORAGE_IDENTIFIER_CODE_SET) pId->CodeSet;

        // copy identifier
        memcpy(pvsi->m_rgbIdentifier, pId->Identifier, pvsi->m_cbIdentifier);

        // move to next identifier
        pId = (STORAGE_IDENTIFIER *) ((BYTE *) pId + pId->NextOffset);
        pvsi++;
        }
    }

void CHardwareTestProvider::RebuildLunInfo()
    {
    for(DWORD iDisk = 0; iDisk < m_cDiskIds; iDisk++)
        {
        DWORD diskId;
        bool bIsDynamic;

        if (m_rgpSourceLuns[iDisk] == NULL && TranslateDisk(m_rgSourceDiskIds[iDisk], diskId, bIsDynamic))
            BuildLunInfoForDisk(diskId, &m_rgpSourceLuns[iDisk], &m_rgcSourcePartitions[iDisk]);

        if (m_rgpDestinationLuns[iDisk] == NULL && TranslateDisk(m_rgDestinationDiskIds[iDisk], diskId, bIsDynamic))
            BuildLunInfoForDisk(diskId, &m_rgpDestinationLuns[iDisk], &m_rgcDestinationPartitions[iDisk]);
        }
    }

DWORD hexconvert(LPCWSTR wsz)
    {
    DWORD dwRet = 0;
    while (*wsz != L'\0')
        {
        dwRet *= 16;
        if (*wsz >= L'0' && *wsz <= L'9')
            dwRet += *wsz - L'0';
        else if (*wsz >= L'a' && *wsz <= L'f')
            dwRet += *wsz - L'a' + 10;
        else if (*wsz >= L'A' && *wsz <= L'F')
            dwRet += *wsz - L'A' + 10;

        wsz++;
        }

    return dwRet;
    }



void CHardwareTestProvider::LoadConfigurationData()
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::LoadConfigurationData");

    VSS_PWSZ wszSourceDisks = NULL;
    VSS_PWSZ wszDestinationDisks = NULL;
    m_cDiskIds = 0;
    try
        {
        CVssRegistryKey key;
        key.Open(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Services\\HardwareTestProvider");
        key.GetValue(L"SourceDisks", wszSourceDisks);
        key.GetValue(L"DestinationDisks", wszDestinationDisks);
        LPWSTR wszSource = wszSourceDisks;
        LPWSTR wszDestination = wszDestinationDisks;

        if (wszSource != NULL && wszDestination != NULL)
            {
            while(*wszSource != L'\0' && *wszDestination != L'\0')
                {
                WCHAR *wszSourceNext = wcschr(wszSource, L',');
                WCHAR *wszDestinationNext = wcschr(wszDestination, L',');
                if (wszSourceNext != NULL)
                    *wszSourceNext = L'\0';

                if (wszDestinationNext != NULL)
                    *wszDestinationNext = L'\0';

                int Source = hexconvert(wszSource);
                int Destination = hexconvert(wszDestination);
                m_rgSourceDiskIds[m_cDiskIds] = Source;
                m_rgDestinationDiskIds[m_cDiskIds] = Destination;
                m_cDiskIds++;

                if (m_cDiskIds == 32)
                    break;

                if (wszSourceNext == NULL || wszDestinationNext == NULL)
                    break;

                wszSource = wszSourceNext + 1;
                wszDestination = wszDestinationNext + 1;
                }
            }

        RebuildSignatures();
        m_bRebuilt = true;
        RebuildLunInfo();
        }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ClearConfiguration();

    if (wszSourceDisks)
        CoTaskMemFree(wszSourceDisks);

    if (wszDestinationDisks)
        CoTaskMemFree(wszDestinationDisks);
    }



void CHardwareTestProvider::BuildLunInfoForDisk
    (
    IN DWORD Drive,
    OUT VDS_LUN_INFORMATION **ppLunInfo,
    OUT DWORD *pcPartitions
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::BuildLunInfoForDisk");

    WCHAR wszbuf[32];
    swprintf(wszbuf, L"\\\\.\\PHYSICALDRIVE%u", Drive);
    CVssAutoWin32Handle hDisk = CreateFile
                    (
                    wszbuf,
                    GENERIC_READ|GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    if (hDisk != INVALID_HANDLE_VALUE)
        BuildLunInfoFromDrive(hDisk, ppLunInfo, *pcPartitions);
    }

void CHardwareTestProvider::ClearConfiguration()
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::ClearConfiguration");

    for(DWORD i = 0; i < m_cDiskIds; i++)
        {
        if (m_rgpSourceLuns[i] != NULL)
            {
            FreeLunInfo(m_rgpSourceLuns[i], 1);
            m_rgpSourceLuns[i] = NULL;
            }

        if (m_rgpDestinationLuns[i] != NULL)
            {
            FreeLunInfo(m_rgpDestinationLuns[i], 1);
            m_rgpDestinationLuns[i] = NULL;
            }
        }

    m_cDiskIds = 0;
    }

// add a lun to a file indicating the luns that were freed
void CHardwareTestProvider::AddFreedLun(LPCWSTR wsz)
    {
    DWORD Drive;
    swscanf(wsz, L"\\\\.\\PHYSICALDRIVE%u", &Drive);

    WCHAR buf[MAX_PATH * 2];
    if (!GetSystemDirectory(buf, sizeof(buf)/sizeof(WCHAR)))
        {
        wprintf(L"GetSystemDirectory failed due to error %d.\n", GetLastError());
        throw E_UNEXPECTED;
        }

    wcscat(buf, L"\\VSNAP_DELETED_LUNS");

    HANDLE h = CreateFile
                    (
                    buf,
                    GENERIC_READ|GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_ALWAYS,
                    0,
                    NULL
                    );

    if (h == INVALID_HANDLE_VALUE)
        return;

    if (SetFilePointer(h, 0, NULL, FILE_END) != 0xffffffff)
        {
        DWORD dwWritten;
        WriteFile(h, &Drive, sizeof(DWORD), &dwWritten, NULL);
        }

    CloseHandle(h);
    }

bool CHardwareTestProvider::TranslateDisk(DWORD signature, DWORD &DiskId, bool &bIsDynamic)
    {
    while(TRUE)
        {
        for(UINT iDisk = 0; iDisk < MAXDISKS; iDisk++)
            {
            if (m_rgDiskSignatures[iDisk] == signature)
                {
                if (GetDiskSignature(iDisk, bIsDynamic) != signature)
                    break;

                DiskId = iDisk;
                return true;
                }
            }

        // rebuild signatures if we haven't done so already
        if (m_bRebuilt)
            break;

        RebuildSignatures();
        m_bRebuilt = true;
        }

    return false;
    }

DWORD CHardwareTestProvider::GetDiskSignature(DWORD iDisk, bool &bIsDynamic)
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::GetDiskSignature");

    LPBYTE buf = NULL;
    DWORD cbOut = 1024;

    bIsDynamic = false;

    WCHAR wszBuf[64];
    swprintf(wszBuf, L"\\\\.\\PHYSICALDRIVE%u", iDisk);

    CVssAutoWin32Handle hDisk = CreateFile
                                (
                                wszBuf,
                                GENERIC_READ|GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL
                                );

    if (hDisk == INVALID_HANDLE_VALUE)
        return 0;

    if (!DoDeviceIoControl
            (
            hDisk,
            IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
            NULL,
            0,
            &buf,
            &cbOut
            ))
        return 0;

    DRIVE_LAYOUT_INFORMATION_EX *pLayout = (DRIVE_LAYOUT_INFORMATION_EX *) buf;
    ULONG cPartitions = pLayout->PartitionCount;
    for(ULONG iPartition = 0; iPartition < cPartitions; iPartition++)
        {
        if (pLayout->PartitionEntry[iPartition].Mbr.PartitionType == PARTITION_LDM)
            bIsDynamic = true;
        }

    if (pLayout->PartitionStyle == PARTITION_STYLE_MBR)
        return pLayout->Mbr.Signature;
    else
        return 0;

    }


void CHardwareTestProvider::RebuildSignatures()
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::RebuildSignatures");

    for(UINT iDisk = 0; iDisk < MAXDISKS; iDisk++)
        {
        bool bIsDynamic;

        m_rgDiskSignatures[iDisk] = GetDiskSignature(iDisk, bIsDynamic);
        if (bIsDynamic)
            AddDynamicDiskInfo(m_rgDiskSignatures[iDisk], iDisk);
        }

    }

void CHardwareTestProvider::AddDynamicDiskInfo(DWORD signature, DWORD disk)
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::AddDynamicDiskInfo");

    DYNAMIC_DISK_INFO *pInfo = m_pDynamicDiskInfo;
    while(pInfo != NULL)
        {
        if (pInfo->m_signature == signature)
            break;

        pInfo = pInfo->m_next;
        }

    // dynamic volumes already found, do nothing
    if (pInfo)
        return;

    LPBYTE bufExtents = NULL;
    DWORD cbBufExtents = 1024;

    LPWSTR buf = new WCHAR[8192];
    if (buf == NULL)
        ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Cannot allocate string");

    LPWSTR wszVolumes = new WCHAR[256];
    if (wszVolumes == NULL)
        {
        delete buf;
        ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Cannot allocate string");
        }

    wszVolumes[0] = L'\0';
    UINT cwcVolumes = 256;
    UINT iwcVolumes = 0;


    HANDLE hFind = FindFirstVolume(buf, 8192);
    try
        {
        if (hFind == INVALID_HANDLE_VALUE)
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_VSSTEST, L"FindVolume");
            }

        while(TRUE)
            {
            // get rid of trailing backslash
            buf[wcslen(buf) - 1] = L'\0';
            CVssAutoWin32Handle hVol = CreateFile
                                        (
                                        buf,
                                        GENERIC_READ,
                                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL
                                        );


            DWORD dwErr = GetLastError();

            if (hVol != INVALID_HANDLE_VALUE)
                {
                if (DoDeviceIoControl
                        (
                        hVol,
                        IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                        NULL,
                        0,
                        &bufExtents,
                        &cbBufExtents
                        ))
                    {
                    VOLUME_DISK_EXTENTS *pDiskExtents = (VOLUME_DISK_EXTENTS *) bufExtents;
                    DWORD cExtents = pDiskExtents->NumberOfDiskExtents;
                    for(DWORD iExtent = 0; iExtent < cExtents; iExtent++)
                        {
                        if (pDiskExtents->Extents[iExtent].DiskNumber == disk)
                            {
                            UINT cwc = (UINT) wcslen(buf) + 1;
                            if (cwc + iwcVolumes + 1 > cwcVolumes)
                                {
                                LPWSTR wszNew = new WCHAR[cwc + iwcVolumes + 256];
                                if (wszNew == NULL)
                                    ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"cannot grow string");

                                wcscpy(wszNew, wszVolumes);
                                delete wszVolumes;
                                wszNew = wszVolumes;
                                cwcVolumes = iwcVolumes + cwc + 256;
                                }

                            wcscpy(wszVolumes + iwcVolumes, buf);
                            iwcVolumes += cwc;

                            // double null terminate MULTI_SZ string
                            wszVolumes[iwcVolumes + 1] = L'\0';
                            break;
                            }
                        }
                    }
                }

            if (!FindNextVolume(hFind, buf, 8192))
                {
                DWORD dwErr = GetLastError();
                if (dwErr == ERROR_NO_MORE_FILES)
                    break;

                ft.hr = HRESULT_FROM_WIN32(dwErr);
                ft.CheckForError(VSSDBG_VSSTEST, L"FindNextVolume");
                }
            }
        }
    catch(...)
        {
        delete bufExtents;
        delete buf;
        delete wszVolumes;
        FindVolumeClose(hFind);
        throw;
        }

    delete bufExtents;
    delete buf;
    FindVolumeClose(hFind);

    if (wcslen(wszVolumes) == 0)
        delete wszVolumes;
    else
        {
        DYNAMIC_DISK_INFO *pInfo = new DYNAMIC_DISK_INFO;
        if (pInfo == NULL)
            {
            delete wszVolumes;
            ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"cannot allocate DYNAMIC_DISK_INFO");
            }

        pInfo->m_signature = signature;
        pInfo->m_wszVolumes = wszVolumes;
        pInfo->m_next = m_pDynamicDiskInfo;
        m_pDynamicDiskInfo = pInfo;
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\hwprv\vsnap\debug.h ===
// Execute the given call and check that the return code must be S_OK
#define CHECK_SUCCESS( Call )                                                                           \
    {                                                                                                   \
        hr = Call;                                                                                    \
        if (hr != S_OK)                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }

#define CHECK_NOFAIL( Call )                                                                            \
    {                                                                                                   \
        hr = Call;                                                                                    \
        if (FAILED(hr))                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }



void Error(INT nReturnCode,
           const WCHAR * pwszMsgFormat,
           ...);
LPCWSTR GetStringFromFailureType(HRESULT hrStatus);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\hwprv\src\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cxx | The file used to compile the precompiled header
    @end

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.

--*/


#include "stdafx.hxx"
#include "hwprv.hxx"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#pragma warning( disable: 4189 )  /* local variable is initialized but not referenced */
#include <atlimpl.cpp>
#pragma warning( default: 4189 )  /* local variable is initialized but not referenced */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\hwprv\vsnap\debug.cpp ===
#include "stdafx.hxx"
#include "vss.h"
#include "vswriter.h"
#include "vsbackup.h"
#include <debug.h>


LPCWSTR
GetStringFromFailureType(HRESULT hrStatus)
{
    LPCWSTR pwszFailureType = L"";

    switch (hrStatus) {
        case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:
            pwszFailureType = L"VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT";
            break;
        case VSS_E_WRITERERROR_OUTOFRESOURCES:
            pwszFailureType = L"VSS_E_WRITERERROR_OUTOFRESOURCES";
            break;
        case VSS_E_WRITERERROR_TIMEOUT:
            pwszFailureType = L"VSS_E_WRITERERROR_TIMEOUT";
            break;
        case VSS_E_WRITERERROR_NONRETRYABLE:
            pwszFailureType = L"VSS_E_WRITERERROR_NONRETRYABLE";
            break;
        case VSS_E_WRITERERROR_RETRYABLE:
            pwszFailureType = L"VSS_E_WRITERERROR_RETRYABLE";
            break;
        case VSS_E_BAD_STATE:
            pwszFailureType = L"VSS_E_BAD_STATE";
            break;
        case VSS_E_PROVIDER_ALREADY_REGISTERED:
            pwszFailureType = L"VSS_E_PROVIDER_ALREADY_REGISTERED";
            break;
        case VSS_E_PROVIDER_NOT_REGISTERED:
            pwszFailureType = L"VSS_E_PROVIDER_NOT_REGISTERED";
            break;
        case VSS_E_PROVIDER_VETO:
            pwszFailureType = L"VSS_E_PROVIDER_VETO";
            break;
        case VSS_E_PROVIDER_IN_USE:
            pwszFailureType = L"VSS_E_PROVIDER_IN_USE";
            break;
        case VSS_E_OBJECT_NOT_FOUND:
            pwszFailureType = L"VSS_E_OBJECT_NOT_FOUND";
            break;
        case VSS_S_ASYNC_PENDING:
            pwszFailureType = L"VSS_S_ASYNC_PENDING";
            break;
        case VSS_S_ASYNC_FINISHED:
            pwszFailureType = L"VSS_S_ASYNC_FINISHED";
            break;
        case VSS_S_ASYNC_CANCELLED:
            pwszFailureType = L"VSS_S_ASYNC_CANCELLED";
            break;
        case VSS_E_VOLUME_NOT_SUPPORTED:
            pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED";
            break;
        case VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER:
            pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER";
            break;
        case VSS_E_OBJECT_ALREADY_EXISTS:
            pwszFailureType = L"VSS_E_OBJECT_ALREADY_EXISTS";
            break;
        case VSS_E_UNEXPECTED_PROVIDER_ERROR:
            pwszFailureType = L"VSS_E_UNEXPECTED_PROVIDER_ERROR";
            break;
        case VSS_E_CORRUPT_XML_DOCUMENT:
            pwszFailureType = L"VSS_E_CORRUPT_XML_DOCUMENT";
            break;
        case VSS_E_INVALID_XML_DOCUMENT:
            pwszFailureType = L"VSS_E_INVALID_XML_DOCUMENT";
            break;
        case VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED:
            pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED";
            break;
        case VSS_E_FLUSH_WRITES_TIMEOUT:
            pwszFailureType = L"VSS_E_FLUSH_WRITES_TIMEOUT";
            break;
        case VSS_E_HOLD_WRITES_TIMEOUT:
            pwszFailureType = L"VSS_E_HOLD_WRITES_TIMEOUT";
            break;
        case VSS_E_UNEXPECTED_WRITER_ERROR:
            pwszFailureType = L"VSS_E_UNEXPECTED_WRITER_ERROR";
            break;
        case VSS_E_SNAPSHOT_SET_IN_PROGRESS:
            pwszFailureType = L"VSS_E_SNAPSHOT_SET_IN_PROGRESS";
            break;
        case VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED:
            pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED";
            break;
        case VSS_E_WRITER_INFRASTRUCTURE:
            pwszFailureType = L"VSS_E_WRITER_INFRASTRUCTURE";
            break;
        case VSS_E_WRITER_NOT_RESPONDING:
            pwszFailureType = L"VSS_E_WRITER_NOT_RESPONDING";
            break;
        case VSS_E_WRITER_ALREADY_SUBSCRIBED:
            pwszFailureType = L"VSS_E_WRITER_ALREADY_SUBSCRIBED";
            break;
        case VSS_E_UNSUPPORTED_CONTEXT:
            pwszFailureType = L"VSS_E_UNSUPPORTED_CONTEXT";
            break;

        case NOERROR:
        default:
            break;
    }

    return (pwszFailureType);
}


// This function displays the formatted message at the console and throws
// The passed return code will be returned by vsreq.exe
void
Error(IN INT nReturnCode,
      IN const WCHAR * pwszMsgFormat,
      IN ...
    )
{
    va_list marker;
    va_start(marker, pwszMsgFormat);
    vwprintf(pwszMsgFormat, marker);
    va_end(marker);

//    BS_ASSERT(FALSE);
    // throw that return code.
    throw(nReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\hwprv\vsnap\main.cpp ===
#include "stdafx.hxx"
#include "vs_idl.hxx"
#include "vswriter.h"
#include "vsbackup.h"
#include "vs_inc.hxx"
#include "vs_debug.hxx"
#include "vs_trace.hxx"
#include <debug.h>
#include <time.h>
#include <partmgrp.h>


typedef enum VSNAP_OPS {
    VSOP_CREATE_SNAPSHOT_SET,
    VSOP_DELETE_SNAPSHOT_SET,
    VSOP_DELETE_SNAPSHOT,
    VSOP_BREAK_SNAPSHOT_SET,
    VSOP_IMPORT_SNAPSHOT_SET,
    VSOP_EXPOSE_SNAPSHOT_LOCALLY,
    VSOP_EXPOSE_SNAPSHOT_REMOTELY,
    VSOP_PRINT_SNAPSHOT_PROPERTIES,
    VSOP_RESCAN,
    VSOP_DISPLAY_DISKS,
    VSOP_DISPLAY_PHYSICAL_DISK,
    VSOP_FLUSH_PHYSICAL_DISK
};

typedef struct _PARSEDARG {
    LONG lContext;
    LPWSTR wszVolumes;
    VSNAP_OPS op;
    VSS_ID idOp;
    LPWSTR wszExpose;
    LPWSTR wszPathFromRoot;
    LPWSTR wszFilename;
    DWORD diskno;
} PARSEDARG;


extern void DoRescanForDeviceChanges();

void DeleteFreedLunsFile();
void PrintPartitionAttributes(DWORD disk,
                              DWORD partition);
void
ReadFreedLunsFile()
{
    WCHAR buf[MAX_PATH * 2];
    if (!GetSystemDirectory(buf, sizeof(buf) / sizeof(WCHAR))) {
        wprintf(L"GetSystemDirectory failed due to error %d.\n",
                GetLastError());
        throw E_UNEXPECTED;
    }
    wcscat(buf, L"\\VSNAP_DELETED_LUNS");

    HANDLE h = CreateFile(buf,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          0,
                          NULL);

    if (h == INVALID_HANDLE_VALUE)
        return;

    DWORD dwRead;

    // read as much as is in the file
    if (!ReadFile(h, buf, sizeof(buf), &dwRead, NULL)) {
        wprintf(L"Read failed due to error %d.\n", GetLastError());
        throw E_UNEXPECTED;
    }

    if (dwRead > 0)
        wprintf(L"\n");

    for (UINT i = 0; i < dwRead; i += sizeof(DWORD)) {
        DWORD disk = *(DWORD *) ((BYTE *) buf + i);
        wprintf(L"Freed disk %d.\n", disk);
    }

    CloseHandle(h);
}




// perform a device i/o control, growing the buffer if necessary
BOOL DoDeviceIoControl(IN HANDLE hDevice,       // handle

                       IN DWORD ioctl,  // device ioctl to perform

                       IN const LPBYTE pbQuery, // input buffer

                       IN DWORD cbQuery,        // size of input buffer

                       IN OUT LPBYTE * ppbOut,  // pointer to output buffer

                       IN OUT DWORD * pcbOut    // pointer to size of output buffer
    ) {
    // loop in case buffer is too small for query result.
    while (TRUE) {
        DWORD dwSize;
        if (*ppbOut == NULL) {
            // allocate buffer for result of query
            *ppbOut = new BYTE[*pcbOut];
            if (*ppbOut == NULL)
                throw E_OUTOFMEMORY;
        }

        // do query
        if (!DeviceIoControl
            (hDevice,
             ioctl, pbQuery, cbQuery, *ppbOut, *pcbOut, &dwSize, NULL)) {
            // query failed
            DWORD dwErr = GetLastError();

            if (dwErr == ERROR_INVALID_FUNCTION ||
                dwErr == ERROR_NOT_SUPPORTED || dwErr == ERROR_NOT_READY)
                return FALSE;


            if (dwErr == ERROR_INSUFFICIENT_BUFFER || dwErr == ERROR_MORE_DATA) {
                // buffer wasn't big enough allocate a new
                // buffer of the specified return size
                delete *ppbOut;
                *ppbOut = NULL;
                *pcbOut *= 2;
                continue;
            }

            // all other errors are remapped (and potentially logged)
            throw E_UNEXPECTED;
        }

        break;
    }

    return TRUE;
}


void
FreeSnapshotProperty(VSS_SNAPSHOT_PROP & prop)
{
    if (prop.m_pwszSnapshotDeviceObject)
        VssFreeString(prop.m_pwszSnapshotDeviceObject);

    if (prop.m_pwszOriginalVolumeName)
        VssFreeString(prop.m_pwszOriginalVolumeName);

    if (prop.m_pwszOriginatingMachine)
        VssFreeString(prop.m_pwszOriginatingMachine);

    if (prop.m_pwszExposedName)
        VssFreeString(prop.m_pwszExposedName);

    if (prop.m_pwszExposedPath)
        VssFreeString(prop.m_pwszExposedPath);
}


BOOL
AssertPrivilege(LPCWSTR privName)
{
    HANDLE tokenHandle;
    BOOL stat = FALSE;

    if (OpenProcessToken(GetCurrentProcess(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &tokenHandle)) {
        LUID value;

        if (LookupPrivilegeValue(NULL, privName, &value)) {
            TOKEN_PRIVILEGES newState;
            DWORD error;

            newState.PrivilegeCount = 1;
            newState.Privileges[0].Luid = value;
            newState.Privileges[0].Attributes =
                SE_PRIVILEGE_ENABLED_BY_DEFAULT | SE_PRIVILEGE_ENABLED;

            /*
               * We will always call GetLastError below, so clear
               * any prior error values on this thread.
             */
            SetLastError(ERROR_SUCCESS);

            stat = AdjustTokenPrivileges
                (tokenHandle, FALSE, &newState, (DWORD) 0, NULL, NULL);

            /*
               * Supposedly, AdjustTokenPriveleges always returns TRUE
               * (even when it fails). So, call GetLastError to be
               * extra sure everything's cool.
             */
            if ((error = GetLastError()) != ERROR_SUCCESS)
                stat = FALSE;

            if (!stat) {
                wprintf
                    (L"AdjustTokenPrivileges for %s failed with %d",
                     privName, error);
            }
        }

    }


    return stat;
}


void
Usage()
{
    wprintf(L"vsnap [options]\n where options are:\n");
    wprintf(L"\t[volume list]");
    wprintf(L"\t[volume list]\n");
    wprintf(L"\t-p\n");
    wprintf(L"\t-ad\n");
    wprintf(L"\t-ap\n");
    wprintf(L"\t -t=filename [volumelist]\n");
    wprintf(L"\t-i=filename\n");
    wprintf(L"\t-ds={snapshot id}\n");
    wprintf(L"\t-dx={snapshot set id}\n");
    wprintf(L"\t-b={snapshot set id}\n");
    wprintf(L"\t-s={snapshot id}\n");
    wprintf(L"\t-el={snapshot id},localname\n");
    wprintf(L"\t-er={snapshot id},sharename[,path from root]\n\n");

    wprintf(L"\twhere [volumelist] is a list of volumes.  When just a\n");
    wprintf(L"\tvolume list is provided the snapshot set is created and\n");
    wprintf(L"\timported locally.\n\n");

    wprintf
        (L"\twhere -p specifies that the snapshot should be persistent.\n\n");

    wprintf
        (L"\twhere -ad specifies that the snapshot should be differential\n");
    wprintf
        (L"\twhere -ap specifies that the snapshot should be plex\n\n");

    wprintf(L"\twhere -t=filename x: y: z: is used to export a snapshot set\n");
    wprintf
        (L"\tfilename is file to store XML data for exported snapshot set\n");
    wprintf
        (L"\tand x: y: z: are any number of volume names separated by spaces.\n\n");

    wprintf(L"\twhere -i=filename is used to import a previously exported\n");
    wprintf(L"\tsnapshot set.  filename is the XML of saved when the\n");
    wprintf(L"\tsnapshot set was created.\n\n");

    wprintf(L"\twhere -ds={snapshot id} is used to delete the specified\n");
    wprintf(L"\tsnapshot.\n\n");

    wprintf(L"\twhere -dx={snapshot set id} is used to delete the specified\n");
    wprintf(L"\tsnapshot set.\n\n");

    wprintf(L"\twhere -b={snapshot set id} is used to break the specified\n");
    wprintf
        (L"\tsnapshot set.  When a snapshot set is broken, all information\n");
    wprintf
        (L"\tabout the snapshot set is lost, but the volumes are retained.\n\n");

    wprintf(L"\twhere -s={snapshot id} is used to display the properties\n");
    wprintf(L"\tof the snapshot.\n\n");

    wprintf(L"\twhere -el={snapshot id},localname is used to expose the\n");
    wprintf(L"\tsnapshot as a drive name or mount point.  Localname can be\n");
    wprintf(L"\ta drive letter, e.g., x:, or a mount point,\n");
    wprintf(L"\te.g. c:\\mountpoint\n\n");

    wprintf(L"\twhere -er={snapshot id},share[,path from root] is used\n");
    wprintf(L"\tto expose a snapshot as a share. Share is any valid share\n");
    wprintf(L"\tname and \"path from root\" is an optional path from the\n");
    wprintf(L"\troot of the volume to be exposed.  For example,\n");
    wprintf(L"\tvsnap -er={...},myshare,windows\\system32 would expose\n");
    wprintf
        (L"\t\\windows\\system32 on the snapshotted volume as share myshare.\n");
}





void ProcessArguments(
    int argc,
    WCHAR ** argv,
    PARSEDARG & arg
    ) 
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST,
                          L"ProcessArguments");
    LPWSTR wszCopy = arg.wszVolumes;

    arg.lContext = 0; //VSS_CTX_FILE_SHARE_BACKUP;
    arg.op = VSOP_CREATE_SNAPSHOT_SET;
    for (int iarg = 1; iarg < argc; iarg++) {
        LPWSTR wszArg = argv[iarg];
        if (wszArg[0] == L'-' || wszArg[0] == L'/') {
            if (wszArg[1] == L't') {
                arg.lContext |= VSS_VOLSNAP_ATTR_TRANSPORTABLE;
                if (wszArg[2] != L'=') {
                    wprintf(L"bad option: %s\n", wszArg);
                    Usage();
                    throw E_INVALIDARG;
                }

                arg.wszFilename = wszArg + 3;
            }
            else if (wszArg[1] == L'p')
                arg.lContext |=
                    VSS_VOLSNAP_ATTR_PERSISTENT |
                    VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE;
            else if (wszArg[1] == L'r') {
                if (wszArg[2] == L'p' || wszArg[2] == L'f') {
                    arg.op =
                        wszArg[2] ==
                        L'p' ? VSOP_DISPLAY_PHYSICAL_DISK :
                        VSOP_FLUSH_PHYSICAL_DISK;
                    if (wszArg[3] != L'=') {
                        wprintf(L"bad option: %s.\n", wszArg);
                        Usage();
                        throw E_INVALIDARG;
                    }

                    swscanf(wszArg + 4, L"%d", &arg.diskno);
                }
                else if (wszArg[2] == L'd')
                    arg.op = VSOP_DISPLAY_DISKS;
                else
                    arg.op = VSOP_RESCAN;
            }
            else if (wszArg[1] == L'd') {
                if (wszArg[2] == L'x')
                    arg.op = VSOP_DELETE_SNAPSHOT_SET;
/*                else if (wszArg[2] == L'f') {
                    CVssID id;
                    arg.op = VSOP_DELETE_SNAPSHOT_SET;
                    FILE *fp = fopen("c:\\vssdebug\\snaplist.txt", "r");
                    WCHAR szGuid[100];
                    if (fp) {
                        try {
                            fwscanf(fp, L"%ws", szGuid);
                            id.Initialize(ft, szGuid, E_INVALIDARG);
                            arg.idOp = id;
                            fclose(fp);
                        }
                        catch(...) {
                            wprintf(L"bad option: %s.\n", wszArg);
                            Usage();
                            throw E_INVALIDARG;
                        }
                    }
                    else 
                        throw E_INVALIDARG;
                }
 */               else
                    arg.op = VSOP_DELETE_SNAPSHOT;


                if (wszArg[2] != L'f') {

                    if (wszArg[3] != L'=' && wszArg[4] != L'{') {
                        wprintf(L"bad option: %s.\n", wszArg);
                        Usage();
                        throw E_INVALIDARG;
                    }

                    CVssID id;
                    try {
                        id.Initialize(ft, wszArg + 4, E_INVALIDARG);
                        arg.idOp = id;
                    }
                    catch(...) {
                        wprintf(L"bad option: %s.\n", wszArg);
                        Usage();
                        throw E_INVALIDARG;
                    }
                }

                break;
            }
            else if (wszArg[1] == L'b' ||
                     wszArg[1] == L'w' || wszArg[1] == L's') {
                if (wszArg[2] != L'=' && wszArg[3] != L'{') {
                    wprintf(L"bad option: %s.\n", wszArg);
                    Usage();
                    throw E_INVALIDARG;
                }

                CVssID id;
                try {
                    id.Initialize(ft, wszArg + 3, E_INVALIDARG);
                    arg.idOp = id;
                }
                catch(...) {
                    wprintf(L"bad option: %s.\n", wszArg);
                    Usage();
                    throw E_INVALIDARG;
                }

                switch (wszArg[1]) {
                    case 'b':
                        arg.op = VSOP_BREAK_SNAPSHOT_SET;
                        break;

                    default:
                        arg.op = VSOP_PRINT_SNAPSHOT_PROPERTIES;
                        break;
                }

                break;
            }
            else if (wszArg[1] == L'i') {
                if (wszArg[2] != L'=') {
                    wprintf(L"bad option: %s.\n", wszArg);
                    Usage();
                    throw E_INVALIDARG;
                }

                arg.op = VSOP_IMPORT_SNAPSHOT_SET;
                arg.wszFilename = wszArg + 3;
                break;
            }
            else if (wszArg[1] == L'a') {
                if (wszArg[2] == L'd')
                    arg.lContext |= VSS_VOLSNAP_ATTR_DIFFERENTIAL;
                else if (wszArg[2] == L'p')
                    arg.lContext |= VSS_VOLSNAP_ATTR_PLEX;
                else {
                    wprintf(L"bad option: %s.\n", wszArg);
                    Usage();
                    throw E_INVALIDARG;
                }
            }
            else if (wszArg[1] == L'e') {
                if (wszArg[2] == L'l')
                    arg.op = VSOP_EXPOSE_SNAPSHOT_LOCALLY;
                else if (wszArg[2] == L'r')
                    arg.op = VSOP_EXPOSE_SNAPSHOT_REMOTELY;
                else {
                    wprintf(L"bad option: %s.\n", wszArg);
                    Usage();
                    throw E_INVALIDARG;
                }

                if (wszArg[3] != L'=' && wszArg[4] == L'{') {
                    wprintf(L"bad option: %s.\n", wszArg);
                    Usage();
                    throw E_INVALIDARG;
                }

                arg.wszExpose = wcschr(wszArg + 4, L'}');
                if (arg.wszExpose == NULL) {
                    wprintf(L"bad option: %s.\n", wszArg);
                    Usage();
                    throw E_INVALIDARG;
                }

                arg.wszExpose++;
                if (*arg.wszExpose == L',') {
                    *(arg.wszExpose) = L'\0';
                    arg.wszExpose += 1;
                }
                else {
                    wprintf(L"bad option: %s.\n", wszArg);
                    Usage();
                    throw E_INVALIDARG;
                }

                arg.wszPathFromRoot = wcschr(arg.wszExpose, L',');
                if (arg.wszPathFromRoot != NULL) {
                    *(arg.wszPathFromRoot) = L'\0';
                    arg.wszPathFromRoot += 1;
                    if (wcslen(arg.wszPathFromRoot) == 0)
                        arg.wszPathFromRoot = NULL;
                }


                CVssID id;
                try {
                    id.Initialize(ft, wszArg + 4, E_INVALIDARG);
                    arg.idOp = id;
                }
                catch(...) {
                    wprintf(L"bad option: %s.\n", wszArg);
                    Usage();
                    throw E_INVALIDARG;
                }


                break;
            }
            else {
                wprintf(L"bad option: %s\n", wszArg);
                Usage();
                throw E_INVALIDARG;
            }
        }
        else {
            WCHAR wsz[64];
            WCHAR wszVolume[256];

            wcscpy(wszVolume, wszArg);
            if (wszVolume[wcslen(wszVolume) - 1] != L'\\') {
                wszVolume[wcslen(wszVolume) + 1] = L'\0';
                wszVolume[wcslen(wszVolume)] = L'\\';
            }

            if (!GetVolumeNameForVolumeMountPoint(wszVolume, wsz, 64)) {
                wprintf(L"Invalid volume name: %s", wszArg);
                Usage();
                throw E_INVALIDARG;
            }

            wcscpy(wszCopy, wsz);
            wszCopy += wcslen(wszCopy) + 1;
        }
    }

    *wszCopy = L'\0';
}

void
PrintSnapshotProperties(VSS_SNAPSHOT_PROP & prop)
{
    LONG lAttributes = prop.m_lSnapshotAttributes;
    wprintf(L"Properties for snapshot " WSTR_GUID_FMT L"\n",
            GUID_PRINTF_ARG(prop.m_SnapshotId));

    wprintf(L"Snapshot Set: " WSTR_GUID_FMT L"\n",
            GUID_PRINTF_ARG(prop.m_SnapshotSetId));

    wprintf(L"Original count of snapshots = %d\n", prop.m_lSnapshotsCount);
    wprintf(L"Original Volume name: %s\n", prop.m_pwszOriginalVolumeName);
    wprintf(L"Snapshot device name: %s\n", prop.m_pwszSnapshotDeviceObject);
    wprintf(L"Originating machine: %s\n", prop.m_pwszOriginatingMachine);
    wprintf(L"Service machine: %s\n", prop.m_pwszServiceMachine);
    if (prop.m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY)
        wprintf(L"Exposed locally as: %s\n", prop.m_pwszExposedName);
    else if (prop.m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY) {
        wprintf(L"Exposed remotely as %s\n", prop.m_pwszExposedName);
        if (prop.m_pwszExposedPath && wcslen(prop.m_pwszExposedPath) > 0)
            wprintf(L"Path exposed: %s\n", prop.m_pwszExposedPath);
    }

    wprintf(L"Provider id: " WSTR_GUID_FMT L"\n",
            GUID_PRINTF_ARG(prop.m_ProviderId));
    wprintf(L"Attributes: ");
    if (lAttributes & VSS_VOLSNAP_ATTR_TRANSPORTABLE)
        wprintf(L"Transportable ");
    if (lAttributes & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE)
        wprintf(L"No Auto Release ");
    else
        wprintf(L"Auto Release ");

    if (lAttributes & VSS_VOLSNAP_ATTR_PERSISTENT)
        wprintf(L"Persistent ");

    if (lAttributes & VSS_VOLSNAP_ATTR_HARDWARE_ASSISTED)
        wprintf(L"Hardware ");

    if (lAttributes & VSS_VOLSNAP_ATTR_NO_WRITERS)
        wprintf(L"No Writers ");

    if (lAttributes & VSS_VOLSNAP_ATTR_IMPORTED)
        wprintf(L"Imported ");

    if (lAttributes & VSS_VOLSNAP_ATTR_PLEX)
        wprintf(L"Plex ");
    
    if (lAttributes & VSS_VOLSNAP_ATTR_DIFFERENTIAL)
        wprintf(L"Differential ");
    
    wprintf(L"\n");
}


/*++

Description:

    Uses the win32 console functions to get one character of input.

--*/
WCHAR
MyGetChar()
{
    DWORD fdwOldMode, fdwMode;
    HANDLE hStdin;
    WCHAR chBuffer[2];

    hStdin =::GetStdHandle(STD_INPUT_HANDLE);
    if (hStdin == INVALID_HANDLE_VALUE) {
        wprintf(L"GetStdHandle failed due to reason %d.\n", GetLastError());
        throw E_UNEXPECTED;
    }

    if (!::GetConsoleMode(hStdin, &fdwOldMode)) {
        wprintf(L"GetConsoleMode failed due to reason %d.\n", GetLastError());
        throw E_UNEXPECTED;
    }


    fdwMode = fdwOldMode & ~(ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT);
    if (!::SetConsoleMode(hStdin, fdwMode)) {
        wprintf(L"SetConsoleMode failed due to reason %d.\n", GetLastError());
        throw E_UNEXPECTED;
    }


    // Flush the console input buffer to make sure there is no queued input
    ::FlushConsoleInputBuffer(hStdin);

    // Without line and echo input modes, ReadFile returns
    // when any input is available.
    DWORD dwBytesRead;
    if (!::ReadConsoleW(hStdin, chBuffer, 1, &dwBytesRead, NULL)) {
        wprintf(L"ReadConsoleW failed due to reason %d.\n", GetLastError());
        throw E_UNEXPECTED;
    }


    // Restore the original console mode.
    ::SetConsoleMode(hStdin, fdwOldMode);

    return chBuffer[0];
}



DWORD
StartImportThread(LPVOID pv)
{
    HANDLE hevt = (HANDLE) pv;
    HANDLE hImportSignal = NULL;
    HANDLE hImportSignalCompleted = NULL;
    try {
        hImportSignal =
            CreateEvent(NULL, TRUE, FALSE, L"Global\\VSNAP_START_IMPORT");
        if (hImportSignal == NULL) {
            wprintf(L"Cannot create event due to error %d.\n", GetLastError());
            throw E_OUTOFMEMORY;
        }

        hImportSignalCompleted =
            CreateEvent(NULL, TRUE, FALSE,
                        L"Global\\VSNAP_START_IMPORT_COMPLETED");
        if (hImportSignalCompleted == NULL) {
            wprintf(L"Cannot create event due to error %d.\n", GetLastError());
            throw E_OUTOFMEMORY;
        }


        if (!SetEvent(hevt)) {
            wprintf(L"Set event failed for reason %d.\n", GetLastError());
            throw E_UNEXPECTED;
        }

        if (WaitForSingleObject(hImportSignal, INFINITE) == WAIT_FAILED) {
            wprintf(L"Wait failed for reason %d.\n", GetLastError());
            throw E_UNEXPECTED;
        }

        wprintf(L"Please import Target luns at this point.\n"
                L"Press Y when done.\n");

        while (TRUE) {
            WCHAR wc = MyGetChar();
            if (wc == L'Y' || wc == L'y')
                break;
            else
                wprintf(L"Press Y when done.\n");
        }

        wprintf(L"Import continuing.\n");

        if (!SetEvent(hImportSignalCompleted)) {
            wprintf(L"SetEvent failed due to error %d.\n", GetLastError());
            throw E_UNEXPECTED;
        }
    }
    catch(...) {
    }

    if (hImportSignal)
        CloseHandle(hImportSignal);

    if (hImportSignalCompleted)
        CloseHandle(hImportSignalCompleted);

    return 0;
}




void
SetupImportThread()
{
    HANDLE hevt = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hevt == NULL) {
        wprintf(L"Cannot Create event due to error %d.\n", GetLastError());
        throw E_OUTOFMEMORY;
    }

    DWORD tid;
    HANDLE hThread = CreateThread(NULL,
                                  0,
                                  StartImportThread,
                                  (LPVOID) hevt,
                                  0,
                                  &tid);

    if (hThread == NULL) {
        wprintf(L"Cannot Create thread due to error %d.\n", GetLastError());
        throw E_OUTOFMEMORY;
    }

    if (WaitForSingleObject(hevt, INFINITE) == WAIT_FAILED) {
        wprintf(L"Wait failed for reason %d.\n", GetLastError());
        throw E_UNEXPECTED;
    }

    CloseHandle(hThread);
    CloseHandle(hevt);
}



extern "C" __cdecl
wmain(int argc,
      WCHAR ** argv)
{
    WCHAR wszVolumes[2048];
    HRESULT hr;
    HRESULT hrReturned = S_OK;

    bool bCoInitializeSucceeded = false;

    try {
        PARSEDARG arg;

        arg.wszVolumes = wszVolumes;

        ProcessArguments(argc, argv, arg);
        CHECK_SUCCESS(CoInitializeEx(NULL, COINIT_MULTITHREADED));
        bCoInitializeSucceeded = true;

        if (!AssertPrivilege(SE_BACKUP_NAME)) {
            wprintf(L"AssertPrivilege returned error, rc:%d\n", GetLastError());
            return 2;
        }

        DeleteFreedLunsFile();

        CComPtr < IVssBackupComponents > pvbc;
        CComPtr < IVssAsync > pAsync;
        HRESULT hrResult;

        if (arg.op != VSOP_IMPORT_SNAPSHOT_SET &&
            arg.op != VSOP_RESCAN &&
            arg.op != VSOP_DISPLAY_DISKS &&
            arg.op != VSOP_DISPLAY_PHYSICAL_DISK &&
            arg.op != VSOP_FLUSH_PHYSICAL_DISK) {
            CHECK_SUCCESS(CreateVssBackupComponents(&pvbc));
            CHECK_SUCCESS(pvbc->InitializeForBackup());
        }

        if (arg.op == VSOP_RESCAN ||
            arg.op == VSOP_DISPLAY_DISKS ||
            arg.op == VSOP_DISPLAY_PHYSICAL_DISK ||
            arg.op == VSOP_FLUSH_PHYSICAL_DISK) {
            if (arg.op == VSOP_RESCAN) {
                wprintf(L"Starting Rescan\n");
                DoRescanForDeviceChanges();
                wprintf(L"Rescan complete\n");
            }
            if (arg.op == VSOP_DISPLAY_PHYSICAL_DISK ||
                arg.op == VSOP_FLUSH_PHYSICAL_DISK) {
                WCHAR wszBuf[64];
                swprintf(wszBuf, L"\\\\.\\PHYSICALDRIVE%u", arg.diskno);
                HANDLE hDisk = CreateFile(wszBuf,
                                          GENERIC_READ | GENERIC_WRITE,
                                          FILE_SHARE_READ,
                                          NULL,
                                          OPEN_EXISTING,
                                          0,
                                          NULL);


                if (hDisk == INVALID_HANDLE_VALUE) {
                    DWORD dwErr = GetLastError();
                    wprintf(L"Create file failed due to error %d.\n", dwErr);
                }
                else if (arg.op == VSOP_FLUSH_PHYSICAL_DISK) {
                    DWORD dwSize;
                    STORAGE_DEVICE_NUMBER devNumber;

                    if (!DeviceIoControl
                        (hDisk,
                         IOCTL_DISK_UPDATE_PROPERTIES,
                         NULL, 0, NULL, 0, &dwSize, NULL)) {
                        DWORD dwErr = GetLastError();
                        wprintf
                            (L"DeviceIoControl(IOCTL_DISK_UPDATE_PROPERTIES failed %d.\n",
                             dwErr);
                    }

                    wprintf(L"Flush disk %d succeeded.\n", arg.diskno);

                    LPBYTE buf = NULL;
                    DWORD cbOut = 1024;

                    DoDeviceIoControl
                        (hDisk,
                         IOCTL_DISK_GET_DRIVE_LAYOUT_EX, NULL, 0, &buf, &cbOut);

                    delete buf;
                    CloseHandle(hDisk);
                }
                else {
                    wprintf(L"Disk %d exists.\n", arg.diskno);
                    LPBYTE buf = NULL;
                    DWORD cbOut = 1024;
                    STORAGE_PROPERTY_QUERY query;

                    query.PropertyId = StorageDeviceProperty;
                    query.QueryType = PropertyStandardQuery;

                    if (DoDeviceIoControl
                        (hDisk,
                         IOCTL_STORAGE_QUERY_PROPERTY,
                         (LPBYTE) & query, sizeof(query), &buf, &cbOut)) {
                        STORAGE_DEVICE_DESCRIPTOR *pDesc =
                            (STORAGE_DEVICE_DESCRIPTOR *) buf;

                        LPSTR szVendor =
                            (LPSTR) ((LPBYTE) pDesc + pDesc->VendorIdOffset);
                        LPSTR szProduct =
                            (LPSTR) ((LPBYTE) pDesc + pDesc->ProductIdOffset);
                        LPSTR szSerial =
                            (LPSTR) ((LPBYTE) pDesc +
                                     pDesc->SerialNumberOffset);
                        printf("\nVendor=%s\nProduct=%s\nSerial #=%s\n",
                               szVendor, szProduct, szSerial);
                    }


                    delete buf;
                    CloseHandle(hDisk);
                }

            }
            else {
                for (UINT iDisk = 0; iDisk < 64; iDisk++) {
                    WCHAR wszBuf[64];
                    swprintf(wszBuf, L"\\\\.\\PHYSICALDRIVE%u", iDisk);
                    HANDLE hDisk = CreateFile(wszBuf,
                                              0,
                                              FILE_SHARE_READ,
                                              NULL,
                                              OPEN_EXISTING,
                                              0,
                                              NULL);


                    if (hDisk != INVALID_HANDLE_VALUE) {
                        wprintf(L"Disk %d exists.\n", iDisk);
                        LPBYTE buf = NULL;
                        DWORD cbOut = 1024;

                        if (DoDeviceIoControl
                            (hDisk,
                             IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                             NULL, 0, &buf, &cbOut)) {
                            DRIVE_LAYOUT_INFORMATION_EX *pLayout =
                                (DRIVE_LAYOUT_INFORMATION_EX *) buf;
                            if (pLayout->PartitionStyle == PARTITION_STYLE_MBR)
                                wprintf(L"MBR Signature = 0x%08lx\n\n",
                                        pLayout->Mbr.Signature);
                            else
                                wprintf(L"GPT GUID = " WSTR_GUID_FMT L"\n",
                                        GUID_PRINTF_ARG(pLayout->Gpt.DiskId));

                            for (UINT iPartition = 0;
                                 iPartition < pLayout->PartitionCount;
                                 iPartition++) {
                                if (pLayout->PartitionEntry[iPartition].
                                    PartitionLength.QuadPart == 0)
                                    continue;

                                PrintPartitionAttributes(iDisk, iPartition + 1);
                            }

                            wprintf(L"\n");
                        }

                        delete buf;
                        CloseHandle(hDisk);
                    }
                }
            }
        }
        else if (arg.op == VSOP_DELETE_SNAPSHOT_SET ||
                 arg.op == VSOP_DELETE_SNAPSHOT) {
            LONG lSnapshots;
            VSS_ID idNonDeleted;

            CHECK_SUCCESS(pvbc->SetContext(VSS_CTX_ALL));

            CHECK_SUCCESS(pvbc->DeleteSnapshots
                          (arg.idOp,
                           (arg.op ==
                            VSOP_DELETE_SNAPSHOT) ? VSS_OBJECT_SNAPSHOT :
                           VSS_OBJECT_SNAPSHOT_SET, FALSE, &lSnapshots,
                           &idNonDeleted))

                if (arg.op == VSOP_DELETE_SNAPSHOT)
                wprintf(L"Successfully deleted snapshot " WSTR_GUID_FMT L".\n",
                        GUID_PRINTF_ARG(arg.idOp));
            else
                wprintf(L"Successfully deleted snapshot set " WSTR_GUID_FMT
                        L".\n", GUID_PRINTF_ARG(arg.idOp));

        }
        else if (arg.op == VSOP_BREAK_SNAPSHOT_SET) {
            CHECK_SUCCESS(pvbc->BreakSnapshotSet(arg.idOp));
            wprintf(L"Successfully eliminated snapshot set " WSTR_GUID_FMT
                    L".\n", GUID_PRINTF_ARG(arg.idOp));
        }
        else if (arg.op == VSOP_EXPOSE_SNAPSHOT_LOCALLY) {
            CHECK_SUCCESS(pvbc->SetContext(VSS_CTX_ALL));
            LPWSTR wszExposed;
            CHECK_SUCCESS(pvbc->ExposeSnapshot
                          (arg.idOp,
                           NULL,
                           VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY,
                           arg.wszExpose, &wszExposed));
            wprintf(L"Exposed snapshot " WSTR_GUID_FMT L"as %s.\n",
                    GUID_PRINTF_ARG(arg.idOp), wszExposed);

            CoTaskMemFree(wszExposed);
        }
        else if (arg.op == VSOP_EXPOSE_SNAPSHOT_REMOTELY) {
            CHECK_SUCCESS(pvbc->SetContext(VSS_CTX_ALL));
            LPWSTR wszExposed;
            CHECK_SUCCESS(pvbc->ExposeSnapshot
                          (arg.idOp,
                           arg.wszPathFromRoot,
                           VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY,
                           wcslen(arg.wszExpose) == 0 ? NULL : arg.wszExpose,
                           &wszExposed));
            wprintf(L"Exposed snapshot " WSTR_GUID_FMT L"as %s.\n",
                    GUID_PRINTF_ARG(arg.idOp), wszExposed);

            CoTaskMemFree(wszExposed);
        }
        else if (arg.op == VSOP_IMPORT_SNAPSHOT_SET) {
            CVssAutoWin32Handle hFile = CreateFile(arg.wszFilename,
                                                   GENERIC_READ,
                                                   FILE_SHARE_READ,
                                                   NULL,
                                                   OPEN_EXISTING,
                                                   NULL,
                                                   NULL);

            if (hFile == INVALID_HANDLE_VALUE) {
                DWORD dwErr = GetLastError();
                wprintf(L"Cannot open file %s due to error %d.\n",
                        arg.wszFilename, dwErr);

                throw HRESULT_FROM_WIN32(dwErr);
            }

            DWORD cbFile;
            cbFile = GetFileSize(hFile, NULL);
            if (cbFile == 0xffffffff) {
                DWORD dwErr = GetLastError();
                wprintf(L"Cannot get file size for file %s due to error %d.\n",
                        arg.wszFilename, dwErr);

                throw HRESULT_FROM_WIN32(dwErr);
            }

            CComBSTR bstr((cbFile + 1) / sizeof(WCHAR));
            if (!bstr) {
                wprintf(L"Out of memory allocating string of size %d.\n",
                        (cbFile + 1) / sizeof(WCHAR));
                throw E_OUTOFMEMORY;
            }

            DWORD dwRead;
            if (!ReadFile(hFile, bstr, cbFile, &dwRead, NULL)) {
                DWORD dwErr = GetLastError();
                wprintf(L"Read file failed on file %s due to error %d.\n",
                        arg.wszFilename, dwErr);

                throw HRESULT_FROM_WIN32(dwErr);
            }

            CHECK_SUCCESS(CreateVssBackupComponents(&pvbc));
            CHECK_SUCCESS(pvbc->InitializeForBackup(bstr));
            SetupImportThread();
            CHECK_SUCCESS(pvbc->ImportSnapshots(&pAsync));
            CHECK_SUCCESS(pAsync->Wait());
            CHECK_SUCCESS(pAsync->QueryStatus(&hrResult, NULL));
            CHECK_NOFAIL(hrResult);
            wprintf(L"Import of snapshot set from file %s was successful.\n",
                    arg.wszFilename);

            CComPtr < IVssEnumObject > pEnum;
            CHECK_SUCCESS(pvbc->SetContext(VSS_CTX_ALL));
            CHECK_SUCCESS(pvbc->
                          Query(GUID_NULL, VSS_OBJECT_NONE, VSS_OBJECT_SNAPSHOT,
                                &pEnum));
            // print imported snapshots
            wprintf(L"Imported snapshots:\n\n");

/*            FILE *fp = fopen("c:\\vssdebug\\snaplist.txt", "w");
            int i = 0;
*/            
            while (TRUE) {
                VSS_OBJECT_PROP prop;
                ULONG cFetched;
                HRESULT hrNext = pEnum->Next(1, &prop, &cFetched);
                CHECK_NOFAIL(hrNext);
                if (hrNext == S_FALSE)
                    break;

                BS_ASSERT(cFetched == 1);
                BS_ASSERT(prop.Type == VSS_OBJECT_SNAPSHOT);
                if ((prop.Obj.Snap.
                     m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_IMPORTED) != 0) {
                    PrintSnapshotProperties(prop.Obj.Snap);

                    wprintf(L"\n");
                    
                }

                CoTaskMemFree(prop.Obj.Snap.m_pwszSnapshotDeviceObject);
                CoTaskMemFree(prop.Obj.Snap.m_pwszOriginalVolumeName);
                CoTaskMemFree(prop.Obj.Snap.m_pwszOriginatingMachine);
                CoTaskMemFree(prop.Obj.Snap.m_pwszServiceMachine);
                CoTaskMemFree(prop.Obj.Snap.m_pwszExposedName);
                CoTaskMemFree(prop.Obj.Snap.m_pwszExposedPath);
            }

/*            if (fp) {
                fclose(fp);
            }
*/        }
        else if (arg.op == VSOP_PRINT_SNAPSHOT_PROPERTIES) {
            CHECK_SUCCESS(pvbc->SetContext(VSS_CTX_ALL));
            VSS_SNAPSHOT_PROP prop;
            CHECK_SUCCESS(pvbc->GetSnapshotProperties(arg.idOp, &prop));
            PrintSnapshotProperties(prop);
        }
        else {
            if ((arg.lContext & VSS_VOLSNAP_ATTR_TRANSPORTABLE) == 0)
                SetupImportThread();

            unsigned cWriters;
            
//            CHECK_NOFAIL(pvbc->InitializeForBackup());
            CHECK_SUCCESS(pvbc->SetBackupState( false, true, VSS_BT_FULL, false));

            CHECK_SUCCESS(pvbc->GatherWriterMetadata(&pAsync));
            CHECK_SUCCESS(pAsync->Wait());

            hrReturned = S_OK;
            CHECK_SUCCESS(pAsync->QueryStatus(&hrReturned, NULL));
            
            CHECK_NOFAIL(hrReturned);
            pAsync = NULL;

            CHECK_NOFAIL  (pvbc->GetWriterMetadataCount (&cWriters));
            wprintf(L"Number of writers that responded: %u\n", cWriters);	

            CHECK_SUCCESS (pvbc->FreeWriterMetadata());


    
            CHECK_SUCCESS(pvbc->SetContext(arg.lContext));
            VSS_ID SnapshotSetId;
            CHECK_SUCCESS(pvbc->StartSnapshotSet(&SnapshotSetId));
            wprintf(L"Creating snapshot set " WSTR_GUID_FMT L"\n",
                    GUID_PRINTF_ARG(SnapshotSetId));
            VSS_ID rgSnapshotId[64];
            UINT cSnapshots = 0;
            LPWSTR wsz = wszVolumes;
            while (*wsz != L'\0') {
                CHECK_SUCCESS(pvbc->AddToSnapshotSet
                              (wsz, GUID_NULL, &rgSnapshotId[cSnapshots]
                              ));


                wprintf(L"Added volume %s to snapshot set" WSTR_GUID_FMT L"\n",
                        wsz, GUID_PRINTF_ARG(SnapshotSetId));
                wsz += wcslen(wszVolumes) + 1;
                cSnapshots++;
            }

            CHECK_SUCCESS(pvbc->PrepareForBackup(&pAsync));
            CHECK_SUCCESS(pAsync->Wait());
            hrReturned = S_OK;
            CHECK_SUCCESS(pAsync->QueryStatus(&hrReturned, NULL));
            CHECK_NOFAIL(hrReturned);
            pAsync = NULL;
            

            CHECK_SUCCESS(pvbc->DoSnapshotSet(&pAsync));
            CHECK_SUCCESS(pAsync->Wait());
            CHECK_SUCCESS(pAsync->QueryStatus(&hrResult, NULL));
            CHECK_NOFAIL(hrResult);
            pAsync = NULL;
            wprintf(L"Snapshot set " WSTR_GUID_FMT L" successfully created.\n",
                    GUID_PRINTF_ARG(SnapshotSetId));
            if ((arg.lContext & VSS_VOLSNAP_ATTR_TRANSPORTABLE) != 0) {
                CComBSTR bstrXML;
                CHECK_SUCCESS(pvbc->SaveAsXML(&bstrXML));
                CVssAutoWin32Handle hFile = CreateFile(arg.wszFilename,
                                                       GENERIC_WRITE,
                                                       0,
                                                       NULL,
                                                       CREATE_ALWAYS,
                                                       NULL,
                                                       NULL);

                if (hFile == INVALID_HANDLE_VALUE) {
                    DWORD dwErr = GetLastError();
                    wprintf(L"Cannot open file %s due to error %d.\n",
                            arg.wszFilename, dwErr);

                    throw HRESULT_FROM_WIN32(dwErr);
                }

                DWORD dwWritten;
                DWORD cbWrite = (wcslen(bstrXML) + 1) * sizeof(WCHAR);
                if (!WriteFile(hFile, bstrXML, cbWrite, &dwWritten, NULL)) {
                    DWORD dwErr = GetLastError();
                    wprintf(L"Write file of file %s failed due to error %d.\n",
                            arg.wszFilename, dwErr);

                    throw HRESULT_FROM_WIN32(dwErr);
                }
                else if (dwWritten != cbWrite) {
                    wprintf
                        (L"Write of file %s was incompute due to disk full condition.\n",
                         arg.wszFilename);

                    throw HRESULT_FROM_WIN32(ERROR_DISK_FULL);
                }
            }
            else {
                for (UINT iSnapshot = 0; iSnapshot < cSnapshots; iSnapshot++) {
                    VSS_ID SnapshotId = rgSnapshotId[iSnapshot];
                    VSS_SNAPSHOT_PROP prop;
                    CHECK_SUCCESS(pvbc->
                                  GetSnapshotProperties(SnapshotId, &prop));
                    wprintf(L"Snapshot " WSTR_GUID_FMT
                            L"\nOriginalVolume: %s\nSnapshotVolume: %s\n",
                            GUID_PRINTF_ARG(SnapshotId),
                            prop.m_pwszOriginalVolumeName,
                            prop.m_pwszSnapshotDeviceObject);

                    FreeSnapshotProperty(prop);
                }
            }
        }

        pvbc = NULL;
        pAsync = NULL;

        ReadFreedLunsFile();
    }
    catch(HRESULT hr) {
    }
    catch(...) {
        BS_ASSERT(FALSE);
        hr = E_UNEXPECTED;
    }

    if (FAILED(hr))
        wprintf(L"Failed with %08x.\n", hr);

    if (bCoInitializeSucceeded)
        CoUninitialize();

    return (0);
}

void
DeleteFreedLunsFile()
{
    WCHAR buf[MAX_PATH * 2];
    if (!GetSystemDirectory(buf, sizeof(buf) / sizeof(WCHAR))) {
        wprintf(L"GetSystemDirectory failed due to error %d.\n",
                GetLastError());
        throw E_UNEXPECTED;
    }
    wcscat(buf, L"\\VSNAP_DELETED_LUNS");
    DeleteFile(buf);
}


void
PrintPartitionAttributes(DWORD disk,
                         DWORD partition)
{
    WCHAR volName[128];

    swprintf
        (volName,
         L"\\\\?\\GlobalRoot\\Device\\Harddisk%d\\Partition%d",
         disk, partition);

    HANDLE h = CreateFile(volName,
                          0,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);

    if (h == INVALID_HANDLE_VALUE)
        return;

    DWORD size;
    VOLUME_GET_GPT_ATTRIBUTES_INFORMATION getAttributesInfo;

    if (!DeviceIoControl
        (h,
         IOCTL_VOLUME_GET_GPT_ATTRIBUTES,
         NULL, 0, &getAttributesInfo, sizeof(getAttributesInfo), &size, NULL)) {
        CloseHandle(h);
        return;
    }

    wprintf(L"Partition %d: ", partition);
    if (getAttributesInfo.GptAttributes & GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY)
        wprintf(L"ReadOnly ");

    if (getAttributesInfo.GptAttributes & GPT_BASIC_DATA_ATTRIBUTE_HIDDEN)
        wprintf(L"Hidden ");

    if (getAttributesInfo.
        GptAttributes & GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER)
        wprintf(L"No Drive Letter");

    wprintf(L"\n");
    CloseHandle(h);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\hwprv\vsnap\rescan.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Abstract:

    @doc
    @module rescan.cxx | Implementation of the CVssHWProviderWrapper methods to do a scsi rescan
    @end

Author:

    Brian Berkowitz  [brianb]  05/22/01

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    brianb      05/21/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "setupapi.h"
#include "rpc.h"
#include "cfgmgr32.h"
#include "devguid.h"
#include "vssmsg.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vss.h"
#include "vscoordint.h"




////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORRESCC"
//


// forward declarations
BOOL DeviceInstanceToDeviceId(IN DEVINST devinst, OUT LPWSTR *deviceId);

BOOL GetDevicePropertyString(IN DEVINST devinst, IN ULONG propCode, OUT LPWSTR *data);

DEVINST DeviceIdToDeviceInstance(LPWSTR deviceId);

BOOL ReenumerateDevices(IN DEVINST deviceInstance);

BOOL GuidFromString(IN LPCWSTR GuidString, OUT GUID *Guid);



////////////////////////////////////////////////////////////////////////
// We will enumerate those device ids that belong to GUID_DEVCLASS_SCSIADAPTER
//  According to Lonny, all others are not needed at all.
//  This will of cource speed up enumeration
//  An excerpt of his mail is shown below
//  Other classes of interest include:
//   PCMCIA,
//  There should be no need to manually force a re-enumeration of PCMCIA
//  devices, since PCMCIA automatically detects/reports cards the moment they
//  arrive.
//
//   HDC,
//  The only way IDE devices can come or go (apart from PCMCIA IDE devices
//  covered under the discussion above) is via ACPI.  In that case, too,
//  hot-plug notification is given, thus there's no need to go and manually
//  re-enumerate.
//
//   MULTI_FUNCTION_ADAPTER,
//  There are two types of multifunction devices--those whose children are
//  enumerated via a bus-standard multi-function mechanism, and those whose
//  children a enumerated based on registry information.  In the former case, it
//  is theoretically possible that you'd need to do a manual re-enumeration in
//  order to cause the bus to find any new multi-function children.  In reality,
//  however, there are no such situations today.  In the latter case, there's no
//  point at all, since it's the registry spooge that determines what children
//  get exposed, not the bus driver.
//
//  Bottom line--I don't think that manual enumeration is necessary for any
//  (setup) class today except ScsiAdapter.  Ideally, the list of devices
//  requiring re-enumeration would be based on interface class instead.  Thus,
//  each device (regardless of setup class) that requires manual re-enumeration
//  in order to detect newly-arrived disks would expose an interface.  This
//  interface wouldn't need to actually be opened, it'd just be a mechanism to
//  enumerate such devices.  Given that ScsiAdapter is the only class today that
//  needs this functionality, and given the fact that all new hot-plug busses
//  actually report the device as soon as it arrives, we probably don't need to
//  go to this extra trouble.
//
void DoRescanForDeviceChanges()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CHardwareProviderWrapper::DoRescanForDeviceChanges");

    //  the following algorithm will be used
    //  a) Get all the deviceIds
    //  b) For each deviceId, get the class guid
    //  c) If the class GUID matches any of the following:
    //      GUID_DEVCLASS_SCSIADAPTER
    //    then get the devinst of the devidId and enumerate the devinst


    CONFIGRET result;
    GUID guid;
    ULONG length;
    LPWSTR deviceList = NULL;
    PWSTR ptr = NULL;
    DEVINST devinst;

    result = CM_Get_Device_ID_List_Size_Ex
                (
                &length,
                NULL, // No enumerator
                CM_GETIDLIST_FILTER_NONE,
                NULL
                );

    if (result != CR_SUCCESS)
        {
        ft.Trace(VSSDBG_COORD, L"unable to do rescan, cannot get buffer size");
        return;
        }

    // allocate device list
    deviceList = new WCHAR[length];
    if (!deviceList)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate string");

    result = CM_Get_Device_ID_List_Ex
                (
                NULL,
                deviceList,
                length,
                CM_GETIDLIST_FILTER_NONE,
                NULL
                );

    if (result != CR_SUCCESS)
        {
        // delete device list and return
        delete deviceList;
        ft.Trace(VSSDBG_COORD, L"Cannot get device list");
        return;
        }

    ptr = deviceList;

    while (ptr && *ptr)
        {
        LPWSTR TempString;

        devinst = DeviceIdToDeviceInstance(ptr);
        if (GetDevicePropertyString(devinst, SPDRP_CLASSGUID, &TempString))
            {
            if (GuidFromString(TempString, &guid))
                {
                if (guid == GUID_DEVCLASS_SCSIADAPTER)
                    // cause rescan on a scsi adapter
                    ReenumerateDevices(devinst);
                }

            delete TempString;
            }

        ptr = ptr + (wcslen(ptr) + 1);
        }

    if (deviceList)
        delete [] deviceList;
    }

// This routine converts the character representation of a GUID into its binary
// form (a GUID struct).  The GUID is in the following form:
//
//  {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
//
//    where 'x' is a hexadecimal digit.
//
//  If the function succeeds, the return value is NO_ERROR.
//  If the function fails, the return value is RPC_S_INVALID_STRING_UUID.
BOOL GuidFromString
    (
    IN LPCWSTR GuidString,
    OUT GUID *Guid
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CHardwareProviderWrapper::GuidFromString");

    // length of guid string
    const GUID_STRING_LEN = 39;

    WCHAR UuidBuffer[GUID_STRING_LEN - 1];

    if(*GuidString++ != L'{' || lstrlen(GuidString) != GUID_STRING_LEN - 2)
        return FALSE;

    // copy string into buffer
    lstrcpy(UuidBuffer, GuidString);

    if (UuidBuffer[GUID_STRING_LEN - 3] != L'}')
        return FALSE;

    // null out terminating bracket
    UuidBuffer[GUID_STRING_LEN - 3] = L'\0';
    return ((UuidFromString(UuidBuffer, Guid) == RPC_S_OK) ? TRUE : FALSE);
    }


// Given the device Id this routine will enumerate all the devices under
// it. Example, given a scsi adapter ID it will find new disks.
// This function uses the user mode PNP manager.
// Returns TRUE on success.
BOOL ReenumerateDevices
    (
    IN DEVINST deviceInstance
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"ReenumerateDevices");
    CONFIGRET result;
    BOOL bResult = TRUE;

    result = CM_Reenumerate_DevNode_Ex(deviceInstance, CM_REENUMERATE_SYNCHRONOUS, NULL);

    bResult = (result == CR_SUCCESS ? TRUE : FALSE);
    if (!bResult)
        ft.Trace(VSSDBG_COORD, L"CM_Reenumerate_DevNode returned an error");

    return bResult;
    }



// Given a deviceId return the device instance (handle)
// returns 0 on a failure
DEVINST DeviceIdToDeviceInstance(LPWSTR deviceId)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"DeviceIdToDeviceInstance");

    CONFIGRET result;
    DEVINST devinst = 0;

    BS_ASSERT(deviceId != NULL);
    result = CM_Locate_DevNode(&devinst, deviceId,CM_LOCATE_DEVNODE_NORMAL | CM_LOCATE_DEVNODE_PHANTOM);
    if (result == CR_SUCCESS)
        return devinst;

    return 0;
    }



// Given the devinst, query the PNP subsystem for a property.
// This function can only be used if the property value is a string.
// propCodes supported are: SPDRP_DEVICEDESC, SPDRP_CLASSGUID,
// SPDRP_FRIENDLYNAME.
BOOL GetDevicePropertyString
    (
    IN DEVINST devinst,
    IN ULONG propCode,
    OUT LPWSTR *data
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"GetDevicePropertyString");

    BOOL bResult = FALSE;
    HDEVINFO DeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfo;
    ULONG reqSize = 0;
    LPWSTR deviceIdString = NULL;

    BS_ASSERT(data);

    // null out output parameter
    *data = NULL;
    if (!devinst)
        return bResult;

    // compute maximum size of output string
    switch(propCode)
        {
        case (SPDRP_DEVICEDESC):
            reqSize = LINE_LEN + 1;
            break;

        case (SPDRP_CLASSGUID):
            reqSize = MAX_GUID_STRING_LEN + 1;
            break;

        case (SPDRP_FRIENDLYNAME):
            reqSize = MAX_PATH + 1;
            break;

        default:
            return bResult;
        }

    // get device id string
    if (!DeviceInstanceToDeviceId(devinst, &deviceIdString))
        return bResult;

    // allocate string
    *data = new WCHAR[reqSize];
    if ((*data) == NULL)
        {
        delete deviceIdString;
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate string.");
        }

    // clear string
    memset (*data, 0, reqSize * sizeof(WCHAR));

    DeviceInfoSet = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (DeviceInfoSet == INVALID_HANDLE_VALUE)
        ft.Trace (VSSDBG_COORD, L"SetupDiCreateDeviceInfoList failed: %lx", GetLastError());
    else
        {
        DeviceInfo.cbSize = sizeof(SP_DEVINFO_DATA);
        if (SetupDiOpenDeviceInfo
                (
                DeviceInfoSet,
                deviceIdString,
                NULL,
                0,
                &DeviceInfo
                ))
            {
            if (SetupDiGetDeviceRegistryProperty
                    (
                    DeviceInfoSet,
                    &DeviceInfo,
                    propCode,
                    NULL,
                    (PBYTE)*data,
                    reqSize*sizeof(WCHAR),
                    NULL
                    ))
                bResult = TRUE;
            else
                ft.Trace (VSSDBG_COORD, L"SetupDiGetDeviceRegistryProperty failed: %lx", GetLastError());
            }
        else
            ft.Trace (VSSDBG_COORD, L"SetupDiOpenDeviceInfo failed: %lx", GetLastError());

        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
        }

    if (!bResult)
        {
        delete *data;
        *data = NULL;
        }

    delete deviceIdString;
    return bResult;
    }



// given a device instance handle set the deviceId
// return TRUE on success FALSE otherwise
BOOL DeviceInstanceToDeviceId
    (
    IN DEVINST devinst,
    OUT LPWSTR *deviceId
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"DeviceInstanceToDeviceId");

    CONFIGRET result;
    BOOL bResult = FALSE;
    DWORD size;

    // null out output parameter
    *deviceId = NULL;
    result = CM_Get_Device_ID_Size_Ex(&size, devinst, 0, NULL);

    if (result != CR_SUCCESS)
        return FALSE;

    // allocate space for string
    *deviceId = new WCHAR[size + 1];

    // check for allocation failure
    if (!(*deviceId))
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate string.");

    // clear string
    memset(*deviceId, 0, (size + 1) * sizeof(WCHAR));
    result = CM_Get_Device_ID
                    (
                    devinst,
                    *deviceId,
                    size + 1,
                    0
                    );

    if (result == CR_SUCCESS)
        bResult = TRUE;
    else
        {
        // delete string on failure
        delete *deviceId;
        *deviceId = NULL;
        }

    return bResult;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\jettest\stdafx.h ===
#include <wtypes.h>
#pragma warning( disable: 4201 )    // C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning( default: 4201 )	// C4201: nonstandard extension used : nameless struct/union
#include <winbase.h>



#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <stdio.h>
#include <stdlib.h>

#include <vs_assert.hxx>

#include <stddef.h>
#include <atlconv.h>
#include <atlbase.h>
CComModule _Module;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\metasnap\metasnap.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	metasnap.cpp
**
**
** Abstract:
**
**	Test program to obtain and display the Writer metadata.
**
**
** Author:
**
**	Michael C. Johnson   [mikejohn]        21-Jul-2000
**
**	(Based on another test program BETEST by Brian Berkowitz)
**
**
** Revision History:
**
**--
*/

/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/
#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>


#include <oleauto.h>

#define ATLASSERT(_condition)

#include <atlconv.h>
#include <atlbase.h>

extern CComModule _Module;
#include <atlcom.h>



inline void CHECK_SUCCESS (HRESULT hr)
    {
    if (hr != S_OK)
	{
	wprintf(L"operation failed with HRESULT =0x%08x\n", hr);
	DebugBreak();
	}
    }

inline void CHECK_NOFAIL (HRESULT hr)
    {
    if (FAILED(hr))
	{
	wprintf(L"operation failed with HRESULT =0x%08x\n", hr);
	DebugBreak();
	}
    }



BOOL AssertPrivilege( LPCWSTR privName )
    {
    HANDLE		 tokenHandle;
    TOKEN_PRIVILEGES	 newState;
    TOKEN_PRIVILEGES	*pTokens = NULL;
    BOOL		 stat    = FALSE;
    LUID		 value;
    DWORD		 error;
    DWORD		 cbTokens;


    if (OpenProcessToken (GetCurrentProcess(),
			  TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,
			  &tokenHandle))
	{

	if (LookupPrivilegeValue (NULL, privName, &value))
	    {
	    newState.PrivilegeCount            = 1;
	    newState.Privileges [0].Luid       = value;
	    newState.Privileges [0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED;

	    /*
	    ** We will always call GetLastError below, so clear
	    ** any prior error values on this thread.
	    */
	    SetLastError (ERROR_SUCCESS);

	    stat = AdjustTokenPrivileges (tokenHandle,
					  FALSE,
					  &newState,
					  (DWORD)0,
					  NULL,
					  NULL);

	    /*
	    ** Supposedly, AdjustTokenPriveleges always returns TRUE
	    ** (even when it fails). So, call GetLastError to be
	    ** extra sure everything's cool.
	    */
	    if ((error = GetLastError()) != ERROR_SUCCESS)
		{
		stat = FALSE;
		}

	    if (!stat)
		{
		wprintf (L"AdjustTokenPrivileges for %s failed with %d",
			 privName,
			 error);
		}
	    }



	GetTokenInformation (tokenHandle,
			     TokenPrivileges,
			     NULL,
			     0,
			     &cbTokens);


	pTokens = (TOKEN_PRIVILEGES *) new BYTE[cbTokens];

	GetTokenInformation (tokenHandle,
			     TokenPrivileges,
			     pTokens,
			     cbTokens,
			     &cbTokens);

	delete pTokens;
	CloseHandle (tokenHandle);
	}


    return stat;
    }


LPCWSTR GetStringFromUsageType (VSS_USAGE_TYPE eUsageType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eUsageType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszRetString = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszRetString = L"SystemService";       break;
	case VSS_UT_USERDATA:            pwszRetString = L"UserData";            break;
	case VSS_UT_OTHER:               pwszRetString = L"Other";               break;
					
	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eSourceType)
	{
	case VSS_ST_TRANSACTEDDB:    pwszRetString = L"TransactionDb";    break;
	case VSS_ST_NONTRANSACTEDDB: pwszRetString = L"NonTransactionDb"; break;
	case VSS_ST_OTHER:           pwszRetString = L"Other";            break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromRestoreMethod (VSS_RESTOREMETHOD_ENUM eRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eRestoreMethod)
	{
	case VSS_RME_RESTORE_IF_NOT_THERE:          pwszRetString = L"RestoreIfNotThere";          break;
	case VSS_RME_RESTORE_IF_CAN_REPLACE:        pwszRetString = L"RestoreIfCanReplace";        break;
	case VSS_RME_STOP_RESTORE_START:            pwszRetString = L"StopRestoreStart";           break;
	case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION: pwszRetString = L"RestoreToAlternateLocation"; break;
	case VSS_RME_RESTORE_AT_REBOOT:             pwszRetString = L"RestoreAtReboot";            break;
	case VSS_RME_CUSTOM:                        pwszRetString = L"Custom";                     break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromWriterRestoreMethod (VSS_WRITERRESTORE_ENUM eWriterRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eWriterRestoreMethod)
	{
	case VSS_WRE_NEVER:            pwszRetString = L"RestoreNever";           break;
	case VSS_WRE_IF_REPLACE_FAILS: pwszRetString = L"RestoreIfReplaceFailsI"; break;
	case VSS_WRE_ALWAYS:           pwszRetString = L"RestoreAlways";          break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eComponentType)
	{
	case VSS_CT_DATABASE:  pwszRetString = L"Database";  break;
	case VSS_CT_FILEGROUP: pwszRetString = L"FileGroup"; break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromFailureType (HRESULT hrStatus)
    {
    LPCWSTR pwszFailureType;

    switch (hrStatus)
	{
	case NOERROR:                                pwszFailureType = L"";                     break;
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT: pwszFailureType = L"InconsistentSnapshot"; break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:       pwszFailureType = L"OutOfResources";       break;
	case VSS_E_WRITERERROR_TIMEOUT:              pwszFailureType = L"Timeout";              break;
	case VSS_E_WRITERERROR_NONRETRYABLE:         pwszFailureType = L"Non-Retryable";        break;
	case VSS_E_WRITERERROR_RETRYABLE:            pwszFailureType = L"Retryable";            break;
	default:                                     pwszFailureType = L"UNDEFINED";            break;
	}

    return (pwszFailureType);
    }





void PrintFiledesc (IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription)
    {
    CComBSTR bstrPath;
    CComBSTR bstrFilespec;
    CComBSTR bstrAlternate;
    bool     bRecursive;


    CHECK_SUCCESS (pFiledesc->GetPath (&bstrPath));
    CHECK_SUCCESS (pFiledesc->GetFilespec (&bstrFilespec));
    CHECK_NOFAIL  (pFiledesc->GetRecursive (&bRecursive));
    CHECK_NOFAIL  (pFiledesc->GetAlternateLocation (&bstrAlternate));

    wprintf (L"%s\n            Path = %s, Filespec = %s, Recursive = %s\n",
	     wszDescription,
	     bstrPath,
	     bstrFilespec,
	     bRecursive ? L"yes" : L"no");

    if (bstrAlternate && wcslen (bstrAlternate) > 0)
	{
	wprintf(L"            Alternate Location = %s\n", bstrAlternate);
	}
    }



extern "C" __cdecl wmain(int argc, WCHAR **argv)
    {
    HRESULT	hr                     = NOERROR;
    bool	bCoInitializeSucceeded = false;


    UNREFERENCED_PARAMETER (argc);
    UNREFERENCED_PARAMETER (argv);


    try
	{
	unsigned cWriters;
	CComBSTR bstrXML;
	CComBSTR bstrXMLOut;
	CComBSTR strSnapshotSetId = "12345678-1234-1234-1234-1234567890ab";
	CComPtr<IVssBackupComponents> pvbc;
	CComPtr<IVssAsync> pAsync;


        CHECK_SUCCESS (CoInitializeEx (NULL, COINIT_MULTITHREADED));

	bCoInitializeSucceeded = true;

	if (!AssertPrivilege (SE_BACKUP_NAME))
	    {
	    wprintf(L"AssertPrivilege returned error, rc:%d\n", GetLastError ());
	    return 2;
	    }

	CHECK_SUCCESS (CreateVssBackupComponents (&pvbc));

	CHECK_SUCCESS (pvbc->InitializeForBackup  ());
	CHECK_SUCCESS (pvbc->SetBackupState       (true, false, VSS_BT_FULL, false));
	CHECK_NOFAIL  (pvbc->GatherWriterMetadata (&pAsync));
	CHECK_NOFAIL  (pAsync->Wait ());
	CHECK_NOFAIL  (pvbc->GetWriterMetadataCount (&cWriters));


	for (unsigned iWriter = 0; iWriter < cWriters; iWriter++)
	    {
	    CComPtr<IVssExamineWriterMetadata> pMetadata;

	    VSS_ID           idInstance;
	    VSS_ID           idInstanceT;
	    VSS_ID           idWriter;
	    CComBSTR         bstrWriterName;
	    VSS_USAGE_TYPE   usage;
	    VSS_SOURCE_TYPE  source;
	    WCHAR           *pwszInstanceId;
	    WCHAR           *pwszWriterId;
	    unsigned cIncludeFiles, cExcludeFiles, cComponents;
	    CComBSTR bstrPath;
	    CComBSTR bstrFilespec;
	    CComBSTR bstrAlternate;
	    CComBSTR bstrDestination;



	    CHECK_SUCCESS (pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata));

	    CHECK_SUCCESS (pMetadata->GetIdentity (&idInstanceT,
						   &idWriter,
						   &bstrWriterName,
						   &usage,
						   &source));

	    wprintf (L"\n\n");

            if (memcmp (&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
		{
		wprintf(L"Instance id mismatch\n");
		DebugBreak();
		}


	    UuidToString (&idInstance, &pwszInstanceId);
	    UuidToString (&idWriter,   &pwszWriterId);

	    wprintf (L"WriterName = %s\n\n"
		     L"    WriterId   = %s\n"
		     L"    InstanceId = %s\n"
		     L"    UsageType  = %d (%s)\n"
		     L"    SourceType = %d (%s)\n",
		     bstrWriterName,
		     pwszWriterId,
		     pwszInstanceId,
		     usage,
		     GetStringFromUsageType (usage),
		     source,
		     GetStringFromSourceType (source));

	    RpcStringFree (&pwszInstanceId);
	    RpcStringFree (&pwszWriterId);

	    CHECK_SUCCESS(pMetadata->GetFileCounts (&cIncludeFiles,
						    &cExcludeFiles,
						    &cComponents));

	    for(unsigned i = 0; i < cIncludeFiles; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;

		CHECK_SUCCESS (pMetadata->GetIncludeFile (i, &pFiledesc));

		PrintFiledesc(pFiledesc, L"\n    Include File");
		}


	    for(i = 0; i < cExcludeFiles; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;

		CHECK_SUCCESS (pMetadata->GetExcludeFile (i, &pFiledesc));

		PrintFiledesc (pFiledesc, L"\n    Exclude File");
		}


	    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
		CComPtr<IVssWMComponent> pComponent;
		PVSSCOMPONENTINFO pInfo;

		CHECK_SUCCESS (pMetadata->GetComponent      (iComponent, &pComponent));
		CHECK_SUCCESS (pComponent->GetComponentInfo (&pInfo));

		wprintf (L"\n"
			 L"    Component %d, type = %d (%s)\n"
			 L"        LogicalPath = %s\n"
			 L"        Name        = %s\n"
			 L"        Caption     = %s\n",
			 iComponent,
			 pInfo->type,
			 GetStringFromComponentType (pInfo->type),
			 pInfo->bstrLogicalPath,
			 pInfo->bstrComponentName,
			 pInfo->bstrCaption);

					

                if (pInfo->cbIcon > 0)
		    {
		    if (pInfo->cbIcon != 10 ||
			pInfo->pbIcon[0] != 1 ||
			pInfo->pbIcon[1] != 2 ||
			pInfo->pbIcon[2] != 3 ||
			pInfo->pbIcon[3] != 4 ||
			pInfo->pbIcon[4] != 5 ||
			pInfo->pbIcon[5] != 6 ||
			pInfo->pbIcon[6] != 7 ||
			pInfo->pbIcon[7] != 8 ||
			pInfo->pbIcon[8] != 9 ||
			pInfo->pbIcon[9] != 10)
			{
			wprintf(L"        Icon is not valid.\n");
			DebugBreak();
			}
		    else
			wprintf(L"        Icon is valid.\n");
		    }

		wprintf (L"        RestoreMetadata        = %s\n"
			 L"        NotifyOnBackupComplete = %s\n"
			 L"        Selectable             = %s\n",
			 pInfo->bRestoreMetadata        ? L"yes" : L"no",
			 pInfo->bNotifyOnBackupComplete ? L"yes" : L"no",
			 pInfo->bSelectable             ? L"yes" : L"no");


		if (pInfo->cFileCount > 0)
		    {
		    for(i = 0; i < pInfo->cFileCount; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;

			CHECK_SUCCESS (pComponent->GetFile (i, &pFiledesc));

			PrintFiledesc (pFiledesc, L"        FileGroupFile");
			}
		    }

		if (pInfo->cDatabases > 0)
		    {
		    for(i = 0; i < pInfo->cDatabases; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;

			CHECK_SUCCESS (pComponent->GetDatabaseFile (i, &pFiledesc));

			PrintFiledesc (pFiledesc, L"        DatabaseFile");
			}
		    }


		if (pInfo->cLogFiles > 0)
		    {
		    for(i = 0; i < pInfo->cLogFiles; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;

			CHECK_SUCCESS (pComponent->GetDatabaseLogFile (i, &pFiledesc));

			PrintFiledesc (pFiledesc, L"        DatabaseLogFile");
			}
		    }

		pComponent->FreeComponentInfo (pInfo);
		}



	    VSS_RESTOREMETHOD_ENUM method;
	    CComBSTR bstrUserProcedure;
	    CComBSTR bstrService;
	    VSS_WRITERRESTORE_ENUM writerRestore;
	    unsigned cMappings;
	    bool bRebootRequired;

	    CHECK_NOFAIL (pMetadata->GetRestoreMethod (&method,
						       &bstrService,
						       &bstrUserProcedure,
						       &writerRestore,
						       &bRebootRequired,
						       &cMappings));


	    wprintf (L"\n"
		     L"    Restore method = %d (%s)\n"
		     L"    Service        = %d\n"
		     L"    User Procedure = %s\n"
		     L"    WriterRestore  = %d (%s)\n"
		     L"    RebootRequired = %s\n",
		     method,
		     GetStringFromRestoreMethod (method),
		     bstrService,
		     bstrUserProcedure,
		     writerRestore,
		     GetStringFromWriterRestoreMethod (writerRestore),
		     bRebootRequired ? L"yes" : L"no");

	    for(i = 0; i < cMappings; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;

		CHECK_SUCCESS (pMetadata->GetAlternateLocationMapping (i, &pFiledesc));

		PrintFiledesc (pFiledesc, L"    AlternateMapping");
		}
	    }


	CHECK_SUCCESS (pvbc->FreeWriterMetadata());
	}
    catch(...)
	{
	hr = E_UNEXPECTED;
	}


    if (FAILED(hr))             wprintf (L"Failed with 0x%08X.\n", hr);
    if (bCoInitializeSucceeded) CoUninitialize();

    return (0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\jettest\main.cpp ===
#include <stdafx.h>

#include <vss.h>
#include <vswriter.h>

#include <jetwriter.h>
#include <esent98.h>

#define	DATABASE_ROOT		L"%SystemDrive%\\JetTestDatabases"
#define	DATABASE_ROOT_A		 "%SystemDrive%\\JetTestDatabases"
#define INCLUDED_DATABASES	L"\\IncludedDatabases"
#define INCLUDED_DATABASES_A	 "\\IncludedDatabases"
#define	EXCLUDED_DATABASES	L"\\ExcludedDatabases"
#define	EXCLUDED_DATABASES_A	 "\\ExcludedDatabases"



#if 1
#define FilesToInclude	L"X:\\Element-00\\/s;"						\
			L"x:\\Element-01\\/s;"						\
			L"x:\\Element-02\\*      /S     ;"				\
			L" x:\\Element-03\\a very long path\\with a long dir\\a.bat"

#define FilesToExclude	DATABASE_ROOT EXCLUDED_DATABASES L"\\" L" /s"

#else

/*
** These are the paths used by RSS at one point.
*/
#define	FilesToExclude	L"%SystemRoot%\\System32\\RemoteStorage\\FsaDb\\*;"	\
			L"%SystemRoot%\\System32\\RemoteStorage\\Trace\\*"

#define	FilesToInclude	L""

#endif




#define	GET_STATUS_FROM_BOOL(_bSucceeded)	((_bSucceeded)       ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_HANDLE(_handle)		((NULL != (_handle)) ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_POINTER(_ptr)		((NULL != (_ptr))    ? NOERROR : E_OUTOFMEMORY)


static const PCHAR achDatabaseNames [] =
    {
    DATABASE_ROOT_A INCLUDED_DATABASES_A "\\jettest_db0.jdb",
    DATABASE_ROOT_A EXCLUDED_DATABASES_A "\\jettest_db1.jdb",
    DATABASE_ROOT_A INCLUDED_DATABASES_A "\\jettest_db2.jdb",
    DATABASE_ROOT_A EXCLUDED_DATABASES_A "\\jettest_db3.jdb",
    DATABASE_ROOT_A INCLUDED_DATABASES_A "\\jettest_db4.jdb",
    DATABASE_ROOT_A EXCLUDED_DATABASES_A "\\jettest_db5.jdb",
    DATABASE_ROOT_A INCLUDED_DATABASES_A "\\jettest_db6.jdb",
    DATABASE_ROOT_A EXCLUDED_DATABASES_A "\\jettest_db7.jdb"
    };


#define MAX_DATABASE_COUNT		(sizeof (achDatabaseNames) / sizeof (PWCHAR))

static CHAR achExpandedDatabaseNames [MAX_DATABASE_COUNT] [MAX_PATH + 1];



static const char szUser []		= "admin";
static const char szPassword []		= "\0";

static const char szTable1 []		= "table1";
static const char szTable2 []		= "table2";

static const char szF1Name []		= "F1PAD";
static const char szF2Name []		= "F2";
static const char szF3Name []		= "F3";
static const char szV1Name []		= "V1";
static const char szT1Name []		= "T1";
static const char szT2Name []		= "T2";
					
static const char szXF1Name []		= "XF1";
static const char szXF3F2Name []	= "XF3F2";
static const char szXV1Name []		= "XV1";
static const char szXT1Name []		= "XT1";
static const char szXT2Name []		= "XT2";


HANDLE *g_phEventHandles = NULL;

typedef enum
    {
    eHandleControlC = 0,
    eHandleStepToNextConfig,
    eHandleMaxHandleCount
    } EHANDLEOFFSETS;



typedef struct
    {
	PCHAR		pszDatabaseName;
	JET_DBID	idDatabase;
} CONTEXTDB, *PCONTEXTDB, **PPCONTEXTDB;

typedef struct
    {
	JET_INSTANCE	idInstance;
	JET_SESID	idSession;

	CONTEXTDB	aDatabase [MAX_DATABASE_COUNT];
} CONTEXTJET, *PCONTEXTJET, **PPCONTEXTJET;





class CVssJetWriterLocal : public CVssJetWriter
    {
public:

	virtual bool STDMETHODCALLTYPE OnThawEnd (bool fJetThawSucceeded);

	virtual void STDMETHODCALLTYPE OnAbortEnd ();

	virtual bool STDMETHODCALLTYPE OnPostRestoreEnd(IVssWriterComponents *pComponents, bool bSucceeded);
};


bool STDMETHODCALLTYPE CVssJetWriterLocal::OnThawEnd (bool fJetThawSucceeded)
    {
	UNREFERENCED_PARAMETER(fJetThawSucceeded);
	wprintf(L"OnThawEnd\n");
    SetEvent (g_phEventHandles [eHandleStepToNextConfig]);

    return (true);
    }

void STDMETHODCALLTYPE CVssJetWriterLocal::OnAbortEnd ()
    {
	wprintf(L"OnAbortEnd\n");
    SetEvent (g_phEventHandles [eHandleStepToNextConfig]);
    }

// This function displays the formatted message at the console and throws
void Error(
    IN  INT nReturnCode,
    IN  const WCHAR* pwszMsgFormat,
    IN  ...
    )
	{
    va_list marker;
    va_start( marker, pwszMsgFormat );
    vwprintf( pwszMsgFormat, marker );
    va_end( marker );

	BS_ASSERT(FALSE);
    // throw that return code.
    throw(nReturnCode);
	}

// Convert a component type into a string
LPCWSTR GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eComponentType)
	{
	case VSS_CT_DATABASE:  pwszRetString = L"Database";  break;
	case VSS_CT_FILEGROUP: pwszRetString = L"FileGroup"; break;

	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a failure type into a string
LPCWSTR GetStringFromFailureType(HRESULT hrStatus)
{
    LPCWSTR pwszFailureType = L"";

    switch (hrStatus)
	{
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:        pwszFailureType = L"VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT";    break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:              pwszFailureType = L"VSS_E_WRITERERROR_OUTOFRESOURCES";          break;
	case VSS_E_WRITERERROR_TIMEOUT:                     pwszFailureType = L"VSS_E_WRITERERROR_TIMEOUT";                 break;
	case VSS_E_WRITERERROR_NONRETRYABLE:                pwszFailureType = L"VSS_E_WRITERERROR_NONRETRYABLE";            break;
	case VSS_E_WRITERERROR_RETRYABLE:                   pwszFailureType = L"VSS_E_WRITERERROR_RETRYABLE";               break;
	case VSS_E_BAD_STATE:                               pwszFailureType = L"VSS_E_BAD_STATE";                           break;
	case VSS_E_PROVIDER_ALREADY_REGISTERED:             pwszFailureType = L"VSS_E_PROVIDER_ALREADY_REGISTERED";         break;
	case VSS_E_PROVIDER_NOT_REGISTERED:                 pwszFailureType = L"VSS_E_PROVIDER_NOT_REGISTERED";             break;
	case VSS_E_PROVIDER_VETO:                           pwszFailureType = L"VSS_E_PROVIDER_VETO";                       break;
	case VSS_E_PROVIDER_IN_USE:				            pwszFailureType = L"VSS_E_PROVIDER_IN_USE";                     break;
	case VSS_E_OBJECT_NOT_FOUND:						pwszFailureType = L"VSS_E_OBJECT_NOT_FOUND";                    break;						
	case VSS_S_ASYNC_PENDING:							pwszFailureType = L"VSS_S_ASYNC_PENDING";                       break;
	case VSS_S_ASYNC_FINISHED:						    pwszFailureType = L"VSS_S_ASYNC_FINISHED";                      break;
	case VSS_S_ASYNC_CANCELLED:						    pwszFailureType = L"VSS_S_ASYNC_CANCELLED";                     break;
	case VSS_E_VOLUME_NOT_SUPPORTED:					pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED";                break;
	case VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER:		pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER";    break;
	case VSS_E_OBJECT_ALREADY_EXISTS:					pwszFailureType = L"VSS_E_OBJECT_ALREADY_EXISTS";               break;
	case VSS_E_UNEXPECTED_PROVIDER_ERROR:				pwszFailureType = L"VSS_E_UNEXPECTED_PROVIDER_ERROR";           break;
	case VSS_E_CORRUPT_XML_DOCUMENT:				    pwszFailureType = L"VSS_E_CORRUPT_XML_DOCUMENT";                break;
	case VSS_E_INVALID_XML_DOCUMENT:					pwszFailureType = L"VSS_E_INVALID_XML_DOCUMENT";                break;
	case VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED:       pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED";   break;
	case VSS_E_FLUSH_WRITES_TIMEOUT:                    pwszFailureType = L"VSS_E_FLUSH_WRITES_TIMEOUT";                break;
	case VSS_E_HOLD_WRITES_TIMEOUT:                     pwszFailureType = L"VSS_E_HOLD_WRITES_TIMEOUT";                 break;
	case VSS_E_UNEXPECTED_WRITER_ERROR:                 pwszFailureType = L"VSS_E_UNEXPECTED_WRITER_ERROR";             break;
	case VSS_E_SNAPSHOT_SET_IN_PROGRESS:                pwszFailureType = L"VSS_E_SNAPSHOT_SET_IN_PROGRESS";            break;
	case VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED:     pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED"; break;
	case VSS_E_WRITER_INFRASTRUCTURE:	 		        pwszFailureType = L"VSS_E_WRITER_INFRASTRUCTURE";               break;
	case VSS_E_WRITER_NOT_RESPONDING:			        pwszFailureType = L"VSS_E_WRITER_NOT_RESPONDING";               break;
    case VSS_E_WRITER_ALREADY_SUBSCRIBED:		        pwszFailureType = L"VSS_E_WRITER_ALREADY_SUBSCRIBED";           break;
	
	case NOERROR:
	default:
	    break;
	}

    return (pwszFailureType);
}



// Execute the given call and check that the return code must be S_OK
#define CHECK_SUCCESS( Call )                                                                           \
    {                                                                                                   \
        hr = Call;                                                                                    \
		if (hr != S_OK)                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }


#define CHECK_NOFAIL( Call )                                                                            \
    {                                                                                                   \
        hr = Call;                                                                                    \
        if (FAILED(hr))                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }


bool STDMETHODCALLTYPE CVssJetWriterLocal::OnPostRestoreEnd(IVssWriterComponents *pWriter, bool bRestoreSucceeded)
	{
	wprintf(L"Restore invoked.\n");
	if (bRestoreSucceeded)
		wprintf(L"Restore succeeded.\n");
	else
		wprintf(L"Restore failed.");

	try
		{
		HRESULT hr;

		unsigned cComponents;
		CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
		VSS_ID idWriter, idInstance;
		CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));
		for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
			{
			CComPtr<IVssComponent> pComponent;
			CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
				
			VSS_COMPONENT_TYPE ct;
			CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;

			CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
			CHECK_SUCCESS(pComponent->GetComponentType(&ct));
			CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
			wprintf(L"COMPONENT path = %s, type=%s, name=%s\n", bstrLogicalPath, GetStringFromComponentType(ct), bstrComponentName);
			}
		}
	catch(...)
		{
		wprintf(L"***Unexpected exception thrown.***\n");
		}

	return true;
	}


#define DO_CALL(xCall) \
    { \
	JET_ERR jetStatus = xCall; \
    if (jetStatus < JET_errSuccess) \
		Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n" \
			  L"\t  Error code = 0x%08lx.\n", \
			  __FILE__, __LINE__, #xCall, jetStatus); \
	 }


BOOL WINAPI Ctrl_C_Handler_Routine(IN DWORD type)
    {
    UNREFERENCED_PARAMETER(type);

    if (g_phEventHandles [eHandleControlC])
	{
	SetEvent (g_phEventHandles [eHandleControlC]);
	}

    return TRUE;
    }







JET_ERR CreateAndPopulateDatabase (JET_SESID	idSession,
				   const char	*szDatabase,
				   JET_DBID *pidDatabase)
    {
    JET_DBID		idDatabase;
    JET_TABLEID		idTable;
    JET_COLUMNDEF	columndef;
    JET_COLUMNID	idColumnF1;
    JET_COLUMNID	idColumnF2;
    JET_COLUMNID	idColumnF3;
    JET_COLUMNID	idColumnV1;
    JET_COLUMNID	idColumnT1;
    JET_COLUMNID	idColumnT2;

    const unsigned short	usCodePage = 1252;
    const unsigned short	usLanguage = 0x409;
    const long			lOne       = 1;


    DO_CALL (JetCreateDatabase (idSession, szDatabase, NULL, &idDatabase, 0));
    DO_CALL (JetCloseDatabase  (idSession, idDatabase, 0));

    /*
    **	check multiple opens of same database
    */
    DO_CALL (JetOpenDatabase (idSession, szDatabase, NULL, &idDatabase, 0));


    DO_CALL (JetBeginTransaction (idSession));

    DO_CALL (JetCreateTable      (idSession, idDatabase, szTable1, 0, 100, &idTable));
    DO_CALL (JetCloseTable       (idSession, idTable));


    DO_CALL (JetOpenTable        (idSession, idDatabase, szTable1, NULL, 0, JET_bitTableDenyRead, &idTable));


    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypLong;
    columndef.cbMax    = 0;
    columndef.grbit    = 0;

    DO_CALL (JetAddColumn (idSession, idTable, szF1Name, &columndef, &lOne, sizeof(lOne), &idColumnF1));



    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypUnsignedByte;
    columndef.cbMax    = 0;
    columndef.grbit    = 0;

    DO_CALL (JetAddColumn (idSession, idTable, szF2Name, &columndef, NULL, 0, &idColumnF2));



    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypLong;
    columndef.cbMax    = 0;
    columndef.grbit    = 0;

    DO_CALL (JetAddColumn (idSession, idTable, szF3Name, &columndef, NULL, 0, &idColumnF3));



    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypText;
    columndef.cbMax    = 0;
    columndef.grbit    = 0;

    DO_CALL (JetAddColumn (idSession, idTable, szV1Name, &columndef, NULL, 0, &idColumnV1));



    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypLongText;
    columndef.cbMax    = 0;
    columndef.grbit    = JET_bitColumnTagged | JET_bitColumnMultiValued;

    DO_CALL (JetAddColumn (idSession, idTable, szT1Name, &columndef, NULL, 0, &idColumnT1));



    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypBinary;
    columndef.cbMax    = 0;
    columndef.grbit    = JET_bitColumnTagged | JET_bitColumnMultiValued;

    DO_CALL (JetAddColumn (idSession, idTable, szT2Name, &columndef, NULL, 0, &idColumnT2));


    {
    char		rgbCols[50];
    sprintf( rgbCols, "+%s", szF1Name);

    rgbCols[ 1 + strlen(szF1Name) + 1] = '\0';
    *(unsigned short *)(&rgbCols[ 1 + strlen(szF1Name) + 1 + 1]) = usLanguage;
    rgbCols[ 1 + strlen(szF1Name) + 1 + 1 + sizeof(usLanguage) ]    = '\0';
    rgbCols[ 1 + strlen(szF1Name) + 1 + 1 + sizeof(usLanguage) + 1] = '\0';

    DO_CALL (JetCreateIndex (idSession,
			  idTable,
			  szXF1Name,
			  JET_bitIndexPrimary | JET_bitIndexUnique,
			  rgbCols,
			  1 + strlen( szF1Name) + 1 + 1 + sizeof(usLanguage) + 1 + 1,
			  100));
    }

    DO_CALL (JetCloseTable (idSession, idTable));
    DO_CALL (JetCommitTransaction (idSession, 0));

	*pidDatabase = idDatabase;


    return (JET_errSuccess);
    }


void DatabaseSetup (PCONTEXTJET pctxJet, ULONG ulDatabaseCount)
    {
    JET_ERR		jetStatus;


    DO_CALL (JetBeginSession (pctxJet->idInstance, &pctxJet->idSession, szUser, szPassword));


    while (ulDatabaseCount-- > 0)
	{
	jetStatus = JetAttachDatabase (pctxJet->idSession,
				       pctxJet->aDatabase [ulDatabaseCount].pszDatabaseName,
				       0);


	if (jetStatus >= JET_errSuccess)
	    {
	    DO_CALL (JetOpenDatabase (pctxJet->idSession,
				   pctxJet->aDatabase [ulDatabaseCount].pszDatabaseName,
				   NULL,
				   &pctxJet->aDatabase [ulDatabaseCount].idDatabase,
				   0));
	    }
	else
	    {
	    DO_CALL (CreateAndPopulateDatabase (pctxJet->idSession,
					     pctxJet->aDatabase [ulDatabaseCount].pszDatabaseName,
						 &pctxJet->aDatabase [ulDatabaseCount].idDatabase));
	    }

	}
    }


void DatabaseCleanup (PCONTEXTJET pctxJet, ULONG ulDatabaseCount)
    {
    while (ulDatabaseCount-- > 0)
	{
	DO_CALL (JetCloseDatabase (pctxJet->idSession,
				pctxJet->aDatabase [ulDatabaseCount].idDatabase,
				0));


	DO_CALL (JetDetachDatabase (pctxJet->idSession,
				 pctxJet->aDatabase [ulDatabaseCount].pszDatabaseName));
	}


    DO_CALL (JetEndSession (pctxJet->idSession, 0));
    }




extern "C" int _cdecl wmain(int argc, WCHAR **argv)
    {
	UNREFERENCED_PARAMETER(argc);
	UNREFERENCED_PARAMETER(argv);

    HRESULT		hrStatus        = NOERROR;
    DWORD		dwStatus        = 0;
    GUID		idWriter        = GUID_NULL;
    CVssJetWriter	*pWriter        = NULL;
    bool		bContinue       = true;
    BOOL		bSucceeded      = FALSE;
    ULONG		ulDatabaseCount = 3;
    ULONG		ulIndex;
    HANDLE		hEventHandles [eHandleMaxHandleCount];
    CONTEXTJET		ctxJet;
	WCHAR		wszBufferName [MAX_PATH + 1];
    DWORD		dwCharCount;



    dwCharCount = ExpandEnvironmentStringsW (DATABASE_ROOT, wszBufferName, sizeof (wszBufferName));

    hrStatus = GET_STATUS_FROM_BOOL (0 != dwCharCount);

    if (FAILED (hrStatus))
	{
	wprintf (L"ExpandEnvironmentStringsW (%s) FAILED with error code %08x\n",
		 DATABASE_ROOT,
		 hrStatus);
	}


    bSucceeded = CreateDirectoryW (wszBufferName, NULL);

    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

    if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_ALREADY_EXISTS) != hrStatus))
	{
	wprintf (L"CreateDirectoryW (%s) FAILED with error code %08x\n",
		 wszBufferName,
		 hrStatus);
	}




    dwCharCount = ExpandEnvironmentStringsW (DATABASE_ROOT INCLUDED_DATABASES, wszBufferName, sizeof (wszBufferName));

    hrStatus = GET_STATUS_FROM_BOOL (0 != dwCharCount);

    if (FAILED (hrStatus))
	{
	wprintf (L"ExpandEnvironmentStringsW (%s) FAILED with error code %08x\n",
		 DATABASE_ROOT INCLUDED_DATABASES,
		 hrStatus);
	}


    bSucceeded = CreateDirectoryW (wszBufferName, NULL);

    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

    if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_ALREADY_EXISTS) != hrStatus))
	{
	wprintf (L"CreateDirectoryW (%s) FAILED with error code %08x\n",
		 wszBufferName,
		 hrStatus);
	}




    dwCharCount = ExpandEnvironmentStringsW (DATABASE_ROOT EXCLUDED_DATABASES, wszBufferName, sizeof (wszBufferName));

    hrStatus = GET_STATUS_FROM_BOOL (0 != dwCharCount);

    if (FAILED (hrStatus))
	{
	wprintf (L"ExpandEnvironmentStringsW (%s) FAILED with error code %08x\n",
		 DATABASE_ROOT EXCLUDED_DATABASES,
		 hrStatus);
	}


    bSucceeded = CreateDirectoryW (wszBufferName, NULL);

    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

    if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_ALREADY_EXISTS) != hrStatus))
	{
	wprintf (L"CreateDirectoryW (%s) FAILED with error code %08x\n",
		 wszBufferName,
		 hrStatus);
	}




    hrStatus = NOERROR;



    /*
    ** Initialise the database contexts
    */
    ctxJet.idInstance = 0;
    ctxJet.idSession  = 0;

    for (ulIndex = 0; ulIndex < MAX_DATABASE_COUNT; ulIndex++)
	{
	dwCharCount = ExpandEnvironmentStringsA (achDatabaseNames [ulIndex],
						 achExpandedDatabaseNames [ulIndex],
						 sizeof (achExpandedDatabaseNames [ulIndex]));

	ctxJet.aDatabase [ulIndex].idDatabase      = 0;
	ctxJet.aDatabase [ulIndex].pszDatabaseName = achExpandedDatabaseNames [ulIndex];
	}



    /*
    ** Initialise the event handles array
    */
    for (ulIndex = 0; ulIndex < eHandleMaxHandleCount; ulIndex++)
	{
	if (SUCCEEDED (hrStatus))
	    {
	    hEventHandles [ulIndex] = CreateEvent (NULL, FALSE, FALSE, NULL);

	    hrStatus = GET_STATUS_FROM_HANDLE (hEventHandles [ulIndex] );

	    if (NULL == hEventHandles [ulIndex])
		{
		wprintf (L"CreateEvent %u failed with error code %08X\n", ulIndex, hrStatus);
		}
	    }
	}



    /*
    ** Hook up the console GetOutOfJail device
    */
    if (SUCCEEDED (hrStatus))
	{
	g_phEventHandles = hEventHandles;

	::SetConsoleCtrlHandler (Ctrl_C_Handler_Routine, TRUE);
	}



    /*
    ** Tally-ho chaps!
    */
    try
	{
	DO_CALL (JetInit(&ctxJet.idInstance));

	hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	if (FAILED (hrStatus))
	    {
	    wprintf (L"CoInitializeEx failed with error code %08x\n", hrStatus);
	    }


    hrStatus = CoInitializeSecurity
			(
			NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
			-1,                                  //  IN LONG                         cAuthSvc,
			NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
			NULL,                                //  IN void                        *pReserved1,
			RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
			RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
			NULL,                                //  IN void                        *pAuthList,
			EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
			NULL                                 //  IN void                        *pReserved3
			);


	if (FAILED (hrStatus))
	    {
	    wprintf (L"CoInitializeSecurity failed with error code %08x\n", hrStatus);
	    }

	if (SUCCEEDED (hrStatus))
	    {
	    pWriter = new CVssJetWriterLocal;

	    if (NULL == pWriter)
		{
		wprintf (L"new CVssJetWriter failed");

		hrStatus = HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY);
		}
	    }



	if (SUCCEEDED (hrStatus))
	    {
	    hrStatus = pWriter->Initialize (idWriter,		// id of writer
					    L"JetTest Writer",	// name of writer
					    true,		// system service
					    false,		// bootable state
					    FilesToInclude,	// files to include
					    FilesToExclude);	// files to exclude

	    if (FAILED (hrStatus))
		{
		wprintf (L"CVssJetWriter::Initialize failed with error code %08x\n", hrStatus);
		}
	    }




	while (SUCCEEDED (hrStatus) && bContinue)
	    {
	    DatabaseSetup (&ctxJet, ulDatabaseCount);


	    dwStatus = WaitForMultipleObjects (eHandleMaxHandleCount, hEventHandles, FALSE, INFINITE);


	    DatabaseCleanup (&ctxJet, ulDatabaseCount);

	    switch (dwStatus - WAIT_OBJECT_0)
		{
		case (eHandleControlC):
		    bContinue = FALSE;
		    break;


		case (eHandleStepToNextConfig):
		    ulDatabaseCount = (ulDatabaseCount + 1) % (MAX_DATABASE_COUNT + 1);
		    break;


		default:
		    BS_ASSERT (0);
		    break;
		}
	    }
	}



    catch(...)
	{
	wprintf(L"unexpected exception\n");
	exit(-1);
	}



    for (ulIndex = 0; ulIndex < eHandleMaxHandleCount; ulIndex++)
	{
	if (NULL != hEventHandles [ulIndex])
	    {
	    CloseHandle (hEventHandles [ulIndex]);

	    hEventHandles [ulIndex] = NULL;
	    }
	}



    if (NULL != pWriter)
	{
	pWriter->Uninitialize();
	delete pWriter;
	pWriter = NULL;
	}


    DO_CALL (JetTerm (ctxJet.idInstance));


    return (hrStatus);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\multilayer\macros.h ===
///////////////////////////////////////////////////////////////////////////////
// Useful classes, macros 

#pragma once


#define GXN_EVAL(X) X
#define GXN_STRINGIZE_ARG(X) #X
#define GXN_STRINGIZE(X) GXN_EVAL(GXN_STRINGIZE_ARG(X))
#define GXN_MERGE(A, B) A##B
#define GXN_MAKE_W(A) GXN_MERGE(L, A)
#define GXN_WSTRINGIZE(X) GXN_MAKE_W(GXN_STRINGIZE(X))
#define __GXN_WFILE__ GXN_MAKE_W(GXN_EVAL(__FILE__))


#define GXN_ERROR_CASE(wszBuffer, dwBufferLen, X) 	\
    case X: ::StringCchCopyW(wszBuffer, dwBufferLen, GXN_MAKE_W(GXN_EVAL(#X)) );  break;

#define GXN_WSTR_GUID_FMT  L"{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}"

#define GXN_WSTR_DWORD_FMT  L"%c%c%c%c%c%c%c%c.%c%c%c%c%c%c%c%c.%c%c%c%c%c%c%c%c.%c%c%c%c%c%c%c%c"

#define GXN_GUID_PRINTF_ARG( X )                          \
    (X).Data1,                                              \
    (X).Data2,                                              \
    (X).Data3,                                              \
    (X).Data4[0], (X).Data4[1], (X).Data4[2], (X).Data4[3], \
    (X).Data4[4], (X).Data4[5], (X).Data4[6], (X).Data4[7]

#define GXN_BIT_PRINTF_ARG( X, val )   (((X) & (1 << (val-1)))? L'1': L'0')

#define GXN_DWORD_PRINTF_ARG( X )                          												\
	GXN_BIT_PRINTF_ARG(X,0x20), GXN_BIT_PRINTF_ARG(X,0x1f), GXN_BIT_PRINTF_ARG(X,0x1e), GXN_BIT_PRINTF_ARG(X,0x1d),	\
	GXN_BIT_PRINTF_ARG(X,0x1c), GXN_BIT_PRINTF_ARG(X,0x1b), GXN_BIT_PRINTF_ARG(X,0x1A), GXN_BIT_PRINTF_ARG(X,0x19),	\
	GXN_BIT_PRINTF_ARG(X,0x18), GXN_BIT_PRINTF_ARG(X,0x17), GXN_BIT_PRINTF_ARG(X,0x16), GXN_BIT_PRINTF_ARG(X,0x15),	\
	GXN_BIT_PRINTF_ARG(X,0x14), GXN_BIT_PRINTF_ARG(X,0x13), GXN_BIT_PRINTF_ARG(X,0x12), GXN_BIT_PRINTF_ARG(X,0x11),	\
	GXN_BIT_PRINTF_ARG(X,0x10), GXN_BIT_PRINTF_ARG(X,0x0f), GXN_BIT_PRINTF_ARG(X,0x0e), GXN_BIT_PRINTF_ARG(X,0x0d),	\
	GXN_BIT_PRINTF_ARG(X,0x0c), GXN_BIT_PRINTF_ARG(X,0x0b), GXN_BIT_PRINTF_ARG(X,0x0A), GXN_BIT_PRINTF_ARG(X,0x09),	\
	GXN_BIT_PRINTF_ARG(X,0x08), GXN_BIT_PRINTF_ARG(X,0x07), GXN_BIT_PRINTF_ARG(X,0x06), GXN_BIT_PRINTF_ARG(X,0x05),	\
	GXN_BIT_PRINTF_ARG(X,0x04), GXN_BIT_PRINTF_ARG(X,0x03), GXN_BIT_PRINTF_ARG(X,0x02), GXN_BIT_PRINTF_ARG(X,0x01)

#define CHECK_CONDITION( Cond, FinalCode )                                         \
    {                                                                              \
        if (!(Cond)) {                                                             \
            ft.Msg(L"- ERROR: Condition %S not succeeded. \n", #Cond );            	\
            do { FinalCode } while(0);												\
           	throw(E_UNEXPECTED); 													\
        } else                														\
            ft.Msg(L"- Condition %S succeeded\n", #Cond);                           \
    }

#define CHECK_COM( Call, FinalCode )                                                \
    {                                                                               \
    	HRESULT hr = Call;															\
        if (FAILED(hr)) {                                                           \
            ft.Msg(L"- ERROR: Call %S not succeeded. \n"                   			\
                L"\t  Error Code = 0x%08lx. Error description = %s\n",              \
                #Call, hr,															\
                GetStringFromFailureType(hr));      				\
            do { FinalCode } while(0);												\
           	throw(hr); 																\
        } else                														\
            ft.Msg(L"- (OK) %S\n", #Call);                                         \
    }


#define CHECK_WIN32( Cond, FinalCode )                                              \
    {                                                                               \
        if (!(Cond)) {                                                              \
            ft.Msg(L"- ERROR: Condition %S not succeeded. \n"                   	\
                L"\t  Error Code = 0x%08lx. Error description = %s\n",              \
                #Cond, HRESULT_FROM_WIN32(GetLastError()),							\
                GetStringFromFailureType(HRESULT_FROM_WIN32(GetLastError())));      \
            do { FinalCode } while(0);												\
           	throw(HRESULT_FROM_WIN32(GetLastError())); 								\
        } else                														\
            ft.Msg(L"- (OK) %S\n", #Cond);                                         \
    }


#define CHECK_WIN32_FUNC( LValue, Condition, Call, FinalCode )                      \
    {                                                                               \
        LValue = Call;                                                               \
        if (!(Condition)) {                                                              \
            ft.Msg(L"- ERROR: (%S) when %S \n"                   					\
                L"\t  Error Code = 0x%08lx. Error description = %s\n",              \
                #Call, #Condition, HRESULT_FROM_WIN32(GetLastError()),							\
                GetStringFromFailureType(HRESULT_FROM_WIN32(GetLastError())));      \
            do { FinalCode } while(0);												\
           	throw(HRESULT_FROM_WIN32(GetLastError())); 								\
        } else                														\
            ft.Msg(L"- (OK) %S\n", #Call);                                         \
    }


#define PRINT_ERROR_DELTA( dwError, dwLastError )									\
	if ( dwError == dwLastError ) {} else {											\
            ft.Msg(L"- ERROR: %s = 0x%08lx [%s]. (Previous value 0x%08lx)\n",      \
            	#dwLastError, dwError, 												\
            	GetStringFromFailureType(HRESULT_FROM_WIN32(GetLastError())),		\
            	dwLastError );														\
           	dwLastError = dwError;													\
		}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\multilayer\cmdparse.h ===
/*
**++
**
** Copyright (c) 2000-2002  Microsoft Corporation
**
**
** Module Name:
**
**	    cmdparse.h
**
**
** Abstract:
**
**	    Command line parser 
**
** Author:
**
**	    Adi Oltean      [aoltean]       02/26/2002
**
** Revision History:
**
**--
*/

#ifndef __CMD_PARSE_HEADER_H__
#define __CMD_PARSE_HEADER_H__

#if _MSC_VER > 1000
#pragma once
#endif


//////////////////////////////////////////////////////////////////
//
//	Generic string class
//


class CGxnString
{
private:
	CGxnString(const CGxnString&);
	
public:

	CGxnString(): m_pwszString(NULL), m_pwszCurrent(NULL) {};
		
	CGxnString(int nAllocatedChars): m_pwszString(NULL), m_pwszCurrent(NULL) {
		Allocate(nAllocatedChars);
	};
	
	CGxnString( const WCHAR* wszString, int nAllocatedChars = -1 ): m_pwszString(NULL), m_pwszCurrent(NULL) {
   		CopyFrom(wszString, nAllocatedChars);
	};
	
	~CGxnString(){
   		Clear();
	};
	
	operator WCHAR* () { return m_pwszCurrent; };


	void operator ++ (int) { m_pwszCurrent++; };
	
	void operator += (int nChars) { m_pwszCurrent += nChars; };
	
	void CopyFrom(const WCHAR * wszString, int nAllocatedChars = -1) { 
		int nLen = (nAllocatedChars == -1)? (int)wcslen(wszString): nAllocatedChars;
   		Allocate(nLen);
   		::wcsncpy(m_pwszString, wszString, nLen);
	};

	void Allocate(int nAllocatedChars) { 
		delete[] m_pwszString;
		m_pwszString = new WCHAR[nAllocatedChars + 1];
   		if (NULL == m_pwszString) throw(E_OUTOFMEMORY);
   		m_pwszString[nAllocatedChars] = L'\0'; 
   		m_pwszCurrent = m_pwszString;
	};

	void Clear() { 
   		delete[] m_pwszString;
   		m_pwszString = m_pwszCurrent = NULL;
	};


private: 
	WCHAR * m_pwszString;
	WCHAR * m_pwszCurrent;
};


//////////////////////////////////////////////////////////////////
//
//	Generic tracing mechanism (can be replaced with a better one)
//


// Useful macros for tracing
#define GXN_DBGINFO __LINE__, __FILE__

// Tracing buffer - max value
#define MAX_TRACING_BUFFER	400


// Macro used for commoditized vsprintf
#define GXN_VARARG( LastParam )												\
	CGxnString buffer(MAX_TRACING_BUFFER);									\
    va_list marker;															\
    va_start( marker, LastParam );											\
    StringCchVPrintfW( buffer, MAX_TRACING_BUFFER, LastParam, marker ); 	\
    va_end( marker );														


// The tracing class (a very simple implementation)
struct CGxnTracer
{
	enum{
		TraceFlag		= 1,
		OutputFlag		= 2,
		ErrorFlag		= 4,
		AllFlags		= 7,
	};

	CGxnTracer(int nLine = 0, char* szFile = NULL, WCHAR* wszFunction = NULL):
		m_nTraceFlags(OutputFlag | ErrorFlag), 
		m_szFile(szFile), m_nLine(nLine), m_wszFunction(wszFunction) {};

	CGxnTracer(int nTraceFlags, int nLine = 0, char* szFile = NULL, WCHAR* wszFunction = NULL):
		m_nTraceFlags(nTraceFlags), 
		m_szFile(szFile), m_nLine(nLine), m_wszFunction(wszFunction) {
		if (m_wszFunction) Trace(m_nLine, m_szFile, L"* Enter %s\n", m_wszFunction);
	};

	~CGxnTracer() {
		if (m_wszFunction) Trace(m_nLine, m_szFile, L"* Exit %s\n", m_wszFunction);
	};

	int SetOptions( int nTraceFlags ) {
		int nPrevTraceFlags = m_nTraceFlags;
		m_nTraceFlags = nTraceFlags;
		return nPrevTraceFlags;
	}

	void Out( WCHAR* pwszMsgFormat, ... )	{
		if (m_nTraceFlags & OutputFlag) {
			GXN_VARARG( pwszMsgFormat );
			wprintf( L"%s", (LPWSTR)buffer);
		}
	}

	void Trace( int nLine, char* szFile, const WCHAR* pwszMsgFormat, ... )	{
		if (m_nTraceFlags & TraceFlag) {
			GXN_VARARG( pwszMsgFormat );
			wprintf( L"%s - %hs(%d)\n", (LPWSTR)buffer, szFile, nLine);
		}
	}

	void Err( WCHAR* pwszMsgFormat, ... )	{
		if (m_nTraceFlags & ErrorFlag) {
			GXN_VARARG( pwszMsgFormat );
			wprintf( L"%s", (LPWSTR)buffer);
		}
	}

	__declspec(noreturn) void Throw( INT nLine, char* szFile, HRESULT hr, const WCHAR* pwszMsgFormat, ... )	{
		if (m_nTraceFlags & ErrorFlag) {
			GXN_VARARG( pwszMsgFormat );
			wprintf( L"%s [ERROR: 0x%08lx] - %hs(%d)\n", (LPWSTR)buffer, hr, szFile, nLine);
		}
		throw (hr);
	}

private:
	int 	m_nTraceFlags;
	char*	m_szFile;
	int 	m_nLine;
	WCHAR* 	m_wszFunction;
};



////////////////////////////////////////////////////////////////////////// 
//
//	Command line parser
//


#define BEGIN_CMD_PARSER( AppName )								\
 	virtual CHAR* GetAppName() { return #AppName; };			\
	virtual CmdTemplateEntry & GetCmdTemplate(INT nIndex) {		\
		static CmdTemplateEntry arrEntries[] = {				\


#define CMD_ENTRY(pRoutine, wszTemplate, wszComment) 			\
		{ pRoutine, wszTemplate, wszComment},					\


#define END_CMD_PARSER								 			\
			{ NULL, NULL, NULL },								\
		};														\
		return arrEntries[nIndex];								\
	}


// Command line parser class
template <
	class CRoutineSupport,
	class CTracer = CGxnTracer, 
	int MAX_PARAMS = 40
	>
class CGxnCmdLineParser
{
// Types
public: 
	typedef  void 	(CRoutineSupport::*PRoutineNonaligned)();
	typedef  __declspec(align(16)) 	PRoutineNonaligned PRoutine;
	
	typedef struct {
		PRoutine	pRoutine;
		LPWSTR 		wszCmdLine;
		LPWSTR 		wszComment;
	} CmdTemplateEntry;

// Constructors/destructors
private:
	CGxnCmdLineParser(const CGxnCmdLineParser&);

public:
	CGxnCmdLineParser(): m_nParamCount(0), m_nSelectedTemplate(0) {};

public:
 	virtual CHAR* GetAppName() = 0;
	virtual CmdTemplateEntry & GetCmdTemplate(INT nIndex) = 0;

// Operations
public:

	bool ParseCmdLine(WCHAR* pwszCommandLine)
	{
//		CTracer ft( GXN_DBGINFO, L"CGxnCmdLineParser::ParseCmdLine");

		for (INT nIndex = 0;; nIndex++)
		{
			CmdTemplateEntry & entry = GetCmdTemplate(nIndex);
			
			// If this is the last entry print usage
			if (entry.pRoutine == NULL)
				return PrintUsage();

			// Clean parameter associations from previous iteration (if any)
			CleanParams();

			CGxnString strCommandLine(pwszCommandLine);
			CGxnString strCommandTemplate(entry.wszCmdLine);
			while (true) {
				// Skip spaces
				for(;iswspace(*strCommandLine);strCommandLine++);
				for(;iswspace(*strCommandTemplate);strCommandTemplate++);

				// Extract a name/value pair if possible
				CGxnString name, value;
				if (ExtractVariable(strCommandTemplate, name)) 
				{
					// No match, try with the next template
					if (!ExtractValue(strCommandLine, value))
						break;
						
					AddParam(name, value);
					continue;
				}
				
				// No match, try with the next template
				if (*strCommandTemplate != *strCommandLine)
					break;

				// Eliminate the current matching tokens
				while(*strCommandTemplate == *strCommandLine) {
					// If we reach an end, we just finished
					if ((*strCommandTemplate == L'\0') 
						&& (*strCommandLine == L'\0')) 
					{
						m_nSelectedTemplate = nIndex;
						return true;
					}
					strCommandTemplate++;
					strCommandLine++;
				}
			}
		}
		return false;
	}


	LPWSTR GetStringParam(const WCHAR* wszName)
	{
		if ((wszName[0] != L'<') && (wszName[wcslen(wszName)-1] != L'>') )
			ft.Throw( GXN_DBGINFO, E_UNEXPECTED, L"Invalid name %s\n", wszName);

		// Extract the '<' and '>' suffixes and search into the array
		CGxnString name(wszName + 1, (int)wcslen(wszName) - 2);
		for (INT nIndex = 0; nIndex < m_nParamCount; nIndex++)
			if (wcscmp(name, m_arrNames[nIndex]) == 0)
				return m_arrValues[nIndex];
		ft.Throw( GXN_DBGINFO, E_UNEXPECTED, L"Invalid string param %s\n", wszName);
	}


	// Get a integer value
	INT GetIntParam(const WCHAR* wszName)
	{
		return _wtoi(GetStringParam( wszName ));
	}


	// Get a int64 value
	LONGLONG GetInt64Param(const WCHAR* wszName)
	{
		return _wtoi64(GetStringParam( wszName ));
	}

	// Get a int64 value
	LARGE_INTEGER GetLargeIntParam(const WCHAR* wszName)
	{
		LARGE_INTEGER li;
		li.QuadPart = _wtoi64(GetStringParam( wszName ));
		return li;
	}


	// Get a GUID value
	GUID GetGuidParam(const WCHAR* wszName)
	{
		GUID guid;
		LPWSTR wszString = GetValue(wszName);
		if (FAILED(CLSIDFromString(wszString, &guidValue)))
			ft.Throw( GXN_DBGINFO, E_INVALIDARG, L"Invalid GUID %s for param %s\n", wszString, wszName);
		return guid;
	}

	bool IsOptionPresent(const WCHAR* /*wszName*/)
	{
		return false;
	}

	PRoutine GetCurrentRoutine()  
	{ 
		return GetCmdTemplate(m_nSelectedTemplate).pRoutine; 
	};

	LPWSTR GetCurrentComment()  
	{ 
		return GetCmdTemplate(m_nSelectedTemplate).wszComment; 
	};

	LPWSTR GetCurrentTemplate()  
	{ 
		return GetCmdTemplate(m_nSelectedTemplate).wszCmdLine; 
	};

	void PrintArguments()
	{
		ft.Out(L"\n\nMatching parameters for template '%s':\n", GetCurrentTemplate());
		for(INT nIndex = 0; nIndex < m_nParamCount; nIndex++)
			ft.Out( L"* <%s> = '%s'\n", (LPWSTR)m_arrNames[nIndex], (LPWSTR)m_arrValues[nIndex] );
		if (m_nParamCount == 0)
			ft.Out( L"* (None)\n");
		ft.Out(L"\n");
	}

	bool PrintUsage()
	{
		ft.Out(L"\n\nUsage:\n");
		for (INT nIndex = 0;; nIndex++)
		{
			CmdTemplateEntry & entry = GetCmdTemplate(nIndex);
			if (entry.pRoutine == NULL)
				break;
			ft.Out(L"  * %s:\t%hs %s\n", entry.wszComment, GetAppName(), entry.wszCmdLine);
		}
		ft.Out(L"\n");
		
		return false;	
	}


// Utility methods
private:

	// Extract a variable of the "<name>" format
	bool ExtractVariable(CGxnString & str, CGxnString & name) { 
		if ( *str != L'<')
			return false;
		str++;
		WCHAR* wszEnd = wcschr(str, L'>');
		if (!wszEnd || (str == wszEnd))
			ft.Throw( GXN_DBGINFO, E_INVALIDARG, L"Invalid variable name %s\n", (LPWSTR)str);
		name.CopyFrom( str, wszEnd - str );
		str += (wszEnd - str) + 1; // Skip the L'>' character also
		return true;
	}


	// Extract a value from the current string until we reach a space.
	bool ExtractValue(CGxnString & str, CGxnString & value) { 
		LPWSTR wszEnd = str;
		
		// Get the first space or zero terminator
		for(; (*wszEnd) && !iswspace(*wszEnd); wszEnd++);
		if (str == wszEnd)
			return false;

		value.CopyFrom( str, wszEnd - str );
		str += (wszEnd - str);
		return true;
	}

		
	void CleanParams()
	{
		for (INT nIndex = 0; nIndex < m_nParamCount; nIndex++) { 
			m_arrNames[nIndex].Clear();
			m_arrValues[nIndex].Clear();
		}
		m_nParamCount = 0;
	}


	void AddParam(CGxnString & name, CGxnString & value)
	{
		if (m_nParamCount == MAX_PARAMS)
			ft.Throw( GXN_DBGINFO, E_INVALIDARG, L"Too many parameters [%d]\n", m_nParamCount);

		m_arrNames[m_nParamCount].CopyFrom(name);
		m_arrValues[m_nParamCount].CopyFrom(value);
		m_nParamCount++;
	}


// Internal data members
private:
	INT				m_nParamCount;
	CGxnString		m_arrNames[MAX_PARAMS];
	CGxnString		m_arrValues[MAX_PARAMS];
	INT				m_nSelectedTemplate;

protected:
	CTracer			ft;
};




#endif // __CMD_PARSE_HEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\multilayer\main.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	main.cpp
**
**
** Abstract:
**
**	Test program to create a backup/multilayer snapshot set
**
** Author:
**
**	Adi Oltean      [aoltean]       02/22/2001
**
** Revision History:
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "ml.h"


///////////////////////////////////////////////////////////////////////////////
// Main functions


extern "C" __cdecl wmain(int argc, WCHAR **argv)
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"wmain");

    try
	{
        CVssMultilayerTest test(argc-1, argv+1);

        // Parsing the command line
        // Eliminate the first argument (program name)
        if (test.ParseCommandLine())
        {
            // Initialize internal objects
            test.Initialize();

            // Run the tests
            test.Run();
        }
	}
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        wprintf(L"\nError catched at program termination: 0x%08lx\n", ft.hr);
    
    return ft.HrFailed() ? 1: 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\multilayer\ml.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	    ml.cpp
**
**
** Abstract:
**
**	    Test program to exercise backup and multilayer snapshots
**
** Author:
**
**	    Adi Oltean      [aoltean]       02/22/2001
**
**
** Revision History:
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "ml.h"

#include "vsbackup.h"

#include "ntddsnap.h"
#include "vss.h"
#include "vscoordint.h"
#include "vsprov.h"
#include <initguid.h>
#include "ichannel.hxx"

#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "vs_reg.hxx"

#include <sddl.h>




// Small structure to keep an event pair
struct CVssWriterEventPair
{
    CVssWriterEventPair(LPWSTR  wszWriterName, INT dwEventID): 
        m_wszWriterName(wszWriterName), m_dwEventID(dwEventID) {};

    // Data members
    LPWSTR  m_wszWriterName;
    INT     m_dwEventID;
};


// The map of event pairs
typedef CVssSimpleMap<CVssWriterEventPair, CVssDiagData*> CVssEventPairMap;


int __cdecl compare_DiagData( const void *arg1, const void *arg2 )
{
    CVssDiagData* pData1 = *((CVssDiagData**)arg1);
    CVssDiagData* pData2 = *((CVssDiagData**)arg2);

    if (pData1->m_llTimestamp < pData2->m_llTimestamp)
        return (-1);
    else if (pData1->m_llTimestamp == pData2->m_llTimestamp)
        return (0);
    else
        return (1);
}


// Needed in order to define correctly the CVssEventPairMap map
inline BOOL VssHashAreKeysEqual( const CVssWriterEventPair& lhK, const CVssWriterEventPair& rhK ) 
{ 
    return ((::wcscmp(lhK.m_wszWriterName, rhK.m_wszWriterName) == 0) && (lhK.m_dwEventID == rhK.m_dwEventID)); 
}





///////////////////////////////////////////////////////////////////////////////
// Processing functions

void CVssMultilayerTest::Initialize()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::Initialize");

    wprintf (L"\n----------------- Initializing ---------------------\n");

    // Initialize the random starting point.
    srand(m_uSeed);

    // Initialize COM library
    CHECK_NOFAIL(CoInitializeEx (NULL, COINIT_MULTITHREADED));
	m_bCoInitializeSucceeded = true;
    wprintf (L"COM library initialized.\n");

    // Initialize COM security
    CHECK_SUCCESS
		(
		CoInitializeSecurity
			(
			NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
			-1,                                  //  IN LONG                         cAuthSvc,
			NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
			NULL,                                //  IN void                        *pReserved1,
			RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
			RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
			NULL,                                //  IN void                        *pAuthList,
			EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
			NULL                                 //  IN void                        *pReserved3
			)
		);
    wprintf (L"COM security initialized.\n");

    // Disable SEH exceptions treatment in COM threads
    ft.ComDisableSEH(VSSDBG_VSSTEST);

    wprintf (L"COM SEH disabled.\n");

}


// Run the tests
void CVssMultilayerTest::Run()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::Run");

    BS_ASSERT(!m_bAttachYourDebuggerNow);

    switch(m_eTest)
    {
    case VSS_TEST_NONE:
        break;
        
    case VSS_TEST_QUERY_VOLUMES:
        QuerySupportedVolumes();
        break;

    case VSS_TEST_QUERY_SNAPSHOTS:
        QuerySnapshots();
        break;

    case VSS_TEST_VOLSNAP_QUERY:
        QueryVolsnap();
        break;

    case VSS_TEST_DELETE_BY_SNAPSHOT_ID:
        DeleteBySnapshotId();
        break;

    case VSS_TEST_DELETE_BY_SNAPSHOT_SET_ID:
        DeleteBySnapshotSetId();
        break;

    case VSS_TEST_QUERY_SNAPSHOTS_ON_VOLUME:
        QuerySnapshotsByVolume();
        break;

    case VSS_TEST_CREATE:
        // Preload the list of existing snapshots
        PreloadExistingSnapshots();

        if (m_lContext)
            CreateTimewarpSnapshotSet();
        else
            CreateBackupSnapshotSet();
        break;

    case VSS_TEST_ADD_DIFF_AREA:
        AddDiffArea();
        break;

    case VSS_TEST_REMOVE_DIFF_AREA:
        RemoveDiffArea();
        break;

    case VSS_TEST_CHANGE_DIFF_AREA_MAX_SIZE:
        ChangeDiffAreaMaximumSize();
        break;

    case VSS_TEST_QUERY_SUPPORTED_VOLUMES_FOR_DIFF_AREA:
        QueryVolumesSupportedForDiffAreas();
        break;

    case VSS_TEST_QUERY_DIFF_AREAS_FOR_VOLUME:
        QueryDiffAreasForVolume();
        break;

    case VSS_TEST_QUERY_DIFF_AREAS_ON_VOLUME:
        QueryDiffAreasOnVolume();
        break;

    case VSS_TEST_QUERY_DIFF_AREAS_FOR_SNAPSHOT:
        QueryDiffAreasForSnapshot();
        break;

    case VSS_TEST_IS_VOLUME_SNAPSHOTTED_C:
        IsVolumeSnapshotted_C();
        break;

    case VSS_TEST_SET_SNAPSHOT_PROPERTIES:
        SetSnapshotProperties();
        break;

    case VSS_TEST_ACCESS_CONTROL_SD:
        TestAccessControlSD();
        break;

    case VSS_TEST_DIAG_WRITERS:
    case VSS_TEST_DIAG_WRITERS_LOG:
    case VSS_TEST_DIAG_WRITERS_CSV:
    case VSS_TEST_DIAG_WRITERS_ON:
    case VSS_TEST_DIAG_WRITERS_OFF:
        DiagnoseWriters(m_eTest);
        break;

    case VSS_TEST_LIST_WRITERS:
        TestListWriters();
        break;
    
    default:
        BS_ASSERT(false);
    }
}


// Querying supported volumes
void CVssMultilayerTest::QuerySupportedVolumes()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::QuerySupportedVolumes");

    wprintf (L"\n---------- Querying supported volumes ----------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_SUCCESS(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get list all snapshots
	CComPtr<IVssEnumMgmtObject> pIEnum;
	CHECK_NOFAIL( pMgmt->QueryVolumesSupportedForSnapshots( m_ProviderId, m_lContext, &pIEnum ) )
	if (ft.hr == S_FALSE) {
        wprintf(L"Query: Empty result...\n");
        return;
	}

    wprintf(L"\n%-50s %-15s\n", L"Volume Name", L"Display name");
    wprintf(L"--------------------------------------------------------------------------------\n");

	// For all volumes do...
	VSS_MGMT_OBJECT_PROP Prop;
	VSS_VOLUME_PROP& Vol = Prop.Obj.Vol;
	for(;;) {
		// Get next element
		ULONG ulFetched;
		CHECK_NOFAIL( pIEnum->Next( 1, &Prop, &ulFetched ) );
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        wprintf(L"%-50s %-15s\n",
            Vol.m_pwszVolumeName,
            Vol.m_pwszVolumeDisplayName
            );

        ::CoTaskMemFree(Vol.m_pwszVolumeName);
        ::CoTaskMemFree(Vol.m_pwszVolumeDisplayName);
	}

    wprintf(L"--------------------------------------------------------------------------------\n");

}


// Querying snapshots
void CVssMultilayerTest::QuerySnapshotsByVolume()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::QuerySnapshotsByVolume");

    wprintf (L"\n---------- Querying snapshots on volume ----------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_NOFAIL(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get list all snapshots
	CComPtr<IVssEnumObject> pIEnumSnapshots;
	CHECK_NOFAIL( pMgmt->QuerySnapshotsByVolume( m_pwszVolume, m_ProviderId, &pIEnumSnapshots ) );
	if (ft.hr == S_FALSE) {
        wprintf(L"Query: Empty result...\n");
        return;
	}

    wprintf(L"\n%-8s %-38s %-50s %-50s %-50s %-50s %-50s %-50s\n", 
        L"Attrib.", L"Snapshot ID", L"Original Volume Name", L"Snapshot device name", L"Originating machine", L"Service machine", L"Exposed name", L"Exposed path");
    wprintf(L"--------------------------------------------------------------------------------------------------------------------------------------------------------------\n");
	// For all snapshots do...
	VSS_OBJECT_PROP Prop;
	VSS_SNAPSHOT_PROP& Snap = Prop.Obj.Snap;
	for(;;) {
		// Get next element
		ULONG ulFetched;
		CHECK_NOFAIL( pIEnumSnapshots->Next( 1, &Prop, &ulFetched ));
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        wprintf(L"%08lx " WSTR_GUID_FMT L" %-50s %-50s %-50s %-50s %-50s\n",
            Snap.m_lSnapshotAttributes,
            GUID_PRINTF_ARG(Snap.m_SnapshotId),
            Snap.m_pwszOriginalVolumeName,
            Snap.m_pwszSnapshotDeviceObject, 
            Snap.m_pwszOriginatingMachine, 
            Snap.m_pwszServiceMachine, 
            Snap.m_pwszExposedName, 
            Snap.m_pwszExposedPath
            );

        ::CoTaskMemFree(Snap.m_pwszOriginalVolumeName);
        ::CoTaskMemFree(Snap.m_pwszSnapshotDeviceObject);
        ::CoTaskMemFree(Snap.m_pwszOriginatingMachine);
        ::CoTaskMemFree(Snap.m_pwszServiceMachine);
        ::CoTaskMemFree(Snap.m_pwszExposedName);
        ::CoTaskMemFree(Snap.m_pwszExposedPath);
	}

    wprintf(L"--------------------------------------------------------------------------------------------------------------------------------------------------------------\n");

}

// Querying snapshots
void CVssMultilayerTest::QuerySnapshots()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::QuerySnapshots");

    wprintf (L"\n---------- Querying existing snapshots ----------------\n");

    // Create a Coordinator interface
    CComPtr<IVssCoordinator> pCoord;
    CHECK_NOFAIL(pCoord.CoCreateInstance( CLSID_VSSCoordinator ));
    if (m_lContext)
        CHECK_NOFAIL(pCoord->SetContext(m_lContext));
    wprintf (L"Coordinator object created with context 0x%08lx.\n", m_lContext);

	// Get list all snapshots
	CComPtr<IVssEnumObject> pIEnumSnapshots;
	CHECK_NOFAIL( pCoord->Query( GUID_NULL, VSS_OBJECT_NONE, VSS_OBJECT_SNAPSHOT, &pIEnumSnapshots ) );
	if (ft.hr == S_FALSE) {
        wprintf(L"Query: Empty result...\n");
        return;
	}

    wprintf(L"\n%-8s %-38s %-50s %-50s %-50s %-50s %-50s %-50s\n", 
        L"Attrib.", L"Snapshot ID", L"Original Volume Name", L"Snapshot device name", L"Originating machine", L"Service machine", L"Exposed name", L"Exposed path");
    wprintf(L"--------------------------------------------------------------------------------------------------------------------------------------------------------------\n");
	// For all snapshots do...
	VSS_OBJECT_PROP Prop;
	VSS_SNAPSHOT_PROP& Snap = Prop.Obj.Snap;
	for(;;) {
		// Get next element
		ULONG ulFetched;
		CHECK_NOFAIL( pIEnumSnapshots->Next( 1, &Prop, &ulFetched ));

		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        wprintf(L"%08lx " WSTR_GUID_FMT L" %-50s %-50s %-50s %-50s %-50s\n",
            Snap.m_lSnapshotAttributes,
            GUID_PRINTF_ARG(Snap.m_SnapshotId),
            Snap.m_pwszOriginalVolumeName,
            Snap.m_pwszSnapshotDeviceObject, 
            Snap.m_pwszOriginatingMachine, 
            Snap.m_pwszServiceMachine, 
            Snap.m_pwszExposedName, 
            Snap.m_pwszExposedPath
            );

        ::CoTaskMemFree(Snap.m_pwszOriginalVolumeName);
        ::CoTaskMemFree(Snap.m_pwszSnapshotDeviceObject);
        ::CoTaskMemFree(Snap.m_pwszOriginatingMachine);
        ::CoTaskMemFree(Snap.m_pwszServiceMachine);
        ::CoTaskMemFree(Snap.m_pwszExposedName);
        ::CoTaskMemFree(Snap.m_pwszExposedPath);
	}

    wprintf(L"--------------------------------------------------------------------------------------------------------------------------------------------------------------\n");

}


// Delete by snapshot Id
void CVssMultilayerTest::DeleteBySnapshotId()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::DeleteBySnapshotId");

    // Create a Timewarp Coordinator interface
    CHECK_NOFAIL(m_pTimewarpCoord.CoCreateInstance( CLSID_VSSCoordinator ));
    CHECK_NOFAIL(m_pTimewarpCoord->SetContext(m_lContext));
    wprintf (L"Timewarp Coordinator object created.\n");

    wprintf (L"\n---------- Deleting TIMEWARP snapshot ----------------\n");

    LONG lDeletedSnapshots = 0;
    VSS_ID ProblemSnapshotId = GUID_NULL;
    ft.hr = m_pTimewarpCoord->DeleteSnapshots(m_SnapshotId,
                VSS_OBJECT_SNAPSHOT,
                TRUE,
                &lDeletedSnapshots,
                &ProblemSnapshotId
                );

    if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
        wprintf( L"Snapshot with ID " WSTR_GUID_FMT L" not found in any provider\n", GUID_PRINTF_ARG(m_SnapshotId));
    else if (ft.hr == S_OK)
        wprintf( L"Snapshot with ID " WSTR_GUID_FMT L" successfully deleted\n", GUID_PRINTF_ARG(m_SnapshotId));
    else
        wprintf( L"Error deleting Snapshot with ID " WSTR_GUID_FMT L" 0x%08lx\n"
                 L"Deleted Snapshots %ld\n",
                 L"Snapshot with problem: " WSTR_GUID_FMT L"\n",
                 GUID_PRINTF_ARG(m_SnapshotId),
                 lDeletedSnapshots,
                 GUID_PRINTF_ARG(ProblemSnapshotId)
                 );

    wprintf (L"\n------------------------------------------------------\n");
}


// Delete by snapshot set Id
void CVssMultilayerTest::DeleteBySnapshotSetId()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::DeleteBySnapshotSetId");

    // Create a Timewarp Coordinator interface
    CHECK_NOFAIL(m_pTimewarpCoord.CoCreateInstance( CLSID_VSSCoordinator ));
    CHECK_NOFAIL(m_pTimewarpCoord->SetContext(m_lContext));
    wprintf (L"Timewarp Coordinator object created.\n");

    wprintf (L"\n---------- Deleting TIMEWARP snapshot set ------------\n");

    LONG lDeletedSnapshots = 0;
    VSS_ID ProblemSnapshotId = GUID_NULL;
    ft.hr = m_pTimewarpCoord->DeleteSnapshots(m_SnapshotSetId,
                VSS_OBJECT_SNAPSHOT_SET,
                TRUE,
                &lDeletedSnapshots,
                &ProblemSnapshotId
                );

    if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
        wprintf( L"Snapshot set with ID " WSTR_GUID_FMT L" not found\n", GUID_PRINTF_ARG(m_SnapshotSetId));
    else if (ft.hr == S_OK)
        wprintf( L"Snapshot set with ID " WSTR_GUID_FMT L" successfully deleted\n", GUID_PRINTF_ARG(m_SnapshotSetId));
    else
        wprintf( L"Error deleting Snapshot set with ID " WSTR_GUID_FMT L" 0x%08lx\n"
                 L"Deleted Snapshots %ld\n",
                 L"Snapshot with problem: " WSTR_GUID_FMT L"\n",
                 GUID_PRINTF_ARG(m_SnapshotSetId),
                 lDeletedSnapshots,
                 GUID_PRINTF_ARG(ProblemSnapshotId)
                 );

    wprintf (L"\n------------------------------------------------------\n");
}


// Querying snapshots using the IOCTL
void CVssMultilayerTest::QueryVolsnap()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::QueryVolsnap");

/*
    // The GUID that corresponds to the format used to store the
    // Backup Snapshot Application Info in Server SKU
    // {BAE53126-BC65-41d6-86CC-3D56A5CEE693}
    const GUID VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU = 
    { 0xbae53126, 0xbc65, 0x41d6, { 0x86, 0xcc, 0x3d, 0x56, 0xa5, 0xce, 0xe6, 0x93 } };

*/

    wprintf (L"\n---------- Querying existing snapshots ----------------\n");

    // Check if the volume represents a real mount point
    WCHAR wszVolumeName[MAX_TEXT_BUFFER];
    if (!GetVolumeNameForVolumeMountPoint(m_pwszVolume, wszVolumeName, MAX_TEXT_BUFFER))
        CHECK_NOFAIL(HRESULT_FROM_WIN32(GetLastError()));

    wprintf(L"Querying snapshots on volume %s\n[From oldest to newest]\n\n", wszVolumeName);

	// Check if the snapshot is belonging to that volume
	// Open a IOCTL channel on that volume
	// Eliminate the last backslash in order to open the volume
	CVssIOCTLChannel volumeIChannel;
	CHECK_NOFAIL(volumeIChannel.Open(ft, wszVolumeName, true, false, VSS_ICHANNEL_LOG_NONE, 0));

	// Get the list of snapshots
	// If IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS not
	// supported then try with the next volume.
	CHECK_NOFAIL(volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, false, VSS_ICHANNEL_LOG_NONE));

	// Get the length of snapshot names multistring
	ULONG ulMultiszLen;
	volumeIChannel.Unpack(ft, &ulMultiszLen);

	// Try to find the snapshot with the corresponding Id
	DWORD dwInitialOffset = volumeIChannel.GetCurrentOutputOffset();

	CVssAutoPWSZ pwszSnapshotName;
	while(volumeIChannel.UnpackZeroString(ft, pwszSnapshotName.GetRef())) {
	
		// Compose the snapshot name in a user-mode style
		WCHAR wszUserModeSnapshotName[MAX_PATH];
        ::VssConcatenate( ft, wszUserModeSnapshotName, MAX_PATH - 1,
            x_wszGlobalRootPrefix, pwszSnapshotName );
		
		// Open that snapshot
		// Do not eliminate the trailing backslash
		// Do not throw on error
    	CVssIOCTLChannel snapshotIChannel;
		CHECK_NOFAIL(snapshotIChannel.Open(ft, wszUserModeSnapshotName, false, false, VSS_ICHANNEL_LOG_NONE, 0));

		// Send the IOCTL to get the application buffer
		CHECK_NOFAIL(snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, false, VSS_ICHANNEL_LOG_NONE));

		// Unpack the length of the application buffer
		ULONG ulLen;
		snapshotIChannel.Unpack(ft, &ulLen);

		if (ulLen == 0) {
            wprintf(L"Zero-size snapshot detected: %s\n", pwszSnapshotName);
			continue;
		}

		// Get the application Id
		VSS_ID AppinfoId;
		snapshotIChannel.Unpack(ft, &AppinfoId);

		// Get the snapshot Id
		VSS_ID CurrentSnapshotId;
		snapshotIChannel.Unpack(ft, &CurrentSnapshotId);

		// Get the snapshot set Id
		VSS_ID CurrentSnapshotSetId;
		snapshotIChannel.Unpack(ft, &CurrentSnapshotSetId);

        if (AppinfoId == VOLSNAP_APPINFO_GUID_BACKUP_CLIENT_SKU)
        {
            // Get the snapshot counts
            LONG lSnapshotsCount;
    		snapshotIChannel.Unpack(ft, &lSnapshotsCount);
    		
            // Reset the ichannel
    		snapshotIChannel.ResetOffsets();

        	// Get the original volume name
        	CHECK_NOFAIL(snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME, false, VSS_ICHANNEL_LOG_NONE));

        	// Load the Original volume name
        	VSS_PWSZ pwszOriginalVolumeName = NULL;
        	snapshotIChannel.UnpackSmallString(ft, pwszOriginalVolumeName);

            // Reset the ichannel
    		snapshotIChannel.ResetOffsets();

        	// Get the timestamp
        	CHECK_NOFAIL(snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_CONFIG_INFO, false, VSS_ICHANNEL_LOG_NONE));

        	// Load the Original volume name
            VOLSNAP_CONFIG_INFO configStruct;
        	snapshotIChannel.Unpack(ft, &configStruct);

    		// Print the snapshot
    		wprintf(
    		    L" * Client Snapshot with name %s:\n"
    		    L"      Application Info: " WSTR_GUID_FMT L"\n"
    		    L"      SnapshotID: " WSTR_GUID_FMT L"\n"
    		    L"      SnapshotSetID: " WSTR_GUID_FMT L"\n"
    		    L"      Snapshot count: %d\n"
    		    L"      Original volume: %s\n"
    		    L"      Attributes: 0x%08lx\n"
    		    L"      Internal attributes: 0x%08lx\n"
    		    L"      Reserved config info: 0x%08lx\n"
    		    L"      Timestamp: %I64x\n"
    		    L"      Structure length: %lu\n"
    		    ,
    		    pwszSnapshotName.GetRef(),
    		    GUID_PRINTF_ARG(AppinfoId),
    		    GUID_PRINTF_ARG(CurrentSnapshotId),
    		    GUID_PRINTF_ARG(CurrentSnapshotSetId),
    		    lSnapshotsCount,
    		    pwszOriginalVolumeName,
    		    configStruct.Attributes,
    		    configStruct.Reserved,
    		    configStruct.SnapshotCreationTime,
    		    ulLen
    		    );

    		::VssFreeString(pwszOriginalVolumeName);
        }
        else
        {

            // Get the snapshot context
            LONG lStructureContext = -1;
    		snapshotIChannel.Unpack(ft, &lStructureContext);

            // Get the snapshot counts
            LONG lSnapshotsCount;
    		snapshotIChannel.Unpack(ft, &lSnapshotsCount);

            // Get the snapshot attributes
            LONG lSnapshotAttributes;
    		snapshotIChannel.Unpack(ft, &lSnapshotAttributes);

            // Get the exposed name
            LPCWSTR pwszExposedName = NULL;
    		snapshotIChannel.UnpackSmallString(ft, pwszExposedName);

            // Get the exposed path
            LPCWSTR pwszExposedPath = NULL;
    		snapshotIChannel.UnpackSmallString(ft, pwszExposedPath);

            // Get the originating machine
            LPCWSTR pwszOriginatingMachine = NULL;
    		snapshotIChannel.UnpackSmallString(ft, pwszOriginatingMachine);

            // Get the service machine
            LPCWSTR pwszServiceMachine = NULL;
    		snapshotIChannel.UnpackSmallString(ft, pwszServiceMachine);

            // Reset the ichannel
    		snapshotIChannel.ResetOffsets();

        	// Get the original volume name
        	CHECK_NOFAIL(snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME, false, VSS_ICHANNEL_LOG_NONE));

        	// Load the Original volume name
        	VSS_PWSZ pwszOriginalVolumeName = NULL;
        	snapshotIChannel.UnpackSmallString(ft, pwszOriginalVolumeName);

            // Reset the ichannel
    		snapshotIChannel.ResetOffsets();

        	// Get the timestamp
        	CHECK_NOFAIL(snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_CONFIG_INFO, false, VSS_ICHANNEL_LOG_NONE));

        	// Load the Original volume name
            VOLSNAP_CONFIG_INFO configStruct;
        	snapshotIChannel.Unpack(ft, &configStruct);

    		// Print the snapshot
    		wprintf(
    		    L" * Server Snapshot with name %s:\n"
    		    L"      Application Info: " WSTR_GUID_FMT L"\n"
    		    L"      SnapshotID: " WSTR_GUID_FMT L"\n"
    		    L"      SnapshotSetID: " WSTR_GUID_FMT L"\n"
    		    L"      Context: 0x%08lx\n"
    		    L"      Snapshot count: %d\n"
    		    L"      Original volume: %s\n"
    		    L"      Attributes: 0x%08lx\n"
    		    L"      Internal attributes: 0x%08lx\n"
    		    L"      Reserved config info: 0x%08lx\n"
    		    L"      Timestamp: %I64x\n"
    		    L"      Exposed name: %s\n"
    		    L"      Exposed path: %s\n"
    		    L"      Originating machine: %s\n"
    		    L"      Service machine: %s\n"
    		    L"      Structure length: %lu\n"
    		    ,
    		    pwszSnapshotName.GetRef(),
    		    GUID_PRINTF_ARG(AppinfoId),
    		    GUID_PRINTF_ARG(CurrentSnapshotId),
    		    GUID_PRINTF_ARG(CurrentSnapshotSetId),
    		    lStructureContext,
    		    lSnapshotsCount,
    		    pwszOriginalVolumeName,
    		    lSnapshotAttributes,
    		    configStruct.Attributes,
    		    configStruct.Reserved,
    		    configStruct.SnapshotCreationTime,
    		    pwszExposedName,
    		    pwszExposedPath,
    		    pwszOriginatingMachine,
    		    pwszServiceMachine,
    		    ulLen
    		    );

    		::VssFreeString(pwszOriginalVolumeName);
    		::VssFreeString(pwszExposedName);
    		::VssFreeString(pwszExposedPath);
    		::VssFreeString(pwszOriginatingMachine);
    		::VssFreeString(pwszServiceMachine);
        }
	}

	// Check if all strings were browsed correctly
	DWORD dwFinalOffset = volumeIChannel.GetCurrentOutputOffset();
	BS_VERIFY( (dwFinalOffset - dwInitialOffset == ulMultiszLen));

    wprintf(L"----------------------------------------------------------\n");

}


// Delete by snapshot set Id
void CVssMultilayerTest::SetSnapshotProperties()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::SetSnapshotProperties");

    // Create a Babbage provider interface
    CComPtr<IVssSoftwareSnapshotProvider> ptrSnapshotProvider;
    CHECK_NOFAIL(ptrSnapshotProvider.CoCreateInstance( CLSID_VSSoftwareProvider ));
    CHECK_NOFAIL(ptrSnapshotProvider->SetContext(m_lContext));
    wprintf (L"Babbage object created.\n");

    wprintf (L"\n---------- Setting the property ------------\n");

    CHECK_NOFAIL(ptrSnapshotProvider->SetSnapshotProperty(m_SnapshotId, 
        (VSS_SNAPSHOT_PROPERTY_ID)m_uPropertyId, 
        m_value));

    wprintf (L"\n------------------------------------------------------\n");
}


// Checks if hte volume is snapshotted using the C API
void CVssMultilayerTest::IsVolumeSnapshotted_C()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::IsVolumeSnapshotted_C");

    wprintf (L"\n---------- Querying IsVolumeSnapshotted ---------------\n");

    BOOL bSnapshotsPresent = FALSE;
    LONG lSnapshotCompatibility = 0;
    CHECK_NOFAIL(IsVolumeSnapshotted(m_pwszVolume, &bSnapshotsPresent, &lSnapshotCompatibility));

    wprintf(L"\n IsVolumeSnapshotted(%s) returned:\n\tSnapshots present = %s\n\tCompatibility flags = 0x%08lx\n\n",
        m_pwszVolume, bSnapshotsPresent? L"True": L"False", lSnapshotCompatibility);

    wprintf(L"----------------------------------------------------------\n");

}


// Preloading  snapshots
void CVssMultilayerTest::PreloadExistingSnapshots()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::PreloadExistingSnapshots");

    wprintf (L"\n---------- Preloading existing snapshots ----------------\n");

    // Create a Timewarp Coordinator interface
    CHECK_NOFAIL(m_pAllCoord.CoCreateInstance( CLSID_VSSCoordinator ));
    CHECK_NOFAIL(m_pAllCoord->SetContext(VSS_CTX_ALL));
    wprintf (L"Timewarp Coordinator object created.\n");

	// Get list all snapshots
	CComPtr<IVssEnumObject> pIEnumSnapshots;
	CHECK_NOFAIL( m_pAllCoord->Query( GUID_NULL,
				VSS_OBJECT_NONE,
				VSS_OBJECT_SNAPSHOT,
				&pIEnumSnapshots ) );

    wprintf(L"\n%-8s %-38s %-50s %-50s\n", L"Attrib.", L"Snapshot ID", L"Original Volume Name", L"Snapshot device name");
    wprintf(L"--------------------------------------------------------------------------------------------------------------------------------------------------------------\n");
	// For all snapshots do...
	VSS_OBJECT_PROP Prop;
	VSS_SNAPSHOT_PROP& Snap = Prop.Obj.Snap;
	for(;;) {
		// Get next element
		ULONG ulFetched;
		CHECK_NOFAIL( pIEnumSnapshots->Next( 1, &Prop, &ulFetched ));
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        wprintf(L"%08lx " WSTR_GUID_FMT L" %-50s %-50s\n",
            Snap.m_lSnapshotAttributes,
            GUID_PRINTF_ARG(Snap.m_SnapshotId),
            Snap.m_pwszOriginalVolumeName,
            Snap.m_pwszSnapshotDeviceObject
            );

        //
        // Adding the snapshot to the internal list
        //

        // Create the new snapshot set object, if not exists
        CVssSnapshotSetInfo* pSet = m_pSnapshotSetCollection.Lookup(Snap.m_SnapshotSetId);
        bool bSetNew = false;
        if (pSet == NULL) {
            pSet = new CVssSnapshotSetInfo(Snap.m_SnapshotSetId);
            if (pSet == NULL)
            {
                ::CoTaskMemFree(Snap.m_pwszOriginalVolumeName);
                ::CoTaskMemFree(Snap.m_pwszSnapshotDeviceObject);
                ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
            }
            bSetNew = true;
        }

        // Create the snapshot info object
        CVssSnapshotInfo* pSnap = new CVssSnapshotInfo(
            true, Snap.m_lSnapshotAttributes,
            Snap.m_SnapshotSetId,
            Snap.m_pwszSnapshotDeviceObject,
            Snap.m_pwszOriginalVolumeName,
            NULL);
        if (pSnap == NULL)
        {
            ::CoTaskMemFree(Snap.m_pwszOriginalVolumeName);
            ::CoTaskMemFree(Snap.m_pwszSnapshotDeviceObject);
            if (bSetNew)
                delete pSet;
            ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
        }

        ::CoTaskMemFree(Snap.m_pwszSnapshotDeviceObject);

        // Add the snapshot to the snapshot set's internal list
        if (!pSet->Add(Snap.m_pwszOriginalVolumeName, pSnap))
        {
            ::CoTaskMemFree(Snap.m_pwszOriginalVolumeName);
            delete pSnap;
            if (bSetNew)
                delete pSet;
            ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
        }

        ::CoTaskMemFree(Snap.m_pwszOriginalVolumeName);

        // Add the snapshot set info to the global list, if needed
        if (bSetNew)
            if (!m_pSnapshotSetCollection.Add(Snap.m_SnapshotSetId, pSet))
                ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
	}

    wprintf(L"--------------------------------------------------------------------------------------------------------------------------------------------------------------\n");

}


// Creating a backup snapshot
void CVssMultilayerTest::CreateTimewarpSnapshotSet()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::CreateTimewarpSnapshotSet");

    // Create a Timewarp Coordinator interface
    CHECK_NOFAIL(m_pTimewarpCoord.CoCreateInstance( CLSID_VSSCoordinator ));
    CHECK_NOFAIL(m_pTimewarpCoord->SetContext(m_lContext));
    wprintf (L"Timewarp Coordinator object created.\n");

    wprintf (L"\n---------- Starting TIMEWARP snapshot ----------------\n");

    CVssVolumeMapNoRemove mapVolumes;
    if (m_uSeed != VSS_SEED)
    {
        // Select one volume. Make sure that we have enough iterations
        for(INT nIterations = 0; nIterations < MAX_VOL_ITERATIONS; nIterations++)
        {
            // If we succeeded to select some volumes then continue;
            if (mapVolumes.GetSize())
                break;

            // Try to select some volumes for backup
            for (INT nIndex = 0; nIndex < m_mapVolumes.GetSize(); nIndex++)
            {
                // Arbitrarily skip volumes
                if (RndDecision())
                    continue;

                CVssVolumeInfo* pVol = m_mapVolumes.GetValueAt(nIndex);
                BS_ASSERT(pVol);

                // WARNING: the test assumes that VSS can have multiple backup snapshots at once.
                if (!mapVolumes.Add(pVol->GetVolumeDisplayName(), pVol))
                    ft.Err(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allcation error");

                // Add only one volume!
                break;
            }
        }
        if (nIterations >= MAX_VOL_ITERATIONS)
        {
            wprintf (L"Warning: a backup snapshot cannot be created. Insufficient volumes?\n");
            wprintf (L"\n---------- Ending TIMEWARP snapshot ----------------\n");
            return;
        }
    }
    else
    {
        // Select all volumes
        for (INT nIndex = 0; nIndex < m_mapVolumes.GetSize(); nIndex++)
        {
            CVssVolumeInfo* pVol = m_mapVolumes.GetValueAt(nIndex);
            BS_ASSERT(pVol);

            // WARNING: the test assumes that VSS can have multiple backup snapshots at once.
            if (!mapVolumes.Add(pVol->GetVolumeDisplayName(), pVol))
                ft.Err(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allcation error");
        }
    }

    wprintf(L"\tCurrent volume set:\n");
    for (INT nIndex = 0; nIndex < mapVolumes.GetSize(); nIndex++)
    {
        CVssVolumeInfo* pVol = mapVolumes.GetValueAt(nIndex);
        BS_ASSERT(pVol);

		// Get the volume containing the path
        wprintf(L"\t- Volume %s mounted on %s\n", pVol->GetVolumeName(), pVol->GetVolumeDisplayName() );
    }
	
    wprintf (L"\n---------- starting the snapshot set ---------------\n");

	CComPtr<IVssAsync> pAsync;
	CSimpleArray<VSS_ID > pSnapshotIDsArray;
	VSS_ID SnapshotSetId = GUID_NULL;

    // Starting a new snapshot set
    wprintf(L"Starting a new Snapshot Set\n");	
    CHECK_SUCCESS(m_pTimewarpCoord->StartSnapshotSet(&SnapshotSetId));
    wprintf(L"Snapshot Set created with ID = " WSTR_GUID_FMT L"\n", GUID_PRINTF_ARG(SnapshotSetId));

    // Add volumes to the snapshot set
    wprintf(L"Adding volumes to the Snapshot Set: \n");
    for (INT nIndex = 0; nIndex < mapVolumes.GetSize(); nIndex++)
    {
        CVssVolumeInfo* pVol = mapVolumes.GetValueAt(nIndex);
        BS_ASSERT(pVol);

		// Get the volume containing the path
        wprintf(L"\t- Adding volume %s ... ", pVol->GetVolumeDisplayName() );

		// Add the volume to the snapshot set
		VSS_ID SnapshotId;
        CHECK_SUCCESS(m_pTimewarpCoord->AddToSnapshotSet(pVol->GetVolumeName(),
            GUID_NULL, &SnapshotId));

        // Add the snapshot to the array
        pSnapshotIDsArray.Add(SnapshotId);
        BS_ASSERT(nIndex + 1 == pSnapshotIDsArray.GetSize());
        wprintf( L"OK\n");
    }

    wprintf (L"\n------------ Creating the snapshot -----------------\n");

    // Create the snapshot
    wprintf(L"\nStarting asynchronous DoSnapshotSet. Please wait...\n");	
    ft.hr = S_OK;
    pAsync = NULL;
    CHECK_SUCCESS(m_pTimewarpCoord->DoSnapshotSet(NULL, &pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	HRESULT hrReturned = S_OK;
	CHECK_SUCCESS(pAsync->QueryStatus(&hrReturned, NULL));
	CHECK_NOFAIL(hrReturned);
    wprintf(L"Asynchronous DoSnapshotSet finished.\n");	

    wprintf(L"Snapshot set created\n");

    // Create the new snapshot set object
    CVssSnapshotSetInfo* pSet = new CVssSnapshotSetInfo(SnapshotSetId);
    if (pSet == NULL)
        ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");

    for (INT nIndex = 0; nIndex < mapVolumes.GetSize(); nIndex++)
    {
        CVssVolumeInfo* pVol = mapVolumes.GetValueAt(nIndex);
        BS_ASSERT(pVol);

        if (pSnapshotIDsArray[nIndex] == GUID_NULL)
            continue;

        VSS_SNAPSHOT_PROP prop;
        CHECK_SUCCESS(m_pTimewarpCoord->GetSnapshotProperties(pSnapshotIDsArray[nIndex], &prop));
        wprintf(L"\t- The snapshot on volume %s resides at %s\n",
            pVol->GetVolumeDisplayName(), prop.m_pwszSnapshotDeviceObject);

        // Create the snapshot info object
        CVssSnapshotInfo* pSnap = new CVssSnapshotInfo(
            true, VSS_CTX_CLIENT_ACCESSIBLE, SnapshotSetId, prop.m_pwszSnapshotDeviceObject, pVol->GetVolumeName(), pVol);
        if (pSnap == NULL)
        {
            ::VssFreeSnapshotProperties(&prop);
            delete pSet;
            ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
        }

        ::VssFreeSnapshotProperties(&prop);

        // Add the snapshot to the snapshot set's internal list
        if (!pSet->Add(pVol->GetVolumeName(), pSnap))
        {
            delete pSnap;
            delete pSet;
            ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
        }
    }

    // Add the snapshot set info to the global list
    if (!m_pSnapshotSetCollection.Add(SnapshotSetId, pSet))
    {
        delete pSet;
        ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
    }

    wprintf (L"\n---------- TIMEWARP snapshot created -----------------\n");

    // Wait for user input
    wprintf(L"\nPress <Enter> to continue...\n");
    getwchar();

}


// Creating a backup snapshot
void CVssMultilayerTest::CreateBackupSnapshotSet()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::CreateBackupSnapshotSet");

    // Create the Backup components object and initialize for backup
	CHECK_NOFAIL(CreateVssBackupComponents(&m_pBackupComponents));
	CHECK_NOFAIL(m_pBackupComponents->InitializeForBackup());
	CHECK_SUCCESS(m_pBackupComponents->SetBackupState( false, true, VSS_BT_FULL, false));
    wprintf (L"Backup components object created.\n");

    DisplayCurrentTime();
    
    // Gather writer metadata
    GatherWriterMetadata();
    GatherWriterStatus(L"after GatherWriterMetadata", VSS_QWS_DISPLAY_WRITER_STATUS);

    wprintf (L"\n---------- Starting BACKUP snapshot ----------------\n");

    DisplayCurrentTime();

    // Compute a set of volumes.
    // Select at least one volume. Make sure that we have enough iterations
    CVssVolumeMapNoRemove mapVolumes;
    if (m_uSeed != VSS_SEED)
    {
        for(INT nIterations = 0; nIterations < MAX_VOL_ITERATIONS; nIterations++)
        {
            // If we succeeded to select some volumes then continue;
            if (mapVolumes.GetSize())
                break;

            // Try to select some volumes for backup
            for (INT nIndex = 0; nIndex < m_mapVolumes.GetSize(); nIndex++)
            {
                // Arbitrarily skip volumes
                if (RndDecision())
                    continue;

                CVssVolumeInfo* pVol = m_mapVolumes.GetValueAt(nIndex);
                BS_ASSERT(pVol);

                // WARNING: the test assumes that VSS can have multiple backup snapshots at once.
                if (!mapVolumes.Add(pVol->GetVolumeDisplayName(), pVol))
                    ft.Err(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allcation error");
            }
        }
        if (nIterations >= MAX_VOL_ITERATIONS)
        {
            wprintf (L"Warning: a backup snapshot cannot be created. Insufficient volumes?\n");
            wprintf (L"\n---------- Ending BACKUP snapshot ----------------\n");
            return;
        }
    }
    else
    {
        // Select all volumes
        for (INT nIndex = 0; nIndex < m_mapVolumes.GetSize(); nIndex++)
        {
            CVssVolumeInfo* pVol = m_mapVolumes.GetValueAt(nIndex);
            BS_ASSERT(pVol);

            // WARNING: the test assumes that VSS can have multiple backup snapshots at once.
            if (!mapVolumes.Add(pVol->GetVolumeDisplayName(), pVol))
                ft.Err(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allcation error");
        }
    }

    wprintf(L"\tCurrent volume set:\n");
    for (INT nIndex = 0; nIndex < mapVolumes.GetSize(); nIndex++)
    {
        CVssVolumeInfo* pVol = mapVolumes.GetValueAt(nIndex);
        BS_ASSERT(pVol);

		// Get the volume containing the path
        wprintf(L"\t- Volume %s mounted on %s\n", pVol->GetVolumeName(), pVol->GetVolumeDisplayName() );
    }
	
    wprintf (L"\n---------- starting the snapshot set ---------------\n");

	CComPtr<IVssAsync> pAsync;
	CSimpleArray<VSS_ID > pSnapshotIDsArray;
	VSS_ID SnapshotSetId = GUID_NULL;

    // Starting a new snapshot set
    wprintf(L"Starting a new Snapshot Set\n");	
    CHECK_SUCCESS(m_pBackupComponents->StartSnapshotSet(&SnapshotSetId));
    wprintf(L"Snapshot Set created with ID = " WSTR_GUID_FMT L"\n", GUID_PRINTF_ARG(SnapshotSetId));

    // Add volumes to the snapshot set
    wprintf(L"Adding volumes to the Snapshot Set: \n");
    for (INT nIndex = 0; nIndex < mapVolumes.GetSize(); nIndex++)
    {
        CVssVolumeInfo* pVol = mapVolumes.GetValueAt(nIndex);
        BS_ASSERT(pVol);

		// Get the volume containing the path
        wprintf(L"\t- Adding volume %s ... ", pVol->GetVolumeDisplayName() );

		// Add the volume to the snapshot set
		VSS_ID SnapshotId;
        CHECK_SUCCESS(m_pBackupComponents->AddToSnapshotSet(pVol->GetVolumeName(),
            GUID_NULL, &SnapshotId));

        // Add the snapshot to the array
        pSnapshotIDsArray.Add(SnapshotId);
        BS_ASSERT(nIndex + 1 == pSnapshotIDsArray.GetSize());
        wprintf( L"OK\n");
    }

    wprintf (L"\n------------ Creating the snapshot -----------------\n");

    DisplayCurrentTime();

    // Prepare for backup
    wprintf(L"Starting asynchronous PrepareForBackup. Please wait...\n");	
    ft.hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->PrepareForBackup(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	HRESULT hrReturned = S_OK;
	CHECK_SUCCESS(pAsync->QueryStatus(&hrReturned, NULL));
	CHECK_NOFAIL(hrReturned);
    wprintf(L"Asynchronous PrepareForBackup finished.\n");	

    GatherWriterStatus(L"after PrepareForBackup");

    DisplayCurrentTime();
    
    // Create the snapshot
    wprintf(L"\nStarting asynchronous DoSnapshotSet. Please wait...\n");	
    ft.hr = S_OK;
    pAsync = NULL;
    CHECK_SUCCESS(m_pBackupComponents->DoSnapshotSet(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hrReturned, NULL));
	CHECK_NOFAIL(hrReturned);
    wprintf(L"Asynchronous DoSnapshotSet finished.\n");	

    wprintf(L"Snapshot set created\n");

    DisplayCurrentTime();
    
    GatherWriterStatus(L"after DoSnapshotSet");

    // Create the new snapshot set object
    CVssSnapshotSetInfo* pSet = new CVssSnapshotSetInfo(SnapshotSetId);
    if (pSet == NULL)
        ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");

    for (INT nIndex = 0; nIndex < mapVolumes.GetSize(); nIndex++)
    {
        CVssVolumeInfo* pVol = mapVolumes.GetValueAt(nIndex);
        BS_ASSERT(pVol);

        if (pSnapshotIDsArray[nIndex] == GUID_NULL)
            continue;

        VSS_SNAPSHOT_PROP prop;
        CHECK_SUCCESS(m_pBackupComponents->GetSnapshotProperties(pSnapshotIDsArray[nIndex], &prop));
        wprintf(L"\t- The snapshot on volume %s resides at %s\n",
            pVol->GetVolumeDisplayName(), prop.m_pwszSnapshotDeviceObject);

        // Create the snapshot info object
        CVssSnapshotInfo* pSnap = new CVssSnapshotInfo(
            true, VSS_CTX_BACKUP, SnapshotSetId, prop.m_pwszSnapshotDeviceObject, pVol->GetVolumeName(), pVol);
        if (pSnap == NULL)
        {
            ::VssFreeSnapshotProperties(&prop);
            delete pSet;
            ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
        }

        ::VssFreeSnapshotProperties(&prop);

        // Add the snapshot to the snapshot set's internal list
        if (!pSet->Add(pVol->GetVolumeName(), pSnap))
        {
            delete pSnap;
            delete pSet;
            ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
        }
    }

    // Add the snapshot set info to the global list
    if (!m_pSnapshotSetCollection.Add(SnapshotSetId, pSet))
    {
        delete pSet;
        ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
    }

    wprintf (L"\n---------- BACKUP snapshot created -----------------\n");

    // Wait for user input
    wprintf(L"\nPress <Enter> to continue...\n");
    getwchar();

    DisplayCurrentTime();
    
    // Complete the backup
    BackupComplete();

    GatherWriterStatus(L"after BackupComplete");

    DisplayCurrentTime();
}


void CVssMultilayerTest::BackupComplete()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::BackupComplete");

	CComPtr<IVssAsync> pAsync;

    wprintf (L"\n------------ Completing backup phase ---------------\n");

	// Send the BackupComplete event
    wprintf(L"\nStarting asynchronous BackupComplete. Please wait...\n");	
    ft.hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->BackupComplete(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	HRESULT hrReturned = S_OK;
	CHECK_SUCCESS(pAsync->QueryStatus(&hrReturned, NULL));
	CHECK_NOFAIL(hrReturned);
    wprintf(L"Asynchronous BackupComplete finished.\n");	
}


// Gather writera metadata and select components for backup, if needed
void CVssMultilayerTest::GatherWriterMetadata()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::GatherWriterMetadata");

	unsigned cWriters;
	CComPtr<IVssAsync> pAsync;
	
    wprintf (L"\n---------- Gathering writer metadata ---------------\n");
	
    wprintf(L"Starting asynchronous GatherWriterMetadata. Please wait...\n");	
    ft.hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->GatherWriterMetadata(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	HRESULT hrReturned = S_OK;
	CHECK_SUCCESS(pAsync->QueryStatus(&hrReturned, NULL));
	CHECK_NOFAIL(hrReturned);
    wprintf(L"Asynchronous GatherWriterMetadata finished.\n");	
	
	CHECK_NOFAIL  (m_pBackupComponents->GetWriterMetadataCount (&cWriters));
    wprintf(L"Number of writers that responded: %u\n", cWriters);	
	
	CHECK_SUCCESS (m_pBackupComponents->FreeWriterMetadata());
}


void CVssMultilayerTest::GatherWriterStatus(
    IN  LPCWSTR wszWhen,
    DWORD dwQWSFlags /* = VSS_QWS_THROW_ON_WRITER_FAILURE */
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::GatherWriterMetadata");

    unsigned cWriters;
	CComPtr<IVssAsync> pAsync;

    wprintf (L"\nGathering writer status %s... ", wszWhen);
    ft.hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->GatherWriterStatus(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	HRESULT hrReturned = S_OK;
	CHECK_SUCCESS(pAsync->QueryStatus(&hrReturned, NULL));
	CHECK_NOFAIL(hrReturned);
	CHECK_NOFAIL(m_pBackupComponents->GetWriterStatusCount(&cWriters));

    wprintf (L"%d writers responded OK\n", cWriters);

    if (dwQWSFlags & VSS_QWS_DISPLAY_WRITER_STATUS)
    {
        wprintf(L"\n\nStatus %s (%d writers)\n\n", wszWhen, cWriters);
        
        // Print the writers state
        for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
        {
            VSS_ID idInstance;
            VSS_ID idWriter;
            VSS_WRITER_STATE status;
            CComBSTR bstrWriter;
            HRESULT hrWriterFailure;
            
            CHECK_SUCCESS(m_pBackupComponents->GetWriterStatus (iWriter,
                                 &idInstance,
                                 &idWriter,
                                 &bstrWriter,
                                 &status,
                                 &hrWriterFailure));
            
            wprintf (L"Status for writer %s: %s(0x%08lx%s%s)\n",
                 bstrWriter,
                 GetStringFromWriterState(status),
                 hrWriterFailure,
                 SUCCEEDED (hrWriterFailure) ? L"" : L" - ",
                 GetStringFromFailureType (hrWriterFailure));
        }
        
        wprintf (L"\n");
        
    }

    if (dwQWSFlags & VSS_QWS_THROW_ON_WRITER_FAILURE)
    {
        // Double-check that all writers are in stable state
        for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
        {
            VSS_ID idInstance;
            VSS_ID idWriter;
            VSS_WRITER_STATE status;
            CComBSTR bstrWriter;
            HRESULT hrWriterFailure;
            
            CHECK_SUCCESS(m_pBackupComponents->GetWriterStatus (iWriter,
                                 &idInstance,
                                 &idWriter,
                                 &bstrWriter,
                                 &status,
                                 &hrWriterFailure));

            switch(status)
            {
            case VSS_WS_STABLE:
            case VSS_WS_WAITING_FOR_FREEZE:
            case VSS_WS_WAITING_FOR_THAW:
            case VSS_WS_WAITING_FOR_POST_SNAPSHOT:
            case VSS_WS_WAITING_FOR_BACKUP_COMPLETE:
                break;

            default:
                
                wprintf( 
                    L"\n\nError: \n\t- Writer %s is not stable: %s(0x%08lx%s%s). \n",
                    bstrWriter,
                    GetStringFromWriterState(status),
                    hrWriterFailure,
                    SUCCEEDED (hrWriterFailure) ? L"" : L" - ",
                    GetStringFromFailureType (hrWriterFailure)
                    );
                throw(E_UNEXPECTED);
            }
        }
    }
    
    m_pBackupComponents->FreeWriterStatus();

    wprintf (L"\n");

}


CVssMultilayerTest::CVssMultilayerTest(
        IN  INT nArgsCount,
        IN  WCHAR ** ppwszArgsArray
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::CVssMultilayerTest");

    // Initialize data members
    m_bCoInitializeSucceeded = false;
    m_bAttachYourDebuggerNow = false;

    // Command line options
    m_eTest = VSS_TEST_UNKNOWN;
    m_uSeed = VSS_SEED;
    m_lContext = VSS_CTX_BACKUP;
    m_pwszVolume = NULL;
    m_pwszDiffAreaVolume = NULL;
    m_ProviderId = VSS_SWPRV_ProviderId;
    m_llMaxDiffArea = VSS_ASSOC_NO_MAX_SPACE;
    m_SnapshotId = GUID_NULL;
    m_SnapshotSetId = GUID_NULL;
    m_uPropertyId = 0;

    // Command line arguments
    m_nCurrentArgsCount = nArgsCount;
    m_ppwszCurrentArgsArray = ppwszArgsArray;

    // Print display header
    wprintf(L"\nVSS Multilayer Test application, version 1.0\n");
}


CVssMultilayerTest::~CVssMultilayerTest()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::~CVssMultilayerTest");

    VssFreeString(m_pwszVolume);
    VssFreeString(m_pwszDiffAreaVolume);

    m_pTimewarpCoord = NULL;
    m_pAllCoord = NULL;
    m_pBackupComponents = NULL;

    // Unloading the COM library
    if (m_bCoInitializeSucceeded)
        CoUninitialize();
}


void CVssMultilayerTest::TestAccessControlSD()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::TestAccessControlSD");

    wprintf (L"\n----------------- TestAccessControlSD ---------------------\n\n");
    
    CVssSidCollection sidCollection;

    // Read keys from registry
    sidCollection.Initialize();

    // Print contents of the list
    for (INT nIndex = 0; nIndex < sidCollection.GetSidCount(); nIndex++)
    {
        CVssAutoLocalString sid;
        CHECK_WIN32( ConvertSidToStringSid( 
            sidCollection.GetSid(nIndex), sid.ResetAndGetAddress()), ;);

        wprintf(L"\n* entry[%d]: '%s' '%s' %s\n", nIndex, 
            sidCollection.GetPrincipal(nIndex), sid.Get(), 
            sidCollection.IsSidAllowed(nIndex)? L"Allowed": L"Denied" );
    }

    wprintf (L"\n----------------------------------------------------------\n");
}


// Print out diagnostic information for writers
void CVssMultilayerTest::DiagnoseWriters(
		IN EVssTestType eType
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::DiagnoseWriters");

    wprintf (L"\n----------------- DiagnoseWriters ---------------------\n\n");

    if (eType == VSS_TEST_DIAG_WRITERS_ON)
    {
        // Turn on diag
        CVssRegistryKey keyDiag;
        if (!keyDiag.Open(HKEY_LOCAL_MACHINE, x_wszVssDiagPath ))
            keyDiag.Create(HKEY_LOCAL_MACHINE, x_wszVssDiagPath );

        CVssSecurityDescriptor    objSD;

        // Build the securityd descriptor
        ft.hr = objSD.InitializeFromThreadToken();
        if (ft.HrFailed())
            ft.TranslateGenericError( VSSDBG_GEN, ft.hr, L"objSD.InitializeFromThreadToken()");

        // Make sure the SACL is NULL (not supported by COM)
        if (objSD.m_pSACL) {
            free(objSD.m_pSACL);
            objSD.m_pSACL= NULL;
        }

        CVssSidCollection sidCollection;
        sidCollection.Initialize();

        // Add principals to the DACL
        for (INT nIndex = 0; nIndex < sidCollection.GetSidCount(); nIndex++)
        {
            if (sidCollection.IsSidAllowed(nIndex))
            {
                ft.hr = objSD.Allow(sidCollection.GetSid(nIndex), 
                                KEY_ALL_ACCESS,         // Registry access rights (for Diag)
                                CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
                                );
                if (ft.HrFailed())
                    ft.TranslateGenericError( VSSDBG_GEN, ft.hr, 
                        L"objSD.Allow(%s, COM_RIGHTS_EXECUTE);", 
                            sidCollection.GetPrincipal(nIndex));
            }
            else
            {
                ft.hr = objSD.Deny(sidCollection.GetSid(nIndex), 
                                KEY_ALL_ACCESS,         // Registry access rights (for Diag)
                                CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
                                );
                if (ft.HrFailed())
                    ft.TranslateGenericError( VSSDBG_GEN, ft.hr, 
                        L"objSD.Deny(%s, COM_RIGHTS_EXECUTE);", 
                            sidCollection.GetPrincipal(nIndex));
            }
        }

        // Set the correct security on the Diag key (so that third-party writers will be diagnosed correctly)
        SECURITY_INFORMATION secInfo = DACL_SECURITY_INFORMATION;
        DWORD dwRes = ::RegSetKeySecurity( keyDiag.GetHandle(), secInfo, objSD );
        if (dwRes != ERROR_SUCCESS)
            ft.TranslateGenericError( VSSDBG_COORD, HRESULT_FROM_WIN32(dwRes), 
                L"::RegSetKeySecurity( keyDiag.GetHandle(), secInfo, objSD )");

        // Enable the diag in the registry
        keyDiag.SetValue(L"", x_wszVssDiagEnabledValue);

        wprintf (L"Diagnose writers is now turned on.\n");

        wprintf (L"\n-----------------------------------------------\n\n");
        return;
    }

    if (eType == VSS_TEST_DIAG_WRITERS_OFF)
    {
        // Disable the diag in the registry
        CVssRegistryKey keyDiag;
        if (keyDiag.Open(HKEY_LOCAL_MACHINE, x_wszVssDiagPath )) {
            keyDiag.SetValue(L"", L"");
            keyDiag.Close();
        }
        
        // Turn off diag
        CVssRegistryKey keyVSS;
        if (keyVSS.Open(HKEY_LOCAL_MACHINE, x_wszVSSKey ))
            keyVSS.DeleteSubkey( L"Diag" );

        wprintf (L"Diagnose writers is now turned off.\n");

        wprintf (L"\n-----------------------------------------------\n\n");
        return;
    }

    CVssSimpleMap<INT,CVssDiagData*>  arrEvents;

    // Enumerate all keys under diag
    CVssRegistryKey keyDiag;
    if (!keyDiag.Open(HKEY_LOCAL_MACHINE, x_wszVssDiagPath)){
        wprintf (L"\nDiagnose disabled...\n\n");
        wprintf (L"\n----------------------------------------------------------\n");
        return;
    }

    CVssRegistryKeyIterator keyIterator;
    keyIterator.Attach(keyDiag);

    INT nIndex = 0;
    for( ;!keyIterator.IsEOF(); keyIterator.MoveNext())
    {
		CVssRegistryKey keyWriter(KEY_QUERY_VALUE);
		if (!keyWriter.Open(keyDiag.GetHandle(), keyIterator.GetCurrentKeyName()))
			ft.Throw (VSSDBG_VSSTEST, E_UNEXPECTED, 
				L"Failed to open registry entry for key %s", keyIterator.GetCurrentKeyName());

        CVssRegistryValueIterator valIterator;
    	valIterator.Attach(keyWriter);

    	// for each value take the value name as the user name (in the "domain\user" format)
    	for(;!valIterator.IsEOF();valIterator.MoveNext())
    	{
    	    // Check to see ifthe value is of the right type
    	    if (valIterator.GetCurrentValueType() != REG_BINARY) {
    	        ft.Trace( VSSDBG_VSSTEST,  
    				L"Invalid data for value %s on key %s", 
				    valIterator.GetCurrentValueName(),
				    keyIterator.GetCurrentKeyName());
                continue;
    	    }

            // Get the allow/deny flag
            CVssAutoCppPtr<PBYTE> awszBuffer;
            DWORD cbSize = 0;
            valIterator.GetCurrentValueContent(*(awszBuffer.ResetAndGetAddress()), cbSize);

            // Copy the value into a local CVssDiagData buffer
            if (cbSize != sizeof(CVssDiagData)) {
    	        ft.Trace( VSSDBG_VSSTEST,  
    				L"Invalid data for value %s on key %s [%ld, %ld]", 
				    valIterator.GetCurrentValueName(),
				    keyIterator.GetCurrentKeyName(),
				    cbSize, sizeof(CVssDiagData));
                continue;
    	    }

            // We should allocate again (alignment problems)
            CVssAutoCppPtr<CVssDiagData*> pDiag = new CVssDiagData;
            if (!pDiag.IsValid())
                ft.ThrowOutOfMemory(VSSDBG_VSSTEST);

            CopyMemory((LPVOID)pDiag.Get(), (LPVOID)awszBuffer.Get(), sizeof(CVssDiagData));

            // Get the writer name
            CVssAutoLocalString strWriterName;
            strWriterName.CopyFrom(keyIterator.GetCurrentKeyName());
            pDiag.Get()->m_pReserved1 = (LPVOID)strWriterName.Detach();

            // Get the event name
            CVssAutoLocalString strEventName;
            strEventName.CopyFrom(valIterator.GetCurrentValueName());
            pDiag.Get()->m_pReserved2 = (LPVOID)strEventName.Detach();

            // Add the buffer into the dynamic array
            if (!arrEvents.Add(nIndex++, pDiag))
                ft.ThrowOutOfMemory(VSSDBG_VSSTEST);

            pDiag.Detach();
    	}
    }

    // Sort the array
    CVssDiagData** pArrDiagData = arrEvents.m_aVal;
    qsort( (void*)pArrDiagData, arrEvents.GetSize(), sizeof(CVssDiagData*), &compare_DiagData);

    CVssEventPairMap arrEventPairs;

    if (eType == VSS_TEST_DIAG_WRITERS_CSV)
        wprintf(L"%s,%s,%s,%s,%s,%s,%s,%s,%s\n", 
            L"Date & Time", L"PID", L"TID", 
            L"Writer", L"Event",
            L"Timestamp", 
            L"State", L"Last error code",
            L"Snapshot Set ID");

    // Print the result and deallocate array elements
    for (nIndex = 0; nIndex < arrEvents.GetSize(); nIndex++)
    {
        CVssDiagData* pData = arrEvents.GetValueAt(nIndex);

        // Convert the timestamp into a readable value
        CVssAutoLocalString pwszDateTime;
        pwszDateTime.Attach(DateTimeToString(pData->m_llTimestamp));

        LPWSTR wszWriterName = (LPWSTR)pData->m_pReserved1;
        LPWSTR wszEventName = (LPWSTR)pData->m_pReserved2;

        if (eType == VSS_TEST_DIAG_WRITERS_LOG)
            wprintf(L"* [%s - %ld.%ld] %s.%s\n  (0x%016I64x, 0x%08lx, 0x%08lx, " WSTR_GUID_FMT L")\n\n", 
                pwszDateTime.Get(), pData->m_dwProcessID, pData->m_dwThreadID, 
                wszWriterName, wszEventName,
                pData->m_llTimestamp, 
                pData->m_dwCurrentState, pData->m_hrLastErrorCode,
                GUID_PRINTF_ARG(pData->m_guidSnapshotSetID));

        if (eType == VSS_TEST_DIAG_WRITERS_CSV)
            wprintf(L"%s,%ld,%ld,%s,%s,0x%016I64x,0x%08lx,0x%08lx," WSTR_GUID_FMT L"\n", 
                pwszDateTime.Get(), pData->m_dwProcessID, pData->m_dwThreadID, 
                wszWriterName, wszEventName,
                pData->m_llTimestamp, 
                pData->m_dwCurrentState, pData->m_hrLastErrorCode,
                GUID_PRINTF_ARG(pData->m_guidSnapshotSetID));

        // Find events that have an Enter but not a Leave.
        // Ignore one-time events (known to have an enter but no leave)
        if ((pData->m_dwEventContext & CVssDiag::VSS_DIAG_IGNORE_LEAVE) == 0)
        {
            // If the element is an "Enter" then add it to the map
            CVssDiagData* pPrevData = arrEventPairs.Lookup( 
                CVssWriterEventPair(wszWriterName, pData->m_dwEventID) );
            if (pPrevData == NULL)
            {
                if (!arrEventPairs.Add( 
                        CVssWriterEventPair(wszWriterName, pData->m_dwEventID), pData))
                    ft.ThrowOutOfMemory(VSSDBG_VSSTEST);
            }
            else
            {
                // If we have an old enter and a new leave, then remove the entry 
                if (!(pData->m_dwEventContext & CVssDiag::VSS_DIAG_ENTER_OPERATION) && 
                    (pPrevData->m_dwEventContext & CVssDiag::VSS_DIAG_ENTER_OPERATION) && 
                    (pData->m_llTimestamp >= pPrevData->m_llTimestamp))
                {
                    arrEventPairs.Remove( CVssWriterEventPair(wszWriterName, pData->m_dwEventID) );
                    continue;
                }

                // If we have an enter leave of the same age, then remove the entry 
                if ((pData->m_dwEventContext & CVssDiag::VSS_DIAG_ENTER_OPERATION) && 
                    !(pPrevData->m_dwEventContext & CVssDiag::VSS_DIAG_ENTER_OPERATION) && 
                    (pData->m_llTimestamp == pPrevData->m_llTimestamp))
                {
                    arrEventPairs.Remove( CVssWriterEventPair(wszWriterName, pData->m_dwEventID) );
                    continue;
                }
                
                // otherwise keep the most recent event
                if (pData->m_llTimestamp > pPrevData->m_llTimestamp)
                    arrEventPairs.SetAt( 
                        CVssWriterEventPair(wszWriterName, pData->m_dwEventID), pData);
            }
        }
    }

    // Display the list of pending operations
    if (arrEventPairs.GetSize() != 0)
        wprintf(L"\n\n --- Pending writers: --- \n\n");
    else 
        wprintf(L"\n\n --- No pending writers --- \n\n");

    if (eType == VSS_TEST_DIAG_WRITERS_CSV)
        wprintf(L"%s,%s,%s,%s,%s,%s,%s,%s,%s\n", 
            L"Date & Time", L"PID", L"TID", 
            L"Writer", L"Event",
            L"Timestamp", 
            L"State", L"Last error code",
            L"Snapshot Set ID");
    
    for (nIndex = 0; nIndex < arrEventPairs.GetSize(); nIndex++)
    {
        CVssDiagData* pData = arrEventPairs.GetValueAt(nIndex);
        BS_ASSERT(pData);

        // Convert the timestamp into a readable value
        CVssAutoLocalString pwszDateTime;
        pwszDateTime.Attach(DateTimeToString(pData->m_llTimestamp));

        LPWSTR wszWriterName = (LPWSTR)pData->m_pReserved1;
        LPWSTR wszEventName = (LPWSTR)pData->m_pReserved2;

        if (eType == VSS_TEST_DIAG_WRITERS_CSV)
            wprintf(L"%s,%ld.%ld,%s.%s,0x%08lx,0x%08lx," WSTR_GUID_FMT L"\n", 
                pwszDateTime.Get(), pData->m_dwProcessID, pData->m_dwThreadID, 
                wszWriterName, wszEventName,
                pData->m_dwCurrentState, pData->m_hrLastErrorCode,
                GUID_PRINTF_ARG(pData->m_guidSnapshotSetID));
        else
            wprintf(L"* [%s - %ld.%ld] %s.%s\n  (0x%08lx, 0x%08lx, " WSTR_GUID_FMT L")\n\n", 
                pwszDateTime.Get(), pData->m_dwProcessID, pData->m_dwThreadID, 
                wszWriterName, wszEventName,
                pData->m_dwCurrentState, pData->m_hrLastErrorCode,
                GUID_PRINTF_ARG(pData->m_guidSnapshotSetID));
    }

    // Deallocate elements
    for (nIndex = 0; nIndex < arrEvents.GetSize(); nIndex++)
    {
        CVssAutoCppPtr<CVssDiagData*> ptrData = arrEvents.GetValueAt(nIndex);
        CVssDiagData* pData = ptrData.Get();
        CVssAutoLocalString wszWriterName = (LPWSTR)pData->m_pReserved1;
        CVssAutoLocalString wszEventName = (LPWSTR)pData->m_pReserved2;
    }

    wprintf (L"\n----------------------------------------------------------\n");
}


// Just list writers
void CVssMultilayerTest::TestListWriters()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::TestListWriters");

    // Create the Backup components object and initialize for backup
    CHECK_NOFAIL(CreateVssBackupComponents(&m_pBackupComponents));
    CHECK_NOFAIL(m_pBackupComponents->InitializeForBackup());
    CHECK_SUCCESS(m_pBackupComponents->SetBackupState( false, true, VSS_BT_FULL, false));
    wprintf (L"Backup components object created.\n");

    DisplayCurrentTime();
    
    // Gather writer metadata
    GatherWriterMetadata();
    GatherWriterStatus(L"after GatherWriterMetadata", 
        VSS_QWS_DISPLAY_WRITER_STATUS | VSS_QWS_THROW_ON_WRITER_FAILURE);

    DisplayCurrentTime();

}


// Just display the current date and time
void CVssMultilayerTest::DisplayCurrentTime()
{
    // Convert the timestamp into a readable value
    CVsFileTime filetime;
    CVssAutoLocalString awszDateTime;
    awszDateTime.Attach(DateTimeToString(filetime));

    wprintf (L"\n* Current time: [%s] - [0x%0I64x]\n", (LPWSTR)awszDateTime, (LONGLONG)filetime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\multilayer\mldiff.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	    ml.cpp
**
**
** Abstract:
**
**	    Test program to exercise backup and multilayer snapshots
**
** Author:
**
**	    Adi Oltean      [aoltean]       02/22/2001
**
**
** Revision History:
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "ml.h"


///////////////////////////////////////////////////////////////////////////////
// Processing functions

// Adding a diff area association
void CVssMultilayerTest::AddDiffArea()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::AddDiffArea");

    wprintf (L"\n---------- Adding a diff area ----------------------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_NOFAIL(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pSnapMgmt;
	CHECK_SUCCESS( pMgmt->GetProviderMgmtInterface( m_ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pSnapMgmt ) );
    
    CHECK_SUCCESS( pSnapMgmt->AddDiffArea( m_pwszVolume, m_pwszDiffAreaVolume, m_llMaxDiffArea ));
}


// Removing a diff area association
void CVssMultilayerTest::RemoveDiffArea()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::RemoveDiffArea");

    wprintf (L"\n---------- Removing a diff area ----------------------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_NOFAIL(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pSnapMgmt;
	CHECK_SUCCESS( pMgmt->GetProviderMgmtInterface( m_ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pSnapMgmt ));

    // Remove the diff area
    CHECK_SUCCESS( pSnapMgmt->ChangeDiffAreaMaximumSize( m_pwszVolume, m_pwszDiffAreaVolume, VSS_ASSOC_REMOVE ));
}


// Changing the diff area max size
void CVssMultilayerTest::ChangeDiffAreaMaximumSize()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::ChangeDiffAreaMaximumSize");

    wprintf (L"\n---------- Changing diff area max size ----------------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_NOFAIL(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pSnapMgmt;
	CHECK_SUCCESS(pMgmt->GetProviderMgmtInterface( m_ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pSnapMgmt ));
    
    CHECK_SUCCESS(pSnapMgmt->ChangeDiffAreaMaximumSize( m_pwszVolume, m_pwszDiffAreaVolume, m_llMaxDiffArea ));
}


// Querying volumes for diff area
void CVssMultilayerTest::QueryVolumesSupportedForDiffAreas()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::QueryVolumesSupportedForDiffAreas");

    wprintf (L"\n---------- Querying volumes supported for diff area ----------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_NOFAIL(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pSnapMgmt;
	CHECK_SUCCESS(pMgmt->GetProviderMgmtInterface( m_ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pSnapMgmt ));
    
	// Get list all supported volumes for diff area
	CComPtr<IVssEnumMgmtObject> pIEnum;
	CHECK_NOFAIL(pSnapMgmt->QueryVolumesSupportedForDiffAreas( m_pwszVolume, &pIEnum ));
	if (ft.hr == S_FALSE) {
        wprintf(L"Query: Empty result...\n");
        return;
	}

    wprintf(L"\n%-50s %-15s %-10s %-10s\n", L"Volume Name", L"Display name", L"Free space", L"Total space");
    wprintf(L"------------------------------------------------------------------------------------------\n");

	// For all volumes do...
	VSS_MGMT_OBJECT_PROP Prop;
	VSS_DIFF_VOLUME_PROP& DiffVol = Prop.Obj.DiffVol;
	for(;;) {
		// Get next element
		ULONG ulFetched;
		CHECK_NOFAIL(pIEnum->Next( 1, &Prop, &ulFetched ));
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        wprintf(L"%-50s %-15s %I64d %I64d\n", 
            DiffVol.m_pwszVolumeName, 
            DiffVol.m_pwszVolumeDisplayName,
            DiffVol.m_llVolumeFreeSpace,
            DiffVol.m_llVolumeTotalSpace
            );

        ::CoTaskMemFree(DiffVol.m_pwszVolumeName);
        ::CoTaskMemFree(DiffVol.m_pwszVolumeDisplayName);
	}

    wprintf(L"------------------------------------------------------------------------------------------\n");

}


// Querying diff areas for volume
void CVssMultilayerTest::QueryDiffAreasForVolume()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::QueryDiffAreasForVolume");

    wprintf (L"\n---------- Querying diff areas for volume ----------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_NOFAIL(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pSnapMgmt;
	CHECK_SUCCESS(pMgmt->GetProviderMgmtInterface( m_ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pSnapMgmt ));
    
	// Get list all supported volumes for diff area
	CComPtr<IVssEnumMgmtObject> pIEnum;
	CHECK_NOFAIL(pSnapMgmt->QueryDiffAreasForVolume( m_pwszVolume, &pIEnum ));
	if (ft.hr == S_FALSE) {
        wprintf(L"Query: Empty result...\n");
        return;
	}

    wprintf(L"\n%- 50s %- 50s %-10s %-10s %-10s\n", L"Volume", L"Diff area", L"Used", L"Allocated", L"Maximum");
    wprintf(L"-------------------------------------------------------------------------------------------------------------------------------\n");

	// For all volumes do...
	VSS_MGMT_OBJECT_PROP Prop;
	VSS_DIFF_AREA_PROP& DiffArea = Prop.Obj.DiffArea; 
	for(;;) {
		// Get next element
		ULONG ulFetched;
		CHECK_NOFAIL(pIEnum->Next( 1, &Prop, &ulFetched ));
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        wprintf(L"%- 50s %- 50s %-10I64d %-10I64d %-10I64d\n", 
            DiffArea.m_pwszVolumeName, 
            DiffArea.m_pwszDiffAreaVolumeName,
            DiffArea.m_llUsedDiffSpace,
            DiffArea.m_llAllocatedDiffSpace,
            DiffArea.m_llMaximumDiffSpace
            );

        ::CoTaskMemFree(DiffArea.m_pwszVolumeName);
        ::CoTaskMemFree(DiffArea.m_pwszDiffAreaVolumeName);
	}

    wprintf(L"-------------------------------------------------------------------------------------------------------------------------------\n");

}


// Querying diff areas on volume
void CVssMultilayerTest::QueryDiffAreasOnVolume()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::QueryDiffAreasOnVolume");

    wprintf (L"\n---------- Querying diff areas On volume ----------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_NOFAIL(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pSnapMgmt;
	CHECK_SUCCESS(pMgmt->GetProviderMgmtInterface( m_ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pSnapMgmt ));
    
	// Get list all supported volumes for diff area
	CComPtr<IVssEnumMgmtObject> pIEnum;
	CHECK_NOFAIL(pSnapMgmt->QueryDiffAreasOnVolume( m_pwszDiffAreaVolume, &pIEnum ));
	if (ft.hr == S_FALSE) {
        wprintf(L"Query: Empty result...\n");
        return;
	}

    wprintf(L"\n%- 50s %- 50s %-10s %-10s %-10s\n", L"Volume", L"Diff area", L"Used", L"Allocated", L"Maximum");
    wprintf(L"-------------------------------------------------------------------------------------------------------------------------------\n");

	// For all volumes do...
	VSS_MGMT_OBJECT_PROP Prop;
	VSS_DIFF_AREA_PROP& DiffArea = Prop.Obj.DiffArea; 
	for(;;) {
		// Get next element
		ULONG ulFetched;
		CHECK_NOFAIL(pIEnum->Next( 1, &Prop, &ulFetched ));
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        wprintf(L"%- 50s %- 50s %-10I64d %-10I64d %-10I64d\n", 
            DiffArea.m_pwszVolumeName, 
            DiffArea.m_pwszDiffAreaVolumeName,
            DiffArea.m_llUsedDiffSpace,
            DiffArea.m_llAllocatedDiffSpace,
            DiffArea.m_llMaximumDiffSpace
            );

        ::CoTaskMemFree(DiffArea.m_pwszVolumeName);
        ::CoTaskMemFree(DiffArea.m_pwszDiffAreaVolumeName);
	}

    wprintf(L"-------------------------------------------------------------------------------------------------------------------------------\n");

}


// Querying diff areas for snapshot
void CVssMultilayerTest::QueryDiffAreasForSnapshot()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::QueryDiffAreasForSnapshot");

    wprintf (L"\n---------- Querying diff areas for snapshot ----------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_NOFAIL(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pSnapMgmt;
	CHECK_SUCCESS(pMgmt->GetProviderMgmtInterface( m_ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pSnapMgmt ));
    
	// Get list all supported volumes for diff area
	CComPtr<IVssEnumMgmtObject> pIEnum;
	CHECK_NOFAIL(pSnapMgmt->QueryDiffAreasForSnapshot( m_SnapshotId, &pIEnum ));
	if (ft.hr == S_FALSE) {
        wprintf(L"Query: Empty result...\n");
        return;
	}

    wprintf(L"\n%- 50s %- 50s %-10s %-10s %-10s\n", L"Volume", L"Diff area", L"Used", L"Allocated", L"Maximum");
    wprintf(L"-------------------------------------------------------------------------------------------------------------------------------\n");

	// For all volumes do...
	VSS_MGMT_OBJECT_PROP Prop;
	VSS_DIFF_AREA_PROP& DiffArea = Prop.Obj.DiffArea; 
	for(;;) {
		// Get next element
		ULONG ulFetched;
		CHECK_NOFAIL(pIEnum->Next( 1, &Prop, &ulFetched ));
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        wprintf(L"%- 50s %- 50s %-10I64d %-10I64d %-10I64d\n", 
            DiffArea.m_pwszVolumeName, 
            DiffArea.m_pwszDiffAreaVolumeName,
            DiffArea.m_llUsedDiffSpace,
            DiffArea.m_llAllocatedDiffSpace,
            DiffArea.m_llMaximumDiffSpace
            );

        ::CoTaskMemFree(DiffArea.m_pwszVolumeName);
        ::CoTaskMemFree(DiffArea.m_pwszDiffAreaVolumeName);
	}

    wprintf(L"-------------------------------------------------------------------------------------------------------------------------------\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\multilayer\ml.h ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	    ml.h
**
**
** Abstract:
**
**	    Test program to exercise backup and multilayer snapshots
**
** Author:
**
**	    Adi Oltean      [aoltean]       02/22/2001
**
** Revision History:
**
**--
*/

#ifndef __ML_HEADER_H__
#define __ML_HEADER_H__

#if _MSC_VER > 1000
#pragma once
#endif


/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/

// Disable warning: 'identifier' : identifier was truncated to 'number' characters in the debug information
//#pragma warning(disable:4786)

//
// C4290: C++ Exception Specification ignored
//
#pragma warning(disable:4290)

//
// C4511: copy constructor could not be generated
//
#pragma warning(disable:4511)

//
//  Warning: ATL debugging turned off (BUG 250939)
//
//  #ifdef _DEBUG
//  #define _ATL_DEBUG_INTERFACES
//  #define _ATL_DEBUG_QI
//  #define _ATL_DEBUG_REFCOUNT
//  #endif // _DEBUG

#include <windows.h>
#include <wtypes.h>
#pragma warning( disable: 4201 )    // C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning( default: 4201 )	// C4201: nonstandard extension used : nameless struct/union
#include <winbase.h>
#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdlib.h>
#include <errno.h>
#include <time.h>
#include <string.h>

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"


#include <oleauto.h>
#include <stddef.h>
#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <atlconv.h>
#include <atlbase.h>


// VSS standard headers 
#include <vss.h>
#include <vscoordint.h>
#include <vsswprv.h>
#include <vsmgmt.h>

#include <vswriter.h>
#include <vsbackup.h>

#include <vs_inc.hxx>

#include "objects.h"
#include "cmdparse.h"
#include "macros.h"

extern CComModule _Module;
#include <atlcom.h>

///////////////////////////////////////////////////////////////////////////////
// Useful macros 



inline void VsmlCopy(
	IN  WCHAR* wszDestBuffer, 
	IN	WCHAR* wszSourceBuffer,
	IN  DWORD dwBufferLen
	)
{
	::ZeroMemory(wszDestBuffer, dwBufferLen * sizeof(WCHAR));
	::wcsncpy(wszDestBuffer, wszSourceBuffer, dwBufferLen - 1);
}



#define VSS_ERROR_CASE(wszBuffer, dwBufferLen, X) 	\
    case X: ::VsmlCopy(wszBuffer, VSS_MAKE_W(VSS_EVAL(#X)), dwBufferLen);  break;

#define WSTR_GUID_FMT  L"{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}"

#define GUID_PRINTF_ARG( X )                                \
    (X).Data1,                                              \
    (X).Data2,                                              \
    (X).Data3,                                              \
    (X).Data4[0], (X).Data4[1], (X).Data4[2], (X).Data4[3], \
    (X).Data4[4], (X).Data4[5], (X).Data4[6], (X).Data4[7]


// Execute the given call and check that the return code must be S_OK
#define CHECK_SUCCESS( Call )                                                                           \
    {                                                                                                   \
        ft.hr = Call;                                                                                   \
        if (ft.hr != S_OK)                                                                              \
            ft.Err(VSSDBG_VSSTEST, ft.hr, L"\nError: \n\t- Call %S not succeeded. \n"                   \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                #Call, ft.hr, GetStringFromFailureType(ft.hr));                                         \
    }

#define CHECK_NOFAIL( Call )                                                                            \
    {                                                                                                   \
        ft.hr = Call;                                                                                   \
        if (ft.HrFailed())                                                                              \
            ft.Err(VSSDBG_VSSTEST, ft.hr, L"\nError: \n\t- Call %S not succeeded. \n"                   \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                #Call, ft.hr, GetStringFromFailureType(ft.hr));                                         \
    }


///////////////////////////////////////////////////////////////////////////////
// Constants

const MAX_TEXT_BUFFER   = 512;
const MAX_VOL_ITERATIONS = 10;
const VSS_SEED = 1234;

// The GUID that corresponds to the format used to store the
// Backup Snapshot Application Info in Client SKU
// {BCF5D39C-27A2-4b4c-B9AE-51B111DC9409}
const GUID VOLSNAP_APPINFO_GUID_BACKUP_CLIENT_SKU = 
{ 0xbcf5d39c, 0x27a2, 0x4b4c, { 0xb9, 0xae, 0x51, 0xb1, 0x11, 0xdc, 0x94, 0x9 } };


// The GUID that corresponds to the format used to store the
// Backup Snapshot Application Info in Server SKU
// {BAE53126-BC65-41d6-86CC-3D56A5CEE693}
const GUID VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU = 
{ 0xbae53126, 0xbc65, 0x41d6, { 0x86, 0xcc, 0x3d, 0x56, 0xa5, 0xce, 0xe6, 0x93 } };


// The GUID that corresponds to the format used to store the
// Hidden (Inaccessible) Snapshot Application Info
// {F12142B4-9A4B-49af-A851-700C42FDC2BE}
const GUID VOLSNAP_APPINFO_GUID_SYSTEM_HIDDEN = 
{ 0xf12142b4, 0x9a4b, 0x49af, { 0xa8, 0x51, 0x70, 0xc, 0x42, 0xfd, 0xc2, 0xbe } };


// The GUID that corresponds to the format used to store the
// NAS Rollback Snapshot Application Info
// {D591D4F0-B920-459d-9FFF-09E032ECBB57}
const GUID VOLSNAP_APPINFO_GUID_NAS_ROLLBACK = 
{ 0xd591d4f0, 0xb920, 0x459d, { 0x9f, 0xff, 0x9, 0xe0, 0x32, 0xec, 0xbb, 0x57 } };


// The GUID that corresponds to the format used to store the
// APP Rollback Snapshot Application Info
// {AE9A9337-0048-4ed6-9874-71500654B7B3}
const GUID VOLSNAP_APPINFO_GUID_APP_ROLLBACK = 
{ 0xae9a9337, 0x48, 0x4ed6, { 0x98, 0x74, 0x71, 0x50, 0x6, 0x54, 0xb7, 0xb3 } };


// The GUID that corresponds to the format used to store the
// File Share Backup Snapshot Application Info
// {8F8F4EDD-E056-4690-BB9E-E35D4D41A4C0}
const GUID VOLSNAP_APPINFO_GUID_FILE_SHARE_BACKUP = 
{ 0x8f8f4edd, 0xe056, 0x4690, { 0xbb, 0x9e, 0xe3, 0x5d, 0x4d, 0x41, 0xa4, 0xc0 } };




// Internal flags
const LONG      x_nInternalFlagHidden = 0x00000001;




typedef enum _EVssTestType
{
    VSS_TEST_UNKNOWN = 0,
    VSS_TEST_NONE,
    VSS_TEST_QUERY_SNAPSHOTS,
    VSS_TEST_QUERY_SNAPSHOTS_ON_VOLUME,
    VSS_TEST_QUERY_VOLUMES,
    VSS_TEST_VOLSNAP_QUERY,
    VSS_TEST_DELETE_BY_SNAPSHOT_ID,
    VSS_TEST_DELETE_BY_SNAPSHOT_SET_ID,
    VSS_TEST_CREATE,
    VSS_TEST_ADD_DIFF_AREA,
    VSS_TEST_REMOVE_DIFF_AREA,
    VSS_TEST_CHANGE_DIFF_AREA_MAX_SIZE,
    VSS_TEST_QUERY_SUPPORTED_VOLUMES_FOR_DIFF_AREA,
    VSS_TEST_QUERY_DIFF_AREAS_FOR_VOLUME,
    VSS_TEST_QUERY_DIFF_AREAS_ON_VOLUME,
    VSS_TEST_QUERY_DIFF_AREAS_FOR_SNAPSHOT,
    VSS_TEST_IS_VOLUME_SNAPSHOTTED_C,
    VSS_TEST_SET_SNAPSHOT_PROPERTIES,
    VSS_TEST_ACCESS_CONTROL_SD,
    VSS_TEST_DIAG_WRITERS,
    VSS_TEST_DIAG_WRITERS_LOG,
	VSS_TEST_DIAG_WRITERS_CSV,
    VSS_TEST_DIAG_WRITERS_ON,
    VSS_TEST_DIAG_WRITERS_OFF,
	VSS_TEST_LIST_WRITERS,
} EVssTestType;


typedef enum _EVssQWSFlags
{
	VSS_QWS_THROW_ON_WRITER_FAILURE = 1,
	VSS_QWS_DISPLAY_WRITER_STATUS = 2,
};



///////////////////////////////////////////////////////////////////////////////
// Main class


class CVssMultilayerTest
{
    
// Constructors& destructors
private:
    CVssMultilayerTest();
    CVssMultilayerTest(const CVssMultilayerTest&);
    
public:
    CVssMultilayerTest(
        IN  INT nArgsCount,
        IN  WCHAR ** ppwszArgsArray
        );

    ~CVssMultilayerTest();

// Main routines
public:

    // Initialize internal members
    void Initialize();

    // Run the test
    void Run();

// Internal tests
public:

    // Queries the snapshots
    void QuerySnapshots();

    // Queries the snapshots on volume
    void QuerySnapshotsByVolume();

    // Creates a backup snapshot set
    void QuerySupportedVolumes();

    // Query using hte IOCTL
    void QueryVolsnap();

    // Delete by snapshot Id
    void DeleteBySnapshotId();

    // Delete by snapshot set Id
    void DeleteBySnapshotSetId();

    // Creates a backup snapshot set
    void PreloadExistingSnapshots();

    // Creates a timewarp snapshot set
    void CreateTimewarpSnapshotSet();

    // Creates a backup snapshot set
    void CreateBackupSnapshotSet();

    // Completes the backup
    void BackupComplete();

    void GatherWriterMetadata();

    void GatherWriterStatus(
        IN  LPCWSTR wszWhen,
		DWORD dwFlags = VSS_QWS_THROW_ON_WRITER_FAILURE
        );

    // Adds a diff area
    void AddDiffArea();

    // Removes a diff area
    void RemoveDiffArea();

    // Change diff area maximum size
    void ChangeDiffAreaMaximumSize();

    // Query volumes for diff area
    void QueryVolumesSupportedForDiffAreas();

    // Query volumes for diff area
    void QueryDiffAreasForVolume();

    // Query volumes on diff area
    void QueryDiffAreasOnVolume();

    // Query volumes on diff area
    void QueryDiffAreasForSnapshot();

    // Test if the volume is snapshotted using the "C" API
    void IsVolumeSnapshotted_C();

    // Test if the volume is snapshotted using the "C" API
    void SetSnapshotProperties();

	// Test the CVssSidCollection class
	void TestAccessControlSD();

	// Diagnose writers
	void DiagnoseWriters(
		IN EVssTestType eType
		);

	// List writers
	void TestListWriters();


// Command line processing
public:

    // Parse command line arguments 
    bool ParseCommandLine();

    // Print the usage
    bool PrintUsage(bool bThrow = true);

    // Returns true if there are tokens left
    bool TokensLeft();
        
    // Returns the current token
    VSS_PWSZ GetCurrentToken();

    // Go to next token
    void Shift();
        
    // Check if the current token matches the given argument
	bool Peek(
		IN	VSS_PWSZ pwszPattern
		) throw(HRESULT);
    
    // Match a pattern. If succeeds, shift to the next token.
	bool Match(
		IN	VSS_PWSZ pwszPattern
		) throw(HRESULT);
    
    // Extract a GUID. If succeeds, shift to the next token.
	bool Extract(
		IN OUT VSS_ID& Guid
		) throw(HRESULT);
    
    // Extract a string. If succeeds, shift to the next token.
	bool Extract(
		IN OUT VSS_PWSZ& pwsz
		) throw(HRESULT);
    
    // Extract an UINT. If succeeds, shift to the next token.
	bool Extract(
		IN OUT UINT& uint
		) throw(HRESULT);
    
    // Extract an UINT. If succeeds, shift to the next token.
	bool Extract(
		IN OUT LONGLONG& llValue
		) throw(HRESULT);
    
// Private methods:
private:

    LPCWSTR GetStringFromFailureType (HRESULT hrStatus);

	LPCWSTR GetStringFromWriterState(VSS_WRITER_STATE state);

    bool IsVolume( IN VSS_PWSZ pwszVolume );

    bool AddVolume( IN VSS_PWSZ pwszVolume, OUT bool & bAdded );

    INT RndDecision(IN INT nVariants = 2);

	LPWSTR DateTimeToString(
	    IN LONGLONG llTimestamp
	    );

	void DisplayCurrentTime();

// Implementation
private:

    // Global state
    bool                        m_bCoInitializeSucceeded;
    bool                        m_bAttachYourDebuggerNow;

    // Command line options
    unsigned int                m_uSeed;
    LONG                        m_lContext;
    EVssTestType                m_eTest;
    VSS_PWSZ                    m_pwszVolume;
    VSS_PWSZ                    m_pwszDiffAreaVolume;
    VSS_ID                      m_ProviderId;
    LONGLONG                    m_llMaxDiffArea;
    VSS_ID                      m_SnapshotId;
    VSS_ID                      m_SnapshotSetId;
    
    CComVariant                 m_value;
    UINT                        m_uPropertyId;

    // test-related members
    CVssSnapshotSetCollection   m_pSnapshotSetCollection;
    CVssVolumeMap               m_mapVolumes;
    CComPtr<IVssCoordinator>    m_pTimewarpCoord;
    CComPtr<IVssCoordinator>    m_pAllCoord;
    CComPtr<IVssBackupComponents>    m_pBackupComponents;

    // Command line
    INT                         m_nCurrentArgsCount;
    WCHAR **                    m_ppwszCurrentArgsArray;
};


#endif // __ML_HEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\multilayer\objects.h ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	    objects.h
**
**
** Abstract:
**
**	    Test program to exercise backup and multilayer snapshots
**
** Author:
**
**	    Adi Oltean      [aoltean]       02/22/2001
**
** Revision History:
**
**--
*/

#ifndef __ML_OBJECTS_H__
#define __ML_OBJECTS_H__

#if _MSC_VER > 1000
#pragma once
#endif


///////////////////////////////////////////////////////////////////////////////
// Snapshot-related classes


class CVssVolumeInfo;


// Keeps the information that describes one snapshot
class CVssSnapshotInfo
{
// Constructors& destructors
private:
    CVssSnapshotInfo& operator = (const CVssSnapshotInfo&);
    CVssSnapshotInfo();
    CVssSnapshotInfo(const CVssSnapshotInfo&);

public:

    CVssSnapshotInfo( 
        IN bool bActive,
        IN LONG lContext, 
        IN VSS_ID SnapshotSetId, 
        IN VSS_PWSZ pwszDeviceName,                     
        IN VSS_PWSZ pwszVolumeName,                     
        IN CVssVolumeInfo* pVol
        ): m_pwszDeviceName(NULL), m_pwszVolumeName(NULL)
    {
        CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSnapshotInfo::CVssSnapshotInfo");

        try
        {
            m_bActive = bActive;
            m_lContext = lContext;
            m_SnapshotSetId = SnapshotSetId;
            m_pVol = pVol;
            
            ::VssSafeDuplicateStr(ft, m_pwszDeviceName, pwszDeviceName); 
            ::VssSafeDuplicateStr(ft, m_pwszVolumeName, pwszVolumeName); 
        }
        VSS_STANDARD_CATCH(ft)

        if (ft.HrFailed()) {
            ::VssFreeString(m_pwszDeviceName); 
            ::VssFreeString(m_pwszVolumeName); 
        }
    };

    ~CVssSnapshotInfo() 
    {
        ::VssFreeString(m_pwszDeviceName);
        ::VssFreeString(m_pwszVolumeName);
    };

    BOOL m_bActive;
    LONG m_lContext;
    VSS_ID m_SnapshotSetId;
    VSS_PWSZ m_pwszDeviceName;  
    VSS_PWSZ m_pwszVolumeName;  
    CVssVolumeInfo* m_pVol;
};


// Keeps an internal map of snapshots from a snapshot set. 
// The key is the original volume name
class CVssSnapshotSetInfo:
    public CVssSimpleMap< LPCWSTR, CVssSnapshotInfo* >
{
// Constructors& destructors
private:
    CVssSnapshotSetInfo& operator = (const CVssSnapshotSetInfo&);
    CVssSnapshotSetInfo(const CVssSnapshotSetInfo&);
    CVssSnapshotSetInfo();
    
public:
    CVssSnapshotSetInfo(
        IN VSS_ID SnapshotSetId
        ): m_SnapshotSetId(SnapshotSetId) {}; 

   ~CVssSnapshotSetInfo() {
        // Remove all elements
        for (int i = 0; i < GetSize(); i++) {
            CVssSnapshotInfo* pSnapInfo = GetValueAt(i);
            delete pSnapInfo;
        }
        // Remove all items        
        RemoveAll();
    };

// Attributes
public:
    VSS_ID GetSnapshotSetID() const { return m_SnapshotSetId; };

// Implementation 
private: 
    VSS_ID m_SnapshotSetId;
};


// Keeps an internal map of snapshots from a snapshot set. 
// The key is the original volume name
class CVssSnapshotSetCollection:
    public CVssSimpleMap< VSS_ID, CVssSnapshotSetInfo* >
{
// Constructors& destructors
private:
    CVssSnapshotSetCollection& operator = (const CVssSnapshotSetCollection&);
    
public:

   ~CVssSnapshotSetCollection() {
        // Remove all elements
        for (int i = 0; i < GetSize(); i++) {
            CVssSnapshotSetInfo* pSnapSetInfo = GetValueAt(i);
            delete pSnapSetInfo;
        }
        // Remove all items        
        RemoveAll();
    }
};


///////////////////////////////////////////////////////////////////////////////
// Volume-related classes

// Keeps the information that describes one volume
class CVssVolumeInfo
{
    
// Constructors/ destructors
private:
    CVssVolumeInfo();
    CVssVolumeInfo(const CVssVolumeInfo&);
    
public:
    CVssVolumeInfo(
        IN VSS_PWSZ pwszVolumeName,  
        IN VSS_PWSZ pwszVolumeDisplayName
        ): m_pwszVolumeName(NULL), m_pwszVolumeDisplayName(NULL)
    {
        CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssVolumeInfo::CVssVolumeInfo");

        try
        {
            ::VssSafeDuplicateStr(ft, m_pwszVolumeName, pwszVolumeName); 
            ::VssSafeDuplicateStr(ft, m_pwszVolumeDisplayName, pwszVolumeDisplayName); 
        }
        VSS_STANDARD_CATCH(ft)

        if (ft.HrFailed()) {
            ::VssFreeString(m_pwszVolumeName);
            ::VssFreeString(m_pwszVolumeDisplayName);
        }
    };

    ~CVssVolumeInfo() 
    {
        ::VssFreeString(m_pwszVolumeName);
        ::VssFreeString(m_pwszVolumeDisplayName);
    };

// Attributes
public:
    VSS_PWSZ GetVolumeName() const { return m_pwszVolumeName; };
    VSS_PWSZ GetVolumeDisplayName() const { return m_pwszVolumeDisplayName; };

// Implementation
private:
    VSS_PWSZ    m_pwszVolumeName;
    VSS_PWSZ    m_pwszVolumeDisplayName;
};


// Keeps an internal array of volume names
// that does NOT remove the volume structures in the destructor
class CVssVolumeMapNoRemove: public CVssSimpleMap<VSS_PWSZ, CVssVolumeInfo*>
{
};


// Keeps an internal array of volume names
// that REMOVES the volume structures in the destructor
class CVssVolumeMap: public CVssSimpleMap<VSS_PWSZ, CVssVolumeInfo*>
{
public:
    ~CVssVolumeMap() {
        // Remove all volumes
        for (int i = 0; i < GetSize(); i++) {
            CVssVolumeInfo* pVolumeInfo = GetValueAt(i);
            delete pVolumeInfo;
        }
        
        // Remove all items        
        RemoveAll();
    }
};

#endif // __ML_OBJECTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\shimtest\shimtest.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    client.cpp

Abstract:

    Test program to drive the VSS Writer Shim contained in VssAPI.DLL

Author:

    Stefan R. Steiner   [ssteiner]        01-30-2000

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
//  Defines

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes

#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdio.h>
#include <objbase.h>

#include <vss.h>

typedef HRESULT ( APIENTRY *PFUNC_RegisterSnapshotSubscriptions )( void );
typedef HRESULT ( APIENTRY *PFUNC_UnregisterSnapshotSubscriptions )( void );
typedef HRESULT ( APIENTRY *PFUNC_SimulateSnapshotFreeze )( PWCHAR pwszSnapshotSetId, PWCHAR pwszVolumeNamesList );
typedef HRESULT ( APIENTRY *PFUNC_SimulateSnapshotThaw )( PWCHAR pwszSnapshotSetId );



static BOOL AssertPrivilege( LPCWSTR privName );

/////////////////////////////////////////////////////////////////////////////
//  WinMain

extern "C" int __cdecl wmain( int argc, WCHAR *argv[] )
{
    HINSTANCE hInstLib;
    PFUNC_RegisterSnapshotSubscriptions pFnRegisterSS;
    PFUNC_UnregisterSnapshotSubscriptions pFnUnregisterSS;
    HRESULT hr;

    if ( !AssertPrivilege( SE_BACKUP_NAME ) )
    {
        wprintf( L"AssertPrivilege returned error, rc:%d\n", GetLastError() );
        return 2;
    }

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( FAILED( hr ) )
    {
        wprintf( L"CoInitialize() returned rc:%d\n", GetLastError() );
        return 1;
    }

    //  Get a handle to the DLL module
    hInstLib = LoadLibrary( L"VssAPI.dll" );

    if ( hInstLib != NULL )
    {
        pFnRegisterSS = ( PFUNC_RegisterSnapshotSubscriptions )GetProcAddress( hInstLib, "RegisterSnapshotSubscriptions" );
        if ( pFnRegisterSS != NULL )
            wprintf( L"pFnRegisterSS returned: 0x%08x\n", ( pFnRegisterSS )() );
        else
            wprintf( L"Couldn't import RegisterSnapshotSubscriptions function, rc:%d\n", GetLastError() );

        wprintf( L"\nPress return to continue...\n" );
        getchar();
        wprintf( L"continuing...\n" );

        pFnUnregisterSS = ( PFUNC_UnregisterSnapshotSubscriptions )GetProcAddress( hInstLib, "UnregisterSnapshotSubscriptions" );
        if ( pFnUnregisterSS != NULL )
            wprintf( L"pFnUnregisterSS returned: 0x%08x\n", ( pFnUnregisterSS )() );
        else
            wprintf( L"Couldn't import UnregisterSnapshotSubscriptions function, rc:%d\n", GetLastError() );

        FreeLibrary( hInstLib );
    }
    else
        printf( "LoadLibrary error, rc:%d\n", GetLastError() );


    // Uninitialize COM library
    CoUninitialize();

    return 0;

    UNREFERENCED_PARAMETER( argv );
    UNREFERENCED_PARAMETER( argc );
}


static BOOL AssertPrivilege( LPCWSTR privName )
{
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if ( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &tokenHandle ) )
    {
        LUID value;

        if ( LookupPrivilegeValue( NULL, privName, &value ) )
        {
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            /*
            * We will always call GetLastError below, so clear
            * any prior error values on this thread.
            */
            SetLastError( ERROR_SUCCESS );

            stat =  AdjustTokenPrivileges(
                tokenHandle,
                FALSE,
                &newState,
                (DWORD)0,
                NULL,
                NULL );
            /*
            * Supposedly, AdjustTokenPriveleges always returns TRUE
            * (even when it fails). So, call GetLastError to be
            * extra sure everything's cool.
            */
            if ( (error = GetLastError()) != ERROR_SUCCESS )
            {
                stat = FALSE;
            }

            if ( !stat )
            {
                wprintf( L"AdjustTokenPrivileges for %s failed with %d",
                    privName,
                    error );
            }
        }
        CloseHandle( tokenHandle );
    }
    return stat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\multilayer\mlutil.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	mlutil.cpp
**
**
** Abstract:
**
**	Utility functions for the VSML test.
**
** Author:
**
**	Adi Oltean      [aoltean]      03/05/2001
**
**  The sample is based on the Metasnap test program  written by Michael C. Johnson.
**
**
** Revision History:
**
**--
*/

///////////////////////////////////////////////////////////////////////////////
// Includes

#include "ml.h"
#include "ntddsnap.h"
#include "ntddvol.h"


///////////////////////////////////////////////////////////////////////////////
// Command line parsing


bool CVssMultilayerTest::PrintUsage(bool bThrow /* = true */)
{
    wprintf(
        L"\nUsage:\n"
        L"     1) For snapshot creation:\n"
        L"           vsml [-xt|-xa|-xp] [-s <seed_number>] <volumes>\n"
        L"     2) For query:\n"
        L"           vsml [-xt|-xa|-xp|-xf] -qs [-P <ProviderID>]\n"
        L"           vsml [-xt|-xa|-xp|-xf] -qsv <volume> [-P <ProviderID>]\n"
        L"           vsml [-xt|-xa|-xp|-xf] -qv [-P <ProviderID>]\n"
        L"           vsml -qi <volume>\n"
        L"           vsml -is <volume>\n"
        L"           vsml -lw\n"
        L"     3) For diff area:\n"
        L"           vsml -da <vol> <diff vol> <max size> [-P <ProviderID>]\n"
        L"           vsml -dr <vol> <diff vol>  [-P <ProviderID>]\n"
        L"           vsml -ds <vol> <diff vol> <max size>  [-P <ProviderID>]\n"
        L"           vsml -dqv [-v original_volume] [-P <ProviderID>]\n"
        L"           vsml -dqf <volume> [-P <ProviderID>]\n"
        L"           vsml -dqo <volume> [-P <ProviderID>]\n"
        L"           vsml -dqs {SnapshotID} [-P <ProviderID>]\n"
        L"     4) For deleting snapshots:\n"
        L"           vsml [-xt|-xa|-xp] -r {snapshot id}\n"
        L"           vsml [-xt|-xa|-xp] -rs {snapshot set id}\n"
        L"     5) For various tests:\n"
        L"           vsml [-xt|-xa|-xp] -sp {snapshot id} PropertyId string\n"
        L"           vsml -test_sc\n"
        L"     6) For displaying various constants:\n"
        L"           vsml -const\n"
        L"     7) For diagnosing writers:\n"
        L"           vsml -diag\n"
        L"           vsml -diag log\n"
        L"           vsml -diag csv\n"
        L"           vsml -diag on\n"
        L"           vsml -diag off\n"
        L"\nOptions:\n"
        L"      -s              Specifies a seed for the random number generator\n"
        L"      -xt             Operates in the Timewarp context\n"
        L"      -xa             Operates  in the 'ALL' context\n"
        L"      -xp             Operates  in the 'Nas Rollback' context\n"
        L"      -xr             Operates  in the 'App Rollback' context\n"
        L"      -xf             Operates in the File Share Backup context\n"
        L"      -qs             Queries the existing snapshots\n"
        L"      -qi             Queries the VOLSNAP snapshots (through ioctl)\n"
        L"      -is             Checks if the volume is snapshotted (through C API)\n"
        L"      -qsv            Queries the snapshots on the given volume\n"
        L"      -qv             Queries the supported volumes.\n"
        L"      -P              Specifies a provider Id\n"
        L"      -da             Adds a diff area association.\n"
        L"      -dr             Removes a diff area association.\n"
        L"      -ds             Change diff area max size.\n"
        L"      -dqv            Query the volumes supported for diff area.\n"
        L"      -dqf            Query the diff area associations for volume.\n"
        L"      -dqo            Query the diff area associations on volume.\n"
        L"      -dqs            Query the diff area associations for snapshot.\n"
        L"      -r              Remove the snapshot with that ID.\n"
        L"      -rs             Remove the snapshots from the set with that ID.\n"
        L"      -sp             Set snapshot properties.\n"
        L"      -test_sc        Test SID collection.\n"
        L"      -const          Prints out various constants.\n"
        L"      -?              Displays this help.\n"
        L"      -D              Pops up an assert for attaching a debugger.\n"
        L"      -diag           Diagnose all writers. Print all writers.\n"
        L"      -diag log       Diagnose all writers. Print only pending writers.\n"
        L"      -diag csv       Diagnose all writers. Print information in CSV format.\n"
        L"      -diag on        Turn on diagnose.\n"
        L"      -diag off       Turn off diagnose.\n"
        L"      -lw             List writers.\n"
        L"\n"
        L"\nExample:\n"
        L"      The following command will create a backup snapshot set\n"
        L"      on the volumes mounted under c:\\ and d:\\\n"
        L"\n"
        L"              vsml c:\\ d:\\ \n"
        L"\n"
        );

    if (bThrow)
        throw(E_INVALIDARG);

    return false;
}


#define VSS_PRINT_VALUE(x) wprintf(L"   0x%08lx - %S\n", x, #x);

#define VSS_PRINT_GUID(X) wprintf( L"   {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x} - %S\n", \
    (X).Data1,                                              \
    (X).Data2,                                              \
    (X).Data3,                                              \
    (X).Data4[0], (X).Data4[1], (X).Data4[2], (X).Data4[3], \
    (X).Data4[4], (X).Data4[5], (X).Data4[6], (X).Data4[7], \
    #X);

bool CVssMultilayerTest::ParseCommandLine()
{
    if (!TokensLeft() || Match(L"-?"))
        return PrintUsage(false);

    // Check for context options
    if (Match(L"-D"))
        m_bAttachYourDebuggerNow = true;

    // displays all ioctls
    if (Match(L"-const")) {
        m_eTest = VSS_TEST_NONE;

        wprintf (L"\nVolsnap ioctls:\n");
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_RELEASE_WRITES);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_COMMIT_SNAPSHOT);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_CLEAR_DIFF_AREA);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_QUERY_DIFF_AREA);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_SET_MAX_DIFF_AREA_SIZE);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_AUTO_CLEANUP);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_DELETE_SNAPSHOT);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_QUERY_CONFIG_INFO);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_SET_APPLICATION_INFO);
        VSS_PRINT_VALUE(IOCTL_VOLSNAP_QUERY_APPLICATION_INFO);
        VSS_PRINT_VALUE(FSCTL_DISMOUNT_VOLUME);
        VSS_PRINT_VALUE(IOCTL_VOLUME_OFFLINE);

        wprintf (L"\n\nVolsnap contexes:\n");
        VSS_PRINT_VALUE(VSS_CTX_BACKUP);
        VSS_PRINT_VALUE(VSS_CTX_FILE_SHARE_BACKUP);
        VSS_PRINT_VALUE(VSS_CTX_NAS_ROLLBACK);
        VSS_PRINT_VALUE(VSS_CTX_APP_ROLLBACK);
        VSS_PRINT_VALUE(VSS_CTX_CLIENT_ACCESSIBLE);
        VSS_PRINT_VALUE(VSS_CTX_ALL);

        wprintf (L"\n\nVolsnap guids:\n");
        VSS_PRINT_GUID(VOLSNAP_APPINFO_GUID_BACKUP_CLIENT_SKU);
        VSS_PRINT_GUID(VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU);
        VSS_PRINT_GUID(VOLSNAP_APPINFO_GUID_SYSTEM_HIDDEN);
        VSS_PRINT_GUID(VOLSNAP_APPINFO_GUID_NAS_ROLLBACK);
        VSS_PRINT_GUID(VOLSNAP_APPINFO_GUID_APP_ROLLBACK);
        VSS_PRINT_GUID(VOLSNAP_APPINFO_GUID_FILE_SHARE_BACKUP);

        wprintf(L"\n\nValid attributes for SetContext:\n");
        wprintf(L"    VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY = %d\n", VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY);
        wprintf(L"    VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY = %d\n", VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY);
        wprintf(L"    VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY | VSS_..._REMOTELY = %d\n",     
                VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY | VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY);

        wprintf(L"\n\nValid property IDs:\n");
        wprintf(L"    VSS_SPROPID_SNAPSHOT_ATTRIBUTES = %d\n", VSS_SPROPID_SNAPSHOT_ATTRIBUTES);
        wprintf(L"    VSS_SPROPID_EXPOSED_NAME = %d\n",        VSS_SPROPID_EXPOSED_NAME);
        wprintf(L"    VSS_SPROPID_EXPOSED_PATH = %d\n",        VSS_SPROPID_EXPOSED_PATH);
        wprintf(L"    VSS_SPROPID_SERVICE_MACHINE = %d\n",     VSS_SPROPID_SERVICE_MACHINE);

        wprintf(L"\n");

        return TokensLeft()? PrintUsage(): true;
    }

    // Test CSidCollection
    if (Match(L"-test_sc")) {
        m_eTest = VSS_TEST_ACCESS_CONTROL_SD;

        return TokensLeft()? PrintUsage(): true;
    }

    // Diagnose writers
    if (Match(L"-diag")) {
        if (Match(L"on")) {
            m_eTest = VSS_TEST_DIAG_WRITERS_ON;
            return TokensLeft()? PrintUsage(): true;
        }
        
        if (Match(L"off")) {
            m_eTest = VSS_TEST_DIAG_WRITERS_OFF;
            return TokensLeft()? PrintUsage(): true;
        }
        
        if (Match(L"log")) {
            m_eTest = VSS_TEST_DIAG_WRITERS_LOG;
            return TokensLeft()? PrintUsage(): true;
        }

        if (Match(L"csv")) {
            m_eTest = VSS_TEST_DIAG_WRITERS_CSV;
            return TokensLeft()? PrintUsage(): true;
        }

        if (!TokensLeft()) {
            m_eTest = VSS_TEST_DIAG_WRITERS;
            return true;
        }

        return PrintUsage();
    }

    // Check for List Writers
    if (Match(L"-lw"))
    {
        m_eTest = VSS_TEST_LIST_WRITERS;
        return TokensLeft()? PrintUsage(): true;
    }
    
    // Query using the IOCTL
    if (Match(L"-qi")) {
        m_eTest = VSS_TEST_VOLSNAP_QUERY;

        // Get the original volume
        if (!Extract(m_pwszVolume) || !IsVolume(m_pwszVolume))
            return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Query using the IOCTL
    if (Match(L"-is")) {
        m_eTest = VSS_TEST_IS_VOLUME_SNAPSHOTTED_C;

        // Get the original volume
        if (!Extract(m_pwszVolume) || !IsVolume(m_pwszVolume))
            return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Check for context options
    if (Match(L"-xt"))
        m_lContext = VSS_CTX_CLIENT_ACCESSIBLE;

    if (Match(L"-xa"))
        m_lContext = VSS_CTX_ALL;

    if (Match(L"-xp"))
        m_lContext = VSS_CTX_NAS_ROLLBACK;

    if (Match(L"-xr"))
        m_lContext = VSS_CTX_APP_ROLLBACK;

    if (Match(L"-xf"))
        m_lContext = VSS_CTX_FILE_SHARE_BACKUP;

    // Set the snapshot property
    if (Match(L"-sp")) {
        m_eTest = VSS_TEST_SET_SNAPSHOT_PROPERTIES;

        // Extract the snapshot id
        if (!Extract(m_SnapshotId))
            return PrintUsage();

        // Extract the property ID
        Extract(m_uPropertyId);

        UINT uNewAttributes = 0;
        LPWSTR pwszString = NULL;
        switch(m_uPropertyId)
        {
        case VSS_SPROPID_SNAPSHOT_ATTRIBUTES:
            // Extract the snapshot attributes
            Extract(uNewAttributes);
            switch(uNewAttributes)
            {
            default:
                wprintf(L"\nInvalid attributes ID (%lu). Valid ones:\n", uNewAttributes);
                wprintf(L"    VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY = %d\n", VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY);
                wprintf(L"    VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY = %d\n", VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY);
                wprintf(L"    VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY | VSS_..._REMOTELY = %d\n",     
                        VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY | VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY);
                return false;

            case VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY:
            case VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY:
            case VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY | VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY:
                break;
            }
            m_value = (LONG)uNewAttributes;
            break;

        case VSS_SPROPID_EXPOSED_NAME:
        case VSS_SPROPID_EXPOSED_PATH:
        case VSS_SPROPID_SERVICE_MACHINE:
            // Extract the snapshot attributes
            if (Extract(pwszString))
            {
                m_value = pwszString;
                ::VssFreeString(pwszString);
            }
            else
                m_value = L"";
            
            break;

        default: 
            wprintf(L"\nInvalid property ID (%ld). Valid ones:\n", m_uPropertyId);
            wprintf(L"    VSS_SPROPID_SNAPSHOT_ATTRIBUTES = %d\n", VSS_SPROPID_SNAPSHOT_ATTRIBUTES);
            wprintf(L"    VSS_SPROPID_EXPOSED_NAME = %d\n",        VSS_SPROPID_EXPOSED_NAME);
            wprintf(L"    VSS_SPROPID_EXPOSED_PATH = %d\n",        VSS_SPROPID_EXPOSED_PATH);
            wprintf(L"    VSS_SPROPID_SERVICE_MACHINE = %d\n",     VSS_SPROPID_SERVICE_MACHINE);
            return false;
        }


        return TokensLeft()? PrintUsage(): true;
    }

    // Add the Diff Area
    if (Match(L"-da")) {
        m_eTest = VSS_TEST_ADD_DIFF_AREA;

        // Get the original volume
        if (!Extract(m_pwszVolume) || !IsVolume(m_pwszVolume))
            return PrintUsage();

        // Get the diff area volume
        if (!Extract(m_pwszDiffAreaVolume) || !IsVolume(m_pwszDiffAreaVolume))
            return PrintUsage();

        // Check to see if we specified a max diff area (i.e. -P is not present)
        if (!Peek(L"-P"))
            Extract(m_llMaxDiffArea);

        // Check to see if we specified a provider ID
        if (Match(L"-P")) {
            if (!Extract(m_ProviderId))
                return PrintUsage();
            Extract(m_llMaxDiffArea);
        }

        return TokensLeft()? PrintUsage(): true;
    }

    // Remove the Diff Area
    if (Match(L"-dr")) {
        m_eTest = VSS_TEST_REMOVE_DIFF_AREA;

        // Get the original volume
        if (!Extract(m_pwszVolume) || !IsVolume(m_pwszVolume))
            return PrintUsage();

        // Get the diff area volume
        if (!Extract(m_pwszDiffAreaVolume) || !IsVolume(m_pwszDiffAreaVolume))
            return PrintUsage();

        // Check to see if we specified a provider ID
        if (Match(L"-P"))
            if (!Extract(m_ProviderId))
                return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Change Diff Area max size
    if (Match(L"-ds")) {
        m_eTest = VSS_TEST_CHANGE_DIFF_AREA_MAX_SIZE;

        // Get the original volume
        if (!Extract(m_pwszVolume) || !IsVolume(m_pwszVolume))
            return PrintUsage();

        // Get the diff area volume
        if (!Extract(m_pwszDiffAreaVolume) || !IsVolume(m_pwszDiffAreaVolume))
            return PrintUsage();

        // Check to see if we specified a max diff area (i.e. -P is not present)
        if (!Peek(L"-P"))
            Extract(m_llMaxDiffArea);

        // Check to see if we specified a provider ID
        if (Match(L"-P")) {
            if (!Extract(m_ProviderId))
                return PrintUsage();
            Extract(m_llMaxDiffArea);
        }

        return TokensLeft()? PrintUsage(): true;
    }

    // Query the volumes supported for Diff Area
    if (Match(L"-dqv")) {
        m_eTest = VSS_TEST_QUERY_SUPPORTED_VOLUMES_FOR_DIFF_AREA;

        // Check to see if we specified a max diff area (i.e. -P is not present)
        if (!Peek(L"-v"))
            if (!Extract(m_pwszVolume) || !IsVolume(m_pwszVolume))
                return PrintUsage();

        // Check to see if we specified a provider ID
        if (Match(L"-P"))
            if (!Extract(m_ProviderId))
                return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Query the volumes supported for Diff Area
    if (Match(L"-dqf")) {
        m_eTest = VSS_TEST_QUERY_DIFF_AREAS_FOR_VOLUME;

        // Get the original volume
        if (!Extract(m_pwszVolume) || !IsVolume(m_pwszVolume))
            return PrintUsage();

        // Check to see if we specified a provider ID
        if (Match(L"-P"))
            if (!Extract(m_ProviderId))
                return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Query the volumes supported for Diff Area
    if (Match(L"-dqo")) {
        m_eTest = VSS_TEST_QUERY_DIFF_AREAS_ON_VOLUME;

        // Get the original volume
        if (!Extract(m_pwszDiffAreaVolume) || !IsVolume(m_pwszDiffAreaVolume))
            return PrintUsage();

        // Check to see if we specified a provider ID
        if (Match(L"-P"))
            if (!Extract(m_ProviderId))
                return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Query the volumes supported for Diff Area
    if (Match(L"-dqs")) {
        m_eTest = VSS_TEST_QUERY_DIFF_AREAS_FOR_SNAPSHOT;

        // Get the original volume
        if (!Extract(m_SnapshotId))
            return PrintUsage();

        // Check to see if we specified a provider ID
        if (Match(L"-P"))
            if (!Extract(m_ProviderId))
                return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Check for Query
    if (Match(L"-qs")) {
        m_eTest = VSS_TEST_QUERY_SNAPSHOTS;

        // Check to see if we specified a provider ID
        if (Match(L"-P"))
            if (!Extract(m_ProviderId))
                return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Check for Query
    if (Match(L"-qsv")) {
        m_eTest = VSS_TEST_QUERY_SNAPSHOTS_ON_VOLUME;

        // Extract the volume volume
        if (!Extract(m_pwszVolume) || !IsVolume(m_pwszVolume))
            return PrintUsage();

        // Check to see if we specified a provider ID
        if (Match(L"-P"))
            if (!Extract(m_ProviderId))
                return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Check for Query Supported Volumes
    if (Match(L"-qv")) {
        m_eTest = VSS_TEST_QUERY_VOLUMES;

        // Check to see if we specified a provider ID
        if (Match(L"-P"))
            if (!Extract(m_ProviderId))
                return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Check for Delete by snapshot Id
    if (Match(L"-r")) {
        m_eTest = VSS_TEST_DELETE_BY_SNAPSHOT_ID;

        // Extract the snapshot id
        if (!Extract(m_SnapshotId))
            return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Check for Delete by snapshot set Id
    if (Match(L"-rs")) {
        m_eTest = VSS_TEST_DELETE_BY_SNAPSHOT_SET_ID;

        // Extract the snapshot id
        if (!Extract(m_SnapshotSetId))
            return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Check for Seed option
    if (Match(L"-s"))
        if (!Extract(m_uSeed))
            return PrintUsage();

    // We are in snapshot creation mode
    if (!TokensLeft())
        return PrintUsage();

    bool bVolumeAdded = false;
    VSS_PWSZ pwszVolumeName = NULL;
    while (TokensLeft()) {
        Extract(pwszVolumeName);
        if (!AddVolume(pwszVolumeName, bVolumeAdded)) {
            wprintf(L"\nError while parsing the command line:\n"
                L"\t%s is not a valid option or a mount point [0x%08lx]\n\n",
                GetCurrentToken(), GetLastError() );
            return PrintUsage();
        }

        // Check if the same volume is added twice
        if (!bVolumeAdded) {
            wprintf(L"\nError while parsing the command line:\n"
                L"\tThe volume %s is specified twice\n\n", GetCurrentToken() );
            return PrintUsage();
        }

        ::VssFreeString(pwszVolumeName);
    }

    m_eTest = VSS_TEST_CREATE;

    return true;
}


// Check if there are tokens left
bool CVssMultilayerTest::TokensLeft()
{
    return (m_nCurrentArgsCount != 0);
}


// Returns the current token
VSS_PWSZ CVssMultilayerTest::GetCurrentToken()
{
    return (*m_ppwszCurrentArgsArray);
}


// Go to next token
void CVssMultilayerTest::Shift()
{
    BS_ASSERT(m_nCurrentArgsCount);
    m_nCurrentArgsCount--;
    m_ppwszCurrentArgsArray++;
}


// Check if the current command line token matches with the given pattern
// Do not shift to the next token
bool CVssMultilayerTest::Peek(
	IN	VSS_PWSZ pwszPattern
	) throw(HRESULT)
{
    if (!TokensLeft())
        return false;

    // Try to find a match
    if (wcscmp(GetCurrentToken(), pwszPattern))
        return false;

    // Go to the next token
    return true;
}


// Match the current command line token with the given pattern
// If succeeds, then switch to the next token
bool CVssMultilayerTest::Match(
	IN	VSS_PWSZ pwszPattern
	) throw(HRESULT)
{
    if (!Peek(pwszPattern))
        return false;

    // Go to the next token
    Shift();
    return true;
}


// Converts the current token to a guid
// If succeeds, then switch to the next token
bool CVssMultilayerTest::Extract(
	IN OUT VSS_ID& Guid
	) throw(HRESULT)
{
    if (!TokensLeft())
        return false;

    // Try to extract the guid
    if (!SUCCEEDED(::CLSIDFromString(W2OLE(const_cast<WCHAR*>(GetCurrentToken())), &Guid)))
        return false;

    // Go to the next token
    Shift();
    return true;
}


// Converts the current token to a string
// If succeeds, then switch to the next token
bool CVssMultilayerTest::Extract(
	IN OUT VSS_PWSZ& pwsz
	) throw(HRESULT)
{
    if (!TokensLeft())
        return false;

    // Extract the string
    ::VssDuplicateStr(pwsz, GetCurrentToken());
    if (!pwsz)
        throw(E_OUTOFMEMORY);

    // Go to the next token
    Shift();
    return true;
}


// Converts the current token to an UINT
// If succeeds, then switch to the next token
bool CVssMultilayerTest::Extract(
	IN OUT UINT& uint
	) throw(HRESULT)
{
    if (!TokensLeft())
        return false;

    // Extract the unsigned value
    uint = ::_wtoi(GetCurrentToken());

    // Go to the next token
    Shift();
    return true;
}


// Converts the current token to an UINT
// If succeeds, then switch to the next token
bool CVssMultilayerTest::Extract(
	IN OUT LONGLONG& llValue
	) throw(HRESULT)
{
    if (!TokensLeft())
        return false;

    // Extract the unsigned value
    llValue = ::_wtoi64(GetCurrentToken());

    // Go to the next token
    Shift();
    return true;
}


// Returns true if the given string is a volume
bool CVssMultilayerTest::IsVolume(
    IN WCHAR* pwszVolumeDisplayName
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::IsVolume");

    // Check if the volume represents a real mount point
    WCHAR wszVolumeName[MAX_TEXT_BUFFER];
    if (!GetVolumeNameForVolumeMountPoint(pwszVolumeDisplayName, wszVolumeName, MAX_TEXT_BUFFER))
        return false; // Invalid volume

    return true;
}


// Add the given volume in the list of potential candidates for snapshots
// - Returns "false" if the volume does not correspond to a real mount point
//   (and GetLastError() will contain the correct Win32 error code)
// - Sets "true" in the bAdded parameter if the volume is actually added
bool CVssMultilayerTest::AddVolume(
    IN WCHAR* pwszVolumeDisplayName,
    OUT bool & bAdded
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::AddVolume");

    // Initialize [out] parameters
    bAdded = false;

    // Check if the volume represents a real mount point
    WCHAR wszVolumeName[MAX_TEXT_BUFFER];
    if (!GetVolumeNameForVolumeMountPoint(pwszVolumeDisplayName, wszVolumeName, MAX_TEXT_BUFFER))
        return false; // Invalid volume

    // Check if the volume is already added.
    WCHAR* pwszVolumeNameToBeSearched = wszVolumeName;
    if (m_mapVolumes.FindKey(pwszVolumeNameToBeSearched) != -1)
        return true; // Volume already added. Stop here.

    // Create the volume info object
    CVssVolumeInfo* pVolInfo = new CVssVolumeInfo(wszVolumeName, pwszVolumeDisplayName);
    if (pVolInfo == NULL)
        ft.Err(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allcation error");

    // Add the volume in our internal list of snapshotted volumes
    if (!m_mapVolumes.Add(pVolInfo->GetVolumeDisplayName(), pVolInfo)) {
        delete pVolInfo;
        ft.Err(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allcation error");
    }

    bAdded = true;

    return true;
}


///////////////////////////////////////////////////////////////////////////////
// Utility functions


// Convert a failure type into a string
LPCWSTR CVssMultilayerTest::GetStringFromFailureType( IN  HRESULT hrStatus )
{
    static WCHAR wszBuffer[MAX_TEXT_BUFFER];

    switch (hrStatus)
	{
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITERERROR_OUTOFRESOURCES)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITERERROR_TIMEOUT)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITERERROR_NONRETRYABLE)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITERERROR_RETRYABLE)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_BAD_STATE)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_PROVIDER_ALREADY_REGISTERED)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_PROVIDER_NOT_REGISTERED)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_PROVIDER_VETO)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_PROVIDER_IN_USE)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_OBJECT_NOT_FOUND)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_S_ASYNC_PENDING)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_S_ASYNC_FINISHED)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_S_ASYNC_CANCELLED)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_VOLUME_NOT_SUPPORTED)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_OBJECT_ALREADY_EXISTS)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_UNEXPECTED_PROVIDER_ERROR)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_CORRUPT_XML_DOCUMENT)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_INVALID_XML_DOCUMENT)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_FLUSH_WRITES_TIMEOUT)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_HOLD_WRITES_TIMEOUT)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_UNEXPECTED_WRITER_ERROR)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_SNAPSHOT_SET_IN_PROGRESS)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITER_INFRASTRUCTURE)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITER_NOT_RESPONDING)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITER_ALREADY_SUBSCRIBED)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_UNSUPPORTED_CONTEXT)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_VOLUME_IN_USE)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_INSUFFICIENT_STORAGE)
	
	case NOERROR:
	    break;
	
	default:
        ::FormatMessageW( FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, hrStatus, 0, (LPWSTR)&wszBuffer, MAX_TEXT_BUFFER - 1, NULL);
	    break;
	}

    return (wszBuffer);
}


// Convert a writer status into a string
LPCWSTR CVssMultilayerTest::GetStringFromWriterState( IN  VSS_WRITER_STATE state )
{
    static WCHAR wszBuffer[MAX_TEXT_BUFFER];

    switch (state)
    {
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_UNKNOWN)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_STABLE)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_WAITING_FOR_FREEZE)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_WAITING_FOR_THAW)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_WAITING_FOR_POST_SNAPSHOT)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_WAITING_FOR_BACKUP_COMPLETE)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_FAILED_AT_PREPARE_BACKUP)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_FAILED_AT_PREPARE_SNAPSHOT)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_FAILED_AT_FREEZE)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_FAILED_AT_THAW)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_FAILED_AT_POST_SNAPSHOT)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_FAILED_AT_BACKUP_COMPLETE)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_FAILED_AT_PRE_RESTORE)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_FAILED_AT_POST_RESTORE)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_FAILED_AT_BACKUPSHUTDOWN)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_WS_COUNT)
    
    default:
        swprintf(wszBuffer, L" Unknown state %d", state);
        break;
    }

    return (wszBuffer);
}


INT CVssMultilayerTest::RndDecision(
    IN INT nVariants /* = 2 */
    )
{
    return (rand() % nVariants);
}


LPWSTR CVssMultilayerTest::DateTimeToString(
    IN LONGLONG llTimestamp
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CVssMultilayerTest::DateTimeToString" );

    SYSTEMTIME stLocal;
    FILETIME ftLocal;
    WCHAR pwszDate[ 64 ];
    WCHAR pwszTime[ 64 ];

    BS_ASSERT(sizeof(FILETIME) == sizeof(LONGLONG));
    
    //  Compensate for local TZ
    ::FileTimeToLocalFileTime( (FILETIME *) &llTimestamp, &ftLocal );

    //  Finally convert it to system time
    ::FileTimeToSystemTime( &ftLocal, &stLocal );

    //  Convert timestamp to a date string
    ::GetDateFormatW( GetThreadLocale( ),
                      DATE_SHORTDATE,
                      &stLocal,
                      NULL,
                      pwszDate,
                      sizeof( pwszDate ) / sizeof( pwszDate[0] ));

    //  Convert timestamp to a time string
    ::GetTimeFormatW( GetThreadLocale( ),
                      0,
                      &stLocal,
                      NULL,
                      pwszTime,
                      sizeof( pwszTime ) / sizeof( pwszTime[0] ));

    //  Now combine the strings and return it
    CVssAutoLocalString pwszDateTime;
    pwszDateTime.Append(pwszDate);
    pwszDateTime.Append(L" ");
    pwszDateTime.Append(pwszTime);
    
    return pwszDateTime.Detach();    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\sqltest\main.cpp ===
// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes

#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>
#include <stdio.h>


#include "vss.h"
#include "vswriter.h"
#include "sqlsnap.h"
#include "sqlwriter.h"

DWORD g_dwMainThreadId;

/////////////////////////////////////////////////////////////////////////////
//  Control-C handler routine


BOOL WINAPI CtrlC_HandlerRoutine(
	IN DWORD /* dwType */
	)
	{
	// End the message loop
	if (g_dwMainThreadId != 0)
		PostThreadMessage(g_dwMainThreadId, WM_QUIT, 0, 0);

	// Mark that the break was handled.
	return TRUE;
	}

CVssSqlWriterWrapper g_Wrapper;

extern "C" int __cdecl wmain(HINSTANCE /*hInstance*/,
    HINSTANCE /*hPrevInstance*/, LPTSTR /*lpCmdLine*/, int /*nShowCmd*/)
	{
	int nRet = 0;

    try
		{
    	// Preparing the CTRL-C handling routine - only for testing...
		g_dwMainThreadId = GetCurrentThreadId();
		::SetConsoleCtrlHandler(CtrlC_HandlerRoutine, TRUE);

        // Initialize COM library
        HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if (FAILED(hr))
			throw hr;

		// Declare a CVssTSubWriter instance
		hr = g_Wrapper.CreateSqlWriter();
		if (FAILED(hr))
			throw hr;

        // message loop - need for STA server
        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

		// Subscribe the object.
		g_Wrapper.DestroySqlWriter();

        // Uninitialize COM library
        CoUninitialize();
		}
	catch(...)
		{
		}

    return nRet;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\simsnap\simsnap.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	simsnap.cpp
**
**
** Abstract:
**
**	Test program to drive the VSS Writer Shim contained in VssAPI.DLL
**
**
** Author:
**
**	Michael C. Johnson   [mikejohn]        24-May-2000
**
**
** Revision History:
**
**	X-5	MCJ		Michael C. Johnson		15-Sep-2000
**		Add test for invalid volume array pointer, interleaved calls
**		and so on.
**
**	X-4	MCJ		Michael C. Johnson		15-Sep-2000
**		Add test for invalid bits in options parameter of call to
**		SimulateSnapshotFreeze()
**
**	X-3	MCJ		Michael C. Johnson		30-Jun-2000
**		Remove calls to RegisterSnapshotSubscriptions() and
**		UnregisterSnapshotSubscriptions() as these are no longer
**		required.
**
**	X-2	MCJ		Michael C. Johnson		26-May-2000
**		Add some extra tests to validate shim is properly sensitive
**		to volume name array contents.
**--
*/

/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/
#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdio.h>
#include <objbase.h>
#include <guiddef.h>

#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>


static BOOL AssertPrivilege (LPCWSTR privName);

static HRESULT DoTest01 (VOID);
static HRESULT DoTest02 (VOID);
static HRESULT DoTest03 (VOID);
static HRESULT DoTest05 (VOID);
static HRESULT DoTest06 (VOID);
static HRESULT DoTest07 (VOID);
static HRESULT DoTest08 (VOID);
static HRESULT DoTest09 (VOID);
static HRESULT DoTest10 (VOID);
static HRESULT DoTest11 (VOID);
static HRESULT DoTest12 (VOID);
static HRESULT DoTest13 (VOID);
static HRESULT DoTest14 (VOID);




extern "C" int __cdecl wmain (int argc, char *argv[])
    {
    HRESULT	hrStatus;


    UNREFERENCED_PARAMETER (argv);
    UNREFERENCED_PARAMETER (argc);


    wprintf (L"Test for SimulateSnapshotXxxx calls (ProcessId 0x%04x)\nChecking privileges\n",
	     GetCurrentProcessId ());


    if (!AssertPrivilege (SE_BACKUP_NAME))
	{
        wprintf (L"AssertPrivilege returned error 0x%08X\n", GetLastError ());
        return 2;
	}



    wprintf (L"Initializing COM\n");

    hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);

    if (FAILED (hrStatus))
	{
        wprintf (L"CoInitialize() returned 0x%08X\n", GetLastError ());
        return 1;
	}



    if ( argc == 1 )
    {
        hrStatus = DoTest01 ();

        hrStatus = DoTest02 ();

        hrStatus = DoTest05 ();

        hrStatus = DoTest06 ();

        hrStatus = DoTest02 ();

        hrStatus = DoTest07 ();

        hrStatus = DoTest08 ();

        hrStatus = DoTest09 ();

        hrStatus = DoTest10 ();

        hrStatus = DoTest11 ();

        hrStatus = DoTest12 ();

        hrStatus = DoTest13 ();

        hrStatus = DoTest14 ();
    }
    else
    {
        hrStatus = DoTest03();
    }


    CoUninitialize();

    return 0;
    }




static BOOL AssertPrivilege (LPCWSTR privName)
    {
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if (OpenProcessToken (GetCurrentProcess (), TOKEN_ADJUST_PRIVILEGES, &tokenHandle))
	{
        LUID value;

        if (LookupPrivilegeValue (NULL, privName, &value))
	    {
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            /*
            ** We will always call GetLastError below, so clear
            ** any prior error values on this thread.
            */
            SetLastError (ERROR_SUCCESS);

            stat = AdjustTokenPrivileges (tokenHandle,
					  FALSE,
					  &newState,
					  (DWORD)0,
					  NULL,
					  NULL);

            /*
            ** Supposedly, AdjustTokenPriveleges always returns TRUE
            ** (even when it fails). So, call GetLastError to be
            ** extra sure everything's cool.
            */
            if ((error = GetLastError()) != ERROR_SUCCESS)
		{
                stat = FALSE;
		}

            if (!stat)
		{
                wprintf (L"AdjustTokenPrivileges for %s failed with 0x%08X",
			 privName,
			 error);
		}
	    }


        CloseHandle (tokenHandle);
	}

    return stat;
    }



static HRESULT DoTest01 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = VSS_SW_BOOTABLE_STATE;
    GUID	guidSnapshotSetId;

    ::CoCreateGuid( &guidSnapshotSetId );

    IVssAsync *pIAsync = NULL;

    wprintf (L"\n\nTest  1 - Bootable State, Synchronous\n\n");
    wprintf (L"Simulating snapshot freeze - should work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }

    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}


    return (hrStatus);
    }



static HRESULT DoTest02 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = 0;
    GUID	guidSnapshotSetId;

    ::CoCreateGuid( &guidSnapshotSetId );

    IVssAsync *pIAsync = NULL;

    wprintf (L"\n\nTest  2 - Service State, Synchronous\n\n");
    wprintf (L"Simulating snapshot freeze - should work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }


static HRESULT DoTest03()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = VSS_SW_BOOTABLE_STATE;
    GUID	guidSnapshotSetId;

    ::CoCreateGuid( &guidSnapshotSetId );

    IVssAsync *pIAsync = NULL;

    wprintf (L"\n\nTest  3 - Bootable State, Asynchronous\n\n");
    wprintf (L"Simulating snapshot freeze with Cancel - should work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        wprintf (L"Waiting 5 seconds and then calling Cancel\n" );
        Sleep( 5000 );
        wprintf (L"Cancelling\n" );
        pIAsync->Cancel();

        do {
                Sleep( 1000 );
                hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
                wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);
        } while ( !FAILED( hrStatus ) && hrStatusAsync == VSS_S_ASYNC_PENDING );

        pIAsync->Release();
        }
#if 0
    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}
#endif
    return (hrStatus);
    }



static HRESULT DoTest05 ()
    {
    HRESULT	hrStatus;
    ULONG	ulOptionFlags       = VSS_SW_BOOTABLE_STATE;
    GUID	guidSnapshotSetId;

    ::CoCreateGuid( &guidSnapshotSetId );

    IVssAsync *pIAsync = NULL;

    wprintf (L"\n\nTest  5 - Bootable State, Synchronous, no volumes\n\n");
    wprintf (L"Simulating snapshot freeze - should work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					0,
					NULL,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }



static HRESULT DoTest06 ()
    {
    HRESULT	hrStatus;
    ULONG	ulOptionFlags       = 0;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest  6 - Service State, Synchronous, no volumes\n\n");
    wprintf (L"Simulating snapshot freeze - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					0,
					NULL,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }




static HRESULT DoTest07 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = 0x40 | VSS_SW_BOOTABLE_STATE;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest  7 - Bootable State, Synchronous, Extra Options set\n\n");
    wprintf (L"Simulating snapshot freeze - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }



    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }



static HRESULT DoTest08 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = 0x40;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest  8 - Service State, Synchronous, Extra Options set\n\n");
    wprintf (L"Simulating snapshot freeze - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }


static HRESULT DoTest09 ()
    {
    HRESULT	hrStatus;
    ULONG	ulOptionFlags       = 0x0 | VSS_SW_BOOTABLE_STATE;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest  9 - Bootable State, Synchronous, No volume list\n\n");
    wprintf (L"Simulating snapshot freeze - should work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					0,
					NULL,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }


static HRESULT DoTest10 ()
    {
    HRESULT	hrStatus;
    ULONG	ulOptionFlags       = 0x0;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest 10 - Service State, Synchronous, No volume list\n\n");
    wprintf (L"Simulating snapshot freeze - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					0,
					NULL,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }


static HRESULT DoTest11 ()
    {
    HRESULT	hrStatus;
    ULONG	ulOptionFlags       = 0x0;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest 11 - Service State, Synchronous, One volume with bad volume list pointer\n\n");
    wprintf (L"Simulating snapshot freeze - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					01,
					NULL,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }


static HRESULT DoTest12 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = 0x0;
    GUID	guidSnapshotSetId1;
    GUID	guidSnapshotSetId2;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId1 );
    ::CoCreateGuid( &guidSnapshotSetId2 );

    wprintf (L"\n\nTest 12 - Service State, Synchronous, nested call\n\n");
    wprintf (L"Simulating snapshot freeze (GUID1)\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId1,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze(GUID1) returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    IVssAsync *pIAsync2 = NULL;

    wprintf (L"Simulating snapshot freeze (GUID2) - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId2,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync2);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze(GUID2) returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync2 != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync2->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync2->Wait();

        hrStatus = pIAsync2->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync2->Release();
        }

    wprintf (L"Simulating snapshot thaw (GUID2)\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId2);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw(GUID2) returned 0x%08X\n", hrStatus);
	}


    wprintf (L"Simulating snapshot thaw (GUID1)\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId1);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw(GUID1) returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }



static HRESULT DoTest13 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = 0x0;
    GUID	guidSnapshotSetId1;
    GUID	guidSnapshotSetId2;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId1 );
    ::CoCreateGuid( &guidSnapshotSetId2 );

    wprintf (L"\n\nTest 13 - Service State, Synchronous, nested call (reverse thaw)\n\n");
    wprintf (L"Simulating snapshot freeze (GUID1)\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId1,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze(GUID1) returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    IVssAsync *pIAsync2 = NULL;


    wprintf (L"Simulating snapshot freeze (GUID2)\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId2,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync2);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze(GUID2) returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync2 != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync2->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync2->Wait();

        hrStatus = pIAsync2->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync2->Release();
        }


    wprintf (L"Simulating snapshot thaw (GUID1)\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId1);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw(GUID1) returned 0x%08X\n", hrStatus);
	}


    wprintf (L"Simulating snapshot thaw (GUID2)\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId2);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw(GUID2) returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }




static HRESULT DoTest14 ()
    {
    HRESULT			 hrStatus              = NOERROR;
    HRESULT			 hrStatusAsync         = NOERROR;
    IVssBackupComponents	*pIVssBackupComponents = NULL;
    VSS_ID		     SnapshotId             = GUID_NULL;
    IVssAsync			*pIVssAsync            = NULL;
    GUID			 guidSnapshotSetId     = GUID_NULL;
    GUID			 guidSnapshotSetId2;

    ::CoCreateGuid( &guidSnapshotSetId2 );

    wprintf (L"\n\nTest 14 - Bootable State, Synchronous, during DoSnapshot\n\n");

    wprintf (L"Calling CreateVssBackupComponents ()\n");

    hrStatus = CreateVssBackupComponents (&pIVssBackupComponents);

    if (FAILED (hrStatus))
	{
	wprintf (L"CreateVssBackupComponents () returned 0x%08X\n", hrStatus);
	}



    wprintf (L"Calling InitializeForBackup ()\n");

    hrStatus = pIVssBackupComponents->InitializeForBackup ();

    if (FAILED (hrStatus))
	{
	wprintf (L"InitializeForBackup () returned 0x%08X\n", hrStatus);
	}





    wprintf (L"Calling SetBackupState ()\n");

    hrStatus = pIVssBackupComponents->SetBackupState (true, true, VSS_BT_FULL, false);

    if (FAILED (hrStatus))
	{
	wprintf (L"SetBackupState () returned 0x%08X\n", hrStatus);
	}



    wprintf (L"Calling GatherWriterMetadata ()\n");

    hrStatus = pIVssBackupComponents->GatherWriterMetadata (&pIVssAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"GatherWriterMetadata () returned 0x%08X\n", hrStatus);
	}


    wprintf (L"Calling Wait () (for GatherWriterMetadata() to complete)\n");

    hrStatus = pIVssAsync->Wait ();

    if (FAILED (hrStatus))
	{
	wprintf (L"Wait () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling StartSnapshotSet ()\n");

    hrStatus = pIVssBackupComponents->StartSnapshotSet (&guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"StartSnapshotSet () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling AddToSnapshotSet ()\n");

    hrStatus = pIVssBackupComponents->AddToSnapshotSet (L"E:\\",
							GUID_NULL,
							&SnapshotId);

    if (FAILED (hrStatus))
	{
	wprintf (L"AddToSnapshotSet () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling PrepareForBackup ()\n");

    hrStatus = pIVssBackupComponents->PrepareForBackup (&pIVssAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"PrepareForBackup () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling Wait () (for PrepareForBackup() to complete)\n");

    hrStatus = pIVssAsync->Wait ();

    if (FAILED (hrStatus))
	{
	wprintf (L"Wait () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling QueryStatus ()\n");

    hrStatus = pIVssAsync->QueryStatus (&hrStatusAsync, 0);

    if (FAILED (hrStatus))
	{
	wprintf (L"QueryStatus () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling DoSnapshotSet ()\n");

    hrStatus = pIVssBackupComponents->DoSnapshotSet (&pIVssAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"DoSnapshotSet () returned 0x%08X\n", hrStatus);
	}



    wprintf (L"Calling SimulateSnapshotFreeze () - should NOT work\n");

    IVssAsync *pIAsync = NULL;

    hrStatus = SimulateSnapshotFreeze (guidSnapshotSetId2,
				       VSS_SW_BOOTABLE_STATE,
				       0,
				       NULL,
  				       &pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze () returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Calling SimulateSnapshotThaw ()\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId2);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw () returned 0x%08X\n", hrStatus);
	}


    wprintf (L"Calling Wait () (for DoSnapshotSet () to complete) ()\n");

    hrStatus = pIVssAsync->Wait();

    if (FAILED (hrStatus))
	{
	wprintf (L"Wait () returned 0x%08X\n", hrStatus);
	}

    pIVssAsync->Release();
    pIVssBackupComponents->Release();

    return (hrStatus);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\ststest\main.cpp ===
#include "stdafx.hxx"
#include "vs_inc.hxx"
#include "iadmw.h"
#include "iiscnfg.h"
#include "vs_reg.hxx"
#include "stssites.hxx"


void Usage()
    {
    wprintf(L"stssites list\n");
    wprintf(L"stssites lock site time\n");
    wprintf(L"\twhere site is the site number\n");
    wprintf(L"\twhere time is the # of seconds to hold the lock\n");
    }

void InitializeSites(CSTSSites &sites)
    {
    if (!sites.ValidateSharepointVersion())
        {
        wprintf(L"Sharepoint 5.0 is not installed on this machine.\n");
        throw E_INVALIDARG;
        }

    if (!sites.Initialize())
        {
        wprintf(L"CSTSSites::Initialize failed.\n");
        throw E_INVALIDARG;
        }
    }



void ListSites()
    {
    CSTSSites sites;
    InitializeSites(sites);
    DWORD cSites = sites.GetSiteCount();
    for(DWORD iSite = 0; iSite < cSites; iSite++)
        {
        DWORD siteId = sites.GetSiteId(iSite);
        wprintf(L"Site 0x%08x\n", siteId);
        VSS_PWSZ wszComment = sites.GetSiteComment(iSite);
        wprintf(L"Site name (comment) = %s\n", wszComment);
        CoTaskMemFree(wszComment);
        VSS_PWSZ wszIpAddress = sites.GetSiteIpAddress(iSite);
        VSS_PWSZ wszHost = sites.GetSiteHost(iSite);
        DWORD dwPort = sites.GetSitePort(iSite);
        if (wszIpAddress)
            {
            wprintf(L"IpAddress = %s\n", wszIpAddress);
            CoTaskMemFree(wszIpAddress);
            }

        if (wszHost)
            {
            wprintf(L"Host = %s\n", wszHost);
            CoTaskMemFree(wszHost);
            }

        wprintf(L"Port = %d\n", dwPort);
        VSS_PWSZ wszDsn = sites.GetSiteDSN(iSite);
        wprintf(L"DSN=%s\n", wszDsn);
        CoTaskMemFree(wszDsn);
        VSS_PWSZ wszRoot = sites.GetSiteRoot(iSite);
        wprintf(L"Root=%s\n", wszRoot);
        CoTaskMemFree(wszRoot);

        VSS_PWSZ wszRoles = sites.GetSiteRoles(iSite);
        wprintf(L"Roles = %s\n", wszRoles);
        CoTaskMemFree(wszRoles);
        wprintf(L"\n\n");
        }
    }

void LockSite(LPCWSTR wszSiteId, LPCWSTR wszSleep)
    {
    DWORD siteId = _wtoi(wszSiteId);
    DWORD secs = _wtoi(wszSleep);

    CSTSSites sites;
    InitializeSites(sites);
    DWORD cSites = sites.GetSiteCount();
    for(DWORD iSite = 0; iSite < cSites; iSite++)
        {
        if (sites.GetSiteId(iSite) == siteId)
            break;
        }

    if (iSite >= cSites)
        {
        wprintf(L"invalid site id %d.\n", siteId);
        throw E_INVALIDARG;
        }

    sites.LockSiteContents(iSite);
    wprintf(L"site %d locked for %d seconds.\n", siteId, secs);
    Sleep(secs * 1000);
    sites.UnlockSites();
    }

extern "C" __cdecl wmain(int argc, WCHAR **argv)
    {
    bool bCoInitializeSucceeded = false;

    try
        {
        HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if (FAILED(hr))
            {
            wprintf(L"CoInitializeEx failed with hr=0x%08lx.\n", hr);
            throw(hr);
            }

        bCoInitializeSucceeded = TRUE;

        if (argc < 2 || argc > 4)
            {
            Usage();
            throw E_INVALIDARG;
            }

        if (_wcsicmp(argv[1], L"list") == 0 && argc == 2)
            ListSites();

        else if (_wcsicmp(argv[1], L"lock") == 0 && argc == 4)
            LockSite(argv[2], argv[3]);
        else
            {
            Usage();
            throw E_INVALIDARG;
            }
        }
    catch(HRESULT)
        {
        }
    catch(...)
        {
        wprintf(L"Unexpected exception!!!\n");
        }

    if (bCoInitializeSucceeded)
        CoUninitialize();

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\ststest\stssites.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Abstract:

    @doc
    @module stssites.cxx | Implementation of CSTSSites
    @end

Author:

    Brian Berkowitz  [brianb]  10/15/2001

Revision History:

    Name        Date        Comments
    brianb     10/15/2001  Created

--*/

#include "stdafx.hxx"
#include "vs_inc.hxx"
#include "vs_reg.hxx"


#include "iadmw.h"
#include "iiscnfg.h"
#include "mdmsg.h"


#include "stssites.hxx"
#include "vswriter.h"

// toplevel key for enumeration of sites and their DSNs
static LPCWSTR x_STSSECUREKEY = L"Software\\Microsoft\\Shared Tools\\Web Server Extensions\\Secure";

// DSN value
static LPCWSTR x_ValueDSN = L"DSN";

// version key for Sharepoint Team Services 5.0"
static LPCWSTR x_STSVERSIONKEY = L"Software\\Microsoft\\Shared Tools\\Web Server Extensions\\5.0";

// key to Shell Folders properties.  Used to get Applications Data directory"
static LPCWSTR x_ShellFoldersKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";

// value of applications data directory under Shell folders key
static LPCWSTR x_AppDataValue = L"Common AppData";

// subfolder under Applications data directory for STS data"
static LPCWSTR x_STSSubfolder = L"\\Microsoft\\Web Server Extensions\\50";

// constructor
CSTSSites::CSTSSites() :
    m_cSites(0),
    m_rgSiteIds(NULL),
    m_rootKey(KEY_READ|KEY_ENUMERATE_SUB_KEYS),
    m_hQuotaLock(INVALID_HANDLE_VALUE),
    m_wszAppDataFolder(NULL)
    {
    }

// destructor
CSTSSites::~CSTSSites()
    {
    delete m_rgSiteIds;
    UnlockSites();
    UnlockQuotaDatabase();
    CoTaskMemFree(m_wszAppDataFolder);
    }


// initialize the array of site ids.  Returns FALSE if there are no sites
bool CSTSSites::Initialize()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::Initialize");

    if (!m_rootKey.Open(HKEY_LOCAL_MACHINE, x_STSSECUREKEY))
        return false;

    CVssRegistryKeyIterator iter;
    iter.Attach(m_rootKey);
    try
        {
        m_cSites = iter.GetSubkeysCount();
        m_rgSiteIds = new DWORD[m_cSites];
        if (m_rgSiteIds == NULL)
            ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"can't allocate site id array");

        for(UINT iSite = 0; iSite < m_cSites; iSite++)
            {
            DWORD siteId;

            BS_ASSERT(!iter.IsEOF());
            LPCWSTR wszSiteName = iter.GetCurrentKeyName();
            BS_ASSERT(wcslen(wszSiteName) > 10);
            BS_ASSERT(wcsncmp(wszSiteName, L"/LM/W3SVC/", 10) == 0);
            DWORD cFields = swscanf(wszSiteName, L"/LM/W3SVC/%d:", &siteId);
            BS_ASSERT(cFields == 1);
            m_rgSiteIds[iSite] = siteId;
            iter.MoveNext();
            }

        }
    catch(...)
        {
        iter.Detach();
        throw;
        }

    iter.Detach();
    return true;
    }

// return the id of a specific site
VSS_PWSZ CSTSSites::GetSiteDSN(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetSiteDSN");

    CVssRegistryKey key(KEY_READ);
    BS_ASSERT(iSite < m_cSites);
    DWORD siteId = m_rgSiteIds[iSite];
    WCHAR buf[MAX_PATH];
    swprintf(buf, L"/LM/W3SVC/%d:", siteId);
    if (!key.Open(m_rootKey.GetHandle(), buf))
        ft.Throw(VSSDBG_STSWRITER, E_UNEXPECTED, L"missing registry key");

    VSS_PWSZ pwszDSN = NULL;
    key.GetValue(x_ValueDSN, pwszDSN);

    return pwszDSN;
    }

// determine if this is the correct sharepoint version
bool CSTSSites::ValidateSharepointVersion()
    {
    CVssRegistryKey key;

    return key.Open(HKEY_LOCAL_MACHINE, x_STSVERSIONKEY);
    }


void CSTSSites::SetupMetabaseInterface()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::SetupMetabaseInterface");

    if (!m_pMetabase)
        {
        ft.hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_ALL, IID_IMSAdminBase, (void **) &m_pMetabase);
        ft.CheckForError(VSSDBG_STSWRITER, L"CoCreateInstance MSAdminBase");
        }
    }

// return pointer to site content root.  The return value should be
// freed using CoTaskMemFree by the caller
VSS_PWSZ CSTSSites::GetSiteRoot(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetSiteRoles");
    METADATA_HANDLE h;
    static const DWORD x_MDTimeout = 2000;

    BS_ASSERT(iSite < m_cSites);
    DWORD siteId = m_rgSiteIds[iSite];
    WCHAR buf[METADATA_MAX_NAME_LEN];

    SetupMetabaseInterface();

    swprintf(buf, L"/LM/W3SVC/%d", siteId);

    ft.hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, buf, METADATA_PERMISSION_READ, x_MDTimeout, &h);
    ft.CheckForError(VSSDBG_STSWRITER, L"IMSAdminBase::OpenKey");
    CVssAutoMetabaseHandle MetaHandle(m_pMetabase, h);
    METADATA_RECORD rec;
    DWORD dwBufLen = METADATA_MAX_NAME_LEN;
    PBYTE pbBuffer = (BYTE *) CoTaskMemAlloc(dwBufLen);
    if (pbBuffer == NULL)
        ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

    rec.dwMDAttributes = METADATA_INHERIT;
    rec.dwMDUserType = IIS_MD_UT_SERVER,
    rec.dwMDDataType = ALL_METADATA;
    rec.dwMDDataLen = dwBufLen;
    rec.pbMDData = pbBuffer;
    rec.dwMDIdentifier = MD_VR_PATH;

    DWORD dwReqSize;
    ft.hr = m_pMetabase->GetData(h, L"/root", &rec, &dwReqSize);
    if (ft.hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
        CoTaskMemFree(pbBuffer);
        pbBuffer = (BYTE *) CoTaskMemAlloc(dwReqSize);
        if (pbBuffer == NULL)
            ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

        rec.dwMDDataLen = dwReqSize;
        rec.pbMDData = pbBuffer;
        ft.hr = m_pMetabase->GetData(h, L"/root", &rec, &dwReqSize);
        }

    ft.CheckForError(VSSDBG_STSWRITER, L"IMSAdminBase::GetData");

    return (WCHAR *) pbBuffer;
    }

void CSTSSites::LockSiteContents(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::LockSiteContents");

    BS_ASSERT(m_rgContentLocks.GetSize() == 0);

    VSS_PWSZ wszContentRoot = GetSiteRoot(iSite);
    WCHAR *wszCurrentFile = NULL;
    char *szFile = NULL;
    WCHAR *wszFile = NULL;
    WCHAR *wszNewRoot = NULL;
    CSimpleArray<VSS_PWSZ> rgwszRoots;
    try
        {
        wszCurrentFile = new WCHAR[wcslen(wszContentRoot) + 1];
        if (wszCurrentFile == NULL)
            ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

        wcscpy(wszCurrentFile, wszContentRoot);
        rgwszRoots.Add(wszCurrentFile);
        DWORD iCurrentPos = 0;
        DWORD iEndLevel = 1;
        CoTaskMemFree(wszContentRoot);
        wszContentRoot = NULL;
        while(iCurrentPos < iEndLevel)
            {
            for(; iCurrentPos < iEndLevel; iCurrentPos++)
                {
                LPCWSTR wszCurrentRoot = rgwszRoots[iCurrentPos];
                wszCurrentFile = new WCHAR[wcslen(wszCurrentRoot) + MAX_PATH + 2];
                if (wszCurrentFile == NULL)
                    ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

                // get front page lock
                wcscpy(wszCurrentFile, wszCurrentRoot);
                wcscat(wszCurrentFile, L"\\_vti_pvt\\frontpg.lck");
                TryLock(wszCurrentFile, false);

                // get service lock
                wcscpy(wszCurrentFile, wszCurrentRoot);
                wcscat(wszCurrentFile, L"\\_vti_pvt\\service.lck");
                TryLock(wszCurrentFile, false);

                // find child sub webs
                wcscpy(wszCurrentFile, wszCurrentRoot);
                wcscat(wszCurrentFile, L"\\_vti_pvt\\services.cnf");
                CVssAutoWin32Handle h = CreateFile
                                        (
                                        wszCurrentFile,
                                        GENERIC_READ,
                                        FILE_SHARE_READ,
                                        NULL,
                                        OPEN_EXISTING,
                                        0,
                                        NULL
                                        );

                if (h == INVALID_HANDLE_VALUE)
                    {
                    DWORD dwErr = GetLastError();
                    if (dwErr == ERROR_PATH_NOT_FOUND ||
                        dwErr == ERROR_FILE_NOT_FOUND)
                        continue;

                    ft.TranslateGenericError
                        (
                        VSSDBG_STSWRITER,
                        HRESULT_FROM_WIN32(GetLastError()),
                        L"CreateFile(%s)",
                        wszCurrentFile
                        );
                    }

                DWORD dwSize = GetFileSize(h, NULL);
                if (dwSize == 0)
                    ft.TranslateGenericError
                        (
                        VSSDBG_STSWRITER,
                        HRESULT_FROM_WIN32(GetLastError()),
                        L"GetFileSize(%s)",
                        wszCurrentFile
                        );

                szFile = new char[dwSize + 1];
                wszFile = new WCHAR[dwSize + 1];
                if (szFile == NULL || wszFile == NULL)
                    ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

                DWORD dwRead;
                if (!ReadFile(h, szFile, dwSize, &dwRead, NULL))
                    ft.TranslateGenericError
                        (
                        VSSDBG_STSWRITER,
                        HRESULT_FROM_WIN32(GetLastError()),
                        L"ReadFile(%s)",
                        wszCurrentFile
                        );

                szFile[dwSize] = '\0';

                if (!MultiByteToWideChar
                        (
                        CP_ACP,
                        MB_ERR_INVALID_CHARS,
                        szFile,
                        dwSize,
                        wszFile,
                        dwSize))
                    {
                    ft.hr = HRESULT_FROM_WIN32(GetLastError());
                    ft.CheckForError(VSSDBG_STSWRITER, L"MultiByteToWideChar");
                    }


                WCHAR *pwcCur = wszFile;
                WCHAR *pwcMax = wszFile + dwSize;
                while(pwcCur < pwcMax)
                    {
                    WCHAR *pwcEnd = wcschr(pwcCur, L'\n');
                    *pwcEnd = L'\0';
                    stripWhiteChars(pwcCur);
                    if (*pwcCur == L'\0' || *pwcCur != L'/' || pwcCur[1] == L'\0')
                        {
                        pwcCur = pwcEnd + 1;
                        continue;
                        }

                    wszNewRoot = new WCHAR[wcslen(pwcCur) + wcslen(wszCurrentRoot) + 1];
                    if (wszNewRoot == NULL)
                        ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

                    wcscpy(wszNewRoot, wszCurrentRoot);

                    // use backslash instead of forward slash
                    wcscat(wszNewRoot, L"\\");

                    // root of subweb
                    wcscat(wszNewRoot, pwcCur+1);
                    rgwszRoots.Add(wszNewRoot);
                    wszNewRoot = NULL;
                    pwcCur = pwcEnd + 1;
                    }

                delete wszFile;
                wszFile = NULL;
                }

            iCurrentPos = iEndLevel;
            iEndLevel = rgwszRoots.GetSize();
            }
        }
    catch(...)
        {
        UnlockSites();
        delete wszNewRoot;
        delete wszFile;
        delete wszCurrentFile;
        CoTaskMemFree(wszContentRoot);
        throw;
        }
    }



// remove white characters from beginning and ending of the string
void CSTSSites::stripWhiteChars(LPWSTR &wsz)
    {
    static LPCWSTR x_wszWhiteChars = L"^[ \t]+";
    while(*wsz != L'\0')
        {
        if (wcschr(x_wszWhiteChars, *wsz) == NULL)
            break;

        wsz++;
        }

    if (*wsz == L'\0')
        return;

    LPWSTR wszEnd = wsz + wcslen(wsz) - 1;
    while(wszEnd > wsz)
        {
        if (wcschr(x_wszWhiteChars, *wszEnd) == NULL && *wszEnd != L'\r')
            break;

        *wszEnd = L'\0';
        wszEnd--;
        }
    }

void CSTSSites::TryLock(LPCWSTR wszFile, bool bQuotaFile)
    {
    static const DWORD x_MAX_RETRIES = 60;
    static const DWORD x_SLEEP_INTERVAL = 1000;

    HANDLE h = INVALID_HANDLE_VALUE;
    for(DWORD i = 0; i < x_MAX_RETRIES; i++)
        {
        h = CreateFile
                (
                wszFile,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

        if (h != INVALID_HANDLE_VALUE)
            break;

        DWORD dwErr = GetLastError();
        if (dwErr == ERROR_SHARING_VIOLATION)
            {
            Sleep(x_SLEEP_INTERVAL);
            continue;
            }

        // assume file doesn't exist
        return;
        }

    if (i >= x_MAX_RETRIES)
        throw VSS_E_WRITERERROR_TIMEOUT;

    BS_ASSERT(h != INVALID_HANDLE_VALUE);

    try
        {
        if (bQuotaFile)
            {
            BS_ASSERT(m_hQuotaLock == INVALID_HANDLE_VALUE);
            m_hQuotaLock = h;
            }
        else
            m_rgContentLocks.Add(h);
        }
    catch(...)
        {
        // add failed, close handle and rethrow error
        CloseHandle(h);
        throw;
        }
    }

void CSTSSites::UnlockSites()
    {
    DWORD dwSize = m_rgContentLocks.GetSize();
    for(DWORD i = 0; i < dwSize; i++)
        CloseHandle(m_rgContentLocks[i]);

    m_rgContentLocks.RemoveAll();
    }

// lock the quota database
void CSTSSites::LockQuotaDatabase()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::LockQuotaDatabase");

    BS_ASSERT(m_hQuotaLock == INVALID_HANDLE_VALUE);

    static LPCWSTR x_wszLockFile = L"\\owsuser.lck";

    VSS_PWSZ wszDbRoot = GetQuotaDatabase();
    LPWSTR wsz = NULL;
    try
        {
        wsz = new WCHAR[wcslen(wszDbRoot) + 1 + wcslen(x_wszLockFile)];
        if (wsz == NULL)
            ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

        wcscpy(wsz, wszDbRoot);
        wcscat(wsz, x_wszLockFile);
        TryLock(wsz, true);
        delete wsz;
        CoTaskMemFree(wszDbRoot);
        }
    catch(...)
        {
        delete wsz;
        CoTaskMemFree(wszDbRoot);
        throw;
        }
    }

// unlock the quota database
void CSTSSites::UnlockQuotaDatabase()
    {
    if (m_hQuotaLock != INVALID_HANDLE_VALUE)
        {
        CloseHandle(m_hQuotaLock);
        m_hQuotaLock = INVALID_HANDLE_VALUE;
        }
    }


// get location of Documents And Settings/All Users folder
LPCWSTR CSTSSites::GetAppDataFolder()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetAppDataFolder");
    if (m_wszAppDataFolder)
        return m_wszAppDataFolder;

    CVssRegistryKey key;
    if (!key.Open(HKEY_LOCAL_MACHINE, x_ShellFoldersKey))
        ft.Throw(VSSDBG_STSWRITER, E_UNEXPECTED, L"shell folders key is missing");


    key.GetValue(x_AppDataValue, m_wszAppDataFolder);
    return m_wszAppDataFolder;
    }

// get location of directory containing the quota database for
// sharepoint.  Caller should call CoTaskMemFree on the returned value
VSS_PWSZ CSTSSites::GetQuotaDatabase()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetQuotaDatabase");
    LPCWSTR wszAppData = GetAppDataFolder();
    DWORD cwc = (DWORD) wcslen(wszAppData) + wcslen(x_STSSubfolder) + 1;
    VSS_PWSZ wsz = (VSS_PWSZ) CoTaskMemAlloc(cwc * sizeof(WCHAR));
    wcscpy(wsz, wszAppData);
    wcscat(wsz, x_STSSubfolder);
    return wsz;
    }

// return of the root directory for the sites roles database under
// the app data folder
VSS_PWSZ CSTSSites::GetSiteRoles(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetSiteRoles");

    DWORD siteId = GetSiteId(iSite);
    WCHAR buf[32];
    swprintf(buf, L"\\W3SVC%d", siteId);
    LPCWSTR wszAppData = GetAppDataFolder();
    DWORD cwc = (DWORD) wcslen(wszAppData) + wcslen(x_STSSubfolder) + wcslen(buf) + 1;
    VSS_PWSZ wsz = (VSS_PWSZ) CoTaskMemAlloc(cwc * sizeof(WCHAR));
    wcscpy(wsz, wszAppData);
    wcscat(wsz, x_STSSubfolder);
    wcscat(wsz, buf);
    return wsz;
    }

VSS_PWSZ CSTSSites::GetSiteBasicInfo(DWORD iSite, DWORD propId)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetSiteBasicInfo");

    METADATA_HANDLE h;
    static const DWORD x_MDTimeout = 2000;

    BS_ASSERT(iSite < m_cSites);
    DWORD siteId = m_rgSiteIds[iSite];

    SetupMetabaseInterface();

    ft.hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, L"/LM/W3SVC", METADATA_PERMISSION_READ, x_MDTimeout, &h);
    ft.CheckForError(VSSDBG_STSWRITER, L"IMSAdminBase::OpenKey");
    CVssAutoMetabaseHandle MetaHandle(m_pMetabase, h);
    METADATA_RECORD rec;
    DWORD dwBufLen = METADATA_MAX_NAME_LEN;
    PBYTE pbBuffer = (BYTE *) CoTaskMemAlloc(dwBufLen);
    if (pbBuffer == NULL)
        ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

    rec.dwMDAttributes = METADATA_INHERIT;
    rec.dwMDUserType = IIS_MD_UT_SERVER,
    rec.dwMDDataType = ALL_METADATA;
    rec.dwMDDataLen = dwBufLen;
    rec.pbMDData = pbBuffer;
    rec.dwMDIdentifier = propId;

    WCHAR buf[16];
    swprintf(buf, L"/%d", siteId);

    DWORD dwReqSize;
    ft.hr = m_pMetabase->GetData(h, buf, &rec, &dwReqSize);
    if (ft.hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
        CoTaskMemFree(pbBuffer);
        pbBuffer = (BYTE *) CoTaskMemAlloc(dwReqSize);
        if (pbBuffer == NULL)
            ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

        rec.dwMDDataLen = dwReqSize;
        rec.pbMDData = pbBuffer;
        ft.hr = m_pMetabase->GetData(h, buf, &rec, &dwReqSize);
        }

    if (ft.hr == MD_ERROR_DATA_NOT_FOUND)
        return NULL;

    ft.CheckForError(VSSDBG_STSWRITER, L"IMSAdminBase::GetData");

    return (WCHAR *) pbBuffer;
    }



// return comments for site (site description).  Caller is responsible
// for freeing up the memory using CoTaskMemFree
VSS_PWSZ CSTSSites::GetSiteComment(DWORD iSite)
    {
    return GetSiteBasicInfo(iSite, MD_SERVER_COMMENT);
    }

// return ip address of the site if it exists.  Caller is responsible for
// freeing up the memory using CoTaskMemFree
VSS_PWSZ CSTSSites::GetSiteIpAddress(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetSiteIpAddress");

    VSS_PWSZ wszBindings = GetSiteBasicInfo(iSite, MD_SERVER_BINDINGS);

    if (wszBindings == NULL)
        return NULL;

    LPWSTR wszHost = wcsrchr(wszBindings, L':');
    if (wszHost == NULL)
        {
        CoTaskMemFree(wszBindings);
        return NULL;
        }

    *wszHost = '\0';
    LPCWSTR wszPort = wcsrchr(wszBindings, L':');
    if (wszPort == NULL || wszPort == wszBindings)
        {
        CoTaskMemFree(wszBindings);
        return NULL;
        }

    DWORD cwc = (DWORD) (wszPort - wszBindings);
    VSS_PWSZ pwszRet = (VSS_PWSZ) CoTaskMemAlloc(cwc * sizeof(WCHAR));
    if (pwszRet == NULL)
        {
        CoTaskMemFree(wszBindings);
        ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");
        }

    wcsncpy(pwszRet, wszBindings, cwc - 1);
    pwszRet[cwc - 1] = L'\0';
    return pwszRet;
    }

// return port address of the site if it exists.  Caller is responsible for
// freeing up the memory using CoTaskMemFree
DWORD CSTSSites::GetSitePort(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetSiteIpAddress");

    VSS_PWSZ wszBindings = GetSiteBasicInfo(iSite, MD_SERVER_BINDINGS);

    if (wszBindings == NULL)
        return NULL;

    LPWSTR wszHost = wcsrchr(wszBindings, L':');
    if (wszHost == NULL)
        {
        CoTaskMemFree(wszBindings);
        return NULL;
        }

    *wszHost = L'\0';
    LPWSTR wszPort = wcsrchr(wszBindings, L':');
    if (wszPort == NULL || wszPort + 1 == wszHost)
        {
        CoTaskMemFree(wszBindings);
        return 0;
        }

    DWORD dwPort = _wtoi(wszPort + 1);
    CoTaskMemFree(wszBindings);
    return dwPort;
    }


// return port address of the site if it exists.  Caller is responsible for
// freeing up the memory using CoTaskMemFree
VSS_PWSZ CSTSSites::GetSiteHost(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetSiteIpAddress");

    VSS_PWSZ wszBindings = GetSiteBasicInfo(iSite, MD_SERVER_BINDINGS);

    if (wszBindings == NULL)
        return NULL;

    LPCWSTR wszHost = wcsrchr(wszBindings, L':');
    if (wszHost == NULL || wcslen(wszHost) == 1)
        {
        CoTaskMemFree(wszBindings);
        return NULL;
        }

    VSS_PWSZ pwszRet = (VSS_PWSZ) CoTaskMemAlloc(wcslen(wszHost));
    if (pwszRet == NULL)
        {
        CoTaskMemFree(wszBindings);
        ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");
        }

    wcscpy(pwszRet, wszHost + 1);
    CoTaskMemFree(wszBindings);
    return pwszRet;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\vsst\cmdparse.h ===
/*
**++
**
** Copyright (c) 2000-2002  Microsoft Corporation
**
**
** Module Name:
**
**	    cmdparse.h
**
**
** Abstract:
**
**	    Command line parser 
**
** Author:
**
**	    Adi Oltean      [aoltean]       02/26/2002
**
** Revision History:
**
**--
*/

#ifndef __CMD_PARSE_HEADER_H__
#define __CMD_PARSE_HEADER_H__

#if _MSC_VER > 1000
#pragma once
#endif


//////////////////////////////////////////////////////////////////
//
//	Generic string class
//


class CGxnString
{
private:
	CGxnString(const CGxnString&);
	
public:

	CGxnString(): m_pwszString(NULL), m_pwszCurrent(NULL) {};
		
	CGxnString(int nAllocatedChars): m_pwszString(NULL), m_pwszCurrent(NULL) {
		Allocate(nAllocatedChars);
	};
	
	CGxnString( const WCHAR* wszString, int nAllocatedChars = -1 ): m_pwszString(NULL), m_pwszCurrent(NULL) {
   		CopyFrom(wszString, nAllocatedChars);
	};
	
	~CGxnString(){
   		Clear();
	};
	
	operator WCHAR* () { return m_pwszCurrent; };


	void operator ++ (int) { m_pwszCurrent++; };
	
	void operator += (int nChars) { m_pwszCurrent += nChars; };
	
	void CopyFrom(const WCHAR * wszString, int nAllocatedChars = -1) { 
		int nLen = (nAllocatedChars == -1)? wcslen(wszString): nAllocatedChars;
   		Allocate(nLen);
   		::wcsncpy(m_pwszString, wszString, nLen);
	};

	void Allocate(int nAllocatedChars) { 
		delete[] m_pwszString;
		m_pwszString = new WCHAR[nAllocatedChars + 1];
   		if (NULL == m_pwszString) throw(E_OUTOFMEMORY);
   		m_pwszString[nAllocatedChars] = L'\0'; 
   		m_pwszCurrent = m_pwszString;
	};

	void Clear() { 
   		delete[] m_pwszString;
   		m_pwszString = m_pwszCurrent = NULL;
	};


private: 
	WCHAR * m_pwszString;
	WCHAR * m_pwszCurrent;
};


//////////////////////////////////////////////////////////////////
//
//	Generic tracing mechanism (can be replaced with a better one)
//


// Useful macros for tracing
#define GXN_DBGINFO __LINE__, __FILE__

// Tracing buffer - max value
#define MAX_TRACING_BUFFER	400


// Macro used for commoditized vsprintf
#define GXN_VARARG( LastParam )												\
	CGxnString buffer(MAX_TRACING_BUFFER);									\
    va_list marker;															\
    va_start( marker, LastParam );											\
    _vsnwprintf( buffer, MAX_TRACING_BUFFER - 1, LastParam, marker );		\
    va_end( marker );														


// The tracing class (a very simple implementation)
struct CGxnTracer
{
	enum{
		TraceFlag		= 1,
		OutputFlag		= 2,
		ErrorFlag		= 4,
		AllFlags		= 7,
	};

	CGxnTracer(int nLine = 0, char* szFile = NULL, WCHAR* wszFunction = NULL):
		m_nTraceFlags(OutputFlag | ErrorFlag), 
		m_szFile(szFile), m_nLine(nLine), m_wszFunction(wszFunction) {};

	CGxnTracer(int nTraceFlags, int nLine = 0, char* szFile = NULL, WCHAR* wszFunction = NULL):
		m_nTraceFlags(nTraceFlags), 
		m_szFile(szFile), m_nLine(nLine), m_wszFunction(wszFunction) {
		if (m_wszFunction) Trace(m_nLine, m_szFile, L"* Enter %s\n", m_wszFunction);
	};

	~CGxnTracer() {
		if (m_wszFunction) Trace(m_nLine, m_szFile, L"* Exit %s\n", m_wszFunction);
	};

	int SetOptions( int nTraceFlags ) {
		int nPrevTraceFlags = m_nTraceFlags;
		m_nTraceFlags = nTraceFlags;
		return nPrevTraceFlags;
	}

	void Out( WCHAR* pwszMsgFormat, ... )	{
		if (m_nTraceFlags & OutputFlag) {
			GXN_VARARG( pwszMsgFormat );
			wprintf( L"%s", (LPWSTR)buffer);
		}
	}

	void Trace( int nLine, char* szFile, const WCHAR* pwszMsgFormat, ... )	{
		if (m_nTraceFlags & TraceFlag) {
			GXN_VARARG( pwszMsgFormat );
			wprintf( L"%s - %hs(%d)\n", (LPWSTR)buffer, szFile, nLine);
		}
	}

	void Err( WCHAR* pwszMsgFormat, ... )	{
		if (m_nTraceFlags & ErrorFlag) {
			GXN_VARARG( pwszMsgFormat );
			wprintf( L"%s", (LPWSTR)buffer);
		}
	}

	__declspec(noreturn) void Throw( INT nLine, char* szFile, HRESULT hr, const WCHAR* pwszMsgFormat, ... )	{
		if (m_nTraceFlags & ErrorFlag) {
			GXN_VARARG( pwszMsgFormat );
			wprintf( L"%s [ERROR: 0x%08lx] - %hs(%d)\n", (LPWSTR)buffer, hr, szFile, nLine);
		}
		throw (hr);
	}

private:
	int 	m_nTraceFlags;
	char*	m_szFile;
	int 	m_nLine;
	WCHAR* 	m_wszFunction;
};



////////////////////////////////////////////////////////////////////////// 
//
//	Command line parser
//


#define BEGIN_CMD_PARSER( AppName )								\
 	virtual CHAR* GetAppName() { return #AppName; };			\
	virtual CmdTemplateEntry & GetCmdTemplate(INT nIndex) {		\
		static CmdTemplateEntry arrEntries[] = {				\


#define CMD_ENTRY(pRoutine, wszTemplate, wszComment) 			\
		{ pRoutine, wszTemplate, wszComment},					\


#define END_CMD_PARSER								 			\
			{ NULL, NULL, NULL },								\
		};														\
		return arrEntries[nIndex];								\
	}


// Command line parser class
template <
	class CRoutineSupport,
	class CTracer = CGxnTracer, 
	int MAX_PARAMS = 40
	>
class CGxnCmdLineParser
{
// Types
public: 
	typedef  void 	(CRoutineSupport::*PRoutineNonaligned)();
	typedef  __declspec(align(16)) 	PRoutineNonaligned PRoutine;
	
	typedef struct {
		PRoutine	pRoutine;
		LPWSTR 		wszCmdLine;
		LPWSTR 		wszComment;
	} CmdTemplateEntry;

// Constructors/destructors
private:
	CGxnCmdLineParser(const CGxnCmdLineParser&);

public:
	CGxnCmdLineParser(): m_nParamCount(0), m_nSelectedTemplate(0) {};

public:
 	virtual CHAR* GetAppName() = 0;
	virtual CmdTemplateEntry & GetCmdTemplate(INT nIndex) = 0;

// Operations
public:

	bool ParseCmdLine(WCHAR* pwszCommandLine)
	{
//		CTracer ft( GXN_DBGINFO, L"CGxnCmdLineParser::ParseCmdLine");

		for (INT nIndex = 0;; nIndex++)
		{
			CmdTemplateEntry & entry = GetCmdTemplate(nIndex);
			
			// If this is the last entry print usage
			if (entry.pRoutine == NULL)
				return PrintUsage();

			// Clean parameter associations from previous iteration (if any)
			CleanParams();

			CGxnString strCommandLine(pwszCommandLine);
			CGxnString strCommandTemplate(entry.wszCmdLine);
			while (true) {
				// Skip spaces
				for(;iswspace(*strCommandLine);strCommandLine++);
				for(;iswspace(*strCommandTemplate);strCommandTemplate++);

				// Extract a name/value pair if possible
				CGxnString name, value;
				if (ExtractVariable(strCommandTemplate, name)) 
				{
					// No match, try with the next template
					if (!ExtractValue(strCommandLine, value))
						break;
						
					AddParam(name, value);
					continue;
				}
				
				// No match, try with the next template
				if (*strCommandTemplate != *strCommandLine)
					break;

				// Eliminate the current matching tokens
				while(*strCommandTemplate == *strCommandLine) {
					// If we reach an end, we just finished
					if ((*strCommandTemplate == L'\0') 
						&& (*strCommandLine == L'\0')) 
					{
						m_nSelectedTemplate = nIndex;
						return true;
					}
					strCommandTemplate++;
					strCommandLine++;
				}
			}
		}
		return false;
	}


	LPWSTR GetStringParam(const WCHAR* wszName)
	{
		if ((wszName[0] != L'<') && (wszName[wcslen(wszName)-1] != L'>') )
			ft.Throw( GXN_DBGINFO, E_UNEXPECTED, L"Invalid name %s\n", wszName);

		// Extract the '<' and '>' suffixes and search into the array
		CGxnString name(wszName + 1, wcslen(wszName) - 2);
		for (INT nIndex = 0; nIndex < m_nParamCount; nIndex++)
			if (wcscmp(name, m_arrNames[nIndex]) == 0)
				return m_arrValues[nIndex];
		ft.Throw( GXN_DBGINFO, E_UNEXPECTED, L"Invalid string param %s\n", wszName);
	}


	// Get a integer value
	INT GetIntParam(const WCHAR* wszName)
	{
		return _wtoi(GetStringParam( wszName ));
	}


	// Get a int64 value
	LONGLONG GetInt64Param(const WCHAR* wszName)
	{
		return _wtoi64(GetStringParam( wszName ));
	}

	// Get a int64 value
	LARGE_INTEGER GetLargeIntParam(const WCHAR* wszName)
	{
		LARGE_INTEGER li;
		li.QuadPart = _wtoi64(GetStringParam( wszName ));
		return li;
	}


	// Get a GUID value
	GUID GetGuidParam(const WCHAR* wszName)
	{
		GUID guid;
		LPWSTR wszString = GetValue(wszName);
		if (FAILED(CLSIDFromString(wszString, &guidValue)))
			ft.Throw( GXN_DBGINFO, E_INVALIDARG, L"Invalid GUID %s for param %s\n", wszString, wszName);
		return guid;
	}

	bool IsOptionPresent(const WCHAR* /*wszName*/)
	{
		return false;
	}

	PRoutine GetCurrentRoutine()  
	{ 
		return GetCmdTemplate(m_nSelectedTemplate).pRoutine; 
	};

	LPWSTR GetCurrentComment()  
	{ 
		return GetCmdTemplate(m_nSelectedTemplate).wszComment; 
	};

	LPWSTR GetCurrentTemplate()  
	{ 
		return GetCmdTemplate(m_nSelectedTemplate).wszCmdLine; 
	};

	void PrintArguments()
	{
		ft.Out(L"\n\nMatching parameters for template '%s':\n", GetCurrentTemplate());
		for(INT nIndex = 0; nIndex < m_nParamCount; nIndex++)
			ft.Out( L"* <%s> = '%s'\n", (LPWSTR)m_arrNames[nIndex], (LPWSTR)m_arrValues[nIndex] );
		if (m_nParamCount == 0)
			ft.Out( L"* (None)\n");
		ft.Out(L"\n");
	}

	bool PrintUsage()
	{
		ft.Out(L"\n\nUsage:\n");
		for (INT nIndex = 0;; nIndex++)
		{
			CmdTemplateEntry & entry = GetCmdTemplate(nIndex);
			if (entry.pRoutine == NULL)
				break;
			ft.Out(L"  * %s:\t%hs %s\n", entry.wszComment, GetAppName(), entry.wszCmdLine);
		}
		ft.Out(L"\n");
		
		return false;	
	}


// Utility methods
private:

	// Extract a variable of the "<name>" format
	bool ExtractVariable(CGxnString & str, CGxnString & name) { 
		if ( *str != L'<')
			return false;
		str++;
		WCHAR* wszEnd = wcschr(str, L'>');
		if (!wszEnd || (str == wszEnd))
			ft.Throw( GXN_DBGINFO, E_INVALIDARG, L"Invalid variable name %s\n", (LPWSTR)str);
		name.CopyFrom( str, wszEnd - str );
		str += (wszEnd - str) + 1; // Skip the L'>' character also
		return true;
	}


	// Extract a value from the current string until we reach a space.
	bool ExtractValue(CGxnString & str, CGxnString & value) { 
		LPWSTR wszEnd = str;

		// Check if we have quota-enclosed parameters
		if (*str == L'"')
		{
			wszEnd = wcschr(str + 1, L'"');
			if (wszEnd == NULL)
				ft.Throw( GXN_DBGINFO, E_INVALIDARG, L"Quota not enclosed at %s\n", (LPWSTR)str);
			value.CopyFrom( str + 1, wszEnd - str - 1 );
			str += (wszEnd-str) + 1;
			return true;
		}
		else 
		{
			// Get the first space or zero terminator
			for(; (*wszEnd) && !iswspace(*wszEnd); wszEnd++);
			if (str == wszEnd)
				return false;

			value.CopyFrom( str, wszEnd - str );
			str += (wszEnd-str);
			return true;
		}
	}

		
	void CleanParams()
	{
		for (INT nIndex = 0; nIndex < m_nParamCount; nIndex++) { 
			m_arrNames[nIndex].Clear();
			m_arrValues[nIndex].Clear();
		}
		m_nParamCount = 0;
	}


	void AddParam(CGxnString & name, CGxnString & value)
	{
		if (m_nParamCount == MAX_PARAMS)
			ft.Throw( GXN_DBGINFO, E_INVALIDARG, L"Too many parameters [%d]\n", m_nParamCount);

		m_arrNames[m_nParamCount].CopyFrom(name);
		m_arrValues[m_nParamCount].CopyFrom(value);
		m_nParamCount++;
	}


// Internal data members
private:
	INT				m_nParamCount;
	CGxnString		m_arrNames[MAX_PARAMS];
	CGxnString		m_arrValues[MAX_PARAMS];
	INT				m_nSelectedTemplate;

protected:
	CTracer			ft;
};




#endif // __CMD_PARSE_HEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\vsst\main.cpp ===
/*
**++
**
** Copyright (c) 2000-2002  Microsoft Corporation
**
**
** Module Name:
**
**	    sec.h
**
** Abstract:
**
**	    Test program for VSS security
**
** Author:
**
**	    Adi Oltean      [aoltean]       02/12/2002
**
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "sec.h"
#include "test_i.c"


///////////////////////////////////////////////////////////////////////////////
// Main functions


// Sample COM server

CComModule _Module;

/*
BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CVssSecTest, CTestCOMServer)
END_OBJECT_MAP()
*/

extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE, LPTSTR , int)
{
    HRESULT hr = S_OK;

    try
	{
        CVssSecurityTest test;

/*
        _Module.Init(ObjectMap, hInstance);
*/
        UNREFERENCED_PARAMETER(hInstance);

        // Initialize internal objects
        test.Initialize();

        // Run the tests
        test.Run();
	}
    catch(HRESULT hr1)
    {
        wprintf(L"\nError catched at program termination: 0x%08lx\n", hr1);
        hr = hr1;
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\vsst\resource.h ===
// Used by sec.rc
//

#ifndef __VSST_RESOURCE_H__
#define __VSST_RESOURCE_H__

#if _MSC_VER > 1000
#pragma once
#endif

#define IDS_SERVICENAME                 100

#define IDR_TEST                        203

#endif // __VSST_RESOURCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\vsst\macros.h ===
///////////////////////////////////////////////////////////////////////////////
// Useful classes, macros 


#define VSS_EVAL(X) X
#define VSS_STRINGIZE_ARG(X) #X
#define VSS_STRINGIZE(X) VSS_EVAL(VSS_STRINGIZE_ARG(X))
#define VSS_MERGE(A, B) A##B
#define VSS_MAKE_W(A) VSS_MERGE(L, A)
#define VSS_WSTRINGIZE(X) VSS_MAKE_W(VSS_STRINGIZE(X))
#define __WFILE__ VSS_MAKE_W(VSS_EVAL(__FILE__))


#define VSS_ERROR_CASE(wszBuffer, dwBufferLen, X) 	\
    case X: ::StringCchCopyW(wszBuffer, dwBufferLen, VSS_MAKE_W(VSS_EVAL(#X)) );  break;

#define WSTR_GUID_FMT  L"{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}"

#define WSTR_DWORD_FMT  L"%c%c%c%c%c%c%c%c.%c%c%c%c%c%c%c%c.%c%c%c%c%c%c%c%c.%c%c%c%c%c%c%c%c"

#define GUID_PRINTF_ARG( X )                          \
    (X).Data1,                                              \
    (X).Data2,                                              \
    (X).Data3,                                              \
    (X).Data4[0], (X).Data4[1], (X).Data4[2], (X).Data4[3], \
    (X).Data4[4], (X).Data4[5], (X).Data4[6], (X).Data4[7]

#define BIT_PRINTF_ARG( X, val )   (((X) & (1 << (val-1)))? L'1': L'0')

#define DWORD_PRINTF_ARG( X )                          												\
	BIT_PRINTF_ARG(X,0x20), BIT_PRINTF_ARG(X,0x1f), BIT_PRINTF_ARG(X,0x1e), BIT_PRINTF_ARG(X,0x1d),	\
	BIT_PRINTF_ARG(X,0x1c), BIT_PRINTF_ARG(X,0x1b), BIT_PRINTF_ARG(X,0x1A), BIT_PRINTF_ARG(X,0x19),	\
	BIT_PRINTF_ARG(X,0x18), BIT_PRINTF_ARG(X,0x17), BIT_PRINTF_ARG(X,0x16), BIT_PRINTF_ARG(X,0x15),	\
	BIT_PRINTF_ARG(X,0x14), BIT_PRINTF_ARG(X,0x13), BIT_PRINTF_ARG(X,0x12), BIT_PRINTF_ARG(X,0x11),	\
	BIT_PRINTF_ARG(X,0x10), BIT_PRINTF_ARG(X,0x0f), BIT_PRINTF_ARG(X,0x0e), BIT_PRINTF_ARG(X,0x0d),	\
	BIT_PRINTF_ARG(X,0x0c), BIT_PRINTF_ARG(X,0x0b), BIT_PRINTF_ARG(X,0x0A), BIT_PRINTF_ARG(X,0x09),	\
	BIT_PRINTF_ARG(X,0x08), BIT_PRINTF_ARG(X,0x07), BIT_PRINTF_ARG(X,0x06), BIT_PRINTF_ARG(X,0x05),	\
	BIT_PRINTF_ARG(X,0x04), BIT_PRINTF_ARG(X,0x03), BIT_PRINTF_ARG(X,0x02), BIT_PRINTF_ARG(X,0x01)

#define CHECK_CONDITION( Cond, FinalCode )                                         \
    {                                                                              \
        if (!(Cond)) {                                                             \
            ft.Msg(L"- ERROR: Condition %S not succeeded. \n", #Cond );            	\
            do { FinalCode } while(0);												\
           	throw(E_UNEXPECTED); 													\
        } else                														\
            ft.Msg(L"- Condition %S succeeded\n", #Cond);                           \
    }

#define CHECK_COM( Call, FinalCode )                                                \
    {                                                                               \
    	HRESULT hr = Call;															\
        if (FAILED(hr)) {                                                           \
            ft.Msg(L"- ERROR: Call %S not succeeded. \n"                   			\
                L"\t  Error Code = 0x%08lx. Error description = %s\n",              \
                #Call, hr,															\
                CVssSecurityTest::GetStringFromFailureType(hr));      				\
            do { FinalCode } while(0);												\
           	throw(hr); 																\
        } else                														\
            ft.Msg(L"- (OK) %S\n", #Call);                                         \
    }


#define CHECK_WIN32( Cond, FinalCode )                                              \
    {                                                                               \
        if (!(Cond)) {                                                              \
            ft.Msg(L"- ERROR: Condition %S not succeeded. \n"                   	\
                L"\t  Error Code = 0x%08lx. Error description = %s\n",              \
                #Cond, HRESULT_FROM_WIN32(GetLastError()),							\
                CVssSecurityTest::GetStringFromFailureType(HRESULT_FROM_WIN32(GetLastError())));      \
            do { FinalCode } while(0);												\
           	throw(HRESULT_FROM_WIN32(GetLastError())); 								\
        } else                														\
            ft.Msg(L"- (OK) %S\n", #Cond);                                         \
    }


#define CHECK_WIN32_FUNC( LValue, Condition, Call, FinalCode )                      \
    {                                                                               \
        LValue = Call;                                                               \
        if (!(Condition)) {                                                              \
            ft.Msg(L"- ERROR: (%S) when %S \n"                   					\
                L"\t  Error Code = 0x%08lx. Error description = %s\n",              \
                #Call, #Condition, HRESULT_FROM_WIN32(GetLastError()),							\
                CVssSecurityTest::GetStringFromFailureType(HRESULT_FROM_WIN32(GetLastError())));      \
            do { FinalCode } while(0);												\
           	throw(HRESULT_FROM_WIN32(GetLastError())); 								\
        } else                														\
            ft.Msg(L"- (OK) %S\n", #Call);                                         \
    }


#define PRINT_ERROR_DELTA( dwError, dwLastError )									\
	if ( dwError == dwLastError ) {} else {											\
            ft.Msg(L"- ERROR: %s = 0x%08lx [%s]. (Previous value 0x%08lx)\n",      \
            	#dwLastError, dwError, 												\
            	CVssSecurityTest::GetStringFromFailureType(HRESULT_FROM_WIN32(GetLastError())),		\
            	dwLastError );														\
           	dwLastError = dwError;													\
		}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\vsst\sec.cpp ===
/*
**++
**
** Copyright (c) 2000-2002  Microsoft Corporation
**
**
** Module Name:
**
**	    sec.cpp
**
**
** Abstract:
**
**	    Security Test program for VSS
**
** Author:
**
**	    Adi Oltean      [aoltean]       02/12/2002
**
**
** Revision History:
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "sec.h"

#include <clusapi.h>
#include <msclus.h>
#include <mstask.h>

#include <ntddsnap.h>

#include "vswriter.h"
#include "vsbackup.h"
#include "vs_reg.hxx"

#include "ntddsnap.h"
#include "vs_clus.hxx"


///////////////////////////////////////////////////////////////////////////////
// Static data


CRITICAL_SECTION CVssSecurityTest::m_csTest;
volatile LONG	 CVssSecurityTest::m_lTestCounter = 0;




///////////////////////////////////////////////////////////////////////////////
// Processing functions

// Run the tests
void CVssSecurityTest::Run()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::Run");
        
    ft.Msg(L"\n--------------- %s ------------\n", GetCurrentComment());
    
    // Execute selected routine
    BS_ASSERT(GetCurrentRoutine());
    (this->*GetCurrentRoutine())();

    ft.Msg(L"\n-------------------------------------------------\n");
}


// Lookup name
void CVssSecurityTest::TestLookupName()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::TestLookupName");
        
    BYTE pbSid[SECURITY_MAX_SID_SIZE];
    PSID pSid = (PSID)pbSid;
    WCHAR wszDomainName[MAX_TEXT_BUFFER];
    SID_NAME_USE snUse;
    
    DWORD cbSid = 0;
    DWORD dwDomainNameSize = 0;
    LookupAccountName( NULL, GetStringParam(L"<name>"),
        pSid, &cbSid,
        wszDomainName, &dwDomainNameSize,
        &snUse);

    ft.Msg( L"* cbSid = %ld, cbDomain = %ld, error = %ld\n", cbSid, dwDomainNameSize, GetLastError() );
    
    cbSid = SECURITY_MAX_SID_SIZE;
    dwDomainNameSize = MAX_TEXT_BUFFER;
    CHECK_WIN32( LookupAccountName( NULL, GetStringParam(L"<name>"),
        pSid, &cbSid,
        wszDomainName, &dwDomainNameSize,
        &snUse), 
        ;
    );

    LPWSTR pwszStringSid = NULL;
    CHECK_WIN32( ConvertSidToStringSid( pSid, &pwszStringSid), ;);

    ft.Msg( L"* Sid: %s, Domain Name: %s, SidUse: %d\n", pwszStringSid, wszDomainName, snUse );

    // Now go back and recompute the name

    WCHAR wszName[MAX_TEXT_BUFFER];
    DWORD dwNameSize = MAX_TEXT_BUFFER;
    dwDomainNameSize = MAX_TEXT_BUFFER;
    CHECK_WIN32( LookupAccountSid( NULL, pSid, 
        wszName, &dwNameSize, 
        wszDomainName, &dwDomainNameSize,
        &snUse), 
        LocalFree(pwszStringSid);
    );

    ft.Msg( L"* Name: %s, Domain Name: %s, SidUse: %d\n", wszName, wszDomainName, snUse );
    
    LocalFree(pwszStringSid);
}


// Lookup SID
void CVssSecurityTest::TestLookupSid()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::TestLookupSid");
        
    PSID pSid = NULL;
    CHECK_WIN32( ConvertStringSidToSid( GetStringParam(L"<sid>"), &pSid) , ;);

    WCHAR wszName[MAX_TEXT_BUFFER];
    DWORD dwNameSize = MAX_TEXT_BUFFER;
    WCHAR wszDomainName[MAX_TEXT_BUFFER];
    DWORD dwDomainNameSize = MAX_TEXT_BUFFER;
    SID_NAME_USE snUse;
    CHECK_WIN32( LookupAccountSid( NULL, pSid, 
        wszName, &dwNameSize, 
        wszDomainName, &dwDomainNameSize,
        &snUse), 
        LocalFree(pSid); 
    );

    ft.Msg( L"* Name: %s, Domain Name: %s, SidUse: %d\n", wszName, wszDomainName, snUse );

    LocalFree(pSid);
}


// Lookup Names
void CVssSecurityTest::TestLookupPrimaryDomainName()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::TestLookupPrimaryDomainName");
        
    // Also get the computer domain
    WCHAR wszDomainName[MAX_TEXT_BUFFER];
    DWORD dwDomainNameLen = MAX_TEXT_BUFFER;
    CHECK_WIN32( GetComputerNameExW( 
        ComputerNamePhysicalDnsDomain,
//        ComputerNameDnsDomain,
        wszDomainName, 
        &dwDomainNameLen), ;);

    ft.Msg( L"* Domain DNS Name for the local computer: %s\n", wszDomainName );
    
    BYTE pbSid[SECURITY_MAX_SID_SIZE];
    DWORD dwSidSize = SECURITY_MAX_SID_SIZE;
    PSID pSid = (PSID)pbSid;
    WCHAR wszReturnedDomainName[MAX_TEXT_BUFFER];
    DWORD dwReturnedDomainNameSize = MAX_TEXT_BUFFER;
    SID_NAME_USE snUse;
    CHECK_WIN32( LookupAccountName( NULL, 
        wszDomainName,
        pSid, 
        &dwSidSize,
        wszReturnedDomainName, 
        &dwReturnedDomainNameSize,
        &snUse), 
        ;
    );

    ft.Msg( L"* LookupAccountName returns Domain Name: %s, SidInuse: %d\n", 
        wszReturnedDomainName, snUse );

    LPWSTR pwszAccountName = NULL;
    CHECK_WIN32( ConvertSidToStringSid( pSid, &pwszAccountName) , ;);

    ft.Msg( L"* ConvertSidToSidString returns %s\n", 
        pwszAccountName );

    LocalFree( pwszAccountName );

    BYTE pbByte2[SECURITY_MAX_SID_SIZE];
    PSID pSid2 = (PSID)pbByte2;
    DWORD dwSid2Length = SECURITY_MAX_SID_SIZE;
    CHECK_WIN32( CreateWellKnownSid( WinAccountComputersSid, 
        pSid, 
        pSid2, 
        &dwSid2Length
        ),
        ;
    );
    
    LPWSTR pwszAccountName2 = NULL;
    CHECK_WIN32( ConvertSidToStringSid( pSid2, &pwszAccountName2) , ;);

    ft.Msg( L"* ConvertSidToSidString returns %s\n", 
        pwszAccountName2 );

    LocalFree( pwszAccountName2 );
}


// Lookup Names for all trusted domains
void CVssSecurityTest::TestLookupTrustedName()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::TestLookupTrustedName");
        
    PDOMAIN_CONTROLLER_INFO pDomainInfo = NULL;
    CHECK_WIN32( 
        DsGetDcName( NULL, 
            NULL,
            NULL,
            NULL,
            0,
        &pDomainInfo),
        ;
    );

    PDS_DOMAIN_TRUSTS pDomains = NULL;
    ULONG ulDomainCount = 0;
    CHECK_WIN32( 
        DsEnumerateDomainTrusts( pDomainInfo->DomainControllerName, 
            DS_DOMAIN_IN_FOREST,
            &pDomains,
            &ulDomainCount),
        NetApiBufferFree(pDomainInfo);
    );

    NetApiBufferFree(pDomainInfo);

    for (ULONG ulIndex = 0; ulIndex < ulDomainCount; ulIndex++)
    {
        ft.Msg( L"* Domain: %s, ", pDomains[ulIndex].DnsDomainName );

        LPWSTR pwszSidName = NULL;
        CHECK_WIN32( ConvertSidToStringSid( pDomains[ulIndex].DomainSid, 
            &pwszSidName), 
            NetApiBufferFree(pDomains);
        );

        ft.Msg( L"SID: %s, ", pwszSidName );
        
        LocalFree( pwszSidName );

        BYTE pbByte2[SECURITY_MAX_SID_SIZE];
        PSID pSid2 = (PSID)pbByte2;
        DWORD dwSid2Length = SECURITY_MAX_SID_SIZE;
        CHECK_WIN32( CreateWellKnownSid( WinAccountComputersSid, 
            pDomains[ulIndex].DomainSid, 
            pSid2, 
            &dwSid2Length
            ),
            NetApiBufferFree(pDomains);
        );

        CHECK_WIN32( ConvertSidToStringSid( pSid2, &pwszSidName),
            NetApiBufferFree(pDomains);
        );
        
        ft.Msg( L"DM SID: %s\n", pwszSidName );
        
        LocalFree( pwszSidName );
    }

    NetApiBufferFree(pDomains);
}



// Lookup Names for all trusted domains
void CVssSecurityTest::TestLookupGroupMembers()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::TestLookupGroupMembers");
        
    // get list of local group members
    CVssAutoNetApiPtr apBuffer;
    DWORD_PTR ResumeHandle = NULL;
    DWORD cEntriesRead = 0, cEntriesTotal = 0;
    NET_API_STATUS status = 0;
    CHECK_WIN32_FUNC(status, status == NERR_Success, 
        NetLocalGroupGetMembers(
            NULL,
            GetStringParam(L"<group>"),
            1,
            apBuffer.ResetAndGetAddress(),
            MAX_PREFERRED_LENGTH,
            &cEntriesRead,
            &cEntriesTotal,
            &ResumeHandle
            ),
        ;
    );

    // loop through member list to see if any sids mach the sid of the owner
    // of the subscription
    LOCALGROUP_MEMBERS_INFO_1 *rgMembers = (LOCALGROUP_MEMBERS_INFO_1 *) apBuffer.Get();
    for(DWORD iEntry = 0; iEntry < cEntriesRead; iEntry++)
    {
        CVssAutoLocalPtr<LPWSTR> pwszStringSid;
        CHECK_WIN32( ConvertSidToStringSid( 
            rgMembers[iEntry].lgrmi1_sid, pwszStringSid.ResetAndGetAddress()), ;);
        
        ft.Msg(L"* Name = %s, Use = %ld, Sid = %s\n", 
            rgMembers[iEntry].lgrmi1_name,
            (LONG)rgMembers[iEntry].lgrmi1_sidusage,
            pwszStringSid.Get()
        );
    }
}


// Lookup Names for all trusted domains
void CVssSecurityTest::IsAllowedToFire()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::IsAllowedToFire");

    try
    {
        CVssSidCollection sidColl;

        sidColl.Initialize();

        BYTE pbSid[SECURITY_MAX_SID_SIZE];
        PSID pSid = (PSID)pbSid;
        WCHAR wszDomainName[MAX_TEXT_BUFFER];
        SID_NAME_USE snUse;
        
        DWORD cbSid = 0;
        DWORD dwDomainNameSize = 0;
        LookupAccountName( NULL, GetStringParam(L"<name>"),
            pSid, &cbSid,
            wszDomainName, &dwDomainNameSize,
            &snUse);

        ft.Msg( L"* cbSid = %ld, cbDomain = %ld, error = %ld\n", cbSid, dwDomainNameSize, GetLastError() );
        
        cbSid = SECURITY_MAX_SID_SIZE;
        dwDomainNameSize = MAX_TEXT_BUFFER;
        CHECK_WIN32( LookupAccountName( NULL, GetStringParam(L"<name>"),
            pSid, &cbSid,
            wszDomainName, &dwDomainNameSize,
            &snUse), 
            ;
        );

        CVssAutoLocalPtr<LPWSTR> pwszStringSid;
        CHECK_WIN32( ConvertSidToStringSid( pSid, pwszStringSid.ResetAndGetAddress()), ;);

        ft.Msg( L"* Sid: %s, Domain Name: %s, SidUse: %d\n", pwszStringSid.Get(), wszDomainName, snUse );

        bool bAllowed = sidColl.IsSidAllowedToFire(pSid);

        ft.Msg( L"* IsAllowed: %s\n", bAllowed? L"TRUE": L"FALSE" );
        
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
 
}





// Lookup Names for all trusted domains
void CVssSecurityTest::WriteRegistry()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::WriteRegistry");

#if 0
    try
    {
        CVssDiag test;

        test.Initialize(L"TEST");

        INT nCount = GetIntParam(L"<max_iterations>");
        GUID guidSnapshotSetID = GUID_NULL;
        for(INT nIterations = 0; nIterations < nCount; nIterations++)
        {
            for(INT nIndex = VSS_IN_IDENTIFY; nIndex < VSS_IN_COUNT; nIndex++)
            {
                test.RecordWriterEvent((VSS_OPERATION)nIndex, 0, 0, S_OK, guidSnapshotSetID);
            }
        }
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
#endif 
}


void CVssSecurityTest::DoQuerySnapshots()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::DoQuerySnapshots");

    try
    {
        QuerySnapshots();
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
}


void CVssSecurityTest::DoQueryProviders()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::DoQueryProviders");

    try
    {
        QueryProviders();
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
}


#include "sample.cpp"


void CVssSecurityTest::DoFsctlDismount()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::DoFsctlDismount");

    try
    {
        //  Open the snapshot with no access rights for perf reasons (bug #537974)
        LPWSTR pwszDevice = GetStringParam(L"<device>");

		HANDLE hDevice;
        CHECK_WIN32_FUNC(
            hDevice,
			hDevice != INVALID_HANDLE_VALUE,
		    CreateFile(pwszDevice,
						GENERIC_READ | GENERIC_WRITE,
						FILE_SHARE_READ | FILE_SHARE_WRITE,
						NULL,
						OPEN_EXISTING,
						FILE_ATTRIBUTE_NORMAL,
						INVALID_HANDLE_VALUE),
			;
            );
			
        CHECK_WIN32(
		    DeviceIoControl(hDevice, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0, NULL, NULL),
			CloseHandle(hDevice);
            );

		CloseHandle(hDevice);
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
}




void CVssSecurityTest::DisplayMessage()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::DisplayMessage");

    try
    {
        DWORD dwMessageID = GetIntParam(L"<MessageID>");

        HMODULE hModule = NULL; // default to system source
        LPWSTR pwszMessageBuffer;
        DWORD dwBufferLength;

        DWORD dwFormatFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_IGNORE_INSERTS |
            FORMAT_MESSAGE_FROM_SYSTEM ;

        // Load the file

        hModule = LoadLibraryExW(
            GetStringParam(L"<File>"),
            NULL,
            LOAD_LIBRARY_AS_DATAFILE
            );

        if(hModule != NULL)
            dwFormatFlags |= FORMAT_MESSAGE_FROM_HMODULE;

        dwBufferLength = FormatMessageW(
            dwFormatFlags,
            hModule, // module to get message from (NULL == system)
            dwMessageID,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // default language
            (LPWSTR) &pwszMessageBuffer,
            0,
            NULL
            );

        if (dwBufferLength)
        {
            ft.Msg(L"Message: %s for ID\n", pwszMessageBuffer);

            //
            // Free the buffer allocated by the system.
            //
            LocalFree(pwszMessageBuffer);
        }

        //
        // If we loaded a message source, unload it.
        //
        if(hModule != NULL)
            FreeLibrary(hModule);
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
}


// add cluster dependency
void CVssSecurityTest::AddDependency()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::AddDependency");

    try
    {
        CVssClusterAPI clus;

        if (!clus.Initialize())
        {
            ft.Msg( L"Cluster initialization failed\n" );
            ft.Throw( VSSDBG_VSSTEST, S_FALSE, L"Cluster initialization failed\n" );
        }
        
        clus.AddDependency(GetStringParam(L"<name1>"), GetStringParam(L"<name2>"));

        ft.Msg( L"* Depoendency was sucesfully added!" );
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
 
}


// remove cluster dependency
void CVssSecurityTest::RemoveDependency()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::RemoveDependency");

    try
    {
        CVssClusterAPI clus;

        if (!clus.Initialize())
        {
            ft.Msg( L"Cluster initialization failed\n" );
            ft.Throw( VSSDBG_VSSTEST, S_FALSE, L"Cluster initialization failed\n" );
        }
        
        clus.RemoveDependency(GetStringParam(L"<name1>"), GetStringParam(L"<name2>"));

        ft.Msg( L"* Dependency was sucesfully removed!" );
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
 
}


// add registry key
void CVssSecurityTest::AddRegKey()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::AddRegKey");

    try
    {
        CVssClusterAPI clus;

        if (!clus.Initialize())
        {
            ft.Msg( L"Cluster initialization failed\n" );
            ft.Throw( VSSDBG_VSSTEST, S_FALSE, L"Cluster initialization failed\n" );
        }
        
        clus.AddRegistryKey(GetStringParam(L"<name>"), GetStringParam(L"<reg_key>"));

        ft.Msg( L"* Reg key was sucesfully added!" );
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
 
}


// remove registry key
void CVssSecurityTest::RemoveRegKey()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::RemoveRegKey");

    try
    {
        CVssClusterAPI clus;

        if (!clus.Initialize())
        {
            ft.Msg( L"Cluster initialization failed\n" );
            ft.Throw( VSSDBG_VSSTEST, S_FALSE, L"Cluster initialization failed\n" );
        }

        clus.RemoveRegistryKey(GetStringParam(L"<name>"), GetStringParam(L"<reg_key>"));

        ft.Msg( L"* Reg key was sucesfully removed!" );
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
}


// add scheduled task
void CVssSecurityTest::AddTask()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::AddTask");

    try
    {
        CVssClusterAPI clus;

        if (!clus.Initialize())
        {
            ft.Msg( L"Cluster initialization failed\n" );
            ft.Throw( VSSDBG_VSSTEST, S_FALSE, L"Cluster initialization failed\n" );
        }

        SYSTEMTIME st = {0};
        GetSystemTime(&st);

        WORD wStartHours = 7;

        TASK_TRIGGER Trigger;
        ZeroMemory(&Trigger, sizeof(TASK_TRIGGER));
        Trigger.wBeginDay =st.wDay;
        Trigger.wBeginMonth =st.wMonth;
        Trigger.wBeginYear =st.wYear;
        Trigger.cbTriggerSize = sizeof(TASK_TRIGGER); 
        Trigger.wStartHour = wStartHours;
        Trigger.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
        Trigger.Type.Weekly.WeeksInterval = 1;
        Trigger.Type.Weekly.rgfDaysOfTheWeek = TASK_MONDAY | TASK_TUESDAY | TASK_WEDNESDAY | TASK_THURSDAY | TASK_FRIDAY;

        ft.Msg( L"Adding a %d TASK_TRIGGER structure...", sizeof(TASK_TRIGGER));

        CVssAutoPWSZ awszResource;
        bool bRet = clus.CreateTaskSchedulerResource(
            GetStringParam(L"<task_name>"), 
            GetStringParam(L"<app_name>"),
            GetStringParam(L"<app_params>"),
            1,
            &Trigger,
            GetStringParam(L"<volume>")
            );

        ft.Msg( L"* Task was sucesfully created! [Return code:%s Resource:%s]",
            bRet? L"TRUE": L"FALSE", 
            GetStringParam(L"<task_name>") );
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
}


// Update scheduled task
void CVssSecurityTest::UpdateTask()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::UpdateTask");

    try
    {
        CVssClusterAPI clus;

        if (!clus.Initialize())
        {
            ft.Msg( L"Cluster initialization failed\n" );
            ft.Throw( VSSDBG_VSSTEST, S_FALSE, L"Cluster initialization failed\n" );
        }

        SYSTEMTIME st = {0};
        GetSystemTime(&st);

        WORD wStartHours = 12;

        TASK_TRIGGER Trigger;
        ZeroMemory(&Trigger, sizeof(TASK_TRIGGER));
        Trigger.wBeginDay =st.wDay;
        Trigger.wBeginMonth =st.wMonth;
        Trigger.wBeginYear =st.wYear;
        Trigger.cbTriggerSize = sizeof(TASK_TRIGGER); 
        Trigger.wStartHour = wStartHours;
        Trigger.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
        Trigger.Type.Weekly.WeeksInterval = 1;
        Trigger.Type.Weekly.rgfDaysOfTheWeek = TASK_MONDAY | TASK_TUESDAY | TASK_WEDNESDAY | TASK_THURSDAY | TASK_FRIDAY;

        ft.Msg( L"Upgrading a %d TASK_TRIGGER structure...", sizeof(TASK_TRIGGER));

        bool bRet = clus.UpdateTaskSchedulerResource(
            GetStringParam(L"<resource_name>"), 
            1,
            &Trigger
            );

        ft.Msg( L"* Task was sucesfully updated! [Return code:%s]",
            bRet? L"TRUE": L"FALSE");
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
}


// Update scheduled task
void CVssSecurityTest::RemoveTask()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::RemoveTask");

    try
    {
        CVssClusterAPI clus;

        if (!clus.Initialize())
        {
            ft.Msg( L"Cluster initialization failed\n" );
            ft.Throw( VSSDBG_VSSTEST, S_FALSE, L"Cluster initialization failed\n" );
        }

        bool bRet = clus.DeleteTaskSchedulerResource(
            GetStringParam(L"<resource_name>")
            );

        ft.Msg( L"* Task was sucesfully deleted! [Return code:%s]",
            bRet? L"TRUE": L"FALSE");
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
}


// Display a COM security descriptor
void CVssSecurityTest::DisplaySD()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::DisplaySD");

    try
    {
        CVssSidCollection scoll;

        scoll.Initialize();

        PSECURITY_DESCRIPTOR pSD = scoll.GetSecurityDescriptor();

        CVssAutoLocalString szSD;

        CHECK_WIN32(ConvertSecurityDescriptorToStringSecurityDescriptor(
            pSD, SDDL_REVISION_1, 
            OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION,
            szSD.ResetAndGetAddress(), NULL), );

        ft.Msg( L" Security descriptor:\n%s\n", szSD.Get() );
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
}



void CVssSecurityTest::GetVolumePath()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::DisplaySD");
    
    try
    {
        WCHAR wszVolume[MAX_PATH + 1];
        CHECK_WIN32(GetVolumePathNameW( GetStringParam(L"<path>"), STRING_CCH_PARAM(wszVolume)), )
            
        ft.Msg( L"Returned volume: %s\n", wszVolume);
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
}


// Display quorum volume
void CVssSecurityTest::DisplayQuorumVolume()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::DisplayQuorumVolume");

    try
    {
        INT nIterations = GetIntParam(L"<iterations>");
        for (INT nIndex = 0; nIndex < nIterations; nIndex++)
        {
            CVssClusterAPI clus;

            if (!clus.Initialize())
            {
                ft.Msg( L"Cluster initialization failed\n" );
                ft.Throw( VSSDBG_VSSTEST, S_FALSE, L"Cluster initialization failed\n" );
            }

            CComBSTR szVolumeName;
            clus.GetQuorumPath(szVolumeName);

            ft.Msg( L"* Quorum volume: %s",
                (LPWSTR)szVolumeName);
        }
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
}


// Get a volume name
void CVssSecurityTest::GetVolumeName()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::GetVolumeName");

    try
    {
        LPWSTR pwszVolume = GetStringParam(L"<volume>");

        WCHAR wszVolumeName[MAX_PATH];
        CHECK_WIN32(GetVolumeNameForVolumeMountPointW( pwszVolume, STRING_CCH_PARAM(wszVolumeName)), );

        ft.Msg(L"* Volume Name: %s\n", wszVolumeName);
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
}


// Create a object with a given CLSID
void CVssSecurityTest::CoCreateInstance()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::CoCreateInstance");

    try
    {
        LPWSTR pwszGuid = GetStringParam(L"<clsid>");

        CVssID clsid;
        clsid.Initialize(ft, pwszGuid);
        
        CComPtr<IUnknown> ptrUnk;
        CHECK_COM(::CoGetClassObject(clsid, CLSCTX_ALL, NULL, IID_IClassFactory, (void**)&ptrUnk), );

        ft.Msg(L"* Instance created.\n");
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Msg(L"Error catched 0x%08lx\n", ft.hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\vsst\sec.h ===
/*
**++
**
** Copyright (c) 2000-2002  Microsoft Corporation
**
**
** Module Name:
**
**	    sec.h
**
**
** Abstract:
**
**	    Test program for VSS security
**
** Author:
**
**	    Adi Oltean      [aoltean]       02/12/2002
**
** Revision History:
**
**--
*/

#ifndef __VSS_SEC_HEADER_H__
#define __VSS_SEC_HEADER_H__

#if _MSC_VER > 1000
#pragma once
#endif




/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'class' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/

// Disable warning: 'identifier' : identifier was truncated to 'number' characters in the debug information
//#pragma warning(disable:4786)

//
// C4290: C++ Exception Specification ignored
//
#pragma warning(disable:4290)

//
// C4511: copy constructor could not be generated
//
#pragma warning(disable:4511)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <windows.h>
#include <wtypes.h>
#pragma warning( disable: 4201 )    // C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning( default: 4201 )	// C4201: nonstandard extension used : nameless struct/union
#include <winbase.h>
#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stddef.h>
#include <stdlib.h>
#include <errno.h>
#include <time.h>
#include <string.h>
#include <sddl.h>
#include <lm.h>
#include <dsgetdc.h>
#include <mstask.h>

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"


#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


#include <oleauto.h>
#include <stddef.h>
#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
//#include <atlconv.h>
#include <atlbase.h>


#include "resource.h"




extern CComModule  _Module;
#include <atlcom.h>

#include "macros.h"
#include "test.h"
#include "cmdparse.h"

#include "vs_inc.hxx"
#include "vs_sec.hxx"

///////////////////////////////////////////////////////////////////////////////
// Constants

const MAX_TEXT_BUFFER   = 512;
const VSS_SEED = 1234;
const MAX_ARGS = 40;



///////////////////////////////////////////////////////////////////////////////
// Main class


class CVssSecurityTest: public CGxnCmdLineParser<CVssSecurityTest>
{
    
// Constructors& destructors
private:
    CVssSecurityTest(const CVssSecurityTest&);
    
public:
    CVssSecurityTest();

    ~CVssSecurityTest();

// Main routines
public:

    // Initialize internal members
    void Initialize();

    // Run the test
    void Run();

// Internal tests
public:

	void TestLookupName();
	void TestLookupSid();
	void TestLookupPrimaryDomainName();
	void TestLookupTrustedName();
	void TestLookupGroupMembers();
	void IsAllowedToFire();
	void WriteRegistry();
	void DoQuerySnapshots();
	void DoQueryProviders();
	void DoFsctlDismount();
	void DisplayMessage();
	void AddDependency();
	void RemoveDependency();
	void AddRegKey();
	void RemoveRegKey();
	void AddTask();
	void UpdateTask();
	void RemoveTask();
	void DisplaySD();
	void GetVolumePath();
	void DisplayQuorumVolume();
	void GetVolumeName();
	void CoCreateInstance();
	
// Command line processing
public:

	BEGIN_CMD_PARSER(VSST)
		CMD_ENTRY(TestLookupName, L"-ln <name>", L"Lookup for an account name")
		CMD_ENTRY(TestLookupSid, L"-ls <sid>", L"Lookup for SID")
		CMD_ENTRY(TestLookupPrimaryDomainName, L"-lpdn", L"Lookup for primary domain name")
		CMD_ENTRY(TestLookupTrustedName, L"-lt", L"Lookup for trusted names")
		CMD_ENTRY(TestLookupGroupMembers, L"-gm  <group>", L"Lookup for group members")
		CMD_ENTRY(IsAllowedToFire, L"-af <name>", L"Check if hte account is allowed to fire")
		CMD_ENTRY(WriteRegistry, L"-wr <max_iterations>", L"Write diag keys <max_iterations> times")
		CMD_ENTRY(DoQuerySnapshots, L"-qs", L"Query snapshots sample code")
		CMD_ENTRY(DoQueryProviders, L"-qp", L"Query providers sample code")
		CMD_ENTRY(DoFsctlDismount, L"-dismount <device>", L"Sends a FSCTL_DISMOUNT_VOLUME to the device")
		CMD_ENTRY(DisplayMessage, L"-msg <MessageID> <File>", L"Prints the message from this file")
		CMD_ENTRY(AddDependency, L"-cad <name1> <name2>", L"Add a cluster dependency")
		CMD_ENTRY(RemoveDependency, L"-crd <name1> <name2>", L"Remove a cluster dependency")
		CMD_ENTRY(AddRegKey, L"-car <name> <reg_key>", L"Add a reg key to a disk")
		CMD_ENTRY(RemoveRegKey, L"-crr <name> <reg_key>", L"Remove a reg key from a disk")
		CMD_ENTRY(AddTask, L"-cat <task_name> <app_name> <app_params> <volume>", L"Add a task")
		CMD_ENTRY(UpdateTask, L"-cut <resource_name>", L"Update the task")
		CMD_ENTRY(RemoveTask, L"-crt <resource_name>", L"Remove the task")
		CMD_ENTRY(DisplaySD, L"-dsd", L"Display the current writer security descriptor")
		CMD_ENTRY(GetVolumePath, L"-vol <path>", L"Display the volume that contains the path")
		CMD_ENTRY(DisplayQuorumVolume, L"-quorum <iterations>", L"Display the quorum volume N times")
		CMD_ENTRY(GetVolumeName, L"-volname <volume>", L"Display the volume name for this mount point")
		CMD_ENTRY(CoCreateInstance, L"-clsid <clsid>", L"Creates an object using the given CLSID")
	END_CMD_PARSER

// Utility methods:
public:
    static LPCWSTR GetStringFromFailureType(HRESULT hrStatus);
	static BOOL IsAdmin();
	static DWORD WINAPI ThreadRoutine(LPVOID);
	
// Private data members
private:
    bool                        m_bCoInitializeSucceeded;
	static CRITICAL_SECTION 	m_csTest;
	static volatile LONG		m_lTestCounter;
};


HRESULT QuerySnapshots();
HRESULT QueryProviders();
HRESULT IsAdministrator2();


/*

// Sample COM server
class CTestCOMServer: 
    public CComObjectRoot,
//    public CComCoClass<CTestCOMServer, &CLSID_CRssSecTest>,
	public CComCoClass<CTestCOMServer, &CLSID_CFsaRecallNotifyClient>,
    public IFsaRecallNotifyClient
{
public:
	
	DECLARE_REGISTRY_RESOURCEID(IDR_TEST)

	DECLARE_NOT_AGGREGATABLE(CTestCOMServer)

	BEGIN_COM_MAP(CTestCOMServer)
		COM_INTERFACE_ENTRY(IRssSecTest)
		COM_INTERFACE_ENTRY(IFsaRecallNotifyClient)
	END_COM_MAP()


    // ITest interface
    STDMETHOD(Test)();

	// IFsaRecallNotifyClient interface
    STDMETHOD(IdentifyWithServer)( IN OLECHAR * szServerName );

protected:
	CGxnTracer		ft;
};  

*/


#endif // __VSS_SEC_HEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\vsst\sample.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2000-2002  Microsoft Corporation
//



///////////////////////////////////////////////////////////////////////////////
// Includes


#include <stdio.h>
#include <atlbase.h>

#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>


#define GUID_FMT  L"{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}"

#define GUID_PRINTF_ARG( X )                                \
    (X).Data1,                                              \
    (X).Data2,                                              \
    (X).Data3,                                              \
    (X).Data4[0], (X).Data4[1], (X).Data4[2], (X).Data4[3], \
    (X).Data4[4], (X).Data4[5], (X).Data4[6], (X).Data4[7]


///////////////////////////////////////////////////////////////////////////////
// Implementation



HRESULT QuerySnapshots()
{
	HRESULT hr;
	
	//Create a BackupComponents Interface
    CComPtr<IVssBackupComponents> pBackupComp;
	hr = CreateVssBackupComponents(&pBackupComp);
    if (FAILED(hr)){
		wprintf(L"CreateVssBackupComponents failed [0x%08lx]\n", hr);
		return (hr);
    }

    // Initialize the backup component instance
	hr = pBackupComp->InitializeForBackup();
    if (FAILED(hr)){
		wprintf(L"IVssBackupComponents::InitializeForBackup failed [0x%08lx]\n", hr);
		return (hr);
    }

    // Query all snapshots in the system
	hr = pBackupComp->SetContext(VSS_CTX_ALL);
    if (FAILED(hr)){
		wprintf(L"IVssBackupComponents::InitializeForBackup failed [0x%08lx]\n", hr);
		return (hr);
    }

    // Get list all snapshots
    CComPtr<IVssEnumObject> pIEnumSnapshots;
	hr = pBackupComp->Query( GUID_NULL, 
			VSS_OBJECT_NONE, 
			VSS_OBJECT_SNAPSHOT, 
			&pIEnumSnapshots );
    if (FAILED(hr)){
		wprintf(L"IVssBackupComponents::Query failed [0x%08lx]\n", hr);
		return (hr);
    }

	// For all snapshots do...
    VSS_OBJECT_PROP Prop;
    VSS_SNAPSHOT_PROP& Snap = Prop.Obj.Snap;
    for(;;) {
		// Get next element
		ULONG ulFetched;
		hr = pIEnumSnapshots->Next( 1, &Prop, &ulFetched );
	
		//Case where we reached the end of list
		if (hr == S_FALSE)
			break;

		if (hr != S_OK) {
			wprintf(L"IVssEnumObject::Next failed [0x%08lx]\n", hr);
			return(hr);
		}
	  
		//print results
		wprintf(L"* ShadowID: " GUID_FMT L"\n"
    		L"  Attributes: [0x%08lx]\n"
		    L"  ShadowSetID: "  GUID_FMT L"\n"
		    L"  Volume: %s \n"
		    L"  Device: %s \n\n",
			GUID_PRINTF_ARG(Snap.m_SnapshotId), 
			Snap.m_lSnapshotAttributes,
			GUID_PRINTF_ARG(Snap.m_SnapshotSetId),
			Snap.m_pwszOriginalVolumeName,
			Snap.m_pwszSnapshotDeviceObject
			);

		 // Free up memory returned by COM
		 ::VssFreeSnapshotProperties(&Snap);
    }

	return(S_OK);
}

HRESULT QueryProviders()
{
	HRESULT hr;
	
	//Create a BackupComponents Interface
    CComPtr<IVssBackupComponents> pBackupComp;
	hr = CreateVssBackupComponents(&pBackupComp);
    if (FAILED(hr)){
		wprintf(L"CreateVssBackupComponents failed [0x%08lx]\n", hr);
		return (hr);
    }

    // Initialize the backup component instance
	hr = pBackupComp->InitializeForBackup();
    if (FAILED(hr)){
		wprintf(L"IVssBackupComponents::InitializeForBackup failed [0x%08lx]\n", hr);
		return (hr);
    }

    // Get list all snapshots
    CComPtr<IVssEnumObject> pIEnumProviders;
	hr = pBackupComp->Query( GUID_NULL, 
			VSS_OBJECT_NONE, 
			VSS_OBJECT_PROVIDER, 
			&pIEnumProviders );
    if (FAILED(hr)){
		wprintf(L"IVssBackupComponents::Query failed [0x%08lx]\n", hr);
		return (hr);
    }

	// For all providers do...
    VSS_OBJECT_PROP Prop;
    VSS_PROVIDER_PROP& Prov = Prop.Obj.Prov;
    for(;;) {
		// Get next element
		ULONG ulFetched;
		hr = pIEnumProviders->Next( 1, &Prop, &ulFetched );
	
		//Case where we reached the end of list
		if (hr == S_FALSE)
			break;

		if (hr != S_OK) {
			wprintf(L"IVssEnumObject::Next failed [0x%08lx]\n", hr);
			return(hr);
		}

		wprintf(L"* ProviderID: " GUID_FMT L"\n"
		    L"  Type: [0x%08lx]\n"
		    L"  Name: %s \n"
		    L"  Version: %s \n"
		    L"  CLSID: " GUID_FMT L"\n\n",
			GUID_PRINTF_ARG(Prov.m_ProviderId), 
			(LONG) Prov.m_eProviderType,
			Prov.m_pwszProviderName,
			Prov.m_pwszProviderVersion,
			GUID_PRINTF_ARG(Prov.m_ClassId)
			);

		// Free up memory returned by COM
		::CoTaskMemFree(Prov.m_pwszProviderName);
		::CoTaskMemFree(Prov.m_pwszProviderVersion);
    }

	return(S_OK);
}



// Returns:
// - S_OK if the COM client is a local Administrator
// - E_ACCESSDENIED if the COM client is not an Administrator
// - E_OUTOFMEMORY on memory errors
HRESULT IsAdministrator2() 
{
    // Impersonate the client
    HRESULT hr = CoImpersonateClient();
    if (hr != S_OK) 
    {
        return E_ACCESSDENIED;
    }

    // Get the impersonation token
    HANDLE hToken = NULL;
    if (!OpenThreadToken(GetCurrentThread(),
        TOKEN_QUERY, TRUE, &hToken))
    {
        return E_ACCESSDENIED;
    }

    // Revert to self
    hr = CoRevertToSelf();
    if (FAILED(hr)) 
    {
        CloseHandle(hToken);
        return E_ACCESSDENIED;
    }

    //  Build the SID for the Administrators group
    PSID psidAdmin = NULL;
    SID_IDENTIFIER_AUTHORITY SidAuth = SECURITY_NT_AUTHORITY;
    if (!AllocateAndInitializeSid
            (
            &SidAuth,
            2, 
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psidAdmin))
    {
        CloseHandle(hToken);
        return E_OUTOFMEMORY;
    }

    // Check the token membership
    BOOL bIsAdmin = FALSE;
    if (!CheckTokenMembership(hToken, psidAdmin, &bIsAdmin))
    {
        FreeSid( psidAdmin );
        CloseHandle(hToken);
        return E_ACCESSDENIED;
    }

    // Release resources
    FreeSid( psidAdmin );
    CloseHandle(hToken);

    // Verify if the client is administrator
    if (!bIsAdmin)
        return E_ACCESSDENIED;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\writer\main.h ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	    main.h
**
**
** Abstract:
**
**	Test program to to register a Writer with various properties
**
** Author:
**
**	Reuven Lax      [reuvenl]       04-June-2002
**
**
**
** Revision History:
**
**--
*/

#ifndef _MAIN_H_
#define _MAIN_H_

extern "C" __cdecl wmain(int argc, wchar_t ** argv);
void loadFile(wchar_t* fileName);
BOOL WINAPI handler(DWORD dwCtrlType);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\writer\sassert.cpp ===
/*
**++
**
** Copyright (c) 2002  Microsoft Corporation
**
**
** Module Name:
**
**	assert.h
**
**
** Abstract:
**
**	Defines my assert function since I can't use the built-in one
**
** Author:
**
**	Reuven Lax      [reuvenl]       04-June-2002
**
**
** Revision History:
**
**--
*/

#include "stdafx.h"
#include "sassert.h"

// really stupid assertion function...
void FailAssertion(const char* fileName, unsigned int lineNumber, const char* condition)
{
	fprintf(stderr, "Assertion failure: %s\nFile: %s\nLine: %u\n", condition, fileName, lineNumber);
	::DebugBreak();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\writer\main.cpp ===
/*
**++
**
** Copyright (c) 2002  Microsoft Corporation
**
**
** Module Name:
**
**	main.cpp
**
**
** Abstract:
**
**	Test program to to register a Writer with various properties
**
** Author:
**
**	Reuven Lax      [reuvenl]       04-June-2002
**
**
** Revision History:
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "stdafx.h"
#include "main.h"
#include "swriter.h"
#include "writerconfig.h"
#include <string>
#include <sstream>
#include <utility>
#include <memory>

///////////////////////////////////////////////////////////////////////////////
// Declarations

HANDLE g_quitEvent = NULL;
using Utility::checkReturn;


///////////////////////////////////////////////////////////////////////////////

extern "C" __cdecl wmain(int argc, wchar_t ** argv)
try
{
	if (argc != 2)
		throw Utility::TestWriterException(L"Invalid number of arguments\n Format: vswriter.exe <config-file>");

	HRESULT hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED );
	checkReturn(hr, L"CoInitializeEx");
	
	loadFile(argv[1]);

       hr = ::CoInitializeSecurity(
           NULL,                                 //  IN PSECURITY_DESCRIPTOR         pSecDesc,
           -1,                                  //  IN LONG                         cAuthSvc,
           NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
           NULL,                                //  IN void                        *pReserved1,
           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,       //  IN DWORD                        dwAuthnLevel,
           RPC_C_IMP_LEVEL_IDENTIFY,            //  IN DWORD                        dwImpLevel,
           NULL,                                //  IN void                        *pAuthList,
           EOAC_NONE,
                                                //  IN DWORD                        dwCapabilities,
           NULL                                 //  IN void                        *pReserved3
           );
       checkReturn(hr, L"CoInitializeSecurity");

	g_quitEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL);
	if (g_quitEvent == NULL)
		throw Utility::TestWriterException(L"Internal Error: could not create event\n");

	// set a control handler that allows the writer to be shut down
	if (!::SetConsoleCtrlHandler(handler, TRUE))
		checkReturn(HRESULT_FROM_WIN32(::GetLastError()), L"SetConsoleCtrlHandler");

	// We want the writer to go out of scope before the return statement
	{
		TestWriter writer;
		hr = writer.Initialize();
		checkReturn(hr, L"TestWriter::Initialize");

		if(::WaitForSingleObject(g_quitEvent, INFINITE) != WAIT_OBJECT_0)
			throw Utility::TestWriterException(L"internal Error: did not successfully wait on event\n");
	}
	
	return 0;	
}
catch(const std::exception& error)	
{
	Utility::printStatus(error.what(), Utility::low);
	exit(1);
}
catch(HRESULT error)	
{
	Utility::TestWriterException e(error);
	Utility::printStatus(e.what(), Utility::low);
	exit(1);
}

void loadFile(wchar_t* fileName)
{
	CXMLDocument document;
	if (!document.LoadFromFile(fileName))
		Utility::parseError(document);

	CComBSTR xmlString = document.SaveAsXML();
	WriterConfiguration::instance()->loadFromXML((BSTR)xmlString);

	return;
}

BOOL WINAPI handler(DWORD dwCtrlType)
{
	// only print to console if it's safe
	if ((dwCtrlType == CTRL_C_EVENT) ||
	     (dwCtrlType == CTRL_BREAK_EVENT))
		Utility::printStatus(L"Terminating writer", Utility::low);
	
	// we want to quit independent of what the control event was
	::SetEvent(g_quitEvent);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\vsst\secutil.cpp ===
/*
**++
**
** Copyright (c) 2000-2002  Microsoft Corporation
**
**
** Module Name:
**
**	    secutil.cpp
**
** Abstract:
**
**	    Utility functions for the VSSEC test.
**
** Author:
**
**	    Adi Oltean      [aoltean]       02/12/2002
**
**
** Revision History:
**
**--
*/

///////////////////////////////////////////////////////////////////////////////
// Includes

#include "sec.h"


///////////////////////////////////////////////////////////////////////////////
// Command line parsing


CVssSecurityTest::CVssSecurityTest()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::CVssSecurityTest()");
        
    // Initialize data members
    m_bCoInitializeSucceeded = false;

    // Print display header
    ft.Msg(L"\nVSS Security Test application, version 1.0\n");
}


CVssSecurityTest::~CVssSecurityTest()
{
    // Unloading the COM library
    if (m_bCoInitializeSucceeded)
        CoUninitialize();
}


void CVssSecurityTest::Initialize()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::Initialize()");
    
    ft.Msg (L"\n----------------- Command line parsing ---------------\n");
    
    // Extract the executable name from the command line
    LPWSTR wszCmdLine = GetCommandLine();
    for(;iswspace(*wszCmdLine); wszCmdLine++);
    if (*wszCmdLine == L'"') {
        if (!wcschr(wszCmdLine+1, L'"'))
            ft.Throw( VSSDBG_VSSTEST, E_UNEXPECTED, L"Invalid command line: %s\n", GetCommandLine() );
        wszCmdLine = wcschr(wszCmdLine+1, L'"') + 1;
    } else
        for(;*wszCmdLine && !iswspace(*wszCmdLine); wszCmdLine++);

    ft.Msg( L"Command line: '%s '\n", wszCmdLine );

    // Parse command line
    if (!ParseCmdLine(wszCmdLine))
       throw(E_INVALIDARG);

    PrintArguments();
    
    BS_ASSERT(!IsOptionPresent(L"-D"));

    ft.Msg (L"\n----------------- Initializing ---------------------\n");

    // Initialize COM library
    CHECK_COM(CoInitializeEx (NULL, COINIT_MULTITHREADED),;);
	m_bCoInitializeSucceeded = true;
    ft.Msg (L"COM library initialized.\n");

    // Initialize COM security
    CHECK_COM
		(
		CoInitializeSecurity
			(
			NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
			-1,                                  //  IN LONG                         cAuthSvc,
			NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
			NULL,                                //  IN void                        *pReserved1,
			RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
			RPC_C_IMP_LEVEL_IDENTIFY,            //  IN DWORD                        dwImpLevel,
			NULL,                                //  IN void                        *pAuthList,
			EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
			NULL                                 //  IN void                        *pReserved3
			)
		,;);

    ft.Msg (L"COM security initialized.\n");
    
    //  Turns off SEH exception handing for COM servers (BUG# 530092)
//    ft.ComDisableSEH(VSSDBG_VSSTEST);

    ft.Msg (L"COM SEH disabled.\n");

}



///////////////////////////////////////////////////////////////////////////////
// Utility functions


// Convert a failure type into a string
LPCWSTR CVssSecurityTest::GetStringFromFailureType( IN  HRESULT hrStatus )
{
    static WCHAR wszBuffer[MAX_TEXT_BUFFER];

    switch (hrStatus)
	{
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, E_OUTOFMEMORY)
	
	case NOERROR:
	    break;
	
	default:
        ::FormatMessageW( FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, hrStatus, 0, wszBuffer, MAX_TEXT_BUFFER - 1, NULL);
	    break;
	}

    return (wszBuffer);
}


BOOL CVssSecurityTest::IsAdmin()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSecurityTest::IsAdmin()");
    
    HANDLE hThreadToken = NULL;
    CHECK_WIN32( OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadToken), ;);

    DWORD cbToken = 0;
    GetTokenInformation( hThreadToken, TokenUser, NULL, 0, &cbToken );
    TOKEN_USER *pUserToken = (TOKEN_USER *)_alloca( cbToken );
    CHECK_WIN32( GetTokenInformation( hThreadToken, TokenUser, pUserToken, cbToken, &cbToken ),
        CloseHandle(hThreadToken);
    );

    WCHAR wszName[MAX_TEXT_BUFFER];
    DWORD dwNameSize = MAX_TEXT_BUFFER;
    WCHAR wszDomainName[MAX_TEXT_BUFFER];
    DWORD dwDomainNameSize = MAX_TEXT_BUFFER;
    SID_NAME_USE snUse;
    CHECK_WIN32( LookupAccountSid( NULL, pUserToken->User.Sid, 
        wszName, &dwNameSize, 
        wszDomainName, &dwDomainNameSize,
        &snUse), 
        CloseHandle(hThreadToken);
    );

    ft.Msg( L"* (ThreadToken) Name: %s, Domain Name: %s, SidUse: %d\n", wszName, wszDomainName, snUse );

    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    PSID   psid = 0;
    CHECK_WIN32( 
        AllocateAndInitializeSid( 
            &siaNtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &psid ),
        CloseHandle(hThreadToken);
    );

    BOOL bIsAdmin = FALSE;
    CHECK_WIN32( CheckTokenMembership( 0, psid, &bIsAdmin ), 
        FreeSid( psid ); 
        CloseHandle(hThreadToken);
    );

    FreeSid( psid ); 
    CloseHandle(hThreadToken);

    return bIsAdmin;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\writer\schema.h ===
wchar_t Schema[] = 
{
L'<', L'S', L'c', L'h', L'e', L'm', L'a', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'V', L's', L's', L'T', L'e', L's', 
L't', L'W', L'r', L'i', L't', L'e', L'r', L'C', L'o', L'n', 
L'f', L'i', L'g', L'"', L' ', L'x', L'm', L'l', L'n', L's', 
L'=', L'"', L'u', L'r', L'n', L':', L's', L'c', L'h', L'e', 
L'm', L'a', L's', L'-', L'm', L'i', L'c', L'r', L'o', L's', 
L'o', L'f', L't', L'-', L'c', L'o', L'm', L':', L'x', L'm', 
L'l', L'-', L'd', L'a', L't', L'a', L'"', L' ', L'x', L'm', 
L'l', L'n', L's', L':', L'd', L't', L'=', L'"', L'u', L'r', 
L'n', L':', L's', L'c', L'h', L'e', L'm', L'a', L's', L'-', 
L'm', L'i', L'c', L'r', L'o', L's', L'o', L'f', L't', L'-', 
L'c', L'o', L'm', L':', L'd', L'a', L't', L'a', L't', L'y', 
L'p', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'<', L'!', 
L'-', L'-', L' ', L'H', L'e', L'r', L'e', L' ', L'w', L'e', 
L' ', L'd', L'e', L'f', L'i', L'n', L'e', L' ', L'a', L'l', 
L'l', L' ', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L's', L' ', L't', L'h', L'a', L't', L' ', L'm', L'a', 
L'y', L' ', L'b', L'e', L' ', L'u', L's', L'e', L'd', L' ', 
L'a', L'c', L'r', L'o', L's', L's', L' ', L'd', L'i', L'f', 
L'f', L'e', L'r', L'e', L'n', L't', L' ', L'e', L'l', L'e', 
L'm', L'e', L'n', L't', L's', L' ', L'o', L'f', L' ', L't', 
L'h', L'e', L' ', L'd', L'o', L'c', L'u', L'm', L'e', L'n', 
L't', L' ', L'-', L'-', L'>', L'\r', L'\n', L'\t', L'<', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'f', 
L'i', L'l', L'e', L's', L'p', L'e', L'c', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', 
L'r', L'i', L'n', L'g', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'F', L'i', L'l', L'e', 
L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', L'c', L'a', 
L't', L'i', L'o', L'n', L'.', L' ', L' ', L'C', L'a', L'n', 
L' ', L'i', L'n', L'c', L'l', L'u', L'd', L'e', L' ', L'w', 
L'i', L'l', L'd', L'c', L'a', L'r', L'd', L' ', L'c', L'h', 
L'a', L'r', L'a', L'c', L't', L'e', L'r', L's', L' ', L'?', 
L' ', L'a', L'n', L'd', L' ', L'*', L'\r', L'\n', L'\t', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'p', L'a', L't', L'h', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'P', 
L'a', L't', L'h', L' ', L't', L'o', L' ', L'a', L' ', L'f', 
L'i', L'l', L'e', L'.', L' ', L' ', L'T', L'h', L'e', L' ', 
L'p', L'a', L't', L'h', L' ', L'c', L'a', L'n', L' ', L'i', 
L'n', L'c', L'l', L'u', L'd', L'e', L' ', L'e', L'n', L'v', 
L'i', L'r', L'o', L'n', L'm', L'e', L'n', L't', L' ', L'v', 
L'a', L'r', L'i', L'a', L'b', L'l', L'e', L's', L' ', L'o', 
L'r', L'\r', L'\n', L'\t', L'v', L'a', L'l', L'u', L'e', L's', 
L' ', L'e', L'x', L't', L'r', L'a', L'c', L't', L'e', L'd', 
L' ', L'f', L'r', L'o', L'm', L' ', L'r', L'e', L'g', L'i', 
L's', L't', L'r', L'y', L' ', L'k', L'e', L'y', L's', L'.', 
L'\r', L'\n', L'\t', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'r', L'e', L'c', L'u', L'r', L's', L'i', L'v', L'e', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', 
L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', 
L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', L'n', L'o', 
L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'I', L's', L' ', L'p', L'a', L't', L'h', L' ', 
L's', L'p', L'e', L'c', L'i', L'f', L'i', L'e', L'd', L' ', 
L'r', L'e', L'c', L'u', L'r', L's', L'i', L'v', L'e', L' ', 
L'o', L'r', L' ', L'l', L'i', L'm', L'i', L't', L'e', L'd', 
L' ', L't', L'o', L' ', L't', L'h', L'e', L' ', L'd', L'i', 
L'r', L'e', L'c', L't', L'o', L'r', L'y', L' ', L't', L'h', 
L'a', L't', L' ', L'i', L's', L' ', L's', L'p', L'e', L'c', 
L'i', L'f', L'i', L'e', L'd', L'.', L'\r', L'\n', L'\t', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'a', L'l', L't', L'e', 
L'r', L'n', L'a', L't', L'e', L'P', L'a', L't', L'h', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L's', L't', L'r', L'i', L'n', L'g', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'A', L'l', 
L't', L'e', L'r', L'n', L'a', L't', L'e', L' ', L'p', L'a', 
L't', L'h', L' ', L'i', L'n', L' ', L'w', L'h', L'i', L'c', 
L'h', L' ', L't', L'o', L' ', L'f', L'i', L'n', L'd', L' ', 
L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', L'.', L' ', 
L' ', L'F', L'i', L'l', L'e', L's', L' ', L'i', L'n', L' ', 
L'a', L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', L'o', 
L'u', L'p', L' ', L'm', L'a', L'y', L'\r', L'\n', L'\t', L'h', 
L'a', L'v', L'e', L' ', L'b', L'e', L'e', L'n', L' ', L'c', 
L'o', L'p', L'i', L'e', L'd', L' ', L't', L'o', L' ', L'a', 
L'n', L' ', L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', 
L'i', L'v', L'e', L' ', L'l', L'o', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L'b', L'y', L' ', L't', L'h', L'e', L' ', 
L'w', L'r', L'i', L't', L'e', L'r', L'.', L' ', L' ', L'B', 
L'a', L'c', L'k', L'u', L'p', L' ', L's', L'h', L'o', L'u', 
L'l', L'd', L'\r', L'\n', L'\t', L'p', L'i', L'c', L'k', L' ', 
L'u', L'p', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', 
L'e', L's', L' ', L'f', L'r', L'o', L'm', L' ', L't', L'h', 
L'e', L' ', L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', 
L'i', L'v', L'e', L' ', L'l', L'o', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L'i', L'n', L's', L't', L'e', L'a', L'd', 
L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', L'o', L'r', 
L'i', L'g', L'i', L'n', L'a', L'l', L'\r', L'\n', L'\t', L'l', 
L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'b', L'u', 
L't', L' ', L's', L'h', L'o', L'u', L'l', L'd', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L' ', L't', L'h', L'e', 
L' ', L'f', L'i', L'l', L'e', L's', L' ', L't', L'o', L' ', 
L't', L'h', L'e', L'i', L'r', L' ', L'o', L'r', L'i', L'g', 
L'i', L'n', L'a', L'l', L' ', L'l', L'o', L'c', L'a', L't', 
L'i', L'o', L'n', L'\r', L'\n', L'\t', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'l', L'o', L'g', L'i', L'c', L'a', L'l', 
L'P', L'a', L't', L'h', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', 
L'g', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'L', L'o', L'g', L'i', L'c', 
L'a', L'l', L' ', L'p', L'a', L't', L'h', L' ', L'f', L'o', 
L'r', L' ', L'a', L' ', L'W', L'r', L'i', L't', L'e', L'r', 
L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', 
L'.', L' ', L' ', L'T', L'h', L'i', L's', L' ', L'l', L'o', 
L'g', L'i', L'c', L'a', L'l', L' ', L'n', L'a', L'm', L'e', 
L' ', L'u', L's', L'e', L's', L' ', L'b', L'a', L'c', L'k', 
L's', L'l', L'a', L's', L'h', L'\r', L'\n', L' ', L' ', L' ', 
L'a', L's', L' ', L's', L'e', L'p', L'a', L'r', L'a', L't', 
L'o', L'r', L's', L' ', L't', L'o', L' ', L'f', L'o', L'r', 
L'm', L' ', L'a', L' ', L'l', L'o', L'g', L'i', L'c', L'a', 
L'l', L' ', L'n', L'a', L'm', L'e', L's', L'p', L'a', L'c', 
L'e', L' ', L'h', L'i', L'e', L'r', L'a', L'r', L'c', L'h', 
L'y', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L'N', L'a', L'm', L'e', L'"', L' ', L'd', L't', 
L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', 
L'i', L'n', L'g', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'N', L'a', L'm', 
L'e', L' ', L'u', L's', L'e', L'd', L' ', L't', L'o', L' ', 
L'i', L'd', L'e', L'n', L't', L'i', L'f', L'y', L' ', L'a', 
L' ', L'W', L'r', L'i', L't', L'e', L'r', L' ', L'c', L'o', 
L'm', L'p', L'o', L'n', L'e', L'n', L't', L'.', L' ', L' ', 
L'M', L'a', L'y', L' ', L'b', L'e', L' ', L'q', L'u', L'a', 
L'l', L'i', L'f', L'i', L'e', L'd', L' ', L'b', L'y', L' ', 
L'a', L'\r', L'\n', L' ', L' ', L' ', L'l', L'o', L'g', L'i', 
L'c', L'a', L'l', L' ', L'p', L'a', L't', L'h', L'.', L'\r', 
L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'<', L'!', L'-', L'-', L' ', L'H', L'e', L'r', L'e', L' ', 
L'w', L'e', L' ', L'd', L'e', L'f', L'i', L'n', L'e', L' ', 
L'a', L'l', L'l', L' ', L'o', L'f', L' ', L't', L'h', L'e', 
L' ', L'p', L'o', L's', L's', L'i', L'b', L'l', L'e', L' ', 
L'e', L'l', L'e', L'm', L'e', L'n', L't', L's', L' ', L'o', 
L'f', L' ', L't', L'h', L'e', L' ', L'd', L'o', L'c', L'u', 
L'm', L'e', L'n', L't', L' ', L'-', L'-', L'>', L'\r', L'\n', 
L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'T', L'e', L's', L't', L'W', L'r', L'i', L't', L'e', L'r', 
L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', 
L'"', L'e', L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', 
L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', 
L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'C', L'o', L'n', L'f', L'i', 
L'g', L'u', L'r', L'a', L't', L'i', L'o', L'n', L' ', L'i', 
L'n', L'f', L'o', L'r', L'm', L'a', L't', L'i', L'o', L'n', 
L' ', L'f', L'o', L'r', L' ', L't', L'h', L'e', L' ', L'V', 
L'S', L'S', L' ', L'T', L'e', L's', L't', L' ', L'W', L'r', 
L'i', L't', L'e', L'r', L'.', L'\r', L'\n', L'\t', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'u', L's', L'a', 
L'g', L'e', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', 
L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', 
L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', 
L'a', L'l', L'u', L'e', L's', L'=', L'"', L'U', L'S', L'E', 
L'R', L'_', L'D', L'A', L'T', L'A', L'\r', L'\n', L'\t', L'\t', 
L'\t', L'\t', L' ', L' ', L' ', L'B', L'O', L'O', L'T', L'A', 
L'B', L'L', L'E', L'_', L'S', L'Y', L'S', L'T', L'E', L'M', 
L'_', L'S', L'T', L'A', L'T', L'E', L' ', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'\t', L' ', L' ', L' ', L'S', L'Y', L'S', L'T', 
L'E', L'M', L'_', L'S', L'E', L'R', L'V', L'I', L'C', L'E', 
L' ', L'\r', L'\n', L'\t', L'\t', L'\t', L'\t', L' ', L' ', L' ', 
L'O', L'T', L'H', L'E', L'R', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L' ', L' ', 
L' ', L' ', L' ', L' ', L'H', L'o', L'w', L' ', L't', L'h', 
L'e', L' ', L'd', L'a', L't', L'a', L' ', L'a', L's', L's', 
L'o', L'c', L'i', L'a', L't', L'e', L'd', L' ', L'w', L'i', 
L't', L'h', L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', 
L't', L'e', L'r', L' ', L'i', L's', L' ', L'u', L's', L'e', 
L'd', L'.', L' ', L' ', L'\r', L'\n', L'\t', L' ', L' ', L' ', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'v', L'e', L'r', L'b', L'o', L's', L'i', L't', 
L'y', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', 
L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', 
L'l', L'u', L'e', L's', L'=', L'"', L'l', L'o', L'w', L' ', 
L'm', L'e', L'd', L'i', L'u', L'm', L' ', L'h', L'i', L'g', 
L'h', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'\t', L'W', L'h', L'e', L't', L'h', 
L'e', L'r', L' ', L'v', L'e', L'r', L'b', L'o', L's', L'e', 
L' ', L'o', L'u', L't', L'p', L'u', L't', L' ', L'i', L's', 
L' ', L'e', L'n', L'a', L'b', L'l', L'e', L'd', L'.', L' ', 
L' ', L' ', L' ', L' ', L' ', L'\r', L'\n', L'\t', L'\t', L'l', 
L'o', L'w', L':', L' ', L' ', L'\t', L'M', L'e', L's', L's', 
L'a', L'g', L'e', L's', L' ', L'a', L'r', L'e', L' ', L'n', 
L'o', L't', L' ', L'p', L'r', L'i', L'n', L't', L'e', L'd', 
L' ', L'i', L'f', L' ', L'f', L'i', L'l', L'e', L's', L' ', 
L'a', L'r', L'e', L' ', L'n', L'o', L't', L' ', L'p', L'r', 
L'o', L'p', L'e', L'r', L'l', L'y', L' ', L'r', L'e', L's', 
L't', L'o', L'r', L'e', L'd', L'\r', L'\n', L'\t', L'\t', L'm', 
L'e', L'd', L'i', L'u', L'm', L':', L'\t', L'M', L'o', L's', 
L't', L' ', L'g', L'e', L'n', L'e', L'r', L'a', L'l', L' ', 
L'm', L'e', L's', L's', L'a', L'g', L'e', L's', L' ', L'a', 
L'r', L'e', L' ', L'p', L'r', L'i', L'n', L't', L'e', L'd', 
L',', L' ', L'i', L'n', L'c', L'l', L'u', L'd', L'i', L'n', 
L'g', L' ', L'w', L'a', L'r', L'n', L'i', L'n', L'g', L's', 
L' ', L'i', L'f', L' ', L'f', L'i', L'l', L'e', L's', L' ', 
L'a', L'r', L'e', L' ', L'n', L'o', L't', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L'd', L'\r', L'\n', L'\t', L'\t', 
L'h', L'i', L'g', L'h', L':', L'\t', L'E', L'x', L't', L'r', 
L'e', L'm', L'e', L'l', L'y', L' ', L'v', L'e', L'r', L'b', 
L'o', L's', L'e', L' ', L'o', L'u', L't', L'p', L'u', L't', 
L' ', L'i', L's', L' ', L'e', L'n', L'a', L'b', L'l', L'e', 
L'd', L'.', L'\r', L'\n', L'\t', L' ', L' ', L' ', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'c', L'h', L'e', L'c', L'k', L'E', L'x', L'c', L'l', L'u', 
L'd', L'e', L's', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', 
L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', 
L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', L'y', L'e', 
L's', L' ', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'W', L'h', 
L'e', L't', L'h', L'e', L'r', L' ', L't', L'o', L' ', L'c', 
L'h', L'e', L'c', L'k', L' ', L't', L'h', L'a', L't', L' ', 
L'e', L'x', L'c', L'l', L'u', L'd', L'e', L'd', L' ', L'f', 
L'i', L'l', L'e', L's', L' ', L'a', L'r', L'e', L' ', L'n', 
L'o', L't', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', 
L'd', L' ', L'a', L't', L' ', L'r', L'e', L's', L't', L'o', 
L'r', L'e', L' ', L't', L'i', L'm', L'e', L'.', L' ', L' ', 
L'\r', L'\n', L'\t', L'\t', L'I', L'f', L' ', L'r', L'e', L's', 
L't', L'o', L'r', L'i', L'n', L'g', L' ', L't', L'o', L' ', 
L'a', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', 
L' ', L't', L'h', L'a', L't', L' ', L'm', L'a', L'y', L' ', 
L'c', L'o', L'n', L't', L'a', L'i', L'n', L' ', L'f', L'i', 
L'l', L'e', L's', L' ', L'm', L'a', L't', L'c', L'h', L'i', 
L'n', L'g', L' ', L't', L'h', L'e', L' ', L'e', L'x', L'c', 
L'l', L'u', L'd', L'e', L' ', L'l', L'i', L's', L't', L',', 
L'\r', L'\n', L'\t', L'\t', L's', L'e', L't', L' ', L't', L'h', 
L'i', L's', L' ', L't', L'o', L' ', L'f', L'a', L'l', L's', 
L'e', L' ', L't', L'o', L' ', L'p', L'r', L'e', L'v', L'e', 
L'n', L't', L' ', L's', L'p', L'u', L'r', L'i', L'o', L'u', 
L's', L' ', L'w', L'a', L'r', L'n', L'i', L'n', L'g', L's', 
L'.', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'c', L'h', L'e', L'c', L'k', L'I', 
L'n', L'c', L'l', L'u', L'd', L'e', L's', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', 
L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', 
L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', L's', 
L'=', L'"', L'y', L'e', L's', L' ', L'n', L'o', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'W', L'h', L'e', L't', L'h', L'e', L'r', L' ', 
L't', L'o', L' ', L'c', L'h', L'e', L'c', L'k', L' ', L't', 
L'h', L'a', L't', L' ', L'i', L'n', L'c', L'l', L'u', L'd', 
L'e', L'd', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'a', 
L'r', L'e', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', 
L'd', L' ', L'a', L't', L' ', L'r', L'e', L's', L't', L'o', 
L'r', L'e', L' ', L't', L'i', L'm', L'e', L'.', L' ', L' ', 
L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'u', 
L's', L'a', L'g', L'e', L'"', L' ', L'd', L'e', L'f', L'a', 
L'u', L'l', L't', L'=', L'"', L'O', L'T', L'H', L'E', L'R', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'v', L'e', L'r', L'b', L'o', L's', 
L'i', L't', L'y', L'"', L' ', L'd', L'e', L'f', L'a', L'u', 
L'l', L't', L'=', L'"', L'm', L'e', L'd', L'i', L'u', L'm', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'c', L'h', L'e', L'c', L'k', L'E', 
L'x', L'c', L'l', L'u', L'd', L'e', L's', L'"', L' ', L'd', 
L'e', L'f', L'a', L'u', L'l', L't', L'=', L'"', L'y', L'e', 
L's', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'c', L'h', L'e', L'c', L'k', 
L'I', L'n', L'c', L'l', L'u', L'd', L'e', L's', L'"', L' ', 
L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', L'"', L'y', 
L'e', L's', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'R', L'e', L's', L't', L'o', L'r', 
L'e', L'M', L'e', L't', L'h', L'o', L'd', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'g', L'r', L'o', L'u', L'p', 
L' ', L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', L'a', 
L'n', L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', 
L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'E', L'x', L'c', L'l', L'u', L'd', 
L'e', L'F', L'i', L'l', L'e', L'"', L' ', L'm', L'i', L'n', 
L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', 
L' ', L'm', L'a', L'x', L'O', L'c', L'c', L'u', L'r', L's', 
L'=', L'"', L'*', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'C', L'o', L'm', L'p', 
L'o', L'n', L'e', L'n', L't', L'"', L' ', L'm', L'i', L'n', 
L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', 
L' ', L'm', L'a', L'x', L'O', L'c', L'c', L'u', L'r', L's', 
L'=', L'"', L'*', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'F', L'a', L'i', L'l', 
L'E', L'v', L'e', L'n', L't', L'"', L' ', L'm', L'i', L'n', 
L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', 
L' ', L'm', L'a', L'x', L'O', L'c', L'c', L'u', L'r', L's', 
L'=', L'"', L'*', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'g', L'r', L'o', L'u', L'p', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'R', L'e', L's', 
L't', L'o', L'r', L'e', L'M', L'e', L't', L'h', L'o', L'd', 
L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', 
L'"', L'e', L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', 
L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', 
L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'H', L'o', L'w', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L' ', L's', L'h', L'o', 
L'u', L'l', L'd', L' ', L'b', L'e', L' ', L'p', L'e', L'r', 
L'f', L'o', L'r', L'm', L'e', L'd', L'.', L' ', L' ', L'I', 
L'n', L'c', L'l', L'u', L'd', L'e', L's', L' ', L's', L'p', 
L'e', L'c', L'i', L'f', L'i', L'c', L'a', L't', L'i', L'o', 
L'n', L' ', L'o', L'f', L' ', L'h', L'o', L'w', L' ', L'f', 
L'i', L'l', L'e', L's', L'\r', L'\n', L'\t', L's', L'h', L'o', 
L'u', L'l', L'd', L' ', L'b', L'e', L' ', L'r', L'e', L's', 
L't', L'o', L'r', L'e', L'd', L' ', L'a', L's', L' ', L'w', 
L'e', L'l', L'l', L' ', L'a', L's', L' ', L's', L'p', L'e', 
L'c', L'i', L'a', L'l', L' ', L's', L't', L'e', L'p', L's', 
L' ', L't', L'h', L'a', L't', L' ', L's', L'h', L'o', L'u', 
L'l', L'd', L' ', L'o', L'c', L'c', L'u', L'r', L' ', L'i', 
L'n', L' ', L'o', L'r', L'd', L'e', L'r', L'\r', L'\n', L'\t', 
L' ', L't', L'o', L' ', L'c', L'o', L'm', L'p', L'l', L'e', 
L't', L'e', L' ', L't', L'h', L'e', L' ', L'r', L'e', L's', 
L't', L'o', L'r', L'e', L'.', L'\r', L'\n', L'\t', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'm', L'e', L't', 
L'h', L'o', L'd', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', 
L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', 
L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', L'R', L'E', 
L'S', L'T', L'O', L'R', L'E', L'_', L'I', L'F', L'_', L'N', 
L'O', L'N', L'E', L'_', L'T', L'H', L'E', L'R', L'E', L'\r', 
L'\n', L'\t', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'R', L'E', 
L'S', L'T', L'O', L'R', L'E', L'_', L'I', L'F', L'_', L'C', 
L'A', L'N', L'_', L'B', L'E', L'_', L'R', L'E', L'P', L'L', 
L'A', L'C', L'E', L'D', L'\r', L'\n', L'\t', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L'S', L'T', L'O', L'P', L'_', L'R', L'E', 
L'S', L'T', L'A', L'R', L'T', L'_', L'S', L'E', L'R', L'V', 
L'I', L'C', L'E', L'\r', L'\n', L'\t', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'R', L'E', L'P', L'L', L'A', L'C', L'E', L'_', 
L'A', L'T', L'_', L'R', L'E', L'B', L'O', L'O', L'T', L'\r', 
L'\n', L'\t', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'R', L'E', 
L'P', L'L', L'A', L'C', L'E', L'_', L'A', L'T', L'_', L'R', 
L'E', L'B', L'O', L'O', L'T', L'_', L'I', L'F', L'_', L'C', 
L'A', L'N', L'N', L'O', L'T', L'_', L'R', L'E', L'P', L'L', 
L'A', L'C', L'E', L'\r', L'\n', L'\t', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'R', L'E', L'S', L'T', L'O', L'R', L'E', L'_', 
L'T', L'O', L'_', L'A', L'L', L'T', L'E', L'R', L'N', L'A', 
L'T', L'E', L'_', L'L', L'O', L'C', L'A', L'T', L'I', L'O', 
L'N', L'\r', L'\n', L'\t', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'C', L'U', L'S', L'T', L'O', L'M', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'R', L'E', L'S', L'T', 
L'O', L'R', L'E', L'_', L'I', L'F', L'_', L'N', L'O', L'N', 
L'E', L'_', L'T', L'H', L'E', L'R', L'E', L':', L' ', L'i', 
L'.', L'e', L'.', L',', L' ', L'c', L'a', L'n', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L' ', L'd', L'a', L't', 
L'a', L' ', L'i', L'f', L' ', L'i', L't', L' ', L'i', L's', 
L' ', L'n', L'o', L't', L' ', L'a', L't', L' ', L't', L'h', 
L'e', L'\r', L'\n', L'\t', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'l', L'o', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L'w', L'h', L'e', L'r', L'e', L' ', L'i', 
L't', L' ', L'w', L'a', L's', L' ', L'b', L'a', L'c', L'k', 
L'e', L'd', L' ', L'u', L'p', L' ', L'f', L'r', L'o', L'm', 
L'.', L' ', L' ', L'T', L'h', L'i', L's', L' ', L'e', L's', 
L's', L'e', L'n', L't', L'i', L'a', L'l', L'l', L'y', L' ', 
L'a', L'l', L'l', L'o', L'w', L's', L'\r', L'\n', L'\t', L'\t', 
L' ', L' ', L'd', L'a', L't', L'a', L' ', L't', L'o', L' ', 
L'b', L'e', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', 
L'd', L' ', L't', L'o', L' ', L'a', L' ', L'c', L'l', L'e', 
L'a', L'n', L' ', L's', L'y', L's', L't', L'e', L'm', L'\r', 
L'\n', L'\t', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'R', 
L'E', L'S', L'T', L'O', L'R', L'E', L'_', L'I', L'F', L'_', 
L'C', L'A', L'N', L'_', L'B', L'E', L'_', L'R', L'E', L'P', 
L'L', L'A', L'C', L'E', L'D', L':', L' ', L'R', L'e', L's', 
L't', L'o', L'r', L'e', L' ', L'd', L'a', L't', L'a', L' ', 
L'i', L'f', L' ', L'a', L'l', L'l', L' ', L'o', L'f', L' ', 
L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', 
L'c', L'a', L'n', L'\r', L'\n', L'\t', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'b', L'e', L' ', L'r', 
L'e', L'p', L'l', L'a', L'c', L'e', L'd', L' ', L'i', L'n', 
L' ', L't', L'h', L'e', L' ', L'o', L'r', L'g', L'i', L'g', 
L'i', L'n', L'a', L'l', L' ', L'b', L'a', L'c', L'k', L'u', 
L'p', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', 
L'.', L' ', L' ', L'F', L'a', L'i', L'l', L's', L' ', L'i', 
L'f', L' ', L'a', L'n', L'y', L' ', L'o', L'f', L'\r', L'\n', 
L'\t', L'\t', L' ', L' ', L't', L'h', L'e', L' ', L'f', L'i', 
L'l', L'e', L's', L' ', L'a', L'r', L'e', L' ', L'o', L'p', 
L'e', L'n', L'.', L' ', L' ', L'I', L'f', L' ', L'a', L'n', 
L' ', L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', L'e', 
L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', 
L'i', L's', L' ', L'p', L'r', L'o', L'v', L'i', L'd', L'e', 
L'd', L',', L' ', L'f', L'i', L'l', L'e', L's', L'\r', L'\n', 
L'\t', L'\t', L' ', L' ', L'w', L'i', L'l', L'l', L' ', L'b', 
L'e', L' ', L'p', L'l', L'a', L'c', L'e', L'd', L' ', L't', 
L'h', L'e', L'r', L'e', L' ', L'i', L'f', L' ', L't', L'h', 
L'e', L'y', L' ', L'c', L'a', L'n', L'n', L'o', L't', L' ', 
L'b', L'e', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', 
L'd', L' ', L't', L'o', L' ', L't', L'h', L'e', L'i', L'r', 
L' ', L'o', L'r', L'i', L'g', L'i', L'n', L'a', L'l', L'\r', 
L'\n', L'\t', L'\t', L' ', L' ', L'l', L'o', L'c', L'a', L't', 
L'i', L'o', L'n', L'.', L'\r', L'\n', L'\t', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'S', L'T', L'O', L'P', L'_', L'R', 
L'E', L'S', L'T', L'A', L'R', L'T', L'_', L'S', L'E', L'R', 
L'V', L'I', L'C', L'E', L':', L' ', L's', L't', L'o', L'p', 
L' ', L's', L'e', L'r', L'v', L'i', L'c', L'e', L' ', L'(', 
L's', L'e', L'r', L'v', L'i', L'c', L'e', L' ', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L'm', L'u', 
L's', L't', L' ', L'b', L'e', L'\r', L'\n', L'\t', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L's', L'p', 
L'e', L'c', L'i', L'f', L'i', L'e', L'd', L')', L'.', L' ', 
L'R', L'e', L's', L't', L'o', L'r', L'e', L' ', L'f', L'i', 
L'l', L'e', L's', L' ', L't', L'o', L' ', L'o', L'r', L'i', 
L'g', L'i', L'n', L'a', L'l', L' ', L'b', L'a', L'c', L'k', 
L'u', L'p', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', 
L'n', L'.', L'\r', L'\n', L'\t', L'\t', L' ', L' ', L'R', L'e', 
L's', L't', L'a', L'r', L't', L' ', L's', L'e', L'r', L'v', 
L'i', L'c', L'e', L'.', L' ', L' ', L'F', L'a', L'i', L'l', 
L's', L' ', L'i', L'f', L' ', L'a', L'n', L'y', L' ', L'o', 
L'f', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', 
L's', L' ', L'a', L'r', L'e', L' ', L'o', L'p', L'e', L'n', 
L' ', L'a', L'f', L't', L'e', L'r', L' ', L't', L'h', L'e', 
L'\r', L'\n', L'\t', L'\t', L' ', L' ', L's', L'e', L'r', L'v', 
L'i', L'c', L'e', L' ', L'i', L's', L' ', L's', L't', L'o', 
L'p', L'p', L'e', L'd', L'.', L'\r', L'\n', L'\t', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'R', L'E', L'P', L'L', L'A', 
L'C', L'E', L'_', L'A', L'T', L'_', L'R', L'E', L'B', L'O', 
L'O', L'T', L':', L' ', L'R', L'e', L's', L't', L'o', L'r', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L't', L'o', 
L' ', L'a', L' ', L't', L'e', L'm', L'p', L'o', L'r', L'a', 
L'r', L'y', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', 
L'n', L'.', L' ', L' ', L'U', L's', L'e', L'\r', L'\n', L'\t', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'M', L'o', L'v', L'e', L'F', L'i', L'l', L'e', L'E', L'x', 
L' ', L't', L'o', L' ', L'r', L'e', L'p', L'l', L'a', L'c', 
L'e', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', 
L's', L' ', L'a', L't', L' ', L'r', L'e', L'b', L'o', L'o', 
L't', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'R', L'E', 
L'P', L'L', L'A', L'C', L'E', L'_', L'A', L'T', L'_', L'R', 
L'E', L'B', L'O', L'O', L'T', L'_', L'I', L'F', L'_', L'C', 
L'A', L'N', L'N', L'O', L'T', L'_', L'R', L'E', L'P', L'L', 
L'A', L'C', L'E', L':', L' ', L' ', L'S', L'i', L'm', L'i', 
L'l', L'i', L'a', L'r', L' ', L't', L'o', L' ', L'R', L'E', 
L'P', L'L', L'A', L'C', L'E', L'_', L'A', L'T', L'_', L'R', 
L'E', L'B', L'O', L'O', L'T', L'\r', L'\n', L'\t', L'\t', L' ', 
L' ', L' ', L'h', L'o', L'w', L'e', L'v', L'e', L'r', L' ', 
L'f', L'i', L'l', L'e', L's', L' ', L'm', L'a', L'y', L' ', 
L'b', L'e', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', 
L'd', L' ', L'i', L'n', L' ', L'p', L'l', L'a', L'c', L'e', 
L' ', L'i', L'n', L' ', L't', L'h', L'e', L'y', L' ', L'a', 
L'r', L'e', L' ', L'n', L'o', L't', L' ', L'b', L'u', L's', 
L'y', L'.', L' ', L' ', L'A', L'l', L'l', L' ', L'f', L'i', 
L'l', L'e', L's', L'\r', L'\n', L'\t', L'\t', L' ', L' ', L' ', 
L'w', L'i', L't', L'h', L'i', L'n', L' ', L'a', L' ', L'c', 
L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L' ', L'm', 
L'u', L's', L't', L' ', L'b', L'e', L' ', L'e', L'i', L't', 
L'h', L'e', L'r', L' ', L'c', L'o', L'm', L'p', L'l', L'e', 
L't', L'e', L'l', L'y', L' ', L'r', L'e', L'p', L'l', L'a', 
L'c', L'e', L'd', L' ', L'i', L'n', L' ', L'p', L'l', L'a', 
L'c', L'e', L' ', L'o', L'r', L'\r', L'\n', L'\t', L'\t', L' ', 
L' ', L' ', L'c', L'o', L'm', L'p', L'l', L'e', L't', L'e', 
L'l', L'y', L' ', L'r', L'e', L'p', L'l', L'a', L'c', L'e', 
L'd', L' ', L'a', L't', L' ', L'r', L'e', L'b', L'o', L'o', 
L't', L',', L' ', L's', L'o', L' ', L'i', L'f', L' ', L'o', 
L'n', L'e', L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L' ', L'f', L'i', L'l', L'e', L' ', L'i', L's', 
L' ', L'b', L'u', L's', L'y', L',', L' ', L'a', L'l', L'l', 
L' ', L'f', L'i', L'l', L'e', L's', L'\r', L'\n', L'\t', L'\t', 
L' ', L' ', L' ', L'i', L'n', L' ', L't', L'h', L'a', L't', 
L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', 
L' ', L'm', L'u', L's', L't', L' ', L'b', L'e', L' ', L'r', 
L'e', L'p', L'l', L'a', L'c', L'e', L'd', L' ', L'a', L't', 
L' ', L'r', L'e', L'b', L'o', L'o', L't', L'.', L'\r', L'\n', 
L'\t', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'\r', L'\n', L'\t', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'R', L'E', L'S', L'T', L'O', L'R', L'E', L'_', L'T', 
L'O', L'_', L'A', L'L', L'T', L'E', L'R', L'N', L'A', L'T', 
L'I', L'V', L'E', L'_', L'L', L'O', L'C', L'A', L'T', L'I', 
L'O', L'N', L':', L' ', L'R', L'e', L's', L't', L'o', L'r', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L't', L'o', 
L' ', L'a', L'n', L' ', L'a', L'l', L't', L'e', L'r', L'n', 
L'a', L't', L'e', L'\r', L'\n', L'\t', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'l', L'o', L'c', L'a', 
L't', L'i', L'o', L'n', L'.', L' ', L' ', L'T', L'y', L'p', 
L'i', L'c', L'a', L'l', L'l', L'y', L' ', L'w', L'r', L'i', 
L't', L'e', L'r', L'R', L'e', L's', L't', L'o', L'r', L'e', 
L' ', L'w', L'i', L'l', L'l', L' ', L'i', L'n', L'd', L'i', 
L'c', L'a', L't', L'e', L' ', L't', L'h', L'a', L't', L' ', 
L't', L'h', L'e', L' ', L'w', L'r', L'i', L't', L'e', L'r', 
L'\r', L'\n', L'\t', L'\t', L' ', L' ', L'w', L'i', L'l', L'l', 
L' ', L'p', L'a', L'r', L't', L'i', L'c', L'i', L'p', L'a', 
L't', L'e', L' ', L'i', L'n', L' ', L't', L'h', L'e', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L' ', L'p', L'r', 
L'o', L'c', L'e', L's', L's', L'\r', L'\n', L'\t', L'\t', L'C', 
L'U', L'S', L'T', L'O', L'M', L':', L' ', L' ', L'C', L'u', 
L's', L't', L'o', L'm', L' ', L'r', L'e', L's', L't', L'o', 
L'r', L'e', L' ', L'm', L'e', L't', L'h', L'o', L'd', L'.', 
L' ', L' ', L'R', L'e', L'q', L'u', L'e', L's', L't', L'o', 
L'r', L'\'', L's', L' ', L's', L'h', L'o', L'u', L'l', L'd', 
L' ', L'n', L'o', L't', L' ', L'h', L'a', L'n', L'd', L'l', 
L'e', L' ', L't', L'h', L'i', L's', L'\r', L'\n', L'\t', L'\t', 
L'c', L'a', L's', L'e', L' ', L'a', L't', L' ', L'a', L'l', 
L'l', L' ', L'f', L'o', L'r', L' ', L't', L'h', L'i', L's', 
L' ', L'w', L'r', L'i', L't', L'e', L'r', L'.', L'\r', L'\n', 
L'\t', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L's', L'e', L'r', 
L'v', L'i', L'c', L'e', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', 
L'g', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'\t', L'M', L'u', L's', L't', L' ', 
L'b', L'e', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', 
L'e', L'd', L' ', L'i', L'f', L' ', L'm', L'e', L't', L'h', 
L'o', L'd', L'=', L'"', L'S', L'T', L'O', L'P', L'_', L'R', 
L'E', L'S', L'T', L'A', L'R', L'T', L'_', L'S', L'E', L'R', 
L'V', L'I', L'C', L'E', L'"', L',', L' ', L'i', L'n', L'd', 
L'i', L'c', L'a', L't', L'e', L's', L'\r', L'\n', L'\t', L' ', 
L' ', L' ', L' ', L' ', L' ', L's', L'e', L'r', L'v', L'i', 
L'c', L'e', L' ', L't', L'o', L' ', L'b', L'e', L' ', L's', 
L't', L'o', L'p', L'p', L'e', L'd', L' ', L'b', L'e', L'f', 
L'o', L'r', L'e', L' ', L'r', L'e', L's', L't', L'o', L'r', 
L'i', L'n', L'g', L' ', L'f', L'i', L'l', L'e', L's', L'.', 
L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'w', L'r', L'i', L't', L'e', L'r', L'R', 
L'e', L's', L't', L'o', L'r', L'e', L'"', L' ', L'd', L't', 
L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', L'u', 
L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', L' ', 
L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', L's', L'=', 
L'"', L'a', L'l', L'w', L'a', L'y', L's', L' ', L'n', L'e', 
L'v', L'e', L'r', L' ', L'i', L'f', L'R', L'e', L'p', L'l', 
L'a', L'c', L'e', L'F', L'a', L'i', L'l', L's', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'W', L'h', L'e', L't', L'h', L'e', L'r', L' ', 
L'w', L'r', L'i', L't', L'e', L'r', L' ', L's', L'h', L'o', 
L'u', L'l', L'd', L' ', L'b', L'e', L' ', L'i', L'n', L'v', 
L'o', L'k', L'e', L'd', L' ', L'a', L'f', L't', L'e', L'r', 
L' ', L'f', L'i', L'l', L'e', L's', L' ', L'a', L'r', L'e', 
L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', 
L't', L'o', L'\r', L'\n', L'\t', L'\t', L'd', L'i', L's', L'k', 
L'.', L' ', L' ', L'O', L'p', L't', L'i', L'o', L'n', L's', 
L' ', L'a', L'r', L'e', L' ', L'a', L'l', L'w', L'a', L'y', 
L's', L',', L' ', L'n', L'e', L'v', L'e', L'r', L',', L' ', 
L'a', L'n', L'd', L' ', L'i', L'f', L'R', L'e', L'p', L'l', 
L'a', L'c', L'e', L'F', L'a', L'i', L'l', L's', L'.', L' ', 
L' ', L'T', L'h', L'e', L' ', L'l', L'a', L't', L't', L'e', 
L'r', L' ', L'm', L'e', L'a', L'n', L's', L'\r', L'\n', L'\t', 
L'\t', L't', L'h', L'a', L't', L' ', L't', L'h', L'e', L' ', 
L'f', L'i', L'l', L'e', L's', L' ', L'w', L'i', L'l', L'l', 
L' ', L'b', L'e', L' ', L'r', L'e', L's', L't', L'o', L'r', 
L'e', L'd', L' ', L't', L'o', L' ', L't', L'h', L'e', L'i', 
L'r', L' ', L'o', L'r', L'i', L'g', L'i', L'n', L'a', L'l', 
L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L'.', 
L' ', L' ', L'I', L'f', L' ', L'o', L'n', L'e', L'\r', L'\n', 
L'\t', L'\t', L'o', L'r', L' ', L'm', L'o', L'r', L'e', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', 
L'e', L's', L' ', L'c', L'a', L'n', L'n', L'o', L't', L' ', 
L'b', L'e', L' ', L'r', L'e', L'p', L'l', L'a', L'c', L'e', 
L'd', L',', L' ', L't', L'h', L'e', L'n', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'w', L'i', 
L'l', L'l', L' ', L'b', L'e', L'\r', L'\n', L'\t', L'\t', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L't', L'o', 
L' ', L'a', L'n', L' ', L'a', L'l', L't', L'e', L'r', L'n', 
L'a', L't', L'e', L' ', L'l', L'o', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L'(', L'm', L'u', L's', L't', L' ', L'b', 
L'e', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', L'e', 
L'd', L' ', L'v', L'i', L'a', L'\r', L'\n', L'\t', L'\t', L'A', 
L'L', L'T', L'E', L'R', L'N', L'A', L'T', L'E', L'_', L'L', 
L'O', L'C', L'A', L'T', L'I', L'O', L'N', L'_', L'M', L'A', 
L'P', L'P', L'I', L'N', L'G', L'.', L' ', L' ', L'A', L'f', 
L't', L'e', L'r', L' ', L't', L'h', L'e', L' ', L'f', L'i', 
L'l', L'e', L's', L' ', L'a', L'r', L'e', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L'd', L',', L' ', L't', L'h', 
L'e', L' ', L'w', L'r', L'i', L't', L'e', L'r', L'\r', L'\n', 
L'\t', L'\t', L'i', L's', L' ', L'i', L'n', L'v', L'o', L'k', 
L'e', L'd', L'.', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'r', L'e', L'b', L'o', 
L'o', L't', L'R', L'e', L'q', L'u', L'i', L'r', L'e', L'd', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', 
L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', 
L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', L'n', 
L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'\t', L'S', L'h', L'o', L'u', L'l', 
L'd', L' ', L'a', L' ', L'r', L'e', L'b', L'o', L'o', L't', 
L' ', L'b', L'e', L' ', L'p', L'e', L'r', L'f', L'o', L'r', 
L'm', L'e', L'd', L' ', L'a', L'f', L't', L'e', L'r', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'i', L'n', L'g', L' ', 
L't', L'h', L'e', L' ', L'd', L'a', L't', L'a', L' ', L'f', 
L'o', L'r', L' ', L't', L'h', L'i', L's', L'\r', L'\n', L'\t', 
L'\t', L'w', L'r', L'i', L't', L'e', L'r', L'\r', L'\n', L'\t', 
L'\t', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'm', L'e', L't', L'h', 
L'o', L'd', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', 
L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L's', L'e', L'r', L'v', L'i', L'c', L'e', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'n', L'o', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'w', L'r', L'i', L't', 
L'e', L'r', L'R', L'e', L's', L't', L'o', L'r', L'e', L'"', 
L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', L'"', 
L'n', L'e', L'v', L'e', L'r', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'r', 
L'e', L'b', L'o', L'o', L't', L'R', L'e', L'q', L'u', L'i', 
L'r', L'e', L'd', L'"', L' ', L'd', L'e', L'f', L'a', L'u', 
L'l', L't', L'=', L'"', L'n', L'o', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', 
L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'A', L'l', 
L't', L'e', L'r', L'n', L'a', L't', L'e', L'L', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L'M', L'a', L'p', L'p', L'i', 
L'n', L'g', L'"', L' ', L'm', L'i', L'n', L'O', L'c', L'c', 
L'u', L'r', L's', L'=', L'"', L'0', L'"', L' ', L'm', L'a', 
L'x', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'*', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', 
L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'D', L'e', L'p', L'e', L'n', L'd', L'e', L'n', 
L'c', L'y', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', 
L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L' ', 
L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', 
L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L'A', L' ', 
L'd', L'e', L'p', L'e', L'n', L'd', L'e', L'n', L'c', L'y', 
L' ', L'f', L'r', L'o', L'm', L' ', L'o', L'n', L'e', L' ', 
L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L' ', 
L't', L'o', L' ', L'a', L'n', L'o', L't', L'h', L'e', L'r', 
L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', 
L' ', L'i', L'n', L' ', L'a', L'n', L'o', L't', L'h', L'e', 
L'r', L' ', L'w', L'r', L'i', L't', L'e', L'r', L'.', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'w', L'r', L'i', L't', L'e', L'r', 
L'I', L'd', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', 
L'e', L'=', L'"', L'u', L'u', L'i', L'd', L'"', L' ', L'r', 
L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', 
L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L'I', L'd', 
L' ', L'o', L'f', L' ', L'w', L'r', L'i', L't', L'e', L'r', 
L' ', L't', L'h', L'a', L't', L' ', L't', L'h', L'i', L's', 
L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', 
L' ', L'i', L's', L' ', L'd', L'e', L'p', L'e', L'n', L'd', 
L'e', L'n', L't', L' ', L'o', L'n', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'w', L'r', 
L'i', L't', L'e', L'r', L'I', L'd', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', 
L's', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'l', L'o', L'g', L'i', L'c', 
L'a', L'l', L'P', L'a', L't', L'h', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'c', L'o', L'm', L'p', L'o', L'n', 
L'e', L'n', L't', L'N', L'a', L'm', L'e', L'"', L' ', L'r', 
L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', 
L'e', L's', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', 
L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', 
L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'C', L'o', L'm', L'p', L'o', L'n', 
L'e', L'n', L't', L'F', L'i', L'l', L'e', L'"', L' ', L'c', 
L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', L'm', 
L'p', L't', L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', 
L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'L', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'o', 
L'f', L' ', L'a', L' ', L'f', L'i', L'l', L'e', L' ', L'i', 
L'n', L' ', L'a', L' ', L'c', L'o', L'm', L'p', L'o', L'n', 
L'e', L'n', L't', L'.', L' ', L' ', L'F', L'o', L'r', L' ', 
L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', L'c', 
L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L's', L',', 
L' ', L't', L'h', L'e', L' ', L'a', L'l', L't', L'e', L'r', 
L'n', L'a', L't', L'e', L'P', L'a', L't', L'h', L'\r', L'\n', 
L'\t', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L'i', L's', L' ', L'i', L'g', L'n', L'o', L'r', L'e', 
L'd', L'.', L'\r', L'\n', L'\t', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'p', L'a', L't', L'h', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', L'p', L'e', 
L'c', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'y', L'e', L's', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'r', L'e', L'c', L'u', L'r', L's', L'i', L'v', L'e', L'"', 
L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', 
L'"', L'y', L'e', L's', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'a', L'l', 
L't', L'e', L'r', L'n', L'a', L't', L'e', L'P', L'a', L't', 
L'h', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'n', L'o', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'E', L'x', L'c', 
L'l', L'u', L'd', L'e', L'F', L'i', L'l', L'e', L'"', L' ', 
L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', 
L'm', L'p', L't', L'y', L'"', L' ', L'm', L'o', L'd', L'e', 
L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'L', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', 
L'o', L'f', L' ', L'a', L' ', L'f', L'i', L'l', L'e', L' ', 
L't', L'h', L'a', L't', L' ', L't', L'h', L'e', L' ', L'w', 
L'r', L'i', L't', L'e', L'r', L' ', L's', L'h', L'o', L'u', 
L'l', L'd', L' ', L'm', L'a', L'r', L'k', L' ', L'a', L's', 
L' ', L'e', L'x', L'c', L'l', L'u', L'd', L'e', L'd', L' ', 
L'f', L'r', L'o', L'm', L' ', L'b', L'a', L'c', L'k', L'u', 
L'p', L'.', L'\r', L'\n', L'\t', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'p', L'a', L't', L'h', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', L'p', L'e', 
L'c', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'y', L'e', L's', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'r', L'e', L'c', L'u', L'r', L's', L'i', L'v', L'e', L'"', 
L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', 
L'"', L'y', L'e', L's', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', 
L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'C', L'o', L'm', L'p', 
L'o', L'n', L'e', L'n', L't', L'"', L' ', L'c', L'o', L'n', 
L't', L'e', L'n', L't', L'=', L'"', L'e', L'l', L't', L'O', 
L'n', L'l', L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', 
L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'D', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L' ', L'o', L'f', L' ', L'a', L' ', L'W', L'r', L'i', 
L't', L'e', L'r', L' ', L'c', L'o', L'm', L'p', L'o', L'n', 
L'e', L'n', L't', L'.', L' ', L' ', L'C', L'u', L'r', L'r', 
L'e', L'n', L't', L'l', L'y', L' ', L't', L'h', L'i', L's', 
L' ', L'c', L'a', L'n', L' ', L'd', L'e', L's', L'c', L'r', 
L'i', L'b', L'e', L' ', L'e', L'i', L't', L'h', L'e', L'r', 
L' ', L'a', L' ', L'f', L'i', L'l', L'e', L'-', L'g', L'r', 
L'o', L'u', L'p', L' ', L'\r', L'\n', L'\t', L'c', L'o', L'm', 
L'p', L'o', L'n', L'e', L'n', L't', L' ', L'o', L'r', L' ', 
L'a', L' ', L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', 
L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', 
L'.', L'\r', L'\n', L'\t', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L'T', L'y', L'p', L'e', L'"', L' ', L'd', L't', 
L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', L'u', 
L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', L' ', 
L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', L's', L'=', 
L'"', L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', 
L'f', L'i', L'l', L'e', L'g', L'r', L'o', L'u', L'p', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L's', L'p', L'e', L'c', L'i', L'f', L'i', 
L'e', L'd', L' ', L't', L'h', L'e', L' ', L't', L'y', L'p', 
L'e', L' ', L'o', L'f', L' ', L'a', L' ', L'W', L'r', L'i', 
L't', L'e', L'r', L' ', L'c', L'o', L'm', L'p', L'o', L'n', 
L'e', L'n', L't', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L's', L'e', L'l', L'e', 
L'c', L't', L'a', L'b', L'l', L'e', L'"', L' ', L'd', L't', 
L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', L'u', 
L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', L' ', 
L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', L's', L'=', 
L'"', L'y', L'e', L's', L' ', L'n', L'o', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'I', L's', L' ', L't', L'h', L'i', L's', L' ', L'c', 
L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L' ', L's', 
L'e', L'l', L'e', L'c', L't', L'a', L'b', L'l', L'e', L' ', 
L'f', L'o', L'r', L' ', L'b', L'a', L'c', L'k', L'u', L'p', 
L' ', L'o', L'r', L' ', L'i', L's', L' ', L'i', L't', L' ', 
L'a', L'l', L'w', L'a', L'y', L's', L' ', L'b', L'a', L'c', 
L'k', L'e', L'd', L' ', L'u', L'p', L'.', L'\r', L'\n', L'\t', 
L'\t', L'I', L'f', L' ', L'n', L'o', L',', L' ', L't', L'h', 
L'e', L'n', L' ', L't', L'h', L'e', L' ', L'c', L'o', L'm', 
L'p', L'o', L'n', L'e', L'n', L't', L' ', L'i', L's', L' ', 
L'a', L'l', L'w', L'a', L'y', L's', L' ', L'b', L'a', L'c', 
L'k', L'e', L'd', L' ', L'u', L'p', L' ', L'i', L'f', L' ', 
L'a', L'n', L'y', L' ', L'o', L't', L'h', L'e', L'r', L' ', 
L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L's', 
L' ', L'o', L'f', L'\r', L'\n', L'\t', L'\t', L't', L'h', L'e', 
L' ', L'a', L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', 
L'o', L'n', L'/', L's', L'e', L'r', L'v', L'i', L'c', L'e', 
L' ', L'a', L'r', L'e', L' ', L'b', L'a', L'c', L'k', L'e', 
L'd', L' ', L'u', L'p', L'.', L' ', L' ', L'I', L'f', L' ', 
L'y', L'e', L's', L',', L' ', L't', L'h', L'e', L'n', L' ', 
L't', L'h', L'e', L'\r', L'\n', L'\t', L'\t', L'c', L'o', L'm', 
L'p', L'o', L'n', L'e', L'n', L't', L' ', L'm', L'a', L'y', 
L' ', L'b', L'e', L' ', L's', L'e', L'l', L'e', L'c', L't', 
L'i', L'v', L'e', L'l', L'y', L' ', L'b', L'a', L'c', L'k', 
L'e', L'd', L' ', L'u', L'p', L'.', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L's', 
L'e', L'l', L'e', L'c', L't', L'a', L'b', L'l', L'e', L'F', 
L'o', L'r', L'R', L'e', L's', L't', L'o', L'r', L'e', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', 
L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', 
L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', L'n', L'o', 
L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'\t', L'I', L's', L' ', L't', L'h', L'i', 
L's', L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', 
L't', L' ', L's', L'e', L'l', L'e', L'c', L't', L'a', L'b', 
L'l', L'e', L' ', L'f', L'o', L'r', L' ', L'r', L'e', L's', 
L't', L'o', L'r', L'e', L'\r', L'\n', L'\t', L'\t', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'r', L'e', L's', 
L't', L'o', L'r', L'e', L'T', L'a', L'r', L'g', L'e', L't', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', 
L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', 
L'u', L'e', L's', L'=', L'"', L'V', L'S', L'S', L'_', L'R', 
L'T', L'_', L'O', L'R', L'I', L'G', L'I', L'N', L'A', L'L', 
L'\r', L'\n', L'\t', L'\t', L'\t', L'\t', L' ', L' ', L' ', L'V', 
L'S', L'S', L'_', L'R', L'T', L'_', L'A', L'L', L'T', L'E', 
L'R', L'N', L'A', L'T', L'E', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'A', 
L'l', L'l', L'o', L'w', L's', L' ', L't', L'h', L'e', L' ', 
L'w', L'r', L'i', L't', L'e', L'r', L' ', L't', L'o', L' ', 
L'o', L'v', L'e', L'r', L'r', L'i', L'd', L'e', L' ', L't', 
L'h', L'e', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', 
L' ', L'm', L'e', L't', L'h', L'o', L'd', L' ', L'f', L'o', 
L'r', L' ', L't', L'h', L'i', L's', L' ', L'c', L'o', L'm', 
L'p', L'o', L'n', L'e', L'n', L't', L' ', L'i', L'n', L' ', 
L't', L'h', L'e', L' ', L'P', L'r', L'e', L'R', L'e', L's', 
L't', L'o', L'r', L'e', L' ', L'e', L'v', L'e', L'n', L't', 
L'.', L'\r', L'\n', L'\t', L'\t', L'V', L'S', L'S', L'_', L'R', 
L'T', L'_', L'O', L'R', L'I', L'G', L'I', L'N', L'A', L'L', 
L':', L' ', L' ', L' ', L'a', L'l', L'l', L' ', L'f', L'i', 
L'l', L'e', L's', L' ', L'i', L'n', L' ', L't', L'h', L'i', 
L's', L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', 
L't', L' ', L's', L'h', L'o', L'u', L'l', L'd', L' ', L'b', 
L'e', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', 
L' ', L't', L'o', L' ', L't', L'h', L'e', L'i', L'r', L' ', 
L'o', L'r', L'i', L'g', L'i', L'n', L'a', L'l', L' ', L'l', 
L'o', L'c', L'a', L't', L'i', L'o', L'n', L's', L'.', L'\r', 
L'\n', L'\t', L'\t', L'V', L'S', L'S', L'_', L'R', L'T', L'_', 
L'A', L'L', L'T', L'E', L'R', L'N', L'A', L'T', L'E', L':', 
L' ', L'a', L'l', L'l', L' ', L'f', L'i', L'l', L'e', L's', 
L' ', L'i', L'n', L' ', L't', L'h', L'i', L's', L' ', L'c', 
L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L' ', L'b', L'e', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L't', L'o', 
L' ', L't', L'h', L'e', L' ', L'p', L'r', L'e', L'v', L'i', 
L'o', L'u', L's', L'l', L'y', L' ', L's', L'p', L'e', L'c', 
L'i', L'f', L'i', L'e', L'd', L' ', L'a', L'l', L't', L'e', 
L'r', L'n', L'a', L't', L'e', L' ', L'l', L'o', L'c', L'a', 
L't', L'i', L'o', L'n', L'\r', L'\n', L'\t', L'\t', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L'T', L'y', L'p', L'e', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', 
L's', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'l', L'o', L'g', L'i', L'c', 
L'a', L'l', L'P', L'a', L't', L'h', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'c', L'o', L'm', L'p', L'o', L'n', 
L'e', L'n', L't', L'N', L'a', L'm', L'e', L'"', L' ', L'r', 
L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', 
L'e', L's', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L's', L'e', L'l', L'e', 
L'c', L't', L'a', L'b', L'l', L'e', L'"', L' ', L'd', L'e', 
L'f', L'a', L'u', L'l', L't', L'=', L'"', L'y', L'e', L's', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L's', L'e', L'l', L'e', L'c', L't', 
L'a', L'b', L'l', L'e', L'F', L'o', L'r', L'R', L'e', L's', 
L't', L'o', L'r', L'e', L'"', L' ', L'd', L'e', L'f', L'a', 
L'u', L'l', L't', L'=', L'"', L'n', L'o', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'r', L'e', L's', L't', L'o', L'r', L'e', L'T', L'a', 
L'r', L'g', L'e', L't', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'g', L'r', L'o', L'u', 
L'p', L' ', L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', 
L'a', L'n', L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', 
L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'C', L'o', L'm', L'p', L'o', 
L'n', L'e', L'n', L't', L'F', L'i', L'l', L'e', L'"', L' ', 
L'm', L'i', L'n', L'O', L'c', L'c', L'u', L'r', L's', L'=', 
L'"', L'0', L'"', L' ', L'm', L'a', L'x', L'O', L'c', L'c', 
L'u', L'r', L's', L'=', L'"', L'*', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', 
L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'D', 
L'e', L'p', L'e', L'n', L'd', L'e', L'n', L'c', L'y', L'"', 
L' ', L'm', L'i', L'n', L'O', L'c', L'c', L'u', L'r', L's', 
L'=', L'"', L'0', L'"', L' ', L'm', L'a', L'x', L'O', L'c', 
L'c', L'u', L'r', L's', L'=', L'"', L'*', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'g', L'r', L'o', L'u', 
L'p', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', 
L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'F', L'a', L'i', L'l', L'E', L'v', L'e', L'n', L't', 
L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', 
L'"', L'e', L'm', L'p', L't', L'y', L'"', L' ', L'm', L'o', 
L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', 
L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'S', L'p', L'e', L'c', L'i', L'f', L'i', 
L'e', L's', L' ', L'a', L'n', L' ', L'e', L'v', L'e', L'n', 
L't', L' ', L't', L'h', L'a', L't', L' ', L't', L'h', L'e', 
L' ', L'T', L'e', L's', L't', L' ', L'W', L'r', L'i', L't', 
L'e', L'r', L' ', L'w', L'i', L'l', L'l', L' ', L'f', L'a', 
L'i', L'l', L'.', L'\r', L'\n', L'\t', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'w', L'r', L'i', L't', L'e', 
L'r', L'E', L'v', L'e', L'n', L't', L'"', L' ', L'd', L't', 
L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', L'u', 
L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', L' ', 
L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', L's', L'=', 
L'"', L'I', L'd', L'e', L'n', L't', L'i', L'f', L'y', L'\r', 
L'\n', L'\t', L'\t', L'\t', L'\t', L' ', L' ', L' ', L'P', L'r', 
L'e', L'p', L'a', L'r', L'e', L'F', L'o', L'r', L'B', L'a', 
L'c', L'k', L'u', L'p', L'\r', L'\n', L'\t', L'\t', L'\t', L'\t', 
L' ', L' ', L' ', L'P', L'r', L'e', L'p', L'a', L'r', L'e', 
L'F', L'o', L'r', L'S', L'n', L'a', L'p', L's', L'h', L'o', 
L't', L'\r', L'\n', L'\t', L'\t', L'\t', L'\t', L' ', L' ', L' ', 
L'F', L'r', L'e', L'e', L'z', L'e', L'\r', L'\n', L'\t', L'\t', 
L'\t', L'\t', L' ', L' ', L' ', L'T', L'h', L'a', L'w', L'\r', 
L'\n', L'\t', L'\t', L'\t', L'\t', L' ', L' ', L' ', L'P', L'o', 
L's', L't', L'S', L'n', L'a', L'p', L's', L'h', L'o', L't', 
L'\r', L'\n', L'\t', L'\t', L'\t', L'\t', L' ', L' ', L' ', L'A', 
L'b', L'o', L'r', L't', L'\r', L'\n', L'\t', L'\t', L'\t', L'\t', 
L' ', L' ', L' ', L'B', L'a', L'c', L'k', L'u', L'p', L'C', 
L'o', L'm', L'p', L'l', L'e', L't', L'e', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'\t', L' ', L' ', L' ', L'B', L'a', L'c', L'k', 
L'u', L'p', L'S', L'h', L'u', L't', L'd', L'o', L'w', L'n', 
L'\r', L'\n', L'\t', L'\t', L'\t', L'\t', L' ', L' ', L' ', L'P', 
L'r', L'e', L'R', L'e', L's', L't', L'o', L'r', L'e', L'\r', 
L'\n', L'\t', L'\t', L'\t', L'\t', L' ', L' ', L' ', L'P', L'o', 
L's', L't', L'R', L'e', L's', L't', L'o', L'r', L'e', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'D', L'e', L'f', L'i', L'n', L'e', L's', 
L' ', L't', L'h', L'e', L' ', L'l', L'i', L's', L't', L' ', 
L'o', L'f', L' ', L'e', L'v', L'e', L'n', L't', L's', L' ', 
L't', L'h', L'a', L't', L' ', L'a', L' ', L'W', L'r', L'i', 
L't', L'e', L'r', L' ', L'c', L'a', L'n', L' ', L'f', L'a', 
L'i', L'l', L'.', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'r', L'e', L't', L'r', 
L'y', L'a', L'b', L'l', L'e', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', 
L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', 
L't', L':', L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', 
L'y', L'e', L's', L' ', L'n', L'o', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'W', L'h', L'e', L't', L'h', L'e', L'r', L' ', L't', L'h', 
L'e', L' ', L'f', L'a', L'i', L'l', L'u', L'r', L'e', L' ', 
L's', L'h', L'o', L'u', L'l', L'd', L' ', L'b', L'e', L' ', 
L'r', L'e', L't', L'r', L'y', L'a', L'b', L'l', L'e', L' ', 
L'o', L'r', L' ', L'n', L'o', L't', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'n', 
L'u', L'm', L'F', L'a', L'i', L'l', L'u', L'r', L'e', L's', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L'n', L'u', L'm', L'b', L'e', L'r', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'I', L'f', L' ', L't', L'h', L'e', L' ', L'f', L'a', L'i', 
L'l', L'u', L'r', L'e', L' ', L'i', L's', L' ', L'r', L'e', 
L't', L'r', L'y', L'a', L'b', L'l', L'e', L',', L' ', L't', 
L'h', L'e', L'n', L' ', L't', L'h', L'i', L's', L' ', L'p', 
L'a', L'r', L'a', L'm', L'e', L't', L'e', L'r', L' ', L'i', 
L'n', L'd', L'i', L'c', L'a', L't', L'e', L's', L' ', L't', 
L'h', L'e', L' ', L'n', L'u', L'm', L'b', L'e', L'r', L' ', 
L'o', L'f', L' ', L't', L'i', L'm', L'e', L's', L' ', L't', 
L'h', L'e', L' ', L'w', L'r', L'i', L't', L'e', L'r', L' ', 
L's', L'h', L'o', L'u', L'l', L'd', L'\r', L'\n', L'\t', L'f', 
L'a', L'i', L'l', L' ', L't', L'h', L'e', L' ', L'e', L'v', 
L'e', L'n', L't', L'.', L'\r', L'\n', L'\t', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'w', L'r', L'i', L't', L'e', L'r', L'E', L'v', 
L'e', L'n', L't', L'"', L' ', L'r', L'e', L'q', L'u', L'i', 
L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'r', L'e', L't', L'r', L'y', L'a', L'b', L'l', 
L'e', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', 
L'=', L'"', L'y', L'e', L's', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'n', 
L'u', L'm', L'F', L'a', L'i', L'l', L'u', L'r', L'e', L's', 
L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', 
L'"', L'1', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', 
L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', 
L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'A', L'l', L't', L'e', L'r', L'n', 
L'a', L't', L'e', L'L', L'o', L'c', L'a', L't', L'i', L'o', 
L'n', L'M', L'a', L'p', L'p', L'i', L'n', L'g', L'"', L' ', 
L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', 
L'm', L'p', L't', L'y', L'"', L' ', L'm', L'o', L'd', L'e', 
L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'M', L'a', L'p', L'p', L'i', L'n', L'g', L' ', L'f', 
L'r', L'o', L'm', L' ', L'a', L' ', L'l', L'o', L'c', L'a', 
L't', L'i', L'o', L'n', L' ', L't', L'h', L'a', L't', L' ', 
L'w', L'a', L's', L' ', L'b', L'a', L'c', L'k', L'e', L'd', 
L' ', L'u', L'p', L' ', L't', L'o', L' ', L'a', L' ', L'l', 
L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L't', L'o', 
L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', L' ', L't', 
L'o', L'.', L'\r', L'\n', L'\t', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'p', L'a', L't', L'h', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', L'p', L'e', 
L'c', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'y', L'e', L's', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'r', L'e', L'c', L'u', L'r', L's', L'i', L'v', L'e', L'"', 
L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', L'"', 
L'n', L'o', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'a', L'l', L't', L'e', 
L'r', L'n', L'a', L't', L'e', L'P', L'a', L't', L'h', L'"', 
L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', 
L'"', L'y', L'e', L's', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', 
L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'N', L'e', L'w', L'T', 
L'a', L'r', L'g', L'e', L't', L'"', L' ', L'c', L'o', L'n', 
L't', L'e', L'n', L't', L'=', L'"', L'e', L'm', L'p', L't', 
L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', L'=', L'"', 
L'c', L'l', L'o', L's', L'e', L'd', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'A', L' ', 
L'n', L'e', L'w', L' ', L't', L'a', L'r', L'g', L'e', L't', 
L' ', L'p', L'a', L't', L'h', L' ', L'f', L'o', L'r', L' ', 
L'a', L' ', L'f', L'i', L'l', L'e', L' ', L't', L'h', L'a', 
L't', L' ', L't', L'h', L'e', L' ', L'W', L'r', L'i', L't', 
L'e', L'r', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', 
L'e', L's', L' ', L'a', L't', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L' ', L't', L'i', L'm', L'e', L'.', L'\r', 
L'\n', L'\t', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', 
L'h', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'y', L'e', L's', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'f', L'i', L'l', L'e', L's', L'p', L'e', L'c', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'y', L'e', L's', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'r', L'e', L'c', 
L'u', L'r', L's', L'i', L'v', L'e', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', 
L's', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'a', L'l', L't', L'e', L'r', 
L'n', L'a', L't', L'e', L'P', L'a', L't', L'h', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'n', L'o', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', 
L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'<', L'/', L'S', L'c', L'h', L'e', 
L'm', L'a', L'>', L'\r', L'\n', L'\0'
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\writer\sassert.h ===
/*
**++
**
** Copyright (c) 2002  Microsoft Corporation
**
**
** Module Name:
**
**	assert.h
**
**
** Abstract:
**
**	Defines my assert function since I can't use the built-in one
**
** Author:
**
**	Reuven Lax      [reuvenl]       04-June-2002
**
**
** Revision History:
**
**--
*/

#ifndef _ASSERT_H_
#define _ASSERT_H_

#include <stdio.h>

#ifdef _DEBUG
#define _ASSERTE(x) { if (!(x)) FailAssertion(__FILE__, __LINE__, #x ); }
#define assert(x) _ASSERTE(x)
#else
#define _ASSERTE(x) 
#define assert(x)
#endif

void FailAssertion(const char* fileName, unsigned int lineNumber, const char* condition);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\writer\stdafx.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    stdafx.hxx

Abstract:

    Include file for standard system include files.

Author:

    Adi Oltean   [aoltean]      07/02/1999

Revision History:


    Name    Date            Comments

    aoltean 07/02/1999      Created
    aoltean 09/11/1999      Disabling the C4290 warning

--*/

#ifndef __VSS_STDAFX_HXX__
#define __VSS_STDAFX_HXX__

#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>

#include "vss.h"
#include <vswriter.h>
#include <vsbackup.h>

#include "sassert.h"
#include <stddef.h>
#include <atlbase.h>
#include <atlconv.h>
#include <new>

#pragma warning(disable:4511)
#pragma warning(disable:4100)  // I don't like disabling this, but STL insists
#endif // __VSS_STDAFX_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\writer\swriter.cpp ===
/*
**++
**
** Copyright (c) 2002  Microsoft Corporation
**
**
** Module Name:
**
**	swriter.cpp
**
**
** Abstract:
**
**	Test  program to to register a Writer with various properties
**
** Author:
**
**	Reuven Lax      [reuvenl]       04-June-2002
**
**
** Revision History:
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "stdafx.h"
#include "swriter.h"
#include "utility.h"
#include "writerconfig.h"
#include <string>
#include <sstream>
#include <functional>
#include <algorithm>
#include <queue>

///////////////////////////////////////////////////////////////////////////////
// Declarations and Definitions

using std::wstring;
using std::string;
using std::wstringstream;
using std::exception;
using std::vector;

using Utility::checkReturn;
using Utility::warnReturn;
using Utility::printStatus;

static const wchar_t* const BackupString = L"BACKUP";
static const wchar_t* const RestoreString = L"RESTORE";

///////////////////////////////////////////////////////////////////////////////

// Initialize the test writer
HRESULT STDMETHODCALLTYPE TestWriter::Initialize()
{
	WriterConfiguration* config = WriterConfiguration::instance();

	printStatus(L"Initializing Writer", Utility::high);
	
	HRESULT hr = CVssWriter::Initialize(TestWriterId, 		// WriterID
								    TestWriterName, 	// wszWriterName
								    config->usage(),		// ut
								    VSS_ST_OTHER); 		// st
	checkReturn(hr, L"CVssWriter::Initialize");
	
	hr = Subscribe();
	checkReturn(hr, L"CVssWriter::Subscribe");

	return S_OK;
}

// OnIdentify is called as a result of the requestor calling GatherWriterMetadata
// Here we report the writer metadata using the passed-in interface
bool STDMETHODCALLTYPE TestWriter::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
try	
{
	enterEvent(Utility::Identify);
	
	WriterConfiguration* config = WriterConfiguration::instance();

	// set the restore method properly
	RestoreMethod method = config->restoreMethod();
	HRESULT hr = pMetadata->SetRestoreMethod(method.m_method, 
	                                                                      method.m_service.c_str(),
								                     NULL, 
								                     method.m_writerRestore, 
								                     method.m_rebootRequired);
	checkReturn(hr, L"IVssCreateWriterMetadata::SetRestoreMethod");
	printStatus(L"\nSet restore method: ", Utility::high);
	printStatus(method.toString(), Utility::high);
	
	// set the alternate-location list
	RestoreMethod::AlternateList::iterator currentAlt = method.m_alternateLocations.begin();
	while (currentAlt != method.m_alternateLocations.end())	{
		hr = pMetadata->AddAlternateLocationMapping(currentAlt->m_path. c_str(), 
										currentAlt->m_filespec.c_str(),
										currentAlt->m_recursive, 
										currentAlt->m_alternatePath.substr(0, currentAlt->m_alternatePath.size()-1).c_str());
		checkReturn(hr, L"IVssCreateWriterMetadata::AddAlternateLocationMapping");

		printStatus(L"\nAdded Alternate Location Mapping");
		printStatus(currentAlt->toString());
		
		++currentAlt;
	}

	// set the exclude-file list
	WriterConfiguration::ExcludeFileList::iterator currentExclude = config->excludeFiles().begin();
	while (currentExclude != config->excludeFiles().end())	{
		hr = pMetadata->AddExcludeFiles(currentExclude->m_path.c_str(), 
									   currentExclude->m_filespec.c_str(), 
									   currentExclude->m_recursive);
		checkReturn(hr, L"IVssCreateWriterMetadata::AddExcludeFiles");

		printStatus(L"\nAdded exclude filespec");
		printStatus(currentExclude->toString());
		
		++currentExclude;
	}

	// add all necessary components
	WriterConfiguration::ComponentList::iterator currentComponent = config->components().begin();
	while (currentComponent != config->components().end())	{
		addComponent(*currentComponent, pMetadata);
		
		++currentComponent;
	}

	return true;
}
catch(const exception& thrown)	
{
	printStatus(string("Failure in Identify event: ") + thrown.what(), Utility::low);
	return false;
}
catch(HRESULT error)
{
	Utility::TestWriterException e(error);
	printStatus(e.what(), Utility::low);
	return false;
};

// This function is called as a result of the requestor calling PrepareForBackup
// Here we do some checking to ensure that the requestor selected components properly
bool STDMETHODCALLTYPE TestWriter::OnPrepareBackup(IN IVssWriterComponents *pComponents)
try
{
    enterEvent(Utility::PrepareForBackup);
    
    WriterConfiguration* config = WriterConfiguration::instance();

    // get the number of components
    UINT numComponents = 0;
    HRESULT hr = pComponents->GetComponentCount(&numComponents);
    checkReturn(hr, L"IVssWriterComponents::GetComponentCount");

    // we haven't defined CUSTOM restore method for this writer.  consequently, backup apps should
    // ignore it.
    if ((config->restoreMethod().m_method == VSS_RME_CUSTOM) &&
         numComponents > 0) {
         throw Utility::TestWriterException(L"Components were selected for backup when CUSTOM restore"
                                                           L" method was used.  This is incorrect");
    }

    m_selectedComponents.clear();

    // for each component that was added
    for (unsigned int x = 0; x < numComponents; x++)	{
    // --- get the relevant information
        CComPtr<IVssComponent> pComponent;
        hr = pComponents->GetComponent(x, &pComponent);
        checkReturn(hr, L"IVssWriterComponents::GetComponent");

        writeBackupMetadata(pComponent);    // --- write private metadata

        // --- find the component in the metadata document.
        // --- this component may actually be a supercomponent of something
        // --- listed in the metadata document, so we must handle that case.
        // --- this is no longer true with the new interface changes...  now, only components
        // --- in the metadata doc can be added
        ComponentBase identity(getPath(pComponent), getName(pComponent));
        WriterConfiguration::ComponentList::iterator found = 
                                            std::find(config->components().begin(), 
                                                         config->components().end(),
                                                         identity);
        if (found == config->components().end())    {
            wstringstream msg;
            msg << L"Component with logical path: " << identity.m_logicalPath <<
                        L"  and name: " << identity.m_name << L" was added to the document" << std::endl <<
                        L", but does not appear in the writer metadata";
            printStatus(msg.str());
        }   else if (!addableComponent(*found))  {   
            wstringstream msg;
            msg << L"Component with logical path: " << identity.m_logicalPath <<
                        L" and name: " << identity.m_name << L" was added to the document" << std::endl <<
                        L", but is not a selectable component";
            printStatus(msg.str());
        }   else    {
            m_selectedComponents.push_back(*found);
        }
    }

    // any non-selectable component with no selectable ancestor must be added.  Check this.
    vector<Component> mustAddComponents;
    buildContainer_if(config->components().begin(), 
                             config->components().end(), 
                             std::back_inserter(mustAddComponents), 
                             Utility::and1(std::not1(std::ptr_fun(isComponentSelectable)),
                                                std::ptr_fun(addableComponent)));

    vector<Component>::iterator currentMust = mustAddComponents.begin();
    while (currentMust != mustAddComponents.end())  {
        if (std::find(m_selectedComponents.begin(),
                          m_selectedComponents.end(),
                          *currentMust) == m_selectedComponents.end())  {
                          wstringstream msg;
                          msg << L"\nComponent with logical path: " << currentMust->m_logicalPath <<
                                      L" and name: " << currentMust->m_name <<
                                      L" is a non-selectable component with no selectable ancestor, and therefore " <<
                                      L" must be added to the document.  However, it was not added";
                          printStatus(msg.str());                          
        }
        ++currentMust;
    }
    
    return true;
}
catch(const exception& thrown)  
{
        printStatus(string("Failure in PrepareForBackup event: ") + thrown.what(), Utility::low);
    return false;
}
catch(HRESULT error)
{
    Utility::TestWriterException e(error);
    printStatus(e.what(), Utility::low);
    return false;
};

// This function is called after a requestor calls DoSnapshotSet
// Here we ensure that the requestor has added the appropriate volumes to the
// snapshot set.  If a spit directory is specified, the spit is done here as well.
bool STDMETHODCALLTYPE TestWriter::OnPrepareSnapshot()	
try
{
	enterEvent(Utility::PrepareForSnapshot);

	// build the list of all files being backed up
	vector<TargetedFile> componentFiles;
	std::pointer_to_binary_function<Component, std::back_insert_iterator<vector<TargetedFile> >, void>
	    ptrFun(buildComponentFiles);
	std::for_each(m_selectedComponents.begin(), 
		              m_selectedComponents.end(), 
                            std::bind2nd(ptrFun, std::back_inserter(componentFiles)));
	
	// for every file being backed up
	vector<TargetedFile>::iterator currentFile = componentFiles.begin();
	while (currentFile != componentFiles.end())	{
		// --- ensure the filespec has been snapshot, taking care of mount points
		if (!checkPathAffected(*currentFile))	{
			wstringstream msg;
			msg << L"Filespec " << currentFile->m_path << currentFile->m_filespec <<
				L"is selected for backup but contains files that have not been snapshot" << std::endl;
			printStatus(msg.str());
		}

		// --- if a spit is needed, spit the file to the proper directory
		if (!currentFile->m_alternatePath.empty())		
			spitFiles(*currentFile);
			
		++currentFile;
	}
		
	return true;
}	
catch(const exception& thrown)	
{
	printStatus(string("Failure in PrepareForSnapshot event: ") + thrown.what(), Utility::low);
	return false;
}
catch(HRESULT error)
{
	Utility::TestWriterException e(error);
	printStatus(e.what(), Utility::low);
	return false;
}

// This function is called after a requestor calls DoSnapshotSet
//  Currently, we don't do much here that is interesting.
bool STDMETHODCALLTYPE TestWriter::OnFreeze()
try	
{
	enterEvent(Utility::Freeze);

	return true;	
}	
catch(const exception& thrown)	
{
	printStatus(string("Failure in Freeze event: ") + thrown.what(), Utility::low);
	return false;
}
catch(HRESULT error)
{
	Utility::TestWriterException e(error);
	printStatus(e.what(), Utility::low);
	return false;
}

// This function is called after a requestor calls DoSnapshotSet
//  Currently, we don't do much here that is interesting.
bool STDMETHODCALLTYPE TestWriter::OnThaw()
try	
{
	enterEvent(Utility::Thaw);

	return true;	
}
catch(const exception& thrown)	
{
	printStatus(string("Failure in Thaw event: ") + thrown.what(), Utility::low);
	return false;
}
catch(HRESULT error)
{
	Utility::TestWriterException e(error);
	printStatus(e.what(), Utility::low);
	return false;
}

// This function is called after a requestor calls DoSnapshotSet
// Here we cleanup the files that were spit in OnPrepareSnapshot
// and do some basic sanity checking
bool STDMETHODCALLTYPE TestWriter::OnPostSnapshot(IN IVssWriterComponents *pComponents)
try	
{
	enterEvent(Utility::PostSnapshot);

	cleanupFiles();
	
	// get the number of components
	UINT numComponents = 0;
	HRESULT hr = pComponents->GetComponentCount(&numComponents);
	checkReturn(hr, L"IVssWriterComponents::GetComponentCount");

	// for each component that was added
	for (unsigned int x = 0; x < numComponents; x++)	{
		// --- get the relevant information		
		CComPtr<IVssComponent> pComponent;
		hr = pComponents->GetComponent(x, &pComponent);
		checkReturn(hr, L"IVssWriterComponents::GetComponent");
		
		// --- ensure that the component was backed up
		ComponentBase identity(getPath(pComponent), getName(pComponent));
		vector<Component>::iterator found = std::find(m_selectedComponents.begin(), 
												m_selectedComponents.end(),
												identity);
		if (found == m_selectedComponents.end())	{
			wstringstream msg;
			msg << L"Component with logical path: " << identity.m_logicalPath <<
				     L"and name: " << identity.m_name <<
				     L"was selected in PostSnapshot, but was not selected in PrepareForSnapshot";
			printStatus(msg.str(), Utility::low);
			
			continue;
		}

		if (!verifyBackupMetadata(pComponent))	{
			wstringstream msg;
			msg << L"Component with logical path: " << identity.m_logicalPath <<
				     L"and name: " << identity.m_name <<
				     L" has been corrupted in PostSnapshot";
			printStatus(msg.str(), Utility::low);			
		}
	}

	m_selectedComponents.clear();

	return true;	
}
catch(const exception& thrown)	
{
	printStatus(string("Failure in PostSnapshot event: ") + thrown.what(), Utility::low);
	return false;
}
catch(HRESULT error)
{
	Utility::TestWriterException e(error);
	printStatus(e.what(), Utility::low);
	return false;
}

// This function is called to abort the writer's backup sequence.
// If the writer has a spit component, spit files are cleaned up here.
bool STDMETHODCALLTYPE TestWriter::OnAbort()
try
{
	enterEvent(Utility::Abort);

	m_selectedComponents.clear();
	cleanupFiles();

	return true;
}
catch(const exception& thrown)	
{
	printStatus(string("Failure in Abort event: ") + thrown.what(), Utility::low);
	return false;
}
catch(HRESULT error)
{
	Utility::TestWriterException e(error);
	printStatus(e.what(), Utility::low);
	return false;
}

// This function is called as a result of the requestor calling BackupComplete
// Once again we do sanity checking, and we also verify that the metadata we 
// wrote in PrepareForBackup has remained the same
bool STDMETHODCALLTYPE TestWriter::OnBackupComplete(IN IVssWriterComponents *pComponents)
try	
{
	enterEvent(Utility::BackupComplete);
	
	WriterConfiguration* config = WriterConfiguration::instance();

	// get the number of components
	UINT numComponents = 0;
	HRESULT hr = pComponents->GetComponentCount(&numComponents);
	checkReturn(hr, L"IVssWriterComponents::GetComponentCount");

	// for each component that was added
	for (unsigned int x = 0; x < numComponents; x++)	{
		// --- get the relevant information		
		CComPtr<IVssComponent> pComponent;
		hr = pComponents->GetComponent(x, &pComponent);
		checkReturn(hr, L"IVssWriterComponents::GetComponent");
		
		// --- ensure that the component is valid
		ComponentBase identity(getPath(pComponent), getName(pComponent));
		WriterConfiguration::ComponentList::iterator found = 
								std::find(config->components().begin(), 
								   	      config->components().end(),
									      identity);
		if (found == config->components().end())	{
			wstringstream msg;
			msg << L"Component with logical path: " << identity.m_logicalPath <<
				     L"and name: " << identity.m_name <<
				     L" is selected in BackupComplete, but does not appear in the writer metadata";
			printStatus(msg.str(), Utility::low);
			
			continue;
		}

		if (!verifyBackupMetadata(pComponent))	{
			wstringstream msg;
			msg << L"Component with logical path: " << identity.m_logicalPath <<
				     L"and name: " << identity.m_name <<
				     L" has been corrupted in BackupComplete";
			printStatus(msg.str(), Utility::low);
			}	

		// check that the backup succeeded
		bool backupSucceeded = false;
		hr = pComponent->GetBackupSucceeded(&backupSucceeded);
		if (!backupSucceeded)	{
			wstringstream msg;
			msg << L"Component with logical path: " << identity.m_logicalPath <<
				     L"and name: " << identity.m_name <<
				     L" was not marked as successfully backed up.";
		}
	}

	return true;	
}	
catch(const exception& thrown)	
{
	printStatus(string("Failure in BackupComplete event: ") + thrown.what(), Utility::low);
	return false;
}
catch(HRESULT error)
{
	Utility::TestWriterException e(error);
	printStatus(e.what(), Utility::low);
	return false;
}

// This function is called at the end of the backup process.  This may happen as a result
// of the requestor shutting down, or it may happen as a result of abnormal termination 
// of the requestor.
bool STDMETHODCALLTYPE TestWriter::OnBackupShutdown(IN VSS_ID SnapshotSetId)
try
{
	UNREFERENCED_PARAMETER(SnapshotSetId);
	
	enterEvent(Utility::BackupShutdown);
	return true;
}
catch(const exception& thrown)
{
	printStatus(string("Failure in BackupShutdown event: ") + thrown.what(), Utility::low);
	return false;
}

// This function is called as a result of the requestor calling PreRestore
// We check that component selection has been done properly, verify the
// backup metadata, and set targets appropriately.
bool STDMETHODCALLTYPE TestWriter::OnPreRestore(IN IVssWriterComponents *pComponents)
try
{
    enterEvent(Utility::PreRestore);

    WriterConfiguration* config = WriterConfiguration::instance();

    // get the number of components
    UINT numComponents = 0;
    HRESULT hr = pComponents->GetComponentCount(&numComponents);
    checkReturn(hr, L"IVssWriterComponents::GetComponentCount");

    m_selectedRestoreComponents.clear();
    // for each component that was added
    for (unsigned int x = 0; x < numComponents; x++)    {
        // --- get the relevant information
        CComPtr<IVssComponent> pComponent;
        hr = pComponents->GetComponent(x, &pComponent);
        checkReturn(hr, L"IVssWriterComponents::GetComponent");
        
        // --- ensure that the component is valid
        ComponentBase identity(getPath(pComponent), getName(pComponent));
        WriterConfiguration::ComponentList::iterator found = 
                                                  std::find(config->components().begin(), 
                                                                config->components().end(), 
                                                                identity);
        if (found == config->components().end())    {
            wstringstream msg;
            msg << L"Component with logical path: " << identity.m_logicalPath <<
                         L"and name: " << identity.m_name <<
                         L" is selected in PreRestore, but does not appear in the writer metadata";

            pComponent->SetPreRestoreFailureMsg(msg.str().c_str());
            printStatus(msg.str(), Utility::low);
            continue;
        }

        // only process those component that are selected for restore
        bool selectedForRestore = false;
        hr = pComponent->IsSelectedForRestore(&selectedForRestore);
        checkReturn(hr, L"IVssComponent::IsSelectedForRestore");
        if (!selectedForRestore)
            continue;
        
        m_selectedRestoreComponents.push_back(*found);

        if (!verifyBackupMetadata(pComponent))  {       // --- verify the backup metadata
            wstringstream msg;
            msg << L"Component with logical path: " << identity.m_logicalPath <<
                         L"and name: " << identity.m_name <<
                         L" has been corrupted in PreRestore";
            pComponent->SetPreRestoreFailureMsg(msg.str().c_str());
            printStatus(msg.str(), Utility::low);
        }
        writeRestoreMetadata(pComponent);               // --- write restore metadata

        // --- set the target appropriately
        if (found->m_restoreTarget != VSS_RT_UNDEFINED) {
            HRESULT hr =pComponent->SetRestoreTarget(found->m_restoreTarget);
            checkReturn(hr, L"IVssComponent::SetRestoreTarget");

            printStatus(wstring(L"Set Restore Target: ") +
                      Utility::toString(found->m_restoreTarget), Utility::high);
        }
    }

    return true;
}
catch(const exception& thrown)
{
    printStatus(string("Failure in PreRestore event: ") + thrown.what(), Utility::low);
    return false;
}
catch(HRESULT error)
{
    Utility::TestWriterException e(error);
    printStatus(e.what(), Utility::low);
    return false;
}

// This function is called as a result of the requestor calling PreRestore
// We do some sanity checking, and then check to see if files have indeed
// been restored
bool STDMETHODCALLTYPE TestWriter::OnPostRestore(IN IVssWriterComponents *pComponents)
try
{
    enterEvent(Utility::PostRestore);    

    // get the number of components
    UINT numComponents = 0;
    HRESULT hr = pComponents->GetComponentCount(&numComponents);
    checkReturn(hr, L"IVssWriterComponents::GetComponentCount");

    // for each component 
    for (unsigned int x = 0; x < numComponents; x++)    {
        // --- get the relevant information
        CComPtr<IVssComponent> pComponent;
        hr = pComponents->GetComponent(x, &pComponent);
        checkReturn(hr, L"I VssWriterComponents::GetComponent");

        // --- ensure that the component is valid
        ComponentBase identity(getPath(pComponent), getName(pComponent));
        vector<Component>::iterator found = std::find(m_selectedRestoreComponents.begin(),
                                                                               m_selectedRestoreComponents.end(), 
                                                                               identity);
        if (found == m_selectedRestoreComponents.end()) {
            wstringstream msg;
            msg << L"Component with logical path: " << identity.m_logicalPath <<
                         L"and name: " << identity.m_name <<
                         L" is selected in PostRestore, but was not selected in PreRestore";
            pComponent->SetPostRestoreFailureMsg(msg.str().c_str());
            printStatus(msg.str(), Utility::low);
            continue;
        }

        // only process those component that are selected for restore
        bool selectedForRestore = false;
        hr = pComponent->IsSelectedForRestore(&selectedForRestore);
        checkReturn(hr, L"IVssComponent::IsSelectedForRestore");
        if (!selectedForRestore)
            continue;

        if (!verifyRestoreMetadata(pComponent)) {
            wstringstream msg;
            msg << L"Component with logical path: " << identity.m_logicalPath <<
                         L"and name: " << identity.m_name <<
                         L" has been corrupted in PostRestore";
            pComponent->SetPostRestoreFailureMsg(msg.str().c_str());
            printStatus(msg.str(), Utility::low);
            continue;
        }


        VSS_FILE_RESTORE_STATUS rStatus;
        hr = pComponent->GetFileRestoreStatus(&rStatus);
        checkReturn(hr, L"IVssComponent::GetFileRestoreStatus");

        if (rStatus != VSS_RS_ALL)  {
            wstringstream msg;
            msg << L"Component with logical path: " << identity.m_logicalPath <<
                         L"and name: " << identity.m_name <<
                         L" was not marked as having been successfully restored";
            printStatus(msg.str(), Utility::low);
            continue;
        }

        updateNewTargets(pComponent, *found);
        verifyFilesRestored(pComponent, *found);
    }

    return true;
}
catch(const exception& thrown)
{
    printStatus(string("Failure in PostRestore event: ") + thrown.what(), Utility::low);
    return false;
}
catch(HRESULT error)
{
    Utility::TestWriterException e(error);
    printStatus(e.what(), Utility::low);
    return false;
}

// This function is called at the entry to all writer events. 
// A status message is printed to the console, and the event is failed if necessary.
void TestWriter::enterEvent(Utility::Events event)
{
	static HRESULT errors[] = { VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT,
							VSS_E_WRITERERROR_OUTOFRESOURCES,
							VSS_E_WRITERERROR_TIMEOUT,
							VSS_E_WRITERERROR_RETRYABLE							 
						      };
	
	printStatus(wstring(L"\nReceived event: ") + Utility::toString(event));

	WriterConfiguration* config = WriterConfiguration::instance();

	// figure out whether we should fail this event
	WriterEvent writerEvent(event);
	WriterConfiguration::FailEventList::iterator found = std::find(config->failEvents().begin(), 
													     config->failEvents().end(),
											 		     writerEvent);

	// if so, then fail it unless failures have run out
	if (found != config->failEvents().end())	{		
		bool failEvent = !found->m_retryable || (m_failures[event] < found->m_numFailures);
		bool setFailure = inSequence(event);
		if (!found->m_retryable && setFailure)
			SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
		else if (failEvent && setFailure)
			SetWriterFailure(errors[rand() % (sizeof(errors) / sizeof(errors[0]))]);

		if (failEvent)	{
			++m_failures[event];
			wstringstream msg;
			msg << L"Failure Requested in Event: " << Utility::toString(event) <<
				L" Failing for the " << m_failures[event] << L" time";
			
			throw Utility::TestWriterException(msg.str());
		}
	}
}


// This helper function adds a component to the writer-metadata document
void TestWriter::addComponent(const Component& component, IVssCreateWriterMetadata* pMetadata)
{
	const wchar_t* logicalPath = component.m_logicalPath.empty() ? NULL : component.m_logicalPath.c_str();

	// add the component to the document
	HRESULT hr = pMetadata->AddComponent(component.m_componentType,		// ct
			 					                 logicalPath,							// logicalwszLogicalPath
					                			   component.m_name.c_str(),			// wszComponentName
					                			   NULL,								// wszCaption
					                			   NULL,								// pbIcon
 								                 0,									// cbIcon
								                 true,								// bRestoreMetadata
					       			          true,								// bNotifyOnBackupComplete
						                		   component.m_selectable,  			// bSelectable
						                		   component.m_selectableForRestore	// bSelectableForRestore
						                		   );
	checkReturn(hr, L"IVssCreateWriterMetadata::AddComponent");						                		   

	printStatus(L"\nAdded component: ", Utility::high);
	printStatus(component.toString(), Utility::high);

	// add all of the files to the component.  NOTE: we don't allow distinctions between database files
	// and database log files in the VSS_CT_DATABASE case.
	// we sometimes put a '\' on the end and sometimes not to keep requestors honest.
	Component::ComponentFileList::iterator current = component.m_files.begin();
	while (current != component.m_files.end())	{		
		if (component.m_componentType == VSS_CT_FILEGROUP)	{
			const wchar_t* alternate = current->m_alternatePath.empty() ? NULL : 
							              current->m_alternatePath.c_str();
			hr = pMetadata->AddFilesToFileGroup(logicalPath,
											  component.m_name.c_str(),
											  current->m_path.substr(0, current->m_path.size()-1).c_str(),
											  current->m_filespec.c_str(),
											  current->m_recursive,
											  alternate);
			checkReturn(hr, L"IVssCreateWriterMetadata::AddFilesToFileGroup");
		}    else if (component.m_componentType == VSS_CT_DATABASE)	{
			hr = pMetadata->AddDatabaseFiles(logicalPath,
										     component.m_name.c_str(),
										     current->m_path.c_str(),
										     current->m_filespec.c_str());
			checkReturn(hr, L"IVssCreateWriterMetadata::AddDatabaseFiles");
										     
		}	else		{
			assert(false);
		}
		
		printStatus(L"\nAdded Component Filespec: ");
		printStatus(current->toString());
		
		++current;
	}

    // add all dependencies to the dependency list for the writer
    Component::DependencyList::iterator currentDependency = component.m_dependencies.begin();
    while (currentDependency != component.m_dependencies.end())	{
        hr = pMetadata->AddComponentDependency(logicalPath, 
                                                                                  component.m_name.c_str(),                           // wszForLogicalPath
                                                                                  currentDependency->m_writerId,                  // wszForComponentName
                                                                                  currentDependency->m_logicalPath.c_str(),             // wszOnLogicalPath
                                                                                  currentDependency->m_componentName.c_str()    // wszOnComponentName
                                                                            );
		checkReturn(hr, L"IVssCreateWriterMetadata::AddComponentDependency");

		printStatus(L"\nAdded Component Dependency: ");
		printStatus(currentDependency->toString());
		
		++currentDependency;
	}
}

// This helper function spits all files in a file specification to an alternate location
void TestWriter::spitFiles(const TargetedFile& file)
{
	assert(!file.m_path.empty());
	assert(file.m_path[file.m_path.size() - 1] == L'\\');
	assert(!file.m_alternatePath.empty());
	assert(file.m_alternatePath[file.m_alternatePath.size() - 1] == L'\\');

	// ensure that both the source and target directories exist
	DWORD attributes = ::GetFileAttributes(file.m_path.c_str());
	if ((attributes == INVALID_FILE_ATTRIBUTES) ||
	     !(attributes & FILE_ATTRIBUTE_DIRECTORY))	{
		wstringstream msg;
		msg << L"The source path " << file.m_path << L" does not exist";
		throw Utility::TestWriterException(msg.str());
	}

	attributes = ::GetFileAttributes(file.m_alternatePath.c_str());
	if ((attributes == INVALID_FILE_ATTRIBUTES) ||
	    !(attributes & FILE_ATTRIBUTE_DIRECTORY))	{
		wstringstream msg;
		msg << L"The target path " << file.m_alternatePath << L" does not exist";
		throw Utility::TestWriterException(msg.str());
	}

	// start by copying files from the specified root directory
	std::queue<wstring> paths;
	paths.push(file.m_path);

	// walk through in breadth-first order.  It's less resource intensive than depth-first, and
	// potentially more performant
	while (!paths.empty())	{
		// --- grab the next path off the queue
		wstring currentPath = paths.front();
		paths.pop();

		// --- start walking all files in the directory
		WIN32_FIND_DATA findData;
		Utility::AutoFindFileHandle findHandle = ::FindFirstFile((currentPath + L'*').c_str(), &findData);
		if (findHandle == INVALID_HANDLE_VALUE)
			continue;

		do	{
			wstring currentName = findData.cFileName;
			if (currentName == L"." ||
			     currentName == L"..")
			     continue;
			
			std::transform(currentName.begin(), currentName.end(), currentName.begin(), towupper);

			// --- if we've hit a direcctory and we care to do a recursive spit
			if ((findData.dwFileAttributes  & FILE_ATTRIBUTE_DIRECTORY) &&
			     file.m_recursive)	{
				assert(!currentName.empty());
				if (currentName[currentName.size() - 1] != L'\\')
					currentName += L"\\";

				// figure out where the target for this new directory is
				assert(currentPath.find(file.m_path) == 0);
				wstring extraDirectory = currentPath.substr(file.m_path.size());
				wstring alternateLocation = file.m_alternatePath + extraDirectory + currentName;

			       // create a target directory to hold the copied files.  
				if (!::CreateDirectory(alternateLocation.c_str(), NULL) &&
					::GetLastError() != ERROR_ALREADY_EXISTS)
					checkReturn(HRESULT_FROM_WIN32(::GetLastError()), L"CreateDirectory");

                            m_directoriesToRemove.push(alternateLocation.c_str());
                            
			       // push the directory on the queue so it gets processed as well
				paths.push(currentPath + currentName);
				continue;			   
			}

			// --- if we've hit a regular file with a matching filespec
			if (!(findData.dwFileAttributes  & FILE_ATTRIBUTE_DIRECTORY) && 
				wildcardMatches(currentName, file.m_filespec))	{
				// figure out where the new target location is
				assert(currentPath.find(file.m_path) == 0);
				wstring extraDirectory = currentPath.substr(file.m_path.size());
				wstring alternateLocation = file.m_alternatePath + extraDirectory + currentName;

				wstringstream msg;
				msg << L"Spitting File: " << currentPath + currentName <<
					     L" To location: " <<  alternateLocation;
				printStatus(msg.str() , Utility::high);

				// copy the file over
				if (!::CopyFile((currentPath + currentName).c_str(), alternateLocation.c_str(), FALSE))
					checkReturn(HRESULT_FROM_WIN32(::GetLastError()), L"CopyFile");
				else
					m_toDelete.push_back(alternateLocation);
			}
		}	while (::FindNextFile(findHandle, &findData));
	}
}

// extract the component name from an interface pointer
wstring TestWriter::getName(IVssComponent* pComponent)
{
    CComBSTR name;
    HRESULT hr = pComponent->GetComponentName(&name);
    checkReturn(hr, L"IVssComponent::GetComponentName");

    assert(name != NULL);       // this should never happen

    return (BSTR)name;
}

// extract the component logical path from an interface pointer
wstring TestWriter::getPath(IVssComponent* pComponent)
{
    CComBSTR path;
    HRESULT hr = pComponent->GetLogicalPath(&path);
    checkReturn(hr, L"IVssComponent::GetLogicalPath");

    // GetLogicalPath can indeed return NULL so be careful
    return (path.Length() > 0) ? (BSTR)path : L"";
}

// write a backup metadata stamp to the component
void TestWriter::writeBackupMetadata(IVssComponent* pComponent)
{
    HRESULT hr = pComponent->SetBackupMetadata(metadata(pComponent, BackupString).c_str());
    checkReturn(hr, L"IVssComponent::SetBackupMetadata");	

    printStatus(wstring(L"Writing backup metadata: ") + metadata(pComponent, BackupString),
                   Utility::high);
}

// verify that a backup metadata stamp is intact
bool TestWriter::verifyBackupMetadata(IVssComponent* pComponent)
{
    CComBSTR data;
    HRESULT hr = pComponent->GetBackupMetadata(&data);
    checkReturn(hr, L"IVssComponent::GetBackupMetadata");

    printStatus(wstring(L"\nComparing metadata: ") + (data.Length() ? (BSTR)data : L"") +
                     wstring(L" Against expected string: ") + metadata(pComponent, BackupString),
                      Utility::high);

    if (data.Length() == 0 || metadata(pComponent, BackupString) != (BSTR)data)
        return false;

    return true;
}

// write a restore metadata stamp to the component
void TestWriter::writeRestoreMetadata(IVssComponent* pComponent)
{
    HRESULT hr = pComponent->SetRestoreMetadata(metadata(pComponent, RestoreString).c_str());
    checkReturn(hr, L"IVssComponent::SetRestoreMetadata");

    printStatus(wstring(L"Writing restore metadata: ") + metadata(pComponent, RestoreString),
                      Utility::high);
}

// verify that a restore metadata stamp is intact
bool TestWriter::verifyRestoreMetadata(IVssComponent* pComponent)
{
	CComBSTR data;
	HRESULT hr = pComponent->GetRestoreMetadata(&data);
	checkReturn(hr, L"IVssComponent::GetRestoreMetadata");

	printStatus(wstring(L"Comparing metadata: ") + (data.Length() ? (BSTR)data : L"") +
		          wstring(L" Against expected string: ") + metadata(pComponent, RestoreString),
		          Utility::high);

	if (data.Length() == 0 || metadata(pComponent, RestoreString) != (BSTR)data)
		return false;

	return true;
}

// check to see if the specified file (or files) are all in the current snapshot set
// doesn't check directory junctions... this will not be changed anytime soon.
// recursive mount points are also not handled very well
bool TestWriter::checkPathAffected(const TargetedFile& file)
{
	wstring backupPath = file.m_alternatePath.empty() ? file.m_path : file.m_alternatePath;
	
	// if the path in question isn't snapshot, then return false
	if (!IsPathAffected(backupPath.c_str()))
		return false;

	// if the filespec isn't recursive, then we're done
	if (!file.m_recursive)
		return true;

	// get the name of the volume we live on
	wchar_t volumeMount[MAX_PATH];
       if(!::GetVolumePathName(backupPath.c_str(), volumeMount, MAX_PATH))
       	checkReturn(HRESULT_FROM_WIN32(::GetLastError()), L"GetVolumePathName");
	assert(backupPath.find(volumeMount) == 0);
		
	wchar_t volumeName[MAX_PATH];
	if (!::GetVolumeNameForVolumeMountPoint(volumeMount, volumeName, MAX_PATH))
		checkReturn(HRESULT_FROM_WIN32(::GetLastError()), L"GetVolumeNameForVolumeMountPoint");

	// start off with the volume name and starting directory on a worklist.
	std::queue<std::pair<wstring, wstring> > worklist;
	worklist.push(std::make_pair(wstring(volumeName), backupPath.substr(wcslen(volumeMount))));

	while (!worklist.empty())	{
		// get the current volume and directory off the worklist
		wstring currentVolume = worklist.front().first;
		wstring currentPath = worklist.front().second;
		worklist.pop();
		
		// now, enumerate all mount points on the volume
	       Utility::AutoFindMountHandle findHandle = ::FindFirstVolumeMountPoint(currentVolume.c_str(), volumeMount, MAX_PATH);
       	if (findHandle == INVALID_HANDLE_VALUE)
       		continue;

	       do	{
			std::transform(volumeMount, volumeMount + wcslen(volumeMount), volumeMount, towupper);
		   	
       		wstring mountPoint = currentVolume + volumeMount;
			
	       	// if this mount point is included in the file specification, the volume better be included in the snapshot set
       		if ((mountPoint.find(currentVolume + currentPath) == 0) &&
       		    !IsPathAffected(mountPoint.c_str()))
	       	    return false;

			if (!::GetVolumeNameForVolumeMountPoint(volumeMount, volumeName, MAX_PATH))
				checkReturn(HRESULT_FROM_WIN32(::GetLastError()), L"GetVolumeNameForVolumeMountPoint");

			// put this volume on the worklist so it gets processed as well
			// Mount points always point to the root of a volume, so pass in 
			// an empty second argument.  When junctions are supported, we
			// will pass in the target directory as the second argument.
       		worklist.push(std::make_pair(wstring(volumeName), wstring()));	// this line will change when we support junctions	
	       }	while (::FindNextVolumeMountPoint(findHandle, volumeMount, MAX_PATH) == TRUE);
	}

	return true;
}

// delete all files and directories created in PrepareForSnapshot
void TestWriter::cleanupFiles()
{
       // delete all created files
    vector<wstring>::iterator currentFile = m_toDelete.begin();
    while (currentFile != m_toDelete.end()) {
        if (!::DeleteFile(currentFile->c_str()))
            warnReturn(HRESULT_FROM_WIN32(::GetLastError()), L"DeleteFile");

        ++currentFile;
    }
    m_toDelete.clear();

    // remove all created directories in the proper order
    while (!m_directoriesToRemove.empty())    {
        wstring dir = m_directoriesToRemove.top();
        if (!::RemoveDirectory(dir.c_str()))
            warnReturn(HRESULT_FROM_WIN32(::GetLastError()), L"RemoveDirectory");

        m_directoriesToRemove.pop();
    }
}

// check to see if the requestor has added any new targets, and add them to the
// Component structure
void TestWriter::updateNewTargets(IVssComponent* pComponent, Component& writerComponent)
{
    HRESULT hr = S_OK;

    UINT newTargetCount = 0;
    hr = pComponent->GetNewTargetCount(&newTargetCount);
    checkReturn(hr, L"IVssComponent::GetNewTargetCount");
    
    writerComponent.m_newTargets.clear();
    for (UINT x = 0; x < newTargetCount; x++)   {
        // get information about the new target
        CComPtr<IVssWMFiledesc> newTarget;

        hr = pComponent->GetNewTarget(x, &newTarget);
        checkReturn(hr, L"IVssComponent::GetNewTarget");

        CComBSTR path, filespec, alternateLocation;
        bool recursive = false;

        hr = newTarget->GetPath(&path);
        checkReturn(hr, L"IVssComponent:GetPath");
        
        hr = newTarget->GetFilespec(&filespec);
        checkReturn(hr, L"IVssComponent:GetFilespec");

        hr = newTarget->GetRecursive(&recursive);
        checkReturn(hr, L"IVssComponent:GetRecursive");

        hr = newTarget->GetAlternateLocation(&alternateLocation);
        checkReturn(hr, L"IVssComponent:GetAlternateLocation");

        // add it to the new-target list
        writerComponent.m_newTargets.push_back(TargetedFile(wstring(path), 
                                                                                              wstring(filespec), 
                                                                                              recursive, 
                                                                                              wstring(alternateLocation)));
    }
}

// verify that files in the component were restored properly.
// assumption is that the directory being restored to is empty if the checkExcluded parameter is true.
// currently, we have a very simple-minded approach to handle the wildcard case
// a more general solution will involve hashing files, and will be implemented if time is found
void TestWriter::verifyFilesRestored(IVssComponent* pComponent, const Component& writerComponent)
{
    WriterConfiguration* config = WriterConfiguration::instance();

    // no checking is being done.  Don't do anything
    if (!config->checkIncludes() && !config->checkExcludes())
        return;

    // for each file in the component
    VSS_RESTORE_TARGET target = writerComponent.m_restoreTarget;
    VSS_RESTOREMETHOD_ENUM method = config->restoreMethod().m_method;

    // build the list of all filespecs that need restoring
    vector<TargetedFile> componentFiles;
    buildComponentFiles(writerComponent, std::back_inserter(componentFiles));

    for (vector<TargetedFile>::iterator currentFile = componentFiles.begin();
            currentFile != componentFiles.end();
            ++currentFile)  {
            // --- figure out if there are any matching exclude files
            vector<File> excludeFiles;
           if (config->checkExcludes()) {
               buildContainer_if(config->excludeFiles().begin(),
                                         config->excludeFiles().end(),
                                         std::back_inserter(excludeFiles),
                                         std::bind2nd(std::ptr_fun(targetMatches), *currentFile));
            }
   
        // if there's no checking to be done for this filespec, continue
        if (excludeFiles.empty() && !config->checkIncludes())
            continue;

        // --- if there are new targets, look for one that references our file
        // --- if we find such a target, ensure that the file was restored there
        // --- NOTE: after the interface changes, there should be at most one matching
        // --- target. 
        
        vector<TargetedFile> targets;
        buildContainer_if(writerComponent.m_newTargets.begin(),
                                  writerComponent.m_newTargets.end(),
                                  std::back_inserter(targets),
                                  std::bind2nd(std::equal_to<File>(), *currentFile));

        if (targets.size() > 1) {
            wstringstream msg;
            msg << L"More than one new target matched filespec " <<
                        currentFile->toString() << std::endl << L"This is an illegal configuration";
            
            printStatus(msg.str());
        }

        if (!targets.empty()) {
            // create a function object to use for verification 
            VerifyFileAtLocation locationChecker(excludeFiles, pComponent, false);

            locationChecker(targets[0], *currentFile);      // TODO:  no longer need this fancy functor, since we're not doing a for_each
        }

        vector<TargetedFile> alternateLocations;
        buildContainer_if(config->restoreMethod().m_alternateLocations.begin(),
                                 config->restoreMethod().m_alternateLocations.end(),
                                 std::back_inserter(alternateLocations),
                                 std::bind2nd(std::equal_to<File>(), *currentFile));

        // --- NOTE: once again, interface changes mean we expect at most one
        assert(alternateLocations.size() <= 1);

        bool alternateRestore = !alternateLocations.empty() &&
            ((target == VSS_RT_ALTERNATE) || (method == VSS_RME_RESTORE_TO_ALTERNATE_LOCATION));
        
        if ((method == VSS_RME_RESTORE_IF_CAN_REPLACE) ||
            (method == VSS_RME_RESTORE_IF_NOT_THERE) ||
            alternateRestore)  {
            // --- in all of these cases, the backup application may restore to an alternate location.  

            // if we're not in either of the following two states, then the alternate location should only be used if there's
            // a matching element in the backup document.  Check to see if this is true
            // create a function object to use for verification 
            // TODO: we no longer need this fancy functor object since we're not doing a for_each
            if (!alternateLocations.empty())    {
                VerifyFileAtLocation locationChecker(excludeFiles, pComponent, 
                (target != VSS_RT_ALTERNATE) && (method != VSS_RME_RESTORE_TO_ALTERNATE_LOCATION));

                // check to ensure that the file has been restored to each matching alternate location
                // once again, this isn't quite correct, but good enough for now. More complicated
                // test scenarios will eventually break this.
                locationChecker(alternateLocations[0], *currentFile);
                }
        }

        // none of the above cases are true.  We need to check to see that the file is restored to its original location
        if ((method != VSS_RME_RESTORE_AT_REBOOT) && (method != VSS_RME_RESTORE_AT_REBOOT_IF_CANNOT_REPLACE) &&
             !alternateRestore)   {
        // create a function object to use for verification 
        VerifyFileAtLocation locationChecker(excludeFiles, pComponent, false);

        locationChecker(TargetedFile(currentFile->m_path, 
                                                   currentFile->m_filespec, 
                                                   currentFile->m_recursive, 
                                                   currentFile->m_path), 
                                                   *currentFile);
        }
    }
}


bool __cdecl TestWriter::isSubcomponent(ComponentBase sub, ComponentBase super)
{
    // if the components are the same, then return true
    if (super == sub)
        return true;

    wstring path = super.m_logicalPath;
    if (!path.empty() && path[path.size()  - 1] != L'\\')
        path+= L"\\";

    path += super.m_name;

    // if the supercomponent full path is the same as the subcomponent logical path, then true
    if (path == sub.m_logicalPath)
        return true;

    // otherwise, check for partial match
    return sub.m_logicalPath.find(path + L"\\") == 0;
}


bool  __cdecl TestWriter::targetMatches (File target, File file)
{
	assert(!file.m_filespec.empty());
	assert(!target.m_filespec.empty());
	
	// the filespec must match first of all
	if (!wildcardMatches(file.m_filespec, target.m_filespec))
		return false;

	// check the path
	if (file.m_recursive)	{
		if (!target.m_recursive)
			return target.m_path.find(file.m_path) == 0;
		else 
			return (target.m_path.find(file.m_path) == 0) ||(file.m_path.find(target.m_path) == 0);
	}	else	 	{
		if (!target.m_recursive)
			return file.m_path == target.m_path;
		else
			return file.m_path.find(target.m_path) == 0;
	}
}

// This helper function tests whether a component can be legally added to the backup document
bool __cdecl TestWriter::addableComponent(Component toAdd)
{
    WriterConfiguration* config = WriterConfiguration::instance();
    
    if (toAdd.m_selectable)
        return true;

    // see if there are any selectable ancestors
    vector<Component> ancestors;
    buildContainer_if(config->components().begin(),       
                              config->components().end(), 
                              std::back_inserter(ancestors), 
                              Utility::and1(std::bind2nd(std::ptr_fun(isSupercomponent), toAdd),
                                                 std::ptr_fun(isComponentSelectable)));

    return ancestors.empty();
}

// check to see if two wildcards match. 
// specifically, check to see whether the set of expansions of the first wildcard has a
// non-empty intersection with the set of expansions of the second wildcard.
// This function is not terribly efficient, but wildcards tend to be fairly short.
bool TestWriter::wildcardMatches(const wstring& first, const wstring& second)
{
	// if both string are empty, then they surely match
	if (first.empty() && second.empty())
		return true;

	// if we're done with the component, the wildcard better be terminated with '*' characters
	if (first.empty())	
		return (second[0] == L'*') && wildcardMatches(first, second.substr(1));
	if (second.empty())
		return (first[0] == L'*') && wildcardMatches(first.substr(1), second);	
	
	switch(first[0])	{
		case L'?':
			if (second[0] == L'*')	{
			      return wildcardMatches(first.substr(1), second) ||  // '*' matches character
				          wildcardMatches(first, second.substr(1));	// '*' matches nothing
			}

			// otherwise, the rest of the strings must match			
			return wildcardMatches(first.substr(1), second.substr(1));
		case L'*':
			return wildcardMatches(first, second.substr(1)) || // '*' matches character
				    wildcardMatches(first.substr(1), second);    // '*' matches nothing
		default:
			switch(second[0])	{
				case L'?':
					return wildcardMatches(first.substr(1), second.substr(1));
				case L'*':
					return wildcardMatches(first.substr(1), second) || // '*' matches character
						    wildcardMatches(first, second.substr(1));    // '*' matches nothing
				default:
					return (first[0] == second[0]) &&
						     wildcardMatches(first.substr(1), second.substr(1));
			}
	}
}

wstring TestWriter::VerifyFileAtLocation::verifyFileAtLocation(const File& file, const TargetedFile& location) const
{
    WriterConfiguration* config = WriterConfiguration::instance();

    // complicated set of assertions.  
    assert(!(file.m_recursive && !location.m_recursive) ||
               (location.m_path.find(file.m_path) == 0));
    assert(!(location.m_recursive && !file.m_recursive) ||
            (file.m_path.find(location.m_path) == 0));
    assert(!(file.m_recursive && location.m_recursive) ||
            ((file.m_path.find(location.m_path) == 0) || (location.m_path.find(file.m_path) == 0)));
    assert(!m_excluded.empty() || config->checkIncludes());
    assert(m_excluded.empty() || config->checkExcludes());
    
    // performant case where we don't have to walk any directory trees
    if (!file.m_recursive && !location.m_recursive && isExact(file.m_filespec)) {
        assert(m_excluded.size() <=  1);        // if not, the config file isn't set up right

        // --- if this is an alternate location mapping, only process it if there's a matching alternate location
        // --- in the backup document
        if (m_verifyAlternateLocation &&
             !verifyAlternateLocation(TargetedFile(file.m_path, file.m_filespec, false, location.m_alternatePath))) {
            return L"";
        }

        // --- ensure that the file has been restored, unless the file is excluded
        printStatus(wstring(L"\nChecking file ") +
                        location.m_alternatePath + file.m_filespec,
                        Utility::high);

        // check for error cases
        if (m_excluded.empty()) {
            if (::GetFileAttributes((location.m_alternatePath + file.m_filespec).c_str()) == INVALID_FILE_ATTRIBUTES)   {
                wstringstream msg;
                msg << L"\nThe file: " << std::endl << file.toString() << std::endl <<
                L"was not restored to location " << location.m_alternatePath;
                printStatus(msg.str(), Utility::low);

                return msg.str();
            }
        }   else if (::GetFileAttributes((location.m_alternatePath + file.m_filespec).c_str()) != INVALID_FILE_ATTRIBUTES)  {
                wstringstream msg;
                msg << L"\nThe file: " << file.m_path << file.m_filespec << 
                L" should have been excluded, but appears in location " << location.m_alternatePath;
                printStatus(msg.str(), Utility::low);

                return msg.str();
        }

        return L"";
    }

    std::queue<wstring> paths;

    // figure out what directory to start looking from
    wstring startPath = location.m_alternatePath;
    if (location.m_recursive && (file.m_path.find(location.m_path) == 0))
        startPath += file.m_path.substr(location.m_path.size());

    paths.push(startPath);

    // in the recursive case, files will hopefully be backed up high in the directory tree
    // consequently, we're going to walk the tree breadth-first
    printStatus(L"\nChecking that filespec was restored:", Utility::high);
    while (!paths.empty())  {
        wstring currentPath = paths.front();
        paths.pop();

        printStatus(wstring(L"      Checking directory: ") + currentPath, 
                        Utility::high);

        // for every file in the current directory (can't pass in filespec since we want to match all directories)
        WIN32_FIND_DATA findData;
        Utility::AutoFindFileHandle findHandle = ::FindFirstFile((currentPath + L"*").c_str(), &findData);
        if (findHandle == INVALID_HANDLE_VALUE)
            continue;

        do  {
            wstring currentName = findData.cFileName;
            std::transform(currentName.begin(), currentName.end(), currentName.begin(), towupper);

            if (currentName == L"." ||
            currentName == L"..")
                continue;

            // --- if the file is a directory
            if  (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)  {
                assert(!currentName.empty());
                if (currentName[currentName.size() - 1] != L'\\')
                    currentName += L"\\";

                // add it if necessary
                if (file.m_recursive)
                    paths.push(currentPath + currentName);

                    continue;       // skip to next file
            }

            printStatus(wstring(L"          Checking file: ") + currentName);

            // --- translate the path to what it would have been in the original tree
            assert(currentPath.find(location.m_alternatePath) == 0);
            wstring originalPath = file.m_path;
            if (file.m_recursive && (location.m_path.find(file.m_path) == 0))
                originalPath += location.m_path.substr(file.m_path.size());
            originalPath += currentPath.substr(location.m_alternatePath.size());

            // --- if this is an alternate location mapping, only process it if there's a matching 
            // --- alternate location mapping in the backup document
            if (m_verifyAlternateLocation &&
                !verifyAlternateLocation(TargetedFile(originalPath, currentName, false, currentPath)))	{	
                continue;
            }

            // --- find an exclude item that matches
            // --- if !config->checkExcluded(), m_excluded will be an empty container, and
            // --- std::find_if will return the end iterator
            vector<File>::const_iterator found = 
                    std::find_if(m_excluded.begin(), 
                                     m_excluded.end(),
                                     std::bind2nd(std::ptr_fun(targetMatches), File(originalPath, currentName, false)));

            // --- return if this is either an excluded file, or if we've found at least one matching include file
            if (found != m_excluded.end())  {
                wstringstream msg;
                msg << L"The file " << originalPath << currentName <<
                            L" should have been excluded, but appears in location " << currentPath;
                printStatus(msg.str(), Utility::low);

                return msg.str();
            }    else if (config->checkIncludes() &&
                              wildcardMatches(currentName, file.m_filespec))    {
                return L"";                             // declare success in cheesy case
            }

        }   while (::FindNextFile(findHandle, &findData));
    }

    if (config->checkIncludes())    {
        wstringstream msg;
        msg << L"None of the files specified by " << std::endl << file.toString() << std::endl <<
             L" were restored to location " << location.m_alternatePath;
        printStatus(msg.str(), Utility::low);
        return msg.str();
    }

    // we're only checking excludes, and we didn't find any violations
        return L"";
}


// verify that an alternate location mapping appears in the backup document
bool TestWriter::VerifyFileAtLocation::verifyAlternateLocation(const TargetedFile& writerAlt) const
{
	assert (isExact(writerAlt.m_filespec));
	assert(!writerAlt.m_recursive);
	
	unsigned int mappings = 0;
	HRESULT hr = m_pComponent->GetAlternateLocationMappingCount(&mappings);
	checkReturn(hr, L"IVssComponent::GetAlternateLocationMappingCount");

	for (unsigned int x = 0; x < mappings; x++)	{
		// get the current alternate location mapping
		CComPtr<IVssWMFiledesc> filedesc;
		hr = m_pComponent->GetAlternateLocationMapping(x, &filedesc);
		checkReturn(hr, L"IVssComponent::GetAlternateLocationMapping");

		// grab all relevant fields
		CComBSTR bstrPath, bstrFilespec, bstrAlternateLocation;

		hr  = filedesc->GetPath(&bstrPath);
		checkReturn(hr, L"IVssComponent::GetPath");
		if (bstrPath.Length() == 0)	{
			printStatus(L"An Alternate Location Mapping with an empty path was added to the backup document", 
			Utility::low);
			continue;
		}
				
		hr = filedesc->GetFilespec(&bstrFilespec);
		checkReturn(hr, L"IVssComponent::GetFilespec");
		if (bstrFilespec.Length() == 0)	{
			printStatus(L"An Alternate Location Mapping with an empty filespec was added to the backup document", 
			Utility::low);
			continue;
		}


		hr = filedesc->GetAlternateLocation(&bstrAlternateLocation);
		checkReturn(hr, L"IVssComponent::GetAlternateLocation");
		if (bstrAlternateLocation.Length() == 0)	{
			printStatus(L"An Alternate Location Mapping with an empty alternateLocation was added to the backup document", 
			Utility::low);
			continue;
		}

		bool recursive;
		hr = filedesc->GetRecursive(&recursive);
		checkReturn(hr, L"IVssComponent::GetRecursive");

		// convert the fields to uppercase and ensure paths are '\' terminated
		wstring path = bstrPath;
		std::transform(path.begin(), path.end(), path.begin(), towupper);
		if (path[path.size() - 1] != L'\\')
			path += L'\\';
		
		wstring filespec = bstrFilespec;
		std::transform(filespec.begin(), filespec.end(), filespec.begin(), towupper);

		wstring alternatePath = bstrAlternateLocation;
		std::transform(alternatePath.begin(), alternatePath.end(), alternatePath.begin(), towupper);
		
		if (alternatePath[alternatePath.size() - 1] != L'\\')
			alternatePath += L'\\';

		// check to see if that passed-in mapping is encompassed by the one in the backup document
		if (targetMatches(File(path, filespec, recursive), writerAlt))	{
			if (recursive)	{
				if (writerAlt.m_alternatePath.find(alternatePath) != 0)
					return false;

				assert(writerAlt.m_path.find(path) == 0);
				alternatePath += writerAlt.m_path.substr(path.size());
			}

			return alternatePath == writerAlt.m_alternatePath;
		}
	}

	return false;
}
// add the current error message to the PostRestoreFailureMsg
void TestWriter::VerifyFileAtLocation::saveErrorMessage(const wstring& message) const
{
	if (!message.empty())	{
		CComBSTR old;
		m_pComponent->GetPostRestoreFailureMsg(&old);
		wstring oldMessage = (old.Length() > 0) ? (BSTR)old : L"";
		m_pComponent->SetPostRestoreFailureMsg((oldMessage + wstring(L"\n") + message).c_str());					
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\writer\utility.cpp ===
/*
**++
**
** Copyright (c) 2002  Microsoft Corporation
**
**
** Module Name:
**
**	    utility.cpp
**
**
** Abstract:
**
**	defines functions and variable used by the Test writer
**
** Author:
**
**	Reuven Lax      [reuvenl]       04-June-2002
**
**
**
** Revision History:
**
**--
*/

////////////////////////////////////////////////////////////////////////
// Includes

#include "stdafx.h"
#include "utility.h"
#include "writerconfig.h"
#include "vs_xml.hxx"
#include "msxml2.h"
#include <string>
#include <sstream>
using std::wstring;

void Utility::missingAttribute(const wchar_t* name)
{
	wstring thrown(L"The attribute ");
	thrown += name;
	thrown += L" was omitted from the XML document";
	
	throw Utility::TestWriterException(thrown);
}

void Utility::missingElement(const wchar_t* name)
{
	wstring thrown(L"The  element ");
	thrown += name;
	thrown += L" was omitted from the XML document";
	throw Utility::TestWriterException(thrown);
}

void Utility::checkReturn(HRESULT returnCode, wstring function)
{
	if (FAILED(returnCode))	
		throw Utility::TestWriterException(returnCode, function);
}

void Utility::warnReturn(HRESULT returnCode, wstring function)
{
	if (FAILED(returnCode))	{
		Utility::TestWriterException ex(returnCode, function);
		printf("%s\n", ex.what());
	}
}

void Utility::parseError(const CXMLDocument& doc)
{
	CComBSTR reason, text;
	CComPtr<IXMLDOMParseError> parseError;
	HRESULT hr = doc.GetInterface()->get_parseError(&parseError);
	checkReturn(hr, L"IXMLDOMDocument::get_parseError");

	wstring thrown;
	if (parseError != NULL)	{
		hr = parseError->get_reason(&reason);
		checkReturn(hr, L"IXMLDOMParseError::get_reason");
		hr = parseError->get_srcText(&text);
		checkReturn(hr, L"IXMLDOMParseError::get_srcText");

		thrown = L"Failed to load configuration file:\n";
		thrown += L" Reason: " ;
		thrown += reason;
		thrown += L"\n Source Text:\n  " ;
		thrown += text;
	}	else		{
		thrown = L"Failed to load configuration file.";
	}

	throw Utility::TestWriterException(thrown);	
}

// this function better not throw exceptions
void Utility::printStatus(const wstring& status, Utility::Verbosity level)
try
{
	// if level == low, then we may be in exception-handling code.  Don't dare use
	// the configuration object in that case
	WriterConfiguration* config = WriterConfiguration::instance();
	if (level == Utility::low || level <= config->verbosity())
		wprintf(L"%s\n", status.c_str());
}
catch(const std::exception&)
{
	wprintf(L"Internal Error: an unexpected error happened in printStatus\n");
	wprintf(L"We were trying to print the following message: %s\n", status.c_str());
}

void Utility::printStatus(const std::string& status, Verbosity level)
try
{
	// if level == low, then we may be in exception-handling code.  Don't dare use
	// the configuration object in that case
	WriterConfiguration* config = WriterConfiguration::instance();
	if (level == Utility::low || level <= config->verbosity())
		printf("%s\n", status.c_str());
}
catch(const std::exception& exception)	
{
	printf("Internal Error: an unexpected error happened in printStatus\n");
	printf("the error is the following\n\t%s\n", exception.what());
	printf("We were trying to print the following message: %s\n", status.c_str());	
}

bool Utility::toBoolean(const wchar_t* name)
{
	assert(!wcscmp(name, L"yes") || !wcscmp(name, L"no"));
	return (wcscmp(name, L"yes") == 0) ? true : false;
}

VSS_USAGE_TYPE Utility::toUsage(const wchar_t* name)
{
	if (wcscmp(name, L"BOOTABLE_SYSTEM_STATE") == 0)
		return VSS_UT_BOOTABLESYSTEMSTATE;
	else if (wcscmp(name, L"SYSTEM_SERVICE") == 0)
		return VSS_UT_SYSTEMSERVICE;
	else if (wcscmp(name, L"USER_DATA") == 0)
		return VSS_UT_USERDATA;
	else if (wcscmp(name, L"OTHER") == 0)		
		return VSS_UT_OTHER;
	else
		assert(false);

	return VSS_UT_UNDEFINED;
}

VSS_RESTOREMETHOD_ENUM Utility::toMethod(const wchar_t* name)
{
	if (wcscmp(name, L"RESTORE_IF_NONE_THERE") == 0)
		return VSS_RME_RESTORE_IF_NOT_THERE;
	else if (wcscmp(name, L"RESTORE_IF_CAN_BE_REPLACED") == 0)
		return VSS_RME_RESTORE_IF_CAN_REPLACE;
	else if (wcscmp(name, L"STOP_RESTART_SERVICE") == 0)
		return VSS_RME_STOP_RESTORE_START;
	else if (wcscmp(name, L"REPLACE_AT_REBOOT") == 0)
		return VSS_RME_RESTORE_AT_REBOOT;
	else if (wcscmp(name, L"REPLACE_AT_REBOOT_IF_CANNOT_REPLACE") == 0)
	        return VSS_RME_RESTORE_AT_REBOOT_IF_CANNOT_REPLACE;
	else if (wcscmp(name, L"RESTORE_TO_ALTERNATE_LOCATION") == 0)
		return VSS_RME_RESTORE_TO_ALTERNATE_LOCATION;
	else if (wcscmp(name, L"CUSTOM") == 0)
		return VSS_RME_CUSTOM;
	else
		assert(false);

	return VSS_RME_RESTORE_AT_REBOOT;
}

VSS_WRITERRESTORE_ENUM Utility::toWriterRestore(const wchar_t* name)
{
	if (wcscmp(name, L"always") == 0)
		return VSS_WRE_ALWAYS;
	else if (wcscmp(name, L"never") == 0)
		return VSS_WRE_NEVER;
	else if (wcscmp(name, L"ifReplaceFails") == 0)
		return VSS_WRE_IF_REPLACE_FAILS;
	else
		assert(false);

	return VSS_WRE_UNDEFINED;
}

VSS_COMPONENT_TYPE Utility::toComponentType(const wchar_t* name)
{
	if (wcscmp(name, L"database") == 0)
		return VSS_CT_DATABASE;
	else if (wcscmp(name, L"filegroup") == 0)
		return VSS_CT_FILEGROUP;
	else
		assert(false);

	return VSS_CT_UNDEFINED;
}

VSS_RESTORE_TARGET Utility::toRestoreTarget(const wchar_t* name)
{
	if (wcscmp(name, L"VSS_RT_ORIGINAL") == 0)	
		return VSS_RT_ORIGINAL;
	else if (wcscmp(name, L"VSS_RT_ALTERNATE") == 0)
		return VSS_RT_ALTERNATE;
	else
		assert(false);

	return VSS_RT_UNDEFINED;
}

Utility::Events Utility::toWriterEvent(const wchar_t* name)
{
	if (wcscmp(name, L"Identify") == 0)
		return Identify;
	else if (wcscmp(name, L"PrepareForBackup") == 0)
		return PrepareForBackup;
	else if (wcscmp(name, L"PrepareForSnapshot") == 0)
		return PrepareForSnapshot;
	else if (wcscmp(name, L"Freeze") == 0)
		return Freeze;
	else if (wcscmp(name, L"Thaw") == 0)
		return Thaw;
	else if (wcscmp(name, L"PostSnapshot") == 0)
		return PostSnapshot;
	else if (wcscmp(name, L"Abort") == 0)
		return Abort;
	else if (wcscmp(name, L"BackupComplete") == 0)
		return BackupComplete;
	else if (wcscmp(name, L"BackupShutdown") == 0)
		return BackupShutdown;
	else if (wcscmp(name, L"PreRestore") == 0)
		return PreRestore;
	else if (wcscmp(name, L"PostRestore") == 0)
		return PostRestore;
	else 
		assert(false);

	return Identify;
}

Utility::Verbosity Utility::toVerbosity(const wchar_t* name)
{
	if (wcscmp(name, L"low") == 0)
		return low;
	else if (wcscmp(name, L"medium") == 0)
		return medium;
	else if (wcscmp(name, L"high") == 0)
		return high;
	else
		assert(false);

	return low;
}

long Utility::toLong(const wchar_t* name)
{
	wchar_t* stopPointer = NULL;
	long number = wcstol(name, &stopPointer, 10);

	assert(stopPointer > name);
	
	return number;	
}

wstring Utility::toString(VSS_USAGE_TYPE usage)
{
	switch(usage)	{
		case VSS_UT_BOOTABLESYSTEMSTATE:
			return L"BOOTABLE_SYSTEM_STATE";
		case VSS_UT_SYSTEMSERVICE:
			return L"SYSTEM_SERVICE";
		case VSS_UT_USERDATA:
			return L"USER_DATA";
		case VSS_UT_OTHER:
			return L"OTHER";
		default:
			assert(false);			
	}

	return L"";
}

wstring Utility::toString(VSS_RESTOREMETHOD_ENUM method)
{
	switch (method)	{
		case VSS_RME_RESTORE_IF_NOT_THERE:
			return L"RESTORE_IF_NONE_THERE";
		case VSS_RME_RESTORE_IF_CAN_REPLACE:
			return L"RESTORE_IF_CAN_BE_REPLACED";
		case VSS_RME_STOP_RESTORE_START:
			return L"STOP_RESTART_SERVICE";
		case VSS_RME_RESTORE_AT_REBOOT:
			return L"REPLACE_AT_REBOOT";
		case VSS_RME_RESTORE_AT_REBOOT_IF_CANNOT_REPLACE:
			return L"REPLACE_AT_REBOOT_IF_CANNOT_REPLACE";
		case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION:
			return L"RESTORE_TO_ALTERNATE_LOCATION";
		case VSS_RME_CUSTOM:
			return L"CUSTOM";
		default:
			assert(false);
	}

	return L"";
}

wstring Utility::toString(VSS_WRITERRESTORE_ENUM writerRestore)
{
	switch (writerRestore)	{
		case VSS_WRE_ALWAYS:
			return L"always";
		case VSS_WRE_NEVER:
			return L"never";
		case VSS_WRE_IF_REPLACE_FAILS:
			return L"ifReplaceFails";
		default:
			assert(false);
	}

	return L"";
}

wstring Utility::toString(VSS_COMPONENT_TYPE type)
{
	switch (type)	{
		case VSS_CT_DATABASE:
			return L"database";
		case VSS_CT_FILEGROUP:
			return L"filegroup";
		default:
			assert(false);
	}

	return L"";
}

wstring Utility::toString(VSS_RESTORE_TARGET target)
{
	switch(target)	{
		case VSS_RT_ORIGINAL:
			return L"VSS_RT_ORIGINAL";
		case VSS_RT_ALTERNATE:
			return L"VSS_RT_ALTERNATE";
		case VSS_RT_DIRECTED:
			return L"VSS_RT_DIRECTED";
		default:
			assert(false);
	}

	return L"";
}

wstring Utility::toString(Events event)
{
	switch (event)	{
		case Identify:
			return L"Identify";
		case PrepareForBackup:
			return L"PrepareForBackup";
		case PrepareForSnapshot:
			return L"PrepareForSnapshot";
		case Freeze:
			return L"Freeze";
		case Thaw:
			return  L"Thaw";
		case PostSnapshot:
			return  L"PostSnapshot";
		case Abort:
			return L"Abort";
		case BackupComplete:
			return L"BackupComplete";
		case BackupShutdown:
			return L"BackupShutdown";
		case PreRestore:
			return L"PreRestore";
		case PostRestore:
			return L"PostRestore";
		default: 
			assert(false);		
	}

	return L"";
}

wstring Utility::toString(Verbosity verbosity)
{
	switch(verbosity)	{
		case low:
			return L"low";
		case medium:
			return L"medium";
		case high:
			return L"high";
		default:
			assert(false);
	}

	return L"";
}

wstring Utility::toString(bool value)
{
	return (value) ? L"yes" : L"no";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\writer\utility.h ===
/*
**++
**
** Copyright (c) 2002  Microsoft Corporation
**
**
** Module Name:
**
**	    utility.h
**
**
** Abstract:
**
**	declare functions and variable used by the Test writer
**
** Author:
**
**	Reuven Lax      [reuvenl]       04-June-2002
**
**
**
** Revision History:
**
**--
*/

#ifndef _UTILITY_H_
#define _UTILITY_H_

////////////////////////////////////////////////////////////////////////
// Includes

#include <functional>
#include <string>
#include <sstream>
#include "vs_xml.hxx"


////////////////////////////////////////////////////////////////////////
// Declarations

using std::wstring;

namespace Utility	{
	enum Events	{
		Identify				  = 0,
		PrepareForBackup       = Identify+1,
		PrepareForSnapshot	  = PrepareForBackup+1,
		Freeze				  = PrepareForSnapshot+1,
		Thaw				  = Freeze+1,
		PostSnapshot		  = Thaw+1,
		Abort				  = PostSnapshot+1,
		BackupComplete	         = Abort+1,
		BackupShutdown          = BackupComplete+1,
		PreRestore			  = BackupShutdown+1,
		PostRestore		         = PreRestore+1,
		NumEvents			  = PostRestore+1
	};

	enum Verbosity	{
		low 			= 0,
		medium		= low+1,
		high		= medium+1
	};

	class TestWriterException : public std::exception	{
	private:
		std::string m_what;
	public:
		TestWriterException(const wstring& what) : m_what("unexpected exception")	{					
			char* buffer = new char[what.size() + 1];			
			if (buffer == NULL)
				return;
	 		if (::WideCharToMultiByte(CP_ACP, 0, what.c_str(), -1, buffer, (int)what.size() + 1, 
	 							NULL, NULL))
	 			m_what = buffer;

	 		delete [] buffer;
		}
		TestWriterException(HRESULT hr, wstring function = L"") : 
					m_what("Unexpected error") 	{
			std::wstringstream msg;
	 		msg << L"An error code of 0x" << std::hex << hr << L" was encountered";
			if (!function.empty())
				msg << L" by " << function;
			
			char* buffer = new char[msg.str().size() + 1];			
			if (buffer == NULL)
				return;
	 		if (::WideCharToMultiByte(CP_ACP, 0, msg.str().c_str(), -1, buffer, (int)msg.str().size() + 1, 
	 							NULL, NULL))
	 			m_what = buffer;

	 		delete [] buffer;
		}
		TestWriterException(const TestWriterException& other)	: m_what(other.m_what)
			{}
		virtual const char* what() const	{ return m_what.c_str(); }
	};

	// generic class that automatically releases in destructor.  Useful for pointers and handles.
	template <class ValueType, ValueType invalid, class CloseType, CloseType closeFunction>
	class AutoValue	{
	private:
		ValueType m_value;
	public:
		AutoValue(ValueType v) : m_value(v)	{}
		~AutoValue()	{ 
			if (m_value != invalid)
				closeFunction(m_value); 
		}
		operator ValueType()	{ return m_value; }
	};

	typedef BOOL(*CloseType)(HANDLE);
	typedef AutoValue<HANDLE, INVALID_HANDLE_VALUE, CloseType, ::FindClose> AutoFindFileHandle;
	typedef AutoValue<HANDLE, INVALID_HANDLE_VALUE, CloseType, ::FindVolumeMountPointClose>
						AutoFindMountHandle;

	// little class to automatically acquire and release a critical section
	struct AutoCS	{
		CComAutoCriticalSection& m_section;
		AutoCS(CComAutoCriticalSection& section) : m_section(section) 	{ m_section.Lock(); }
		~AutoCS()	{ m_section.Unlock(); }
	};

      // function object to compute the logical and of two function objects
      template<class Inner1, class Inner2>
      struct unary_and : public std::unary_function<typename Inner1::argument_type, bool>   {
      protected:
        Inner1 m_inner1;
        Inner2 m_inner2;
      public:
        unary_and();
        unary_and(const Inner1& inner1, const Inner2& inner2) : m_inner1(inner1), m_inner2(inner2)
            {}

        bool operator()(const typename Inner2::argument_type& argument) const {
            return m_inner1(argument) && m_inner2(argument);
        }
      };

      template<class Inner1, class Inner2>
      inline  unary_and<Inner1, Inner2> and1(const Inner1& inner1, const Inner2& inner2) {
        return unary_and<Inner1, Inner2>(inner1, inner2);
      }
      
	void missingAttribute(const wchar_t* name);
	void missingElement(const wchar_t* name);
	void checkReturn(HRESULT returnCode, wstring function);
	void warnReturn(HRESULT returnCode, wstring function);
	void parseError(const CXMLDocument& doc);
	void printStatus(const wstring& status, Verbosity level = medium);
	void printStatus(const std::string& status, Verbosity level = medium);
	
	bool toBoolean(const wchar_t* name);
	VSS_USAGE_TYPE toUsage(const wchar_t* name);
	VSS_RESTOREMETHOD_ENUM toMethod(const wchar_t* name);
	VSS_WRITERRESTORE_ENUM toWriterRestore(const wchar_t* name);
	VSS_COMPONENT_TYPE toComponentType(const wchar_t* name);
	VSS_RESTORE_TARGET toRestoreTarget(const wchar_t* name);
	Events toWriterEvent(const wchar_t* name);
	Verbosity toVerbosity(const wchar_t* name);
	long toLong(const wchar_t* name);
	
	wstring toString(VSS_USAGE_TYPE usage);
	wstring toString(VSS_RESTOREMETHOD_ENUM method);
	wstring toString(VSS_WRITERRESTORE_ENUM writerRestore);
	wstring toString(VSS_COMPONENT_TYPE type);
	wstring toString(VSS_RESTORE_TARGET target);
	wstring toString(Events event);
	wstring toString(Verbosity verbosity);
	wstring toString(bool value);	
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\writer\writerconfig.cpp ===
/*
**++
**
** Copyright (c) 2002  Microsoft Corporation
**
**
** Module Name:
**
**	    writerconfig.cpp
**
**
** Abstract:
**
**	defines classes that encapsulate the Test writer's configuration
**
** Author:
**
**	Reuven Lax      [reuvenl]       04-June-2002
**
**
**
** Revision History:
**
**--
*/

////////////////////////////////////////////////////////////////////////
// Includes

#include "stdafx.h"
#include "writerconfig.h"
#include "vs_xml.hxx"
#include "msxml2.h"
#include <string>
#include <sstream>
#include <algorithm>

////////////////////////////////////////////////////////////////////////
// Declarations

using Utility::checkReturn;
using Utility::AutoCS;
using std::wstring;
using std::wstringstream;

namespace XMLData	{
	// names of attributes and elements
	wchar_t Name[]						=L"name";
	wchar_t Xmlns[]						= L"xmlns";
	wchar_t SchemaPointer[]	 			= L"x-schema:#VssTestWriterConfig";	
	wchar_t RootStart[] 					= L"<root>";
	wchar_t RootEnd[] 					= L"</root>\n";
	wchar_t Root[]						= L"root";
	wchar_t TestWriter[]			  	       = L"TestWriter";
	wchar_t Verbosity[]					= L"verbosity";
	wchar_t CheckExcludes[]				= L"checkExcludes";
	wchar_t CheckIncludes[]				= L"checkIncludes";
	wchar_t Path[] 						= L"path";	
	wchar_t Filespec[]					= L"filespec";
	wchar_t Recursive[]					= L"recursive";
	wchar_t AlternatePath[]				= L"alternatePath";
	wchar_t Usage[]						= L"usage";
	wchar_t RestoreMethod[]				= L"RestoreMethod";
	wchar_t Method[]						= L"method";
	wchar_t WriterRestore[]				= L"writerRestore";
	wchar_t Service[]						= L"service";
	wchar_t RebootRequired[]				= L"rebootRequired";
	wchar_t AlternateLocationMapping[]	= L"AlternateLocationMapping";
	wchar_t Component[]					= L"Component";
	wchar_t ComponentType[]				= L"componentType";
	wchar_t LogicalPath[]					= L"logicalPath";
	wchar_t Selectable[]					= L"selectable";
	wchar_t SelectableForRestore[]		= L"selectableForRestore";	
	wchar_t ComponentName[]			= L"componentName";
	wchar_t ComponentFile[]				= L"ComponentFile";
	wchar_t Dependency[]					= L"Dependency";
	wchar_t WriterId[]					= L"writerId";
	wchar_t ExcludeFile[]					= L"ExcludeFile";
	wchar_t RestoreTarget[]				= L"restoreTarget";
	wchar_t NewTarget[]					= L"NewTarget";
	wchar_t FailEvent[]					= L"FailEvent";
	wchar_t WriterEvent[]					= L"writerEvent";
	wchar_t Retryable[]					= L"retryable";
	wchar_t NumFailures[]				= L"numFailures";
	
	// string containing the Test writer schema
	#include "schema.h"
}

////////////////////////////////////////////////////////////////////////
// Implementation for the File struct

File::File(CXMLDocument node)
{
	// read the attributes from the document and store in the structure
	CComBSTR path;
	if (!node.FindAttribute(XMLData::Path, &path))
		missingAttribute(XMLData::Path);

	CComBSTR filespec;
	if (!node.FindAttribute(XMLData::Filespec, &filespec))
		missingAttribute(XMLData::Filespec);

	CComBSTR recursive;
	if (!node.FindAttribute(XMLData::Recursive, &recursive))
		missingAttribute(XMLData::Recursive);
	
	m_path = (BSTR)path;
	std::transform(m_path.begin(), m_path.end(), m_path.begin(), towupper);
	
	m_filespec = (BSTR)filespec;
	std::transform(m_filespec.begin(), m_filespec.end(), m_filespec.begin(), towupper);

	// path and filespec should never be empty.  
	if (m_path.empty())
		throw Utility::TestWriterException(L"File specification has empty path");
	if (m_filespec.empty())
		throw Utility::TestWriterException(L"File specification has empty filespec");
	
	if (m_path[m_path.size() -1] != L'\\')
		m_path += L'\\';
	
	m_recursive = Utility::toBoolean(recursive);
}

wstring File::toString() const
{
	wstringstream msg;
	msg << L"Path: " << m_path << std::endl <<
		      L"Filespec: " << m_filespec << std::endl <<
		      L"Recursive: " << Utility::toString(m_recursive);

	return msg.str();
}
////////////////////////////////////////////////////////////////////////
// Implementation for the TargetedFile struct

TargetedFile::TargetedFile(CXMLDocument node) : File(node)
{
	// read the alternatePath attribute and store it
	CComBSTR alternatePath;
	if (!node.FindAttribute(XMLData::AlternatePath, &alternatePath))
		return;
	assert(alternatePath);
	
	m_alternatePath = (BSTR)alternatePath;
	std::transform(m_alternatePath.begin(), m_alternatePath.end(), m_alternatePath.begin(), towupper);
	
	if (m_alternatePath.empty())
		throw Utility::TestWriterException(L"File specification has empty alternate path");
	
	if (m_alternatePath[m_alternatePath.size()-1] != L'\\')
		m_alternatePath += L'\\';
}

wstring TargetedFile::toString() const
{
	wstringstream msg;
	msg << File::toString() << std::endl <<
		    L"AlternatePath: " << m_alternatePath;

	return msg.str();
}

////////////////////////////////////////////////////////////////////////
// Implementation for the RestoreMethod struct

RestoreMethod::RestoreMethod(CXMLDocument node) 
{
	node.SetToplevel();

	CComBSTR method, writerRestore, service, rebootRequired;
	// read attributes and elements from document
	if (!node.FindAttribute(XMLData::Method, &method))
		missingAttribute(XMLData::Method);

	if (!node.FindAttribute(XMLData::WriterRestore, &writerRestore))
		missingAttribute(XMLData::WriterRestore);

	node.FindAttribute(XMLData::Service, &service);

	if(!node.FindAttribute(XMLData::RebootRequired, &rebootRequired))
		missingAttribute(XMLData::RebootRequired);	
	
	if (node.FindElement(XMLData::AlternateLocationMapping, true))
		m_alternateLocations = AlternateList(node);

	m_method = Utility::toMethod(method);
	m_writerRestore = Utility::toWriterRestore(writerRestore);
	m_service = (service.Length() > 0) ? service : L"";
	m_rebootRequired = Utility::toBoolean(rebootRequired);	
}

wstring RestoreMethod::toString() const
{
	wstringstream msg;
	msg << L"method: " << Utility::toString(m_method) << std::endl <<
		     L"service: " << m_service << std::endl <<
		     L"writerRestore: " << Utility::toString(m_writerRestore) << std::endl <<
		     L"reboot: " << Utility::toString(m_rebootRequired);

	return msg.str();
}

////////////////////////////////////////////////////////////////////////
// Implementation for the Dependency struct
Dependency::Dependency(CXMLDocument node)
{
	node.SetToplevel();

	CComBSTR logicalPath, componentName, writerId;
		
	if(!node.FindAttribute(XMLData::WriterId, &writerId))
		missingAttribute(XMLData::WriterId);

	node.FindAttribute(XMLData::LogicalPath, &logicalPath);

	if(!node.FindAttribute(XMLData::ComponentName, &componentName))
		missingAttribute(XMLData::ComponentName);


       HRESULT hr = ::UuidFromString(writerId, &m_writerId);
       checkReturn(hr, L"CLSIDFromString");
        
	m_logicalPath = (logicalPath.Length() > 0) ? logicalPath : L"";
	m_componentName = componentName;
}

wstring Dependency::toString() const
{
	wstringstream msg;
	msg << L"WriterId: " << (wchar_t*)CComBSTR(m_writerId) << std::endl <<
		     L"Logical Path: " << m_logicalPath << std::endl <<
		     L"Component Name: " << m_componentName;

	return msg.str();
}

////////////////////////////////////////////////////////////////////////
// Implementation for the Component struct

Component::Component(CXMLDocument node)
{
	node.SetToplevel();

	CComBSTR componentType, restoreTarget, logicalPath, name, selectable, 
			    selectableForRestore;
	
	// read attributes from document and store them
	if (!node.FindAttribute(XMLData::ComponentType, &componentType))
		missingAttribute(XMLData::ComponentType);

	node.FindAttribute(XMLData::RestoreTarget, &restoreTarget);
	
	node.FindAttribute(XMLData::LogicalPath, &logicalPath);

	if (!node.FindAttribute(XMLData::ComponentName, &name))
		missingAttribute(XMLData::ComponentName);

	if (!node.FindAttribute(XMLData::Selectable, &selectable))
		missingAttribute(XMLData::Selectable);

	if (!node.FindAttribute(XMLData::SelectableForRestore, &selectableForRestore))
		missingAttribute(XMLData::SelectableForRestore);
	
	m_componentType = Utility::toComponentType(componentType);
	m_restoreTarget = (restoreTarget.Length() > 0) ? Utility::toRestoreTarget(restoreTarget) : VSS_RT_UNDEFINED;
	m_logicalPath = (logicalPath.Length() > 0) ? logicalPath : L"";
	m_selectable = Utility::toBoolean(selectable);
	m_selectableForRestore = Utility::toBoolean(selectableForRestore);
	
	m_name = name;
	if (m_name.empty())
		throw Utility::TestWriterException(L"Component has empty name");
	
	// read elements from document and store them
	if (node.FindElement(XMLData::ComponentFile, true))
		m_files = ComponentFileList(node);

	node.ResetToDocument();
	
	if (node.FindElement(XMLData::Dependency, true))
		m_dependencies = DependencyList(node);
}

wstring ComponentBase::toString() const
{
	wstringstream msg;
	msg << L"Logical Path: " << m_logicalPath << std::endl <<
	             L"Name: " << m_name << std::endl;

	return msg.str();
}

// comparison operations for writer components
bool operator==(const ComponentBase& left, const ComponentBase& right)
{
		return (left.m_name == right.m_name) &&
			    (left.m_logicalPath == right.m_logicalPath);
}
bool operator!=(const ComponentBase& left, const ComponentBase& right)
{
	return !(left == right);
}
bool operator==(const Component& left, const Component& right)
{
	return ((ComponentBase&)left == (ComponentBase&)right) && 
		      (left.m_componentType == right.m_componentType) &&
		      (left.m_restoreTarget == right.m_restoreTarget) &&
		      (left.m_selectable == right.m_selectable) &&
		      (left.m_selectableForRestore == right.m_selectableForRestore) &&
		      (left.m_files == right.m_files) &&
		      (left.m_newTargets == right.m_newTargets);
		
}
bool operator!=(const Component& left, const Component& right)
{
	return !(left == right);
}

////////////////////////////////////////////////////////////////////////
// Implementation for the WriterEvent struct

WriterEvent::WriterEvent(CXMLDocument node)
{
	CComBSTR event;
	if (!node.FindAttribute(XMLData::WriterEvent, &event))
		missingAttribute(XMLData::WriterEvent);

	CComBSTR retryable;
	if (!node.FindAttribute(XMLData::Retryable, &retryable))
		missingAttribute(XMLData::Retryable);

	CComBSTR numFailures;
	if (!node.FindAttribute(XMLData::NumFailures, &numFailures))
		missingAttribute(XMLData::NumFailures);
	
	m_writerEvent = Utility::toWriterEvent(event);
	m_retryable = Utility::toBoolean(retryable);
	m_numFailures = Utility::toLong(numFailures);
}

////////////////////////////////////////////////////////////////////////
// Implementation for the WriterConfiguration class

// load configuration from the XML file
void WriterConfiguration::loadFromXML(const wstring& xml)
{
	AutoCS critical(m_section);
	
	// load the document from the XML string
	wstring xmlString = XMLData::RootStart;
	xmlString += XMLData::Schema;
	xmlString += xml;
	xmlString += XMLData::RootEnd;

	// load twice so we can do schema validation the second time
	for (int x = 0; x < 2; x++)	{
		if (!m_doc.LoadFromXML(const_cast<wchar_t*> (xmlString.c_str())))	
			Utility::parseError(m_doc);

		// --- skip to the part of the document we care about
	 	if (!m_doc.FindElement(XMLData::Root, true))
	 		missingElement(XMLData::Root);	
	 	if (!m_doc.FindElement(XMLData::TestWriter, true))
	 		missingElement(XMLData::TestWriter);

		// --- set the schema namespace
		if (x == 0)	{
			CXMLNode testNode(m_doc.GetCurrentNode(), m_doc.GetInterface());
		 	testNode.SetAttribute(XMLData::Xmlns, XMLData::SchemaPointer);	
		 	xmlString = m_doc.SaveAsXML();
		}
	}

	m_doc.SetToplevel();
}

VSS_USAGE_TYPE WriterConfiguration::usage() const
{
	assert(m_doc.GetLevel() == 0);
	AutoCS critical(m_section);
	Resetter reset(m_doc);

	CComBSTR value;
	if (!m_doc.FindAttribute(XMLData::Usage, &value))
		missingAttribute(XMLData::Usage);

	return Utility::toUsage(value);
}

Utility::Verbosity WriterConfiguration::verbosity() const
{
	assert(m_doc.GetLevel() == 0);
	AutoCS critical(m_section);
	Resetter reset(m_doc);

	CComBSTR value;
	if (!m_doc.FindAttribute(XMLData::Verbosity, &value))
		missingAttribute(XMLData::Verbosity);

	return Utility::toVerbosity(value);
}

bool WriterConfiguration::checkExcludes() const
{
	assert(m_doc.GetLevel() == 0);
	AutoCS critical(m_section);
	Resetter reset(m_doc);

	CComBSTR value;
	if (!m_doc.FindAttribute(XMLData::CheckExcludes, &value))
		missingAttribute(XMLData::CheckExcludes);

	return Utility::toBoolean(value);
}

bool WriterConfiguration::checkIncludes() const
{
	assert(m_doc.GetLevel() == 0);
	AutoCS critical(m_section);
	Resetter reset(m_doc);

	CComBSTR value;
	if (!m_doc.FindAttribute(XMLData::CheckIncludes, &value))
		missingAttribute(XMLData::CheckIncludes);

	return Utility::toBoolean(value);
}

// get the writer's restore method
RestoreMethod WriterConfiguration::restoreMethod() const
{
	assert(m_doc.GetLevel() == 0);
	AutoCS critical(m_section);
	Resetter reset(m_doc);
	
	if (!m_doc.FindElement(XMLData::RestoreMethod, true))
		missingElement(XMLData::RestoreMethod);

	return RestoreMethod(m_doc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\writer\swriter.h ===
/*
**++
**
** Copyright (c) 2002  Microsoft Corporation
**
**
** Module Name:
**
**	    swriter.h
**
**
** Abstract:
**
**	Test program to to register a Writer with various properties
**
** Author:
**
**	Reuven Lax      [reuvenl]       04-June-2002
**
**
**
** Revision History:
**
**--
*/

#ifndef _SWRITER_H_
#define _SWRITER_H_

///////////////////////////////////////////////////////////////////////////////
// Includes

#include <vector>
#include <stack>
#include <functional>
#include <string>
#include "writerconfig.h"
#include "utility.h"

///////////////////////////////////////////////////////////////////////////////
// Declarations and Definitions

// {5AFFB034-969F-4919-8875-88F830D0EF89}
static const VSS_ID TestWriterId  = 
	{ 0x5affb034, 0x969f, 0x4919, { 0x88, 0x75, 0x88, 0xf8, 0x30, 0xd0, 0xef, 0x89 } };

static const wchar_t* const  TestWriterName = L"TestVssWriter";

using std::vector;

///////////////////////////////////////////////////////////////////////////////
// TestWriter class

class TestWriter : public CVssWriter	{
private:
	// member variables
	vector<Component> m_selectedComponents;
	vector<Component> m_selectedRestoreComponents;
	vector<wstring> m_toDelete;
	std::stack<wstring> m_directoriesToRemove;
	long m_failures[Utility::NumEvents];
	
	// closure to encapsulate calls to verifyFileAtLocation and record error messages
	class VerifyFileAtLocation : public std::binary_function<const TargetedFile, const File, void>	{
	private:
		const vector<File>& m_excluded;
		bool m_verifyAlternateLocation;
		mutable IVssComponent* m_pComponent;	// necessary due to bug in STL

		wstring verifyFileAtLocation(const File& file, const TargetedFile& location) const;
		bool verifyAlternateLocation(const TargetedFile& writerAlt) const;
		void saveErrorMessage(const wstring& message) const;
	public:
		VerifyFileAtLocation(const vector<File>& excludeFiles, IVssComponent* pComponent, 
			                      bool verifyAlternateLocation) : 
								m_excluded(excludeFiles), m_pComponent(pComponent),
								m_verifyAlternateLocation(verifyAlternateLocation)
			{}

		// The function operator.  Verifies the file, and records any error message
		void operator()(const TargetedFile location, const File file)  const { 
			saveErrorMessage(verifyFileAtLocation(file, location)); 
		}
	};

	// static helper functions

	// filter out elements in a source container that match a specific condition.  Place these elements
	// into a target container.
	template <class SourceIterator, class TargetIterator, class Condition>
	static void buildContainer_if(SourceIterator begin, SourceIterator end, TargetIterator output, Condition cond)	{
		SourceIterator current = std::find_if(begin, end, cond);
		while (current != end)	{
			*output++ = *current++;
			current = std::find_if(current, end, cond);
		}
	}


    // build a list of all files in this component and in all non-selectable subcomponents
    template<class TargetIterator>
    static void __cdecl buildComponentFiles(Component component, TargetIterator output) {
        WriterConfiguration* config = WriterConfiguration::instance();

        buildComponentFilesHelper(component, output);
        
        // build a list of all subcomponents
        vector<Component> subcomponents;
        buildContainer_if(config->components().begin(), 
                                 config->components().end(), 
                                 std::back_inserter(subcomponents), 
                                 std::bind2nd(std::ptr_fun(isSubcomponent), component));

        // add all files in all non-selectable subcomponents to the output
        std::pointer_to_binary_function<Component, std::back_insert_iterator<vector<TargetedFile> >, void>
        ptrFun(buildComponentFilesHelper);
        std::for_each(subcomponents.begin(), 
                            subcomponents.end(), 
                            std::bind2nd(ptrFun, output));
    }

    template<class TargetIterator>
    static void __cdecl buildComponentFilesHelper(Component component, TargetIterator output)  {
        // add all the files in the current component
        Component::ComponentFileList::iterator currentCompFile = component.m_files.begin();
        while (currentCompFile != component.m_files.end())  
            *output++ = *currentCompFile++;
    }

    static bool __cdecl isSubcomponent(ComponentBase sub, ComponentBase super);
    static bool __cdecl isSupercomponent(ComponentBase super, ComponentBase sub)    {
        return isSubcomponent(sub, super);
    }
    
    // return whether a component is selectable for backup
    static bool __cdecl isComponentSelectable(Component component)  {
        return component.m_selectable;
    }

    static bool __cdecl addableComponent(Component toAdd);
    
	// Returns whether a filespec is a wildcard or an exact filespec.
	static bool isExact(const wstring& file)    { return file.find_first_of(L"*?") == wstring::npos; }
	
	static bool  __cdecl targetMatches(File target, File file);
	static bool wildcardMatches(const wstring& first, const wstring& second);
	
	// non-static helper functions
	void enterEvent(Utility::Events event);
	void addComponent(const Component& component, IVssCreateWriterMetadata* pMetadata);
	void spitFiles(const TargetedFile& file);
	wstring getName(IVssComponent* pComponent);
	wstring getPath(IVssComponent* pComponent);
	void writeBackupMetadata(IVssComponent* pComponent);
	bool verifyBackupMetadata(IVssComponent* pComponent);
	void writeRestoreMetadata(IVssComponent* pComponent);
	bool  verifyRestoreMetadata(IVssComponent* pComponent);
	bool checkPathAffected(const TargetedFile& file);
	void cleanupFiles();
	void updateNewTargets(IVssComponent* pComponent, Component& writerComponent);
	void verifyFilesRestored(IVssComponent* pComponent, const Component& writerComponent);	

	// returns the private metadata string that the writer stores in the document
	wstring metadata(IVssComponent* pComponent, const wstring& suffix)	{ 
		return getPath(pComponent) + L"\\" + getName(pComponent) + suffix;
	}

       bool inSequence(Utility::Events event)   { 
        return event != Utility::Identify &&  event != Utility::BackupComplete && 
                   event != Utility::BackupShutdown; 
        }
public:
	TestWriter()	{ memset(m_failures, 0, sizeof(m_failures)); }
	virtual ~TestWriter()	{ Uninitialize(); }

	HRESULT STDMETHODCALLTYPE Initialize();
	HRESULT STDMETHODCALLTYPE Uninitialize()	{ return Unsubscribe(); }
	bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);
	bool STDMETHODCALLTYPE OnPrepareBackup(IN IVssWriterComponents *pComponents);
	bool STDMETHODCALLTYPE OnPrepareSnapshot();
	bool STDMETHODCALLTYPE OnFreeze();
	bool STDMETHODCALLTYPE OnThaw();
       bool STDMETHODCALLTYPE OnPostSnapshot(IN IVssWriterComponents *pComponents);
	bool STDMETHODCALLTYPE OnAbort();
	bool STDMETHODCALLTYPE OnBackupComplete(IN IVssWriterComponents *pComponents);
	bool STDMETHODCALLTYPE OnBackupShutdown(IN VSS_ID SnapshotSetId);
	bool STDMETHODCALLTYPE OnPreRestore(IN IVssWriterComponents *pComponents);
	bool STDMETHODCALLTYPE OnPostRestore(IN IVssWriterComponents *pComponents);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\writer\writerconfig.h ===
/*
**++
**
** Copyright (c) 2002  Microsoft Corporation
**
**
** Module Name:
**
**	    writerconfig.h
**
**
** Abstract:
**
**	declare classes that encapsulate the Test writer's configuration
**
** Author:
**
**	Reuven Lax      [reuvenl]       04-June-2002
**
**
**
** Revision History:
**
**--
*/

#ifndef _WRITERCONFIG_H_
#define _WRITERCONFIG_H_

///////////////////////////////////////////////////////////////////////////////
// Includes

#include <string>
#include <algorithm>
#include <vector>
#include "vs_xml.hxx"
#include "utility.h"

using std::wstring;
using Utility::missingAttribute;
using Utility::missingElement;
using Utility::AutoCS;

///////////////////////////////////////////////////////////////////////////////
// Declarations 

// this namespace contains all XML data
namespace XMLData	{
	// names of attributes and elements
	extern wchar_t AlternateLocationMapping[];
	extern wchar_t Component[];
	extern wchar_t ComponentFile[];
	extern wchar_t ExcludeFile[];
	extern wchar_t NewTarget[];
	extern wchar_t FailEvent[];
	extern wchar_t Dependency[];
}

///////////////////////////////////////////////////////////////////////////////
// Class Declarations

// this is the generic collection class for sequences in the XML document
template <class T, wchar_t ElementName[]>
class XMLCollection	{
public:
	// required typedefs for a collection class
	typedef const T value_type ;
	typedef const T& reference ;
	typedef const T& const_reference ;
	typedef T* pointer ;
	typedef const T* const_pointer ;
	typedef long size_type ;

	class Iterator;
	typedef  Iterator iterator;	
	typedef Iterator const_iterator ;

	// The iterator for objects in the collection.  The iterator is read only -- objects in the collection can't be modified
	class Iterator : public std::iterator<std::input_iterator_tag, T>	{		
		CXMLDocument m_doc;
		mutable long* m_identifier;		
		mutable T* m_currentElement;
		bool m_pastEnd;		
		unsigned long m_index;
	public:
		Iterator() :  m_identifier(NULL), m_currentElement(NULL), m_pastEnd(true), m_index(0) 	{}
		Iterator(const Iterator& other) : m_identifier(NULL)	{ *this = other; }
		Iterator(const XMLCollection& collection)  : m_doc(collection.m_doc), m_currentElement(NULL), m_pastEnd(false), m_index(0)
		{ 
			// the assumption is that m_doc is currently at a node with type ElementName
			// bad things will ensue if this is not true			
			m_doc.SetToplevel(); 

			// m_identifer is used to ensure the following statements			
			//		iterator  i1 = ...;
			//		iterator  i2 = i1;
			//		assert(i1 == i2);
			//		assert(++i1 == ++i2);
			m_identifier = new long(1);
			if (m_identifier == NULL)
				throw std::bad_alloc();
		}
		
		virtual ~Iterator()	{ 
			if (m_identifier && --*m_identifier == 0)
				delete m_identifier;
			
			delete m_currentElement; 
		}
		
		Iterator& operator=(const Iterator& other)	{
			if (&other == this)
				return *this;
			
			m_currentElement = NULL; 
			m_doc = other.m_doc; 
			m_pastEnd = other.m_pastEnd; 
			m_index = other.m_index; 

			// make the reference count right
			if (other.m_identifier)
				++*other.m_identifier;
			if(m_identifier && --*m_identifier == 0)
				delete m_identifier;
			
			m_identifier = other.m_identifier;

			return *this;
		}
		
		bool operator==(const Iterator& other) const	 { 
			return (m_pastEnd && other.m_pastEnd) ||
				      ((m_identifier == other.m_identifier) && (m_index == other.m_index) && !m_pastEnd && !other.m_pastEnd); 
		}
		
		bool operator!=(const Iterator& other) const  { return !(*this == other); }

		const_reference  operator*() const	{
			assert(m_identifier);
			assert(!m_pastEnd);
			
			if (!m_currentElement)	
				m_currentElement = new T(m_doc);
			if (m_currentElement == NULL)
				throw std::bad_alloc();				
			
			return *m_currentElement;	
		}
		
		const_pointer operator->() const	{ return &**this; }
		
		Iterator& operator++() 	{
			if (m_pastEnd)	{
				assert(false);
				return *this;
			}

			assert(m_identifier);
			
			delete m_currentElement;
			m_currentElement = NULL;

			if (!m_doc.FindElement(ElementName, false))	
				m_pastEnd = true;

			++m_index;
			
			return *this;
		}
		
		Iterator operator++(int) 	{
			Iterator temp = *this;
			++*this;
			return temp;
		}
	};
	
	XMLCollection() :  m_size(0) {}	// initialize an empty collection
	XMLCollection(const XMLCollection& other)	{ *this = other; }
	XMLCollection(CXMLDocument& document) : m_doc(document), m_size(-1)	{	m_doc.SetToplevel(); }
	virtual ~XMLCollection()	{}
	
	XMLCollection& operator= (const XMLCollection& other)	{ 
		m_doc = other.m_doc; 
		m_size = other.m_size; 

		return *this;
	}

	bool operator==(const XMLCollection& other) const	{ 
		return (size() == other.size()) && std::equal(begin(), end(), other.begin()); 
	}
	bool operator!=(const XMLCollection& other) const	{ return !(*this == other); }
	
	size_type size() const	{
		// if we've already calculated the size, return it
		if (m_size != -1)
			return m_size;

		// otherwise, calculate the size and return it
		assert(!m_doc.IsEmpty());				// if so, then m_size should==0, and we wouldn't be here
		size_type size = 0;
		iterator current(*this);		// can't use begin()/end() as that would recurse
		while (current != m_pastEndIterator)	{
			++size;
			++current;
		}
		assert(size > 0);

		return (m_size = size);
	}		
	
	size_type max_size() const	{ return LONG_MAX; }
	bool empty() const	{ return size() == 0; }
	iterator begin() const	{ return empty() ? m_pastEndIterator : Iterator(*this); 	}
	iterator end() const	{ return m_pastEndIterator; }
private:
	friend class Iterator;
	
	CXMLDocument m_doc;
	mutable long m_size;
	Iterator m_pastEndIterator;
};

// little class to ensure that the document is always reset at the end of each function
struct Resetter	{
	CXMLDocument& m_config;
	Resetter(CXMLDocument& config) : m_config(config)	{}
	~Resetter()	{ m_config.ResetToDocument(); }
};

// generic file specification. 
struct File	{
	File(CXMLDocument node);
	File(const wstring& path, const wstring& filespec, bool recursive) : 
							m_path(path), m_filespec(filespec), m_recursive(recursive)		{
		std::transform(m_path.begin(), m_path.end(), m_path.begin(), towupper);
		std::transform(m_filespec.begin(), m_filespec.end(), m_filespec.begin(), towupper);
	}
	bool operator==(const File& other) const	{
		return (m_path == other.m_path) && 
			    (m_filespec == other.m_filespec) && 
			    (m_recursive == other.m_recursive);
	}
	bool operator!=(const File& other) const	{ return !(*this == other); }

	wstring toString() const;
	
	wstring m_path;
	wstring m_filespec;
	bool m_recursive;
};

// file specification together with an alternate-path target.
struct TargetedFile : public File	{
	TargetedFile(CXMLDocument node);
	TargetedFile(const wstring &path, const wstring& filespec, 
			     bool recursive, const wstring& alternate) : File(path, filespec, recursive),
													m_alternatePath(alternate)	{
		std::transform(m_alternatePath.begin(), m_alternatePath.end(), m_alternatePath.begin(), towupper);
	}
	bool operator==(const TargetedFile& other) const	{
		return (m_alternatePath == other.m_alternatePath) && 
			    (File::operator==(other));
	}
	bool operator!=(const TargetedFile& other) const	{ return !(*this == other); }

	wstring toString() const;
	
	wstring m_alternatePath;
};

// Writer restore method
struct RestoreMethod		{
	RestoreMethod(CXMLDocument node);
	bool operator==(const RestoreMethod& other) const	{
		return (m_method == other.m_method) &&
			    (m_writerRestore == other.m_writerRestore) &&
			    (m_service ==other.m_service) &&
			    (m_rebootRequired == other.m_rebootRequired) &&
			    (m_alternateLocations == other.m_alternateLocations);
	}
	bool operator!=(const RestoreMethod& other) const	{ return !(*this == other); }

	wstring toString() const;
	
	VSS_RESTOREMETHOD_ENUM m_method;
	VSS_WRITERRESTORE_ENUM m_writerRestore;
	wstring m_service;
	bool m_rebootRequired;

	typedef XMLCollection<TargetedFile, XMLData::AlternateLocationMapping> AlternateList ;
	AlternateList m_alternateLocations;	
};


// component dependency
struct Dependency   {
    Dependency(CXMLDocument node);
    bool operator==(const Dependency& other) const  {
        return (m_writerId == other.m_writerId) &&
                    (m_logicalPath == other.m_logicalPath) &&
                    (m_componentName == other.m_componentName);
    }

    bool operator!=(const Dependency& other) const  { return !(*this == other); }

    wstring toString() const;
    
    VSS_ID m_writerId;
    wstring m_logicalPath;
    wstring m_componentName;
};

// Writer component
struct ComponentBase	{	
	ComponentBase(const wstring& path = L"", const wstring& name = L"") : m_logicalPath(path), m_name(name)
		{}
	wstring toString() const;
	
	wstring m_logicalPath;
	wstring m_name;
};

struct  Component : public ComponentBase    {
	Component(CXMLDocument node);

	VSS_COMPONENT_TYPE m_componentType;
	VSS_RESTORE_TARGET m_restoreTarget;
	bool m_selectable;
	bool m_selectableForRestore;

	typedef XMLCollection<TargetedFile, XMLData::ComponentFile> ComponentFileList;
	typedef std::vector<TargetedFile> TargetList;
	typedef XMLCollection<Dependency, XMLData::Dependency> DependencyList;
	
	ComponentFileList m_files;
	DependencyList m_dependencies;
	TargetList m_newTargets;
};

// comparison operators for Component and ComponentBase
bool operator==(const ComponentBase& left, const ComponentBase& right);
bool operator!=(const ComponentBase& left, const ComponentBase& right);
bool operator==(const Component& left, const Component& right);
bool operator!=(const Component& left, const Component& right);

// Writer event.
struct  WriterEvent	{
	WriterEvent(CXMLDocument node);
	WriterEvent(Utility::Events event, bool retryable = true, long failures = 1) : 
				m_writerEvent(event), m_retryable(retryable), 
				m_numFailures(failures)	{}
	bool operator==(const WriterEvent& other) const	{ return m_writerEvent == other.m_writerEvent; }
	bool operator!=(const WriterEvent& other) const	{ return !(*this == other); }
	
	Utility::Events m_writerEvent;
	bool m_retryable;
	long m_numFailures;
};


// Singleton class that encapsulates writer configuration
class WriterConfiguration	{
private:
	// disallow explicit creation of this class
	WriterConfiguration()	{}
	WriterConfiguration(WriterConfiguration&);
	operator= (WriterConfiguration&);

	mutable CComAutoCriticalSection m_section;
	mutable CXMLDocument m_doc;

	template <class T, wchar_t ElementName[]>
	const XMLCollection<T, ElementName> getCollection() const	{
		assert(m_doc.GetLevel() == 0);
		AutoCS critical(m_section);
		Resetter reset(m_doc);

		if (m_doc.FindElement(ElementName, true))
			return XMLCollection<T, ElementName>(m_doc);
		else
			return XMLCollection<T,ElementName>();
	}
public:
	typedef XMLCollection<File, XMLData::ExcludeFile> ExcludeFileList;
	typedef XMLCollection<Component, XMLData::Component>ComponentList;
	typedef XMLCollection<WriterEvent, XMLData::FailEvent> FailEventList;
	static WriterConfiguration* instance();

	void loadFromXML(const wstring& xml);
	VSS_USAGE_TYPE usage() const;
	Utility::Verbosity  verbosity() const;
	bool checkExcludes() const;
	bool checkIncludes() const;
	RestoreMethod  restoreMethod() const;
	const  ExcludeFileList excludeFiles() const
		{ return getCollection<File, XMLData::ExcludeFile>(); }
	const  ComponentList components() const
		{ return getCollection<Component, XMLData::Component>(); }
	const  FailEventList failEvents() const
		{ return getCollection<WriterEvent, XMLData::FailEvent>(); }
};

// return the singleton instance of the class
// This is always called for the first time at the beginning of main, so no critical section
// need be involved
inline WriterConfiguration* WriterConfiguration::instance()
{
	static WriterConfiguration configuration;

	return &configuration;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\tests\writer\mkschema\main.cpp ===
#include "stdafx.hxx"
#include "vs_inc.hxx"

static unsigned s_iwcDocBegin;
static unsigned s_iwcDocEnd;


unsigned PrintStringToFile(FILE *file, LPCWSTR wsz)
	{
	const WCHAR *pwc = wsz;
	fputc('{', file);
	unsigned ich = 0;

	s_iwcDocBegin = ich;


	while(*pwc != L'\0')
		{
		if ((ich++ % 10) == 0)
			fputc('\n', file);

		fprintf(file, "L'");

		if (*pwc == L'\\')
			{
			fputc('\\', file);
			fputc('\\', file);
			}
		else if (*pwc == L'\n')
			{
			fputc('\\', file);
			fputc('n', file);
			}
		else if (*pwc == L'\r')
			{
			fputc('\\', file);
			fputc('r', file);
			}
		else if (*pwc == L'\t')
			{
			fputc('\\', file);
			fputc('t', file);
			}
		else if (*pwc == L'\'')
			{
			fputc('\\', file);
			fputc('\'', file);
			}
		else
			fputc((char) *pwc, file);

		fprintf(file, "', ");
		pwc++;
		}

	s_iwcDocEnd = ich;

	fprintf(file, "L'\\0'\n};");

	return ich;
	}

extern "C" __cdecl wmain(int argc, WCHAR ** argv)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"main");

	CXMLDocument doc;

	try
		{
		ft.hr = CoInitialize(NULL);
		if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_XML,
				E_UNEXPECTED,
				L"CoInitialize failed.  hr = 0x%08lx",
				ft.hr

				);

		BS_ASSERT(argc == 3);

		if (!doc.LoadFromFile(argv[1]))
			{
			wprintf(L"Cannot load %s\n", argv[1]);
			exit(-1);
			}

		CComBSTR bstr = doc.SaveAsXML();
		FILE *f = _wfopen(argv[2], L"w");
		if (f == NULL)
			{
			wprintf(L"create of %s failed\n", argv[1]);
			exit(-1);
			}

		fprintf(f, "wchar_t Schema[] = \n");
		PrintStringToFile(f, bstr);

		bstr.Empty();
		fclose(f);
		}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		{
		printf("Unexpected exception, hr = 0x%08lx", ft.hr);
		exit(-1);
		}

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\hosting.cpp ===
// Hosting.cpp : implementation file
//

#include "stdafx.h"
#include "utils.h"
#include "Hosting.h"
#include "uihelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHosting dialog


CHosting::CHosting(CWnd* pParent /*=NULL*/)
	: CDialog(CHosting::IDD, pParent)
{
	//{{AFX_DATA_INIT(CHosting)
	m_strVolume = _T("");
	//}}AFX_DATA_INIT
    m_strComputer = _T("");
}

CHosting::CHosting(LPCTSTR pszComputer, LPCTSTR pszVolume, CWnd* pParent /*=NULL*/)
	: CDialog(CHosting::IDD, pParent)
{
    m_strComputer = pszComputer + (TWO_WHACKS(pszComputer) ? 2 : 0);
    m_strVolume = pszVolume;
}

void CHosting::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHosting)
	DDX_Control(pDX, IDC_HOSTING_FREE_DISKSPACE, m_ctrlFreeSpace);
	DDX_Control(pDX, IDC_HOSTING_TOTAL_DISKSPACE, m_ctrlTotalSpace);
	DDX_Control(pDX, IDC_HOSTING_VOLUMELIST, m_ctrlVolumeList);
	DDX_Text(pDX, IDC_HOSTING_VOLUME, m_strVolume);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHosting, CDialog)
	//{{AFX_MSG_MAP(CHosting)
	ON_WM_CONTEXTMENU()
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHosting message handlers

BOOL CHosting::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    // init listview control
    HWND hwnd = m_ctrlVolumeList.m_hWnd;
    AddLVColumns(
            hwnd, 
            IDS_HOSTINGLIST_COLUMN_VOLUME,
            IDS_HOSTINGLIST_COLUMN_DIFFLIMITS - IDS_HOSTINGLIST_COLUMN_VOLUME + 1);
    ListView_SetExtendedListViewStyle(hwnd, LVS_EX_FULLROWSELECT);
	
    CString strNoLimits;
    strNoLimits.LoadString(IDS_NOLIMITS);

    TCHAR   szDiskSpace[MAX_PATH];
    DWORD   dwSize = 0;
    int     nIndex = 0;
    LVITEM  lvItem = {0};
    for (VSSUI_DIFFAREA_LIST::iterator i = m_DiffAreaList.begin(); i != m_DiffAreaList.end(); i++)
    {
        ZeroMemory(&lvItem, sizeof(LVITEM));
        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = (*i)->pszVolumeDisplayName;
        lvItem.iSubItem = 0;
        nIndex = m_ctrlVolumeList.InsertItem(&lvItem);

        lvItem.iItem = nIndex;

        if ((*i)->llMaximumDiffSpace == VSS_ASSOC_NO_MAX_SPACE)
        {
            lvItem.pszText = (PTSTR)(LPCTSTR)strNoLimits;
        } else
        {
            dwSize = sizeof(szDiskSpace)/sizeof(TCHAR);
            DiskSpaceToString((*i)->llMaximumDiffSpace, szDiskSpace, &dwSize);
            lvItem.pszText = szDiskSpace;
        }
        lvItem.iSubItem = IDS_HOSTINGLIST_COLUMN_DIFFLIMITS - IDS_HOSTINGLIST_COLUMN_VOLUME;
        m_ctrlVolumeList.SetItem(&lvItem);

        dwSize = sizeof(szDiskSpace)/sizeof(TCHAR);
        DiskSpaceToString((*i)->llUsedDiffSpace, szDiskSpace, &dwSize);
        lvItem.pszText = szDiskSpace;
        lvItem.iSubItem = IDS_HOSTINGLIST_COLUMN_DIFFCONSUMPTION - IDS_HOSTINGLIST_COLUMN_VOLUME;
        m_ctrlVolumeList.SetItem(&lvItem);
    }
    
    dwSize = sizeof(szDiskSpace)/sizeof(TCHAR);
    DiskSpaceToString(m_llDiffVolumeFreeSpace, szDiskSpace, &dwSize);
    m_ctrlFreeSpace.SetWindowText(szDiskSpace);

    dwSize = sizeof(szDiskSpace)/sizeof(TCHAR);
    DiskSpaceToString(m_llDiffVolumeTotalSpace, szDiskSpace, &dwSize);
    m_ctrlTotalSpace.SetWindowText(szDiskSpace);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT CHosting::Init(
    IVssDifferentialSoftwareSnapshotMgmt* i_piDiffSnapMgmt,
    VSSUI_VOLUME_LIST*  i_pVolumeList,
    IN LPCTSTR          i_pszVolumeDisplayName,
    IN ULONGLONG        i_llDiffVolumeTotalSpace,
    IN ULONGLONG        i_llDiffVolumeFreeSpace
    )
{
    if (!i_piDiffSnapMgmt ||
        !i_pVolumeList ||
        !i_pszVolumeDisplayName || !*i_pszVolumeDisplayName)
        return E_INVALIDARG;

    m_strVolume = i_pszVolumeDisplayName;
    m_llDiffVolumeTotalSpace = i_llDiffVolumeTotalSpace;
    m_llDiffVolumeFreeSpace = i_llDiffVolumeFreeSpace;

    FreeDiffAreaList(&m_DiffAreaList);

    CComPtr<IVssEnumMgmtObject> spiEnum;
    HRESULT hr = i_piDiffSnapMgmt->QueryDiffAreasOnVolume((PTSTR)i_pszVolumeDisplayName, &spiEnum);
    if (FAILED(hr))
        return hr;

    VSS_MGMT_OBJECT_PROP Prop;
    VSS_DIFF_AREA_PROP* pDiffAreaProp = &(Prop.Obj.DiffArea);
    ULONG ulFetched = 0;
    while (SUCCEEDED(spiEnum->Next(1, &Prop, &ulFetched)) && ulFetched > 0)
    {
        if (VSS_MGMT_OBJECT_DIFF_AREA != Prop.Type)
            return E_FAIL;

        VSSUI_DIFFAREA *pDiffAreaInfo = (VSSUI_DIFFAREA *)calloc(1, sizeof(VSSUI_DIFFAREA));
        if (pDiffAreaInfo)
        {
            PTSTR pszVolumeDisplayName = GetDisplayName(i_pVolumeList, pDiffAreaProp->m_pwszVolumeName);
            PTSTR pszDiffVolumeDisplayName = GetDisplayName(i_pVolumeList, pDiffAreaProp->m_pwszDiffAreaVolumeName);
            if (pszVolumeDisplayName && pszDiffVolumeDisplayName)
            {
                lstrcpyn(pDiffAreaInfo->pszVolumeDisplayName, pszVolumeDisplayName, MAX_PATH);
                lstrcpyn(pDiffAreaInfo->pszDiffVolumeDisplayName, pszDiffVolumeDisplayName, MAX_PATH);
                pDiffAreaInfo->llMaximumDiffSpace = pDiffAreaProp->m_llMaximumDiffSpace;
                pDiffAreaInfo->llUsedDiffSpace = pDiffAreaProp->m_llAllocatedDiffSpace;

                m_DiffAreaList.push_back(pDiffAreaInfo);
            } else
            {
                free(pDiffAreaInfo); // indicate something inconsistent happened on the DiffVol, disgard this result.
            }
        } else
        {
            FreeDiffAreaList(&m_DiffAreaList);
            hr = E_OUTOFMEMORY;
        }

        ::CoTaskMemFree(pDiffAreaProp->m_pwszVolumeName);
        ::CoTaskMemFree(pDiffAreaProp->m_pwszDiffAreaVolumeName);
    }

    return hr;
}


void CHosting::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if (!pWnd)
        return;

    ::WinHelp(pWnd->GetSafeHwnd(),
                VSSUI_CTX_HELP_FILE,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(PVOID)aMenuHelpIDsForViewFiles); 
}

BOOL CHosting::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (!pHelpInfo || 
        pHelpInfo->iContextType != HELPINFO_WINDOW || 
        pHelpInfo->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)pHelpInfo->hItemHandle,
                VSSUI_CTX_HELP_FILE,
                HELP_WM_HELP,
                (DWORD_PTR)(PVOID)aMenuHelpIDsForViewFiles); 

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\hosting.h ===
#if !defined(AFX_HOSTING_H__0B0CBFCC_5235_439E_9482_385B52D23C6E__INCLUDED_)
#define AFX_HOSTING_H__0B0CBFCC_5235_439E_9482_385B52D23C6E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Hosting.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CHosting dialog

class CHosting : public CDialog
{
// Construction
public:
	CHosting(CWnd* pParent = NULL);   // standard constructor
	CHosting(LPCTSTR pszComputer, LPCTSTR pszVolume, CWnd* pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CHosting)
	enum { IDD = IDD_HOSTING };
	CEdit	m_ctrlFreeSpace;
	CEdit	m_ctrlTotalSpace;
	CListCtrl	m_ctrlVolumeList;
	CString	m_strVolume;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHosting)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
    HRESULT Init(
        IVssDifferentialSoftwareSnapshotMgmt* i_piDiffSnapMgmt,
        VSSUI_VOLUME_LIST*  i_pVolumeList,
        IN LPCTSTR          i_pszVolumeDisplayName,
        IN ULONGLONG        i_llDiffVolumeTotalSpace,
        IN ULONGLONG        i_llDiffVolumeFreeSpace
        );

protected:
	CString	    m_strComputer;
    ULONGLONG   m_llDiffVolumeTotalSpace;
    ULONGLONG   m_llDiffVolumeFreeSpace;
    VSSUI_DIFFAREA_LIST m_DiffAreaList;

	// Generated message map functions
	//{{AFX_MSG(CHosting)
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HOSTING_H__0B0CBFCC_5235_439E_9482_385B52D23C6E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vssui.rc
//
#define IDS_PROJNAME                    100
#define IDS_MENU_NAME                   101
#define IDS_MENU_STATUSBARTEXT          102
#define IDR_VSSUI                       104
#define IDR_VSSSHELLEXT                 105
#define IDS_VOLUMELIST_COLUMN_VOLUME    121
#define IDS_VOLUMELIST_COLUMN_NEXTRUNTIME 122
#define IDS_VOLUMELIST_COLUMN_NUMOFSHARES 123
#define IDS_VOLUMELIST_COLUMN_USED      124
#define IDS_SNAPSHOTLIST_COLUMN_TIMESTAMP 130
#define IDS_HOSTINGLIST_COLUMN_VOLUME   135
#define IDS_HOSTINGLIST_COLUMN_DIFFCONSUMPTION 136
#define IDS_HOSTINGLIST_COLUMN_DIFFLIMITS 137
#define IDS_DATE_TIME                   140
#define IDS_USED_ON_VOLUME              141
#define IDS_DISABLED                    142
#define IDS_SPACE_LABEL_B               143
#define IDS_SPACE_LABEL_KB              144
#define IDS_SPACE_LABEL_MB              145
#define IDS_NOLIMITS                    149
#define IDS_ERROR                       150
#define IDS_ERROR_HR                    151
#define IDS_VSSPROP_INIT_ERROR          152
#define IDS_VSSPROP_GETVOLUMES_ERROR    153
#define IDS_VSSPROP_EMPTY_VOLUMELIST    154
#define IDS_VSSPROP_VOLUME_ILEGIBLE     155
#define IDS_TAKESNAPSHOT_ERROR          156
#define IDS_DELETESNAPSHOTS_ERROR       157
#define IDS_FINDSCHEDULE_ERROR          158
#define IDS_CREATESCHEDULE_ERROR        159
#define IDS_DELETEDIFFAREA_ERROR        160
#define IDS_SETTINGS_ERROR              161
#define IDS_CHANGEDIFFAREAMAX_ERROR     162
#define IDS_ADDDIFFAREA_ERROR           163
#define IDS_VIEWFILES_ERROR             164
#define IDS_SCHEDULEPAGE_ERROR          165
#define IDS_LIMITS_NEEDED               166
#define IDS_DIFFASSOC_NOT_FOUND         167
#define IDS_DIFFASSOC_ALREADY_EXISTS    168
#define IDS_PERSISTSCHEDULE_ERROR       171
#define IDS_CANNOT_ENABLE_SMALL_VOLUME  172
#define IDS_DELETEDIFFAREA_ERROR_IN_USE 173
#define IDB_VOLUME_16x16                202
#define IDD_VSSPROP                     1000
#define IDC_EXPLANATION                 1001
#define IDC_VOLUME_LIST_LABLE           1002
#define IDC_VOLUME_LIST                 1003
#define IDC_ENABLE                      1004
#define IDC_DISABLE                     1005
#define IDC_SETTINGS                    1006
#define IDC_SNAPSHOT_LIST_LABLE         1007
#define IDC_SNAPSHOT_LIST               1008
#define IDC_CREATE                      1009
#define IDC_DELETE                      1010
#define IDC_VSSPROP_ERROR               1011
#define IDD_SETTINGS                    1020
#define IDC_SETTINGS_VOLUME             1021
#define IDC_SETTINGS_STORAGE_VOLUME     1022
#define IDC_SETTINGS_DIFFLIMITS_EDIT    1023
#define IDC_SETTINGS_DIFFLIMITS_SPIN    1024
#define IDC_SETTINGS_HOSTING            1027
#define IDC_SETTINGS_NOLIMITS           1028
#define IDC_SETTINGS_HAVELIMITS         1029
#define IDC_SETTINGS_MAXSIZE_LABEL      1030
#define IDC_SETTINGS_MB_STATIC          1031
#define IDC_SETTINGS_100MB_STATIC       1032
#define IDC_SETTINGS_SCHEDULE_STATIC    1033
#define IDD_HOSTING                     1040
#define IDC_HOSTING_VOLUME              1041
#define IDC_HOSTING_VOLUMELIST          1042
#define IDC_HOSTING_FREE_DISKSPACE      1043
#define IDC_HOSTING_TOTAL_DISKSPACE     1044
#define IDC_HOSTING_FREE_DISKSPACE_LABEL 1045
#define IDC_HOSTING_TOTAL_DISKSPACE_LABEL 1046
#define IDD_REMINDER_ENABLE             1049
#define IDD_REMINDER                    1050
#define IDC_MSG_ONOFF                   1051
#define IDC_MESSAGE                     1052
#define IDC_SCHEDULE                    1053
#define IDC_REMINDER_ICON               1063
#define IDC_SETTINGS_STORAGE_VOLUME_STATIC 1064
#define ID_CONFIG_SNAPSHOT              32768

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32769
#define _APS_NEXT_CONTROL_VALUE         1065
#define _APS_NEXT_SYMED_VALUE           156
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\remdlg.h ===
#if !defined(AFX_REMDLG_H__3FB35059_815F_45FC_B12D_E6B2F31204C1__INCLUDED_)
#define AFX_REMDLG_H__3FB35059_815F_45FC_B12D_E6B2F31204C1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RemDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CReminderDlg dialog

class CReminderDlg : public CDialog
{
// Construction
public:
    CReminderDlg(CWnd* pParent = NULL);   // standard constructor
    CReminderDlg(HKEY hKey, LPCTSTR pszRegValueName, CWnd* pParent = NULL);

// Dialog Data
    //{{AFX_DATA(CReminderDlg)
    enum { IDD = IDD_REMINDER };
    BOOL    m_bMsgOnOff;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CReminderDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    HKEY    m_hKey;
    CString m_strRegValueName;

    // Generated message map functions
    //{{AFX_MSG(CReminderDlg)
    virtual void OnOK();
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

class CReminderDlgEx : public CDialog
{
// Construction
public:
    CReminderDlgEx(CWnd* pParent = NULL);   // standard constructor
    CReminderDlgEx(HKEY hKey, LPCTSTR pszRegValueName, CWnd* pParent = NULL);

// Dialog Data
    //{{AFX_DATA(CReminderDlgEx)
    enum { IDD = IDD_REMINDER_ENABLE };
    BOOL    m_bMsgOnOff;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CReminderDlgEx)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    HKEY    m_hKey;
    CString m_strRegValueName;

    // Generated message map functions
    //{{AFX_MSG(CReminderDlgEx)
    virtual void OnOK();
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnHelpLink(NMHDR* pNMHDR, LRESULT* pResult);
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REMDLG_H__3FB35059_815F_45FC_B12D_E6B2F31204C1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\settings.h ===
#if !defined(AFX_HOSTED_H__46C0FDC0_6E97_40CF_807A_91051E61BB1F__INCLUDED_)
#define AFX_HOSTED_H__46C0FDC0_6E97_40CF_807A_91051E61BB1F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Settings.h : header file
//

#include "vssprop.h" // VSSUI_VOLUME_LIST

/////////////////////////////////////////////////////////////////////////////
// CSettings dialog

class CSettings : public CDialog
{
// Construction
public:
	CSettings(CWnd* pParent = NULL);   // standard constructor
	CSettings(LPCTSTR pszComputer, LPCTSTR pszVolume, CWnd* pParent = NULL);
    ~CSettings();

// Dialog Data
	//{{AFX_DATA(CSettings)
	enum { IDD = IDD_SETTINGS };
	CStatic	m_ctrlStorageVolumeStatic;
	CEdit	m_ctrlDiffLimits;
	CSpinButtonCtrl	m_ctrlSpin;
	CComboBox	m_ctrlStorageVolume;
	CString	m_strVolume;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSettings)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
    void _ResetInterfacePointers();
    HRESULT Init(
        IVssDifferentialSoftwareSnapshotMgmt *piDiffSnapMgmt,
        IN ITaskScheduler*      piTS,
        IN BOOL                 bCluster,
        IN VSSUI_VOLUME_LIST*   pVolumeList,
        IN BOOL                 bReadOnlyDiffVolume
    );
    HRESULT NotifyClusterTaskSchedulerResource(
        IN  ITaskScheduler* i_piTS,
        IN  LPCTSTR         i_pszVolumeName
        );

protected:
    CString             m_strComputer;
    CComPtr<IVssDifferentialSoftwareSnapshotMgmt> m_spiDiffSnapMgmt;
    CComPtr<ITaskScheduler> m_spiTS;
    BOOL                m_bCluster;

    VSSUI_VOLUME_LIST*  m_pVolumeList;
    CString             m_strDiffVolumeDisplayName;
    ULONGLONG           m_llMaximumDiffSpace;
	ULONGLONG	        m_llDiffLimitsInMB;
    BOOL                m_bHasDiffAreaAssociation;
    BOOL                m_bReadOnlyDiffVolume;
    ULONGLONG           m_llDiffVolumeTotalSpace;
    ULONGLONG           m_llDiffVolumeFreeSpace;
    CComPtr<ITask>      m_spiTask;
    PTSTR               m_pszTaskName;

	// Generated message map functions
	//{{AFX_MSG(CSettings)
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	afx_msg void OnViewFiles();
	afx_msg void OnSchedule();
	afx_msg void OnSelchangeDiffVolume();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnLimits();
	afx_msg void OnDeltaposSettingsSpin(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HOSTED_H__46C0FDC0_6E97_40CF_807A_91051E61BB1F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\shlext.h ===
// ShlExt.h : Declaration of the CVSSShellExt

#ifndef __VSSSHELLEXT_H_
#define __VSSSHELLEXT_H_

#include "resource.h"       // main symbols
#include <shlobj.h>

/////////////////////////////////////////////////////////////////////////////
// CVSSShellExt
class ATL_NO_VTABLE CVSSShellExt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CVSSShellExt, &CLSID_VSSShellExt>,
	public IShellExtInit,
    public IShellPropSheetExt
{
public:
	CVSSShellExt();

	~CVSSShellExt();

DECLARE_REGISTRY_RESOURCEID(IDR_VSSSHELLEXT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CVSSShellExt)
	COM_INTERFACE_ENTRY(IShellExtInit)
	COM_INTERFACE_ENTRY(IShellPropSheetExt)
END_COM_MAP()

// IVSSShellExt

public:
    // IShellExtInit Methods
    STDMETHOD(Initialize)
    (
            IN LPCITEMIDLIST        pidlFolder,
            IN LPDATAOBJECT         lpdobj,
            IN HKEY                 hkeyProgID
    );

    //IShellPropSheetExt methods
    STDMETHOD(AddPages)
        (
                IN LPFNADDPROPSHEETPAGE lpfnAddPage,
                IN LPARAM lParam
        );
    
    STDMETHOD(ReplacePage)
    (
            IN UINT uPageID,
            IN LPFNADDPROPSHEETPAGE lpfnReplaceWith,
            IN LPARAM lParam
    );

private:
    PTSTR                   m_lpszFile;
    CComPtr<IDataObject>    m_spiDataObject;
};

#endif //__VSSSHELLEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\remdlg.cpp ===
// RemDlg.cpp : implementation file
//

#include "stdafx.h"
#include "RemDlg.h"
#include "uihelp.h"
#include <htmlhelp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CReminderDlg dialog


CReminderDlg::CReminderDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CReminderDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CReminderDlg)
    m_bMsgOnOff = FALSE;
    //}}AFX_DATA_INIT
    m_hKey = NULL;
    m_strRegValueName = _T("");
}

CReminderDlg::CReminderDlg(HKEY hKey, LPCTSTR pszRegValueName, CWnd* pParent /*=NULL*/)
    : CDialog(CReminderDlg::IDD, pParent)
{
    m_bMsgOnOff = FALSE;
    m_hKey = hKey;
    m_strRegValueName = pszRegValueName;
}

void CReminderDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CReminderDlg)
    DDX_Check(pDX, IDC_MSG_ONOFF, m_bMsgOnOff);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CReminderDlg, CDialog)
    //{{AFX_MSG_MAP(CReminderDlg)
    ON_WM_CONTEXTMENU()
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CReminderDlg message handlers

void CReminderDlg::OnOK() 
{
    // TODO: Add extra validation here
    UpdateData(TRUE);

    if (m_bMsgOnOff && m_hKey && !m_strRegValueName.IsEmpty())
    {
        DWORD dwData = 1;
        (void)RegSetValueEx(m_hKey, m_strRegValueName, 0, REG_DWORD, (const BYTE *)&dwData, sizeof(DWORD));
    }

    CDialog::OnOK();
}

void CReminderDlg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if (!pWnd)
        return;

    ::WinHelp(pWnd->GetSafeHwnd(),
                VSSUI_CTX_HELP_FILE,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(PVOID)aMenuHelpIDsForReminder); 
}

BOOL CReminderDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (!pHelpInfo || 
        pHelpInfo->iContextType != HELPINFO_WINDOW || 
        pHelpInfo->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)pHelpInfo->hItemHandle,
                VSSUI_CTX_HELP_FILE,
                HELP_WM_HELP,
                (DWORD_PTR)(PVOID)aMenuHelpIDsForReminder); 

    return TRUE;
}

BOOL CReminderDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();

    HICON hIcon = ::LoadIcon(NULL, IDI_EXCLAMATION);
    ((CStatic*)GetDlgItem(IDC_REMINDER_ICON))->SetIcon(hIcon);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
// CReminderDlgEx dialog


CReminderDlgEx::CReminderDlgEx(CWnd* pParent /*=NULL*/)
    : CDialog(CReminderDlgEx::IDD, pParent)
{
    //{{AFX_DATA_INIT(CReminderDlgEx)
    m_bMsgOnOff = FALSE;
    //}}AFX_DATA_INIT
    m_hKey = NULL;
    m_strRegValueName = _T("");
}

CReminderDlgEx::CReminderDlgEx(HKEY hKey, LPCTSTR pszRegValueName, CWnd* pParent /*=NULL*/)
    : CDialog(CReminderDlgEx::IDD, pParent)
{
    m_bMsgOnOff = FALSE;
    m_hKey = hKey;
    m_strRegValueName = pszRegValueName;
}

void CReminderDlgEx::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CReminderDlgEx)
    DDX_Check(pDX, IDC_MSG_ONOFF, m_bMsgOnOff);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CReminderDlgEx, CDialog)
    //{{AFX_MSG_MAP(CReminderDlgEx)
    ON_WM_CONTEXTMENU()
    ON_WM_HELPINFO()
    ON_NOTIFY(NM_CLICK, IDC_MESSAGE, OnHelpLink)
    ON_NOTIFY(NM_RETURN, IDC_MESSAGE, OnHelpLink)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CReminderDlgEx message handlers

void CReminderDlgEx::OnOK() 
{
    // TODO: Add extra validation here
    UpdateData(TRUE);

    if (m_bMsgOnOff && m_hKey && !m_strRegValueName.IsEmpty())
    {
        DWORD dwData = 1;
        (void)RegSetValueEx(m_hKey, m_strRegValueName, 0, REG_DWORD, (const BYTE *)&dwData, sizeof(DWORD));
    }

    CDialog::OnOK();
}

void CReminderDlgEx::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if (!pWnd)
        return;

    ::WinHelp(pWnd->GetSafeHwnd(),
                VSSUI_CTX_HELP_FILE,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(PVOID)aMenuHelpIDsForReminder); 
}

BOOL CReminderDlgEx::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (!pHelpInfo || 
        pHelpInfo->iContextType != HELPINFO_WINDOW || 
        pHelpInfo->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)pHelpInfo->hItemHandle,
                VSSUI_CTX_HELP_FILE,
                HELP_WM_HELP,
                (DWORD_PTR)(PVOID)aMenuHelpIDsForReminder); 

    return TRUE;
}

void CReminderDlgEx::OnHelpLink(NMHDR* pNMHDR, LRESULT* pResult)
{
    CWaitCursor wait;

    ::HtmlHelp(0, _T("timewarp.chm"), HH_DISPLAY_TOPIC, (DWORD_PTR)(_T("best_practices_snapshot.htm")));

    *pResult = 0;
}

BOOL CReminderDlgEx::OnInitDialog() 
{
    CDialog::OnInitDialog();

    HICON hIcon = ::LoadIcon(NULL, IDI_INFORMATION);
    ((CStatic*)GetDlgItem(IDC_REMINDER_ICON))->SetIcon(hIcon);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\settings.cpp ===
// Settings.cpp : implementation file
//

#include "stdafx.h"
#include "utils.h"
#include "Settings.h"
#include "Hosting.h"
#include "uihelp.h"
#include <mstask.h>
#include <vsmgmt.h>

#include <clusapi.h>
#include <msclus.h>
#include <vs_clus.hxx>  // vss\server\inc

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSettings dialog


CSettings::CSettings(CWnd* pParent /*=NULL*/)
	: CDialog(CSettings::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSettings)
	m_strVolume = _T("");
	m_llDiffLimitsInMB = 0;
	//}}AFX_DATA_INIT
    m_strComputer = _T("");
    m_pszTaskName = NULL;
}

CSettings::CSettings(LPCTSTR pszComputer, LPCTSTR pszVolume, CWnd* pParent /*=NULL*/)
	: CDialog(CSettings::IDD, pParent)
{
	m_llDiffLimitsInMB = 0;
    m_strComputer = pszComputer + (TWO_WHACKS(pszComputer) ? 2 : 0);
    m_strVolume = pszVolume;
    m_pszTaskName = NULL;
}

CSettings::~CSettings()
{
    if (m_pszTaskName)
        free(m_pszTaskName);
}

void CSettings::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSettings)
	DDX_Control(pDX, IDC_SETTINGS_STORAGE_VOLUME_STATIC, m_ctrlStorageVolumeStatic);
	DDX_Control(pDX, IDC_SETTINGS_DIFFLIMITS_EDIT, m_ctrlDiffLimits);
	DDX_Control(pDX, IDC_SETTINGS_DIFFLIMITS_SPIN, m_ctrlSpin);
	DDX_Control(pDX, IDC_SETTINGS_STORAGE_VOLUME, m_ctrlStorageVolume);
	DDX_Text(pDX, IDC_SETTINGS_VOLUME, m_strVolume);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSettings, CDialog)
	//{{AFX_MSG_MAP(CSettings)
	ON_BN_CLICKED(IDC_SETTINGS_HOSTING, OnViewFiles)
	ON_BN_CLICKED(IDC_SCHEDULE, OnSchedule)
	ON_CBN_SELCHANGE(IDC_SETTINGS_STORAGE_VOLUME, OnSelchangeDiffVolume)
	ON_WM_CONTEXTMENU()
	ON_WM_HELPINFO()
	ON_BN_CLICKED(IDC_SETTINGS_HAVELIMITS, OnLimits)
	ON_BN_CLICKED(IDC_SETTINGS_NOLIMITS, OnLimits)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SETTINGS_DIFFLIMITS_SPIN, OnDeltaposSettingsSpin)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSettings message handlers

void CSettings::OnOK() 
{
    CWaitCursor wait;

    UpdateData(TRUE);

    PTSTR pszVolumeName = GetVolumeName(m_pVolumeList, m_strVolume);
    ASSERT(pszVolumeName);
    PTSTR pszDiffAreaVolumeName = GetVolumeName(m_pVolumeList, m_strDiffVolumeDisplayName);
    ASSERT(pszDiffAreaVolumeName);

    CString strDiffVolumeDisplayName;
    m_ctrlStorageVolume.GetWindowText(strDiffVolumeDisplayName);

    PTSTR pszNewDiffAreaVolumeName = GetVolumeName(m_pVolumeList, strDiffVolumeDisplayName);
    ASSERT(pszNewDiffAreaVolumeName);

    ULONGLONG llDiffLimitsInMB = 0;
    ULONGLONG llMaximumDiffSpace = 0;
    if (BST_CHECKED == IsDlgButtonChecked(IDC_SETTINGS_NOLIMITS))
    {
        llDiffLimitsInMB = VSS_ASSOC_NO_MAX_SPACE / g_llMB;
        llMaximumDiffSpace = VSS_ASSOC_NO_MAX_SPACE;
    } else
    {
        CString strDiffLimits;
        m_ctrlDiffLimits.GetWindowText(strDiffLimits);
        if (strDiffLimits.IsEmpty())
        {
            DoErrMsgBox(m_hWnd, MB_OK, 0, IDS_LIMITS_NEEDED);
            return;
        }

        llDiffLimitsInMB = (ULONGLONG)_ttoi64(strDiffLimits);
        if (llDiffLimitsInMB < MINIMUM_DIFF_LIMIT_MB)
        {
            DoErrMsgBox(m_hWnd, MB_OK, 0, IDS_LIMITS_NEEDED);
            return;
        }

        llMaximumDiffSpace = llDiffLimitsInMB * g_llMB;
    }

    HRESULT hr = S_OK;
    if (m_bReadOnlyDiffVolume ||
        m_bHasDiffAreaAssociation && !strDiffVolumeDisplayName.CompareNoCase(m_strDiffVolumeDisplayName))
    {
        if (llDiffLimitsInMB != m_llDiffLimitsInMB)
        {
            hr = m_spiDiffSnapMgmt->ChangeDiffAreaMaximumSize(
                                        pszVolumeName, 
                                        pszDiffAreaVolumeName, 
                                        llMaximumDiffSpace);
            if (SUCCEEDED(hr))
            {
                m_llDiffLimitsInMB = llDiffLimitsInMB;
                m_llMaximumDiffSpace = llMaximumDiffSpace;
            } else
            {
                switch (hr)
                {
                case VSS_E_OBJECT_NOT_FOUND:
                    {
                        // diff association not found, dialog closing
                        DoErrMsgBox(m_hWnd, MB_OK, 0, IDS_DIFFASSOC_NOT_FOUND);
                        break;
                    }
                default:
                    {
                        DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_CHANGEDIFFAREAMAX_ERROR);
                        return;
                    }
                }
            }
        }
    } else
    {
        if (m_bHasDiffAreaAssociation)
        {
            //
            // Diff Volume has been changed to a different value, we need to
            // remove the old association and create a new one
            //
            hr = m_spiDiffSnapMgmt->ChangeDiffAreaMaximumSize(
                                            pszVolumeName, 
                                            pszDiffAreaVolumeName, 
                                            VSS_ASSOC_REMOVE);
        }

        if (llMaximumDiffSpace > 0 && SUCCEEDED(hr))
        {
            hr = m_spiDiffSnapMgmt->AddDiffArea(
                                        pszVolumeName, 
                                        pszNewDiffAreaVolumeName, 
                                        llMaximumDiffSpace);
            if (SUCCEEDED(hr))
            {
                m_llDiffLimitsInMB = llDiffLimitsInMB;
                m_llMaximumDiffSpace = llMaximumDiffSpace;
                m_strDiffVolumeDisplayName = strDiffVolumeDisplayName;
            }
        }

        if (FAILED(hr))
        {
            switch (hr)
            {
            case VSS_E_OBJECT_ALREADY_EXISTS:
                {
                    // diff association already exists, dialog closing
                    DoErrMsgBox(m_hWnd, MB_OK, 0, IDS_DIFFASSOC_ALREADY_EXISTS);
                    break;
                }
            case VSS_E_OBJECT_NOT_FOUND:
                {
                    // diff association not found, dialog closing
                    DoErrMsgBox(m_hWnd, MB_OK, 0, IDS_DIFFASSOC_NOT_FOUND);
                    break;
                }
            default:
                {
                    DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_ADDDIFFAREA_ERROR);
                    return;
                }
            }
        }
    }

    // if m_spiTask association exists, persist the changes
    if ((ITask *)m_spiTask)
    {
        ///////////////////////////////////////////////////////////////////
        // Call IPersistFile::Save to save trigger to disk.
        ///////////////////////////////////////////////////////////////////
        CComPtr<IPersistFile> spiPersistFile;
        hr = m_spiTask->QueryInterface(IID_IPersistFile, (void **)&spiPersistFile);
        if (SUCCEEDED(hr))
            hr = spiPersistFile->Save(NULL, TRUE);

        ///////////////////////////////////////////////////////////////////
        // Notify Cluster Task Scheduler resource of the latest triggers
        ///////////////////////////////////////////////////////////////////
        if (SUCCEEDED(hr))
        {
            hr = NotifyClusterTaskSchedulerResource(m_spiTS, pszVolumeName);
        }

        // reset m_spiTask
        m_spiTask.Release();

        if (FAILED(hr))
        {
            DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_PERSISTSCHEDULE_ERROR);

            if (m_pszTaskName)
            {
                DeleteOneScheduledTimewarpTasks(
                                            m_spiTS,
                                            m_strComputer,
                                            m_pszTaskName
                                            );
                //m_spiTS->Delete(m_pszTaskName);
                free(m_pszTaskName);
                m_pszTaskName = NULL;
            }

            return;
        }
    }

	CDialog::OnOK();
}

HRESULT CSettings::NotifyClusterTaskSchedulerResource(
    IN  ITaskScheduler* i_piTS,
    IN  LPCTSTR         i_pszVolumeName
    )
{
    if (!i_piTS || !i_pszVolumeName || !*i_pszVolumeName)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    try
    {
        CVssClusterAPI cluster;
        bool bRet = cluster.Initialize(m_strComputer);
        CComPtr<ISClusResource> ptrResource;
        if (bRet)
            ptrResource = cluster.GetPhysicalDiskResourceForVolumeName(i_pszVolumeName);
        if (ptrResource)
        {
            PTSTR           pszTaskName = NULL;
            CComPtr<ITask>  spiTask;
            hr = FindScheduledTimewarpTask(i_piTS, i_pszVolumeName, &spiTask, &pszTaskName);
            if (FAILED(hr))
                throw hr;

            if (S_FALSE == hr)
            {
                (void)DeleteAllScheduledTimewarpTasks(i_piTS,
                                                    m_strComputer,
                                                    i_pszVolumeName,
                                                    TRUE // i_bDeleteDisabledOnesOnly
                                                    );
                throw hr;
            }

            WORD cTriggers = 0;
            hr = spiTask->GetTriggerCount(&cTriggers);
            if (FAILED(hr))
                throw hr;

            TASK_TRIGGER *pTriggers = NULL;
            if (cTriggers > 0)
            {
                pTriggers = (TASK_TRIGGER *)calloc(cTriggers, sizeof(TASK_TRIGGER));
                if (!pTriggers)
                    throw E_OUTOFMEMORY;
            }

            for (WORD i = 0; i < cTriggers; i++)
            {
                CComPtr<ITaskTrigger> spiTaskTrigger;
                hr = spiTask->GetTrigger(i, &spiTaskTrigger);
                if (FAILED(hr))
                    break;

                pTriggers[i].cbTriggerSize = sizeof(TASK_TRIGGER);
                hr = spiTaskTrigger->GetTrigger(pTriggers + i);
                if (FAILED(hr))
                    break;
            }

            if (SUCCEEDED(hr))
            {
                bRet = cluster.UpdateTaskSchedulerResource(pszTaskName, cTriggers, pTriggers);
                if (!bRet)
                    hr = E_FAIL;
            }

            if (pTriggers)
                free(pTriggers);

            throw hr;
        }
    } catch (HRESULT hrClus)
    {
        hr = hrClus;
    }

    return hr;
}

void CSettings::OnCancel() 
{
    CWaitCursor wait;

    //
    // before exit, we want to delete the schedule we have created
    //
    if (m_pszTaskName)
    {
        DeleteOneScheduledTimewarpTasks(
                                    m_spiTS,
                                    m_strComputer,
                                    m_pszTaskName
                                    );
        //m_spiTS->Delete(m_pszTaskName);
    }
	
	CDialog::OnCancel();
}

void CSettings::_ResetInterfacePointers()
{
    if ((IVssDifferentialSoftwareSnapshotMgmt *)m_spiDiffSnapMgmt)
        m_spiDiffSnapMgmt.Release();

    if ((ITaskScheduler *)m_spiTS)
        m_spiTS.Release();

    m_bCluster = FALSE;
}

HRESULT CSettings::Init(
    IVssDifferentialSoftwareSnapshotMgmt *piDiffSnapMgmt,
    ITaskScheduler*         piTS,
    BOOL                    bCluster,
    IN VSSUI_VOLUME_LIST*   pVolumeList,
    IN BOOL                 bReadOnlyDiffVolume
    )
{
    if (!piDiffSnapMgmt || !piTS ||
        !pVolumeList || pVolumeList->empty())
        return E_INVALIDARG;

    _ResetInterfacePointers();

    m_pVolumeList = pVolumeList;
    m_bReadOnlyDiffVolume = bReadOnlyDiffVolume;
    m_spiDiffSnapMgmt = piDiffSnapMgmt;
    m_spiTS = piTS;
    m_bCluster = bCluster;

    HRESULT hr = S_OK;
    do
    {
        VSSUI_DIFFAREA diffArea;
        hr = GetDiffAreaInfo(m_spiDiffSnapMgmt, m_pVolumeList, m_strVolume, &diffArea);
        if (FAILED(hr))
            break;

        m_bHasDiffAreaAssociation = (S_OK == hr);

        if (S_FALSE == hr)
        {
            hr = GetVolumeSpace(
                                m_spiDiffSnapMgmt,
                                m_strVolume,
                                &m_llDiffVolumeTotalSpace,
                                &m_llDiffVolumeFreeSpace);
            if (FAILED(hr))
                break;

            m_strDiffVolumeDisplayName = m_strVolume;
            m_llMaximumDiffSpace = max(m_llDiffVolumeTotalSpace * 0.1, MINIMUM_DIFF_LIMIT); // 10%
        } else
        {
            m_strDiffVolumeDisplayName = diffArea.pszDiffVolumeDisplayName;
            m_llMaximumDiffSpace = diffArea.llMaximumDiffSpace;

            hr = GetVolumeSpace(
                                m_spiDiffSnapMgmt,
                                m_strDiffVolumeDisplayName,
                                &m_llDiffVolumeTotalSpace,
                                &m_llDiffVolumeFreeSpace);
            if (FAILED(hr))
                break;
        }

        m_llDiffLimitsInMB = m_llMaximumDiffSpace / g_llMB;
    } while(0);

    if (FAILED(hr))
        _ResetInterfacePointers();

    return hr;
}

#define ULONGLONG_TEXTLIMIT         20  // 20 decimal digits for the biggest LONGLONG

BOOL CSettings::OnInitDialog() 
{
	CDialog::OnInitDialog();

    // Get list of volumes supported for diff areas
    // (Note: The volume list passed in Init() is a list of volumes supported for
    //  snapshot, not for diff area... If this list is not required here then vssprop
    //  may be changed to pass a different list...)
    VSSUI_VOLUME_LIST diffVolumeList;
    VSSUI_VOLUME_LIST *pDiffVolumeList = &diffVolumeList;

    HRESULT hrDiff = GetVolumesSupportedForDiffArea(m_spiDiffSnapMgmt, m_strVolume, pDiffVolumeList);
    if (FAILED(hrDiff))
        // Default to input list
        pDiffVolumeList = m_pVolumeList;

    // init diff volume combo box
    int nIndex = CB_ERR;
    BOOL bAdded = FALSE;
    BOOL bSelected = FALSE;
    for (VSSUI_VOLUME_LIST::iterator i = pDiffVolumeList->begin(); i != pDiffVolumeList->end(); i++)
    {
        nIndex = m_ctrlStorageVolume.AddString((*i)->pszDisplayName);
        if (CB_ERR != nIndex)
        {
            bAdded = TRUE;
            if(! m_strDiffVolumeDisplayName.CompareNoCase((*i)->pszDisplayName))
            {
                m_ctrlStorageVolume.SetCurSel(nIndex);
                bSelected = TRUE;
            }
        }
    }
    if (bAdded && !bSelected)
        // At least one volume added but none is selected - select first one
        // (this can happen when the volume is not supported as diff area)
        m_ctrlStorageVolume.SetCurSel(0);

    if (! FAILED(hrDiff))
        FreeVolumeList(&diffVolumeList);

    m_ctrlStorageVolume.EnableWindow(!m_bReadOnlyDiffVolume);
    m_ctrlStorageVolumeStatic.EnableWindow(!m_bReadOnlyDiffVolume);

    if (m_llMaximumDiffSpace == VSS_ASSOC_NO_MAX_SPACE)
        CheckDlgButton(IDC_SETTINGS_NOLIMITS, BST_CHECKED);
    else
        CheckDlgButton(IDC_SETTINGS_HAVELIMITS, BST_CHECKED);
    OnLimits();

    m_ctrlDiffLimits.SetLimitText(ULONGLONG_TEXTLIMIT);

    if (m_llDiffVolumeTotalSpace >= MINIMUM_DIFF_LIMIT) 
    {
        LONG maxSpinRange = min(0x7FFFFFFF, m_llDiffVolumeTotalSpace / g_llMB);
        maxSpinRange = (maxSpinRange / MINIMUM_DIFF_LIMIT_DELTA_MB) * MINIMUM_DIFF_LIMIT_DELTA_MB;
        m_ctrlSpin.SendMessage(UDM_SETRANGE32, MINIMUM_DIFF_LIMIT_MB, maxSpinRange);
    }
    else
        m_ctrlSpin.SendMessage(UDM_SETRANGE32, MINIMUM_DIFF_LIMIT_MB, 0x7FFFFFFF);

    if (m_llMaximumDiffSpace != VSS_ASSOC_NO_MAX_SPACE)
    {
        CString strDiffLimitsInMB;
        strDiffLimitsInMB.Format(_T("%I64d"), m_llDiffLimitsInMB);
        m_ctrlDiffLimits.SetWindowText(strDiffLimitsInMB);
    } else
        m_ctrlDiffLimits.SetWindowText(_T("")); // default to be 100MB, no need to localize

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSettings::OnViewFiles() 
{
    CWaitCursor wait;

    CString strStorageVolume;
    m_ctrlStorageVolume.GetWindowText(strStorageVolume);

    ULONGLONG   llDiffVolumeTotalSpace = 0;
    ULONGLONG   llDiffVolumeFreeSpace = 0;
    HRESULT hr = GetVolumeSpace(
                        m_spiDiffSnapMgmt,
                        strStorageVolume,
                        &llDiffVolumeTotalSpace,
                        &llDiffVolumeFreeSpace);

    if (SUCCEEDED(hr))
    {
        CHosting dlg(m_strComputer, strStorageVolume);
        hr = dlg.Init(m_spiDiffSnapMgmt,
                    m_pVolumeList,
                    strStorageVolume,
                    llDiffVolumeTotalSpace,
                    llDiffVolumeFreeSpace);

        if (SUCCEEDED(hr))
            dlg.DoModal();
    }

    if (FAILED(hr))
        DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_VIEWFILES_ERROR, strStorageVolume);
}

void CSettings::OnSchedule() 
{
    CWaitCursor wait;
    HRESULT hr = S_OK;
    BOOL bNewSchedule = FALSE;

    //
    // In case we have never associated m_spiTask with a schedule task, try to
    // associate it with an existing task, otherwise, with a new schedule task.
    //
    if (!m_spiTask)
    {
        PTSTR pszVolumeName = GetVolumeName(m_pVolumeList, m_strVolume);
        ASSERT(pszVolumeName);
        if (! pszVolumeName)
        {
            DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_FINDSCHEDULE_ERROR, m_strVolume);
            return;
        }

        hr = FindScheduledTimewarpTask((ITaskScheduler *)m_spiTS, pszVolumeName, &m_spiTask, NULL);
        if (FAILED(hr))
        {
            DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_FINDSCHEDULE_ERROR, m_strVolume);
            return;
        }

        if (S_OK != hr)
        {
            //
            // schedule not found, we need to create a new task with the default schedule
            //
            if (m_pszTaskName)
            {
                free(m_pszTaskName);
                m_pszTaskName = NULL;
            }

            hr = CreateDefaultEnableSchedule(
                                            (ITaskScheduler *)m_spiTS,
                                            m_strComputer,
                                            m_strVolume,
                                            pszVolumeName,
                                            &m_spiTask,
                                            &m_pszTaskName); // remember the taskname, we need to delete it if dlg is cancelled.
            if (FAILED(hr))
            {
                DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_CREATESCHEDULE_ERROR, m_strVolume);

                return;
            }

            bNewSchedule = TRUE;
        }
    }

    ASSERT((ITask *)m_spiTask);

    //
    // bring up the property sheet as modal with only the schedule tab
    //
    CComPtr<IProvideTaskPage> spiProvTaskPage;
    hr = m_spiTask->QueryInterface(IID_IProvideTaskPage, (void **)&spiProvTaskPage);
    if (SUCCEEDED(hr))
    {
        //
        // call GetPage with FALSE, we'll persist the schedule changes in OnOK
        //
        HPROPSHEETPAGE phPage = NULL;
        hr = spiProvTaskPage->GetPage(TASKPAGE_SCHEDULE, FALSE, &phPage);

        if (SUCCEEDED(hr))
        {
            PROPSHEETHEADER psh;
            ZeroMemory(&psh, sizeof(PROPSHEETHEADER));
            psh.dwSize = sizeof(PROPSHEETHEADER);
            psh.dwFlags = PSH_DEFAULT | PSH_NOAPPLYNOW;
            psh.hwndParent = m_hWnd;
            psh.hInstance = _Module.GetResourceInstance();
            psh.pszCaption = m_strVolume;
            psh.phpage = &phPage;
            psh.nPages = 1;

            int id = PropertySheet(&psh);

            //
            // BUG#428943 LinanT
            // In case this is a new schedule task created at this entry of button click,
            // we need to discard it if user cancels the schedule page.
            //
            if (IDOK != id && bNewSchedule)
            {
                if (m_pszTaskName)
                {
                    DeleteOneScheduledTimewarpTasks(
                                                m_spiTS,
                                                m_strComputer,
                                                m_pszTaskName
                                                );
                    //m_spiTS->Delete(m_pszTaskName);
                    free(m_pszTaskName);
                    m_pszTaskName = NULL;
                }

                // reset m_spiTask
                m_spiTask.Release();
            }
        }
    }

    if (FAILED(hr))
    {
        DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_SCHEDULEPAGE_ERROR);

        if (m_pszTaskName)
        {
            DeleteOneScheduledTimewarpTasks(
                                        m_spiTS,
                                        m_strComputer,
                                        m_pszTaskName
                                        );
            //m_spiTS->Delete(m_pszTaskName);
            free(m_pszTaskName);
            m_pszTaskName = NULL;
        }

        // reset m_spiTask
        m_spiTask.Release();
    }

    return;
}

void CSettings::OnSelchangeDiffVolume() 
{
    CWaitCursor wait;

	int nIndex = m_ctrlStorageVolume.GetCurSel();
    ASSERT(CB_ERR != nIndex);

    CString strDiffVolumeDisplayName;
    m_ctrlStorageVolume.GetLBText(nIndex, strDiffVolumeDisplayName);

    ULONGLONG   llDiffVolumeTotalSpace = 0;
    ULONGLONG   llDiffVolumeFreeSpace = 0;
    HRESULT hr = GetVolumeSpace(
                        m_spiDiffSnapMgmt,
                        strDiffVolumeDisplayName,
                        &llDiffVolumeTotalSpace,
                        &llDiffVolumeFreeSpace);

    if (SUCCEEDED(hr))
    {
        if (llDiffVolumeTotalSpace >= MINIMUM_DIFF_LIMIT)
        {
            LONG maxSpinRange = min(0x7FFFFFFF, llDiffVolumeTotalSpace / g_llMB);
            maxSpinRange = (maxSpinRange / MINIMUM_DIFF_LIMIT_DELTA_MB) * MINIMUM_DIFF_LIMIT_DELTA_MB;
            m_ctrlSpin.SendMessage(UDM_SETRANGE32, MINIMUM_DIFF_LIMIT_MB, maxSpinRange);
        }
        else
            m_ctrlSpin.SendMessage(UDM_SETRANGE32, MINIMUM_DIFF_LIMIT_MB, 0x7FFFFFFF);
    }
}

void CSettings::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if (!pWnd)
        return;

    ::WinHelp(pWnd->GetSafeHwnd(),
                VSSUI_CTX_HELP_FILE,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(PVOID)aMenuHelpIDsForSettings); 
}

BOOL CSettings::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (!pHelpInfo || 
        pHelpInfo->iContextType != HELPINFO_WINDOW || 
        pHelpInfo->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)pHelpInfo->hItemHandle,
                VSSUI_CTX_HELP_FILE,
                HELP_WM_HELP,
                (DWORD_PTR)(PVOID)aMenuHelpIDsForSettings); 

	return TRUE;
}

void CSettings::OnLimits() 
{
	// TODO: Add your control notification handler code here
	
    BOOL bNoLimits = (BST_CHECKED == IsDlgButtonChecked(IDC_SETTINGS_NOLIMITS));

    m_ctrlDiffLimits.EnableWindow(!bNoLimits);
    m_ctrlSpin.EnableWindow(!bNoLimits);
}

void CSettings::OnDeltaposSettingsSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

    // Change delta to min-diff-area-size-delta instead of the spin control default which is 1
    ASSERT(pNMUpDown);
    int pos = pNMUpDown->iPos;
    if (pNMUpDown->iDelta == 1)
        pNMUpDown->iDelta = 
            (pos / MINIMUM_DIFF_LIMIT_DELTA_MB + 1) * MINIMUM_DIFF_LIMIT_DELTA_MB - pos;
    else if (pNMUpDown->iDelta == -1)
        pNMUpDown->iDelta = 
            (pos - 1) / MINIMUM_DIFF_LIMIT_DELTA_MB * MINIMUM_DIFF_LIMIT_DELTA_MB - pos;
	
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\shlext.cpp ===
// ShlExt.cpp : Implementation of CVSSShellExt
#include "stdafx.h"
#include "Vssui.h"
#include "ShlExt.h"
#include "vssprop.h"

#include <shellapi.h>

/////////////////////////////////////////////////////////////////////////////
// CVSSShellExt

CVSSShellExt::CVSSShellExt()
{
#ifdef DEBUG
    OutputDebugString(_T("CVSSShellExt::CVSSShellExt\n"));
#endif
    m_lpszFile = NULL;
}

CVSSShellExt::~CVSSShellExt()
{
#ifdef DEBUG
    OutputDebugString(_T("CVSSShellExt::~CVSSShellExt\n"));
#endif
    if (m_lpszFile)
    {
        delete [] m_lpszFile;
        m_lpszFile = NULL;
    }
}

STDMETHODIMP CVSSShellExt::Initialize(
    IN LPCITEMIDLIST        pidlFolder, // For property sheet extensions, this parameter is NULL
    IN LPDATAOBJECT         lpdobj,
    IN HKEY                 hkeyProgID  // not used in property sheet extensions
)
{
    HRESULT hr = S_OK;

    if ((IDataObject *)m_spiDataObject)
        m_spiDataObject.Release();

    if (lpdobj)
    {
        m_spiDataObject = lpdobj;

        STGMEDIUM   medium;
        FORMATETC   fe = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        UINT        uCount = 0;

        hr = m_spiDataObject->GetData(&fe, &medium);
        if (FAILED(hr))
        {
            fe.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_MOUNTEDVOLUME);
            hr = m_spiDataObject->GetData(&fe, &medium);
        }

        if (SUCCEEDED(hr))
        {
            if (m_lpszFile)
            {
                delete [] m_lpszFile;
                m_lpszFile = NULL;
            }

            uCount = DragQueryFile((HDROP)medium.hGlobal, (UINT)-1, NULL, 0);
            if (uCount > 0)
            {
                UINT uiChars = DragQueryFile ((HDROP) medium.hGlobal, 0, NULL, 0);
                m_lpszFile = new TCHAR [uiChars + 1];
                if (!m_lpszFile)
                {
                    hr = E_OUTOFMEMORY;
                } else
                {
                    ZeroMemory(m_lpszFile, sizeof(TCHAR) * (uiChars + 1));
                    DragQueryFile ((HDROP) medium.hGlobal, 0, m_lpszFile, uiChars + 1);
                }

            } else
            {
                hr = E_FAIL;
            }

            ReleaseStgMedium(&medium);
        }
    }

    return hr;
}

LPFNPSPCALLBACK _OldPropertyPageCallback;

UINT CALLBACK _NewPropertyPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    ASSERT(_OldPropertyPageCallback);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // First, let the old callback function handles the msg.
    //
    UINT i = _OldPropertyPageCallback(hwnd, uMsg, ppsp);

    //
    // Then, we release our page here
    //
    if (uMsg == PSPCB_RELEASE)
    {
        ASSERT(ppsp);
        CVSSProp* pPage = (CVSSProp*)(ppsp->lParam);
        ASSERT(pPage);
        delete pPage;
    }

    return i;
}


void ReplacePropertyPageCallback(void* vpsp)
{
    ASSERT(vpsp);
    LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE)vpsp;
    _OldPropertyPageCallback = ppsp->pfnCallback; // save the old callback function
    ppsp->pfnCallback = _NewPropertyPageCallback; // replace with our own callback
}

//
// From RaymondC:
// If you didn't add a page, you still return S_OK -- you successfully added zero pages.
// If you add some pages and then you want one of those added pages to be the default, 
// you return ResultFromShort(pagenumber+1).  S_FALSE = ResultFromShort(1).
//
STDMETHODIMP CVSSShellExt::AddPages(
    IN LPFNADDPROPSHEETPAGE lpfnAddPage,
    IN LPARAM lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // we only add our page if local machine is postW2K server
    //
    if (!IsPostW2KServer(NULL))
        return S_OK;

    //
    // we only add our page for local fixed non-FAT drive
    //
    if (DRIVE_FIXED != GetDriveType(m_lpszFile))
        return S_OK;

    TCHAR  szFileSystemName[MAX_PATH] = _T("");
    DWORD  dwMaxCompLength = 0, dwFileSystemFlags = 0;
    GetVolumeInformation(m_lpszFile, NULL, 0, NULL, &dwMaxCompLength,
                         &dwFileSystemFlags, szFileSystemName, MAX_PATH);
    if (CSTR_EQUAL != CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, _T("NTFS"), -1, szFileSystemName, -1))
      return S_OK;

    CVSSProp *pPage = new CVSSProp(_T(""), m_lpszFile);
    if (!pPage)
        return E_OUTOFMEMORY;

    if (pPage->m_psp.dwFlags & PSP_USECALLBACK)
    {
        //
        // Replace with our own callback function such that we can delete pPage
        // when the property sheet is closed.
        //
        // Note: don't change m_psp.lParam, which has to point to CVSSProp object;
        // otherwise, MFC won't hook up message handler correctly.
        //
        ReplacePropertyPageCallback(&(pPage->m_psp));

        //
        // Fusion MFC-based property page
        //
        PROPSHEETPAGE_V3 sp_v3 = {0};
        CopyMemory (&sp_v3, &(pPage->m_psp), (pPage->m_psp).dwSize);
        sp_v3.dwSize = sizeof(sp_v3);

        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&sp_v3);
        if (hPage)
        {
            if (lpfnAddPage(hPage, lParam))
            {
                // Store this pointer in pPage in order to keep our dll loaded,
                // it will be released when pPage gets deleted.
                pPage->StoreShellExtPointer((IShellPropSheetExt *)this);
                return S_OK;
            }

            DestroyPropertySheetPage(hPage);
            hPage = NULL;
        }
    }

    delete pPage;

    return S_OK;
}

//
// The shell doesn't call ReplacePage
//
STDMETHODIMP CVSSShellExt::ReplacePage(
    IN UINT uPageID,
    IN LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    IN LPARAM lParam
)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\snapext.h ===
#ifndef __SNAPEXT_H_
#define __SNAPEXT_H_
#include "resource.h"
#include <atlsnap.h>
#include "vssprop.h"

class CVSSUIExtData1 : public CSnapInItemImpl<CVSSUIExtData1, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	BEGIN_SNAPINCOMMAND_MAP(CVSSUIExtData1, FALSE)
	END_SNAPINCOMMAND_MAP()

//	SNAPINMENUID(IDR_VSSUI_MENU)

	CVSSUIExtData1()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CVSSUIExtData1()
	{
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}
};

class CVSSUIExtData2 : public CSnapInItemImpl<CVSSUIExtData2, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	BEGIN_SNAPINCOMMAND_MAP(CVSSUIExtData2, FALSE)
	END_SNAPINCOMMAND_MAP()

//	SNAPINMENUID(IDR_VSSUI_MENU)  // use the same context menu

	CVSSUIExtData2()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CVSSUIExtData2()
	{
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}
};

class CVSSUI :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CSnapInObjectRoot<0, CVSSUI>,
	public IExtendContextMenuImpl<CVSSUI>,
//    public IExtendPropertySheetImpl<CVSSUI>,
	public CComCoClass<CVSSUI, &CLSID_VSSUI>
{
public:
	CVSSUI();
	~CVSSUI();

EXTENSION_SNAPIN_DATACLASS(CVSSUIExtData1)
EXTENSION_SNAPIN_DATACLASS(CVSSUIExtData2)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CVSSUI)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CVSSUIExtData1)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CVSSUIExtData2)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CVSSUI)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
//    COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_VSSUI)

DECLARE_NOT_AGGREGATABLE(CVSSUI)


	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();
	}

    ///////////////////////////////
    // Interface IExtendContextMenu
    ///////////////////////////////

    //
    // overwrite AddMenuItems() such that we only add the menu item
    // when targeted machine belongs to postW2K server SKUs.
    //
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems(
    /* [in] */ LPDATAOBJECT piDataObject,
    /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
    /* [out][in] */ long *pInsertionAllowed);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command(
    /* [in] */ long lCommandID,
    /* [in] */ LPDATAOBJECT piDataObject);

    ///////////////////////////////
    // Interface IExtendPropertySheet
    ///////////////////////////////
//    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
//        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
//        /* [in] */ LONG_PTR handle,
//        /* [in] */ LPDATAOBJECT lpIDataObject);
    
//    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
//    /* [in] */ LPDATAOBJECT lpDataObject) { return S_OK; }

    HRESULT InvokePropSheet(LPDATAOBJECT piDataObject);
    
private:
    CVSSProp* m_pPage;
};

HRESULT ExtractData(
    IDataObject* piDataObject,
    CLIPFORMAT   cfClipFormat,
    BYTE*        pbData,
    DWORD        cbData 
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__371FD9E3_CB47_4FA1_BF6D_986FF1B98013__INCLUDED_)
#define AFX_STDAFX_H__371FD9E3_CB47_4FA1_BF6D_986FF1B98013__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxcmn.h>         // MFC common controls
#include <afxext.h>         // MFC extensions
//#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

#include "resource.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__371FD9E3_CB47_4FA1_BF6D_986FF1B98013__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\snapext.cpp ===
#include "stdafx.h"
#include "Vssui.h"
#include "snapext.h"
#include "VSSProp.h"

/////////////////////////////////////////////////////////////////////////////
// CVSSUIComponentData

static const GUID CVSSUIExtGUID1_NODETYPE = 
{ 0x4e410f0e, 0xabc1, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
const GUID*  CVSSUIExtData1::m_NODETYPE = &CVSSUIExtGUID1_NODETYPE;
const OLECHAR* CVSSUIExtData1::m_SZNODETYPE = OLESTR("4e410f0e-abc1-11d0-b944-00c04fd8d5b0");
const OLECHAR* CVSSUIExtData1::m_SZDISPLAY_NAME = OLESTR("");
const CLSID* CVSSUIExtData1::m_SNAPIN_CLASSID = &CLSID_VSSUI;

static const GUID CVSSUIExtGUID2_NODETYPE = 
{ 0x312B59C1, 0x4002, 0x11d0, { 0x96, 0xF8, 0x0, 0xA0, 0xC9, 0x19, 0x16, 0x01 } };
const GUID*  CVSSUIExtData2::m_NODETYPE = &CVSSUIExtGUID2_NODETYPE;
const OLECHAR* CVSSUIExtData2::m_SZNODETYPE = OLESTR("312B59C1-4002-11d0-96F8-00A0C9191601");
const OLECHAR* CVSSUIExtData2::m_SZDISPLAY_NAME = OLESTR("");
const CLSID* CVSSUIExtData2::m_SNAPIN_CLASSID = &CLSID_VSSUI;

CVSSUI::CVSSUI()
{
#ifdef DEBUG
    OutputDebugString(_T("CVSSUI::CVSSUI\n"));
#endif
    m_pComponentData = this;
    m_pPage = NULL;
}

CVSSUI::~CVSSUI()
{
#ifdef DEBUG
    OutputDebugString(_T("CVSSUI::~CVSSUI\n"));
#endif
    if (m_pPage)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        delete m_pPage;
        m_pPage = NULL;
    }
}
///////////////////////////////
// Interface IExtendContextMenu
///////////////////////////////

CLIPFORMAT g_cfMachineName = (CLIPFORMAT)RegisterClipboardFormat(_T("MMC_SNAPIN_MACHINE_NAME"));

HRESULT CVSSUI::AddMenuItems(
    LPDATAOBJECT piDataObject,
    LPCONTEXTMENUCALLBACK piCallback,
    long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // we add the context menu item only when targeted machine belongs to postW2K server SKUs
    //
    TCHAR szMachineName[MAX_PATH] = {0};
    HRESULT hr = ExtractData(piDataObject, g_cfMachineName, (PBYTE)szMachineName, MAX_PATH);
    if (FAILED(hr))
        return hr;

    CComPtr<IContextMenuCallback2> spiCallback2;
    hr = piCallback->QueryInterface(IID_IContextMenuCallback2, (void **)&spiCallback2);
    if (FAILED(hr))
        return hr;

    if (IsPostW2KServer(szMachineName))
    {
        CString strMenuName;
        strMenuName.LoadString(IDS_MENU_NAME);
        CString strStatusBarText;
        strStatusBarText.LoadString(IDS_MENU_STATUSBARTEXT);

        CONTEXTMENUITEM2   ContextMenuItem;
        ZeroMemory(&ContextMenuItem, sizeof(CONTEXTMENUITEM));
        ContextMenuItem.strName = (LPTSTR)(LPCTSTR)strMenuName;
        ContextMenuItem.strStatusBarText = (LPTSTR)(LPCTSTR)strStatusBarText;
        ContextMenuItem.lCommandID = ID_CONFIG_SNAPSHOT;
        ContextMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
        ContextMenuItem.strLanguageIndependentName = _T("ConfigVSS");

        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
            hr = spiCallback2->AddItem(&ContextMenuItem);
    }

    return hr;
}

HRESULT CVSSUI::Command(
    IN long lCommandID,
    IN LPDATAOBJECT piDataObject)
{
    switch (lCommandID)
    {
    case ID_CONFIG_SNAPSHOT:
        {
            InvokePropSheet(piDataObject);
        }
        break;
    }

    return S_OK;
}

HRESULT ExtractData(
    IDataObject* piDataObject,
    CLIPFORMAT   cfClipFormat,
    BYTE*        pbData,
    DWORD        cbData )
{
    HRESULT hr = S_OK;
    
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL, NULL};
    
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            break;
        }
        
        BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            hr = E_UNEXPECTED;
            break;
        }

        ::memcpy( pbData, pbNewData, cbData );

    } while (FALSE); // false loop
    
    if (stgmedium.hGlobal)
        ::GlobalFree(stgmedium.hGlobal);

    return hr;
}

//
// disable the "Cancel" button on the property sheet
//
int CALLBACK SnapinPropSheetProc(
    HWND hwndDlg, 
    UINT uMsg, 
    LPARAM lParam )
{
    if (PSCB_INITIALIZED == uMsg)
    {
        HWND hwnd = GetDlgItem(hwndDlg, IDCANCEL);
        if (hwnd)
            EnableWindow(hwnd, FALSE);
    }

    return 0;
}

//
// This function invokes a modal property sheet.
//
void ReplacePropertyPageCallback(void* vpsp);  // implemented in shlext.cpp
HRESULT CVSSUI::InvokePropSheet(LPDATAOBJECT piDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWaitCursor wait;

    TCHAR szMachineName[MAX_PATH] = {0};
    HRESULT hr = ExtractData(piDataObject, g_cfMachineName, (PBYTE)szMachineName, MAX_PATH);
    if (FAILED(hr))
        return hr;

    CString strTitle;
    strTitle.LoadString(IDS_PROJNAME);

    CVSSProp *pPage = new CVSSProp(szMachineName, NULL);
    if (!pPage)
        return E_OUTOFMEMORY;

    if (pPage->m_psp.dwFlags & PSP_USECALLBACK)
    {
        //
        // Replace with our own callback function such that we can delete pPage
        // when the property sheet is closed.
        //
        // Note: don't change m_psp.lParam, which has to point to CVSSProp object;
        // otherwise, MFC won't hook up message handler correctly.
        //
        ReplacePropertyPageCallback(&(pPage->m_psp));
    }

    PROPSHEETHEADER psh;
    ZeroMemory(&psh, sizeof(psh));
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_USECALLBACK;
    psh.hwndParent = ::GetActiveWindow();
    psh.hInstance = _Module.GetResourceInstance();
    psh.pszCaption = strTitle;
    psh.nPages = 1;
    psh.nStartPage = 0;
    psh.ppsp = (LPCPROPSHEETPAGE)&(pPage->m_psp);
    psh.pfnCallback = SnapinPropSheetProc;

    PropertySheet(&psh); // this will do a modal proerty sheet

    return S_OK;
}

/*
//
// This function invokes a modaless property sheet.
//
HRESULT CVSSUI::InvokePropSheet(LPDATAOBJECT piDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWaitCursor wait;

    //
    // CoCreate an instance of the MMC Node Manager to obtain
    // an IPropertySheetProvider interface pointer
    //
    
    CComPtr<IPropertySheetProvider> spiPropertySheetProvider;
    HRESULT hr = CoCreateInstance(CLSID_NodeManager, NULL, 
                                CLSCTX_INPROC_SERVER, 
                                IID_IPropertySheetProvider, 
                                (void **)&spiPropertySheetProvider);
    if (FAILED(hr))
        return hr;
    
    //
    // Create the property sheet
    //
    CString strTitle;
    strTitle.LoadString(IDS_PROJNAME);
    hr = spiPropertySheetProvider->CreatePropertySheet(
                    strTitle, // pointer to the property page title
                    TRUE,           // property sheet
                    NULL,           // cookie of current object - can be NULL for extension snap-ins
                    piDataObject,   // data object of selected node
                    NULL            // specifies flags set by the method call
                    );
 
    if (FAILED(hr))
        return hr;
     
    //
    // Call AddPrimaryPages. MMC will then call the
    // IExtendPropertySheet methods of our property sheet extension object
    //
    hr = spiPropertySheetProvider->AddPrimaryPages(
                    reinterpret_cast<IUnknown *>(this), // pointer to our object's IUnknown
                    FALSE, // specifies whether to create a notification handle
                    NULL,  // must be NULL
                    TRUE   // scope pane; FALSE for result pane
                    );
 
    if (FAILED(hr))
        return hr;
 
    //
    // Allow property page extensions to add
    // their own pages to the property sheet
    //
    hr = spiPropertySheetProvider->AddExtensionPages();
    
    if (FAILED(hr))
        return hr;
 
    //
    //Display property sheet
    //
    hr = spiPropertySheetProvider->Show((LONG_PTR)::GetActiveWindow(),0);
//    hr = spiPropertySheetProvider->Show(NULL,0); //NULL is allowed for modeless prop sheet
    
    return hr;
}

HRESULT CVSSUI::CreatePropertyPages( 
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    LPDATAOBJECT piDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TCHAR szMachineName[MAX_PATH] = {0};
    HRESULT hr = ExtractData(piDataObject, g_cfMachineName, (PBYTE)szMachineName, MAX_PATH);
    if (FAILED(hr))
        return hr;

    m_pPage = new CVSSProp(szMachineName, NULL);
    if (m_pPage)
    {
        CPropertyPage* pBasePage = m_pPage;
        MMCPropPageCallback(&(pBasePage->m_psp));
        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&(pBasePage->m_psp));

        if (hPage)
        {
            hr = lpProvider->AddPage(hPage);
            if (FAILED(hr))
                DestroyPropertySheetPage(hPage);
        } else
            hr = E_FAIL;

        if (FAILED(hr))
        {
            delete m_pPage;
            m_pPage = NULL;
        }
    } else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\uihelp.h ===
#ifndef _VSSHELP_H_
#define _VSSHELP_H_

#define VSSUI_CTX_HELP_FILE             _T("timewarp.hlp")

#define IDH_SETTINGS_VOLUME             1021
#define IDH_SETTINGS_STORAGE_VOLUME     1022
#define IDH_SETTINGS_DIFFLIMITS_EDIT    1023
#define IDH_SETTINGS_DIFFLIMITS_SPIN    1024
#define IDH_SETTINGS_HOSTING            1027
#define IDH_SETTINGS_NOLIMITS           1028
#define IDH_SETTINGS_HAVELIMITS         1029
#define IDH_SCHEDULE                    1053

#define IDH_HOSTING_VOLUME              1041
#define IDH_HOSTING_VOLUMELIST          1044
#define IDH_MSG_ONOFF                   1051

#define IDH_VOLUME_LIST                 1003
#define IDH_ENABLE                      1005
#define IDH_DISABLE                     1007
#define IDH_SETTINGS                    1009
#define IDH_SNAPSHOT_LIST               1010
#define IDH_CREATE                      1012
#define IDH_DELETE                      1013

static const DWORD aMenuHelpIDsForVSSProp[] =
{
    IDC_EXPLANATION,                -1,
    IDC_VOLUME_LIST_LABLE,          IDH_VOLUME_LIST,
    IDC_VOLUME_LIST,                IDH_VOLUME_LIST,
    IDC_ENABLE,                     IDH_ENABLE,
    IDC_DISABLE,                    IDH_DISABLE,
    IDC_SETTINGS,                   IDH_SETTINGS,
    IDC_SNAPSHOT_LIST_LABLE,        -1,
    IDC_SNAPSHOT_LIST,              IDH_SNAPSHOT_LIST,
    IDC_CREATE,                     IDH_CREATE,
    IDC_DELETE,                     IDH_DELETE,
    IDC_VSSPROP_ERROR,              -1,
    0,                              0
};

static const DWORD aMenuHelpIDsForSettings[] =
{
    IDC_SETTINGS_VOLUME,            IDH_SETTINGS_VOLUME,
    IDC_SETTINGS_STORAGE_VOLUME_STATIC, IDH_SETTINGS_STORAGE_VOLUME,
    IDC_SETTINGS_STORAGE_VOLUME,    IDH_SETTINGS_STORAGE_VOLUME,
    IDC_SETTINGS_HOSTING,           IDH_SETTINGS_HOSTING,
    IDC_SETTINGS_MAXSIZE_LABEL,     -1,
    IDC_SETTINGS_NOLIMITS,          IDH_SETTINGS_NOLIMITS,
    IDC_SETTINGS_HAVELIMITS,        IDH_SETTINGS_HAVELIMITS,
    IDC_SETTINGS_DIFFLIMITS_EDIT,   IDH_SETTINGS_DIFFLIMITS_EDIT,
    IDC_SETTINGS_DIFFLIMITS_SPIN,   IDH_SETTINGS_DIFFLIMITS_SPIN,
    IDC_SETTINGS_MB_STATIC,         -1,
    IDC_SETTINGS_100MB_STATIC,      -1,
    IDC_SCHEDULE,                   IDH_SCHEDULE,
    IDC_SETTINGS_SCHEDULE_STATIC,   -1,
    0,                              0
};
 
static const DWORD aMenuHelpIDsForViewFiles[] =
{
    IDC_HOSTING_VOLUME,             IDH_HOSTING_VOLUME,
    IDC_HOSTING_VOLUMELIST,         IDH_HOSTING_VOLUMELIST,
    IDC_HOSTING_FREE_DISKSPACE_LABEL, -1,
    IDC_HOSTING_FREE_DISKSPACE,     -1,
    IDC_HOSTING_TOTAL_DISKSPACE_LABEL, -1,
    IDC_HOSTING_TOTAL_DISKSPACE,    -1,
    0,                              0
};

static const DWORD aMenuHelpIDsForReminder[] =
{
    IDC_REMINDER_ICON,              -1,
    IDC_MESSAGE,                    -1,
    IDC_MSG_ONOFF,                  IDH_MSG_ONOFF,
    0,                              0
};

#endif // _VSSHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\utils.cpp ===
// Utils.cpp : helper functions
//

#include "stdafx.h"
#include "utils.h"
#include <lm.h>

#include <clusapi.h>
#include <msclus.h>
#include <vs_clus.hxx> // vss\server\inc

ULONGLONG g_llKB = 1024;
ULONGLONG g_llMB = 1024 * 1024;

HRESULT
AddLVColumns(
  IN const HWND     hwndListBox,
  IN const INT      iStartingResourceID,
  IN const UINT     uiColumns
  )
{
  //
  // calculate the listview column width
  //
  RECT      rect;
  ZeroMemory(&rect, sizeof(rect));
  ::GetWindowRect(hwndListBox, &rect);
  int nControlWidth = rect.right - rect.left;
  int nVScrollbarWidth = GetSystemMetrics(SM_CXVSCROLL);
  int nBorderWidth = GetSystemMetrics(SM_CXBORDER);
  int nControlNetWidth = nControlWidth - 4 * nBorderWidth;
  int nWidth = nControlNetWidth / uiColumns;

  LVCOLUMN  lvColumn;
  ZeroMemory(&lvColumn, sizeof(lvColumn));
  lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

  lvColumn.fmt = LVCFMT_LEFT;
  lvColumn.cx = nWidth;

  for (UINT i = 0; i < uiColumns; i++)
  {
    CString  strColumnText;
    strColumnText.LoadString(iStartingResourceID + i);

    lvColumn.pszText = (LPTSTR)(LPCTSTR)strColumnText;
    lvColumn.iSubItem = i;

    ListView_InsertColumn(hwndListBox, i, &lvColumn);
  }

  return S_OK;
}

LPARAM GetListViewItemData(
    IN HWND hwndList,
    IN int  index
)
{
    if (-1 == index)
        return NULL;

    LVITEM lvItem;
    ZeroMemory(&lvItem, sizeof(lvItem));

    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = index;
    if (ListView_GetItem(hwndList, &lvItem))
        return lvItem.lParam;

    return NULL;
}

int MyCompareStringN(
    IN LPCTSTR  lpString1,
    IN LPCTSTR  lpString2,
    IN UINT     cchCount,
    IN DWORD    dwCmpFlags
)
{
  UINT  nLen1 = (lpString1 ? lstrlen(lpString1) : 0);
  UINT  nLen2 = (lpString2 ? lstrlen(lpString2) : 0);
  int   nRet = CompareString(
                LOCALE_USER_DEFAULT,
                dwCmpFlags,
                lpString1,
                min(cchCount, nLen1),
                lpString2,
                min(cchCount, nLen2)
              );

  return (nRet - CSTR_EQUAL);
}

int mylstrncmpi(
    IN LPCTSTR lpString1,
    IN LPCTSTR lpString2,
    IN UINT    cchCount
)
{
  return MyCompareStringN(lpString1, lpString2, cchCount, NORM_IGNORECASE);
}

HRESULT GetArgV(
    IN  LPCTSTR i_pszParameters,
    OUT UINT    *o_pargc,
    OUT void    ***o_pargv
    )
{
    if (!o_pargc || !o_pargv)
        return E_INVALIDARG;

    *o_pargc = 0;
    *o_pargv = NULL;
    
    TCHAR *p = (TCHAR *)i_pszParameters;
    while (*p && _istspace(*p))  // skip leading spaces
        p++;
    if (!*p)
        return S_FALSE; // i_pszParameters contains no parameters

    UINT nChars = lstrlen(p) + 1;
    BYTE *pbData = (BYTE *)calloc((nChars / 2) * sizeof(PTSTR *) + nChars * sizeof(TCHAR), sizeof(BYTE));
    if (!pbData)
        return E_OUTOFMEMORY;

    PTSTR *pargv = (PTSTR *)pbData;
    PTSTR t = (PTSTR)(pbData + (nChars / 2) * sizeof(PTSTR *));
    _tcscpy(t, p);

    UINT argc = 0;
    do {
        *pargv++ = t;
        argc++;

        while (*t && !_istspace(*t))    // move to the end of the token
            t++;
        if (!*t)
            break;

        *t++ = _T('\0');                // end the token with '\0'

        while (*t && _istspace(*t))     // skip leading spaces of the next token
            t++;

    } while (*t);

    *o_pargv = (void **)pbData;
    *o_pargc = argc;

    return S_OK;
}

#define TIMEWARP_CMD_APPNAME        _T("vssadmin")
#define TIMEWARP_CMD_APPEXENAME     _T("vssadmin.exe")
#define TIMEWARP_TASK_ACTION_MAJOR  _T("Create")
#define TIMEWARP_TASK_ACTION_MINOR  _T("Shadow")
#define TIMEWARP_TASK_VOLUME        _T("/For=")
#define TIMEWARP_TASK_PARAMETERS    _T("Create Shadow /AutoRetry=5 /For=")

BOOL IsTimewarpTask(
    IN LPCTSTR i_pszAppName,
    IN LPCTSTR i_pszParameters,
    IN LPCTSTR i_pszVolume
    )
{
    if (!i_pszAppName || !*i_pszAppName ||
        !i_pszParameters || !*i_pszParameters ||
        !i_pszVolume || !*i_pszVolume)
        return FALSE;

    //
    // check the application name
    //
    TCHAR *p = (PTSTR)(i_pszAppName + lstrlen(i_pszAppName) - 1);
    while (p > i_pszAppName && *p != _T('\\'))
        p--;

    if (*p == _T('\\'))
        p++;

    if (CSTR_EQUAL != CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, p, -1, TIMEWARP_CMD_APPEXENAME, -1) &&
        CSTR_EQUAL != CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, p, -1, TIMEWARP_CMD_APPNAME, -1))
        return FALSE; // application name doesn't match

    //
    // check the parameters
    //
    BOOL bVolume = FALSE;

    UINT argc = 0;
    void **argv = NULL;
    if (SUCCEEDED(GetArgV(i_pszParameters, &argc, &argv)))
    {
        if (argc >= 4 &&
            CSTR_EQUAL == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, (PTSTR)(argv[0]), -1, TIMEWARP_TASK_ACTION_MAJOR, -1) &&
            CSTR_EQUAL == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, (PTSTR)(argv[1]), -1, TIMEWARP_TASK_ACTION_MINOR, -1))
        {
            UINT nVolume = lstrlen(TIMEWARP_TASK_VOLUME);
            for (UINT i = 2; i < argc; i++)
            {
                if (!bVolume &&
                    !mylstrncmpi((PTSTR)(argv[i]), TIMEWARP_TASK_VOLUME, nVolume) &&
                    !lstrcmpi((PTSTR)(argv[i]) + nVolume, i_pszVolume))
                {
                    bVolume = TRUE;
                    break;
                }
            }
        }
        
        if (argv)
            free(argv);
    }
    
    return bVolume;
}

#define NUM_OF_TASKS            5

//
// Find the first enabled Timewarp task, skip all disabled tasks.
//
HRESULT FindScheduledTimewarpTask(
    IN  ITaskScheduler* i_piTS,
    IN  LPCTSTR         i_pszVolumeName,
    OUT ITask**         o_ppiTask,
    OUT PTSTR*          o_ppszTaskName /* = NULL */
    ) 
{
    if (!i_piTS ||
        !i_pszVolumeName || !*i_pszVolumeName ||
        !o_ppiTask)
        return E_INVALIDARG;

    *o_ppiTask = NULL;
    if (o_ppszTaskName)
        *o_ppszTaskName = NULL;

    /////////////////////////////////////////////////////////////////
    // Call ITaskScheduler::Enum to get an enumeration object.
    /////////////////////////////////////////////////////////////////
    CComPtr<IEnumWorkItems> spiEnum;
    HRESULT hr = i_piTS->Enum(&spiEnum);
    if (FAILED(hr))
        return hr;  
  
    /////////////////////////////////////////////////////////////////
    // Call IEnumWorkItems::Next to retrieve tasks. Note that 
    // this example tries to retrieve five tasks for each call.
    /////////////////////////////////////////////////////////////////
    BOOL    bTimewarpTask = FALSE;
    BOOL    bEnabled = FALSE;
    SYSTEMTIME stNextRun = {0};
    LPTSTR *ppszNames = NULL;
    DWORD   dwFetchedTasks = 0;
    while (!bTimewarpTask && SUCCEEDED(spiEnum->Next(NUM_OF_TASKS, &ppszNames, &dwFetchedTasks)) && (dwFetchedTasks != 0))
    {
        ///////////////////////////////////////////////////////////////
        // Process each task.
        //////////////////////////////////////////////////////////////
        while (!bTimewarpTask && dwFetchedTasks)
        {
            LPTSTR pszTaskName = ppszNames[--dwFetchedTasks];

            ///////////////////////////////////////////////////////////////////
            // Call ITaskScheduler::Activate to get the Task object.
            ///////////////////////////////////////////////////////////////////
            CComPtr<ITask> spiTask;
            hr = i_piTS->Activate(pszTaskName,
                                IID_ITask,
                                (IUnknown**) &spiTask);
            if (SUCCEEDED(hr))
            {
                LPTSTR pszApplicationName = NULL;
                hr = spiTask->GetApplicationName(&pszApplicationName);
                if (SUCCEEDED(hr))
                {
                    LPTSTR pszParameters = NULL;
                    hr = spiTask->GetParameters(&pszParameters);
                    if (SUCCEEDED(hr))
                    {
                        if (IsTimewarpTask(pszApplicationName, pszParameters, i_pszVolumeName))
                        {
                            bEnabled = FALSE;
                            GetScheduledTimewarpTaskStatus(spiTask, &bEnabled, &stNextRun);

                            if (bEnabled)
                                bTimewarpTask = TRUE;
                        }
                        CoTaskMemFree(pszParameters);
                    }

                    CoTaskMemFree(pszApplicationName);
                }

                if (bTimewarpTask)
                {
                    if (o_ppszTaskName)
                    {
                        // omit the ending .job
                        int nLen = lstrlen(pszTaskName);
                        BOOL bEndingFound = (nLen > 4 && CSTR_EQUAL == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, pszTaskName + nLen - 4, -1, _T(".job"), -1));
                        if (bEndingFound)
                            *(pszTaskName + nLen - 4) = _T('\0');

                        *o_ppszTaskName = _tcsdup(pszTaskName);
                        if (bEndingFound)
                            *(pszTaskName + nLen - 4) = _T('.');

                        if (!*o_ppszTaskName)
                            hr = E_OUTOFMEMORY;
                    }

                    if (SUCCEEDED(hr))
                    {
                        *o_ppiTask = (ITask *)spiTask;
                        spiTask.Detach();
                    }
                }
            }

            CoTaskMemFree(ppszNames[dwFetchedTasks]);
        }
        CoTaskMemFree(ppszNames);
    }
  
    if (FAILED(hr))
        return hr;

    return (bTimewarpTask ? S_OK : S_FALSE);
}

HRESULT GetScheduledTimewarpTaskStatus(
    IN  ITask*          i_piTask,
    OUT BOOL*           o_pbEnabled,
    OUT SYSTEMTIME*     o_pstNextRunTime
    ) 
{
    if (!i_piTask ||
        !o_pbEnabled || !o_pstNextRunTime)
        return E_INVALIDARG;

    *o_pbEnabled = FALSE;
    ZeroMemory(o_pstNextRunTime, sizeof(SYSTEMTIME));

    HRESULT hrStatus = S_OK;
    HRESULT hr = i_piTask->GetStatus(&hrStatus);
    if (SUCCEEDED(hr))
    {
        switch (hrStatus)
        {
        case SCHED_S_TASK_HAS_NOT_RUN:
        case SCHED_S_TASK_READY:
        case SCHED_S_TASK_RUNNING:
            {
                hr = i_piTask->GetNextRunTime(o_pstNextRunTime);
                if (S_OK == hr)
                    *o_pbEnabled = TRUE;
            }
            break;
        default:
            break;
        }
    }
  
    return hr;
}

HRESULT CreateDefaultEnableSchedule(
    IN  ITaskScheduler* i_piTS,
    IN  LPCTSTR         i_pszComputer,
    IN  LPCTSTR         i_pszVolumeDisplayName,
    IN  LPCTSTR         i_pszVolumeName,
    OUT ITask**         o_ppiTask,      
    OUT PTSTR*          o_ppszTaskName /* = NULL */
    )
{
    if (!i_piTS ||
        !i_pszVolumeDisplayName || !*i_pszVolumeDisplayName ||
        !i_pszVolumeName || !*i_pszVolumeName ||
        !o_ppiTask)
        return E_INVALIDARG;

    *o_ppiTask = NULL;
    if (o_ppszTaskName)
        *o_ppszTaskName = NULL;

    HRESULT hr = S_OK;
    do
    {
        //
        // i_pszVolumeName is in the form of \\?\Volume{xxx.....xxx}\
        // The task name will be ShadowCopy concatenating with Volume{xxx.....xxx}
        //
        TCHAR szTaskName[MAX_PATH] = _T("ShadowCopy");
        _tcscat(szTaskName, i_pszVolumeName + 4); // skip the beginning "\\?\"
        TCHAR *p = szTaskName + lstrlen(szTaskName) - 1;
        if (*p == _T('\\'))
            *p = _T('\0'); // remove the ending whack

        if (o_ppszTaskName)
        {
            *o_ppszTaskName = _tcsdup(szTaskName);
            if (!*o_ppszTaskName)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }

        //
        // delete any task that has the same name
        //
        (void)i_piTS->Delete(szTaskName);

        TCHAR szSystem32Directory[MAX_PATH];
        DWORD dwSize = sizeof(szSystem32Directory) / sizeof(TCHAR);
        hr = GetSystem32Directory(i_pszComputer, szSystem32Directory, &dwSize);
        if (FAILED(hr))
            break;

        TCHAR szApplicationName[MAX_PATH * 2];
        lstrcpyn(szApplicationName, szSystem32Directory, MAX_PATH);
        _tcscat(szApplicationName, _T("\\vssadmin.exe"));

        TCHAR szParameters[MAX_PATH] = TIMEWARP_TASK_PARAMETERS;
        _tcscat(szParameters, i_pszVolumeName);

        SYSTEMTIME st = {0};
        GetSystemTime(&st);

        WORD wStartHours[] = {7, 12};
        TASK_TRIGGER Triggers[2];
        for (DWORD i = 0; i < sizeof(wStartHours)/sizeof(wStartHours[0]); i++)
        {
            //////////////////////////////////////////////////////
            // Define TASK_TRIGGER structure. Note that wBeginDay,
            // wBeginMonth, and wBeginYear must be set to a valid 
            // day, month, and year respectively.
            //////////////////////////////////////////////////////
            ZeroMemory(Triggers + i, sizeof(TASK_TRIGGER));
            Triggers[i].wBeginDay =st.wDay;
            Triggers[i].wBeginMonth =st.wMonth;
            Triggers[i].wBeginYear =st.wYear;
            Triggers[i].cbTriggerSize = sizeof(TASK_TRIGGER); 
            Triggers[i].wStartHour = wStartHours[i];
            Triggers[i].TriggerType = TASK_TIME_TRIGGER_WEEKLY;
            Triggers[i].Type.Weekly.WeeksInterval = 1;
            Triggers[i].Type.Weekly.rgfDaysOfTheWeek = TASK_MONDAY | TASK_TUESDAY | TASK_WEDNESDAY | TASK_THURSDAY | TASK_FRIDAY;
        }

        try
        {
            CVssClusterAPI cluster;

            bool bRet = cluster.Initialize(i_pszComputer);
            if (!bRet || !cluster.IsVolumeBelongingToPhysicalDiskResource(i_pszVolumeName))
            {
                CComPtr<ITask> spiTask;
                hr = i_piTS->NewWorkItem(szTaskName,      // Name of task
                                 CLSID_CTask,            // Class identifier 
                                 IID_ITask,              // Interface identifier
                                 (IUnknown**)&spiTask);  // Address of task interface
                if (FAILED(hr))
                    break;

                hr = spiTask->SetWorkingDirectory(szSystem32Directory);
                if (FAILED(hr))
                    break;

                hr = spiTask->SetApplicationName(szApplicationName);
                if (FAILED(hr))
                    break;

                hr = spiTask->SetParameters(szParameters);
                if (FAILED(hr))
                    break;

                // run as local system account
                hr = spiTask->SetAccountInformation(_T(""), NULL);
                if (FAILED(hr))
                    break;

                for (i = 0; i < sizeof(wStartHours)/sizeof(wStartHours[0]); i++)
                {
                    ///////////////////////////////////////////////////////////////////
                    // Call ITask::CreateTrigger to create new trigger.
                    ///////////////////////////////////////////////////////////////////
                    CComPtr<ITaskTrigger> spiTaskTrigger;
                    WORD piNewTrigger;
                    hr = spiTask->CreateTrigger(&piNewTrigger, &spiTaskTrigger);
                    if (FAILED(hr))
                        break;

                    ///////////////////////////////////////////////////////////////////
                    // Call ITaskTrigger::SetTrigger to set trigger criteria.
                    ///////////////////////////////////////////////////////////////////
                    hr = spiTaskTrigger->SetTrigger(Triggers + i);
                    if (FAILED(hr))
                        break;
                }
                if (FAILED(hr))
                    break;

                ///////////////////////////////////////////////////////////////////
                // Call IPersistFile::Save to save trigger to disk.
                ///////////////////////////////////////////////////////////////////
                CComPtr<IPersistFile> spiPersistFile;
                hr = spiTask->QueryInterface(IID_IPersistFile, (void **)&spiPersistFile);
                if (FAILED(hr))
                    break;

                hr = spiPersistFile->Save(NULL, TRUE);

                if (SUCCEEDED(hr))
                {
                    *o_ppiTask = (ITask *)spiTask;
                    spiTask.Detach();
                }
            } else // cluster
            {
                bRet = cluster.CreateTaskSchedulerResource(
                                                szTaskName,
                                                szApplicationName,
                                                szParameters,
                                                2,
                                                Triggers,
                                                i_pszVolumeName
                                                );
                if (bRet)
                {
                    hr = FindScheduledTimewarpTask(i_piTS, i_pszVolumeName, o_ppiTask);
                    if (S_FALSE == hr)
                        hr = E_FAIL;  // we failed to find a valid enabled task, something is wrong
                } else
                {
                    hr = E_FAIL;
                }
            }
        } catch (HRESULT hrClus)
        {
            hr = hrClus;
        }
    } while(0);


    if (FAILED(hr))
    {
        if (o_ppszTaskName && *o_ppszTaskName)
        {
            free(*o_ppszTaskName);
            *o_ppszTaskName = NULL;
        }
    }

    return hr;
}

HRESULT DeleteOneScheduledTimewarpTasks(
    IN ITaskScheduler* i_piTS,
    IN LPCTSTR         i_pszComputer,
    IN LPCTSTR         i_pszTaskName
    )
{
    if (!i_piTS || !i_pszTaskName || !*i_pszTaskName)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    try
    {
        CVssClusterAPI cluster;
        bool bRet = cluster.Initialize(i_pszComputer);
        if (bRet)
        {
            // omit the ending .job
            PTSTR pszTaskName = (PTSTR)i_pszTaskName;
            int nLen = lstrlen(pszTaskName);
            BOOL bEndingFound = (nLen > 4 && CSTR_EQUAL == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, pszTaskName + nLen - 4, -1, _T(".job"), -1));
            if (bEndingFound)
                *(pszTaskName + nLen - 4) = _T('\0');

            bRet = cluster.DeleteTaskSchedulerResource(pszTaskName);

            if (bEndingFound)
                *(pszTaskName + nLen - 4) = _T('.');

            if (!bRet)
            {
                hr = i_piTS->Delete(i_pszTaskName);
            }
        } else
        {
            hr = i_piTS->Delete(i_pszTaskName);
        }
    } catch (HRESULT hrIgnore)
    {
        hr = i_piTS->Delete(i_pszTaskName);;
    }

    return hr;
}

HRESULT DeleteAllScheduledTimewarpTasks(
    IN ITaskScheduler* i_piTS,
    IN LPCTSTR         i_pszComputer,
    IN LPCTSTR         i_pszVolumeName,
    IN BOOL            i_bDeleteDisabledOnesOnly
    ) 
{
    if (!i_piTS ||
        !i_pszVolumeName || !*i_pszVolumeName)
        return E_INVALIDARG;

    /////////////////////////////////////////////////////////////////
    // Call ITaskScheduler::Enum to get an enumeration object.
    /////////////////////////////////////////////////////////////////
    CComPtr<IEnumWorkItems> spiEnum;
    HRESULT hr = i_piTS->Enum(&spiEnum);
  
    /////////////////////////////////////////////////////////////////
    // Call IEnumWorkItems::Next to retrieve tasks. Note that 
    // this example tries to retrieve five tasks for each call.
    /////////////////////////////////////////////////////////////////
    BOOL        bEnabled = FALSE;
    SYSTEMTIME  stNextRun = {0};
    LPTSTR *ppszNames = NULL;
    DWORD   dwFetchedTasks = 0;
    while (SUCCEEDED(hr) && SUCCEEDED(spiEnum->Next(NUM_OF_TASKS, &ppszNames, &dwFetchedTasks)) && (dwFetchedTasks != 0))
    {
        ///////////////////////////////////////////////////////////////
        // Process each task.
        //////////////////////////////////////////////////////////////
        while (SUCCEEDED(hr) && dwFetchedTasks)
        {
            LPTSTR pszTaskName = ppszNames[--dwFetchedTasks];

            ///////////////////////////////////////////////////////////////////
            // Call ITaskScheduler::Activate to get the Task object.
            ///////////////////////////////////////////////////////////////////
            CComPtr<ITask> spiTask;
            hr = i_piTS->Activate(pszTaskName,
                                IID_ITask,
                                (IUnknown**) &spiTask);
            if (SUCCEEDED(hr))
            {
                LPTSTR pszApplicationName = NULL;
                hr = spiTask->GetApplicationName(&pszApplicationName);
                if (SUCCEEDED(hr))
                {
                    LPTSTR pszParameters = NULL;
                    hr = spiTask->GetParameters(&pszParameters);
                    if (SUCCEEDED(hr))
                    {
                        if (IsTimewarpTask(pszApplicationName, pszParameters, i_pszVolumeName))
                        {
                            if (i_bDeleteDisabledOnesOnly)
                            {
                                bEnabled = FALSE;
                                GetScheduledTimewarpTaskStatus(spiTask, &bEnabled, &stNextRun);
                                if (!bEnabled)
                                    hr = DeleteOneScheduledTimewarpTasks(i_piTS, i_pszComputer, pszTaskName);
                                    //hr = i_piTS->Delete(pszTaskName);
                            } else
                            {
                                hr = DeleteOneScheduledTimewarpTasks(i_piTS, i_pszComputer, pszTaskName);
                                //hr = i_piTS->Delete(pszTaskName);
                            }
                        }

                        CoTaskMemFree(pszParameters);
                    }

                    CoTaskMemFree(pszApplicationName);
                }
            }

            CoTaskMemFree(ppszNames[dwFetchedTasks]);
        }
        CoTaskMemFree(ppszNames);
    }
  
    return hr;
}

HRESULT VssTimeToSystemTime(
    IN  VSS_TIMESTAMP*  i_pVssTime,
    OUT SYSTEMTIME*     o_pSystemTime
    )
{
    if (!o_pSystemTime)
        return E_INVALIDARG;

    SYSTEMTIME stLocal = {0};
    FILETIME ftLocal = {0};

    if (!i_pVssTime)
    {
        SYSTEMTIME sysTime = {0};
        FILETIME fileTime = {0};
        
        //  Get current time
        ::GetSystemTime(&sysTime);

        //  Convert system time to file time
        ::SystemTimeToFileTime(&sysTime, &fileTime);
        
        //  Compensate for local TZ
        ::FileTimeToLocalFileTime(&fileTime, &ftLocal);
    } else
    {        
        //  Compensate for local TZ
        ::FileTimeToLocalFileTime((FILETIME *)i_pVssTime, &ftLocal);
    }

    //  Finally convert it to system time
    ::FileTimeToSystemTime(&ftLocal, o_pSystemTime);

    return S_OK;
}

HRESULT SystemTimeToString(
    IN      SYSTEMTIME* i_pSystemTime,
    OUT     PTSTR       o_pszText,
    IN OUT  DWORD*      io_pdwSize   
    )
{
    if (!i_pSystemTime || !o_pszText || !io_pdwSize)
        return E_INVALIDARG;

    //  Convert to a date string
    TCHAR pszDate[64];
    ::GetDateFormat(GetThreadLocale( ),
                    DATE_SHORTDATE,
                    i_pSystemTime,
                    NULL,
                    pszDate,
                    sizeof(pszDate) / sizeof(TCHAR));

    //  Convert to a time string
    TCHAR pszTime[64];
    ::GetTimeFormat(GetThreadLocale( ),
                    TIME_NOSECONDS,
                    i_pSystemTime,
                    NULL,
                    pszTime,
                    sizeof( pszTime ) / sizeof(TCHAR));

    CString strMsg;
    strMsg.Format(IDS_DATE_TIME, pszDate, pszTime);
    DWORD dwRequiredSize = strMsg.GetLength() + 1;
    if (*io_pdwSize < dwRequiredSize)
    {
        *io_pdwSize = dwRequiredSize;
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    *io_pdwSize = dwRequiredSize;
    _tcscpy(o_pszText, strMsg);

    return S_OK;    
}

HRESULT DiskSpaceToString(
    IN      ULONGLONG    i_llDiskSpace,
    OUT     PTSTR       o_pszText,
    IN OUT  DWORD*      io_pdwSize   
    )
{
    if (!o_pszText || !io_pdwSize)
        return E_INVALIDARG;

    CString strMsg;
    if (i_llDiskSpace < g_llKB)
        strMsg.Format(IDS_SPACE_LABEL_B, i_llDiskSpace);
    else if (i_llDiskSpace < g_llMB)
        strMsg.Format(IDS_SPACE_LABEL_KB, i_llDiskSpace / g_llKB);
    else
        strMsg.Format(IDS_SPACE_LABEL_MB, i_llDiskSpace / g_llMB);

    DWORD dwRequiredSize = strMsg.GetLength() + 1;
    if (*io_pdwSize < dwRequiredSize)
    {
        *io_pdwSize = dwRequiredSize;
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    *io_pdwSize = dwRequiredSize;
    _tcscpy(o_pszText, strMsg);

    return S_OK;
}

HRESULT GetVolumeSpace(
    IN  IVssDifferentialSoftwareSnapshotMgmt* piDiffSnapMgmt,
    IN  LPCTSTR     i_pszVolumeDisplayName,
    OUT ULONGLONG*  o_pllVolumeTotalSpace,  // = NULL
    OUT ULONGLONG*  o_pllVolumeFreeSpace    // = NULL
    )
{
    if (!piDiffSnapMgmt ||
        !i_pszVolumeDisplayName || !*i_pszVolumeDisplayName ||
        !o_pllVolumeTotalSpace && !o_pllVolumeFreeSpace)
        return E_INVALIDARG;

    CComPtr<IVssEnumMgmtObject> spiEnum;
    HRESULT hr = piDiffSnapMgmt->QueryVolumesSupportedForDiffAreas((PTSTR)i_pszVolumeDisplayName, &spiEnum);
    if (FAILED(hr))
        return hr;

    BOOL bFound = FALSE;
    VSS_MGMT_OBJECT_PROP Prop;
    VSS_DIFF_VOLUME_PROP *pDiffVolProp = &(Prop.Obj.DiffVol);
    ULONG ulFetched = 0;
    while (!bFound && SUCCEEDED(spiEnum->Next(1, &Prop, &ulFetched)) && ulFetched > 0)
    {
        if (VSS_MGMT_OBJECT_DIFF_VOLUME != Prop.Type)
            return E_FAIL;

        if (!lstrcmpi(i_pszVolumeDisplayName, pDiffVolProp->m_pwszVolumeDisplayName))
        {
            bFound = TRUE;
            if (o_pllVolumeTotalSpace)
                *o_pllVolumeTotalSpace = pDiffVolProp->m_llVolumeTotalSpace;

            if (o_pllVolumeFreeSpace)
                *o_pllVolumeFreeSpace = pDiffVolProp->m_llVolumeFreeSpace;
        }

        CoTaskMemFree(pDiffVolProp->m_pwszVolumeName);
        CoTaskMemFree(pDiffVolProp->m_pwszVolumeDisplayName);
    }

    return (bFound ? S_OK : S_FALSE);
}

HRESULT GetDiffAreaInfo(
    IN  IVssDifferentialSoftwareSnapshotMgmt* piDiffSnapMgmt,
    IN  VSSUI_VOLUME_LIST*  pVolumeList,
    IN  LPCTSTR             pszVolumeName,
    OUT VSSUI_DIFFAREA*     pDiffArea
    )
{
    if (!piDiffSnapMgmt ||
        !pVolumeList ||
        !pszVolumeName || !*pszVolumeName ||
        !pDiffArea)
        return E_INVALIDARG;

    ZeroMemory(pDiffArea, sizeof(VSSUI_DIFFAREA));

    CComPtr<IVssEnumMgmtObject> spiEnumMgmtDiffArea;
    HRESULT hr = piDiffSnapMgmt->QueryDiffAreasForVolume(
                            (PTSTR)pszVolumeName,
                            &spiEnumMgmtDiffArea);
    if (S_OK == hr)
    {
        VSS_MGMT_OBJECT_PROP Prop;
        VSS_DIFF_AREA_PROP *pDiffAreaProp = &(Prop.Obj.DiffArea);
        ULONG ulDiffFetched = 0;
        hr = spiEnumMgmtDiffArea->Next(1, &Prop, &ulDiffFetched);
        if (SUCCEEDED(hr) && ulDiffFetched > 0)
        {
            if (VSS_MGMT_OBJECT_DIFF_AREA != Prop.Type || 1 != ulDiffFetched)
                return E_FAIL;

            PTSTR pszVolumeDisplayName = GetDisplayName(pVolumeList, pDiffAreaProp->m_pwszVolumeName);
            PTSTR pszDiffVolumeDisplayName = GetDisplayName(pVolumeList, pDiffAreaProp->m_pwszDiffAreaVolumeName);
            if (pszVolumeDisplayName && pszDiffVolumeDisplayName)
            {
                lstrcpyn(pDiffArea->pszVolumeDisplayName, pszVolumeDisplayName, MAX_PATH);
                lstrcpyn(pDiffArea->pszDiffVolumeDisplayName, pszDiffVolumeDisplayName, MAX_PATH);
                pDiffArea->llMaximumDiffSpace = pDiffAreaProp->m_llMaximumDiffSpace;
                pDiffArea->llUsedDiffSpace = pDiffAreaProp->m_llAllocatedDiffSpace;
            } else
            {
                hr = S_FALSE; // indicate something inconsistent happened (e.g., DiffVol formated to be FAT), we disgard the result
            }

            CoTaskMemFree(pDiffAreaProp->m_pwszVolumeName);
            CoTaskMemFree(pDiffAreaProp->m_pwszDiffAreaVolumeName);
        }
    }

    return hr;
}

PTSTR GetDisplayName(VSSUI_VOLUME_LIST *pVolumeList, LPCTSTR pszVolumeName)
{
    if (!pVolumeList || !pszVolumeName || !*pszVolumeName)
        return NULL;

    for (VSSUI_VOLUME_LIST::iterator i = pVolumeList->begin(); i != pVolumeList->end(); i++)
    {
        if (!lstrcmpi(pszVolumeName, (*i)->pszVolumeName))
            return (*i)->pszDisplayName;
    }

    return NULL;
}

PTSTR GetVolumeName(VSSUI_VOLUME_LIST *pVolumeList, LPCTSTR pszDisplayName)
{
    if (!pVolumeList || !pszDisplayName || !*pszDisplayName)
        return NULL;

    for (VSSUI_VOLUME_LIST::iterator i = pVolumeList->begin(); i != pVolumeList->end(); i++)
    {
        if (!lstrcmpi(pszDisplayName, (*i)->pszDisplayName))
            return (*i)->pszVolumeName;
    }

    return NULL;
}

void FreeVolumeList(VSSUI_VOLUME_LIST *pList)
{
    if (!pList || pList->empty())
        return;

    for (VSSUI_VOLUME_LIST::iterator i = pList->begin(); i != pList->end(); i++)
        free(*i);

    pList->clear();
}

void FreeSnapshotList(VSSUI_SNAPSHOT_LIST *pList)
{
    if (!pList || pList->empty())
        return;

    for (VSSUI_SNAPSHOT_LIST::iterator i = pList->begin(); i != pList->end(); i++)
        free(*i);

    pList->clear();
}

void FreeDiffAreaList(VSSUI_DIFFAREA_LIST *pList)
{
    if (!pList || pList->empty())
        return;

    for (VSSUI_DIFFAREA_LIST::iterator i = pList->begin(); i != pList->end(); i++)
        free(*i);

    pList->clear();
}

HRESULT GetSystem32Directory(
    IN     LPCTSTR  i_pszComputer,
    OUT    PTSTR    o_pszSystem32Directory,
    IN OUT DWORD*   o_pdwSize
    )
{
    if (!o_pszSystem32Directory)
        return E_INVALIDARG;

    SHARE_INFO_2 *pInfo = NULL;
    DWORD dwRet = NetShareGetInfo((PTSTR)i_pszComputer, _T("ADMIN$"), 2, (LPBYTE *)&pInfo);
    if (NERR_Success == dwRet)
    {
        DWORD dwRequiredLength = lstrlen(pInfo->shi2_path) + lstrlen(_T("\\system32")) + 1;
        if (*o_pdwSize < dwRequiredLength)
            dwRet = ERROR_INSUFFICIENT_BUFFER;
        else
        {
            _tcscpy(o_pszSystem32Directory, pInfo->shi2_path);

            TCHAR *p = o_pszSystem32Directory + lstrlen(pInfo->shi2_path) - 1;
            if (_T('\\') != *p)
                p++;
            _tcscpy(p, _T("\\system32"));
        }

        *o_pdwSize = dwRequiredLength;
    }

    if (pInfo)
        NetApiBufferFree(pInfo);

    return HRESULT_FROM_WIN32(dwRet);
}

HRESULT GetErrorMessageFromModule(
    IN  DWORD       dwError,
    IN  LPCTSTR     lpszDll,
    OUT LPTSTR      *ppBuffer
)
{
    if (0 == dwError || !lpszDll || !*lpszDll || !ppBuffer)
        return E_INVALIDARG;

    HRESULT      hr = S_OK;

    HINSTANCE  hMsgLib = LoadLibrary(lpszDll);
    if (!hMsgLib)
        hr = HRESULT_FROM_WIN32(GetLastError());
    else
    {
        DWORD dwRet = ::FormatMessage(
                            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                            hMsgLib, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (LPTSTR)ppBuffer, 0, NULL);

        if (0 == dwRet)
            hr = HRESULT_FROM_WIN32(GetLastError());

        FreeLibrary(hMsgLib);
    }

    return hr;
}

HRESULT GetErrorMessage(
    IN  DWORD        i_dwError,
    OUT CString&     cstrErrorMsg
)
{
    if (0 == i_dwError)
        return E_INVALIDARG;

    HRESULT      hr = S_OK;
    LPTSTR       lpBuffer = NULL;

    DWORD dwRet = ::FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL, i_dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                        (LPTSTR)&lpBuffer, 0, NULL);
    if (0 == dwRet)
    {
        // if no message is found, GetLastError will return ERROR_MR_MID_NOT_FOUND
        hr = HRESULT_FROM_WIN32(GetLastError());

        if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hr ||
            0x80070000 == (i_dwError & 0xffff0000) ||
            0 == (i_dwError & 0xffff0000) )
        {
            hr = GetErrorMessageFromModule((i_dwError & 0x0000ffff), _T("netmsg.dll"), &lpBuffer);
        }

        // could be a VSS error, try myself - vssui.dll
        if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hr)
        {
            hr = GetErrorMessageFromModule(i_dwError, _T("vssui.dll"), &lpBuffer);
        }
    }

    if (SUCCEEDED(hr))
    {
        cstrErrorMsg = lpBuffer;
        LocalFree(lpBuffer);
    }
    else
    {
        // we failed to retrieve the error message from system/netmsg.dll/sfmmsg.dll,
        // report the error code directly to user
        hr = S_OK;
        cstrErrorMsg.Format(_T("0x%x"), i_dwError);
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////
//    GetMsgHelper()
//
//    This function will retrieve the error msg if dwErr is specified,
//    load resource string if specified, and format the string with
//    the error msg and other optional arguments.
//
//
HRESULT GetMsgHelper(
    OUT CString& strMsg,// OUT: the message
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String ID
    va_list* parglist   // IN: OPTIONAL arguments
    )
{
    if (!dwErr && !wIdString) 
        return E_INVALIDARG;

    //
    // retrieve error msg
    //
    CString strErrorMessage;
    if (dwErr != 0)
        GetErrorMessage(dwErr, strErrorMessage);

    //
    // load string resource, and format it with the error msg and 
    // other optional arguments
    //
    if (wIdString == 0)
    {
        strMsg = strErrorMessage;
    } else
    {
        CString strFormat;
        strFormat.LoadString(wIdString);

	    CString strFormatedMsg;
        strFormatedMsg.FormatV(strFormat, *parglist); 

        if (dwErr == 0)
            strMsg = strFormatedMsg;
        else 
            strMsg.FormatMessage((((HRESULT)dwErr < 0) ? IDS_ERROR_HR : IDS_ERROR),
            strFormatedMsg,
            dwErr,
            strErrorMessage);
    }

    return S_OK;
} // GetMsgHelper()

/////////////////////////////////////////////////////////////////////
//    GetMsg()
//
//    This function will call GetMsgHelp to retrieve the error msg
//    if dwErr is specified, load resource string if specified, and
//    format the string with the error msg and other optional arguments.
//
//
void GetMsg(
    OUT CString& strMsg,// OUT: the message
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
    ...)                // IN: Optional arguments
{
    va_list arglist;
    va_start(arglist, wIdString);

    HRESULT hr = GetMsgHelper(strMsg, dwErr, wIdString, &arglist);
    if (FAILED(hr))
        strMsg.Format(_T("0x%x"), hr);

    va_end(arglist);

} // GetMsg()

/////////////////////////////////////////////////////////////////////
//    DoErrMsgBox()
//
//    Display a message box for the error code.  This function will
//    load the error message from the system resource and append
//    the optional string (if any)
//
//    EXAMPLE
//        DoErrMsgBox(GetActiveWindow(), MB_OK, GetLastError(), IDS_s_FILE_READ_ERROR, L"foo.txt");
//
INT DoErrMsgBox(
    HWND hwndParent,    // IN: Parent of the dialog box
    UINT uType,         // IN: style of message box
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
    ...)                // IN: Optional arguments
{
    //
    // get string and the error msg
    //
    va_list arglist;
    va_start(arglist, wIdString);

    CString strMsg;
    HRESULT hr = GetMsgHelper(strMsg, dwErr, wIdString, &arglist);
    if (FAILED(hr))
        strMsg.Format(_T("0x%x"), hr);

    va_end(arglist);

    //
    // Load the caption
    //
    CString strCaption;
    strCaption.LoadString(IDS_PROJNAME);

    //
    // Display the message.
    //
    return ::MessageBox(hwndParent, strMsg, strCaption, uType);

}

BOOL IsPostW2KServer(LPCTSTR pszComputer)
{
    BOOL bPostW2KServer = FALSE;
    SERVER_INFO_102* pServerInfo = NULL;
    DWORD dwRet = NetServerGetInfo((LPTSTR)pszComputer, 102, (LPBYTE*)&pServerInfo);
    if (NERR_Success == dwRet)
    {
        bPostW2KServer = (pServerInfo->sv102_type & SV_TYPE_NT) &&          // NT/W2K/XP or after
            (pServerInfo->sv102_version_major & MAJOR_VERSION_MASK) >= 5 &&
            pServerInfo->sv102_version_minor > 0 &&                         // XP or after
            ((pServerInfo->sv102_type & SV_TYPE_DOMAIN_CTRL) ||
             (pServerInfo->sv102_type & SV_TYPE_DOMAIN_BAKCTRL) ||
             (pServerInfo->sv102_type & SV_TYPE_SERVER_NT));                // server

        NetApiBufferFree(pServerInfo);
    }

    return bPostW2KServer;
}

HRESULT GetVolumesSupportedForDiffArea(
    IN  IVssDifferentialSoftwareSnapshotMgmt* piDiffSnapMgmt,
    IN  LPCTSTR                 pszVolumeDisplayName,
    IN OUT VSSUI_VOLUME_LIST*   pVolumeList
    )
{
    if (!piDiffSnapMgmt || !pszVolumeDisplayName || !*pszVolumeDisplayName)
        return E_INVALIDARG;

    if (!pVolumeList || (!pVolumeList->empty()))
        // Expect an empty list...
        return E_INVALIDARG;

    CComPtr<IVssEnumMgmtObject> spiEnumMgmt;
    HRESULT hr = piDiffSnapMgmt->QueryVolumesSupportedForDiffAreas((PTSTR)pszVolumeDisplayName, &spiEnumMgmt);
    if (FAILED(hr))
        return hr;

    VSS_MGMT_OBJECT_PROP Prop;
    VSS_DIFF_VOLUME_PROP *pDiffVolProp = &(Prop.Obj.DiffVol);
    ULONG ulFetched = 0;
    while (SUCCEEDED(hr = spiEnumMgmt->Next(1, &Prop, &ulFetched)) && ulFetched > 0)
    {
        if (VSS_MGMT_OBJECT_DIFF_VOLUME != Prop.Type)
            return E_FAIL;

        VSSUI_VOLUME *pVolInfo = (VSSUI_VOLUME *)calloc(1, sizeof(VSSUI_VOLUME));
        if (pVolInfo)
        {
            lstrcpyn(pVolInfo->pszVolumeName, pDiffVolProp->m_pwszVolumeName, MAX_PATH);
            lstrcpyn(pVolInfo->pszDisplayName, pDiffVolProp->m_pwszVolumeDisplayName, MAX_PATH);
            pVolumeList->push_back(pVolInfo);
        } else
        {
            FreeVolumeList(pVolumeList);
            hr = E_OUTOFMEMORY;
        }
        CoTaskMemFree(pDiffVolProp->m_pwszVolumeName);
        CoTaskMemFree(pDiffVolProp->m_pwszVolumeDisplayName);

        if (FAILED(hr))
            break;
    }
    if (hr == S_FALSE)
        // End of loop detected
        hr = S_OK;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\vsspage.h ===
// vsspage.h : main header file for the VSSUI DLL
//

#ifndef __VSSPAGE_H_
#define __VSSPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// CVssPageApp
// See vssui.cpp for the implementation of this class
//

class CVssPageApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
protected:
    BOOL m_bRun;
};

#endif // _VSSPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\utils.h ===
#ifndef _UTILS_H_
#define _UTILS_H_

#include <vss.h>    // VSS_TIMESTAMP
#include <vsmgmt.h>
#include <mstask.h>

#include <list>
using namespace std;

typedef struct _VSSUI_VOLUME
{
    TCHAR pszVolumeName[MAX_PATH];
    TCHAR pszDisplayName[MAX_PATH];
} VSSUI_VOLUME;

typedef list<VSSUI_VOLUME *> VSSUI_VOLUME_LIST;

typedef struct _VSSUI_SNAPSHOT
{
    GUID            idSnapshot;
    VSS_TIMESTAMP   vssTimeStamp;
} VSSUI_SNAPSHOT;

typedef list<VSSUI_SNAPSHOT *> VSSUI_SNAPSHOT_LIST;

typedef struct _VSSUI_DIFFAREA
{
    TCHAR       pszVolumeDisplayName[MAX_PATH];
    TCHAR       pszDiffVolumeDisplayName[MAX_PATH];
    ULONGLONG    llMaximumDiffSpace;
    ULONGLONG    llUsedDiffSpace;
} VSSUI_DIFFAREA;

typedef list<VSSUI_DIFFAREA *> VSSUI_DIFFAREA_LIST;

// MACROS
#define TWO_WHACKS(p)   ((p) && lstrlen(p) > 1 && *(p) == _T('\\') && *((p)+1) == _T('\\'))

#define MINIMUM_DIFF_LIMIT              (100 * g_llMB)
#define MINIMUM_DIFF_LIMIT_MB           100
#define MINIMUM_DIFF_LIMIT_DELTA_MB     50   

// globals
extern ULONGLONG g_llKB;
extern ULONGLONG g_llMB;
extern ULONGLONG g_llGB;

HRESULT
AddLVColumns(
	IN const HWND     hwndListBox,
	IN const INT      iStartingResourceID,
	IN const UINT     uiColumns
);

LPARAM GetListViewItemData(
    IN HWND hwndList,
    IN int  index
);

int mylstrncmpi(
    IN LPCTSTR lpString1,
    IN LPCTSTR lpString2,
    IN UINT    cchCount
);

HRESULT FindScheduledTimewarpTask(
    IN  ITaskScheduler* i_piTS,
    IN  LPCTSTR         i_pszVolumeName,
    OUT ITask**         o_ppiTask,
    OUT PTSTR*          o_ppszTaskName = NULL
    );

HRESULT GetScheduledTimewarpTaskStatus(
    IN  ITask*          i_piTask,
    OUT BOOL*           o_pbEnabled,
    OUT SYSTEMTIME*     o_pstNextRunTime
    );

HRESULT CreateDefaultEnableSchedule(
    IN  ITaskScheduler* i_piTS,
    IN  LPCTSTR         i_pszComputer,
    IN  LPCTSTR         i_pszVolumeDisplayName,
    IN  LPCTSTR         i_pszVolumeName,
    OUT ITask**         o_ppiTask,      
    OUT PTSTR*          o_pszTaskName = NULL
    );

HRESULT DeleteOneScheduledTimewarpTasks(
    IN ITaskScheduler* i_piTS,
    IN LPCTSTR         i_pszComputer,
    IN LPCTSTR         i_pszTaskName
    );

HRESULT DeleteAllScheduledTimewarpTasks(
    IN ITaskScheduler* i_piTS,
    IN LPCTSTR         i_pszComputer,
    IN LPCTSTR         i_pszVolumeName,
    IN BOOL            i_bDeleteDisabledOnesOnly
    );

HRESULT VssTimeToSystemTime(
    IN  VSS_TIMESTAMP*  i_pVssTime,
    OUT SYSTEMTIME*     o_pSystemTime
    );

HRESULT SystemTimeToString(
    IN      SYSTEMTIME* i_pSystemTime,
    OUT     PTSTR       o_pszText,
    IN OUT  DWORD*      io_pdwSize   
    );

HRESULT DiskSpaceToString(
    IN      ULONGLONG   i_llDiskSpace,
    OUT     PTSTR       o_pszText,
    IN OUT  DWORD*      io_pdwSize   
    );

HRESULT GetVolumeSpace(
    IN  IVssDifferentialSoftwareSnapshotMgmt* piDiffSnapMgmt,
    IN  LPCTSTR     i_pszVolumeDisplayName,
    OUT ULONGLONG*  o_pllVolumeTotalSpace = NULL,
    OUT ULONGLONG*  o_pllVolumeFreeSpace = NULL
    );

HRESULT GetDiffAreaInfo(
    IN  IVssDifferentialSoftwareSnapshotMgmt* piDiffSnapMgmt,
    IN  VSSUI_VOLUME_LIST*  pVolumeList,
    IN  LPCTSTR             pszVolumeName,
    OUT VSSUI_DIFFAREA*     pDiffArea
    );

HRESULT GetVolumesSupportedForDiffArea(
    IN  IVssDifferentialSoftwareSnapshotMgmt* piDiffSnapMgmt,
    IN  LPCTSTR                 pszVolumeDisplayName,
    IN OUT VSSUI_VOLUME_LIST*   pVolumeList
    );

PTSTR GetDisplayName(VSSUI_VOLUME_LIST *pVolumeList, LPCTSTR pszVolumeName);
PTSTR GetVolumeName(VSSUI_VOLUME_LIST *pVolumeList, LPCTSTR pszDisplayName);

void FreeVolumeList(VSSUI_VOLUME_LIST* pList);
void FreeSnapshotList(VSSUI_SNAPSHOT_LIST *pList);
void FreeDiffAreaList(VSSUI_DIFFAREA_LIST* pList);

HRESULT GetSystem32Directory(
    IN     LPCTSTR  i_pszComputer,
    OUT    PTSTR    o_pszSystem32Directory,
    IN OUT DWORD*   o_pdwSize
    );

void GetMsg(
    OUT CString& strMsg,// OUT: the message
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
    ...);               // IN: Optional arguments

INT DoErrMsgBox(
    HWND hwndParent,    // IN: Parent of the dialog box
    UINT uType,         // IN: style of message box
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
    ...);               // IN: Optional arguments

BOOL IsPostW2KServer(LPCTSTR pszComputer);

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\vssprop.h ===
#if !defined(AFX_VSSPROP_H__CB712178_310D_4459_9927_E0CAF69C7FA1__INCLUDED_)
#define AFX_VSSPROP_H__CB712178_310D_4459_9927_E0CAF69C7FA1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CVSSProp.h : header file
//

#include "utils.h"

#include <shlobj.h>

#include <vsmgmt.h>
#include <vscoordint.h>

#define WM_SETPAGEFOCUS WM_APP+2

/////////////////////////////////////////////////////////////////////////////
// CVSSProp dialog

class CVSSProp : public CPropertyPage
{
    DECLARE_DYNCREATE(CVSSProp)

// Construction
public:
    CVSSProp();
    CVSSProp(LPCTSTR pszComputer, LPCTSTR pszVolume);
    ~CVSSProp();

// Dialog Data
    //{{AFX_DATA(CVSSProp)
    enum { IDD = IDD_VSSPROP };
    CButton    m_ctrlSettings;
    CButton    m_ctrlDisable;
    CButton    m_ctrlEnable;
    CListCtrl    m_ctrlVolumeList;
    CListCtrl    m_ctrlSnapshotList;
    CButton    m_ctrlDelete;
    CButton    m_ctrlCreate;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CVSSProp)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
public:
    void _ResetInterfacePointers();
    HRESULT InitInterfacePointers();
    HRESULT GetVolumes();
    HRESULT StoreShellExtPointer(IShellPropSheetExt* piShellExt);
    HRESULT InsertVolumeInfo(HWND hwnd);

    HRESULT UpdateDiffArea();
    HRESULT UpdateDiffArea(int nIndex, LPCTSTR pszVolumeName);
    HRESULT InsertDiffAreaInfo(HWND hwnd);

    HRESULT InsertShareInfo(HWND hwnd);

    HRESULT UpdateSchedule();
    HRESULT UpdateSchedule(int nIndex, LPCTSTR pszVolumeName);
    void UpdateSchedule(ITask * i_piTask, int nIndex);
    HRESULT InsertScheduleInfo(HWND hwnd);

    void SelectVolume(HWND hwnd, LPCTSTR pszVolume);

    HRESULT GetSnapshots(LPCTSTR pszVolume);
    HRESULT UpdateSnapshotList();

    HRESULT TakeOneSnapshotNow(IN LPCTSTR pszVolumeName);
    HRESULT DoEnable();
    HRESULT DoDisable();
    HRESULT DeleteAllSnapshotsOnVolume(IN LPCTSTR pszVolumeName);

    void UpdateEnableDisableButtons();

protected:
    BOOL m_bHideAllControls;

    CString m_strComputer;
    BOOL    m_bCluster;
    CString m_strSelectedVolume;
    CString m_strDisabled;
    HIMAGELIST m_hImageList;

    CComPtr<IShellPropSheetExt> m_spiShellExt;

    CComPtr<IVssSnapshotMgmt>   m_spiMgmt;
    CComPtr<IVssCoordinator>    m_spiCoord;
    CComPtr<IVssDifferentialSoftwareSnapshotMgmt> m_spiDiffSnapMgmt;
    CComPtr<ITaskScheduler>     m_spiTS;

    VSSUI_VOLUME_LIST           m_VolumeList;
    VSSUI_SNAPSHOT_LIST         m_SnapshotList;

    int                         m_nScrollbarWidth;
    int                         m_nSnapshotListColumnWidth;
    int                         m_nSnapshotListCountPerPage;

    // Generated message map functions
    //{{AFX_MSG(CVSSProp)
    afx_msg void OnCreateNow();
    afx_msg void OnDeleteNow();
    afx_msg void OnItemchangedSnapshotList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemchangedVolumeList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    virtual BOOL OnInitDialog();
    afx_msg void OnEnable();
    afx_msg void OnDisable();
    afx_msg void OnSettings();
    afx_msg void OnHelpLink(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    LRESULT OnSetPageFocus(WPARAM wParam, LPARAM lParam);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VSSPROP_H__CB712178_310D_4459_9927_E0CAF69C7FA1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\vssui.cpp ===
// vssui.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f vssps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "vssui.h"

#include "vssui_i.c"
#include "vsspage.h"
#include "snapext.h"
#include "ShlExt.h"

#include <shfusion.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_VSSUI, CVSSUI)
OBJECT_ENTRY(CLSID_VSSShellExt, CVSSShellExt)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
CVssPageApp theApp;

BOOL CVssPageApp::InitInstance()
{
//    _Module.Init(ObjectMap, m_hInstance, &LIBID_VSSUILib);
    _Module.Init(ObjectMap, m_hInstance);
    SHFusionInitializeFromModuleID (m_hInstance, 2);
    DisableThreadLibraryCalls(m_hInstance);
    return CWinApp::InitInstance();
}

int CVssPageApp::ExitInstance()
{
    // MFC's class factories registration is
    // automatically revoked by MFC itself.
    if (m_bRun)
        _Module.RevokeClassObjects();

    SHFusionUninitialize();

    _Module.Term();
	return 0;
}

/*
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_VSSUILib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}
*/

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\vssui\vssprop.cpp ===
// CVSSProp.cpp : implementation file
//

#include "stdafx.h"
#include "utils.h"
#include "VSSProp.h"
#include "RemDlg.h"
#include "Settings.h"
#include "Hosting.h"
#include "uihelp.h"
#include "msgcomm.h" // vss error msg

#include <vss.h> // _VSS_SNAPSHOT_CONTEXT
#include <vsmgmt.h>
#include <vsswprv.h> // VSS_SWPRV_ProviderId
#include <vswriter.h>// VssFreeSnapshotProperties
#include <vsbackup.h> // VssFreeSnapshotProperties
#include <htmlhelp.h>
#include <clusapi.h> // GetNodeClusterState

#include <lm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVSSProp property page

IMPLEMENT_DYNCREATE(CVSSProp, CPropertyPage)

CVSSProp::CVSSProp() : CPropertyPage(CVSSProp::IDD)
{
    //{{AFX_DATA_INIT(CVSSProp)
    //}}AFX_DATA_INIT
    m_strComputer = _T("");
    m_strSelectedVolume = _T("");
    m_strDisabled.LoadString(IDS_DISABLED);
    m_hImageList = NULL;

    m_nScrollbarWidth = 16;
    m_nSnapshotListColumnWidth = 0;
    m_nSnapshotListCountPerPage = 0;
}

CVSSProp::CVSSProp(LPCTSTR pszComputer, LPCTSTR pszVolume) : CPropertyPage(CVSSProp::IDD)
{
#ifdef DEBUG
    OutputDebugString(_T("CVSSProp::CVSSPRop\n"));
#endif
    if (!pszComputer)
        m_strComputer = _T("");
    else
        m_strComputer = pszComputer + (TWO_WHACKS(pszComputer) ? 2 : 0);

    m_strSelectedVolume = (pszVolume ? pszVolume : _T(""));
    m_strDisabled.LoadString(IDS_DISABLED);
    m_hImageList = NULL;

    m_nScrollbarWidth = 16;
    m_nSnapshotListColumnWidth = 0;
    m_nSnapshotListCountPerPage = 0;
}

CVSSProp::~CVSSProp()
{
#ifdef DEBUG
    OutputDebugString(_T("CVSSProp::~CVSSPRop\n"));
#endif
    if(NULL != m_hImageList)
    {
       ImageList_Destroy(m_hImageList);
       m_hImageList = NULL;
    }
}

HRESULT CVSSProp::StoreShellExtPointer(IShellPropSheetExt* piShellExt)
{
    if (!piShellExt)
        return E_INVALIDARG;

    // This assignment will call AddRef().
    // Release() will later be called by ~CVSSProp().
    m_spiShellExt = piShellExt;

    return S_OK;
}

void CVSSProp::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CVSSProp)
    DDX_Control(pDX, IDC_VOLUME_LIST, m_ctrlVolumeList);
    DDX_Control(pDX, IDC_ENABLE, m_ctrlEnable);
    DDX_Control(pDX, IDC_DISABLE, m_ctrlDisable);
    DDX_Control(pDX, IDC_SETTINGS, m_ctrlSettings);
    DDX_Control(pDX, IDC_SNAPSHOT_LIST, m_ctrlSnapshotList);
    DDX_Control(pDX, IDC_CREATE, m_ctrlCreate);
    DDX_Control(pDX, IDC_DELETE, m_ctrlDelete);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CVSSProp, CPropertyPage)
    //{{AFX_MSG_MAP(CVSSProp)
    ON_BN_CLICKED(IDC_CREATE, OnCreateNow)
    ON_BN_CLICKED(IDC_DELETE, OnDeleteNow)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_SNAPSHOT_LIST, OnItemchangedSnapshotList)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_VOLUME_LIST, OnItemchangedVolumeList)
    ON_WM_CONTEXTMENU()
    ON_WM_HELPINFO()
    ON_BN_CLICKED(IDC_ENABLE, OnEnable)
    ON_BN_CLICKED(IDC_DISABLE, OnDisable)
    ON_BN_CLICKED(IDC_SETTINGS, OnSettings)
    ON_NOTIFY(NM_CLICK, IDC_EXPLANATION, OnHelpLink)
    ON_NOTIFY(NM_RETURN, IDC_EXPLANATION, OnHelpLink)
    ON_MESSAGE(WM_SETPAGEFOCUS, OnSetPageFocus)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVSSProp message handlers

//
// If we have successfully taken one snapshot of the specified volume, we will
// return VSS_S_ASYNC_FINISHED.
//
HRESULT CVSSProp::TakeOneSnapshotNow(IN LPCTSTR pszVolumeName) 
{
    if (!pszVolumeName || !*pszVolumeName)
        return E_INVALIDARG;

    VSS_ID SnapshotSetId = GUID_NULL;
    HRESULT hr = m_spiCoord->StartSnapshotSet(&SnapshotSetId);

    if (SUCCEEDED(hr))
    {
        VSS_ID SnapshotId = GUID_NULL;
        hr = m_spiCoord->AddToSnapshotSet(
                            (PTSTR)pszVolumeName,
                            VSS_SWPRV_ProviderId,
                            &SnapshotId);
        if (SUCCEEDED(hr))
        {
            CComPtr<IVssAsync> spiAsync;
            hr = m_spiCoord->DoSnapshotSet(NULL, &spiAsync);
            if (SUCCEEDED(hr))
            {
                hr = spiAsync->Wait();
                if (SUCCEEDED(hr))
                {
                    HRESULT hrStatus = S_OK;
                    hr = spiAsync->QueryStatus(&hrStatus, NULL);
                    if (SUCCEEDED(hr))
                    {
                        return hrStatus;
                    }
                }
            }
        }
    }

    return hr;
}

//
// OnCreateNow works when only one volume is currently selected.
//
void CVSSProp::OnCreateNow() 
{
    CWaitCursor wait;

    if (m_strSelectedVolume.IsEmpty())
        return;

    PTSTR pszVolumeName = GetVolumeName(&m_VolumeList, m_strSelectedVolume);
    ASSERT(pszVolumeName);

    HRESULT hr = TakeOneSnapshotNow(pszVolumeName);
    if (VSS_S_ASYNC_FINISHED == (DWORD)hr)
    {
        UpdateSnapshotList();
        UpdateDiffArea();
        UpdateEnableDisableButtons();
    } else if (FAILED(hr))
    {
        DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_TAKESNAPSHOT_ERROR, m_strSelectedVolume);
    }
}

//
// OnDeleteNow works on multi-selected snapshots when only one volume is currently selected.
//
void CVSSProp::OnDeleteNow() 
{
    CWaitCursor wait;

    if (m_strSelectedVolume.IsEmpty())
        return;

    BOOL    bAtLeastOneDeleted = FALSE;
    HRESULT hr = S_OK;

    int nIndex = -1;
    while (-1 != (nIndex = m_ctrlSnapshotList.GetNextItem(nIndex, LVNI_SELECTED)))
    {
        VSSUI_SNAPSHOT *pSnapshot = (VSSUI_SNAPSHOT *)GetListViewItemData(m_ctrlSnapshotList.m_hWnd, nIndex);
        ASSERT(pSnapshot);
        if (!pSnapshot)
            continue;  // shouldn't happen, skip it just in case

        LONG lDeletedSnapshots = 0;
        VSS_ID ProblemSnapshotId = GUID_NULL;
        hr = m_spiCoord->DeleteSnapshots(pSnapshot->idSnapshot,
                                        VSS_OBJECT_SNAPSHOT,
                                        TRUE,
                                        &lDeletedSnapshots,
                                        &ProblemSnapshotId
                                        );
        if (SUCCEEDED(hr) || VSS_E_OBJECT_NOT_FOUND == hr)
        {
            hr = S_OK; // ignore if snapshot has already been deleted
            bAtLeastOneDeleted = TRUE;
        }

        if (FAILED(hr))
            break;
    }

    if (FAILED(hr))
        DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_DELETESNAPSHOTS_ERROR, m_strSelectedVolume);

    if (bAtLeastOneDeleted)
    {
        UpdateSnapshotList();
        if (0 == m_ctrlSnapshotList.GetSelectedCount())
        {
            ::SendMessage(m_hWnd, DM_SETDEFID, (WPARAM)IDC_CREATE, (LPARAM)0);
            m_ctrlCreate.SetFocus(); // DeleteNow button has been disabled, set focus to CreateNow button
        }

        UpdateDiffArea();
        UpdateEnableDisableButtons();
    }
}

#define HKCU_VSSUI_KEY          _T("Software\\Microsoft\\VSSUI")
#define REGVALUENAME_ENABLE     _T("EnableReminderOff")
#define REGVALUENAME_DISABLE    _T("DisableReminderOff")

void CVSSProp::OnEnable() 
{
    BOOL bShowReminder = TRUE;

    HKEY hKey = NULL;
    LONG lErr = RegCreateKeyEx(HKEY_CURRENT_USER,
                                HKCU_VSSUI_KEY,
                                0,                              // reserved
                                _T(""),                         // lpClass
                                REG_OPTION_NON_VOLATILE,
                                KEY_QUERY_VALUE | KEY_SET_VALUE,
                                NULL,                           // lpSecurityAttributes
                                &hKey,
                                NULL                            // lpdwDisposition
                                );
    if (ERROR_SUCCESS == lErr)
    {
        DWORD dwType = 0;
        DWORD dwData = 0;
        DWORD cbData = sizeof(DWORD);

        lErr = RegQueryValueEx(hKey, REGVALUENAME_ENABLE, 0, &dwType, (LPBYTE)&dwData, &cbData);

        if (ERROR_SUCCESS == lErr && REG_DWORD == dwType && 0 != dwData)
            bShowReminder = FALSE;
    }

    int nRet = IDOK;
    if (bShowReminder)
    {
        CReminderDlgEx dlg(hKey, REGVALUENAME_ENABLE);
        nRet = dlg.DoModal();
    }

    if (hKey)
        RegCloseKey(hKey);

    if (IDOK == nRet)
        DoEnable();
}

HRESULT CVSSProp::DoEnable()
{
    CWaitCursor wait;

    HRESULT hr = S_OK;
    LVITEM lvItem = {0};
    int nSelectedCount = m_ctrlVolumeList.GetSelectedCount();
    if (nSelectedCount > 0)
    {
        POSITION pos = m_ctrlVolumeList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nIndex = m_ctrlVolumeList.GetNextSelectedItem(pos);
            VSSUI_VOLUME *pVolume = (VSSUI_VOLUME *)GetListViewItemData(m_ctrlVolumeList.m_hWnd, nIndex);
            ASSERT(pVolume);
            if (!pVolume)
                continue; // shouldn't happen, skip it just in case

            // bug#495719 - prompt instructions when enabling vss on a small volume
            ULONGLONG   llDiffVolumeTotalSpace = 0;
            ULONGLONG   llDiffVolumeFreeSpace = 0;
            hr = GetVolumeSpace(
                                m_spiDiffSnapMgmt,
                                pVolume->pszDisplayName,
                                &llDiffVolumeTotalSpace,
                                &llDiffVolumeFreeSpace);

            if (SUCCEEDED(hr) && llDiffVolumeTotalSpace < MINIMUM_DIFF_LIMIT) // ignore the failure of GetVolumeSpace
            {
                VSSUI_DIFFAREA diffArea;
                hr = GetDiffAreaInfo(m_spiDiffSnapMgmt, &m_VolumeList, pVolume->pszVolumeName, &diffArea);
                if (S_OK != hr) // failed to retrieve diff area association, assume it doesn't have one
                {
                    DoErrMsgBox(m_hWnd, MB_OK, 0, IDS_CANNOT_ENABLE_SMALL_VOLUME, pVolume->pszDisplayName);
                    continue; // skip enabling this selection
                }
            }

            // bug#494209: take a snapshot first, if failed, no need to create the default schedule

            //
            // take one snapshot now, it will create default diff area association if none
            //
            hr = TakeOneSnapshotNow(pVolume->pszVolumeName);
            if (VSS_S_ASYNC_FINISHED == (DWORD)hr)
            {
                if (1 == nSelectedCount)
                    UpdateSnapshotList();

                UpdateDiffArea(nIndex, pVolume->pszVolumeName);
            } else if (FAILED(hr))
            {
                DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_TAKESNAPSHOT_ERROR, pVolume->pszDisplayName);
                break;
            }

            //
            // if none, create default schedule for that volume
            //
            CComPtr<ITask> spiTask;
            hr = FindScheduledTimewarpTask(
                                        (ITaskScheduler *)m_spiTS,
                                        pVolume->pszVolumeName,
                                        &spiTask);
            if (FAILED(hr))
            {
                DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_FINDSCHEDULE_ERROR, pVolume->pszDisplayName);
            } else if (S_FALSE == hr)  // task not found
            {
                (void)DeleteAllScheduledTimewarpTasks((ITaskScheduler *)m_spiTS,
                                                    m_strComputer,
                                                    pVolume->pszVolumeName,
                                                    TRUE // i_bDeleteDisabledOnesOnly
                                                    );
                hr = CreateDefaultEnableSchedule(
                                        (ITaskScheduler *)m_spiTS,
                                        m_strComputer,
                                        pVolume->pszDisplayName,
                                        pVolume->pszVolumeName,
                                        &spiTask);
                if (FAILED(hr))
                    DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_CREATESCHEDULE_ERROR, pVolume->pszDisplayName);
            }

            if (SUCCEEDED(hr))
            {
                UpdateSchedule((ITask *)spiTask, nIndex);

                // bug#494491: we need to update the Enable/Disable button when schedule changes.
                if (1 == nSelectedCount)
                {
                    UpdateEnableDisableButtons();

                    ::SendMessage(m_hWnd, DM_SETDEFID, (WPARAM)IDC_DISABLE, (LPARAM)0);
                    m_ctrlDisable.SetFocus(); // Disable button will be enabled, set focus to it
                }
            } else
                break;
        }
    }

    return hr;
}

void CVSSProp::OnDisable() 
{
    BOOL bShowReminder = TRUE;

    HKEY hKey = NULL;
    LONG lErr = RegCreateKeyEx(HKEY_CURRENT_USER,
                                HKCU_VSSUI_KEY,
                                0,                              // reserved
                                _T(""),                         // lpClass
                                REG_OPTION_NON_VOLATILE,
                                KEY_QUERY_VALUE | KEY_SET_VALUE,
                                NULL,                           // lpSecurityAttributes
                                &hKey,
                                NULL                            // lpdwDisposition
                                );
    if (ERROR_SUCCESS == lErr)
    {
        DWORD dwType = 0;
        DWORD dwData = 0;
        DWORD cbData = sizeof(DWORD);

        lErr = RegQueryValueEx(hKey, REGVALUENAME_DISABLE, 0, &dwType, (LPBYTE)&dwData, &cbData);

        if (ERROR_SUCCESS == lErr && REG_DWORD == dwType && 0 != dwData)
            bShowReminder = FALSE;
    }

    int nRet = IDOK;
    if (bShowReminder)
    {
        CReminderDlg dlg(hKey, REGVALUENAME_DISABLE);
        nRet = dlg.DoModal();
    }

    if (hKey)
        RegCloseKey(hKey);

    if (IDOK == nRet)
        DoDisable();
}

HRESULT CVSSProp::DoDisable()
{
    CWaitCursor wait;

    HRESULT hr = S_OK;
    LVITEM lvItem = {0};
    int nSelectedCount = m_ctrlVolumeList.GetSelectedCount();
    if (nSelectedCount > 0)
    {
        POSITION pos = m_ctrlVolumeList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nIndex = m_ctrlVolumeList.GetNextSelectedItem(pos);
            VSSUI_VOLUME *pVolume = (VSSUI_VOLUME *)GetListViewItemData(m_ctrlVolumeList.m_hWnd, nIndex);
            ASSERT(pVolume);
            if (!pVolume)
                continue; // shouldn't happen, skip it just in case

            //
            // delete all snapshots on that volume
            //
            hr = DeleteAllSnapshotsOnVolume(pVolume->pszVolumeName);
            if (1 == nSelectedCount)
                UpdateSnapshotList();
            if (FAILED(hr))
            {
                DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_DELETESNAPSHOTS_ERROR, pVolume->pszDisplayName);
                break;
            }

            //
            // delete all scheduled tasks for that volume
            //
            hr = DeleteAllScheduledTimewarpTasks((ITaskScheduler *)m_spiTS,
                                                m_strComputer,
                                                pVolume->pszVolumeName,
                                                FALSE // i_bDeleteDisabledOnesOnly
                                                );

            if (SUCCEEDED(hr))
                UpdateSchedule(NULL, nIndex);
            else
            {
                DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_FINDSCHEDULE_ERROR, pVolume->pszDisplayName);
                break;
            }

            //
            // remove diff area associate for that volume
            //
            VSSUI_DIFFAREA diffArea;
            hr = GetDiffAreaInfo(m_spiDiffSnapMgmt, &m_VolumeList, pVolume->pszVolumeName, &diffArea);
            if (S_OK == hr)
            {
                PTSTR pszDiffAreaVolumeName = GetVolumeName(&m_VolumeList, diffArea.pszDiffVolumeDisplayName);
                ASSERT(pszDiffAreaVolumeName);
                hr = m_spiDiffSnapMgmt->ChangeDiffAreaMaximumSize(
                                                pVolume->pszVolumeName, 
                                                pszDiffAreaVolumeName, 
                                                VSS_ASSOC_REMOVE);
                if (VSS_E_OBJECT_NOT_FOUND == hr)
                    hr = S_OK; // ignore if diff assoc has already been deleted
            }
            if (SUCCEEDED(hr))
            {
                UpdateDiffArea(nIndex, pVolume->pszVolumeName);
            } 
            else if (hr == VSS_E_VOLUME_IN_USE)
            {
                // Special error message (Bug 519124)
                DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_DELETEDIFFAREA_ERROR_IN_USE, pVolume->pszDisplayName);
            }
            else
            {
                DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_DELETEDIFFAREA_ERROR, pVolume->pszDisplayName);
            }

            // bug#494491: we need to update the Enable/Disable button even when failure occurs.
            if (1 == nSelectedCount)
            {
                UpdateEnableDisableButtons();

                if (SUCCEEDED(hr))
                {
                    ::SendMessage(m_hWnd, DM_SETDEFID, (WPARAM)IDC_ENABLE, (LPARAM)0);
                    m_ctrlEnable.SetFocus(); // Enable button will be enabled, set focus to it
                }
            }

            if (FAILED(hr))
                break;
        }
    }

    return hr;
}

HRESULT CVSSProp::DeleteAllSnapshotsOnVolume(
    IN LPCTSTR pszVolumeName
    )
{
    if (!pszVolumeName || !*pszVolumeName)
        return E_INVALIDARG;

    CComPtr<IVssEnumObject> spiEnumSnapshots;
    HRESULT hr = m_spiMgmt->QuerySnapshotsByVolume(
                                            (PTSTR)pszVolumeName,
                                            VSS_SWPRV_ProviderId,
                                            &spiEnumSnapshots
                                            );
    if (S_OK == hr)
    {
        VSS_OBJECT_PROP     Prop;
        VSS_SNAPSHOT_PROP*  pSnapProp = &(Prop.Obj.Snap);
        ULONG               ulFetched = 0;
        while (SUCCEEDED(spiEnumSnapshots->Next(1, &Prop, &ulFetched)) && ulFetched > 0)
        {
            if (VSS_OBJECT_SNAPSHOT != Prop.Type)
                return E_FAIL;

            if (pSnapProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE)
            {
                LONG lDeletedSnapshots = 0;
                VSS_ID ProblemSnapshotId = GUID_NULL;
                hr = m_spiCoord->DeleteSnapshots(pSnapProp->m_SnapshotId,
                                                VSS_OBJECT_SNAPSHOT,
                                                TRUE,
                                                &lDeletedSnapshots,
                                                &ProblemSnapshotId
                                                );
                VssFreeSnapshotProperties(pSnapProp);

                if (VSS_E_OBJECT_NOT_FOUND == hr)
                    hr = S_OK; // ignore if snapshot has already been deleted

                if (FAILED(hr))
                    break;
            }
        }
    }

    return hr;
}

void CVSSProp::OnSettings() 
{
    CWaitCursor wait;

    CSettings dlg(m_strComputer, m_strSelectedVolume);
    HRESULT hr = dlg.Init(m_spiDiffSnapMgmt,
                        m_spiTS,
                        m_bCluster,
                        &m_VolumeList,
                        !m_SnapshotList.empty());

    if (FAILED(hr))
    {
        DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_SETTINGS_ERROR, m_strSelectedVolume);
        return;
    }

    dlg.DoModal();

    UpdateDiffArea();
    UpdateSchedule();
    UpdateEnableDisableButtons();

    UpdateSnapshotList();
}

void CVSSProp::OnItemchangedSnapshotList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    m_ctrlDelete.EnableWindow(0 < m_ctrlSnapshotList.GetSelectedCount());
    
    *pResult = 0;
}

void CVSSProp::OnItemchangedVolumeList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    
    int nSelectedCount = m_ctrlVolumeList.GetSelectedCount();
    if (0 == nSelectedCount)
    {
        m_ctrlEnable.EnableWindow(FALSE);
        m_ctrlDisable.EnableWindow(FALSE);
        m_ctrlSettings.EnableWindow(FALSE);
        m_ctrlCreate.EnableWindow(FALSE);
        m_ctrlDelete.EnableWindow(FALSE);
    } else
    {
        m_ctrlSettings.EnableWindow(1 == nSelectedCount);
        m_ctrlCreate.EnableWindow(1 == nSelectedCount);

        UpdateEnableDisableButtons();
    }

    if (1 < nSelectedCount)
    {
        m_strSelectedVolume = _T("");
    } else
    {
        int nIndex = m_ctrlVolumeList.GetNextItem(-1, LVNI_SELECTED);
        if (-1 != nIndex)
        {
            m_strSelectedVolume = m_ctrlVolumeList.GetItemText(nIndex, 0);
        } else
        {
            m_strSelectedVolume = _T("");
        }
    }

    CWaitCursor wait;
    UpdateSnapshotList();

    *pResult = 0;
}

void CVSSProp::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if (!pWnd)
        return;

    ::WinHelp(pWnd->GetSafeHwnd(),
                VSSUI_CTX_HELP_FILE,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(PVOID)aMenuHelpIDsForVSSProp); 
}

BOOL CVSSProp::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (!pHelpInfo || 
        pHelpInfo->iContextType != HELPINFO_WINDOW || 
        pHelpInfo->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)pHelpInfo->hItemHandle,
                VSSUI_CTX_HELP_FILE,
                HELP_WM_HELP,
                (DWORD_PTR)(PVOID)aMenuHelpIDsForVSSProp); 

    return TRUE;
}

BOOL CVSSProp::OnInitDialog() 
{
    CWaitCursor wait;

    CPropertyPage::OnInitDialog();
    
    m_bHideAllControls = FALSE;
    CString strMsg;

    HRESULT hr = S_OK;
    
    do {
        hr = InitInterfacePointers();
        if (FAILED(hr))
        {
            GetMsg(strMsg, hr, IDS_VSSPROP_INIT_ERROR);
            m_bHideAllControls = TRUE;
            break;
        }

        hr = GetVolumes(); // get a list of volumes that are suitable for taking snapshots

        if (FAILED(hr))
        {
            GetMsg(strMsg, hr, IDS_VSSPROP_GETVOLUMES_ERROR);
            m_bHideAllControls = TRUE;
            break;
        }

        if (m_VolumeList.empty())
        {
            GetMsg(strMsg, 0, IDS_VSSPROP_EMPTY_VOLUMELIST);
            m_bHideAllControls = TRUE;
            break;
        }

        if (!m_strSelectedVolume.IsEmpty())
        {
            BOOL bFound = FALSE;
            for (VSSUI_VOLUME_LIST::iterator i = m_VolumeList.begin(); i != m_VolumeList.end(); i++)
            {
                if (!m_strSelectedVolume.CompareNoCase((*i)->pszDisplayName))
                {
                    bFound = TRUE;
                    break;
                }
            }

            // in case of mounted drive without assigned drive letter, the SelectedVolume could be the GUID name
            if (!bFound)
            {
                for (VSSUI_VOLUME_LIST::iterator i = m_VolumeList.begin(); i != m_VolumeList.end(); i++)
                {
                    if (!m_strSelectedVolume.CompareNoCase((*i)->pszVolumeName))
                    {
                        bFound = TRUE;
                        m_strSelectedVolume = (*i)->pszDisplayName; // change the selected volume to hold the display name
                        break;
                    }
                }
            }

            if (!bFound)
            {
                GetMsg(strMsg, 0, IDS_VSSPROP_VOLUME_ILEGIBLE, m_strSelectedVolume);
                m_bHideAllControls = TRUE;
                break;
            }
        }
    } while (0);

    if (m_bHideAllControls)
    {
        GetDlgItem(IDC_VSSPROP_ERROR)->SetWindowText(strMsg);
        GetDlgItem(IDC_VSSPROP_ERROR)->EnableWindow(TRUE);

        for (int i = IDC_EXPLANATION; i < IDC_VSSPROP_ERROR; i++)
        {
            GetDlgItem(i)->EnableWindow(FALSE);
            GetDlgItem(i)->ShowWindow(SW_HIDE);
        }
    } else
    {
        GetDlgItem(IDC_VSSPROP_ERROR)->EnableWindow(FALSE);
        GetDlgItem(IDC_VSSPROP_ERROR)->ShowWindow(SW_HIDE);
        //
        // insert column header of the Volume listbox
        //
        HWND hwnd = m_ctrlVolumeList.m_hWnd;
        m_hImageList = ImageList_LoadBitmap(
                                _Module.GetResourceInstance(),
                                MAKEINTRESOURCE(IDB_VOLUME_16x16),
                                16,
                                8,
                                CLR_DEFAULT);
        ListView_SetImageList(hwnd, m_hImageList, LVSIL_SMALL);

        AddLVColumns(
                hwnd, 
                IDS_VOLUMELIST_COLUMN_VOLUME,
                IDS_VOLUMELIST_COLUMN_USED - IDS_VOLUMELIST_COLUMN_VOLUME + 1);
        ListView_SetExtendedListViewStyle(hwnd, LVS_EX_FULLROWSELECT);
        
        //
        // insert column headers for the snapshot listbox
        //
        AddLVColumns(
                m_ctrlSnapshotList.m_hWnd,
                IDS_SNAPSHOTLIST_COLUMN_TIMESTAMP,
                IDS_SNAPSHOTLIST_COLUMN_TIMESTAMP - IDS_SNAPSHOTLIST_COLUMN_TIMESTAMP + 1);
        ListView_SetExtendedListViewStyle(m_ctrlSnapshotList.m_hWnd, LVS_EX_FULLROWSELECT);

        // remember the original column width, later we need to adjust the width
        // to eliminate the horizontal scroll bar
        m_nSnapshotListColumnWidth = ListView_GetColumnWidth(m_ctrlSnapshotList.m_hWnd, 0);

        // before we insert rows, we need to remember the initial volume such that
        // we can pass it to SelectVolume() later.
        CString cstrVolume = m_strSelectedVolume;

        InsertVolumeInfo(hwnd);
        InsertDiffAreaInfo(hwnd);
        InsertShareInfo(hwnd);
        InsertScheduleInfo(hwnd);
        SelectVolume(hwnd, cstrVolume);

        // Since we're using the medium property page size (227, 215) as other shell pages,
        // we need to adjust the column width a little bit to make the UI look prettier.
        // We adjust column width after InsertVolumeInfo call, where we might shrink the 
        // Share column to eliminate the horizontal bar.
        int nAdjustment = 10; // we find this number by experiment
        int nCol = IDS_VOLUMELIST_COLUMN_VOLUME - IDS_VOLUMELIST_COLUMN_VOLUME;
        int nColumnWidth = ListView_GetColumnWidth(hwnd, nCol);
        if (nAdjustment < nColumnWidth)
        {
            // shrink the Volume column
            ListView_SetColumnWidth(hwnd, nCol, nColumnWidth - nAdjustment);

            // widen the Next Run Time column
            nCol = IDS_VOLUMELIST_COLUMN_NEXTRUNTIME - IDS_VOLUMELIST_COLUMN_VOLUME;
            nColumnWidth = ListView_GetColumnWidth(hwnd, nCol);
            ListView_SetColumnWidth(hwnd, nCol, nColumnWidth + nAdjustment);
        }

        UpdateEnableDisableButtons();

        UpdateSnapshotList();
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CVSSProp::_ResetInterfacePointers()
{
    if ((IVssSnapshotMgmt *)m_spiMgmt)
        m_spiMgmt.Release();

    if ((IVssCoordinator *)m_spiCoord)
        m_spiCoord.Release();

    if ((IVssDifferentialSoftwareSnapshotMgmt *)m_spiDiffSnapMgmt)
        m_spiDiffSnapMgmt.Release();

    if ((ITaskScheduler *)m_spiTS)
        m_spiTS.Release();

    m_bCluster = FALSE;
}

HRESULT CVSSProp::InitInterfacePointers()
{
    _ResetInterfacePointers();

    HRESULT hr = S_OK;
    if (m_strComputer.IsEmpty())
    {
        hr = CoCreateInstance(CLSID_VssSnapshotMgmt, 
                                NULL,
                                CLSCTX_LOCAL_SERVER,
                                IID_IVssSnapshotMgmt,
                                (void **)&m_spiMgmt);
        if (SUCCEEDED(hr))
            hr = CoCreateInstance(CLSID_VSSCoordinator, 
                        NULL,
                        CLSCTX_LOCAL_SERVER,
                        IID_IVssCoordinator,
                        (void **)&m_spiCoord);

    } else
    {
        COSERVERINFO serverInfo = {0};
        serverInfo.pwszName = (LPTSTR)(LPCTSTR)m_strComputer;

        IID         iid = IID_IVssSnapshotMgmt;
        MULTI_QI    MQI = {0};
        MQI.pIID = &iid;
        hr = CoCreateInstanceEx(CLSID_VssSnapshotMgmt, 
                                NULL,
                                CLSCTX_REMOTE_SERVER,
                                &serverInfo,
                                1,
                                &MQI);
        if (SUCCEEDED(hr))
        {
            m_spiMgmt = (IVssSnapshotMgmt *)MQI.pItf;

            ZeroMemory(&MQI, sizeof(MQI));
            iid = IID_IVssCoordinator;
            MQI.pIID = &iid;
            hr = CoCreateInstanceEx(CLSID_VSSCoordinator, 
                                    NULL,
                                    CLSCTX_REMOTE_SERVER,
                                    &serverInfo,
                                    1,
                                    &MQI);
            if (SUCCEEDED(hr))
                m_spiCoord = (IVssCoordinator *)MQI.pItf;
        }
    }

    if (SUCCEEDED(hr))
        hr = m_spiCoord->SetContext(VSS_CTX_CLIENT_ACCESSIBLE);

    if (SUCCEEDED(hr))
        hr = m_spiMgmt->GetProviderMgmtInterface(
                                    VSS_SWPRV_ProviderId,
                                    IID_IVssDifferentialSoftwareSnapshotMgmt,
                                    (IUnknown**)&m_spiDiffSnapMgmt);

    if (SUCCEEDED(hr))
        hr = CoCreateInstance(CLSID_CTaskScheduler,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_ITaskScheduler,
                                (void **)&m_spiTS);
  
    if (SUCCEEDED(hr))
    {
        // SetTargetComputer requires server name to start with whackwhack
        if (m_strComputer.IsEmpty())
            hr = m_spiTS->SetTargetComputer(NULL);
        else
        {
            CString strTargetComputer = _T("\\\\");
            strTargetComputer += m_strComputer;
            hr = m_spiTS->SetTargetComputer((LPCTSTR)strTargetComputer);
        }
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwState = 0;
        if (ERROR_SUCCESS == GetNodeClusterState(m_strComputer, &dwState) && ClusterStateRunning == dwState)
        {
            m_bCluster = TRUE;
        }
    }

    if (FAILED(hr))
        _ResetInterfacePointers();

    return hr;
}

HRESULT CVSSProp::GetVolumes()
{
    if (!m_spiMgmt)
        return E_INVALIDARG;

    FreeVolumeList(&m_VolumeList);

    CComPtr<IVssEnumMgmtObject> spiEnumMgmt;
    HRESULT hr = m_spiMgmt->QueryVolumesSupportedForSnapshots(
                    VSS_SWPRV_ProviderId,
                    VSS_CTX_CLIENT_ACCESSIBLE,
                    &spiEnumMgmt);
    if (FAILED(hr))
        return hr;

    VSS_MGMT_OBJECT_PROP Prop;
    VSS_VOLUME_PROP *pVolProp = &(Prop.Obj.Vol);
    ULONG ulFetched = 0;
    while (SUCCEEDED(hr = spiEnumMgmt->Next(1, &Prop, &ulFetched)) && ulFetched > 0)
    {
        if (VSS_MGMT_OBJECT_VOLUME != Prop.Type)
            return E_FAIL;

        VSSUI_VOLUME *pVolInfo = (VSSUI_VOLUME *)calloc(1, sizeof(VSSUI_VOLUME));
        if (pVolInfo)
        {
            lstrcpyn(pVolInfo->pszVolumeName, pVolProp->m_pwszVolumeName, MAX_PATH);
            lstrcpyn(pVolInfo->pszDisplayName, pVolProp->m_pwszVolumeDisplayName, MAX_PATH);
            m_VolumeList.push_back(pVolInfo);
        } else
        {
            FreeVolumeList(&m_VolumeList);
            hr = E_OUTOFMEMORY;
        }
        CoTaskMemFree(pVolProp->m_pwszVolumeName);
        CoTaskMemFree(pVolProp->m_pwszVolumeDisplayName);

        if (FAILED(hr))
            break;
    }
    if (hr == S_FALSE)
        // End of loop detected
        hr = S_OK;

    return hr;
}

HRESULT CVSSProp::InsertVolumeInfo(HWND hwnd)
{
    ListView_DeleteAllItems(hwnd);

    for (VSSUI_VOLUME_LIST::iterator i = m_VolumeList.begin(); i != m_VolumeList.end(); i++)
    {
        LVITEM lvItem = {0};
        lvItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        lvItem.lParam = (LPARAM)(*i);
        lvItem.pszText = (*i)->pszDisplayName;
        lvItem.iSubItem = 0;
        lvItem.iImage = 1;
        ListView_InsertItem(hwnd, &lvItem);
    }

    if (m_VolumeList.size() > 0)
    {
        int nVolumeListCountPerPage = ListView_GetCountPerPage(hwnd);

        if (m_VolumeList.size() > nVolumeListCountPerPage)
        {
            // we shrink the "Shares" column to eliminate the honrizontal scroll bar
            int nCol = IDS_VOLUMELIST_COLUMN_NUMOFSHARES - IDS_VOLUMELIST_COLUMN_VOLUME;
            int nSharesColumnWidth = ListView_GetColumnWidth(hwnd, nCol);
            ListView_SetColumnWidth(hwnd, nCol, nSharesColumnWidth - m_nScrollbarWidth);
        }
    }

    return S_OK;
}

//
// Update diff area column of the currently selected volume
//
HRESULT CVSSProp::UpdateDiffArea()
{
    if (m_strSelectedVolume.IsEmpty())
        return E_INVALIDARG;

    int nIndex = m_ctrlVolumeList.GetNextItem(-1, LVNI_SELECTED);
    ASSERT(-1 != nIndex);

    PTSTR pszVolumeName = GetVolumeName(&m_VolumeList, m_strSelectedVolume);
    ASSERT(pszVolumeName);

    return UpdateDiffArea(nIndex, pszVolumeName);
}

//
// Update diff area column of the specified volume
//
HRESULT CVSSProp::UpdateDiffArea(int nIndex, LPCTSTR pszVolumeName)
{
    CString strMsg = _T("");
    VSSUI_DIFFAREA diffArea;
    HRESULT hr = GetDiffAreaInfo(m_spiDiffSnapMgmt, &m_VolumeList, pszVolumeName, &diffArea);

    if (S_OK == hr)
    {
        //
        // "Used on DiffVolume"
        //
        TCHAR szUsed[MAX_PATH];
        DWORD dwSize = sizeof(szUsed)/sizeof(TCHAR);
        DiskSpaceToString(diffArea.llUsedDiffSpace, szUsed, &dwSize);

        strMsg.FormatMessage(IDS_USED_ON_VOLUME, szUsed, diffArea.pszDiffVolumeDisplayName);
    }

    LVITEM lvItem = {0};
    lvItem.iItem = nIndex;
    lvItem.mask = LVIF_TEXT;
    lvItem.pszText = (PTSTR)(LPCTSTR)strMsg;
    lvItem.iSubItem = IDS_VOLUMELIST_COLUMN_USED - IDS_VOLUMELIST_COLUMN_VOLUME;
    m_ctrlVolumeList.SetItem(&lvItem);

    return hr;
}

HRESULT CVSSProp::InsertDiffAreaInfo(HWND hwnd)
{
    if (m_VolumeList.empty())
        return S_OK;

    int nIndex = -1;
    while (-1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL)))
    {
        VSSUI_VOLUME *pVolume = (VSSUI_VOLUME *)GetListViewItemData(hwnd, nIndex);
        ASSERT(pVolume);
        if (!pVolume)
            continue; // shouldn't happen, skip it just in case

        UpdateDiffArea(nIndex, pVolume->pszVolumeName);
    }

    return S_OK;
}

HRESULT CVSSProp::InsertShareInfo(HWND hwnd)
{
    if (m_VolumeList.empty())
        return S_OK;

    SHARE_INFO_2 *pInfo = NULL;
    DWORD dwEntriesRead = 0;
    DWORD dwEntriesTotal = 0;
    DWORD dwRet = NetShareEnum((PTSTR)(LPCTSTR)m_strComputer, 
                                2, 
                                (LPBYTE *)&pInfo,
                                -1, //max
                                &dwEntriesRead,
                                &dwEntriesTotal,
                                NULL // resume handle
                                );

    if (NERR_Success != dwRet)
        return HRESULT_FROM_WIN32(dwRet);

    TCHAR szNumOfShares[256];
    int nIndex = -1;
    while (-1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL)))
    {
        VSSUI_VOLUME *pVolume = (VSSUI_VOLUME *)GetListViewItemData(hwnd, nIndex);
        ASSERT(pVolume);
        if (!pVolume)
            continue; // shouldn't happen, skip it just in case

        UINT count = 0;

        for (DWORD i = 0; i < dwEntriesRead; i++)
        {
            if (pInfo[i].shi2_type == STYPE_DISKTREE)
            {
                if (!mylstrncmpi(pInfo[i].shi2_path, pVolume->pszDisplayName, lstrlen(pVolume->pszDisplayName)))
                    count++;
            }
        }

        _stprintf(szNumOfShares, _T("%d"), count); // no need to localize the format
        LVITEM lvItem = {0};
        lvItem.iItem = nIndex;
        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = szNumOfShares;
        lvItem.iSubItem = IDS_VOLUMELIST_COLUMN_NUMOFSHARES - IDS_VOLUMELIST_COLUMN_VOLUME;
        ListView_SetItem(hwnd, &lvItem);
    }

    NetApiBufferFree(pInfo);
    
    return S_OK;
}

//
// Update schedule column of the currently selected volume
//
HRESULT CVSSProp::UpdateSchedule()
{
    if (m_strSelectedVolume.IsEmpty())
        return E_INVALIDARG;

    int nIndex = m_ctrlVolumeList.GetNextItem(-1, LVNI_SELECTED);
    ASSERT(-1 != nIndex);
    VSSUI_VOLUME *pVolume = (VSSUI_VOLUME *)GetListViewItemData(m_ctrlVolumeList.m_hWnd, nIndex);
    ASSERT(pVolume);
    if (!pVolume)
        return E_FAIL;

    return UpdateSchedule(nIndex, pVolume->pszVolumeName);
}

//
// Update schedule column of the specified volume
//
HRESULT CVSSProp::UpdateSchedule(int nIndex, LPCTSTR pszVolumeName)
{
    if (!pszVolumeName || !*pszVolumeName)
        return E_INVALIDARG;

    CComPtr<ITask> spiTask;
    (void)FindScheduledTimewarpTask((ITaskScheduler *)m_spiTS, pszVolumeName, &spiTask);

    UpdateSchedule((ITask *)spiTask, nIndex);

    return S_OK;
}

void CVSSProp::UpdateSchedule(ITask * i_piTask, int nIndex)
{
    BOOL bEnabled = FALSE;
    SYSTEMTIME stNextRun = {0};
    if (i_piTask)
        (void)GetScheduledTimewarpTaskStatus(i_piTask, &bEnabled, &stNextRun);

    LVITEM lvItem = {0};
    lvItem.iItem = nIndex;
    lvItem.mask = LVIF_IMAGE;
    lvItem.iImage = (bEnabled ? 0 : 1);
    lvItem.iSubItem = 0;
    m_ctrlVolumeList.SetItem(&lvItem);

    TCHAR szNextRun[MAX_PATH] = _T("");
    DWORD dwSize = sizeof(szNextRun)/sizeof(TCHAR);

    if (bEnabled)
        SystemTimeToString(&stNextRun, szNextRun, &dwSize);
    else
        lstrcpyn(szNextRun, m_strDisabled, MAX_PATH);

    ZeroMemory(&lvItem, sizeof(LVITEM));
    lvItem.iItem = nIndex;
    lvItem.mask = LVIF_TEXT;
    lvItem.pszText = szNextRun;
    lvItem.iSubItem = IDS_VOLUMELIST_COLUMN_NEXTRUNTIME - IDS_VOLUMELIST_COLUMN_VOLUME;
    m_ctrlVolumeList.SetItem(&lvItem);
}

HRESULT CVSSProp::InsertScheduleInfo(HWND hwnd)
{
    if (m_VolumeList.empty())
        return S_OK;

    int nIndex = -1;
    while (-1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL)))
    {
        VSSUI_VOLUME *pVolume = (VSSUI_VOLUME *)GetListViewItemData(hwnd, nIndex);
        ASSERT(pVolume);
        if (!pVolume)
            continue; // shouldn't happen, skip it just in case

        UpdateSchedule(nIndex, pVolume->pszVolumeName);
    }

    return S_OK;
}

void CVSSProp::SelectVolume(HWND hwnd, LPCTSTR pszVolume)
{
    if (m_VolumeList.empty())
        return;

    int nIndex = -1;
    if (pszVolume && *pszVolume)
    {
        while (-1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL)))
        {
            VSSUI_VOLUME *pVolume = (VSSUI_VOLUME *)GetListViewItemData(hwnd, nIndex);
            ASSERT(pVolume);
            if (!pVolume)
                continue; // shouldn't happen, skip it just in case

            if (!lstrcmpi(pszVolume, pVolume->pszDisplayName))
                break;
        }
    }

    if (-1 == nIndex)
        nIndex = 0;

    ListView_SetItemState(hwnd, nIndex, LVIS_SELECTED | LVIS_FOCUSED, 0xffffffff);
    ListView_EnsureVisible(hwnd, nIndex, FALSE);
}

HRESULT CVSSProp::GetSnapshots(LPCTSTR pszVolume)
{
    if (!pszVolume || !*pszVolume)
        return E_INVALIDARG;

    FreeSnapshotList(&m_SnapshotList);

    CComPtr<IVssEnumObject> spiEnumSnapshots;
    HRESULT hr = m_spiMgmt->QuerySnapshotsByVolume((PTSTR)pszVolume, VSS_SWPRV_ProviderId, &spiEnumSnapshots);
    if (S_OK == hr)
    {
        VSS_OBJECT_PROP     Prop;
        VSS_SNAPSHOT_PROP*  pSnapProp = &(Prop.Obj.Snap);
        ULONG               ulFetched = 0;
        while (SUCCEEDED(spiEnumSnapshots->Next(1, &Prop, &ulFetched)) && ulFetched > 0)
        {
            if (VSS_OBJECT_SNAPSHOT != Prop.Type)
                return E_FAIL;

            if (pSnapProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE)
            {
                VSSUI_SNAPSHOT *pSnapInfo = (VSSUI_SNAPSHOT *)calloc(1, sizeof(VSSUI_SNAPSHOT));
                if (pSnapInfo)
                {
                    pSnapInfo->idSnapshot = pSnapProp->m_SnapshotId;
                    pSnapInfo->vssTimeStamp = pSnapProp->m_tsCreationTimestamp;
                    m_SnapshotList.push_back(pSnapInfo);
                } else
                {
                    FreeSnapshotList(&m_SnapshotList);
                    hr = E_OUTOFMEMORY;
                }

                VssFreeSnapshotProperties(pSnapProp);

                if (FAILED(hr))
                    break;
            }
        }
    }

    return hr;
}

HRESULT CVSSProp::UpdateSnapshotList()
{
    if (m_strSelectedVolume.IsEmpty())
    {
        m_ctrlSnapshotList.DeleteAllItems();
        m_ctrlDelete.EnableWindow(FALSE);

        return S_OK;
    }

    HRESULT hr = GetSnapshots(m_strSelectedVolume);

    m_ctrlSnapshotList.DeleteAllItems();
    m_ctrlDelete.EnableWindow(FALSE);

    if (SUCCEEDED(hr))
    {
        TCHAR   szTimeStamp[256];
        DWORD   dwSize = 0;
        LVITEM  lvItem = {0};

        for (VSSUI_SNAPSHOT_LIST::iterator i = m_SnapshotList.begin(); i != m_SnapshotList.end(); i++)
        {
            SYSTEMTIME st = {0};
            VssTimeToSystemTime(&((*i)->vssTimeStamp), &st);

            dwSize = sizeof(szTimeStamp)/sizeof(TCHAR);
            SystemTimeToString(&st, szTimeStamp, &dwSize);

            ZeroMemory(&lvItem, sizeof(lvItem));
            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.lParam = (LPARAM)(*i);
            lvItem.pszText = szTimeStamp;
            m_ctrlSnapshotList.InsertItem(&lvItem);
        }

        if (m_SnapshotList.size() > 0)
        {
            HWND hwnd = m_ctrlSnapshotList.m_hWnd;

            if (!m_nSnapshotListCountPerPage)
                m_nSnapshotListCountPerPage = ListView_GetCountPerPage(hwnd);

            if (m_SnapshotList.size() > m_nSnapshotListCountPerPage)
                ListView_SetColumnWidth(hwnd, 0, m_nSnapshotListColumnWidth - m_nScrollbarWidth);
            else
                ListView_SetColumnWidth(hwnd, 0, m_nSnapshotListColumnWidth);
        }
    }

    return hr;
}

//
// If multi-selection: both "Enable" and "Disable" buttons are enabled.
// If single-selection:
// The "Enable" button is disabled whenever there is a schedule.
// The "Disable" button is disabled when no schedule and no diff association.
//
void CVSSProp::UpdateEnableDisableButtons()
{
    int nSelectedCount = m_ctrlVolumeList.GetSelectedCount();

    if (nSelectedCount == 0)
        return;

    if (nSelectedCount > 1)
    {
        m_ctrlEnable.EnableWindow(TRUE);
        m_ctrlDisable.EnableWindow(TRUE);
        return;
    }

    int nIndex = m_ctrlVolumeList.GetNextItem(-1, LVNI_SELECTED);
    if (-1 == nIndex)
        return; // shouldn't happen

    CString strNextRunTime;
    strNextRunTime = m_ctrlVolumeList.GetItemText(nIndex, IDS_VOLUMELIST_COLUMN_NEXTRUNTIME - IDS_VOLUMELIST_COLUMN_VOLUME);
    if (strNextRunTime.CompareNoCase(m_strDisabled))
    {
        // schedule exists
        m_ctrlEnable.EnableWindow(FALSE);
        m_ctrlDisable.EnableWindow(TRUE);
        return;
    }

    // no schedule
    m_ctrlEnable.EnableWindow(TRUE);

    CString strUsed;
    strUsed = m_ctrlVolumeList.GetItemText(nIndex, IDS_VOLUMELIST_COLUMN_USED - IDS_VOLUMELIST_COLUMN_VOLUME);
    m_ctrlDisable.EnableWindow(!strUsed.IsEmpty());
}

void CVSSProp::OnHelpLink(NMHDR* pNMHDR, LRESULT* pResult)
{
    CWaitCursor wait;

    ::HtmlHelp(0, _T("timewarp.chm"), HH_DISPLAY_TOPIC, (DWORD_PTR)(_T("deploy_timewarp_client.htm")));

    *pResult = 0;
}

//
// Q148388 How to Change Default Control Focus on CPropertyPageEx
//
BOOL CVSSProp::OnSetActive()
{
    BOOL fRet = CPropertyPage::OnSetActive();

    if (!m_bHideAllControls)
    {
        PostMessage(WM_SETPAGEFOCUS, 0, 0L);
    }

    return fRet;
}

LRESULT CVSSProp::OnSetPageFocus(WPARAM wParam, LPARAM lParam)
{
    GetDlgItem(IDC_VOLUME_LIST)->SetFocus();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\betest\cwriter.cpp ===
#include "stdafx.hxx"
#include "vss.h"
#include "vswriter.h"
#include "cwriter.h"
#include "debug.h"
#include "time.h"
#include "msxml.h"

#define IID_PPV_ARG( Type, Expr ) IID_##Type, reinterpret_cast< void** >( static_cast< Type** >( Expr ) )
#define SafeQI( Type, Expr ) QueryInterface( IID_PPV_ARG( Type, Expr ) )

static BYTE x_rgbIcon[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
static unsigned x_cbIcon = 10;


static VSS_ID s_WRITERID =
	{
	0xc0577ae6, 0xd741, 0x452a,
	0x8c, 0xba, 0x99, 0xd7, 0x44, 0x00, 0x8c, 0x04
	};

static LPCWSTR s_WRITERNAME = L"BeTest Writer";

void CTestVssWriter::Initialize()
	{
	HRESULT hr;

	CHECK_SUCCESS(CVssWriter::Initialize
					(
					s_WRITERID,
					s_WRITERNAME,
					VSS_UT_USERDATA,
					VSS_ST_OTHER
					));
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
	{
	HRESULT hr;

	if (m_lWait & x_maskWaitGatherWriterMetadata)
		{
		wprintf(L"OnIdentify sleeping 20 seconds.\n");
		Sleep(20000);
		}

	CHECK_SUCCESS(pMetadata->AddIncludeFiles
					(
					L"%systemroot%\\config",
					L"mytestfiles.*",
					false,
					NULL
					));

    CHECK_SUCCESS(pMetadata->AddExcludeFiles
						(
						L"%systemroot%\\config",
						L"*.tmp",
						true
						));

    CHECK_SUCCESS(pMetadata->AddComponent
						(
						VSS_CT_DATABASE,
						L"\\mydatabases",
						L"db1",
						L"this is my main database",
						x_rgbIcon,
						x_cbIcon,
						true,
						true,
						true
						));

    CHECK_SUCCESS(pMetadata->AddDatabaseFiles
					(
					L"\\mydatabases",
					L"db1",
					L"e:\\databases",
					L"foo.db"
					));

    CHECK_SUCCESS(pMetadata->AddDatabaseLogFiles
					(
					L"\\mydatabases",
					L"db1",
					L"e:\\logs",
					L"foo.log"
					));

    CHECK_SUCCESS(pMetadata->SetRestoreMethod
					(
					VSS_RME_RESTORE_IF_NOT_THERE,
					NULL,
					NULL,
					VSS_WRE_ALWAYS,
					true
					));

    CHECK_SUCCESS(pMetadata->AddAlternateLocationMapping
					(
					L"c:\\databases",
					L"*.db",
					false,
					L"e:\\databases\\restore"
					));

    CHECK_SUCCESS(pMetadata->AddAlternateLocationMapping
					(
					L"d:\\logs",
					L"*.log",
					false,
					L"e:\\databases\\restore"
					));


	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPrepareBackup(IN IVssWriterComponents *pWriterComponents)
	{
	unsigned cComponents;
	LPCWSTR wszBackupType;

	if (m_lWait & x_maskWaitPrepareBackup)
		{
		wprintf(L"OnPrepareBackup sleeping 10 seconds.\n");
		Sleep(10000);
		}

	switch(GetBackupType())
		{
		default:
			wszBackupType = L"undefined";
			break;

		case VSS_BT_FULL:
			wszBackupType = L"full";
			break;

        case VSS_BT_INCREMENTAL:
			wszBackupType = L"incremental";
			break;

        case VSS_BT_DIFFERENTIAL:
			wszBackupType = L"differential";
			break;

        case VSS_BT_OTHER:
			wszBackupType = L"other";
			break;
		}

	wprintf(L"\n\n****WRITER*****\nBackup Type = %s\n", wszBackupType);

	wprintf
		(
		L"AreComponentsSelected = %s\n",
		AreComponentsSelected() ? L"yes" : L"no"
		);

	wprintf
		(
		L"BootableSystemStateBackup = %s\n\n",
		IsBootableSystemStateBackedUp() ? L"yes" : L"no"
		);

	pWriterComponents->GetComponentCount(&cComponents);
	for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
		HRESULT hr;

		CComPtr<IVssComponent> pComponent;
		VSS_COMPONENT_TYPE ct;
		CComBSTR bstrLogicalPath;
		CComBSTR bstrComponentName;


		CHECK_SUCCESS(pWriterComponents->GetComponent(iComponent, &pComponent));
		CHECK_SUCCESS(pComponent->GetLogicalPath(&bstrLogicalPath));
		CHECK_SUCCESS(pComponent->GetComponentType(&ct));
		CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
		if (ct != VSS_CT_DATABASE)
			{
			wprintf(L"component type is incorrect\n");
			DebugBreak();
			}

		wprintf
			(
			L"Backing up database %s\\%s.\n",
			bstrLogicalPath,
			bstrComponentName
			);

		WCHAR buf[100];
		wsprintf (buf, L"backupTime = %d", (INT) time(NULL));

		CHECK_SUCCESS(pComponent->SetBackupMetadata(buf));
		wprintf(L"\nBACKUPMETADATA=%s\n", buf);
		}

	wprintf(L"\n******END WRITER******\n\n");
	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPrepareSnapshot()
	{
	IsPathAffected(L"e:\\foobar");
	return true;
	}


bool STDMETHODCALLTYPE CTestVssWriter::OnFreeze()
	{
	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnThaw()
	{
	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnBackupComplete(IN IVssWriterComponents *pWriterComponents)
	{
	if (m_lWait & x_maskWaitBackupComplete)
		{
		wprintf(L"OnBackupComplete sleeping 10 seconds.\n");
		Sleep(20000);
		}

	unsigned cComponents;
	pWriterComponents->GetComponentCount(&cComponents);
	for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
		HRESULT hr;

		CComPtr<IVssComponent> pComponent;
		VSS_COMPONENT_TYPE ct;
		CComBSTR bstrLogicalPath;
		CComBSTR bstrComponentName;
		bool bBackupSucceeded;

		CHECK_SUCCESS(pWriterComponents->GetComponent(iComponent, &pComponent));
		CHECK_SUCCESS(pComponent->GetLogicalPath(&bstrLogicalPath));
		CHECK_SUCCESS(pComponent->GetComponentType(&ct));
		CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
		CHECK_SUCCESS(pComponent->GetBackupSucceeded(&bBackupSucceeded));
		if (ct != VSS_CT_DATABASE)
			{
			wprintf(L"component type is incorrect\n");
			DebugBreak();
			}

		wprintf
			(
			L"Database %s\\%s backup %s.\n",
			bstrLogicalPath,
			bstrComponentName,
			bBackupSucceeded ? L"succeeded" : L"failed"
			);

		CComBSTR bstrMetadata;
		CHECK_SUCCESS(pComponent->GetBackupMetadata(&bstrMetadata));
		wprintf(L"BACKUPMETADATA=%s\n", bstrMetadata);
		}

	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPreRestore(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);

	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPostRestore(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);

	if (m_lWait & x_maskWaitPostRestore)
		{
		wprintf(L"OnPostRestore sleeping 10 seconds.\n");
		Sleep(10000);
		}

	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnAbort()
	{
	return true;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\betest\debug.h ===
// Execute the given call and check that the return code must be S_OK
#define CHECK_SUCCESS( Call )                                                                           \
    {                                                                                                   \
        hr = Call;                                                                                    \
        if (hr != S_OK)                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }

#define CHECK_NOFAIL( Call )                                                                            \
    {                                                                                                   \
        hr = Call;                                                                                    \
        if (FAILED(hr))                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }



void Error(INT nReturnCode, const WCHAR* pwszMsgFormat, ...);
LPCWSTR GetStringFromFailureType(HRESULT hrStatus);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\betest\cwriter.h ===
//
//  ATL debugging support turned on at debug version
//  BUGBUG: the ATL thunking support is not enable yet in IA64
//  When this will be enabled then enable it here also!
//
#ifdef _DEBUG
#ifdef _M_IX86
#define _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_QI
#define _ATL_DEBUG_REFCOUNT
#endif
#endif // _DEBUG

class CTestVssWriter : public CVssWriter
	{
public:
	CTestVssWriter(LONG lWait) : m_lWait(lWait)
		{
		}

	void Initialize();

	virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

	virtual bool STDMETHODCALLTYPE OnPrepareBackup(IN IVssWriterComponents *pComponent);

	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

	virtual bool STDMETHODCALLTYPE OnFreeze();

	virtual bool STDMETHODCALLTYPE OnThaw();

	virtual bool STDMETHODCALLTYPE OnAbort();

	virtual bool STDMETHODCALLTYPE OnBackupComplete(IN IVssWriterComponents *pComponent);

	virtual bool STDMETHODCALLTYPE OnPreRestore(IN IVssWriterComponents *pComponent);
	
	virtual bool STDMETHODCALLTYPE OnPostRestore(IN IVssWriterComponents *pComponent);
private:
	enum
		{
		x_maskWaitGatherWriterMetadata = 1,
		x_maskWaitPrepareBackup = 2,
		x_maskWaitBackupComplete=4,
		x_maskWaitPostRestore=8
		};

	LONG m_lWait;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\betest\debug.cpp ===
#include "stdafx.hxx"
#include "vss.h"
#include "vswriter.h"
#include "vsbackup.h"
#include <debug.h>
#include <cwriter.h>
#include <lmshare.h>
#include <lmaccess.h>


LPCWSTR GetStringFromFailureType(HRESULT hrStatus)
{
    LPCWSTR pwszFailureType = L"";

    switch (hrStatus)
	{
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:        pwszFailureType = L"VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT";    break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:              pwszFailureType = L"VSS_E_WRITERERROR_OUTOFRESOURCES";          break;
	case VSS_E_WRITERERROR_TIMEOUT:                     pwszFailureType = L"VSS_E_WRITERERROR_TIMEOUT";                 break;
	case VSS_E_WRITERERROR_NONRETRYABLE:                pwszFailureType = L"VSS_E_WRITERERROR_NONRETRYABLE";            break;
	case VSS_E_WRITERERROR_RETRYABLE:                   pwszFailureType = L"VSS_E_WRITERERROR_RETRYABLE";               break;
	case VSS_E_BAD_STATE:                               pwszFailureType = L"VSS_E_BAD_STATE";                           break;
	case VSS_E_PROVIDER_ALREADY_REGISTERED:             pwszFailureType = L"VSS_E_PROVIDER_ALREADY_REGISTERED";         break;
	case VSS_E_PROVIDER_NOT_REGISTERED:                 pwszFailureType = L"VSS_E_PROVIDER_NOT_REGISTERED";             break;
	case VSS_E_PROVIDER_VETO:                           pwszFailureType = L"VSS_E_PROVIDER_VETO";                       break;
	case VSS_E_PROVIDER_IN_USE:				            pwszFailureType = L"VSS_E_PROVIDER_IN_USE";                     break;
	case VSS_E_OBJECT_NOT_FOUND:						pwszFailureType = L"VSS_E_OBJECT_NOT_FOUND";                    break;						
	case VSS_S_ASYNC_PENDING:							pwszFailureType = L"VSS_S_ASYNC_PENDING";                       break;
	case VSS_S_ASYNC_FINISHED:						    pwszFailureType = L"VSS_S_ASYNC_FINISHED";                      break;
	case VSS_S_ASYNC_CANCELLED:						    pwszFailureType = L"VSS_S_ASYNC_CANCELLED";                     break;
	case VSS_E_VOLUME_NOT_SUPPORTED:					pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED";                break;
	case VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER:		pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER";    break;
	case VSS_E_OBJECT_ALREADY_EXISTS:					pwszFailureType = L"VSS_E_OBJECT_ALREADY_EXISTS";               break;
	case VSS_E_UNEXPECTED_PROVIDER_ERROR:				pwszFailureType = L"VSS_E_UNEXPECTED_PROVIDER_ERROR";           break;
	case VSS_E_CORRUPT_XML_DOCUMENT:				    pwszFailureType = L"VSS_E_CORRUPT_XML_DOCUMENT";                break;
	case VSS_E_INVALID_XML_DOCUMENT:					pwszFailureType = L"VSS_E_INVALID_XML_DOCUMENT";                break;
	case VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED:       pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED";   break;
	case VSS_E_FLUSH_WRITES_TIMEOUT:                    pwszFailureType = L"VSS_E_FLUSH_WRITES_TIMEOUT";                break;
	case VSS_E_HOLD_WRITES_TIMEOUT:                     pwszFailureType = L"VSS_E_HOLD_WRITES_TIMEOUT";                 break;
	case VSS_E_UNEXPECTED_WRITER_ERROR:                 pwszFailureType = L"VSS_E_UNEXPECTED_WRITER_ERROR";             break;
	case VSS_E_SNAPSHOT_SET_IN_PROGRESS:                pwszFailureType = L"VSS_E_SNAPSHOT_SET_IN_PROGRESS";            break;
	case VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED:     pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED"; break;
	case VSS_E_WRITER_INFRASTRUCTURE:	 		        pwszFailureType = L"VSS_E_WRITER_INFRASTRUCTURE";               break;
	case VSS_E_WRITER_NOT_RESPONDING:			        pwszFailureType = L"VSS_E_WRITER_NOT_RESPONDING";               break;
    case VSS_E_WRITER_ALREADY_SUBSCRIBED:		        pwszFailureType = L"VSS_E_WRITER_ALREADY_SUBSCRIBED";           break;
	
	case NOERROR:
	default:
	    break;
	}

    return (pwszFailureType);
}


// This function displays the formatted message at the console and throws
// The passed return code will be returned by vsreq.exe
void Error(
    IN  INT nReturnCode,
    IN  const WCHAR* pwszMsgFormat,
    IN  ...
    )
{
    va_list marker;
    va_start( marker, pwszMsgFormat );
    vwprintf( pwszMsgFormat, marker );
    va_end( marker );

	BS_ASSERT(FALSE);
    // throw that return code.
    throw(nReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\dep_demo\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dep_demo.rc
//
#define IDS_PROJNAME                    100
#define IDR_Writer_1                    100
#define IDR_DSSSNAPSHOTWRITER           101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\dep_demo\dep_demo.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module dep_demo.cpp | header of Dependency demo
    @end

Author:

    Adi Oltean  [aoltean]  09/17/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/17/1999  Created

--*/


#ifndef __DEP_DEMO_H_	
#define __DEP_DEMO_H_


/////////////////////////////////////////////////////////////////////////////
//  Defines and pragmas

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>
#include <comadmin.h>

#include "vs_assert.hxx"

// ATL
#include <atlconv.h>
#include <atlbase.h>

// Application specific
#include "vs_inc.hxx"

// Generated MIDL headers
#include "vss.h"
#include "vscoordint.h"


#endif //__DEP_DEMO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\betest\main.cpp ===
#include "stdafx.hxx"
#include "vs_idl.hxx"
#include "vswriter.h"
#include "vsbackup.h"
#include <debug.h>
#include <cwriter.h>
#include <lmshare.h>
#include <lmaccess.h>
#include <time.h>

BOOL AssertPrivilege( LPCWSTR privName )
    {
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if ( OpenProcessToken (GetCurrentProcess(),
               TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,
               &tokenHandle))
    {
    LUID value;

    if ( LookupPrivilegeValue( NULL, privName, &value ) )
        {
        TOKEN_PRIVILEGES newState;
        DWORD            error;

        newState.PrivilegeCount           = 1;
        newState.Privileges[0].Luid       = value;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED;

        /*
         * We will always call GetLastError below, so clear
         * any prior error values on this thread.
         */
        SetLastError( ERROR_SUCCESS );

        stat = AdjustTokenPrivileges (tokenHandle,
                      FALSE,
                      &newState,
                      (DWORD)0,
                      NULL,
                      NULL );

        /*
         * Supposedly, AdjustTokenPriveleges always returns TRUE
         * (even when it fails). So, call GetLastError to be
         * extra sure everything's cool.
         */
        if ( (error = GetLastError()) != ERROR_SUCCESS )
        {
        stat = FALSE;
        }

        if ( !stat )
        {
        wprintf( L"AdjustTokenPrivileges for %s failed with %d",
             privName,
             error );
        }
        }

    DWORD cbTokens;
    GetTokenInformation (tokenHandle,
                 TokenPrivileges,
                 NULL,
                 0,
                 &cbTokens);

    TOKEN_PRIVILEGES *pTokens = (TOKEN_PRIVILEGES *) new BYTE[cbTokens];
    GetTokenInformation (tokenHandle,
                 TokenPrivileges,
                 pTokens,
                 cbTokens,
                 &cbTokens);

    delete pTokens;
    CloseHandle( tokenHandle );
    }


    return stat;
    }


LPCWSTR GetStringFromUsageType (VSS_USAGE_TYPE eUsageType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eUsageType)
    {
    case VSS_UT_BOOTABLESYSTEMSTATE: pwszRetString = L"BootableSystemState"; break;
    case VSS_UT_SYSTEMSERVICE:       pwszRetString = L"SystemService";       break;
    case VSS_UT_USERDATA:            pwszRetString = L"UserData";            break;
    case VSS_UT_OTHER:               pwszRetString = L"Other";               break;
                    
    default:
        break;
    }


    return (pwszRetString);
    }


LPCWSTR GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eSourceType)
    {
    case VSS_ST_TRANSACTEDDB:    pwszRetString = L"TransactionDb";    break;
    case VSS_ST_NONTRANSACTEDDB: pwszRetString = L"NonTransactionDb"; break;
    case VSS_ST_OTHER:           pwszRetString = L"Other";            break;

    default:
        break;
    }


    return (pwszRetString);
    }


LPCWSTR GetStringFromRestoreMethod (VSS_RESTOREMETHOD_ENUM eRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eRestoreMethod)
    {
    case VSS_RME_RESTORE_IF_NOT_THERE:          pwszRetString = L"RestoreIfNotThere";          break;
    case VSS_RME_RESTORE_IF_CAN_REPLACE:        pwszRetString = L"RestoreIfCanReplace";        break;
    case VSS_RME_STOP_RESTORE_START:            pwszRetString = L"StopRestoreStart";           break;
    case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION: pwszRetString = L"RestoreToAlternateLocation"; break;
    case VSS_RME_RESTORE_AT_REBOOT:             pwszRetString = L"RestoreAtReboot";            break;
    case VSS_RME_CUSTOM:                        pwszRetString = L"Custom";                     break;

    default:
        break;
    }


    return (pwszRetString);
    }


LPCWSTR GetStringFromWriterRestoreMethod (VSS_WRITERRESTORE_ENUM eWriterRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eWriterRestoreMethod)
    {
    case VSS_WRE_NEVER:            pwszRetString = L"RestoreNever";           break;
    case VSS_WRE_IF_REPLACE_FAILS: pwszRetString = L"RestoreIfReplaceFailsI"; break;
    case VSS_WRE_ALWAYS:           pwszRetString = L"RestoreAlways";          break;

    default:
        break;
    }


    return (pwszRetString);
    }


LPCWSTR GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eComponentType)
    {
    case VSS_CT_DATABASE:  pwszRetString = L"Database";  break;
    case VSS_CT_FILEGROUP: pwszRetString = L"FileGroup"; break;

    default:
        break;
    }


    return (pwszRetString);
    }




void PrintFiledesc(IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription)
    {
    CComBSTR bstrPath;
    CComBSTR bstrFilespec;
    CComBSTR bstrAlternate;
    CComBSTR bstrDestination;
    bool bRecursive;
    HRESULT hr;

    CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
    CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
    CHECK_NOFAIL(pFiledesc->GetRecursive(&bRecursive));
    CHECK_NOFAIL(pFiledesc->GetAlternateLocation(&bstrAlternate));
    CHECK_NOFAIL(pFiledesc->GetAlternateLocation(&bstrDestination));

    wprintf (L"%s\n            Path = %s, Filespec = %s, Recursive = %s\n",
         wszDescription,
         bstrPath,
         bstrFilespec,
         bRecursive ? L"yes" : L"no");

    if (bstrAlternate && wcslen(bstrAlternate) > 0)
    wprintf(L"            Alternate Location = %s\n", bstrAlternate);

    if (bstrDestination && wcslen(bstrDestination) > 0)
    wprintf(L"            Destination Location = %s\n", bstrDestination);
    }


/*
void AddShares(IVssSnapshot **rgpSnapshot, UINT cSnapshot)
    {
    VSS_PWSZ wszDeviceName = NULL;

    try
        {
        for(UINT iSnapshot = 0; iSnapshot < cSnapshot; iSnapshot++)
            {
            SHARE_INFO_502 info;
            CHECK_SUCCESS(rgpSnapshot[iSnapshot]->GetDevice(&wszDeviceName));
            WCHAR *wszPath = new WCHAR[wcslen(wszDeviceName) + 2];
            if (wszPath != NULL)
                {
                wcscpy(wszPath, wszDeviceName);
                wcscat(wszPath, L"\\");
                memset(&info, 0, sizeof(info));
                WCHAR wszName[20];
                swprintf(wszName, L"Snapshot%d", iSnapshot);

                info.shi502_netname = wszName;
                info.shi502_type = STYPE_DISKTREE;
                info.shi502_permissions = ACCESS_READ;
                info.shi502_max_uses = 10;
                info.shi502_path = wszDeviceName;

                NET_API_STATUS status;
                DWORD parm_err;

                status = NetShareAdd(NULL, 502, (LPBYTE) &info, &parm_err);
                }

            CoTaskMemFree(wszDeviceName);
            wszDeviceName = NULL;
            }
        }
    catch(...)
        {
        }

    if (wszDeviceName)
        CoTaskMemFree(wszDeviceName);

    }

*/




void DoAddToSnapshotSet
    (
    IN IVssBackupComponents *pvbc,
    IN BSTR bstrPath,
    IN LPWSTR wszVolumes,
    OUT VSS_ID * rgpSnapshotId,
    UINT *pcSnapshot
    )
    {
    PWCHAR  pwszPath           = NULL;
    PWCHAR  pwszMountPointName = NULL;
    WCHAR   wszVolumeName [50];
    ULONG   ulPathLength;
    ULONG   ulMountpointBufferLength;
    HRESULT hr;


    ulPathLength = ExpandEnvironmentStringsW (bstrPath, NULL, 0);

    pwszPath = (PWCHAR) malloc (ulPathLength * sizeof (WCHAR));

    ulPathLength = ExpandEnvironmentStringsW (bstrPath, pwszPath, ulPathLength);


    ulMountpointBufferLength = GetFullPathName (pwszPath, 0, NULL, NULL);

    pwszMountPointName = (PWCHAR) malloc (ulMountpointBufferLength * sizeof (WCHAR));

    bool fSuccess = false;
    if (wcslen(pwszPath) >= 3 && pwszPath[1] == L':' && pwszPath[2] == L'\\')
        {
        wcsncpy(pwszMountPointName, pwszPath, 3);
        pwszMountPointName[3] = L'\0';
        fSuccess = true;
        }
    else
        {
        if (GetVolumePathNameW (pwszPath, pwszMountPointName, ulMountpointBufferLength))
            fSuccess = true;
        else
            printf("GetVolumeMountPointW failed with error %d\npath=%s\n", GetLastError(), pwszPath);
        }

    if (fSuccess)
        {
        if (!GetVolumeNameForVolumeMountPointW (pwszMountPointName, wszVolumeName, sizeof (wszVolumeName) / sizeof (WCHAR)))
                printf("GetVolumeNameForVolumeMountPointW failed with error %d", GetLastError());
        else
            {
            if (NULL == wcsstr (wszVolumes, wszVolumeName))
                {
                if (L'\0' != wszVolumes [0])
                    wcscat (wszVolumes, L";");

                wcscat (wszVolumes, wszVolumeName);

                CHECK_SUCCESS
                    (
                    pvbc->AddToSnapshotSet
                        (
                        wszVolumeName,
                        GUID_NULL,
                        &rgpSnapshotId[*pcSnapshot]
                        )
                    );

                *pcSnapshot += 1;
                }
            }
        }

    if (NULL != pwszPath)           free (pwszPath);
    if (NULL != pwszMountPointName) free (pwszMountPointName);
    }

static LPCWSTR s_rgwszStates[] =
    {
    NULL,
    L"STABLE",
    L"WAIT_FOR_FREEZE",
    L"WAIT_FOR_THAW",
    L"WAIT_FOR_POST_SNAPSHOT",
    L"WAIT_FOR_BACKUP_COMPLETE",
    L"FAILED_AT_IDENTIFY",
    L"FAILED_AT_PREPARE_BACKUP",
    L"FAILED_AT_PREPARE_SNAPSHOT",
    L"FAILED_AT_FREEZE",
    L"FAILED_AT_THAW",
    L"FAILED_AT_BACKUP_COMPLETE",
    L"FAILED_AT_PRE_RESTORE",
    L"FAILED_AT_POST_RESTORE"
    };

void CheckStatus(IVssBackupComponents *pvbc, LPCWSTR wszWhen)
    {
    unsigned cWriters;
    CComPtr<IVssAsync> pAsync;
    HRESULT hr;
    HRESULT hrResult;


    CHECK_NOFAIL(pvbc->GatherWriterStatus(&pAsync));
    CHECK_NOFAIL(pAsync->Wait());
    CHECK_SUCCESS(pAsync->QueryStatus(&hrResult, NULL));
    CHECK_NOFAIL(hrResult);

    CHECK_NOFAIL(pvbc->GetWriterStatusCount(&cWriters));


    wprintf(L"\n\nstatus %s (%d writers)\n\n", wszWhen, cWriters);

    for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
    {
    VSS_ID idInstance;
    VSS_ID idWriter;
    VSS_WRITER_STATE status;
    CComBSTR bstrWriter;
    HRESULT hrWriterFailure;

    CHECK_SUCCESS(pvbc->GetWriterStatus (iWriter,
                         &idInstance,
                         &idWriter,
                         &bstrWriter,
                         &status,
                         &hrWriterFailure));

    wprintf (L"Status for writer %s: %s(0x%08lx%s%s)\n",
         bstrWriter,
         s_rgwszStates[status],
         hrWriterFailure,
         SUCCEEDED (hrWriterFailure) ? L"" : L" - ",
         GetStringFromFailureType (hrWriterFailure));
        }

    pvbc->FreeWriterStatus();
    }

// wait a maximum number of seconds before cancelling the operation
void LoopWait
    (
    IVssAsync *pAsync,
    LONG seconds,
    LPCWSTR wszOperation
    )
    {
    clock_t start = clock();
    HRESULT hr, hrStatus;
    while(TRUE)
        {
        Sleep(1000);
        CHECK_SUCCESS(pAsync->QueryStatus(&hrStatus, NULL));
        if (hrStatus != VSS_S_ASYNC_PENDING)
            break;

        if (((clock() - start)/CLOCKS_PER_SEC) >= seconds)
            break;
        }

    if (hrStatus == VSS_S_ASYNC_PENDING)
        {
        CHECK_NOFAIL(pAsync->Cancel());
        wprintf(L"Called cancelled for %s.\n", wszOperation);
        }

    CHECK_SUCCESS(pAsync->QueryStatus(&hrStatus, NULL));
    CHECK_NOFAIL(hrStatus);
    }


extern "C" __cdecl wmain(int argc, WCHAR **argv)
    {
    WCHAR wszVolumes[2048];
    wszVolumes[0] = L'\0';

    UINT cSnapshot = 0;
    VSS_ID rgpSnapshotId[64];

    CTestVssWriter *pInstance = NULL;
    bool bCreated = false;
    bool bSubscribed = false;
    HRESULT hr = S_OK;
    bool bCoInitializeSucceeded = false;


    try
    {
    HRESULT hr;
    CComBSTR bstrXML;
    CComBSTR bstrXMLOut;
    LONG lWait = 0;

    if (argc == 2 &&
        wcslen(argv[1]) == 3 &&
        argv[1][0] == L'-' &&
        argv[1][1] == L'w' &&
        (argv[1][2] >= L'0' && argv[1][2] <= L'9'||
         argv[1][2] >= L'a' && argv[1][2] <= L'f'))
         {
         if (argv[1][2] >= L'0' && argv[1][2] <= L'9')
             lWait = argv[1][2] - L'0';
         else
             lWait = argv[1][2] - L'a' + 10;

         wprintf(L"wait parameter=%d.\n", lWait);
         }
        


    CHECK_SUCCESS(CoInitializeEx(NULL, COINIT_MULTITHREADED));

    CComPtr<IGlobalOptions> ptrIGLB;
    CHECK_SUCCESS( ptrIGLB.CoCreateInstance(CLSID_GlobalOptions) );
    CHECK_SUCCESS( ptrIGLB->Set(COMGLB_EXCEPTION_HANDLING, COMGLB_EXCEPTION_DONOT_HANDLE));

    // Initialize COM security
    CHECK_SUCCESS
        (
        CoInitializeSecurity
            (
            NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
            -1,                                  //  IN LONG                         cAuthSvc,
            NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
            NULL,                                //  IN void                        *pReserved1,
            RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
            RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
            NULL,                                //  IN void                        *pAuthList,
            EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
            NULL                                 //  IN void                        *pReserved3
            )
        );

    bCoInitializeSucceeded = true;

    if ( !AssertPrivilege( SE_BACKUP_NAME ) )
        {
        wprintf( L"AssertPrivilege returned error, rc:%d\n", GetLastError() );
        return 2;
        }

    pInstance = new CTestVssWriter(lWait);
    if (pInstance == NULL)
        {
        wprintf(L"allocation failure\n");
        DebugBreak();
        }

    bCreated = true;
    pInstance->Initialize();
    CHECK_SUCCESS(pInstance->Subscribe());
    bSubscribed = true;

    CComBSTR strSnapshotSetId = "12345678-1234-1234-1234-1234567890ab";

    CComPtr<IVssBackupComponents> pvbc;

    CHECK_SUCCESS(CreateVssBackupComponents(&pvbc));


    CHECK_SUCCESS(pvbc->InitializeForBackup());
    CHECK_SUCCESS(pvbc->SetBackupState (true,
                        false,
                        VSS_BT_FULL));

    unsigned cWriters;
    CComPtr<IVssAsync> pAsync;
    CHECK_NOFAIL(pvbc->GatherWriterMetadata(&pAsync));

    LoopWait(pAsync, 15, L"GatherWriterMetadata");

    CHECK_NOFAIL(pvbc->GetWriterMetadataCount(&cWriters));

    VSS_ID id;

    while(TRUE)
        {
        hr = pvbc->StartSnapshotSet(&id);
        if (hr == S_OK)
            break;

        if (hr == VSS_E_SNAPSHOT_SET_IN_PROGRESS)
            Sleep(1000);
        else
            CHECK_SUCCESS(hr);
        }

    for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
        {
        CComPtr<IVssExamineWriterMetadata> pMetadata;
        VSS_ID idInstance;

        CHECK_SUCCESS(pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata));
        VSS_ID idInstanceT;
        VSS_ID idWriter;
        CComBSTR bstrWriterName;
        VSS_USAGE_TYPE usage;
        VSS_SOURCE_TYPE source;

        CHECK_SUCCESS(pMetadata->GetIdentity (&idInstanceT,
                          &idWriter,
                          &bstrWriterName,
                          &usage,
                          &source));

        wprintf (L"\n\n");

            if (memcmp(&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
        {
        wprintf(L"Instance id mismatch\n");
        DebugBreak();
        }

        WCHAR *pwszInstanceId;
        WCHAR *pwszWriterId;
        UuidToString(&idInstance, &pwszInstanceId);
        UuidToString(&idWriter, &pwszWriterId);
        wprintf (L"WriterName = %s\n\n"
             L"    WriterId   = %s\n"
             L"    InstanceId = %s\n"
             L"    UsageType  = %d (%s)\n"
             L"    SourceType = %d (%s)\n",
             bstrWriterName,
             pwszWriterId,
             pwszInstanceId,
             usage,
             GetStringFromUsageType (usage),
             source,
             GetStringFromSourceType (source));

        RpcStringFree(&pwszInstanceId);
        RpcStringFree(&pwszWriterId);

        unsigned cIncludeFiles, cExcludeFiles, cComponents;
        CHECK_SUCCESS(pMetadata->GetFileCounts (&cIncludeFiles,
                            &cExcludeFiles,
                            &cComponents));

        CComBSTR bstrPath;
        CComBSTR bstrFilespec;
        CComBSTR bstrAlternate;
        CComBSTR bstrDestination;

        for(unsigned i = 0; i < cIncludeFiles; i++)
        {
        CComPtr<IVssWMFiledesc> pFiledesc;
        CHECK_SUCCESS(pMetadata->GetIncludeFile(i, &pFiledesc));

        PrintFiledesc(pFiledesc, L"\n    Include File");
        }

        for(i = 0; i < cExcludeFiles; i++)
        {
        CComPtr<IVssWMFiledesc> pFiledesc;
        CHECK_SUCCESS(pMetadata->GetExcludeFile(i, &pFiledesc));
        PrintFiledesc(pFiledesc, L"\n    Exclude File");
        }

        for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
        {
        CComPtr<IVssWMComponent> pComponent;
        PVSSCOMPONENTINFO pInfo;
        CHECK_SUCCESS(pMetadata->GetComponent(iComponent, &pComponent));
        CHECK_SUCCESS(pComponent->GetComponentInfo(&pInfo));
        wprintf (L"\n"
             L"    Component %d, type = %d (%s)\n"
             L"        LogicalPath = %s\n"
             L"        Name        = %s\n"
             L"        Caption     = %s\n"
             L"        Icon size   = %u\n",
             iComponent,
             pInfo->type,
             GetStringFromComponentType (pInfo->type),
             pInfo->bstrLogicalPath,
             pInfo->bstrComponentName,
             pInfo->bstrCaption,
             pInfo->cbIcon );

        wprintf (L"        RestoreMetadata        = %s\n"
             L"        NotifyOnBackupComplete = %s\n"
             L"        Selectable             = %s\n",
             pInfo->bRestoreMetadata        ? L"yes" : L"no",
             pInfo->bNotifyOnBackupComplete ? L"yes" : L"no",
             pInfo->bSelectable             ? L"yes" : L"no");



        CHECK_SUCCESS(pvbc->AddComponent (idInstance,
                          idWriter,
                          pInfo->type,
                          pInfo->bstrLogicalPath,
                          pInfo->bstrComponentName));


        if (pInfo->cFileCount > 0)
            {
            for(i = 0; i < pInfo->cFileCount; i++)
            {
            CComPtr<IVssWMFiledesc> pFiledesc;
            CHECK_SUCCESS(pComponent->GetFile(i, &pFiledesc));

            CComBSTR bstrPath;
            CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
            DoAddToSnapshotSet(pvbc, bstrPath, wszVolumes, rgpSnapshotId, &cSnapshot);

            PrintFiledesc(pFiledesc, L"        FileGroupFile");
            }
            }

        if (pInfo->cDatabases > 0)
            {
            for(i = 0; i < pInfo->cDatabases; i++)
            {
            CComPtr<IVssWMFiledesc> pFiledesc;
            CHECK_SUCCESS(pComponent->GetDatabaseFile(i, &pFiledesc));

            CComBSTR bstrPath;
            CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
            DoAddToSnapshotSet(pvbc, bstrPath, wszVolumes, rgpSnapshotId, &cSnapshot);
            PrintFiledesc(pFiledesc, L"        DatabaseFile");
            }
            }

        if (pInfo->cLogFiles > 0)
            {
            for(i = 0; i < pInfo->cLogFiles; i++)
            {
            CComPtr<IVssWMFiledesc> pFiledesc;
            CHECK_SUCCESS(pComponent->GetDatabaseLogFile(i, &pFiledesc));

            CComBSTR bstrPath;
            CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
            DoAddToSnapshotSet(pvbc, bstrPath, wszVolumes, rgpSnapshotId, &cSnapshot);
            PrintFiledesc(pFiledesc, L"        DatabaseLogFile");
            }
            }

        pComponent->FreeComponentInfo(pInfo);
        }

        VSS_RESTOREMETHOD_ENUM method;
        CComBSTR bstrUserProcedure;
        CComBSTR bstrService;
        VSS_WRITERRESTORE_ENUM writerRestore;
        unsigned cMappings;
        bool bRebootRequired;

        CHECK_NOFAIL(pMetadata->GetRestoreMethod (&method,
                              &bstrService,
                              &bstrUserProcedure,
                              &writerRestore,
                              &bRebootRequired,
                              &cMappings));


        wprintf (L"\n"
             L"    Restore method = %d (%s)\n"
             L"    Service        = %s\n"
             L"    User Procedure = %s\n"
             L"    WriterRestore  = %d (%s)\n"
             L"    RebootRequired = %s\n",
             method,
             GetStringFromRestoreMethod (method),
             bstrService,
             bstrUserProcedure,
             writerRestore,
             GetStringFromWriterRestoreMethod (writerRestore),
             bRebootRequired ? L"yes" : L"no");

        for(i = 0; i < cMappings; i++)
        {
        CComPtr<IVssWMFiledesc> pFiledesc;

        CHECK_SUCCESS(pMetadata->GetAlternateLocationMapping(i, &pFiledesc));

        PrintFiledesc(pFiledesc, L"AlternateMapping");
        }
    
        CComBSTR bstrMetadata;
        CHECK_SUCCESS(pMetadata->SaveAsXML(&bstrMetadata));
        CComPtr<IVssExamineWriterMetadata> pMetadataNew;
        CHECK_SUCCESS(CreateVssExamineWriterMetadata(bstrMetadata, &pMetadataNew));
        CHECK_SUCCESS(pMetadataNew->GetIdentity (&idInstanceT,
                          &idWriter,
                          &bstrWriterName,
                          &usage,
                          &source));

        wprintf (L"\n\n");

        if (memcmp(&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
            {
            wprintf(L"Instance id mismatch\n");
            DebugBreak();
            }

        UuidToString(&idInstance, &pwszInstanceId);
        UuidToString(&idWriter, &pwszWriterId);
        wprintf (L"WriterName = %s\n\n"
             L"    WriterId   = %s\n"
             L"    InstanceId = %s\n"
             L"    UsageType  = %d (%s)\n"
             L"    SourceType = %d (%s)\n",
             bstrWriterName,
             pwszWriterId,
             pwszInstanceId,
             usage,
             GetStringFromUsageType (usage),
             source,
             GetStringFromSourceType (source));

        RpcStringFree(&pwszInstanceId);
        RpcStringFree(&pwszWriterId);
        }
        

    CHECK_SUCCESS(pvbc->FreeWriterMetadata());

    {
    CComPtr<IVssAsync> pAsync;
    HRESULT hr;

    CHECK_SUCCESS(pvbc->PrepareForBackup(&pAsync));
    LoopWait(pAsync, 5, L"PrepareForBackup");
    }


    CheckStatus(pvbc, L"After Prepare Backup");

    unsigned cWriterComponents;
    CHECK_SUCCESS(pvbc->GetWriterComponentsCount(&cWriterComponents));

    for(iWriter = 0; iWriter < cWriterComponents; iWriter++)
        {
        CComPtr<IVssWriterComponentsExt> pWriter;
        CHECK_SUCCESS(pvbc->GetWriterComponents(iWriter, &pWriter));

        unsigned cComponents;
        CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
        VSS_ID idWriter, idInstance;
        CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));
        for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
        {
        CComPtr<IVssComponent> pComponent;
        CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
                
        VSS_COMPONENT_TYPE ct;
        CComBSTR bstrLogicalPath;
        CComBSTR bstrComponentName;

        CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
        CHECK_SUCCESS(pComponent->GetComponentType(&ct));
        CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
        CHECK_SUCCESS(pvbc->SetBackupSucceeded (idInstance,
                            idWriter,
                            ct,
                            bstrLogicalPath,
                            bstrComponentName,
                            true));
        }
        }


    {
    CComPtr<IVssAsync> pAsync;
    INT nPercentDone;
    CHECK_SUCCESS(pvbc->DoSnapshotSet (&pAsync));


    CHECK_SUCCESS(pAsync->Wait());
    CHECK_SUCCESS(pAsync->QueryStatus(&hr, &nPercentDone));
    }
                            

        if (FAILED(hr))
        {
            wprintf(L"Creating the snapshot failed.  hr = 0x%08lx\n", hr);
        CheckStatus(pvbc, L"After Do Snapshot");
        }
    else
        {
        CheckStatus(pvbc, L"After Do Snapshot");
        CComBSTR bstrXML;
        CComPtr<IVssBackupComponents> pvbcRestore;

        CHECK_SUCCESS(pvbc->SaveAsXML(&bstrXML));
        CHECK_SUCCESS(CreateVssBackupComponents(&pvbcRestore));
        CHECK_SUCCESS(pvbcRestore->InitializeForRestore(bstrXML));
        wprintf(L"InitializeForRestore succeeded.\n");

        LONG lSnapshotsNotDeleted;
        VSS_ID rgSnapshotsNotDeleted[10];
        {
        CComPtr<IVssAsync> pAsync;
        HRESULT hr;

        CHECK_SUCCESS(pvbc->BackupComplete(&pAsync));
        LoopWait(pAsync, 5, L"BackupComplete");
        }

        CheckStatus(pvbc, L"After Backup Complete");
        hr  = pvbc->DeleteSnapshots (id,
                     VSS_OBJECT_SNAPSHOT_SET,
                     false,
                     &lSnapshotsNotDeleted,
                     rgSnapshotsNotDeleted);

        if (FAILED(hr))
            wprintf(L"Deletion of Snapshots failed.  hr = 0x%08lx\n", hr);
        {
        CComPtr<IVssAsync> pAsync;
        HRESULT hr;

        pvbcRestore->GatherWriterMetadata(&pAsync);
        CHECK_SUCCESS(pAsync->Wait());
        CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));

        CHECK_NOFAIL(hr);

        CHECK_SUCCESS(pvbcRestore->GetWriterMetadataCount(&cWriters));
        for(iWriter = 0; iWriter < cWriters; iWriter++)
            {
            CComPtr<IVssExamineWriterMetadata> pMetadata;
            VSS_ID idInstance;
            CHECK_SUCCESS(pvbcRestore->GetWriterMetadata(iWriter, &idInstance, &pMetadata));
            }

        pAsync = NULL;

        pvbcRestore->PostRestore(&pAsync);
        LoopWait(pAsync, 5, L"PostRetore");
        CHECK_NOFAIL(hr);
        }
        }
    }
    catch(...)
    {
    BS_ASSERT(FALSE);
    hr = E_UNEXPECTED;
    }

    if (bSubscribed)
        pInstance->Unsubscribe();

    if (bCreated)
        delete pInstance;

    if (FAILED(hr))
    wprintf(L"Failed with %08x.\n", hr);

    if (bCoInitializeSucceeded)
    CoUninitialize();

    return(0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\dep_demo\dep_demo.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module dep_demo.cpp | Implementation of the Volume Snapshots demo
    @end

Author:

    Adi Oltean  [aoltean]  09/17/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/17/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes

#include "dep_demo.h"


/////////////////////////////////////////////////////////////////////////////
//  Implementation

HRESULT DemoMain()
{
    CVssFunctionTracer ft( VSSDBG_VSSDEMO, L"DemoMain" );

    try
    {
		// Get the Snapshot Service object.
		CComPtr<IVssDependencies> pIDepGraph;
        ft.hr = pIDepGraph.CoCreateInstance( CLSID_VSSDependencies );
        if ( ft.HrFailed() )
            ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"Connection failed with hr = 0x%08lx", ft.hr);

        ft.Msg( L"Creating Dependency Graph instance... OK");

		CComBSTR strResName = L"Resource1";
		CComBSTR strAppInstance = L"APP1";
		CComBSTR strVolumeList = L"C:\\;D:\\";
		CComBSTR strDetails = L"...Description...";
		CComBSTR strResourceId;
		ft.hr = pIDepGraph->AddResource(
			strResName,
			strAppInstance,
			VS_LOCAL_RESOURCE,
			strVolumeList,
			strDetails,
			&strResourceId
			);
		if (ft.HrFailed())
            ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"AddResource failed with hr = 0x%08lx", ft.hr);

		strResName = L"Resource2";
		strAppInstance = L"APP2";
		strVolumeList = L"C:\\;D:\\";
		strDetails = L"...Description...";
		strResourceId;
		ft.hr = pIDepGraph->AddResource(
			strResName,
			strAppInstance,
			VS_LOCAL_RESOURCE,
			strVolumeList,
			strDetails,
			&strResourceId
			);
		if (ft.HrFailed())
            ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"AddResource failed with hr = 0x%08lx", ft.hr);

		strResName = L"Resource1";
		strAppInstance = L"APP1";
		strVolumeList = L"C:\\;D:\\";
		strDetails = L"...Description...";
		strResourceId;
		ft.hr = pIDepGraph->AddResource(
			strResName,
			strAppInstance,
			VS_LOCAL_RESOURCE,
			strVolumeList,
			strDetails,
			&strResourceId
			);
		if (ft.HrFailed())
            ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"AddResource failed with hr = 0x%08lx", ft.hr);

		strResName = L"Resource1";
		strAppInstance = L"APP2";
		strVolumeList = L"C:\\;D:\\";
		strDetails = L"...Description...";
		strResourceId;
		ft.hr = pIDepGraph->AddResource(
			strResName,
			strAppInstance,
			VS_LOCAL_RESOURCE,
			strVolumeList,
			strDetails,
			&strResourceId
			);
		if (ft.HrFailed())
            ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"AddResource failed with hr = 0x%08lx", ft.hr);

		CComBSTR strContext = L"Context1";
		CComBSTR strProcessID;
		HRESULT hrErrorCode;
		CComBSTR strCancelReason;
		INT nMaxDuration = 1000;
		INT nMaxIterations = 1000;
		ft.hr = pIDepGraph->StartDiscoveryProcess(
			strContext,
			&strProcessID,
			&hrErrorCode,
			&strCancelReason,
			nMaxDuration,
			nMaxIterations
			);
		if (ft.HrFailed())
            ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"StartDiscoveryProcess failed with hr = 0x%08lx", ft.hr);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}

extern "C" int WINAPI _tWinMain(HINSTANCE /*hInstance*/, 
    HINSTANCE /*hPrevInstance*/, LPTSTR /*lpCmdLine*/, int /*nShowCmd*/)
{
    CVssFunctionTracer ft( VSSDBG_VSSDEMO, L"_tWinMain" );

    try
    {
		// Initialize COM library
		ft.hr = CoInitialize(NULL);
		if (ft.HrFailed())
			ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"Failure in initializing the COM library 0x%08lx", ft.hr);

		// Run the demo
		ft.hr = DemoMain();

		// Uninitialize COM library
		CoUninitialize();
	}
    VSS_STANDARD_CATCH(ft)

    return ft.HrSucceeded();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\backup\stdafx.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <atlbase.h>
#include <vststtools.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\backup\backup.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    backup.h

Abstract:

    definitions for backup test exe


    Brian Berkowitz  [brianb]  06/02/2000

TBD:
	

Revision History:

    Name        Date        Comments
    brianb      06/02/2000  Created
	brianb		06/12/2000  Added comments

--*/

// options for snapshotting volumes
typedef enum VSTST_BACKUP_VOLUMES
	{
	VSTST_BV_UNDEFINE = 0,
	VSTST_BV_ONE,				// snapshot a single volume during a pass
	VSTST_BV_SOME,				// snasphot several volumes during a pass
	VSTST_BV_ALL				// snapshot all volumes during a pass
	};

// actual implementation of the test
class CVsBackupTest :
	public IVsTstRunningTest,
	public CVsTstClientLogger
	{
public:

	// constructor
	CVsBackupTest();

	// destructor
	~CVsBackupTest();

	// callback to run the test
	HRESULT RunTest
		(
		CVsTstINIConfig *pConfig,		// configuration file
		CVsTstClientMsg *pMsg,			// message pipe
		CVsTstParams *pParams			// command line parameters
		);


	// callback to shutdown the test
	HRESULT ShutdownTest(VSTST_SHUTDOWN_REASON reason)
		{
		UNREFERENCED_PARAMETER(reason);

		m_bTerminateTest = true;
		return S_OK;
		}

private:
	enum
		{
		// max number of volumes this test will deal with
		MAX_VOLUME_COUNT = 2048,

		// maximum number of simultaneous snapshots that this test will deal with
		MAX_SNAPSHOT_SET_COUNT = 128
		};


    // do a single run of the backup test
	void RunBackupTest();

	// obtain state of the writers and validate the state
	bool GetAndValidateWriterState
		(
		IVssBackupComponents *pvbc,
		VSS_WRITER_STATE ws1,
		VSS_WRITER_STATE ws2 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws3 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws4 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws5 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws6 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws7 = VSS_WS_UNKNOWN
		);

	// wait for a response from an asynchronous call.   Cycles controls
	// when a cancel of the asynchronous call is issued.  The writer states
	// are valid states for writers during the asynchronous call
    HRESULT WaitLoop
		(
		IVssBackupComponents *pvbc,
		IVssAsync *pAsync,
		UINT cycles,
		VSS_WRITER_STATE ws1,
		VSS_WRITER_STATE ws2 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws3 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws4 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws5 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws6 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws7 = VSS_WS_UNKNOWN
		);

    // if components are being backed up, indicate that components were
	// successfully backed up
	void SetComponentsSuccessfullyBackedUp(IVssBackupComponents *pvbc);

	// validate metadata obtained by writers and add components to backup
	// components document, if component backup is used
	void GetMetadataAndSetupComponents(IVssBackupComponents *pvbc);

	// add a volume to the snapshot set based on the path
	void DoAddToSnapshotSet
		(
		IN IVssBackupComponents *pvbc,
		IN LPCWSTR bstrPath
		);

    // validate a IVssWMFiledesc object
	void ValidateFiledesc(IVssWMFiledesc *pFiledesc);

	// assert a privilege, either backup or restore
    BOOL AssertPrivilege(LPCWSTR privName);

	// remove volumes that are not candidates for the snapshot
	// based on test configuration
	void RemoveNonCandidateVolumes();

	// choose a volume to backup from non-snapshotted volumes
	void ChooseVolumeToBackup(IVssBackupComponents *pvbc);

	// delete a snapshot set
	void DoDeleteSnapshotSet(IVssBackupComponents *pvbc, VSS_ID id);

	// delete a list of strings
	void DeleteVolumeList(LPWSTR *rgwsz, UINT cwsz);

	// build a volume list
	void BuildVolumeList(LPCWSTR wszOption, UINT *pcVolumes, LPWSTR **prgwsz);

	// delete snapshot sets that are cached by the serial test
	void DeleteCachedSnapshotSets();

	// configuration file
	CVsTstINIConfig *m_pConfig;

	// command line parameters
	CVsTstParams *m_pParams;

	// flag indicating that test should be terminated after the current
	// run is complete
	bool m_bTerminateTest;


	// range for cancelling PrepareBackup
	LONGLONG m_llCancelPrepareBackupLow;
	LONGLONG m_llCancelPrepareBackupHigh;

	// range for cancelling DoSnapshotSet
	LONGLONG m_llCancelDoSnapshotSetLow;
	LONGLONG m_llCancelDoSnapshotSetHigh;

	// range for cancelling BackupComplete
	LONGLONG m_llCancelBackupCompleteLow;
	LONGLONG m_llCancelBackupCompleteHigh;

	// number of cycles to loop until calling cancel during PrepareBackup
	UINT m_cyclesCancelPrepareBackup;

   	// number of cycles to loop until calling cancel during DoSnapshotSet
	UINT m_cyclesCancelDoSnapshotSet;

	// number of cycles to loop until calling cancel during BackupComplete
	UINT m_cyclesCancelBackupComplete;

	// is this a component backup
	bool m_bComponentBackup;

	// is this a volume backup
	bool m_bVolumeBackup;

	// is this a serial volume (i.e., multiple backups on different volumes) backup
	bool m_bSerialBackup;

	// should ntfs volumes be backed up
	bool m_bBackupNTFS;

	// should fat32 volumes be backed up
	bool m_bBackupFAT32;

	// should fat16 volumes be backed up
	bool m_bBackupFAT16;

	// should raw volumes be backed up
	bool m_bBackupRAW;

	// how many volumes should be backed up at a time
	VSTST_BACKUP_VOLUMES m_backupVolumes;

	// volume list
	CVsTstVolumeList m_volumeList;

	// number of volumes in the volume list
	UINT m_cVolumes;

	// number of volumes left in the volume list
	UINT m_cVolumesLeft;

	// array of snapshot sets created
	VSS_ID m_rgSnapshotSetIds[MAX_SNAPSHOT_SET_COUNT];

	// array of backup components objects created
	IVssBackupComponents *m_rgvbc[MAX_SNAPSHOT_SET_COUNT];

	// # of snapshot sets
	UINT m_cSnapshotSets;

	// array of assigned volumes
	bool m_rgbAssignedVolumes[MAX_VOLUME_COUNT];

	// array of excluded volumes
	LPWSTR *m_rgwszExcludedVolumes;

	// count of excluded volumes
	UINT m_cExcludedVolumes;

	// array of volumes to include in the snapshot
	LPWSTR *m_rgwszIncludedVolumes;

	// number of volumes in included array
	UINT m_cIncludedVolumes;

	// perform random fills of volumes to check diff allocation code
	bool m_bRandomFills;

	// perform selected fills of volumes
	bool m_bSelectedFills;

	// try to fragment volumes when filling them
	bool m_bFragmentWhenFilling;

	// array of volumes that should be filled
	LPWSTR *m_rgwszFillVolumes;

	// number of volumes that should be filled
	UINT m_cFillVolumes;

	// array of volumes
	LPWSTR m_wszVolumesSnapshot;

	// size of volume array
	UINT m_cwcVolumesSnapshot;

	// time for wait interval
	UINT m_waitTime;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\failsnap\failsnap.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	simsnap.cpp
**
**
** Abstract:
**
**	Test program to drive the VSS Writer Shim contained in VssAPI.DLL
**
**
** Author:
**
**	Michael C. Johnson   [mikejohn]        24-May-2000
**
**
** Revision History:
**
**	X-5	MCJ		Michael C. Johnson		18-Sep-2000
**		176860: Add the missing calling convention specifiers
**
**	X-4	MCJ		Michael C. Johnson		23-Jun-2000
**		Set the writer failure status.
**
**	X-3	MCJ		Michael C. Johnson		15-Jun-2000
**		Add some additional event routines and the ability to act
**		as various types of writer.
**
**	X-2	MCJ		Michael C. Johnson		26-May-2000
**		Add some extra tests to validate shim is properly sensitive
**		to volume name array contents.
**--
*/

/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/
#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <assert.h>

#include <vss.h>
#include <vswriter.h>



#define	GET_STATUS_FROM_BOOL(_bSucceeded)	((_bSucceeded)       ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_HANDLE(_handle)		((NULL != (_handle)) ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_POINTER(_ptr)		((NULL != (_ptr))    ? NOERROR : E_OUTOFMEMORY)

#define SIZEOF_ARRAY(_aBase)			(sizeof (_aBase) / sizeof ((_aBase)[0]))



typedef enum FAIL_PHASE
    {
    PHASE_UNDEFINED = 0,
    PHASE_IDENTIFY,
    PHASE_PREPARE_FOR_BACKUP,
    PHASE_PREPARE_FOR_SNAPSHOT,
    PHASE_FREEZE,
    PHASE_THAW,
    PHASE_ABORT,
    PHASE_BACKUP_COMPLETE,
    PHASE_RESTORE
    } FAIL_PHASE;


HRESULT SelectFailureStatus (VOID)
    {
    HRESULT	hrStatus;

    switch (rand () / (RAND_MAX / 5))
	{
	case 0: hrStatus = VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT; break;
	case 1: hrStatus = VSS_E_WRITERERROR_OUTOFRESOURCES;       break;
	case 2: hrStatus = VSS_E_WRITERERROR_TIMEOUT;              break;
	case 3: hrStatus = VSS_E_WRITERERROR_NONRETRYABLE;         break;
	case 4: hrStatus = VSS_E_WRITERERROR_RETRYABLE;            break;

	default:
	    assert (FALSE);
	    break;
	}

    return (hrStatus);
    }



LPCWSTR GetStringFromFailureType (HRESULT hrStatus)
    {
    LPCWSTR pwszFailureType;

    switch (hrStatus)
	{
	case NOERROR:                                pwszFailureType = L"";                     break;
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT: pwszFailureType = L"InconsistentSnapshot"; break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:       pwszFailureType = L"OutOfResources";       break;
	case VSS_E_WRITERERROR_TIMEOUT:              pwszFailureType = L"Timeout";              break;
	case VSS_E_WRITERERROR_NONRETRYABLE:         pwszFailureType = L"Non-Retryable";        break;
	case VSS_E_WRITERERROR_RETRYABLE:            pwszFailureType = L"Retryable";            break;
	default:                                     pwszFailureType = L"UNDEFINED";            break;
	}

    return (pwszFailureType);
    }



LPCWSTR GetStringFromWriterType (VSS_USAGE_TYPE wtWriterType)
    {
    LPCWSTR pwszWriterType;

    switch (wtWriterType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszWriterType = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszWriterType = L"SystemServiceState";  break;
	case VSS_UT_USERDATA:            pwszWriterType = L"UserData";            break;
	case VSS_UT_OTHER:               pwszWriterType = L"Other";               break;
	default:                         pwszWriterType = L"UNDEFINED";           break;
	}

    return (pwszWriterType);
    }



LPCWSTR GetStringFromFailPhase (FAIL_PHASE fpFailPhase)
    {
    LPCWSTR pwszFailPhase;


    switch (fpFailPhase)
	{
	case PHASE_IDENTIFY:             pwszFailPhase = L"Identify";           break;
	case PHASE_PREPARE_FOR_BACKUP:   pwszFailPhase = L"PrepareForBackup";   break;
	case PHASE_PREPARE_FOR_SNAPSHOT: pwszFailPhase = L"PrepareForSnapshot"; break;
	case PHASE_FREEZE:               pwszFailPhase = L"Freeze";             break;
	case PHASE_THAW:                 pwszFailPhase = L"Thaw";               break;
	case PHASE_ABORT:                pwszFailPhase = L"Abort";              break;
	case PHASE_BACKUP_COMPLETE:      pwszFailPhase = L"BackupComplete";     break;
	case PHASE_RESTORE:              pwszFailPhase = L"Restore";            break;
	default:                         pwszFailPhase = L"UNDEFINED";          break;
	}
    
    return (pwszFailPhase);
    }





static volatile BOOL       bContinue   = TRUE;
static volatile FAIL_PHASE fpFailPhase = PHASE_FREEZE;


class CVssWriterFailSnap : public CVssWriter
	{
public:
	    bool STDMETHODCALLTYPE OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata);
	    bool STDMETHODCALLTYPE OnPrepareBackup (IVssWriterComponents *pIVssWriterComponents);
	    bool STDMETHODCALLTYPE OnPrepareSnapshot ();
	    bool STDMETHODCALLTYPE OnFreeze ();
	    bool STDMETHODCALLTYPE OnThaw ();
	    bool STDMETHODCALLTYPE OnAbort ();
	    bool STDMETHODCALLTYPE OnBackupComplete (IVssWriterComponents *pIVssWriterComponents);
	    bool STDMETHODCALLTYPE OnPostRestore (IVssWriterComponents *pIVssWriterComponents);
};



bool STDMETHODCALLTYPE CVssWriterFailSnap::OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata)
    {
    bool	bPhaseSucceeded = (PHASE_IDENTIFY != fpFailPhase);
    HRESULT	hrStatus        = SelectFailureStatus ();

    if (bPhaseSucceeded)
	{
	hrStatus = pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							    NULL,
							    L"Failsnap Writer Component",
							    L"Failsnap Writer Caption",
							    NULL, // icon
							    0,
							    true,
							    false,
							    false);

	bPhaseSucceeded = SUCCEEDED (hrStatus);
	}


    wprintf (L"\nThreadId 0x%04x - Received event - OnIdentify ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnPrepareBackup (IVssWriterComponents *pIVssWriterComponents)
    {
    bool	bPhaseSucceeded = (PHASE_PREPARE_FOR_BACKUP != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnPrepareBackup ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnPrepareSnapshot ()
    {
    bool	bPhaseSucceeded = (PHASE_PREPARE_FOR_SNAPSHOT != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnPrepareSnapshot ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnFreeze ()
    {
    bool	bPhaseSucceeded = (PHASE_FREEZE != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnFreeze ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnThaw ()
    {
    bool	bPhaseSucceeded = (PHASE_THAW != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnThaw ()%s%s", 
	     GetCurrentThreadId (),
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnAbort ()
    {
    bool	bPhaseSucceeded = (PHASE_ABORT != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnAbort ()%s%s",
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnBackupComplete (IVssWriterComponents *pIVssWriterComponents)
    {
    bool	bPhaseSucceeded = (PHASE_BACKUP_COMPLETE != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnBackupComplete ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnPostRestore (IVssWriterComponents *pIVssWriterComponents)
    {
    bool	bPhaseSucceeded = (PHASE_RESTORE != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnPostRestore ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }






static BOOL AssertPrivilege (LPCWSTR privName)
    {
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if (OpenProcessToken (GetCurrentProcess (), TOKEN_ADJUST_PRIVILEGES, &tokenHandle))
	{
        LUID value;

        if (LookupPrivilegeValue (NULL, privName, &value))
	    {
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            /*
            ** We will always call GetLastError below, so clear
            ** any prior error values on this thread.
            */
            SetLastError (ERROR_SUCCESS);

            stat = AdjustTokenPrivileges (tokenHandle,
					  FALSE,
					  &newState,
					  (DWORD)0,
					  NULL,
					  NULL);

            /*
            ** Supposedly, AdjustTokenPriveleges always returns TRUE
            ** (even when it fails). So, call GetLastError to be
            ** extra sure everything's cool.
            */
            if ((error = GetLastError()) != ERROR_SUCCESS)
		{
                stat = FALSE;
		}

            if (!stat)
		{
                wprintf (L"AdjustTokenPrivileges for %s failed with 0x%08X",
			 privName,
			 error);
		}
	    }


        CloseHandle (tokenHandle);
	}

    return stat;
    }



BOOL WINAPI CtrlC_HandlerRoutine (IN DWORD /* dwType */)
	{
	bContinue = FALSE;

	// Mark that the break was handled.
	return TRUE;
	}



extern "C" int __cdecl wmain (int argc, WCHAR *argv[])
    {
    HRESULT		 hrStatus            = NOERROR;
    CVssWriterFailSnap	*pCVssWriterFailSnap = NULL;
    BOOL		 bSucceeded          = FALSE;
    BOOL		 bComInitialized     = FALSE;
    BOOL		 bSubscribed         = FALSE;
    VSS_USAGE_TYPE	 wtWriterType        = VSS_UT_USERDATA;
    const GUID		 guidIdWriter        = {0xd335a99e,
						0x57fb,
						0x4b80,
						    {0x85, 0xb1, 0x15, 0xda, 0xa7, 0xc7, 0x4e, 0x14}};


    srand ((unsigned)time (NULL));

    SetConsoleCtrlHandler(CtrlC_HandlerRoutine, TRUE);


    if ((argc >= 2) && (wcslen (argv[1]) > 0))
	{
	switch (*argv[1])
	    {
	    case L'I': case L'i': fpFailPhase = PHASE_IDENTIFY;             break;
	    case L'B': case L'b': fpFailPhase = PHASE_PREPARE_FOR_BACKUP;   break;
	    case L'S': case L's': fpFailPhase = PHASE_PREPARE_FOR_SNAPSHOT; break;
	    case L'F': case L'f': fpFailPhase = PHASE_FREEZE;               break;
	    case L'T': case L't': fpFailPhase = PHASE_THAW;                 break;
	    case L'A': case L'a': fpFailPhase = PHASE_ABORT;                break;
	    case L'C': case L'c': fpFailPhase = PHASE_BACKUP_COMPLETE;      break;
	    case L'R': case L'r': fpFailPhase = PHASE_RESTORE;              break;

	    default:
		wprintf (L"\nFAILSNAP [phase] [writer type]"
			 L"\n\n\tFailPhases"
			 L"\n\t\ti - Identify"
			 L"\n\t\tb - PrepareForBackup"
			 L"\n\t\ts - PrepareForSnapshot"
			 L"\n\t\tf - Freeze                (default)"
			 L"\n\t\tt - Thaw"
			 L"\n\t\ta - Abort"
			 L"\n\t\tc - BackupComplete"
			 L"\n\t\tr - PostRestore"

			 L"\n\n\tWriterTypes"
			 L"\n\t\tb - BootableState writer"
			 L"\n\t\ts - ServiceState writer"
			 L"\n\t\tu - UserData writer       (default)"
			 L"\n\t\to - Other writer"
			 L"\n");



		bContinue = FALSE;
		break;
	    }
	}



    if ((argc >= 3) && (wcslen (argv[2]) > 0))
	{
	switch (*argv[2])
	    {
	    case L'B': case L'b': wtWriterType = VSS_UT_BOOTABLESYSTEMSTATE; break;
	    case L'S': case L's': wtWriterType = VSS_UT_SYSTEMSERVICE;       break;
	    case L'U': case L'u': wtWriterType = VSS_UT_USERDATA;            break;
	    case L'O': case L'o': wtWriterType = VSS_UT_OTHER;               break;

	    default:
		bContinue = FALSE;
		break;
	    }
	}





    if (bContinue)
	{
	wprintf (L"\nSetting up %s writer to fail %s requests (ProcessId 0x%04x)",
		 GetStringFromWriterType (wtWriterType),
		 GetStringFromFailPhase  (fpFailPhase),
		 GetCurrentProcessId ());


	wprintf (L"\nChecking privileges");

	bSubscribed = AssertPrivilege (SE_BACKUP_NAME);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);


	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nAssertPrivilege returned error 0x%08X", hrStatus);
	    }

	}


    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nInitializing COM");

	hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nCoInitialize() returned error 0x%08X", hrStatus);
	    }

	else
	    {
	    bComInitialized = TRUE;
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nConstructing Writer");

	pCVssWriterFailSnap = new CVssWriterFailSnap;

	if (NULL == pCVssWriterFailSnap)
	    {
	    hrStatus = HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY);

	    wprintf (L"\nFailed to allocate CVssWriterFailSnap : 0x%08X", hrStatus);
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	WCHAR	awchWriterName [256];


	wprintf (L"\nInitialising the writer");

	_snwprintf (awchWriterName, 
		    SIZEOF_ARRAY (awchWriterName), 
		    L"Microsoft Test Writer - FailSnap (%s/%s/0x%04x)",
		    GetStringFromWriterType (wtWriterType),
		    GetStringFromFailPhase  (fpFailPhase),
		    GetCurrentProcessId ());


	hrStatus = pCVssWriterFailSnap->Initialize (guidIdWriter,
						    awchWriterName,
						    wtWriterType,
						    VSS_ST_OTHER);

	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nFailed to initialize the writer : 0x%08X", hrStatus);
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nSubscribing to snapshot events");

	hrStatus = pCVssWriterFailSnap->Subscribe ();

	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nFailed to subscribe to snapshot events : 0x%08X", hrStatus);
	    }

	else
	    {
	    bSubscribed = TRUE;
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nWaiting for snapshot events (or Ctrl-C)");
	
	while (bContinue)
	    {
	    Sleep (100);
	    }
	}



    if (bSubscribed)
	{
	wprintf (L"\nUn-Subscribing from snapshot events");

	pCVssWriterFailSnap->Unsubscribe ();
	}


    if (NULL != pCVssWriterFailSnap)
	{
	wprintf (L"\nDeconstructing Writer");

	delete pCVssWriterFailSnap;
	}


    if (bComInitialized)
	{
	wprintf (L"\nUnInitialising COM");

	CoUninitialize();
	}

    return (hrStatus);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\common\stdafx.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <atlbase.h>
#include <vststtools.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\common\bsfixalloc.cxx ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    bsfixalloc.cpp

Abstract:

    Adapted from MFC 6 SR 1 release of fixalloc.cpp.  Removed all MFC stuff.

Author:

    Stefan R. Steiner   [ssteiner]        4-10-2000

Revision History:

--*/

// fixalloc.cpp - implementation of fixed block allocator

//#include "stdafx.h"
#include <windows.h>
#include <assert.h>
#include "bsfixalloc.hxx"

#define ASSERT assert
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;

// #define new DEBUG_NEW
#endif


/////////////////////////////////////////////////////////////////////////////
// CBsFixedAlloc

CBsFixedAlloc::CBsFixedAlloc(UINT nAllocSize, UINT nBlockSize)
{
	ASSERT(nAllocSize >= sizeof(CNode));
	ASSERT(nBlockSize > 1);
    //wprintf( L"CBsFixedAlloc called, nAllocSize: %d, nBlockSize: %d\n", nAllocSize, nBlockSize );
	m_nAllocSize = nAllocSize;
	m_nBlockSize = nBlockSize;
	m_pNodeFree = NULL;
	m_pBlocks = NULL;
	InitializeCriticalSection(&m_protect);
}

CBsFixedAlloc::~CBsFixedAlloc()
{
	FreeAll();
	DeleteCriticalSection(&m_protect);
}

void CBsFixedAlloc::FreeAll()
{
	EnterCriticalSection(&m_protect);
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
	m_pNodeFree = NULL;
	LeaveCriticalSection(&m_protect);
}

void* CBsFixedAlloc::Alloc()
{
	EnterCriticalSection(&m_protect);
	if (m_pNodeFree == NULL)
	{
		CBsPlex* pNewBlock = NULL;
		try
		{
			// add another block
			pNewBlock = CBsPlex::Create(m_pBlocks, m_nBlockSize, m_nAllocSize);
            //wprintf( L"Alloc getting more core, nAllocSize: %d\n", m_nAllocSize );
		}
		catch( ... )
		{
			LeaveCriticalSection(&m_protect);
			throw;
		}

		// chain them into free list
		CNode* pNode = (CNode*)pNewBlock->data();
		// free in reverse order to make it easier to debug
		(BYTE*&)pNode += (m_nAllocSize * m_nBlockSize) - m_nAllocSize;
		for (int i = m_nBlockSize-1; i >= 0; i--, (BYTE*&)pNode -= m_nAllocSize)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	// remove the first available node from the free list
	void* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;

	LeaveCriticalSection(&m_protect);
	return pNode;
}

void CBsFixedAlloc::Free(void* p)
{
	if (p != NULL)
	{
		EnterCriticalSection(&m_protect);

		// simply return the node to the free list
		CNode* pNode = (CNode*)p;
		pNode->pNext = m_pNodeFree;
		m_pNodeFree = pNode;
		LeaveCriticalSection(&m_protect);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBsPlex

CBsPlex* PASCAL CBsPlex::Create(CBsPlex*& pHead, UINT nMax, UINT cbElement)
{
	ASSERT(nMax > 0 && cbElement > 0);
	CBsPlex* p = (CBsPlex*) new BYTE[sizeof(CBsPlex) + nMax * cbElement];
			// may throw exception
    if ( p == NULL )
        throw( E_OUTOFMEMORY );

	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

void CBsPlex::FreeDataChain()     // free this one and links
{
	CBsPlex* p = this;
	while (p != NULL)
	{
		BYTE* bytes = (BYTE*) p;
		CBsPlex* pNext = p->pNext;
		delete[] bytes;
		p = pNext;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\backup\backup.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    backup.cpp

Abstract:

    main module of backup test exe


    Brian Berkowitz  [brianb]  05/23/2000

TBD:
	

Revision History:

    Name        Date        Comments
    brianb      05/23/2000  Created
	brianb		06/16/2000  Added comments

--*/

#include <stdafx.h>
#include <vststmsgclient.hxx>
#include <tstiniconfig.hxx>
#include <vststprocess.hxx>
#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>
#include <vststparser.hxx>
#include <vststutil.hxx>
#include <vststvolinfo.hxx>
#include <backup.h>

void LogUnexpectedFailure(LPCWSTR wsz, ...);


// selection of volumes
static LPCWSTR x_wszVolumeBackup = L"VolumeBackup";
static LPCWSTR x_wszSome = L"Some";
static LPCWSTR x_wszOne = L"One";
static LPCWSTR x_wszAll = L"All";

// selection of file system type
static LPCWSTR x_wszFileSystemBackup = L"FileSystemBackup";
static LPCWSTR x_wszNTFS = L"NTFS";
static LPCWSTR x_wszFAT32 = L"FAT32";
static LPCWSTR x_wszFAT16 = L"FAT16";
static LPCWSTR x_wszRAW = L"RAW";

// what to backup
static LPCWSTR x_wszBackingUp = L"BackingUp";
static LPCWSTR x_wszSerialVolumes = L"Serial";
static LPCWSTR x_wszVolumes = L"Volumes";
static LPCWSTR x_wszComponents = L"Components";

// cancelling async operations
static LPCWSTR x_wszCancelPrepareBackup = L"CancelPrepareBackup";
static LPCWSTR x_wszCancelDoSnapshotSet = L"CancelDoSnapshotSet";
static LPCWSTR x_wszCancelBackupComplete = L"CancelBackupComplete";

// wait time interval
static LPCWSTR x_wszWaitInterval = L"WaitInterval";


// volumes to exclude
static LPCWSTR x_wszExcludeVolumes = L"ExcludeVolumes";

// volumes to include
static LPCWSTR x_wszVolumeList = L"VolumeList";

// volumes to fill with data
static LPCWSTR x_wszFillVolumes = L"FillVolumes";
static LPCWSTR x_wszFillVolumesOptRandom = L"Random";
static LPCWSTR x_wszFillVolumesOptSelected = L"Selected";
static LPCWSTR x_wszFillVolumesOptNone = L"None";

// whether volumes filled with data should be fragmented
static LPCWSTR x_wszFillVolumesOptFragment = L"Fragment";

// which volumes to fill
static LPCWSTR x_wszFillVolumesList = L"FillVolumesList";

// constructor
CVsBackupTest::CVsBackupTest() :
		m_bTerminateTest(false),
		m_bBackupNTFS(false),
		m_bBackupFAT32(false),
		m_bBackupFAT16(false),
		m_bBackupRAW(false),
		m_bSerialBackup(false),
		m_bVolumeBackup(false),
		m_bComponentBackup(false),
		m_cyclesCancelPrepareBackup(0),
		m_cyclesCancelDoSnapshotSet(0),
		m_cyclesCancelBackupComplete(0),
		m_cVolumes(0),
		m_cVolumesLeft(0),
		m_cSnapshotSets(0),
		m_cExcludedVolumes(0),
		m_rgwszExcludedVolumes(NULL),
		m_cIncludedVolumes(0),
		m_rgwszIncludedVolumes(NULL),
		m_bRandomFills(false),
		m_bFragmentWhenFilling(false),
		m_rgwszFillVolumes(NULL),
		m_cFillVolumes(0)
		{
		}

// delete an array of strings
void CVsBackupTest::DeleteVolumeList(LPWSTR *rgwsz, UINT cwsz)
	{
	if (rgwsz)
		{
		for(UINT iwsz = 0; iwsz < cwsz; iwsz++)
			delete rgwsz[iwsz];
		}

	delete rgwsz;
	}


// destructor
CVsBackupTest::~CVsBackupTest()
	{
	// delete any snapshot sets that are cached
	if (m_cSnapshotSets)
		DeleteCachedSnapshotSets();

	delete m_wszVolumesSnapshot;

	// delete various lists of volumes (string arrays)
	DeleteVolumeList(m_rgwszExcludedVolumes, m_cExcludedVolumes);
	DeleteVolumeList(m_rgwszIncludedVolumes, m_cIncludedVolumes);
	DeleteVolumeList(m_rgwszFillVolumes, m_cFillVolumes);
	}

// enable a privilege
BOOL CVsBackupTest::AssertPrivilege(LPCWSTR privName)
	{
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if (OpenProcessToken
			(
			GetCurrentProcess(),
			TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,
			&tokenHandle
			))
		{
        LUID value;

		// obtain privilige value
        if (LookupPrivilegeValue( NULL, privName, &value ))
			{
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED;

            /*
            * We will always call GetLastError below, so clear
            * any prior error values on this thread.
            */
            SetLastError( ERROR_SUCCESS );

            stat =  AdjustTokenPrivileges
				(
                tokenHandle,
                FALSE,
                &newState,
                (DWORD)0,
                NULL,
                NULL
				);
            /*
            * Supposedly, AdjustTokenPriveleges always returns TRUE
            * (even when it fails). So, call GetLastError to be
            * extra sure everything's cool.
            */
            if ((error = GetLastError()) != ERROR_SUCCESS)
                stat = FALSE;

            if (!stat)
				{
				char buf[128];
				sprintf
					(
					buf,
					"AdjustTokenPrivileges for %s failed with %d",
                    privName,
                    error
					);

                LogFailure(buf);
				}
			}
		
		CloseHandle(tokenHandle);
		}

    return stat;
	}

// build a list of volumes
void CVsBackupTest::BuildVolumeList
	(
	LPCWSTR wszOption,
	UINT *pcVolumes,
	LPWSTR **prgwszVolumes
	)
	{
	// delete existing volume list
	DeleteVolumeList(*prgwszVolumes, *pcVolumes);
	*prgwszVolumes = NULL;
	*pcVolumes = 0;

	// get option value
	CBsString bssVolumes;
	m_pConfig->GetOptionValue(wszOption, &bssVolumes);

	// split into seperate strings for each volume
	LPCWSTR wszEnd = CVsTstParser::SplitOptions(bssVolumes);
	LPCWSTR wszStart = bssVolumes;
	UINT cVolumes = 0;

	// count number of volumes in exclude list
	while(wszStart < wszEnd)
		{
		cVolumes++;
		wszStart += wcslen(wszStart) + 1;
		}

	// allocate array for strings
	*prgwszVolumes = new LPWSTR[cVolumes];
	if (*prgwszVolumes == NULL)
		{
		LogUnexpectedFailure(L"Out of Memory");
		throw E_OUTOFMEMORY;
		}
	
	wszStart = bssVolumes;
	for (UINT iVolume = 0; iVolume < cVolumes; iVolume++)
		{
		// extract a string value
		LPWSTR wszNew = new WCHAR[wcslen(wszStart) + 2];
		if (wszNew == NULL)
			{
			LogUnexpectedFailure(L"Out of Memory");
			throw E_OUTOFMEMORY;
			}

		UINT cwc = (UINT) wcslen(wszStart);

		memcpy(wszNew, wszStart, cwc * sizeof(WCHAR));
		wszStart += cwc + 1;

		// add trailing backslash if not there in order to convert
		// into a path to the root directory on the voloume
		if (wszNew[cwc-1] != L'\\')
			wszNew[cwc++] = L'\\';

		wszNew[cwc] = L'\0';
		
		WCHAR wsz[MAX_PATH];
		// get unique volume name
		if (!GetVolumeNameForVolumeMountPoint(wszNew, wsz, MAX_PATH))
			{
			delete wszNew;
			LogUnexpectedFailure
				(
				L"Cannot find unique volume name for volume volume %s due to error %d.",
				wszStart,
				GetLastError()
				);
			}
		else
			{
			delete wszNew;

			// allocate new string for unique volume name
			(*prgwszVolumes)[*pcVolumes] = new WCHAR[wcslen(wsz) + 1];
			if ((*prgwszVolumes)[*pcVolumes] == NULL)
				{
				LogUnexpectedFailure(L"Out of Memory");
				throw E_OUTOFMEMORY;
				}

			wcscpy((*prgwszVolumes)[*pcVolumes], wsz);

		    // incrmement count of volumes
			*pcVolumes += 1;
			}
		}
	}


// callback to run the test
HRESULT CVsBackupTest::RunTest
	(
	CVsTstINIConfig *pConfig,		// configuration file (selected section)
	CVsTstClientMsg *pClient,		// message pipe
	CVsTstParams *pParams			// command line parameters
	)
	{
	// save supplied parameters
	m_pConfig = pConfig;
	m_pParams = pParams;
	SetClientMsg(pClient);

	try
		{
		// make sure that backup privileges are enabled
		if (!AssertPrivilege(SE_BACKUP_NAME))
			{
			LogFailure("Unable to assert backup privilege");
			throw E_UNEXPECTED;
			}

		// determine what we are backing up
		CBsString bssBackingUp;
		m_pConfig->GetOptionValue(x_wszBackingUp, &bssBackingUp);

		// determe the type of volume backup being performed
		CBsString bssVolumeBackup;
		m_pConfig->GetOptionValue(x_wszVolumeBackup, &bssVolumeBackup);

		// determine which volumes are being backed up
		CBsString bssFilesystemBackup;
		m_pConfig->GetOptionValue(x_wszFileSystemBackup, &bssFilesystemBackup);

		// get value of FillVolumes option
		CBsString bssFillVolumes;
		m_pConfig->GetOptionValue(x_wszFillVolumes, &bssFillVolumes);


		// get cancel test options
		m_pConfig->GetOptionValue(x_wszCancelPrepareBackup, &m_llCancelPrepareBackupLow, &m_llCancelPrepareBackupHigh);
		m_pConfig->GetOptionValue(x_wszCancelDoSnapshotSet, &m_llCancelDoSnapshotSetLow, &m_llCancelDoSnapshotSetHigh);
		m_pConfig->GetOptionValue(x_wszCancelBackupComplete, &m_llCancelBackupCompleteLow, &m_llCancelBackupCompleteHigh);


		// get wait time interval
		LONGLONG llWaitTimeLow, llWaitTimeHigh;
		m_pConfig->GetOptionValue(x_wszWaitInterval, &llWaitTimeLow, &llWaitTimeHigh);
		m_waitTime = (UINT) llWaitTimeLow;

		// determine type of backup
		if (_wcsicmp(bssBackingUp, x_wszComponents) == 0)
			m_bComponentBackup = true;
		else if (_wcsicmp(bssBackingUp, x_wszVolumes) == 0)
			m_bVolumeBackup = true;
		else if (_wcsicmp(bssBackingUp, x_wszSerialVolumes) == 0)
			m_bSerialBackup = true;

		// determine how many volumes are snapshot
		if (_wcsicmp(bssVolumeBackup, x_wszAll) == 0)
			m_backupVolumes = VSTST_BV_ALL;
		else if (_wcsicmp(bssVolumeBackup, x_wszSome) == 0)
			m_backupVolumes = VSTST_BV_SOME;
		else if (_wcsicmp(bssVolumeBackup, x_wszOne) == 0)
			m_backupVolumes = VSTST_BV_ONE;

		// determine which file systems are backed up
		LPCWSTR wszEnd = CVsTstParser::SplitOptions(bssFilesystemBackup);
		LPCWSTR wszStart = bssFilesystemBackup;
		while(wszStart < wszEnd)
			{
			if (_wcsicmp(wszStart, x_wszAll) == 0)
				{
				m_bBackupNTFS = true;
				m_bBackupFAT16 = true;
				m_bBackupFAT32 = true;
				m_bBackupRAW = true;
				break;
				}

			else if (_wcsicmp(wszStart, x_wszNTFS) == 0)
				m_bBackupNTFS = true;
			else if (_wcsicmp(wszStart, x_wszFAT32) == 0)
				m_bBackupFAT32 = true;
			else if (_wcsicmp(wszStart, x_wszFAT16) == 0)
				m_bBackupFAT16 = true;
			else if (_wcsicmp(wszStart, x_wszRAW) == 0)
				m_bBackupRAW = true;

			wszStart += wcslen(wszStart) + 1;
			}

		// build list of excluded volumes
		BuildVolumeList
			(
			x_wszExcludeVolumes,
			&m_cExcludedVolumes,
			&m_rgwszExcludedVolumes
			);

		// build list of included volumes
        BuildVolumeList
			(
			x_wszVolumeList,
			&m_cIncludedVolumes,
			&m_rgwszIncludedVolumes
			);

        // build list of volumes to fill
        BuildVolumeList
			(
			x_wszFillVolumesList,
			&m_cFillVolumes,
			&m_rgwszFillVolumes
			);

        // log information about the test
		LogMessage("Starting Backup test.\n");
		if (m_bVolumeBackup || m_bSerialBackup)
			{
			LogMessage("Performing volume backup\n");

			if (m_bSerialBackup)
				LogMessage("Serially backing up volumes\n");

			if (m_bBackupNTFS && m_bBackupFAT32 &&
				m_bBackupRAW && m_bBackupFAT16)
				LogMessage("Backing up all file systems\n");
			else
				{
				if (m_bBackupNTFS)
					LogMessage("Backing up NTFS volumes.\n");
				if (m_bBackupFAT32)
					LogMessage("Backing up FAT32 volumes.\n");
				if (m_bBackupFAT16)
					LogMessage("Backing up FAT16 volumes.\n");
				if (m_bBackupRAW)
					LogMessage("Backing up RAW volumes.\n");
				}

			if (m_backupVolumes == VSTST_BV_ONE)
				LogMessage("Backing up one volume at a time");
			else if (m_backupVolumes == VSTST_BV_SOME)
				LogMessage("Backing up multiple volumes at a time");
			else if (m_backupVolumes == VSTST_BV_ALL)
				LogMessage("Backing up all volumes at once");
			}
		else
			LogMessage("Performing component backup.\n");

		if (m_llCancelPrepareBackupHigh > 0i64)
			LogMessage("Cancel during PrepareBackup.\n");

		if (m_llCancelDoSnapshotSetHigh > 0i64)
			LogMessage("Cancel during DoSnapshotSet.\n");

		if (m_llCancelBackupCompleteHigh > 0i64)
			LogMessage("Cancel during BackupComplete.\n");

		// run the test until told to terminate the test
		while(!m_bTerminateTest)
			RunBackupTest();

		LogMessage("Ending backup test.\n");
		}
	catch(...)
		{
		return E_FAIL;
		}

	return S_OK;
	}

// routine to handle waiting for an asynchronous operation to compelte
HRESULT CVsBackupTest::WaitLoop
	(
	IVssBackupComponents *pvbc,
	IVssAsync *pAsync,
	UINT cycles,
	VSS_WRITER_STATE state1,
	VSS_WRITER_STATE state2,
	VSS_WRITER_STATE state3,
	VSS_WRITER_STATE state4,
	VSS_WRITER_STATE state5,
	VSS_WRITER_STATE state6,
	VSS_WRITER_STATE state7
	)
	{
	HRESULT hr;
	INT nPercentDone;
	HRESULT hrResult;

	while(TRUE)
		{
		if (cycles == 0)
			{
			hr = pAsync->Cancel();
			ValidateResult(hr, "IVssAsync::Cancel");

			GetAndValidateWriterState
				(
				pvbc,
				state1,
				state2,
				state3,
				state4,
				state5,
				state6,
				state7
				);

			while(TRUE)
				{
				hr = pAsync->QueryStatus(&hrResult, &nPercentDone);
				ValidateResult(hr, "IVssAsync::QueryStatus");
				if (hrResult != STG_S_ASYNC_PENDING)
					return hrResult;

				Sleep(m_waitTime);
				}
			}

		cycles--;
		hr = pAsync->QueryStatus(&hrResult, &nPercentDone);
		ValidateResult(hr, "IVssAsync::QueryStatus");
		if (hrResult == STG_S_ASYNC_FINISHED)
			break;
		else if (hrResult != STG_S_ASYNC_PENDING)
			return hrResult;

		Sleep(m_waitTime);
		}

	return S_OK;
	}


void CVsBackupTest::RunBackupTest()
	{
	if (m_wszVolumesSnapshot == NULL)
		{
		m_wszVolumesSnapshot = new WCHAR[1024];
		if (m_wszVolumesSnapshot == NULL)
			{
			LogFailure("Out of memory");
			throw E_OUTOFMEMORY;
			}

		m_cwcVolumesSnapshot = 1024;
		}

	m_wszVolumesSnapshot[0] = L'\0';
	CComPtr<IVssBackupComponents> pvbc;
	HRESULT hr;
	bool bAbortNeeded = false;
	bool bDeleteNeeded = false;


	VSS_ID id = GUID_NULL;
	try
		{
		hr = CreateVssBackupComponents(&pvbc);
		ValidateResult(hr, "CreateVssBackupComponents");


		hr = pvbc->InitializeForBackup();
		ValidateResult(hr, "IVssBackupComponents::InitializeForBackup");
		hr = pvbc->SetBackupState(true, false, VSS_BT_FULL);
		ValidateResult(hr, "IVssBackupComponents::SetBackupState");
		hr = pvbc->StartSnapshotSet(&id);
		bAbortNeeded = true;
		ValidateResult(hr, "IVssBackupComponents::StartSnapshotSet");
		GetMetadataAndSetupComponents(pvbc);
		if(m_bVolumeBackup || m_bSerialBackup)
			{
			if (m_cVolumes == 0)
				{
				m_volumeList.RefreshVolumeList();
				m_cVolumes = m_volumeList.GetVolumeCount();
				if (m_cVolumes > MAX_VOLUME_COUNT)
					m_cVolumes = MAX_VOLUME_COUNT;

				m_cVolumesLeft = m_cVolumes;
				memset(m_rgbAssignedVolumes, 0, m_cVolumes * sizeof(bool));
				RemoveNonCandidateVolumes();
				if (m_cVolumesLeft == 0)
					LogFailure("No Volumes to snapshot.");
				}

			if (m_backupVolumes == VSTST_BV_ONE)
				ChooseVolumeToBackup(pvbc);
			else if (m_backupVolumes == VSTST_BV_ALL)
				{
				// backup all volumes
				while(m_cVolumesLeft > 0)
					ChooseVolumeToBackup(pvbc);
				}
			else
				{
				// choose some subset of volumes to backup
				UINT cVolumesToBackup = CVsTstRandom::RandomChoice(1, m_cVolumes);
				while(cVolumesToBackup-- > 0)
					ChooseVolumeToBackup(pvbc);
				}
			}


			{
			CComPtr<IVssAsync> pAsync;
			hr = pvbc->PrepareForBackup(&pAsync);
			ValidateResult(hr, "IVssBackupComponents::PrepareForBackup");
			if (m_llCancelPrepareBackupHigh > 0i64)
				{
				if (m_cyclesCancelPrepareBackup < (UINT) m_llCancelPrepareBackupLow)
					m_cyclesCancelPrepareBackup = (UINT) m_llCancelPrepareBackupLow;
				}
			else
				m_cyclesCancelPrepareBackup = 0xffffffff;


			hr = WaitLoop
					(
					pvbc,
					pAsync,
					m_cyclesCancelPrepareBackup,
					VSS_WS_FAILED_AT_PREPARE_BACKUP,
					VSS_WS_STABLE
					);

			if (m_cyclesCancelPrepareBackup != 0xffffffff)
				m_cyclesCancelPrepareBackup++;

            if (m_cyclesCancelPrepareBackup > (UINT) m_llCancelPrepareBackupHigh)
				m_cyclesCancelPrepareBackup = 0xffffffff;
			}

		if (FAILED(hr))
			{
			char buf[128];
			sprintf(buf, "PrepareForBackup failed.  hr = 0x%08lx", hr);
			LogFailure(buf);
			throw hr;
			}

		if (hr == STG_S_ASYNC_CANCELLED)
			throw S_OK;

		LogMessage("PrepareForBackup Succeeded.\n");
		if (!GetAndValidateWriterState(pvbc, VSS_WS_STABLE))
			throw E_FAIL;

		LogMessage("Starting snapshot");

			{
			CComPtr<IVssAsync> pAsync;
			hr = pvbc->DoSnapshotSet(0, &pAsync);

			if (m_llCancelDoSnapshotSetHigh > 0i64)
				{
				if (m_cyclesCancelDoSnapshotSet < (UINT) m_llCancelDoSnapshotSetLow)
					m_cyclesCancelDoSnapshotSet = (UINT) m_llCancelDoSnapshotSetLow;
				}
			else
				m_cyclesCancelDoSnapshotSet = 0xffffffff;

			hr = WaitLoop
					(	
					pvbc,
					pAsync,
					m_cyclesCancelDoSnapshotSet,
					VSS_WS_FAILED_AT_PREPARE_SYNC,
					VSS_WS_FAILED_AT_FREEZE,
					VSS_WS_FAILED_AT_THAW,
					VSS_WS_WAITING_FOR_COMPLETION,
					VSS_WS_WAITING_FOR_FREEZE,
					VSS_WS_WAITING_FOR_THAW,
					VSS_WS_STABLE
					);

            if (m_cyclesCancelDoSnapshotSet != 0xffffffff)
				m_cyclesCancelDoSnapshotSet++;

            if (m_cyclesCancelDoSnapshotSet > (UINT) m_llCancelDoSnapshotSetHigh)
				m_cyclesCancelDoSnapshotSet = 0xffffffff;
			}

		if (FAILED(hr))
			{
			char buf[128];
			sprintf(buf, "DoSnapshotSet failed.  hr = 0x%08lx", hr);
			LogFailure(buf);
			throw hr;
			}

		if (hr == STG_S_ASYNC_CANCELLED)
			throw S_OK;

		bDeleteNeeded = true;
		LogMessage("DoSnapshotSet Succeeded.\n");
		bAbortNeeded = false;
		if (!GetAndValidateWriterState(pvbc, VSS_WS_WAITING_FOR_COMPLETION, VSS_WS_STABLE))
			throw E_FAIL;

		SetComponentsSuccessfullyBackedUp(pvbc);

			{
			CComPtr<IVssAsync> pAsync;
			hr = pvbc->BackupComplete(&pAsync);
			ValidateResult(hr, "IVssBackupComponents::BackupComplete");

			if (m_llCancelBackupCompleteHigh > 0i64)
				{
				if (m_cyclesCancelBackupComplete < (UINT) m_llCancelBackupCompleteLow)
					m_cyclesCancelBackupComplete = (UINT) m_llCancelBackupCompleteLow;
				}
			else
				m_cyclesCancelBackupComplete = 0xffffffff;

			hr = WaitLoop
					(
					pvbc,
					pAsync,
					m_cyclesCancelBackupComplete,
					VSS_WS_WAITING_FOR_COMPLETION,
					VSS_WS_STABLE
					);

            if (m_cyclesCancelBackupComplete != 0xffffffff)
				m_cyclesCancelBackupComplete++;

            if (m_cyclesCancelBackupComplete > (UINT) m_llCancelDoSnapshotSetHigh)
				m_cyclesCancelBackupComplete = 0xffffffff;
			}

		if (FAILED(hr))
			{
			char buf[128];
			sprintf(buf, "BackupComplete failed.  hr = 0x%08lx", hr);
			LogFailure(buf);
			throw hr;
			}

		if (hr == STG_S_ASYNC_CANCELLED)
			throw S_OK;

		LogMessage("BackupComplete Succeeded.\n");
		if (!GetAndValidateWriterState(pvbc, VSS_WS_STABLE, VSS_WS_WAITING_FOR_COMPLETION))
			throw E_FAIL;

		m_cyclesCancelPrepareBackup = 0;
		m_cyclesCancelDoSnapshotSet = 0;
		m_cyclesCancelBackupComplete = 0;
		}
	catch(...)
		{
		}

	char buf[128];

	if (bAbortNeeded)
		{
		hr = pvbc->AbortBackup();
		if (FAILED(hr))
			{
			sprintf(buf, "IVssBackupComponents::AbortBackup failed.  hr = 0x%08lx", hr);
			LogFailure(buf);
			}
		}

	if (bDeleteNeeded)
		{
		if (m_bSerialBackup)
			{
			m_rgSnapshotSetIds[m_cSnapshotSets] = id;
			m_rgvbc[m_cSnapshotSets] = pvbc.Detach();
			m_cSnapshotSets++;
			}
		else
			DoDeleteSnapshotSet(pvbc, id);
		}

	if (!m_bSerialBackup)
		{
		// reset for a new snapshot by causing volume list to be refreshed
		m_cVolumes = 0;
		m_cVolumesLeft = 0;
		}
	else if (m_cVolumesLeft == 0 ||
			 m_cSnapshotSets == MAX_SNAPSHOT_SET_COUNT ||
			 !bDeleteNeeded)
		{
		// delete existing snapshot sets if there was a failure or
		// if there are no more volumes to add or
		// if we can't create a new snapshot set.
		DeleteCachedSnapshotSets();
		m_cVolumes = 0;
		m_cVolumesLeft = 0;
		m_cSnapshotSets = 0;
		}
	}

// delete all snapshot sets that are cached
void CVsBackupTest::DeleteCachedSnapshotSets()
	{
	for(UINT iSnapshotSet = 0; iSnapshotSet < m_cSnapshotSets; iSnapshotSet++)
		{
		CComPtr<IVssBackupComponents> pvbc;
		pvbc.Attach(m_rgvbc[iSnapshotSet]);
		DoDeleteSnapshotSet(pvbc, m_rgSnapshotSetIds[iSnapshotSet]);
		}
	}


void CVsBackupTest::DoDeleteSnapshotSet(IVssBackupComponents *pvbc, VSS_ID id)
	{
	try
		{
		LONG lSnapshotsNotDeleted;
		VSS_ID rgSnapshotsNotDeleted[10];
		HRESULT hr  = pvbc->DeleteSnapshots
						(
						id,
						VSS_OBJECT_SNAPSHOT_SET,
						false,
						&lSnapshotsNotDeleted,
						rgSnapshotsNotDeleted
						);

		ValidateResult(hr, "IVssBackupComponents::DeleteSnapshots");
		}
	catch(HRESULT)
		{
		}
	catch(...)
		{
		LogUnexpectedException("CVsBackupTest::DoDeleteSnapshotSet");
		}
		
	}


bool CVsBackupTest::GetAndValidateWriterState
	(
	IVssBackupComponents *pvbc,
	VSS_WRITER_STATE ws1,
	VSS_WRITER_STATE ws2,
	VSS_WRITER_STATE ws3,
    VSS_WRITER_STATE ws4,
	VSS_WRITER_STATE ws5,
	VSS_WRITER_STATE ws6,
	VSS_WRITER_STATE ws7
	)
	{
	unsigned cWriters;

	HRESULT hr = pvbc->GatherWriterStatus(&cWriters);
	ValidateResult(hr, "IVssBackupComponents::GatherWriterStatus");

	for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
		{
		VSS_ID idInstance;
		VSS_ID idWriter;
		VSS_WRITER_STATE status;
		CComBSTR bstrWriter;
		HRESULT hrWriterFailure;

		hr = pvbc->GetWriterStatus
					(
					iWriter,
					&idInstance,
					&idWriter,
					&bstrWriter,
					&status,
					&hrWriterFailure
					);

        ValidateResult(hr, "IVssBackupComponents::GetWriterStatus");
		if (status == VSS_WS_UNKNOWN ||
			(status != ws1 &&
			 status != ws2 &&
			 status != ws3 &&
             status != ws4 &&
			 status != ws5 &&
			 status != ws6 &&
			 status != ws7))
            {
			char buf[128];

			sprintf(buf, "Writer is in inappropriate state %d.", status);
			LogFailure(buf);
			return false;
			}
		}

	hr = pvbc->FreeWriterStatus();
	ValidateResult(hr, "IVssBackupComponents::FreeWriterStatus");
	return true;
	}

void CVsBackupTest::SetComponentsSuccessfullyBackedUp
	(
	IVssBackupComponents *pvbc
	)
	{
	unsigned cWriterComponents;
	HRESULT hr = pvbc->GetWriterComponentsCount(&cWriterComponents);
	ValidateResult(hr, "IVssBackupComponents::GetWriterComponentsCount");
	for(UINT iWriter = 0; iWriter < cWriterComponents; iWriter++)
		{
		CComPtr<IVssWriterComponentsExt> pWriter;
		hr = pvbc->GetWriterComponents(iWriter, &pWriter);
		ValidateResult(hr, "IVssBackupComponents::GetWriterComponents");

		unsigned cComponents;
		hr = pWriter->GetComponentCount(&cComponents);
		ValidateResult(hr, "IVssWriterComponents::GetComponentCount");

		VSS_ID idWriter, idInstance;
		hr = pWriter->GetWriterInfo(&idInstance, &idWriter);
		ValidateResult(hr, "IVssWriterComponents::GetWriterInfo");
		for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
			{
			CComPtr<IVssComponent> pComponent;
			hr = pWriter->GetComponent(iComponent, &pComponent);
			ValidateResult(hr, "IVssWriterComponents::GetComponent");
				
			VSS_COMPONENT_TYPE ct;
			CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;

			hr = pComponent->GetLogicalPath(&bstrLogicalPath);
			ValidateResult(hr, "IVssComponent::GetLogicalPath");
			hr = pComponent->GetComponentType(&ct);
			ValidateResult(hr, "IVssComponent::GetComponentType");
			hr = pComponent->GetComponentName(&bstrComponentName);
			ValidateResult(hr, "IVssComponent::GetComponentName");
			hr = pvbc->SetBackupSucceeded
								(
								idInstance,
								idWriter,
								ct,
								bstrLogicalPath,
								bstrComponentName,
								true
								);

			ValidateResult(hr, "IVssComponent::SetBackupSucceeded");
			}
		}
	}

void CVsBackupTest::GetMetadataAndSetupComponents
	(
	IVssBackupComponents *pvbc
	)
	{
	unsigned cWriters;
	HRESULT hr = pvbc->GatherWriterMetadata(&cWriters);
	ValidateResult(hr, "IVssBackupComponents::GatherWriterMetadata");

	for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
		{
		CComPtr<IVssExamineWriterMetadata> pMetadata;
		VSS_ID idInstance;

		hr = pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata);
		ValidateResult(hr, "IVssBackupComponents::GetWriterMetadata");

		VSS_ID idInstanceT;
		VSS_ID idWriter;
		CComBSTR bstrWriterName;
		VSS_USAGE_TYPE usage;
		VSS_SOURCE_TYPE source;
		
		hr = pMetadata->GetIdentity
							(
							&idInstanceT,
							&idWriter,
							&bstrWriterName,
							&usage,
							&source
							);

        ValidateResult(hr, "IVssExamineWriterMetadata::GetIdentity");

		if (memcmp(&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
			LogFailure("Id Instance mismatch");

		unsigned cIncludeFiles, cExcludeFiles, cComponents;
		hr = pMetadata->GetFileCounts(&cIncludeFiles, &cExcludeFiles, &cComponents);
		ValidateResult(hr, "IVssExamineWriterMetadata::GetFileCounts");

		CComBSTR bstrPath;
		CComBSTR bstrFilespec;
		CComBSTR bstrAlternate;
		CComBSTR bstrDestination;

		for(unsigned i = 0; i < cIncludeFiles; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;
			hr = pMetadata->GetIncludeFile(i, &pFiledesc);
			ValidateResult(hr, "IVssExamineWriterMetadata::GetIncludeFile");
			ValidateFiledesc(pFiledesc);
			}

		for(i = 0; i < cExcludeFiles; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;
			hr = pMetadata->GetExcludeFile(i, &pFiledesc);
			ValidateResult(hr, "IVssExamineWriterMetadata::GetExcludeFile");
			ValidateFiledesc(pFiledesc);
			}

		for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
			{
			CComPtr<IVssWMComponent> pComponent;
			PVSSCOMPONENTINFO pInfo;
			hr = pMetadata->GetComponent(iComponent, &pComponent);
			ValidateResult(hr, "IVssExamineWriterMetadata::GetComponent");
			hr = pComponent->GetComponentInfo(&pInfo);
			ValidateResult(hr, "IVssWMComponent::GetComponentInfo");
			if (m_bComponentBackup)
				{
				hr = pvbc->AddComponent
						(
						idInstance,
						idWriter,
						pInfo->type,
						pInfo->bstrLogicalPath,
						pInfo->bstrComponentName
						);

				ValidateResult(hr, "IVssBackupComponents::AddComponent");
				}
			if (pInfo->cFileCount > 0)
				{
				for(i = 0; i < pInfo->cFileCount; i++)
					{
					CComPtr<IVssWMFiledesc> pFiledesc;
					hr = pComponent->GetFile(i, &pFiledesc);
					ValidateResult(hr, "IVssWMComponent::GetFile");

					CComBSTR bstrPath;
					hr = pFiledesc->GetPath(&bstrPath);
					ValidateResult(hr, "IVssWMFiledesc::GetPath");
					if (m_bComponentBackup)
						DoAddToSnapshotSet(pvbc, bstrPath);

					ValidateFiledesc(pFiledesc);
					}
				}

			if (pInfo->cDatabases > 0)
				{
				for(i = 0; i < pInfo->cDatabases; i++)
					{
					CComPtr<IVssWMFiledesc> pFiledesc;
					hr = pComponent->GetDatabaseFile(i, &pFiledesc);
					ValidateResult(hr, "IVssWMComponent::GetDatabaseFile");
					
					
					CComBSTR bstrPath;
					hr = pFiledesc->GetPath(&bstrPath);
					ValidateResult(hr, "IVssWMFiledesc::GetPath");

					if (m_bComponentBackup)
						DoAddToSnapshotSet(pvbc, bstrPath);

					ValidateFiledesc(pFiledesc);
					}
				}

			if (pInfo->cLogFiles > 0)
				{
				for(i = 0; i < pInfo->cLogFiles; i++)
					{
					CComPtr<IVssWMFiledesc> pFiledesc;
					hr = pComponent->GetDatabaseLogFile(i, &pFiledesc);
					ValidateResult(hr, "IVssWMComponent::GetDatabaseLogFile");

					
					CComBSTR bstrPath;
					hr = pFiledesc->GetPath(&bstrPath);
					ValidateResult(hr, "IVssWMFiledesc::GetPath");
					if (m_bComponentBackup)
						DoAddToSnapshotSet(pvbc, bstrPath);

					ValidateFiledesc(pFiledesc);
					}
				}

			hr = pComponent->FreeComponentInfo(pInfo);
			ValidateResult(hr, "IVssWMComponent::FreeComponentInfo");
			}

		VSS_RESTOREMETHOD_ENUM method;
		CComBSTR bstrUserProcedure;
		CComBSTR bstrService;
		VSS_WRITERRESTORE_ENUM writerRestore;
		unsigned cMappings;
		bool bRebootRequired;

		hr = pMetadata->GetRestoreMethod
							(
							&method,
							&bstrService,
							&bstrUserProcedure,
							&writerRestore,
							&bRebootRequired,
							&cMappings
							);

        ValidateResult(hr, "IVssExamineWriterMetadata::GetRestoreMethod");

		for(i = 0; i < cMappings; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;

			hr = pMetadata->GetAlternateLocationMapping(i, &pFiledesc);
			ValidateResult(hr, "IVssExamineWriterMetadata::GetAlternateLocationMapping");
			ValidateFiledesc(pFiledesc);
			}
		}

	hr = pvbc->FreeWriterMetadata();
	ValidateResult(hr, "IVssBackupComponents::FreeWriterMetadata");
	}

void CVsBackupTest::ValidateFiledesc(IVssWMFiledesc *pFiledesc)
	{
	CComBSTR bstrPath;
	CComBSTR bstrFilespec;
	CComBSTR bstrAlternate;
	CComBSTR bstrDestination;
	bool bRecursive;

	HRESULT hr = pFiledesc->GetPath(&bstrPath);
	ValidateResult(hr, "IVssWMFiledesc::GetPath");
	hr = pFiledesc->GetFilespec(&bstrFilespec);
	ValidateResult(hr, "IVssWMFiledesc::GetFilespec");
	hr = pFiledesc->GetRecursive(&bRecursive);
	ValidateResult(hr, "IVssWMFiledesc::GetRecursive");
	hr = pFiledesc->GetAlternateLocation(&bstrAlternate);
	ValidateResult(hr, "IVssWMFiledesc::GetAlternateLocation");
	}


// add a component file to the snapshot set by determining which volume
// contains the file and then adding the file to the snapshot set if it
// is not already included.
void CVsBackupTest::DoAddToSnapshotSet
	(
	IN IVssBackupComponents *pvbc,
	IN LPCWSTR wszPath
	)
	{
	WCHAR wszVolume[MAX_PATH];
	UINT cwc = (UINT) wcslen(wszPath) + 1;
	WCHAR *wszVolumeMountPoint = new WCHAR[cwc];
	if (wszVolumeMountPoint == NULL)
		{
		LogFailure("Out of memory");
		throw E_OUTOFMEMORY;
		}

	if (!GetVolumePathName(wszPath, wszVolumeMountPoint, cwc))
		ValidateResult(HRESULT_FROM_WIN32(GetLastError()), "GetVolumePathName");

	if (!GetVolumeNameForVolumeMountPointW
			(
			wszVolumeMountPoint,
			wszVolume,
			MAX_PATH
			))
		ValidateResult(HRESULT_FROM_WIN32(GetLastError()), "GetVolumeNameForVolumeMountPointW");



	WCHAR *pwc = m_wszVolumesSnapshot;
	while(*pwc != '\0')
		{
		if (wcsncmp(pwc, wszVolume, wcslen(wszVolume)) == 0)
			return;

		pwc = wcschr(pwc, L';');
		if (pwc == NULL)
			break;

		pwc++;
		}
	

	HRESULT hr = pvbc->AddToSnapshotSet
						(
						wszVolume,
						GUID_NULL,
						L"",
						0,
						0,
						NULL,
						NULL
						);

    ValidateResult(hr, "IVssBackupComponents::AddToSnaphsotSet");
	if (pwc - m_wszVolumesSnapshot + wcslen(wszVolume) + 1 > m_cwcVolumesSnapshot)
		{
		WCHAR *wszVolumesNew = new WCHAR[m_cwcVolumesSnapshot + 1024];
		if(wszVolumesNew == NULL)
			{
			LogFailure("Out of memory");
			throw E_OUTOFMEMORY;
			}

		wcscpy(wszVolumesNew, m_wszVolumesSnapshot);
		delete m_wszVolumesSnapshot;
		m_wszVolumesSnapshot = wszVolumesNew;
		m_cwcVolumesSnapshot += 1024;
		pwc = m_wszVolumesSnapshot + wcslen(m_wszVolumesSnapshot);
		}

	*pwc++ = L';';
	wcscpy(pwc, wszVolume);
    }

// remove volumes for possible set of volume we can choose to backup based
// on configuration information
void CVsBackupTest::RemoveNonCandidateVolumes()
	{
	for(UINT iVolume = 0; iVolume < m_cVolumes; iVolume++)
		{
		// get volume information
		const CVsTstVolumeInfo *pVolume = m_volumeList.GetVolumeInfo(iVolume);
		bool bCandidate = false;

		// validate that file system is one we will backup
		if (pVolume->IsNtfs())
			bCandidate = m_bBackupNTFS;
		else if (pVolume->IsFat32())
			bCandidate = m_bBackupFAT32;
		else if (pVolume->IsFat())
			bCandidate = m_bBackupFAT16;
		else if (pVolume->IsRaw())
			bCandidate = m_bBackupRAW;

		// candidates must be in the included volumes list
		if (m_cIncludedVolumes > 0)
			{
			LPCWSTR wszVolumeName = pVolume->GetVolumeName();

			bool fFound = false;
			for(UINT iIncluded = 0; iIncluded < m_cIncludedVolumes; iIncluded++)
				{
				if (wcscmp(wszVolumeName, m_rgwszIncludedVolumes[iIncluded]) == 0)
					fFound = true;
				}

			if (!fFound)
				bCandidate = false;
			}

		// candidates must not be in the excluded volumes list
		if (m_cExcludedVolumes > 0)
			{
			LPCWSTR wszVolumeName = pVolume->GetVolumeName();

			for(UINT iExcluded = 0; iExcluded < m_cExcludedVolumes; iExcluded++)
				{
				if (wcscmp(wszVolumeName, m_rgwszExcludedVolumes[iExcluded]) == 0)
					bCandidate = false;
				}
			}

		// if it is not a candidate, mark it is if it is already in use.  This
		// will prevent us from choosing the volume as part of a snapshot set
		if (!bCandidate)
			{
			m_rgbAssignedVolumes[iVolume] = true;
			m_cVolumesLeft--;
			}
		}
	}

// pick a random volume to backup
void CVsBackupTest::ChooseVolumeToBackup(IVssBackupComponents *pvbc)
	{
	VSTST_ASSERT(m_cVolumesLeft > 0);

	UINT iVolume;
	while(TRUE)
		{
		// select a volume number
		iVolume = CVsTstRandom::RandomChoice(0, m_cVolumes-1);

		// check to see if volume is already assigned.  If not, then
		// break out of loop
		if (!m_rgbAssignedVolumes[iVolume])
			break;
		}

	// get volume information about volume
	const CVsTstVolumeInfo *pVolume = m_volumeList.GetVolumeInfo(iVolume);

	// add the volume to the snapshot set using the default provider
	HRESULT hr = pvbc->AddToSnapshotSet
							(
							(VSS_PWSZ) pVolume->GetVolumeName(),
							GUID_NULL,
							L"",
							0,
							0,
							NULL,
							NULL
							);

    ValidateResult(hr, "IVssBackupComponents::AddToSnapshotSet");

	// indicate that volume is assigned
	m_rgbAssignedVolumes[iVolume] = true;
	m_cVolumesLeft--;
	}



// main driver routine
extern "C" __cdecl wmain(int argc, WCHAR **argv)
	{
	CVsBackupTest *pTest = NULL;

	bool bCoInitializeSucceeded = false;
	try
		{
		// setup to use OLE
		HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if (FAILED(hr))
			{
			LogUnexpectedFailure(L"CoInitialize Failed hr = 0x%08lx", hr);
			throw hr;
			}

		bCoInitializeSucceeded = true;

		// create test object
        pTest = new CVsBackupTest;
		if (pTest == NULL)
			{
			LogUnexpectedFailure(L"Cannot create test object.");
			throw(E_OUTOFMEMORY);
			}


		// run test using the test object
        hr = CVsTstRunner::RunVsTest(argv, argc, pTest, true);
		if (FAILED(hr))
			LogUnexpectedFailure(L"CVsTstRunner::RunTest failed.  hr = 0x%08lx", hr);
		}
	catch(HRESULT)
		{
		}
	catch(...)
		{
		LogUnexpectedFailure(L"Unexpected exception in wmain");
		}

	// delete test object
	delete pTest;

	// uninitialize OLE
	if (bCoInitializeSucceeded)
		CoUninitialize();

	return 0;
	}


// log an unexpected failure from the test.
void LogUnexpectedFailure(LPCWSTR wsz, ...)
	{
	va_list args;

	va_start(args, wsz);

	VSTST_ASSERT(FALSE);
	vwprintf(wsz, args);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\common\assrt.cxx ===
/*++

Copyright (c) 200  Microsoft Corporation

Module Name:

    assrt.cxx

Abstract:
	assertion code used by VSTST_ASSERT

Author:


Revision History:
	Name		Date		Comments
	brianb		05/23/2000	created

--*/


#include "stdafx.h"


VOID
AssertFail
	(
    IN LPCSTR FileName,
    IN UINT LineNumber,
    IN LPCSTR Condition
    )
	{
    int i;
    CHAR Msg[4096];

    //
    // Use dll name as caption
    //
    sprintf(
        Msg,
        "Assertion failure at line %u in file %s in process %d thread %d: %s\n\nHit Cancel to break into the debugger.",
        LineNumber,
        FileName,
		GetCurrentProcessId(),
		GetCurrentThreadId(),
        Condition
        );

    i = MessageBoxA
			(
            NULL,
            Msg,
			"Volume Snapshots",
			MB_SYSTEMMODAL | MB_ICONSTOP | MB_OKCANCEL | MB_SERVICE_NOTIFICATION
            );

    if(i == IDCANCEL)
        DebugBreak();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\common\bsstring.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bsstring.cpp

Abstract:

    This module implements the CBsString class.  This class manages character
    arrays in a similar manner as the CString class in VC++.  In fact, this
    class is a copy of the CString class with the MFC specific stuff ripped
    out since LTS doesn't use MTF.

Author:

    Stefan R. Steiner   [SSteiner]      1-Mar-1998

Revision History:

    Stefan R. Steiner   [SSteiner]      10-Apr-2000
        Added fixed allocator code and resynced with MFC 6 SR-1 code
        
--*/

//#include "stdafx.h"
#include <windows.h>
#include "bsstring.hxx"
#include <malloc.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

struct _BSAFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };
struct _BSAFX_FLOAT   { BYTE floatBits[sizeof(float)]; };

// #define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

TCHAR bsafxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int _bsafxInitData[] = { -1, 0, 0, 0 };
static CBsStringData* _bsafxDataNil = (CBsStringData*)&_bsafxInitData;
static LPCTSTR _bsafxPchNil = (LPCTSTR)(((BYTE*)&_bsafxInitData)+sizeof(CBsStringData));
// special function to make bsafxEmptyString work even during initialization
const CBsString& BSAFXAPI BsAfxGetEmptyString()
	{ return *(CBsString*)&_bsafxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CBsString::CBsString()
{
	Init();
}

CBsString::CBsString(const CBsString& stringSrc)
{
	ASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ASSERT(stringSrc.GetData() != _bsafxDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

CBsString::CBsString(GUID guid)
{
	Init();
	AllocBuffer(38);
    _stprintf( m_pchData, _T("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
               guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1], 
               guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], 
               guid.Data4[6], guid.Data4[7] );
}

#ifndef _DEBUG

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

#define ROUND(x,y) (((x)+(y-1))&~(y-1))
#define ROUND4(x) ROUND(x, 4)
static CBsFixedAlloc _bsafxAlloc8(ROUND4(9*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc16(ROUND4(17*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc32(ROUND4(33*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc64(ROUND4(65*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc128(ROUND4(129*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc256(ROUND4(257*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc512(ROUND4(513*sizeof(TCHAR)+sizeof(CBsStringData)));

#endif //!_DEBUG

void CBsString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ASSERT(nLen >= 0);
	ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CBsStringData* pData;	    
#ifndef _DEBUG
		if (nLen <= 8)
		{
			pData = (CBsStringData*)_bsafxAlloc8.Alloc();
			pData->nAllocLength = 8;
		} 
		else if (nLen <= 16)
		{
			pData = (CBsStringData*)_bsafxAlloc16.Alloc();
			pData->nAllocLength = 16;
		} 
		else if (nLen <= 32)
		{
			pData = (CBsStringData*)_bsafxAlloc32.Alloc();
			pData->nAllocLength = 32;
		} 
		else if (nLen <= 64)
		{
			pData = (CBsStringData*)_bsafxAlloc64.Alloc();
			pData->nAllocLength = 64;
		}
		else if (nLen <= 128)
		{
			pData = (CBsStringData*)_bsafxAlloc128.Alloc();
			pData->nAllocLength = 128;
		}
		else if (nLen <= 256)
		{
			pData = (CBsStringData*)_bsafxAlloc256.Alloc();
			pData->nAllocLength = 256;
		}
		else if (nLen <= 512)
		{
			pData = (CBsStringData*)_bsafxAlloc512.Alloc();
			pData->nAllocLength = 512;
		}
		else
#endif
		{
			pData = (CBsStringData*)
				new BYTE[sizeof(CBsStringData) + (nLen+1)*sizeof(TCHAR)];
            if ( pData == NULL )
                throw E_OUTOFMEMORY;

			pData->nAllocLength = nLen;
		}
		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		m_pchData = pData->data();
	}
}

void FASTCALL CBsString::FreeData(CBsStringData* pData)
{
#ifndef _DEBUG
	int nLen = pData->nAllocLength;
	if (nLen == 8)
		_bsafxAlloc8.Free(pData);
	else if (nLen == 16)
		_bsafxAlloc16.Free(pData);
	else if (nLen == 32)
		_bsafxAlloc32.Free(pData);
	else if (nLen == 64)
		_bsafxAlloc64.Free(pData);
	else if (nLen == 128)
		_bsafxAlloc128.Free(pData);
	else if (nLen == 256)
		_bsafxAlloc256.Free(pData);
	else  if (nLen == 512)
		_bsafxAlloc512.Free(pData);
	else
	{
		ASSERT(nLen > 512);
		delete[] (BYTE*)pData;
	}
#else
	delete[] (BYTE*)pData;
#endif
}

void CBsString::Release()
{
	if (GetData() != _bsafxDataNil)
	{
		ASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			FreeData(GetData());
		Init();
	}
}

void PASCAL CBsString::Release(CBsStringData* pData)
{
	if (pData != _bsafxDataNil)
	{
		ASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			FreeData(pData);
	}
}

void CBsString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &bsafxChNil;
	ASSERT(GetData()->nDataLength == 0);
	ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

void CBsString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CBsStringData* pData = GetData();
		Release();
		AllocBuffer(pData->nDataLength);
		memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ASSERT(GetData()->nRefs <= 1);
}

void CBsString::AllocBeforeWrite(int nLen)
{
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		AllocBuffer(nLen);
	}
	ASSERT(GetData()->nRefs <= 1);
}

CBsString::~CBsString()
//  free any attached data
{
	if (GetData() != _bsafxDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			FreeData(GetData());
	}
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CBsString::AllocCopy(CBsString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CBsString::CBsString(LPCTSTR lpsz)
{
	Init();
	int nLen = SafeStrlen(lpsz);
	if (nLen != 0)
	{
		AllocBuffer(nLen);
		memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CBsString::CBsString(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen);
		_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
}
#else //_UNICODE
CBsString::CBsString(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen*2);
		_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CBsString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CBsString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	AllocBeforeWrite(nSrcLen);
	memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
	GetData()->nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
}

const CBsString& CBsString::operator=(const CBsString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != _bsafxDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ASSERT(stringSrc.GetData() != _bsafxDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

const CBsString& CBsString::operator=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CBsString& CBsString::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	AllocBeforeWrite(nSrcLen);
	_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
	ReleaseBuffer();
	return *this;
}
#else //!_UNICODE
const CBsString& CBsString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	AllocBeforeWrite(nSrcLen*2);
	_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
	ReleaseBuffer();
	return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CBsString + CBsString
// and for ? = TCHAR, LPCTSTR
//          CBsString + ?
//          ? + CBsString

void CBsString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CBsString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		AllocBuffer(nNewLen);
		memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
		memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
	}
}

CBsString BSAFXAPI operator+(const CBsString& string1, const CBsString& string2)
{
	CBsString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

CBsString BSAFXAPI operator+(const CBsString& string, LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	CBsString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
		CBsString::SafeStrlen(lpsz), lpsz);
	return s;
}

CBsString BSAFXAPI operator+(LPCTSTR lpsz, const CBsString& string)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	CBsString s;
	s.ConcatCopy(CBsString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CBsString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CBsStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ASSERT(pOldData != NULL);
		CBsString::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

const CBsString& CBsString::operator+=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CBsString& CBsString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

const CBsString& CBsString::operator+=(const CBsString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CBsString::GetBuffer(int nMinBufLength)
{
	ASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CBsStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
		GetData()->nDataLength = nOldLen;
		CBsString::Release(pOldData);
	}
	ASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

void CBsString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

LPTSTR CBsString::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

void CBsString::FreeExtra()
{
	ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CBsStringData* pOldData = GetData();
		AllocBuffer(GetData()->nDataLength);
		memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
		ASSERT(m_pchData[GetData()->nDataLength] == '\0');
		CBsString::Release(pOldData);
	}
	ASSERT(GetData() != NULL);
}

LPTSTR CBsString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

void CBsString::UnlockBuffer()
{
	ASSERT(GetData()->nRefs == -1);
	if (GetData() != _bsafxDataNil)
		GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CBsString::Find(TCHAR ch) const
{
	return Find(ch, 0);
}

int CBsString::Find(TCHAR ch, int nStart) const
{
	int nLength = GetData()->nDataLength;
	if (nStart >= nLength)
		return -1;

	// find first single character
	LPTSTR lpsz = _tcschr(m_pchData + nStart, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CBsString::FindOneOf(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

void CBsString::MakeUpper()
{
	CopyBeforeWrite();
	_tcsupr(m_pchData);
}

void CBsString::MakeLower()
{
	CopyBeforeWrite();
	_tcslwr(m_pchData);
}

void CBsString::MakeReverse()
{
	CopyBeforeWrite();
	_tcsrev(m_pchData);
}

void CBsString::SetAt(int nIndex, TCHAR ch)
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CBsString::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
void CBsString::OemToAnsi()
{
	CopyBeforeWrite();
	::OemToAnsi(m_pchData, m_pchData);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CBsString conversion helpers (these use the current system locale)

int BSAFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, (INT)count, NULL, NULL);
	ASSERT(mbstr == NULL || result <= (int)count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

int BSAFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, (INT)count);
	ASSERT(wcstr == NULL || result <= (int)count);
	if (result > 0)
		wcstr[result-1] = 0;
	return result;
}

LPWSTR BSAFXAPI BsAfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	if (lpa == NULL)
		return NULL;
	ASSERT(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
	return lpw;
    UNREFERENCED_PARAMETER( nChars );
}

LPSTR BSAFXAPI BsAfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	if (lpw == NULL)
		return NULL;
	ASSERT(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
    UNREFERENCED_PARAMETER( nChars );
}


//
//  the following is from strex.cpp
//

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CBsString::CBsString(TCHAR ch, int nLength)
{
	Init();
	if (nLength >= 1)
	{
		AllocBuffer(nLength);
#ifdef _UNICODE
		for (int i = 0; i < nLength; i++)
			m_pchData[i] = ch;
#else
		memset(m_pchData, ch, nLength);
#endif
	}
}

CBsString::CBsString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
		ASSERT(BsAfxIsValidAddress(lpch, nLength, FALSE));
		AllocBuffer(nLength);
		memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CBsString::CBsString(LPCSTR lpsz, int nLength)
{
	Init();
	if (nLength != 0)
	{
		AllocBuffer(nLength);
		int n = ::MultiByteToWideChar(CP_ACP, 0, lpsz, nLength, m_pchData, nLength+1);
		ReleaseBuffer(n >= 0 ? n : -1);
	}
}
#else //_UNICODE
CBsString::CBsString(LPCWSTR lpsz, int nLength)
{
	Init();
	if (nLength != 0)
	{
		AllocBuffer(nLength*2);
		int n = ::WideCharToMultiByte(CP_ACP, 0, lpsz, nLength, m_pchData,
			(nLength*2)+1, NULL, NULL);
		ReleaseBuffer(n >= 0 ? n : -1);
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CBsString& CBsString::operator=(TCHAR ch)
{
	AssignCopy(1, &ch);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CBsString BSAFXAPI operator+(const CBsString& string1, TCHAR ch)
{
	CBsString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

CBsString BSAFXAPI operator+(TCHAR ch, const CBsString& string)
{
	CBsString s;
	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// Advanced manipulation

int CBsString::Delete(int nIndex, int nCount /* = 1 */)
{
	if (nIndex < 0)
		nIndex = 0;
	int nNewLength = GetData()->nDataLength;
	if (nCount > 0 && nIndex < nNewLength)
	{
		CopyBeforeWrite();
		int nBytesToCopy = nNewLength - (nIndex + nCount) + 1;

		memcpy(m_pchData + nIndex,
			m_pchData + nIndex + nCount, nBytesToCopy * sizeof(TCHAR));
		GetData()->nDataLength = nNewLength - nCount;
	}

	return nNewLength;
}

int CBsString::Insert(int nIndex, TCHAR ch)
{
	CopyBeforeWrite();

	if (nIndex < 0)
		nIndex = 0;

	int nNewLength = GetData()->nDataLength;
	if (nIndex > nNewLength)
		nIndex = nNewLength;
	nNewLength++;

	if (GetData()->nAllocLength < nNewLength)
	{
		CBsStringData* pOldData = GetData();
		LPTSTR pstr = m_pchData;
		AllocBuffer(nNewLength);
		memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(TCHAR));
		CBsString::Release(pOldData);
	}

	// move existing bytes down
	memcpy(m_pchData + nIndex + 1,
		m_pchData + nIndex, (nNewLength-nIndex)*sizeof(TCHAR));
	m_pchData[nIndex] = ch;
	GetData()->nDataLength = nNewLength;

	return nNewLength;
}

int CBsString::Insert(int nIndex, LPCTSTR pstr)
{
	if (nIndex < 0)
		nIndex = 0;

	int nInsertLength = SafeStrlen(pstr);
	int nNewLength = GetData()->nDataLength;
	if (nInsertLength > 0)
	{
		CopyBeforeWrite();
		if (nIndex > nNewLength)
			nIndex = nNewLength;
		nNewLength += nInsertLength;

		if (GetData()->nAllocLength < nNewLength)
		{
			CBsStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			AllocBuffer(nNewLength);
			memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(TCHAR));
			CBsString::Release(pOldData);
		}

		// move existing bytes down
		memcpy(m_pchData + nIndex + nInsertLength,
			m_pchData + nIndex,
			(nNewLength-nIndex-nInsertLength+1)*sizeof(TCHAR));
		memcpy(m_pchData + nIndex,
			pstr, nInsertLength*sizeof(TCHAR));
		GetData()->nDataLength = nNewLength;
	}

	return nNewLength;
}

int CBsString::Replace(TCHAR chOld, TCHAR chNew)
{
	int nCount = 0;

	// short-circuit the nop case
	if (chOld != chNew)
	{
		// otherwise modify each character that matches in the string
		CopyBeforeWrite();
		LPTSTR psz = m_pchData;
		LPTSTR pszEnd = psz + GetData()->nDataLength;
		while (psz < pszEnd)
		{
			// replace instances of the specified character only
			if (*psz == chOld)
			{
				*psz = chNew;
				nCount++;
			}
			psz = _tcsinc(psz);
		}
	}
	return nCount;
}

int CBsString::Replace(LPCTSTR lpszOld, LPCTSTR lpszNew)
{
	// can't have empty or NULL lpszOld

	int nSourceLen = SafeStrlen(lpszOld);
	if (nSourceLen == 0)
		return 0;
	int nReplacementLen = SafeStrlen(lpszNew);

	// loop once to figure out the size of the result string
	int nCount = 0;
	LPTSTR lpszStart = m_pchData;
	LPTSTR lpszEnd = m_pchData + GetData()->nDataLength;
	LPTSTR lpszTarget;
	while (lpszStart < lpszEnd)
	{
		while ((lpszTarget = _tcsstr(lpszStart, lpszOld)) != NULL)
		{
			nCount++;
			lpszStart = lpszTarget + nSourceLen;
		}
		lpszStart += lstrlen(lpszStart) + 1;
	}

	// if any changes were made, make them
	if (nCount > 0)
	{
		CopyBeforeWrite();

		// if the buffer is too small, just
		//   allocate a new buffer (slow but sure)
		int nOldLength = GetData()->nDataLength;
		int nNewLength =  nOldLength + (nReplacementLen-nSourceLen)*nCount;
		if (GetData()->nAllocLength < nNewLength || GetData()->nRefs > 1)
		{
			CBsStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			AllocBuffer(nNewLength);
			memcpy(m_pchData, pstr, pOldData->nDataLength*sizeof(TCHAR));
			CBsString::Release(pOldData);
		}
		// else, we just do it in-place
		lpszStart = m_pchData;
		lpszEnd = m_pchData + GetData()->nDataLength;

		// loop again to actually do the work
		while (lpszStart < lpszEnd)
		{
			while ( (lpszTarget = _tcsstr(lpszStart, lpszOld)) != NULL)
			{
				int nBalance = nOldLength - (int)(lpszTarget - m_pchData + nSourceLen);
				memmove(lpszTarget + nReplacementLen, lpszTarget + nSourceLen,
					nBalance * sizeof(TCHAR));
				memcpy(lpszTarget, lpszNew, nReplacementLen*sizeof(TCHAR));
				lpszStart = lpszTarget + nReplacementLen;
				lpszStart[nBalance] = '\0';
				nOldLength += (nReplacementLen - nSourceLen);
			}
			lpszStart += lstrlen(lpszStart) + 1;
		}
		ASSERT(m_pchData[nNewLength] == '\0');
		GetData()->nDataLength = nNewLength;
	}

	return nCount;
}

int CBsString::Remove(TCHAR chRemove)
{
	CopyBeforeWrite();

	LPTSTR pstrSource = m_pchData;
	LPTSTR pstrDest = m_pchData;
	LPTSTR pstrEnd = m_pchData + GetData()->nDataLength;

	while (pstrSource < pstrEnd)
	{
		if (*pstrSource != chRemove)
		{
			*pstrDest = *pstrSource;
			pstrDest = _tcsinc(pstrDest);
		}
		pstrSource = _tcsinc(pstrSource);
	}
	*pstrDest = '\0';
	int nCount = ( int )( pstrSource - pstrDest );
	GetData()->nDataLength -= nCount;

	return nCount;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CBsString CBsString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CBsString CBsString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	ASSERT(nFirst >= 0);
	ASSERT(nFirst + nCount <= GetData()->nDataLength);

	// optimize case of returning entire string
	if (nFirst == 0 && nFirst + nCount == GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

CBsString CBsString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	if (nCount >= GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

CBsString CBsString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	if (nCount >= GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
CBsString CBsString::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	return Left((INT)_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CBsString CBsString::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	return Left((INT)_tcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CBsString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CBsString::Find(LPCTSTR lpszSub) const
{
	return Find(lpszSub, 0);
}

int CBsString::Find(LPCTSTR lpszSub, int nStart) const
{
	ASSERT(BsAfxIsValidString(lpszSub));

	int nLength = GetData()->nDataLength;
	if (nStart > nLength)
		return -1;

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData + nStart, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// CBsString formatting

#define TCHAR_ARG   TCHAR
#define WCHAR_ARG   WCHAR
#define CHAR_ARG    char

#ifdef _X86_
	#define DOUBLE_ARG  _BSAFX_DOUBLE
#else
	#define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000
#define FORCE_INT64		0x40000

void CBsString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	ASSERT(BsAfxIsValidString(lpszFormat));

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	
	int nMaxLen = 16 * 1024;  // Don't expect it to be larger than this - SRS

#if 0	
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
		{
			nMaxLen += (INT)_tclen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
				*lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
				;
		}
		ASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = _tcsinc(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = _tcsinc(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
					;
			}
			ASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		if (_tcsncmp(lpsz, _T("I64"), 3) == 0)
		{
			lpsz += 3;
			nModifier = FORCE_INT64;
#if !defined(_X86_) && !defined(_ALPHA_)
			// __int64 is only available on X86 and ALPHA platforms
			ASSERT(FALSE);
#endif
		}
		else
		{
			switch (*lpsz)
			{
			// modifiers that affect size
			case 'h':
				nModifier = FORCE_ANSI;
				lpsz = _tcsinc(lpsz);
				break;
			case 'l':
				nModifier = FORCE_UNICODE;
				lpsz = _tcsinc(lpsz);
				break;

			// modifiers that do not affect size
			case 'F':
			case 'N':
			case 'L':
				lpsz = _tcsinc(lpsz);
				break;
			}
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR_ARG);
			break;
		case 'c'|FORCE_ANSI:
		case 'C'|FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, CHAR_ARG);
			break;
		case 'c'|FORCE_UNICODE:
		case 'C'|FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR_ARG);
			break;

		// strings
		case 's':
			{
				LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6;  // "(null)"
				else
				{
				   nItemLen = lstrlen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;

		case 'S':
			{
#ifndef _UNICODE
				LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6;  // "(null)"
				else
				{
				   nItemLen = wcslen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
#else
				LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = lstrlenA(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
#endif
			}
			break;

		case 's'|FORCE_ANSI:
		case 'S'|FORCE_ANSI:
			{
				LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = lstrlenA(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;

		case 's'|FORCE_UNICODE:
		case 'S'|FORCE_UNICODE:
			{
				LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = (INT)wcslen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
			nItemLen = max(nItemLen, nWidth);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				if (nModifier & FORCE_INT64)
					va_arg(argList, __int64);
				else
					va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'e':
			case 'g':
			case 'G':
				va_arg(argList, DOUBLE_ARG);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'f':
				{
					double f;
					LPTSTR pszTemp;

					// 312 == strlen("-1+(309 zeroes).")
					// 309 zeroes == max precision of a double
					// 6 == adjustment in case precision is not specified,
					//   which means that the precision defaults to 6
					pszTemp = (LPTSTR)_alloca(max(nWidth, 312+nPrecision+6));

					f = va_arg(argList, double);
					_stprintf( pszTemp, _T( "%*.*f" ), nWidth, nPrecision+6, f );
					nItemLen = _tcslen(pszTemp);
				}
				break;

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}
#endif

	GetBuffer(nMaxLen);
	INT i = _vstprintf(m_pchData, lpszFormat, argListSave);
	ASSERT( i <= GetAllocLength() );
	ReleaseBuffer();

	va_end(argListSave);
}

// formatting (using wsprintf style formatting)
const CBsString& BSAFX_CDECL CBsString::Format(LPCTSTR lpszFormat, ...)
{
	ASSERT(BsAfxIsValidString(lpszFormat));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);

	return *this;
}

void CBsString::TrimRight(LPCTSTR lpszTargetList)
{
	// find beginning of trailing matches
	// by starting at beginning (DBCS aware)

	CopyBeforeWrite();
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;

	while (*lpsz != '\0')
	{
		if (_tcschr(lpszTargetList, *lpsz) != NULL)
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at left-most matching character
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}

void CBsString::TrimRight(TCHAR chTarget)
{
	// find beginning of trailing matches
	// by starting at beginning (DBCS aware)

	CopyBeforeWrite();
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;

	while (*lpsz != '\0')
	{
		if (*lpsz == chTarget)
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at left-most matching character
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}


void CBsString::TrimRight()
{
	// find beginning of trailing spaces by starting at beginning (DBCS aware)

	CopyBeforeWrite();
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	
	while (*lpsz != '\0')
	{
		if (_istspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}

void CBsString::TrimLeft(LPCTSTR lpszTargets)
{
	// if we're not trimming anything, we're not doing any work
	if (SafeStrlen(lpszTargets) == 0)
		return;

	CopyBeforeWrite();
	LPCTSTR lpsz = m_pchData;

	while (*lpsz != '\0')
	{
		if (_tcschr(lpszTargets, *lpsz) == NULL)
			break;
		lpsz = _tcsinc(lpsz);
	}

	if (lpsz != m_pchData)
	{
		// fix up data and length
		int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
		memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
		GetData()->nDataLength = nDataLength;
	}
}

void CBsString::TrimLeft(TCHAR chTarget)
{
	// find first non-matching character

	CopyBeforeWrite();
	LPCTSTR lpsz = m_pchData;

	while (chTarget == *lpsz)
		lpsz = _tcsinc(lpsz);

	if (lpsz != m_pchData)
	{
		// fix up data and length
		int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
		memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
		GetData()->nDataLength = nDataLength;
	}
}

void CBsString::TrimLeft()
{
	// find first non-space character

	CopyBeforeWrite();
	LPCTSTR lpsz = m_pchData;
	
	while (_istspace(*lpsz))
		lpsz = _tcsinc(lpsz);

	if (lpsz != m_pchData)
	{
    	// fix up data and length
    	int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
    	memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
    	GetData()->nDataLength = nDataLength;
	}
}


//
//  From validadd.cpp
//

BOOL BSAFXAPI BsAfxIsValidString(LPCWSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrW(lpsz, nLength) == 0;
}

BOOL BSAFXAPI BsAfxIsValidString(LPCSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrA(lpsz, nLength) == 0;
}

BOOL BSAFXAPI BsAfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\common\vststmsg.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vststmsg.cxx

Abstract:

    Implementation of test message classes for the server


    Brian Berkowitz  [brianb]  05/22/2000

TBD:
	

Revision History:

    Name        Date        Comments
    brianb      05/22/2000  Created
    ssteiner    06/07/2000  Split client and server portions into
                            two files.  vststmsgclient.cxx contains
                            the client portion.

--*/


#include <stdafx.h>
#include <vststmsg.hxx>
#include <vststmsghandler.hxx>

void LogUnexpectedFailure(LPCWSTR wsz, ...);

/*++

Routine Description:

    This needs to be run once on the server side to install all of the message handlers.

Arguments:

    None

Return Value:

    <Enter return values here>

--*/
static void
InstallServerMsgHandlers()
{
    g_msgTypes[VSTST_MT_TEXT].pfnHandler                = CVsTstMsgHandlerRoutines::PrintMessage;
    g_msgTypes[VSTST_MT_IMMEDIATETEXT].pfnHandler       = CVsTstMsgHandlerRoutines::PrintMessage;
    g_msgTypes[VSTST_MT_FAILURE].pfnHandler             = CVsTstMsgHandlerRoutines::HandleFailure;
    g_msgTypes[VSTST_MT_OPERATIONFAILURE].pfnHandler    = CVsTstMsgHandlerRoutines::HandleOperationFailure;
    g_msgTypes[VSTST_MT_UNEXPECTEDEXCEPTION].pfnHandler = CVsTstMsgHandlerRoutines::HandleUnexpectedException;
    g_msgTypes[VSTST_MT_SUCCESS].pfnHandler             = CVsTstMsgHandlerRoutines::HandleSuccess;
}

CVsTstMsgHandler::CVsTstMsgHandler(
    IN LPCWSTR pwszLogFileName
    ) :
	m_bcsQueueInitialized(false),
	m_pmsgFirst(NULL),
	m_pmsgLast(NULL),
	m_cbMaxMsgLength(0),
	m_hThreadReader(NULL),
	m_hThreadWorker(NULL),
	m_hevtWorker(NULL),
	m_hevtReader(NULL),
	m_bReadEnabled(false),
	m_bTerminateWorker(false),
	m_bTerminateReader(false),
    m_pipeList(NULL),
    m_bcsPipeListInitialized(false),
    m_cNtLog( pwszLogFileName )
	{
	    //
	    //  Initialize the general message types array and install the message
	    //  handlers.
	    //
	    InitMsgTypes();
	    InstallServerMsgHandlers();
	}

// free data allocated by the class
void CVsTstMsgHandler::FreeData()
	{
	if (m_bcsQueueInitialized)
		{
		m_csQueue.Term();
		m_bcsQueueInitialized = false;
		}

    if (m_bcsPipeListInitialized)
		{
        m_csPipeList.Term();
		m_bcsPipeListInitialized = false;
		}

	while(m_pmsgFirst)
		{
		VSTST_MSG_HDR *pmsgNext = m_pmsgFirst->pmsgNext;
		delete m_pmsgFirst;
		m_pmsgFirst = pmsgNext;
		}

	if (m_hThreadWorker)
		{
		CloseHandle(m_hThreadWorker);
		m_hThreadWorker = NULL;
		}

	if (m_hevtWorker)
		{
		CloseHandle(m_hevtWorker);
		m_hevtWorker = NULL;
		}

	if (m_hevtReader)
		{
		CloseHandle(m_hevtReader);
		m_hevtReader = NULL;
		}
	}


CVsTstMsgHandler::~CVsTstMsgHandler()
	{
	ForceTermination();

	FreeData();
	}
	

// initailize message handler and worker thread
HRESULT CVsTstMsgHandler::Initialize(UINT cbMaxMsg)
	{
	m_cbMaxMsgLength = cbMaxMsg;
	try
		{
		m_csQueue.Init();
		m_bcsQueueInitialized = true;
        m_csPipeList.Init();
        m_bcsPipeListInitialized = true;
		}
	catch(...)
		{
		return E_UNEXPECTED;
		}

	HRESULT hr = S_OK;

	m_hevtWorker = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (m_hevtWorker == NULL)
		goto _ErrExit;

	m_hevtReader = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (m_hevtReader == NULL)
		goto _ErrExit;

	DWORD tid;

	m_hThreadWorker = CreateThread
							(
							NULL,
							64*1024,
							StartWorkerThread,
							this,
							0,
							&tid
							);


	if (m_hThreadWorker == NULL)
		goto _ErrExit;

    return S_OK;

_ErrExit:
	hr = HRESULT_FROM_WIN32(GetLastError());

	FreeData();
	return hr;
	}


// adjust message pointers
bool CVsTstMsgHandler::AdjustPointers(VSTST_MSG_HDR *phdr)
	{
	VSTST_MSG_TYPE_TABLE *pType = &g_msgTypes[phdr->type];
	BYTE *pb = phdr->rgb;
	VOID **ppv = (VOID **) (pb + pType->cbFixed);
	pb = (BYTE *) (ppv + pType->cVarPtr);
	for(unsigned iVarPtr = 0; iVarPtr < pType->cVarPtr; iVarPtr++, ppv++)
		{
		*ppv = pb;
		size_t cb;
		switch(pType->pointerTypes[iVarPtr])
			{
			default:
				return false;

			case VSTST_VPT_BYTE:
				cb = *(UINT *) pb;
				break;

            case VSTST_VPT_ANSI:
				cb = strlen((char *) pb) + 1;
				break;

            case VSTST_VPT_UNICODE:
				cb = (wcslen((WCHAR *) pb) + 1) * sizeof(WCHAR);
				break;
            }

		// align to pointer boundary
		cb = (cb + sizeof(PVOID) - 1) & ~(sizeof(PVOID) - 1);
		pb += cb;
		}

	return true;
	}

// process message immediately
bool CVsTstMsgHandler::ProcessMsgImmediate(VSTST_MSG_HDR *phdr)
	{
	if (!AdjustPointers(phdr))
		return false;

	VSTST_MSG_TYPE_TABLE *pType = &g_msgTypes[phdr->type];
	try
		{
		pType->pfnHandler(phdr, &m_cNtLog);
		}
	catch(...)
		{
		return false;
		}

	return true;
	}

// queue message for worker thrad
bool CVsTstMsgHandler::QueueMsg(VSTST_MSG_HDR *phdr)
	{
	BYTE *pbMsg = new BYTE[phdr->cbMsg];
	if (pbMsg == NULL)
		// can't allocate message, wait for queue to of messages
		// to complete and then process messages serially
		{
		WaitForQueueToComplete();
		return ProcessMsgImmediate(phdr);
		}

	memcpy(pbMsg, phdr, phdr->cbMsg);
	VSTST_MSG_HDR *phdrT = (VSTST_MSG_HDR *) pbMsg;
	if (!AdjustPointers(phdrT))
		return false;

	m_csQueue.Lock();
	if (m_pmsgLast == NULL)
		{
		VSTST_ASSERT(m_pmsgFirst == NULL);
		m_pmsgLast = m_pmsgFirst = phdrT;
		SetEvent(m_hevtWorker);
		}
	else
		{
		VSTST_ASSERT(m_pmsgLast->pmsgNext == NULL);
		m_pmsgLast->pmsgNext = phdrT;

		// replace last element on queue
		m_pmsgLast = phdrT;
		}

	m_csQueue.Unlock();
	return true;
	}


// execute items on the work queue
bool CVsTstMsgHandler::DoWork()
	{		
	//  Add this thread as a participant
	m_cNtLog.AddParticipant();
	
	//  For now start the one and only variation
	m_cNtLog.StartVariation( L"VssTestController" );
		
	while(TRUE)
		{
		// wait for something to get on the work queue or for 1 second
		if (WaitForSingleObject(m_hevtWorker, 1000) == WAIT_FAILED)
		{
		    //  Log severe error
		    m_cNtLog.Log( eSevLev_Severe, L"CVsTstMsgHandler::DoWork, WaitForSingleObject returned WAIT_FAILED, dwRet: %d", ::GetLastError() );

		    //  End the variation
        	m_cNtLog.EndVariation();

            //  Remove the thread as a participant
        	m_cNtLog.RemoveParticipant();
		
			return false;
		}
		
		while(TRUE)
			{
			// lock queue
			m_csQueue.Lock();

			// check whether queue is empty
			if (m_pmsgFirst == NULL)
				{
				VSTST_ASSERT(m_pmsgLast == NULL);

				// check whether we should terminate the thread
				if (m_bTerminateWorker)
					{
					// terminate thread
					m_csQueue.Unlock();
					
                	//  End the variation
                	m_cNtLog.EndVariation();
                	
                    //  Remove the thread as a participant
                	m_cNtLog.RemoveParticipant();
		
					return true;
					}

				// setup to wait again
				ResetEvent(m_hevtWorker);
				m_csQueue.Unlock();
				break;
				}

			// pull first message off of queue
			VSTST_MSG_HDR *phdr = m_pmsgFirst;

			// move head of queue to next element
			m_pmsgFirst = m_pmsgFirst->pmsgNext;

			// is queue now empty
			if (m_pmsgFirst == NULL)
				{
				VSTST_ASSERT(m_pmsgLast == phdr);

				// set tail of queue to null
				m_pmsgLast = NULL;
				}

			// unlock queue before executing item
			m_csQueue.Unlock();

			// execute item
			VSTST_MSG_TYPE_TABLE *pType = &g_msgTypes[phdr->type];
			try
				{
				pType->pfnHandler(phdr, &m_cNtLog );
				}
			catch(...)
				{
    		    //  Log severe error
    		    m_cNtLog.Log( eSevLev_Severe, L"CVsTstMsgHandler::DoWork, caught unexpected exception from message handler" );

    		    //  End the variation
            	m_cNtLog.EndVariation();
    		
                //  Remove the thread as a participant
            	m_cNtLog.RemoveParticipant();
		
				return false;
				}
			}
		}

	return true;
	}


// terminate worker thread, waiting for all work to complete
void CVsTstMsgHandler::WaitForQueueToComplete()
	{
	m_bTerminateWorker = true;
	if (WaitForSingleObject(m_hThreadWorker, INFINITE) == WAIT_FAILED)
		{
		// polling way to wait if we wait fails.  Note that we usually
		// would only expect to get here in stress situations
		while(TRUE)
			{
			m_csQueue.Lock();
			if (m_pmsgFirst == NULL)
				{
				m_csQueue.Unlock();
				break;
				}

			m_csQueue.Unlock();
			Sleep(100);
			}
		}
	}


DWORD CVsTstMsgHandler::StartWorkerThread(VOID *pv)
	{
	CVsTstMsgHandler *pHandler = (CVsTstMsgHandler *) pv;

	try
		{
		pHandler->DoWork();
		}
	catch(...)
		{
		LogUnexpectedFailure(L"Worker thread unexpectedly terminated");
		}

	return 0;
	}

void CVsTstMsgHandler::StartProcessingMessages()
	{
	m_bReadEnabled = true;
	SetEvent(m_hevtReader);
	}

void CVsTstMsgHandler::StopProcessingMessages()
	{
	ResetEvent(m_hevtReader);
	m_bReadEnabled = false;
	}

void CVsTstMsgHandler::ForceTermination()
	{
	m_bReadEnabled = false;
	m_bTerminateWorker = true;
	m_bTerminateReader = true;
	SetEvent(m_hevtReader);
	if (m_hThreadWorker)
		{
		DWORD dwErr = WaitForSingleObject(m_hThreadWorker, 5000);
		if (dwErr == WAIT_FAILED || dwErr == WAIT_TIMEOUT)
			// force termination of worker thread
			TerminateThread(m_hThreadWorker, 1);

		CloseHandle(m_hThreadWorker);
		m_hThreadWorker = NULL;
		}

    m_csPipeList.Lock();

    while(m_pipeList != NULL)
        {
		CVsTstPipe *pipe = m_pipeList;
		HANDLE hThread = pipe->m_hThreadReader;
		pipe->m_hThreadReader = NULL;
		m_csPipeList.Unlock();
        m_pipeList->ForceTermination(hThread);
		m_csPipeList.Lock();
		if (m_pipeList == pipe)
			delete m_pipeList;
        }

    m_csPipeList.Unlock();
	}

// launch a pipe reader thread
HRESULT CVsTstMsgHandler::LaunchReader()
    {
    CVsTstPipe *pipe = new CVsTstPipe(this);
    if (pipe == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = pipe->Initialize(m_cbMaxMsgLength);
    if (FAILED(hr))
        {
        delete pipe;
        return hr;
        }

    return S_OK;
    }


// link pipe into pipe list
void CVsTstMsgHandler::LinkPipe(CVsTstPipe *pipe)
    {
    VSTST_ASSERT(!pipe->m_bLinked);
    m_csPipeList.Lock();
    pipe->m_prev = NULL;
    pipe->m_next = m_pipeList;
	if (m_pipeList)
		{
		VSTST_ASSERT(m_pipeList->m_prev == NULL);
        m_pipeList->m_prev = pipe;
		}

    m_pipeList = pipe;
    m_csPipeList.Unlock();
    pipe->m_bLinked = true;
    }

// unlink pipe from pipe list
void CVsTstMsgHandler::UnlinkPipe(CVsTstPipe *pipe)
    {
    VSTST_ASSERT(pipe->m_bLinked);
    m_csPipeList.Lock();
    if (pipe->m_prev == NULL)
        {
        VSTST_ASSERT(m_pipeList == pipe);
        m_pipeList = pipe->m_next;
        if (m_pipeList)
            {
            VSTST_ASSERT(m_pipeList->m_prev == pipe);
            m_pipeList->m_prev = NULL;
            }
        }
    else
        {
        VSTST_ASSERT(pipe->m_prev->m_next == pipe);
        pipe->m_prev->m_next = pipe->m_next;
        if (pipe->m_next)
            {
            VSTST_ASSERT(pipe->m_next->m_prev == pipe);
            pipe->m_next->m_prev = pipe->m_prev;
            }
        }

    m_csPipeList.Unlock();
    pipe->m_bLinked = false;
    }


// constructor for a pipe
CVsTstPipe::CVsTstPipe(CVsTstMsgHandler *pHandler) :
    m_hPipe(NULL),
    m_hevtOverlapped(NULL),
    m_rgbMsg(NULL),
    m_cbMsg(0),
    m_hThreadReader(NULL),
    m_bLinked(NULL),
    m_pHandler(pHandler),
	m_bConnected(false)
    {
    }

// destructor for a pipe
CVsTstPipe::~CVsTstPipe()
    {
	// unlink pipe from list if linked
    if (m_bLinked)
        {
        VSTST_ASSERT(m_pHandler);
        m_pHandler->UnlinkPipe(this);
        }

    FreeData();
    }


// initailize message handler and worker thread
HRESULT CVsTstPipe::Initialize(UINT cbMaxMsg)
	{
	HRESULT hr = S_OK;

	// create pipe
	m_hPipe = CreateNamedPipe
				(
				s_wszPipeName,
				FILE_FLAG_OVERLAPPED|PIPE_ACCESS_INBOUND,
				PIPE_TYPE_MESSAGE|PIPE_READMODE_MESSAGE|PIPE_WAIT,
				PIPE_UNLIMITED_INSTANCES,
				0,
				cbMaxMsg,
				100,
				NULL
				);

    if (m_hPipe == INVALID_HANDLE_VALUE)
		return HRESULT_FROM_WIN32(GetLastError());

	// create message buffer
	m_cbMsg = cbMaxMsg;
	m_rgbMsg = new BYTE[m_cbMsg];
	if (m_rgbMsg == NULL)
		{
		hr = E_OUTOFMEMORY;
		goto _ErrCleanup;
		}

	// create overlapped read event
	m_hevtOverlapped = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (m_hevtOverlapped == NULL)
		goto _ErrExit;



	// create reader thread
	DWORD tid;
	m_hThreadReader = CreateThread
							(
							NULL,
							256*1024,
							StartReaderThread,
							this,
							0,
							&tid
							);

    if (m_hThreadReader == NULL)
		goto _ErrExit;

	// link pipe into list
    m_pHandler->LinkPipe(this);

    return S_OK;

_ErrExit:
	hr = HRESULT_FROM_WIN32(GetLastError());

_ErrCleanup:
	FreeData();
	return hr;
	}


// free data allocated by the class
void CVsTstPipe::FreeData()
	{
	delete m_rgbMsg;
	m_rgbMsg = NULL;

	if (m_hPipe != INVALID_HANDLE_VALUE)
		{
		// disconnect pipe if connected
		if (m_bConnected)
			{
			DisconnectNamedPipe(m_hPipe);
			m_bConnected = false;
			}

		CloseHandle(m_hPipe);
		m_hPipe = NULL;
		}

	if (m_hThreadReader)
		{
		CloseHandle(m_hThreadReader);
		m_hThreadReader = NULL;
		}

	if (m_hevtOverlapped)
		{
		CloseHandle(m_hevtOverlapped);
		m_hevtOverlapped = NULL;
		}
	}

void CVsTstPipe::ForceTermination(HANDLE hThread)
	{
    // thread should already be terminated
	DWORD dwErr = WaitForSingleObject(hThread, 5000);
	if (dwErr == WAIT_FAILED || dwErr == WAIT_TIMEOUT)
		// force termination of thread
		TerminateThread(hThread, 1);

    CloseHandle(hThread);
	}



// setup overlapped I/O structure used for reading data
// from the pipe
void CVsTstPipe::SetupOverlapped()
	{
	VSTST_ASSERT(m_hevtOverlapped);
	ResetEvent(m_hevtOverlapped);
	memset(&m_overlap, 0, sizeof(m_overlap));
	m_overlap.hEvent = m_hevtOverlapped;
	}

bool CVsTstPipe::WaitForConnection()
	{
	SetupOverlapped();
	if (ConnectNamedPipe(m_hPipe, &m_overlap))
		return true;

	if (GetLastError() == ERROR_IO_PENDING)
		{
		while(TRUE)
			{
			if (!m_pHandler->m_bReadEnabled)
				{
				CancelIo(m_hPipe);
				return false;
				}

			DWORD dwErr = WaitForSingleObject(m_hevtOverlapped, 1000);
			if (dwErr == WAIT_OBJECT_0)
				break;

			if (dwErr == WAIT_FAILED)
				{
				Sleep(1000);
				CancelIo(m_hPipe);
				return false;
				}
			}
		}

	return true;
	}


// do the work of reading messages
VSTST_READER_STATUS CVsTstPipe::ReadMessages(bool bConnect)
	{
    if (bConnect)
        {
        if (!WaitForConnection())
			return VSTST_RS_NOTCONNECTED;

        // launch a new reader thread to wait for the next connection
        m_pHandler->LaunchReader();
        }

    // while we are doing reads
	while(m_pHandler->m_bReadEnabled)
		{
		DWORD cbRead;

        // setup overlapped structure
        SetupOverlapped();

		if (!ReadFile
				(
				m_hPipe,
				m_rgbMsg,
				m_cbMsg,
				&cbRead,
				&m_overlap
				))
           {
		   DWORD dwErr = GetLastError();
		   if (dwErr == ERROR_IO_PENDING)
			   {
			   while(TRUE)
				   {
				   if (!m_pHandler->m_bReadEnabled)
					   {
					   CancelIo(m_hPipe);
					   return VSTST_RS_READDISABLED;
					   }

				   DWORD dwErr = WaitForSingleObject(m_hevtOverlapped, 1000);
				   if (dwErr == WAIT_OBJECT_0)
					   break;

				   if (dwErr == WAIT_FAILED)
					   {
					   Sleep(1000);
					   CancelIo(m_hPipe);
					   continue;
					   }
				   }

			   if (!GetOverlappedResult(m_hPipe, &m_overlap, &cbRead, FALSE))
				   {
				   CancelIo(m_hPipe);
				   continue;
				   }
			   }
		   else
			   {
			   // unexpected error reading from pipe
			   DWORD dwErr = GetLastError();
			   if (dwErr == ERROR_BROKEN_PIPE)
				   {
                   // terminate thread as we are no longer reading from
                   // the pipe
				   DisconnectNamedPipe(m_hPipe);
                   return VSTST_RS_DISCONNECTED;
				   }
			   else
				   ReadPipeError(dwErr);

			   return VSTST_RS_ERROR;
			   }
		   }

       VSTST_MSG_HDR *phdr = (VSTST_MSG_HDR *) m_rgbMsg;
	   if (phdr->cbMsg != cbRead ||
		   phdr->type == VSTST_MT_UNDEFINED ||
		   phdr->type >= VSTST_MT_MAXMSGTYPE)
		   LogInvalidMessage(phdr);
	   else if (g_msgTypes[phdr->type].priority == VSTST_MP_IMMEDIATE)
		   {
		   if (!m_pHandler->ProcessMsgImmediate(phdr))
			   LogInvalidMessage(phdr);
		   }
	   else
		   {
		   if (!m_pHandler->QueueMsg(phdr))
			   LogInvalidMessage(phdr);
		   }
	   }

   return VSTST_RS_READDISABLED;
   }


DWORD CVsTstPipe::StartReaderThread(VOID *pv)
	{
	CVsTstPipe *pipe = (CVsTstPipe *) pv;

	bool bConnected = false;
	try
		{
		while(!pipe->m_pHandler->m_bTerminateReader)
			{
			if (WaitForSingleObject(pipe->m_pHandler->m_hevtReader, INFINITE) == WAIT_FAILED)
				break;

			VSTST_READER_STATUS status = pipe->ReadMessages(!bConnected);
            if (status == VSTST_RS_DISCONNECTED)
				{
				bConnected = false;
                break;
				}
			else if (status != VSTST_RS_NOTCONNECTED)
				bConnected = true;
			}
		}
	catch(...)
		{
		LogUnexpectedFailure(L"Read thread unexpectedly terminated");
		}

    delete pipe;
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\common\tstiniconfig.cxx ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    TstINIConfig.cxx

Abstract:

    Class that manages the reading of the test scenario INI file.

Author:

    Stefan R. Steiner   [ssteiner]        05-16-2000

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "vststtools.hxx"
#include "vs_hash.hxx"

#include "tstiniconfig.hxx"
#include "tstiniconfigpriv.hxx" // has layouts of all the possible INI sections

static VOID
pVsTstWrapOutput(
    IN FILE *pfOut,
    IN LPCWSTR pwszBeginString,
    IN CBsString& cwsToBeWrapped,
    IN SIZE_T cWrapWidth
    );

static LPCWSTR x_wszDefaultINIPath = L"%SystemRoot%\\VsTestHarness.ini";

struct SVsTstSection
{
    LPWSTR m_pwszSectionTypeName;
    SVsTstINISectionDef *m_psSectionDef;
};
    
//
//  This array must match the EVsTstINISectionType enum in tstiniconfigpriv.h.  
//  These strings are the strings found in the INI file in the section headers.  E.g.
//  for section name [VssTestHarness.XXXX]
//  the XXXX is the section qualifier for the section type VssTestHarness.
//  See tstiniconfigpriv.hxx for definitions of sVsTstINISectionDefXXXX variables.
//
static SVsTstSection x_sSectionDefArr[] = 
{
    { L"INVALID",           NULL },
    { L"VssTestController", sVsTstINISectionDefController },
    { L"VssTestRequestor",  sVsTstINISectionDefRequester },
    { L"VssTestWriter",     sVsTstINISectionDefWriter },
    { L"VssTestProvider",   sVsTstINISectionDefProvider }
};

static LPCWSTR x_wszDefaultSectionName = L"DEFAULT";

//
//  Range delimiter
//
static LPCWSTR x_wszRangeString = L"...";

//
//  The following constants define the boolean values when writing to the
//  ini files.
//
static LPWSTR const x_pwszBooleanValueNames[] =
{
    L"No",      // eVsTstBool_False
    L"Yes",     // eVsTstBool_True
    L"Random"   // eVsTstBool_Random
};

//
//  The valid true values that can be specified as a boolean value.
//
static LPWSTR const x_pwszValidBooleanTrueValues[] =
{
    L"YES",
    L"TRUE",
    L"1",
    L"JA",
    L"SI",
    L"OUI",
    NULL
};

//
//  The valid false values that can be specified as a boolean value.
//  
static LPWSTR const x_pwszValidBooleanFalseValues[] =
{
    L"NO",
    L"FALSE",
    L"0",
    L"NEIN",
    L"NON",
    NULL
};

//
//  The valid strings to specify random values.
//
static LPWSTR const x_pwszValidBooleanRandomValues[] =
{
    L"RANDOM",
    L"-1",
    NULL
};

//
//  Function that finds a match within a string array
//
static BOOL
IsInArray( 
    IN const CBsString& cwsString,
    IN LPWSTR const *ppwszStringMatchArray
    )
{
    VSTST_ASSERT( ppwszStringMatchArray != NULL );
    
    while ( *ppwszStringMatchArray != NULL )
    {
        if ( cwsString == *ppwszStringMatchArray )
            return TRUE;
        ++ppwszStringMatchArray;
    }

    return FALSE;
}

//
//  Parent class the all in memory options subclass from
//
class CVsTstSectionOptionBase
{
public:
    CVsTstSectionOptionBase(
        IN EVsTstINIOptionType eOptionType
        ) : m_eOptionType( eOptionType ),
            m_bDefaultOverridden( FALSE ) { };
    
    virtual ~CVsTstSectionOptionBase() {};

    EVsTstINIOptionType GetOptionType() { return m_eOptionType; }

    // 
    //  The value after the "KeyName=" in the INI file
    //
    virtual VOID SetValueFromINIValue(
        IN CBsString cwsINIValue
        ) = 0;

    //
    //  Returns true if the default value was overridden by the INI
    //  file or a call to a SetValueXXXX method in derived classes.
    //
    BOOL IsDefaultOverridden() { return m_bDefaultOverridden; }
    
protected:
    VOID SetDefaultOverriden() { m_bDefaultOverridden = TRUE; }
    
private:
    EVsTstINIOptionType m_eOptionType;
    BOOL m_bDefaultOverridden;    //  TRUE if default value was overridden 
};

//
//  In-memory boolean option.  This maintains the state of
//  one option.  It takes care of using the option definition in 
//  tstiniconfigpriv.hxx to initialize the option with its default value
//  and if the option value changes, makes sure it matches what
//  is allowed by the definition.
//
class CVsTstSectionOptionBoolean : public CVsTstSectionOptionBase
{
public:
    CVsTstSectionOptionBoolean(
        IN SVsTstINIBooleanDef& rsBoolDef
        ) : CVsTstSectionOptionBase( eVsTstOptType_Boolean )
    {
        //  Set up option definition
        m_psBoolDef  = &rsBoolDef;

        //  Set up default values
        m_eBoolValue = m_psBoolDef->m_eBoolDefault;
    };
    
    virtual ~CVsTstSectionOptionBoolean() {};

    virtual VOID SetValueFromINIValue(
        IN CBsString cwsINIValue
        ) 
    { 
        cwsINIValue.TrimLeft();
        cwsINIValue.TrimRight();
        cwsINIValue.MakeUpper();
        if ( ::IsInArray( cwsINIValue, x_pwszValidBooleanTrueValues ) )
            SetValue( eVsTstBool_True );
        else if ( ::IsInArray( cwsINIValue, x_pwszValidBooleanFalseValues ) )
            SetValue( eVsTstBool_False );
        else if ( ::IsInArray( cwsINIValue, x_pwszValidBooleanRandomValues ) )
            SetValue( eVsTstBool_Random );
        else
        {
            CBsString cwsThrow;
            VSTST_THROW( cwsThrow.Format( L"Invalid boolean value '%s'", cwsINIValue.c_str() ) );
        }
            
    }

    VOID SetValue(
        IN EVsTstINIBoolType eBoolValue
        )
    { 
        CBsString cwsThrow;
        
        VSTST_ASSERT( eBoolValue == eVsTstBool_False || eBoolValue == eVsTstBool_True ||
                      eBoolValue == eVsTstBool_Random );
        if ( GetOptionType() != eVsTstOptType_Boolean )
            VSTST_THROW( E_INVALIDARG );
        
        if ( eBoolValue == eVsTstBool_Random && !m_psBoolDef->m_bCanHaveRandom )
            VSTST_THROW( cwsThrow.Format( L"Value 'Random' not allowed for this keyword" ) );
        
        m_eBoolValue = eBoolValue;
        SetDefaultOverriden();
    }

    EVsTstINIBoolType GetValue()
    {
        if ( GetOptionType() != eVsTstOptType_Boolean )
            VSTST_THROW( E_INVALIDARG );
        
        return m_eBoolValue;
    }
    
private:
    EVsTstINIBoolType m_eBoolValue;    
    SVsTstINIBooleanDef *m_psBoolDef;
    
};


//
//  In-memory number option.  This maintains the state of
//  one option.  It takes care of using the option definition in 
//  tstiniconfigpriv.hxx to initialize the option with its default value
//  and if the option value changes, makes sure it matches what
//  is allowed by the definition.
//
class CVsTstSectionOptionNumber : public CVsTstSectionOptionBase
{
public:
    CVsTstSectionOptionNumber(
        IN SVsTstININumberDef& rsNumDef
        ) : CVsTstSectionOptionBase( eVsTstOptType_Number )
    {
        //  Set up option definition
        m_psNumDef = &rsNumDef;

        //  Set up default values
        m_llMinNumberValue = m_psNumDef->m_llDefaultMinNumber;
        if ( m_psNumDef->m_bCanHaveRange )
            m_llMaxNumberValue = m_psNumDef->m_llDefaultMaxNumber;
        else
            m_llMaxNumberValue = m_psNumDef->m_llDefaultMinNumber;   
    };
    
    virtual ~CVsTstSectionOptionNumber() {};
    
    virtual VOID SetValueFromINIValue(
        IN CBsString cwsINIValue
        ) 
    { 
        INT iFind;
        LONGLONG llMinNumberValue;
        LONGLONG llMaxNumberValue;
        
        //
        //  See if the range characters are in the value
        //
        iFind = cwsINIValue.Find( x_wszRangeString );
        if ( iFind == -1 )
        {
            //
            //  Not a range
            //
            llMinNumberValue = _wtoi64( cwsINIValue );
            SetValue( llMinNumberValue, 0, FALSE );
        }
        else
        {
            CBsString cwsTemp( cwsINIValue );
            llMinNumberValue = _wtoi64( cwsTemp );  //  Will stop at ...
            cwsTemp = cwsINIValue.Mid( iFind + (INT)::wcslen( x_wszRangeString ) );
            llMaxNumberValue = _wtoi64( cwsTemp );
            SetValue( llMinNumberValue, llMaxNumberValue, TRUE );
        }            
    }

    VOID SetValue(
        IN LONGLONG llMinNumberValue,
        IN LONGLONG llMaxNumberValue,
        IN BOOL bRange
        )
    { 
        CBsString cwsThrow;
        
        if ( GetOptionType() != eVsTstOptType_Number )
            VSTST_THROW( E_INVALIDARG );

        if ( bRange  &&  llMinNumberValue != llMaxNumberValue  && 
             !m_psNumDef->m_bCanHaveRange )
            VSTST_THROW( cwsThrow.Format( L"%s number range not allowed in value", x_wszRangeString ) );

        if ( llMinNumberValue < m_psNumDef->m_llMinNumber || 
             llMinNumberValue > m_psNumDef->m_llMaxNumber )
            VSTST_THROW( cwsThrow.Format( L"%I64d not within valid min (%I64d) and max (%I64d) number values", 
                llMinNumberValue, m_psNumDef->m_llMinNumber, m_psNumDef->m_llMaxNumber ) );

        if ( bRange )
        {
            if ( llMaxNumberValue < m_psNumDef->m_llMinNumber || 
                 llMaxNumberValue > m_psNumDef->m_llMaxNumber )
                VSTST_THROW( cwsThrow.Format( L"%I64d not within valid min (%I64d) and max (%I64d) number values", 
                    llMaxNumberValue, m_psNumDef->m_llMinNumber, m_psNumDef->m_llMaxNumber ) );
            else if ( llMinNumberValue > llMaxNumberValue )            
                VSTST_THROW( cwsThrow.Format( L"Min value larger than max value" ) );
        }
        
        m_llMinNumberValue = llMinNumberValue;
        if ( bRange )
            m_llMaxNumberValue = llMaxNumberValue;
        else
            m_llMaxNumberValue = llMinNumberValue;
        SetDefaultOverriden();
    }

    VOID GetValue(
        OUT LONGLONG *pllMinNumberValue,
        OUT LONGLONG *pllMaxNumberValue,
        OUT BOOL *pbRange
        )
    {
        if ( GetOptionType() != eVsTstOptType_Number )
            VSTST_THROW( E_INVALIDARG );
        
        *pllMinNumberValue = m_llMinNumberValue;
        *pllMaxNumberValue = m_llMaxNumberValue;

        if ( m_llMinNumberValue == m_llMaxNumberValue )
            *pbRange = FALSE;
        else
            *pbRange = TRUE;
    }

private:    
    LONGLONG m_llMinNumberValue;
    LONGLONG m_llMaxNumberValue;
    SVsTstININumberDef *m_psNumDef;
};


//
//  In-memory string option.  This maintains the state of
//  one option.  It takes care of using the option definition in 
//  tstiniconfigpriv.hxx to initialize the option with its default value
//  and if the option value changes, makes sure it matches what
//  is allowed by the definition.
//
class CVsTstSectionOptionString : public CVsTstSectionOptionBase
{
public:
    CVsTstSectionOptionString(
        IN SVsTstINIStringDef& rsStringDef
        ) : CVsTstSectionOptionBase( eVsTstOptType_String )
    {
        //  Set up option definition
        m_psStringDef = &rsStringDef;

        //  Set up default values
        m_wsStringValue = m_psStringDef->m_pwszDefaultString;
    };
    
    virtual ~CVsTstSectionOptionString() {};

    virtual VOID SetValueFromINIValue(
        IN CBsString cwsINIValue
        ) 
    { 
        SetValue( cwsINIValue );
    }

    VOID SetValue(
        IN const CBsString& rwsStringValue
        )
    { 
        //
        //  If the PossibleValues field is NULL in the definition
        //  then, any string is allowed in the option.
        //
        if ( m_psStringDef->m_pwszPossibleValues != NULL )
        {
            //
            //  See if this string is part of the set of possible
            //  values.  The values are in a string delimited by '|' chars.
            //
            LPWSTR pwszPossibleValues = ::_wcsdup( m_psStringDef->m_pwszPossibleValues );
            if ( pwszPossibleValues == NULL )
                VSTST_THROW( E_OUTOFMEMORY );

            LPWSTR pwszToken;
            pwszToken = ::wcstok( pwszPossibleValues, L"|" );
            while ( pwszToken != NULL )
            {
                if ( ::_wcsicmp( pwszToken, rwsStringValue.c_str() ) == 0 )
                    break;
                pwszToken = ::wcstok( NULL, L"|" );
            }

            free( pwszPossibleValues );
            
            if ( pwszToken == NULL )
            {
                //  Not a string in the PossibleValues array, throw string
                CBsString cwsThrow;
                VSTST_THROW( cwsThrow.Format( L"Invalid value '%s', possible values are '%s'",
                    rwsStringValue.c_str(), m_psStringDef->m_pwszPossibleValues ) );
            }
        }

        m_wsStringValue = rwsStringValue;
        SetDefaultOverriden();
    }

    CBsString GetValue()
    {
        if ( GetOptionType() != eVsTstOptType_String )
            VSTST_THROW( E_INVALIDARG );
        
        return m_wsStringValue;
    }
    
private:
    CBsString m_wsStringValue;    
    SVsTstINIStringDef *m_psStringDef;
};

//
//  Definition of the hash table that maintains the option name to 
//  option class instance mapping.  This will efficiently allow
//  many options to be used in a section.  Pointer to instances
//  of this class are stored in the m_pvOptionsList field of 
//  CVsTstINIConfig.
//
typedef TBsHashMap< CBsString, CVsTstSectionOptionBase * > CVsTstOptionsList;

//
//  The equality test
//
inline BOOL AreKeysEqual( const CBsString& lhK, const CBsString& rhK )
{
    //
    //  Do a case independent compare
    //
    return ( lhK.CompareNoCase( rhK ) == 0 );
}

static LONG CBsStringHashFunc( const CBsString& Key, LONG NumBuckets ) 
{
    //
    //  Need a temp string to uppercase
    //
    CBsString cwsTemp( Key );
    cwsTemp.MakeUpper();
    
    const BYTE *pByteKey = (const BYTE *)cwsTemp.c_str();
    LONG dwHashVal = 0;
    SIZE_T cKeyLen = cwsTemp.GetLength() * sizeof WCHAR;
    
    for ( SIZE_T i = 0; i < cKeyLen; ++i ) 
    {
        dwHashVal += pByteKey[i];
    }
    return dwHashVal % NumBuckets;
}

/*++

Routine Description:

    Constructor for the CVsTstINIConfig class.

Arguments:

    eSectionType - The section type of the section to read.
    pwszSectionQualifier - The qualifier of the section in the INI file, the XXX in [SectionType.XXX]
    bWriteINIFile - If true and the INI file doesn't exist, the INI file
        will be created with the default values filled in.
    pwszINIFileName - The full path to the INI file.  If NULL, the default
        INI file location is used.
    bContinueOnINIFileErrors - If FALSE, an CVsTstINIConfigException class is thrown
        when an error is found in the ini file.  If TRUE, they are silently skipped; however,
        HRESULT's may be still thrown if programatic or memory errors occur.
        
Return Value:

    NONE
    May throw HRESULT and CVsTstINIConfigException exceptions.

--*/
CVsTstINIConfig::CVsTstINIConfig( 
    IN EVsTstINISectionType eSectionType,
    IN LPCWSTR pwszSectionQualifier,
    IN BOOL bWriteINIFile, 
    IN LPCWSTR pwszINIFileName,
    IN BOOL bContinueOnINIFileErrors
    ) : m_bWriteINIFile( bWriteINIFile ),
        m_eSectionType( eSectionType ),
        m_pvOptionsList( NULL ),
        m_bContinueOnINIFileErrors( bContinueOnINIFileErrors )
{
    VSTST_ASSERT( pwszSectionQualifier != NULL );
    VSTST_ASSERT( pwszSectionQualifier[ 0 ] != L'\0' );
    VSTST_ASSERT( eSectionType > eVsTstSectionType_UNKNOWN  &&
        eSectionType < eVsTstSectionType_SENTINEL );

    //
    //  Set up the hash table to be used to store the option values
    //
    m_pvOptionsList = new CVsTstOptionsList( BSHASHMAP_SMALL, CBsStringHashFunc );
    if ( m_pvOptionsList == NULL )
        VSTST_THROW( E_OUTOFMEMORY );
    
    //
    //  Set up the section that will be read
    //
    m_wsSectionName  = x_sSectionDefArr[ m_eSectionType ].m_pwszSectionTypeName;
    m_wsSectionName += L".";
    m_wsSectionName += pwszSectionQualifier;

    //
    //  Set up the INI file path.  If pwszINIFileName is NULL, use the default
    //  INI file name.  The paths can have environment variables that need
    //  to be expanded.
    //
    DWORD dwRet;
    dwRet = ::ExpandEnvironmentStringsW( 
                pwszINIFileName == NULL ? x_wszDefaultINIPath : pwszINIFileName,
                m_wsINIFileName.GetBuffer( MAX_PATH ),
                MAX_PATH );
    m_wsINIFileName.ReleaseBuffer();
    if ( dwRet == 0 )
        VSTST_THROW( E_UNEXPECTED );        

    HRESULT hr;

    //
    //  First initialize all options with their default values
    //
    hr = SetupDefaultValues();
    if ( FAILED( hr ) )
    {
        VSTST_THROW( hr );
    }
    
    //
    //  Now open the ini file.  If the file is not there and the caller wants a 
    //  default INI file created, then what are we waiting for, create it.
    // 
    hr = LoadINIFileData();
    if ( hr == STG_E_FILENOTFOUND && bWriteINIFile )
    {
        hr = CreateDefaultINIFile();
    } 
    
    if ( FAILED( hr ) )
    {
        VSTST_THROW( hr );
    }
}


CVsTstINIConfig::~CVsTstINIConfig()
{
    //
    //  Clean up the options list if necessary
    //
    if ( m_pvOptionsList != NULL )
    {
        CVsTstOptionsList *pcOptionsList = ( CVsTstOptionsList * )m_pvOptionsList;
        CBsString wsOptionName;
        CVsTstSectionOptionBase *pcSectionOptionBase;
        
        pcOptionsList->StartEnum();
        while ( pcOptionsList->GetNextEnum( &wsOptionName, &pcSectionOptionBase ) )
        {
            delete pcSectionOptionBase;
        }    
        pcOptionsList->EndEnum();
        
        delete pcOptionsList;
        
        m_pvOptionsList = NULL;
    }
}


HRESULT
CVsTstINIConfig::LoadINIFileData()
{
    DWORD dwSectionBufferSize = 1024;
    DWORD dwRet;
    LPWSTR pwszSectionBuffer = NULL;

    //
    //  See if the INI file exists, if not return file not found
    //
    if ( ::GetFileAttributesW( m_wsINIFileName ) == -1 )
    {
        if ( ::GetLastError() != ERROR_FILE_NOT_FOUND &&
             ::GetLastError() != ERROR_PATH_NOT_FOUND )
            VSTST_THROW( HRESULT_FROM_WIN32( ::GetLastError() ) );
        else
            return STG_E_FILENOTFOUND;
    }
    
    //
    //  First get the entire section from the INI file by using the funky
    //  GetPrivateProfileSection API.
    //
    do
    {
        if ( pwszSectionBuffer )
        {
            free( pwszSectionBuffer );
            dwSectionBufferSize <<= 2;   // bump up the size by a power of two and try again
        }
        
        pwszSectionBuffer = ( LPWSTR )malloc( sizeof( WCHAR ) * dwSectionBufferSize );
        if ( pwszSectionBuffer == NULL )
            VSTST_THROW( E_OUTOFMEMORY );
        
        dwRet = ::GetPrivateProfileSectionW( 
                    m_wsSectionName,
                    pwszSectionBuffer,
                    dwSectionBufferSize,
                    m_wsINIFileName );        
    } while ( dwRet == dwSectionBufferSize - 2 );  // who came up with this API ???    

    if ( dwRet > 0 )
    {
        //  Section is found and not empty
    
        //
        //  Now go through the section buffer, one option at a time, replacing defaults
        //  with the specified options.
        //
        CVsTstOptionsList *pcOptionsList = ( CVsTstOptionsList * ) m_pvOptionsList;
        
        LPWSTR pwszCurrOption = pwszSectionBuffer;
        while ( true )
        {
            SIZE_T cOptionLen = ::wcslen( pwszCurrOption );
            
            LPWSTR pwszValue = ::wcschr( pwszCurrOption, L'=' ); 
            if ( pwszValue != NULL )
            {
                pwszValue[ 0 ] = '\0'; //  blast away =
                ++pwszValue; //  Skip over blasted =

                //
                //  Now pwszCurrOption only contains the key name and pwszValue contains
                //  the value
                //  Find the key in the option list and set the value
                //
                CVsTstSectionOptionBase *pcSectionOptionBase;
                if ( pcOptionsList->Find( pwszCurrOption, &pcSectionOptionBase ) )
                {
                    //
                    //  Key found, set it.  Note, the SetValue methods
                    //  can throw CBsStrings when an INI file error is 
                    //  found.
                    //
                    try 
                    {
                        pcSectionOptionBase->SetValueFromINIValue( pwszValue );
                    }
                    catch ( CBsString cwsExcept )
                    {
                        if ( !m_bContinueOnINIFileErrors )
                        {
                            CVsTstINIConfigException cExcept;
                            cExcept.m_cwsExceptionString.Format( L"(%s), keyword '%s', section '%s', INI file '%s'", 
                                cwsExcept.c_str(), pwszCurrOption, m_wsSectionName.c_str(), m_wsINIFileName.c_str() );
                            free( pwszSectionBuffer );                
                            VSTST_THROW( cExcept );
                        }
                    }
                }
                else
                {
                    if ( !m_bContinueOnINIFileErrors )
                    {
                        //
                        //  Keyword not found, throw an error.  We might not want to do this
                        //  in the future.
                        //
                        CVsTstINIConfigException cExcept;
                        cExcept.m_cwsExceptionString.Format( L"Unknown keyword '%s', section '%s', INI file '%s'", 
                            pwszCurrOption, m_wsSectionName.c_str(), m_wsINIFileName.c_str() );
                        VSTST_THROW( cExcept );
                    }
                }
            }
            else
            {
                if ( !m_bContinueOnINIFileErrors )
                {
                    CVsTstINIConfigException cExcept;
                    cExcept.m_cwsExceptionString.Format( L"No '=' in line '%s', section '%s' of INI file '%s'", 
                        pwszCurrOption, m_wsSectionName.c_str(), m_wsINIFileName.c_str() );
                    free( pwszSectionBuffer );                
                    VSTST_THROW( cExcept );
                }
            }
            
            pwszCurrOption += cOptionLen;

            if ( pwszCurrOption[ 0 ] == L'\0' && 
                 pwszCurrOption[ 1 ] == L'\0' )
                break;
                
            ++pwszCurrOption;  //  Skip null char
        }
    }
    
    free( pwszSectionBuffer );
    
    return S_OK;
}


HRESULT
CVsTstINIConfig::SetupDefaultValues()
{
    VSTST_ASSERT( m_pvOptionsList != NULL );
    HRESULT hr = S_OK;
    
    //
    //  Initialize all of the section options with the hardwired option types,
    //  max sizes and default values.
    //
    SVsTstINISectionDef *psSectionDef = x_sSectionDefArr[ m_eSectionType ].m_psSectionDef;

    if ( psSectionDef == NULL )
        //  No section definition, return
        return S_OK;

    CVsTstOptionsList *pcOptionsList = ( CVsTstOptionsList * ) m_pvOptionsList;
    
    //
    //  Iterate through the list of options in the definition.
    //
    for( SIZE_T cOptionIdx = 0;
         psSectionDef[ cOptionIdx ].m_pwszKeyName != NULL;
         ++cOptionIdx )
    {
        // 
        //  Skip comments in definition
        //
        if ( psSectionDef[ cOptionIdx ].m_eOptionType == eVsTstOptType_Comment )
            continue;
        
        CVsTstSectionOptionBase *pcOptionBase = NULL;

        //
        //  Depending on type of option, create the correct
        //  object and place it into the hash table.  Yes,
        //  these new()'s can throw exceptions, not a 
        //  problem here, things will clean up properly.
        //
        switch ( psSectionDef[ cOptionIdx ].m_eOptionType )
        {
        case eVsTstOptType_Boolean:
            pcOptionBase = new CVsTstSectionOptionBoolean( 
                psSectionDef[ cOptionIdx ].m_sBooleanDef );
            break;
        case eVsTstOptType_String:
            pcOptionBase = new CVsTstSectionOptionString( 
                psSectionDef[ cOptionIdx ].m_sStringDef );
            break;            
        case eVsTstOptType_Number:
            pcOptionBase = new CVsTstSectionOptionNumber( 
                psSectionDef[ cOptionIdx ].m_sNumberDef );
            break;                        
        default:
            VSTST_ASSERT( "Invalid option type in definition array" && FALSE );
            VSTST_THROW( E_INVALIDARG );
            break;
        }

        if ( pcOptionBase == NULL )
            VSTST_THROW( E_OUTOFMEMORY );
        
        //
        //  Now insert the option object into the hash table.
        //
        try
        {
            LONG lRet;
            CBsString cwsKeyName( psSectionDef[ cOptionIdx ].m_pwszKeyName );

            //
            //  Store key names in uppercase
            //
            lRet = pcOptionsList->Insert( cwsKeyName, pcOptionBase );
            if ( lRet == BSHASHMAP_ALREADY_EXISTS )
            {
                VSTST_ASSERT( "Option name defined twice in definition array" && FALSE );
                VSTST_THROW( E_INVALIDARG );
            }
        }
        VSTST_STANDARD_CATCH();
        
        if ( FAILED( hr ) )
        {
            delete pcOptionBase;
            VSTST_THROW( hr );
        }
    }

    return S_OK;
}

#define VSTST_WRAP_WIDTH 97

/*++

Routine Description:

    Creates a default INI file that specifies all sections, keys
    and default values including comments about what each key
    is for.

Arguments:

    None

Return Value:

    <Enter return values here>

--*/
HRESULT
CVsTstINIConfig::CreateDefaultINIFile()
{
    FILE *pfINIFile = NULL;
    HRESULT hr = S_OK;
    
    try
    {
        //  Open the INI file
        pfINIFile = ::_wfopen( m_wsINIFileName, L"w" );
        if ( pfINIFile == NULL )
        {
            CVsTstINIConfigException cExcept;
            cExcept.m_cwsExceptionString.Format( L"Unable to open INI file '%s' for write", 
                m_wsINIFileName.c_str() );
            VSTST_THROW( cExcept );
        }
        
        //  Write out all known options for all sections.
        for ( SIZE_T idx = ( SIZE_T ) eVsTstSectionType_UNKNOWN + 1;
              idx < ( ( SIZE_T )eVsTstSectionType_SENTINEL );
              ++idx )
        { 
            fwprintf( pfINIFile, L"[%s.%s]\n", 
                x_sSectionDefArr[ idx ].m_pwszSectionTypeName, x_wszDefaultSectionName );
                
            SVsTstINISectionDef *psSectionDef = x_sSectionDefArr[ idx ].m_psSectionDef;
            if ( psSectionDef != NULL )
            {
                CBsString cwsToBeWrapped;
                
                //  Go through each option in the sections.
                for ( SIZE_T cSect = 0; psSectionDef[ cSect ].m_pwszKeyName != NULL; ++cSect )
                {
                    if ( psSectionDef[ cSect ].m_eOptionType != eVsTstOptType_Comment )
                    {
                        cwsToBeWrapped.Format( L"%s - %s", psSectionDef[ cSect ].m_pwszKeyName,
                            psSectionDef[ cSect ].m_pwszDescription );
                        ::pVsTstWrapOutput( pfINIFile, L"; ", cwsToBeWrapped, VSTST_WRAP_WIDTH );
                    }
                    
                    switch ( psSectionDef[ cSect ].m_eOptionType )
                    {
                    case eVsTstOptType_Comment:
                        if ( psSectionDef[ cSect ].m_pwszDescription == NULL )
                            fwprintf( pfINIFile, L"\n" );
                        else
                        {
                            fwprintf( pfINIFile, L";\n" );
                            cwsToBeWrapped.Format( L"%s\n", psSectionDef[ cSect ].m_pwszDescription );
                            ::pVsTstWrapOutput( pfINIFile, L"; ", cwsToBeWrapped, VSTST_WRAP_WIDTH );
                            fwprintf( pfINIFile, L";\n" );
                        }
                        break;
                        
                    case eVsTstOptType_String:
                        if ( psSectionDef[ cSect ].m_sStringDef.m_pwszPossibleValues == NULL )                        
                            cwsToBeWrapped.Format( L"Default value: '%s'\n", 
                                psSectionDef[ cSect ].m_sStringDef.m_pwszDefaultString );
                        else
                        {   
                            CBsString cwsPossibleValuesConverted( psSectionDef[ cSect ].m_sStringDef.m_pwszPossibleValues );
                            cwsPossibleValuesConverted.Replace( L'|', L',' );
                            cwsToBeWrapped.Format( L"Default value: '%s', possible values: '%s'\n", 
                                psSectionDef[ cSect ].m_sStringDef.m_pwszDefaultString,
                                cwsPossibleValuesConverted.c_str() );
                        }
                        ::pVsTstWrapOutput( pfINIFile, L"; ", cwsToBeWrapped, VSTST_WRAP_WIDTH );
                        fwprintf( pfINIFile, L";%s = %s\n\n", 
                            psSectionDef[ cSect ].m_pwszKeyName,
                            psSectionDef[ cSect ].m_sStringDef.m_pwszDefaultString );
                        break;
                        
                    case eVsTstOptType_Boolean:
                        cwsToBeWrapped.Format( L"Default value: '%s'%s", 
                            x_pwszBooleanValueNames[ psSectionDef[ cSect ].m_sBooleanDef.m_eBoolDefault ],
                            ( psSectionDef[ cSect ].m_sBooleanDef.m_bCanHaveRandom )
                               ? L", can have 'Random' value\n" : L"" );
                        ::pVsTstWrapOutput( pfINIFile, L"; ", cwsToBeWrapped, VSTST_WRAP_WIDTH );
                        fwprintf( pfINIFile, L";%s = %s\n\n", 
                            psSectionDef[ cSect ].m_pwszKeyName,
                            x_pwszBooleanValueNames[ psSectionDef[ cSect ].m_sBooleanDef.m_eBoolDefault ] );
                        break;
                            
                    case eVsTstOptType_Number:
                        {
                            SVsTstININumberDef *psNumDef = &( psSectionDef[ cSect ].m_sNumberDef );
                            if ( psNumDef->m_bCanHaveRange )
                            {
                                cwsToBeWrapped.Format( L"Default value: %I64d%s%I64d, Min value: %I64d, Max value: %I64d, can be a range\n", 
                                    psNumDef->m_llDefaultMinNumber, 
                                    x_wszRangeString,
                                    psNumDef->m_llDefaultMaxNumber,
                                    psNumDef->m_llMinNumber,
                                    psNumDef->m_llMaxNumber );
                                ::pVsTstWrapOutput( pfINIFile, L"; ", cwsToBeWrapped, VSTST_WRAP_WIDTH );
                                
                                fwprintf( pfINIFile, L";%s = %I64d%s%I64d\n\n", 
                                    psSectionDef[ cSect ].m_pwszKeyName,
                                    psNumDef->m_llDefaultMinNumber, 
                                    x_wszRangeString,
                                    psNumDef->m_llDefaultMaxNumber );
                            }
                            else
                            {
                                cwsToBeWrapped.Format( L"Default value: %I64d, Min value: %I64d, Max value: %I64d\n", 
                                    psNumDef->m_llDefaultMinNumber, 
                                    psNumDef->m_llMinNumber,
                                    psNumDef->m_llMaxNumber );
                                ::pVsTstWrapOutput( pfINIFile, L"; ", cwsToBeWrapped, VSTST_WRAP_WIDTH );
                                
                                fwprintf( pfINIFile, L";%s = %I64d\n\n", 
                                    psSectionDef[ cSect ].m_pwszKeyName,
                                    psNumDef->m_llDefaultMinNumber );
                            }                            
                        }
                        break;
                    }
                }            
            }
            
            fwprintf( pfINIFile, L"; ==================================================================\n" );
        }                
    }
    VSTST_STANDARD_CATCH();

    if ( pfINIFile != NULL )
        ::fclose( pfINIFile );
    
    return S_OK;
}

//  Gets a string value
VOID
CVsTstINIConfig::GetOptionValue(
    IN LPCWSTR pwszOptionName,
    OUT CBsString *pwsOptionValue,
    OUT BOOL *pbOverridden
    )
{
    CVsTstOptionsList *pcOptionsList = ( CVsTstOptionsList * ) m_pvOptionsList;
    CVsTstSectionOptionBase *pcSectionOptionBase;
    if ( pcOptionsList->Find( pwszOptionName, &pcSectionOptionBase ) )
    {
        if ( pcSectionOptionBase->GetOptionType() != eVsTstOptType_String )
        {
            VSTST_ASSERT( FALSE );
            VSTST_THROW( E_INVALIDARG );
        }
        
        CVsTstSectionOptionString *pcOptionString;
        pcOptionString = ( CVsTstSectionOptionString * )pcSectionOptionBase;
        
        *pwsOptionValue = pcOptionString->GetValue();
        if ( pbOverridden != NULL )
            *pbOverridden = pcOptionString->IsDefaultOverridden();
        return;
    }

    VSTST_THROW( E_INVALIDARG );
}


//  Gets a boolean value
VOID 
CVsTstINIConfig::GetOptionValue(
    IN LPCWSTR pwszOptionName,
    OUT EVsTstINIBoolType *peOptionValue,
    OUT BOOL *pbOverridden
    )
{
    CVsTstOptionsList *pcOptionsList = ( CVsTstOptionsList * ) m_pvOptionsList;
    CVsTstSectionOptionBase *pcSectionOptionBase;
    if ( pcOptionsList->Find( pwszOptionName, &pcSectionOptionBase ) )
    {
        if ( pcSectionOptionBase->GetOptionType() != eVsTstOptType_Boolean )
        {
            VSTST_ASSERT( FALSE );
            VSTST_THROW( E_INVALIDARG );
        }
        
        CVsTstSectionOptionBoolean *pcOptionBoolean;
        pcOptionBoolean = ( CVsTstSectionOptionBoolean * )pcSectionOptionBase;
        
        *peOptionValue = pcOptionBoolean->GetValue();
        if ( pbOverridden != NULL )
            *pbOverridden = pcOptionBoolean->IsDefaultOverridden();
        
        return;
    }

    VSTST_THROW( E_INVALIDARG );
}


//  Get a number value
VOID 
CVsTstINIConfig::GetOptionValue(
    IN LPCWSTR pwszOptionName,
    OUT LONGLONG *pllOptionMinValue,
    OUT LONGLONG *pllOptionMaxValue,
    OUT BOOL *pbOverridden
    )
{
    CVsTstOptionsList *pcOptionsList = ( CVsTstOptionsList * ) m_pvOptionsList;
    CVsTstSectionOptionBase *pcSectionOptionBase;
    if ( pcOptionsList->Find( pwszOptionName, &pcSectionOptionBase ) )
    {
        if ( pcSectionOptionBase->GetOptionType() != eVsTstOptType_Number )
        {
            VSTST_ASSERT( FALSE );
            VSTST_THROW( E_INVALIDARG );
        }
        
        CVsTstSectionOptionNumber *pcOptionNumber;
        pcOptionNumber = ( CVsTstSectionOptionNumber * )pcSectionOptionBase;

        BOOL bHasRange;
        pcOptionNumber->GetValue( pllOptionMinValue, pllOptionMaxValue, &bHasRange );
        if ( pbOverridden != NULL )
            *pbOverridden = pcOptionNumber->IsDefaultOverridden();
        
        return;
    }

    VSTST_THROW( E_INVALIDARG );
}

static VOID
pVsTstWrapOutput(
    IN FILE *pfOut,
    IN LPCWSTR pwszBeginString,
    IN CBsString& cwsToBeWrapped,
    IN SIZE_T cWrapWidth
    )
{
    cwsToBeWrapped.TrimLeft();
    cwsToBeWrapped.TrimRight();
    LPWSTR pwszCurrPosition = cwsToBeWrapped.GetBuffer( cwsToBeWrapped.GetLength() );
    LPWSTR pwszNextLine = NULL;
    LPWSTR pwszSpaces = L"";
    
    while( *pwszCurrPosition != L'\0' )
    {
        SIZE_T cLen;
        cLen = ::wcslen( pwszCurrPosition );

        //
        //  Get rid of the easy case
        //
        if ( cLen <= cWrapWidth )
        {
            fwprintf( pfOut, L"%s%s%s\n", pwszBeginString, pwszSpaces, pwszCurrPosition );
            break;
        }
        
        pwszNextLine = pwszCurrPosition + cWrapWidth - ::wcslen( pwszSpaces );
        while ( pwszNextLine > pwszCurrPosition )
        {
            if ( *pwszNextLine == L' ' )
                break;
            --pwszNextLine;
        }

        if ( pwszNextLine == pwszCurrPosition )
        {
            //
            //  No spaces within margin, move forward to first space.
            //
            pwszNextLine = ::wcschr( pwszCurrPosition, L' ' );

            //
            //  If pwszNextLine is NULL, then it means the entire rest of the line has no spaces
            //
            if ( pwszNextLine != NULL )
                *pwszNextLine = '\0';
        }
        else
        {
            *pwszNextLine = '\0';
        }
        fwprintf( pfOut, L"%s%s%s\n", pwszBeginString, pwszSpaces, pwszCurrPosition );

        //
        //  If special case where pwszNextLine is NULL, we are done
        //
        if ( pwszNextLine == NULL )
            break;
            
        pwszCurrPosition = pwszNextLine + 1;
        pwszSpaces = L"     ";
    }

    cwsToBeWrapped.ReleaseBuffer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\common\vststmsgclient.cxx ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    vststmsgclient.cxx

Abstract:

    Implementation of test message classes for the client and holder of
    shared methods and variables shared between client and server.


    Brian Berkowitz  [brianb]  05/22/2000

TBD:

Revision History:

    Name        Date        Comments
    brianb      05/22/2000  Created
    ssteiner    06/07/2000  Split client and server portions into
                            two files.  vststmsg.cxx contains
                            the server portion.

--*/

#include "stdafx.h"
#include "vststmsgclient.hxx"

void LogUnexpectedFailure(LPCWSTR wsz, ...);

VSTST_MSG_TYPE_TABLE g_msgTypes[VSTST_MT_MAXMSGTYPE];

void AddMessageType
	(
	VSTST_MSG_TYPE type,
	UINT cbFixed,
	UINT cVarPtr,
	VSTST_MSG_PRIORITY priority,
	VSTST_MSG_HANDLER pfnHandler,
	VSTST_VARPTR_TYPE ptype1 = VSTST_VPT_UNDEFINED,
	VSTST_VARPTR_TYPE ptype2 = VSTST_VPT_UNDEFINED,
	VSTST_VARPTR_TYPE ptype3 = VSTST_VPT_UNDEFINED,
	VSTST_VARPTR_TYPE ptype4 = VSTST_VPT_UNDEFINED,
	VSTST_VARPTR_TYPE ptype5 = VSTST_VPT_UNDEFINED,
	VSTST_VARPTR_TYPE ptype6 = VSTST_VPT_UNDEFINED,
	VSTST_VARPTR_TYPE ptype7 = VSTST_VPT_UNDEFINED,
	VSTST_VARPTR_TYPE ptype8 = VSTST_VPT_UNDEFINED
	)
	{
	VSTST_MSG_TYPE_TABLE *pEntry = &g_msgTypes[type];
	pEntry->cbFixed = cbFixed;
	pEntry->cVarPtr = cVarPtr;
	pEntry->priority = priority;
	pEntry->pfnHandler = pfnHandler;
	pEntry->pointerTypes[0] = (BYTE) ptype1;
	pEntry->pointerTypes[1] = (BYTE) ptype2;
	pEntry->pointerTypes[2] = (BYTE) ptype3;
	pEntry->pointerTypes[3] = (BYTE) ptype4;
	pEntry->pointerTypes[4] = (BYTE) ptype5;
	pEntry->pointerTypes[5] = (BYTE) ptype6;
	pEntry->pointerTypes[6] = (BYTE) ptype7;
	pEntry->pointerTypes[7] = (BYTE) ptype8;
	};


 void InitMsgTypes()
	{
	AddMessageType
		(
		VSTST_MT_TEXT,
		FIELD_OFFSET(VSTST_TEXTMSG, pch),
		1,
		VSTST_MP_QUEUED,
		NULL,   //  Not needed by client, server will fill in
		VSTST_VPT_ANSI
		);

	AddMessageType
		(
		VSTST_MT_IMMEDIATETEXT,
		FIELD_OFFSET(VSTST_TEXTMSG, pch),
		1,
		VSTST_MP_IMMEDIATE,
		NULL,
		VSTST_VPT_ANSI
		);

	AddMessageType
		(
		VSTST_MT_FAILURE,
		FIELD_OFFSET(VSTST_FAILUREMSG, szFailure),
		1,
		VSTST_MP_QUEUED,
		NULL,
		VSTST_VPT_ANSI
		);

	AddMessageType
		(
		VSTST_MT_OPERATIONFAILURE,
		FIELD_OFFSET(VSTST_OPERATIONFAILUREMSG, szFailedOperation),
		1,
		VSTST_MP_QUEUED,
		NULL,
		VSTST_VPT_ANSI
		);

	AddMessageType
		(
		VSTST_MT_UNEXPECTEDEXCEPTION,
		FIELD_OFFSET(VSTST_UNEXPECTEDEXCEPTIONMSG, szFailedRoutine),
		1,
		VSTST_MP_QUEUED,
		NULL,
		VSTST_VPT_ANSI
		);

	AddMessageType
		(
		VSTST_MT_SUCCESS,
		FIELD_OFFSET(VSTST_SUCCESSMSG, szMsg),
		1,
		VSTST_MP_QUEUED,
		NULL,
		VSTST_VPT_ANSI
		);

    }


CVsTstClientMsg::CVsTstClientMsg() :
	m_bcsInitialized(false),
	m_rgbMsg(NULL),
	m_hPipe(INVALID_HANDLE_VALUE),
	m_bSkipWrites(false),
	m_seqQueued(0),
	m_seqImmediate(0)
	{
	}

CVsTstClientMsg::~CVsTstClientMsg()
	{
	delete m_rgbMsg;
	if (m_bcsInitialized)
		m_cs.Term();

	if (m_hPipe != INVALID_HANDLE_VALUE)
		CloseHandle(m_hPipe);
	}

// initialize messaging to test controller
HRESULT CVsTstClientMsg::Init
	(
	LONGLONG processId,
	UINT cbMaxMsg,
	bool bIgnorePipeCreationFailure
	)
	{
	m_processId = processId;
	try
		{
		m_cs.Init();
		m_bcsInitialized = true;
		}
	catch(...)
		{
		return E_UNEXPECTED;
		}

	m_hPipe = CreateFile
					(
					s_wszPipeName,
					GENERIC_WRITE,
					FILE_SHARE_READ|FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL
					);


   if (m_hPipe == INVALID_HANDLE_VALUE)
	   {
	   if (bIgnorePipeCreationFailure)
		   m_bSkipWrites = true;
	   else
		   return HRESULT_FROM_WIN32(GetLastError());
	   }
   else
	   {
	   m_cbMaxMsgLength = cbMaxMsg;
	   m_rgbMsg = new BYTE[cbMaxMsg];
	   if (m_rgbMsg == NULL)
		   {
		   CloseHandle(m_hPipe);
		   m_hPipe = INVALID_HANDLE_VALUE;
		   return E_OUTOFMEMORY;
		   }
	   }

   return S_OK;
   }

// send a message to the test controller
HRESULT CVsTstClientMsg::SendMessage(VSTST_MSG_TYPE type, void *pv)
	{
	m_cs.Lock();
	VSTST_ASSERT(type < VSTST_MT_MAXMSGTYPE);
	VSTST_MSG_TYPE_TABLE *pType = &g_msgTypes[type];

	VSTST_MSG_HDR *phdr = (VSTST_MSG_HDR *) m_rgbMsg;

	phdr->processId = m_processId;
	phdr->type = type;
	time(&phdr->time);
	if (pType->priority == VSTST_MP_IMMEDIATE)
		phdr->sequence = ++m_seqImmediate;
	else
		phdr->sequence = ++m_seqQueued;

	BYTE *pbMsg = phdr->rgb;

	size_t cbUsed = pType->cbFixed + FIELD_OFFSET(VSTST_MSG_HDR, rgb) +
				  pType->cVarPtr * sizeof(PVOID);

	if (cbUsed >= m_cbMaxMsgLength)
		{
		m_cs.Unlock();
		return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
		}

	// copy in fixed portion of data structure
	memcpy(pbMsg, pv, pType->cbFixed);
	pbMsg += pType->cbFixed;

	// reserve room for pointers
	memset(pbMsg, 0, pType->cVarPtr * sizeof(PVOID));
	pbMsg += pType->cVarPtr * sizeof(PVOID);

	// walk and write out pointer data
	VOID **ppv = (VOID **) ((BYTE *) pv + pType->cbFixed);
	for(UINT iPtr = 0; iPtr < pType->cVarPtr; iPtr++, ppv++)
		{
		VSTST_VARPTR_TYPE type = (VSTST_VARPTR_TYPE) pType->pointerTypes[iPtr];
		BYTE *pb = NULL;
		size_t cb = 0;

		switch(type)
			{
			default:
				VSTST_ASSERT(FALSE);
				break;

			case VSTST_VPT_BYTE:
				pb = *(BYTE **) ppv;
				cb = *(UINT *) *pb;
				break;

            case VSTST_VPT_ANSI:
				pb = *(BYTE **) ppv;
				cb = strlen((char *) pb) + 1;
				break;

			case VSTST_VPT_UNICODE:
				pb = *(BYTE **) ppv;
				cb = (wcslen((WCHAR *) pb) + 1) * sizeof(WCHAR);
				break;
			}

		// round up to alignment boundary
		size_t cbAlign = (cb + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1);

		// check for buffer overflow
		if (cbAlign + cbUsed >= m_cbMaxMsgLength)
			{
			m_cs.Unlock();
			return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
			}

		memcpy(pbMsg, pb, cb);

		// adjust pointer to alignment boundary
		pb += cbAlign;

		// adjust amount used
		cbUsed += cbAlign;
		}

	phdr->cbMsg = cbUsed;
	phdr->pmsgNext = NULL;

	DWORD cbWritten;
	if (!WriteFile(m_hPipe, m_rgbMsg, (UINT) cbUsed, &cbWritten, NULL) || cbUsed != cbWritten)
		{
		m_cs.Unlock();
		return HRESULT_FROM_WIN32(GetLastError());
		}

	VSTST_ASSERT(cbUsed == cbWritten);

	m_cs.Unlock();
	return S_OK;
	}

void CVsTstClientLogger::LogFailure(LPCSTR szFailure)
	{
	VSTST_ASSERT(m_pClient);
	VSTST_FAILUREMSG msg;
	msg.szFailure = szFailure;
	m_pClient->SendMessage(VSTST_MT_FAILURE, &msg);
	}

void CVsTstClientLogger::LogUnexpectedException(LPCSTR szRoutine)
	{
	VSTST_ASSERT(m_pClient);
	VSTST_UNEXPECTEDEXCEPTIONMSG msg;
	msg.szFailedRoutine = szRoutine;
	m_pClient->SendMessage(VSTST_MT_UNEXPECTEDEXCEPTION, &msg);
	}

void CVsTstClientLogger::ValidateResult(HRESULT hr, LPCSTR szOperation)
	{
	VSTST_ASSERT(m_pClient);
	if (FAILED(hr))
		{
		VSTST_OPERATIONFAILUREMSG msg;
		msg.hr = hr;
		msg.szFailedOperation = szOperation;
		m_pClient->SendMessage(VSTST_MT_OPERATIONFAILURE, &msg);
		throw hr;
		}
	}

void CVsTstClientLogger::LogSuccess(LPCSTR sz)
	{
	VSTST_ASSERT(m_pClient);
	VSTST_SUCCESSMSG msg;
	msg.szMsg = sz;
	m_pClient->SendMessage(VSTST_MT_SUCCESS, &msg);
	}

void CVsTstClientLogger::LogMessage(LPCSTR sz)
	{
	VSTST_ASSERT(m_pClient);

	VSTST_TEXTMSG msg;
	msg.pch = sz;
	m_pClient->SendMessage(VSTST_MT_TEXT, &msg);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\common\vststntlog.cxx ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    vststntlog.cxx

Abstract:

    Wrapper class for the test team's ntlog suite of APIs and VolSnap test harness.

Author:

    Stefan R. Steiner   [ssteiner]        06-05-2000

Revision History:

--*/

#include "stdafx.h"
#include "ntlog.h"
#include "vststntlog.hxx"

#define VS_TST_NT_LOG_INFO_LEVELS_AND_STYLES \
    TLS_INFO | TLS_WARN | TLS_SEV2 | TLS_PASS | TLS_VARIATION | TLS_REFRESH | TLS_TEST

/*++

Routine Description:

    Constructor for the CVsTstNtLog class

Arguments:

    None

--*/
CVsTstNtLog::CVsTstNtLog(
    IN LPCWSTR pwszLogFileName
    ) : m_cwsNtLogFileName( pwszLogFileName ),
        m_hNtLog( NULL ),
        m_bInVariation( FALSE ),
        m_dwHighestLogLev( TLS_PASS )
{
    //
    //  Create the NtLog log file
    //
    m_hNtLog = ::tlCreateLog( m_cwsNtLogFileName.c_str(), 
        VS_TST_NT_LOG_INFO_LEVELS_AND_STYLES );
    if ( m_hNtLog == NULL )
        VSTST_THROW( HRESULT_FROM_WIN32( ::GetLastError() ) ) ;

    //
    //  Add this thread as a participant
    //
    AddParticipant();
}


/*++

Routine Description:

    Destructor for the CVsTstNtLog class

Arguments:

    None

--*/
CVsTstNtLog::~CVsTstNtLog()
{
    if ( m_hNtLog != NULL )
    {
        //
        //  If we are still in a variation, end it
        //
        if ( m_bInVariation )
            EndVariation();

        //
        //  Specify that the test is finished
        //
        ::tlLog_W( m_hNtLog, m_dwHighestLogLev | TL_TEST, 
            L"Test finished, highest test log-lev: %d",
            m_dwHighestLogLev );
        
        //
        //  Report test stats
        //
        ::tlReportStats( m_hNtLog );

        //
        //  Remove main thread as a participant
        //
        ::tlRemoveParticipant( m_hNtLog );

        //
        //  Destroy the log object
        //
        ::tlDestroyLog( m_hNtLog );    
        
        m_hNtLog = INVALID_HANDLE_VALUE;
    }
}

/*++

Routine Description:

    When a new thread needs access to this logging object, this function
    needs to be called.

Arguments:

    None

Return Value:

    <Enter return values here>

--*/
VOID
CVsTstNtLog::AddParticipant()
{
    if ( !::tlAddParticipant( m_hNtLog, 0, 0 ) )
        VSTST_THROW( E_UNEXPECTED );

    //
    //  This next part is kind of a hack to make sure the new participant has
    //  a variation started.  This code needs to be changed when the coordinator
    //  is able to get it's message thread to start a variation.
    //
    if ( !m_cwsVariationName.IsEmpty() ) 
        if ( !::tlStartVariation( m_hNtLog ) )
            VSTST_THROW( E_UNEXPECTED );
    
    Log( eSevLev_Info, L"Participant added, thread id: 0x%04x", ::GetCurrentThreadId() );
}


/*++

Routine Description:

    When a thread is finished accessing this logging object, this function may
    be called.  The thread which created the object doesn't need to call this 
    function since it is done in the destructor.
    
Arguments:

    None

Return Value:

    <Enter return values here>

--*/
VOID
CVsTstNtLog::RemoveParticipant()
{
    ::tlRemoveParticipant( m_hNtLog );
    
    Log( eSevLev_Info, L"Participant removed, thread id: 0x%04x", ::GetCurrentThreadId() );
}


/*++

Routine Description:

    Call this function when a thread wants to start a new variation.

Arguments:

    None

Return Value:

    <Enter return values here>

--*/
VOID
CVsTstNtLog::StartVariation(
    IN LPCWSTR pwszVariationName
    )
{
    if ( m_bInVariation )
        EndVariation();
    
    m_cwsVariationName = pwszVariationName;    
    if ( !::tlStartVariation( m_hNtLog ) )
        VSTST_THROW( E_UNEXPECTED );
    
    m_bInVariation = TRUE;
    
    Log( eSevLev_Info, L"Variation '%s' started", m_cwsVariationName.c_str() );
}


/*++

Routine Description:

    Call this when a thread is finished with a variation.

Arguments:

    None

Return Value:

    Returns the most severe log-level encountered during the variation.

--*/
DWORD
CVsTstNtLog::EndVariation()
{
    DWORD dwMostSevereLev;    

    dwMostSevereLev = ::tlEndVariation( m_hNtLog );
    
    ::tlLog_W( m_hNtLog, dwMostSevereLev | TL_VARIATION, 
        L"Variation '%s' ended, highest log-lev: %d",
        m_cwsVariationName.c_str(), dwMostSevereLev );
        
    m_bInVariation = FALSE;
    m_cwsVariationName.Empty();
    return dwMostSevereLev;    
}


VOID 
CVsTstNtLog::Log(     
    IN EVsTstNtLogSeverityLevel eSevLev,
    IN LPCWSTR pwszFormat,
    IN ... 
    )
{
    va_list marker;
    va_start( marker, pwszFormat );

    CBsString cwsFormatted;

    cwsFormatted.FormatV( pwszFormat, marker );
    va_end( marker );

    DWORD dwStyle;
    switch( eSevLev )
    {
    case eSevLev_Info: dwStyle    = TLS_INFO; break;
    case eSevLev_Pass: dwStyle    = TLS_PASS; break;
    case eSevLev_Warning: dwStyle = TLS_WARN; break;
    case eSevLev_Severe: dwStyle  = TLS_SEV2; break;
    default:
        VSTST_THROW( E_FAIL );
    }
    
    if ( m_dwHighestLogLev > dwStyle )
         m_dwHighestLogLev = dwStyle;
        
    if ( m_bInVariation )
        dwStyle |= TLS_VARIATION;
    else
        dwStyle |= TLS_TEST;
    ::tlLog_W( m_hNtLog, dwStyle, TEXT( __FILE__ ), (int)__LINE__, L"%s", cwsFormatted.c_str() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\controller\stdafx.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <atlbase.h>
#include <vststtools.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\common\vststutil.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vststutil.cxx

Abstract:

    Implementation of CVsTstRandom class


    Brian Berkowitz  [brianb]  06/08/2000

TBD:
	

Revision History:

    Name        Date        Comments
    brianb      06/08/2000  Created

--*/

#include <stdafx.h>
#include <math.h>
#include <vststutil.hxx>

void CVsTstRandom::SetRandomSeed(UINT seed)
	{
	srand(seed);
	}

UINT CVsTstRandom::RandomChoice(UINT low, UINT high)
	{
	UINT val = rand();
	double d = (double) (high - low);
	double m = (double) val/ (double) RAND_MAX;
	double res = d * m + .5;
	return (UINT) floor(res);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\writer\stdafx.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <atlbase.h>
#include <vststtools.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\common\vststvolinfo.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

   vststvolinfo.cxx

Abstract:

    Implementation of volume information class


    Brian Berkowitz  [brianb]  06/06/2000

TBD:
	

Revision History:

    Name        Date        Comments
    brianb      06/06/2000  Created

--*/

#include <stdafx.h>
#include <vststvolinfo.hxx>



CVsTstVolumeInfo::CVsTstVolumeInfo() :
	m_wszVolumeName(NULL),
	m_wszFileSystemName(NULL),
	m_llTotalSize(0L),
	m_llTotalFreeSpace(0L),
	m_flags(0),
	m_driveType(0),
	m_pVolumeNext(NULL)
	{
	}

CVsTstVolumeInfo::~CVsTstVolumeInfo()
	{
	delete m_wszVolumeName;
	delete m_wszFileSystemName;
	}

void CVsTstVolumeList::FreeVolumeList()
	{
	CVsTstVolumeInfo *pVolume = m_pVolumeFirst;
	m_pVolumeFirst = NULL;
	while(pVolume)
		{
		CVsTstVolumeInfo *pVolumeNext = pVolume->m_pVolumeNext;

		delete pVolume;
		pVolume = pVolumeNext;
		}
	}


HRESULT CVsTstVolumeList::RefreshVolumeList()
	{
	FreeVolumeList();

	WCHAR bufVolumeName[MAX_PATH];

	HANDLE hVolumes = FindFirstVolume(bufVolumeName, sizeof(bufVolumeName));
	if (hVolumes == INVALID_HANDLE_VALUE)
		return HRESULT_FROM_WIN32(GetLastError());

	HRESULT hr = S_OK;

	try
		{
		do
			{
			WCHAR bufFileSystemName[MAX_PATH];
			DWORD serialNumber = 0;
			DWORD maxFileNameLength = 0;
			DWORD flags = 0;

			ULARGE_INTEGER freeSpace;
			ULARGE_INTEGER totalSpace;
			ULARGE_INTEGER totalFreeSpace;

			freeSpace.QuadPart = 0i64;
			totalSpace.QuadPart = 0i64;
			totalFreeSpace.QuadPart = 0i64;

			bufFileSystemName[0] = L'\0';

			UINT driveType = GetDriveType(bufVolumeName);

			if (driveType == DRIVE_FIXED)
				{
				if (!GetVolumeInformation
						(
						bufVolumeName,
						NULL,
						0,
						&serialNumber,
						&maxFileNameLength,
						&flags,
						bufFileSystemName,
						sizeof(bufFileSystemName)
						))
					throw(HRESULT_FROM_WIN32(GetLastError()));


				if (!GetDiskFreeSpaceEx
						(
						bufVolumeName,
						&freeSpace,
						&totalSpace,
						&totalFreeSpace
						))
					throw(HRESULT_FROM_WIN32(GetLastError()));
				}


			CVsTstVolumeInfo *pVolume = new CVsTstVolumeInfo;
			if (pVolume == NULL)
				throw(E_OUTOFMEMORY);

			pVolume->m_wszVolumeName = new WCHAR[wcslen(bufVolumeName) + 1];
			if (pVolume->m_wszVolumeName == NULL)
				{
				delete pVolume;
				throw(E_OUTOFMEMORY);
				}

			wcscpy(pVolume->m_wszVolumeName, bufVolumeName);

			pVolume->m_wszFileSystemName = new WCHAR[wcslen(bufFileSystemName) + 1];
			if (pVolume->m_wszFileSystemName == NULL)
				{
				delete pVolume;
				throw(E_OUTOFMEMORY);
				}

			wcscpy(pVolume->m_wszFileSystemName, bufFileSystemName);
			pVolume->m_llTotalSize = totalSpace.QuadPart;
			pVolume->m_llTotalFreeSpace = totalFreeSpace.QuadPart;
			pVolume->m_llUserFreeSpace = freeSpace.QuadPart;
			pVolume->m_flags = flags;
			pVolume->m_serialNumber = serialNumber;
			pVolume->m_driveType = driveType;
			pVolume->m_pVolumeNext = m_pVolumeFirst;
			m_pVolumeFirst = pVolume;
			} while(FindNextVolume(hVolumes, bufVolumeName, sizeof(bufVolumeName)));

		DWORD dwErr = GetLastError();
		if (dwErr != ERROR_NO_MORE_FILES)
			throw(HRESULT_FROM_WIN32(dwErr));
		}
	catch(HRESULT hrExcept)
		{
		hr = hrExcept;
		}
	catch(...)
		{
		hr = E_UNEXPECTED;
		}

	if (FAILED(hr))
		FreeVolumeList();

	FindVolumeClose(hVolumes);
	return hr;
	}
	

UINT CVsTstVolumeList::GetVolumeCount()
	{
	UINT cVolumes = 0;

	CVsTstVolumeInfo *pVolume = m_pVolumeFirst;
	while(pVolume)
		{
		cVolumes++;
		pVolume = pVolume->m_pVolumeNext;
		}

	return cVolumes;
	}

const CVsTstVolumeInfo *CVsTstVolumeList::GetVolumeInfo(UINT iVolume)
	{
	CVsTstVolumeInfo *pVolume = m_pVolumeFirst;

	while(pVolume && iVolume > 0)
		{
		pVolume = pVolume->m_pVolumeNext;
		iVolume--;
		}

	return pVolume;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\common\vststparser.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vststparser.cxx

Abstract:

    Implementation of CVsTstParser class


    Brian Berkowitz  [brianb]  06/07/2000

TBD:
	

Revision History:

    Name        Date        Comments
    brianb      06/07/2000  Created

--*/
#include <stdafx.h>
#include <bsstring.hxx>
#include <vststparser.hxx>

LPCWSTR CVsTstParser::SplitOptions(CBsString &bss)
	{
	bss.CopyBeforeWrite();
	LPCWSTR wsz = bss;
	LPCWSTR wszTop = bss;
	bool bMoreToDo = *wsz != L'\0';
	bool bLeadingSpacesFound = false;
	while(bMoreToDo)
		{
		while(*wsz == L' ')
			{
			bLeadingSpacesFound = true;
			wsz++;
			}

		LPCWSTR pwc = wsz;
		while(*pwc != L'\0' && *pwc != L',')
			pwc++;
		
		if (*pwc == L'\0')
			bMoreToDo = false;
		else
			bss.SetAt((UINT) (pwc - wszTop), L'\0');

		wsz = pwc + 1;
		}

	if (!bLeadingSpacesFound)
		return wsz;

	LPCWSTR wszEnd = wsz;
	wsz = bss;
    UINT iwc = 0;

	// remove leading spaces from options
	while(wsz < wszEnd)
		{
		while(*wsz == ' ')
			wsz++;

		while(*wsz != L'\0')
			bss.SetAt(iwc++, *wsz++);

		bss.SetAt(iwc++, *wsz++);
		}

	return wszEnd;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\jettest\stdafx.h ===
#include <wtypes.h>
#pragma warning( disable: 4201 )    // C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning( default: 4201 )	// C4201: nonstandard extension used : nameless struct/union
#include <winbase.h>



#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <stdio.h>
#include <stdlib.h>

#include <vs_assert.hxx>

#include <stddef.h>
#include <atlconv.h>
#include <atlbase.h>
CComModule _Module;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\common\vststprocess.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vststprocess.cxx

Abstract:

    Implementation of test message classes


    Brian Berkowitz  [brianb]  05/24/2000

TBD:
	

Revision History:

    Name        Date        Comments
    brianb      05/24/2000  Created

--*/


#include <stdafx.h>
#include <vststprocess.hxx>
#include <vststmsg.hxx>
#include <tstiniconfig.hxx>



void LogUnexpectedFailure(LPCWSTR, ...);


CVsTstProcessList::CVsTstProcessList() :
	m_processId(0L),
	m_processList(NULL),
	m_bcsProcessListInitialized(false),
	m_bNoMoreProcessesAreCreated(false),
	m_bShuttingDown(true)
	{
	}

CVsTstProcessList::~CVsTstProcessList()
	{
	m_bShuttingDown = true;

	if (WaitForSingleObject(m_hThreadMonitor, INFINITE) == WAIT_FAILED)
		{
		LogUnexpectedFailure(L"WaitForSingleObject failed for reason %d.\n", GetLastError());
		// wait for 1 minute for everything to shut down
		Sleep(60000);
		}

    CloseHandle(m_hThreadMonitor);
	if (m_bcsProcessListInitialized)
		m_csProcessList.Term();
	}


void CVsTstProcessList::LinkIntoProcessList(CVsTstProcess *process)
	{
	m_csProcessList.Lock();
	VSTST_ASSERT(m_processList == NULL || m_processList->m_prev == NULL);
	process->m_next = m_processList;
	process->m_prev = NULL;

	if (m_processList != NULL)
		m_processList->m_prev = process;

    m_processList = process;

	m_csProcessList.Unlock();
	}


void CVsTstProcessList::UnlinkFromProcessList(CVsTstProcess *process)
	{
	m_csProcessList.Lock();
	VSTST_ASSERT(m_processList);
	VSTST_ASSERT(m_processList->m_prev == NULL);

	if (process == m_processList)
		{
		m_processList = process->m_next;
		if (m_processList)
			{
			VSTST_ASSERT(m_processList->m_prev == process);
			m_processList->m_prev = NULL;
			}
		}
	else
		{
		VSTST_ASSERT(process->m_prev != NULL);
		process->m_prev->m_next = process->m_next;
		if (process->m_next)
			{
			VSTST_ASSERT(process->m_next->m_prev == process);
			process->m_next->m_prev = process->m_prev;
			}
		}

    m_csProcessList.Unlock();
	delete process;
	}

HRESULT CVsTstProcessList::Initialize
	(
	UINT maxLifetime,
	HANDLE hevtTermination
	)
	{
	try
		{
		m_csProcessList.Init();
		m_bcsProcessListInitialized = true;
		}
	catch(...)
		{
		return E_UNEXPECTED;
		}

	time_t timeCur;
	time(&timeCur);
	m_timeTerminateTest = timeCur + maxLifetime;
	m_hevtTermination = hevtTermination;

	DWORD tid;
	m_hThreadMonitor = CreateThread
							(
							NULL,
							256*1024,
							StartupMonitorThread,
							this,
							0,
							&tid
							);

    if (m_hThreadMonitor == NULL)
		return HRESULT_FROM_WIN32(GetLastError());

	return S_OK;
	}

DWORD CVsTstProcessList::StartupMonitorThread(void *pv)
	{
	CVsTstProcessList *processList = (CVsTstProcessList *) pv;

	try
		{
		processList->MonitorFunc();
		if (processList->m_hevtTermination)
			{
			if (!SetEvent(processList->m_hevtTermination))
				LogUnexpectedFailure(L"SetEvent failed with error %d", GetLastError());
			}
		}
	catch(...)
		{
		}

	return 0;
	}

//
void CVsTstProcessList::MonitorFunc()
	{
	while(TRUE)
		{
		time_t timeNow;
		Sleep(5000);

		time(&timeNow);
		if (timeNow > m_timeTerminateTest)
            {
			StartTermination();
            break;
            }
		else
			{
			m_csProcessList.Lock();

			// check if there are no processes and no more proceses
			// are created
			if (m_processList == NULL && m_bNoMoreProcessesAreCreated)
				{
				m_csProcessList.Unlock();
				break;
				}

			CVsTstProcess *process = m_processList;
			while(process != NULL)
				{
				CVsTstProcess *processNext = process->m_next;

                m_csProcessList.Unlock();
				if (process->HasProcessExpired())
					process->DoTerminateProcess(false);

                m_csProcessList.Lock();
				process = processNext;
				}

			m_csProcessList.Unlock();
			}
		}
	}

// start process termination
void CVsTstProcessList::StartTermination()
	{
	m_bNoMoreProcessesAreCreated = true;

	while(TRUE)
		{
		m_csProcessList.Lock();
		CVsTstProcess *process = m_processList;

		if (process == NULL)
			{
			m_csProcessList.Unlock();
			return;
			}
		
		while(process != NULL)
			{
			CVsTstProcess *processNext = process->m_next;
			m_csProcessList.Unlock();
			process->DoTerminateProcess(m_bShuttingDown);
			m_csProcessList.Lock();
			process = processNext;
			}

		// unlock list before going to sleep
		m_csProcessList.Unlock();
		Sleep(5000);
		}
	}


// constructor
CVsTstProcess::CVsTstProcess(CVsTstProcessList *list) :
	m_hProcess(NULL),
	m_hevtGracefullyTerminate(NULL),
	m_hevtNotifyProcessTermination(NULL),
	m_pvPrivateData(NULL),
	m_next(NULL),
	m_prev(NULL),
	m_bLinked(false),
	m_processList(list),
	m_bGracefullyTerminated(false)
	{
	}

// deastructor
CVsTstProcess::~CVsTstProcess()
	{
	if (m_bLinked)
		m_processList->UnlinkFromProcessList(this);

	if (m_hevtGracefullyTerminate)
		CloseHandle(m_hevtGracefullyTerminate);
	}


HRESULT CVsTstProcess::InitializeConformingExe
	(
	ULONGLONG processId,
	VSTST_PROCESS_TYPE type,
	VSTST_ACCOUNT_TYPE account,
	LPCWSTR wszExecutableName,
	LPCWSTR wszScenarioFile,
	LPCWSTR wszSection,
	DWORD seed,
	UINT lifetime,
	bool bAbnormalTermination,
	HANDLE hevtNotify
	)
	{
	WCHAR buf[256];
	SECURITY_ATTRIBUTES attributes;

	m_processId = processId;
	m_type = type;
	m_account = account;
	m_bConforming = true;
	
	attributes.nLength = sizeof(SECURITY_ATTRIBUTES);
	attributes.lpSecurityDescriptor = NULL;
	attributes.bInheritHandle = true;
    m_hevtGracefullyTerminate = CreateEvent(&attributes, TRUE, FALSE, NULL);
	if (m_hevtGracefullyTerminate == NULL)
		return HRESULT_FROM_WIN32(GetLastError());

	UINT pidLow = (UINT) (m_processId & 0xffffffff);
	UINT pidHigh = (UINT) (m_processId >> 32);
	swprintf
		(
		buf,
		L"%s -pidLow=%d -pidHigh=%d -scenario={%s} -section={%s} -seed=%u -lifetime=%d -event=0x%08x",
		wszExecutableName,
		pidLow,
		pidHigh,
		wszScenarioFile,
		wszSection,
		seed,
		lifetime,
		m_hevtGracefullyTerminate
		);

	PROCESS_INFORMATION info;
    STARTUPINFO startup;
    memset(&startup, 0, sizeof(STARTUPINFO));
    startup.cb = sizeof(STARTUPINFO);
	if (!CreateProcess
			(
			NULL,
			buf,
			NULL,
			NULL,
			TRUE,
			NORMAL_PRIORITY_CLASS,
			NULL,
			NULL,
            &startup,
			&info
			))
        {
		DWORD dwErr = GetLastError();
		CloseHandle(m_hevtGracefullyTerminate);
		m_hevtGracefullyTerminate = NULL;
		return HRESULT_FROM_WIN32(dwErr);
		}

	m_hProcess = info.hProcess;
	m_hevtNotifyProcessTermination = hevtNotify;
	m_bAbnormallyTerminate = bAbnormalTermination;
	time(&m_timeProcessStart);
	m_timeProcessTerminate = m_timeProcessStart + lifetime;
	m_processList->LinkIntoProcessList(this);
	return S_OK;
	}

// startup a process associated with a non-conforming executable
HRESULT CVsTstProcess::InitializeNonConformingExe
	(
	ULONGLONG processId,
	VSTST_PROCESS_TYPE type,
	VSTST_ACCOUNT_TYPE account,
	LPCWSTR wszCommandLine,
	UINT lifetime,
	HANDLE hevtNotify
	)
	{
	m_processId = processId;
	m_type = type;
	m_account = account;
	m_bConforming = false;
	
	PROCESS_INFORMATION info;
    STARTUPINFO startup;

    memset(&startup, 0, sizeof(STARTUPINFO));
    startup.cb = sizeof(STARTUPINFO);
	if (!CreateProcess
			(
			NULL,
			(LPWSTR) wszCommandLine,
			NULL,
			NULL,
			TRUE,
			NORMAL_PRIORITY_CLASS,
			NULL,
			NULL,
			&startup,
			&info
			))
		return HRESULT_FROM_WIN32(GetLastError());

	m_hProcess = info.hProcess;
	m_hevtNotifyProcessTermination = hevtNotify;
	m_bAbnormallyTerminate = true;
	time(&m_timeProcessStart);
	m_timeProcessTerminate = m_timeProcessStart + lifetime;
	m_processList->LinkIntoProcessList(this);
	return S_OK;
	}

void CVsTstProcess::DoTerminateProcess(bool bAgressive)
	{
	if (m_bAbnormallyTerminate)
		ForceTerminateProcess();
	else if (!m_bGracefullyTerminated)
		GracefullyTerminateProcess(bAgressive);
	else
		{
		// see if process is terminated
		DWORD dwErr = WaitForSingleObject(m_hProcess, 0);
		
		if (dwErr == WAIT_FAILED)
			ForceTerminateProcess();
		else if (dwErr == WAIT_TIMEOUT)
			{
			time_t timeCur;
			time(&timeCur);
			if (m_timeProcessTerminationExpiration < timeCur)
				// forcefully terminate the process
				ForceTerminateProcess();

			// if we are shutting down, give the process 10 seconds
			// to shut down before we forcefully terminate it
			if (bAgressive && m_timeProcessTerminationExpiration > timeCur + 10)
				m_timeProcessTerminationExpiration = timeCur + 10;
			}
		else
			CleanupProcess();
		}
	}


// has process expired
bool CVsTstProcess::HasProcessExpired()
    {
    // see if process is terminated
    DWORD dwErr = WaitForSingleObject(m_hProcess, 0);
    if (dwErr == WAIT_OBJECT_0)
        {
        CleanupProcess();
        return false;
        }
	
    time_t timeVal;

    time(&timeVal);

    return timeVal > m_timeProcessTerminate;
    }


// cleanup process at termination				
void CVsTstProcess::CleanupProcess()
	{
	if (m_hevtNotifyProcessTermination)
		{
		if (!SetEvent(m_hevtNotifyProcessTermination))
			LogUnexpectedFailure(L"SetEvent failed with error %d", GetLastError());
		}

	m_processList->UnlinkFromProcessList(this);
	}

// forceably terminate the process
void CVsTstProcess::ForceTerminateProcess()
	{
	if (!TerminateProcess(m_hProcess, 0))
		LogUnexpectedFailure(L"Terminate process failed with error %d", GetLastError());

	CleanupProcess();
	}

// try terminating the process gracefully
void CVsTstProcess::GracefullyTerminateProcess(bool bAgressive)
	{
	VSTST_ASSERT(m_hevtGracefullyTerminate);

	if (!SetEvent(m_hevtGracefullyTerminate))
		LogUnexpectedFailure(L"SetEvent failed with error %d", GetLastError());

	m_bGracefullyTerminated = true;
	time(&m_timeProcessStartTermination);

	// allow 2 minutes for the process to gracefully terminate, 10 seconds if
	// if we are agressive
	m_timeProcessTerminationExpiration = m_timeProcessStartTermination + bAgressive ? 10 : 120;
	}


HRESULT CVsTstProcessList::CreateConformingExe
	(
	VSTST_PROCESS_TYPE type,
	VSTST_ACCOUNT_TYPE account,
	LPCWSTR wszExecutableName,
	LPCWSTR wszScenarioFile,
	LPCWSTR wszSectionName,
	DWORD seed,
	UINT lifetime,
	bool bAbnormalTerminate,
	HANDLE hevtNotify,
	ULONGLONG &processId
	)
	{
	processId = AllocateProcessId();
	CVsTstProcess *process = new CVsTstProcess(this);
	if (process == NULL)
		return E_OUTOFMEMORY;

	HRESULT hr = process->InitializeConformingExe
					(
					processId,
					type,
					account,
					wszExecutableName,
					wszScenarioFile,
					wszSectionName,
					seed,
					lifetime,
					bAbnormalTerminate,
					hevtNotify
					);

	if (FAILED(hr))
		delete process;

	return hr;
	}

// create a process for a non-conforming executable
HRESULT CVsTstProcessList::CreateNonConformingExe
	(
	VSTST_PROCESS_TYPE type,
	VSTST_ACCOUNT_TYPE account,
	LPCWSTR wszCommandLine,
	UINT lifetime,
	HANDLE hevtNotify,
	ULONGLONG &processId
	)
	{
	processId = AllocateProcessId();
	CVsTstProcess *process = new CVsTstProcess(this);
	if (process == NULL)
		return E_OUTOFMEMORY;

	HRESULT hr = process->InitializeNonConformingExe
					(
					processId,
					type,
					account,
					wszCommandLine,
					lifetime,
					hevtNotify
					);

	if (FAILED(hr))
		delete process;

	return hr;
	}

// find a specific process
CVsTstProcess *CVsTstProcessList::FindProcess(ULONGLONG processId)
	{
	m_csProcessList.Lock();
	CVsTstProcess *process = m_processList;
	while(process != NULL)
		{
		if (process->m_processId == processId)
			{
			m_csProcessList.Unlock();
			return process;
			}

		process = process->m_next;
		}

	return NULL;
	}



// get private data associated with a process
void *CVsTstProcessList::GetProcessPrivateData(LONGLONG processId)
	{
	CVsTstProcess *process = FindProcess(processId);

	if (process == NULL)
		return NULL;
	else
		return process->GetPrivateData();
	}

	// set private data associated with a process
void CVsTstProcessList::SetProcessPrivateData(LONGLONG processId, void *pv)
	{
	CVsTstProcess *process = FindProcess(processId);

	if (process != NULL)
		process->SetPrivateData(pv);
	}

// indicate that no more processes will be created
void CVsTstProcessList::EndOfProcessCreation()
	{
	m_bNoMoreProcessesAreCreated = true;
	}

ULONGLONG CVsTstProcessList::AllocateProcessId()
	{
	m_csProcessList.Lock();
	ULONGLONG processId = ++m_processId;
	m_csProcessList.Unlock();

	return processId;
	}

static VSTST_CMDDESC x_rgCommands[] =
	{
		{
		L"scenario",
		VSTST_CT_STRING,
		VSTST_CP_SCENARIOFILE
		},
		{
		L"testseries",
		VSTST_CT_STRING,
		VSTST_CP_TESTSERIES
		},
		{
		L"section",
		VSTST_CT_STRING,
		VSTST_CP_SECTIONNAME
		},
		{
		L"seed",
		VSTST_CT_UINT,
		VSTST_CP_SEED
		},
		{
		L"lifetime",
		VSTST_CT_UINT,
		VSTST_CP_LIFETIME,
		},
		{
		L"event",
		VSTST_CT_HANDLE,
		VSTST_CP_TERMINATIONEVENT
		},
		{
		L"pidLow",
		VSTST_CT_UINT,
		VSTST_CP_PIDLOW
		},
		{
		L"pidHigh",
		VSTST_CT_UINT,
		VSTST_CP_PIDHIGH
		}

	};

static UINT x_cCommands = sizeof(x_rgCommands)/sizeof(x_rgCommands[0]);

// constructor
CVsTstParams::CVsTstParams() :
	m_wszScenarioFile(NULL),
	m_wszSectionName(NULL),
	m_wszTestSeries(NULL),
	m_supplied(0)
	{
	}

// destructor
CVsTstParams::~CVsTstParams()
	{
	delete m_wszScenarioFile;
	delete m_wszSectionName;
	}

// parse the command line
bool CVsTstParams::ParseCommandLine(WCHAR **argv, UINT argc)
	{
	for(UINT iarg = 1; iarg < argc; iarg++)
		{
		WCHAR *wsz = argv[iarg];

		if (wsz[0] != '-')
			return false;

		wsz++;

		WCHAR *pwc = wsz;
		while(*pwc != L'\0' && *pwc != L'=')
			pwc++;

		if (*pwc != '=')
			return false;

		*pwc++ = '\0';
		for(UINT icmd = 0; icmd < x_cCommands; icmd++)
			{
			if (wcscmp(wsz, x_rgCommands[icmd].wszParam) == 0)
				break;
			}

		if (icmd == x_cCommands)
			return false;

		VSTST_CMDDESC *pCommand = &x_rgCommands[icmd];
		UINT ulVal;
		LPWSTR wszVal;
		HANDLE hVal;

		switch(pCommand->type)
			{
			default:
				VSTST_ASSERT(FALSE && "shouldn't get here");
				return false;

            case VSTST_CT_UINT:
				if (!ParseUINT(pwc, &ulVal))
					return false;
					
				switch(pCommand->param)
					{
					default:
						VSTST_ASSERT(FALSE && "shouldn't get here");
						return false;

					case VSTST_CP_SEED:
						SetSeed(ulVal);
						break;

					case VSTST_CP_LIFETIME:
						SetLifetime(ulVal);
						break;

                    case VSTST_CP_PIDLOW:
						SetPidLow(ulVal);
						break;

                    case VSTST_CP_PIDHIGH:
						SetPidHigh(ulVal);
						break;
					}	

				break;

            case VSTST_CT_HANDLE:
				if (!ParseHandle(pwc, &hVal))
					return false;

				if (pCommand->param == VSTST_CP_TERMINATIONEVENT)
					SetTerminationEvent(hVal);
				else
					{
					VSTST_ASSERT(FALSE && "shouldn't get here");
					return false;
					}

				break;


            case VSTST_CT_STRING:
				if (!ParseString(pwc, &wszVal))
					return false;

				switch(pCommand->param)
					{
					default:
						VSTST_ASSERT(FALSE && "shouldn't get here");
						return false;

					case VSTST_CP_SCENARIOFILE:
						SetScenarioFile(wszVal);
						break;

                    case VSTST_CP_TESTSERIES:
						SetTestSeries(wszVal);
						break;

					case VSTST_CP_SECTIONNAME:
						SetSectionName(wszVal);
						break;

					}

				break;
			}
		}

	m_hTestTerminationEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (m_hTerminationEvent == NULL)
		return false;

	m_supplied |= VSTST_CP_TESTTERMINATIONEVENT;

	return true;
	}

bool CVsTstParams::ParseUINT(LPCWSTR wsz, UINT *pulVal)
	{
	UINT ulVal = 0;

	if (*wsz == L'\0')
		return false;

	do
		{
		WCHAR wc = *wsz++;

		if (wc < L'0' || wc > L'9')
			return false;

		UINT ulValNew = ulVal * 10 + (wc - L'0');
		if (ulValNew < ulVal)
			return false;

		ulVal = ulValNew;
		} while(*wsz != L'\0');

    *pulVal = ulVal;
	return true;
	}

// parse a string value of the form "..."
bool CVsTstParams::ParseString(LPCWSTR wsz, LPWSTR *pwszVal)
	{
	if (*wsz != L'{')
		return false;

	wsz++;
	LPCWSTR wszStart = wsz;

	while(*wsz != L'\0' && *wsz != '}')
		wsz++;

	if (*wsz != L'}')
		return false;

	UINT cwc = (UINT)( wsz - wszStart );

	LPWSTR wszRet = new WCHAR[cwc + 1];
	memcpy(wszRet, wszStart, cwc * sizeof(WCHAR));
	wszRet[cwc] = L'\0';
	*pwszVal = wszRet;
	return true;
	}

bool CVsTstParams::ParseHandle(LPCWSTR wsz, HANDLE *phVal)
	{
	UINT ulVal = 0;

	if (*wsz++ != L'0')
		return false;

	if (*wsz++ != L'x')
		return false;

	if (*wsz == L'\0')
		return false;

	do
		{
		WCHAR wc = *wsz++;
		UINT digit;

		if (wc >= L'0' && wc <= L'9')
			digit = wc - L'0';
		else if (wc >= L'a' && wc <= L'f')
			digit = wc - L'a' + 10;
		else if (wc >= L'A' && wc <= L'F')
			digit = wc - L'A' + 10;
		else
			return false;

		if (ulVal & 0xf0000000)
			return false;

		ulVal = ulVal << 4 | digit;
		} while(*wsz != L'\0');

    *phVal = (HANDLE)(ULONGLONG) ulVal;
	return true;
	}

bool CVsTstParams::GetScenarioFileName(LPCWSTR *pwszScenarioFile)
	{
	if ((m_supplied & VSTST_CP_SCENARIOFILE) == 0)
		{
		*pwszScenarioFile = NULL;
		return false;
		}
	else
		{
		*pwszScenarioFile = m_wszScenarioFile;
		return true;
		}
	}

bool CVsTstParams::GetTestSeries(LPCWSTR *pwszTestSeries)
	{
	if ((m_supplied & VSTST_CP_TESTSERIES) == 0)
		{
		*pwszTestSeries = NULL;
		return false;
		}
	else
		{
		*pwszTestSeries = m_wszTestSeries;
		return true;
		}
	}



bool CVsTstParams::GetSectionName(LPCWSTR *pwszSectionName)
	{
	if ((m_supplied & VSTST_CP_SECTIONNAME) == 0)
		{
		*pwszSectionName = NULL;
		return false;
		}
	else
		{
		*pwszSectionName = m_wszSectionName;
		return true;
		}
	}


bool CVsTstParams::GetRandomSeed(UINT *pSeed)
	{
	if ((m_supplied & VSTST_CP_SEED) == 0)
		return false;
	else
		{
		*pSeed = m_seed;
		return true;
		}
	}

bool CVsTstParams::GetLifetime(UINT *pLifetime)
	{
	if ((m_supplied & VSTST_CP_LIFETIME) == 0)
		return false;
	else
		{
		*pLifetime = m_lifetime;
		return true;
		}
	}

bool CVsTstParams::GetTerminationEvent(HANDLE *pHandle)
	{
	if ((m_supplied & VSTST_CP_TERMINATIONEVENT) == 0)
		{
		*pHandle = NULL;
		return false;
		}
	else
		{
		*pHandle = m_hTerminationEvent;
		return true;
		}
	}

bool CVsTstParams::GetTestTerminationEvent(HANDLE *pHandle)
	{
	if ((m_supplied & VSTST_CP_TESTTERMINATIONEVENT) == 0)
		{
		*pHandle = NULL;
		return false;
		}
	else
		{
		*pHandle = m_hTestTerminationEvent;
		return true;
		}
	}

bool CVsTstParams::GetProcessId(ULONGLONG *pid)
	{
	if ((m_supplied & VSTST_CP_PIDLOW) == 0)
		return false;
	else if ((m_supplied & VSTST_CP_PIDHIGH) == 0)
		{
		*pid = m_pidLow;
		return true;
		}
	else
		{
		*pid = (((ULONGLONG) m_pidHigh) << 32) + m_pidLow;
		return true;
		}
	}

void CVsTstParams::SetSeed(UINT ulVal)
	{
	if (ulVal != 0)
		{
		m_supplied |= VSTST_CP_SEED;
		m_seed = ulVal;
		}
	}

void CVsTstParams::SetLifetime(UINT ulVal)
	{
	if (ulVal != 0)
		{
		m_supplied |= VSTST_CP_LIFETIME;
		m_lifetime = ulVal;
		}
	}

void CVsTstParams::SetPidLow(UINT ulVal)
	{
	m_supplied |= VSTST_CP_PIDLOW;
	m_pidLow = ulVal;
	}

void CVsTstParams::SetPidHigh(UINT ulVal)
	{
	m_supplied |= VSTST_CP_PIDHIGH;
	m_pidHigh = ulVal;
	}

void CVsTstParams::SetTerminationEvent(HANDLE hEvent)
	{
	if (hEvent != NULL)
		{
		m_supplied |= VSTST_CP_TERMINATIONEVENT;
		m_hTerminationEvent = hEvent;
		}
	}

void CVsTstParams::SetScenarioFile(LPWSTR wsz)
	{
	m_supplied |= VSTST_CP_SCENARIOFILE;
	m_wszScenarioFile = wsz;
	}

void CVsTstParams::SetTestSeries(LPWSTR wsz)
	{
	m_supplied |= VSTST_CP_TESTSERIES;
	m_wszTestSeries = wsz;
	}


void CVsTstParams::SetSectionName(LPWSTR wsz)
	{
	m_supplied |= VSTST_CP_SECTIONNAME;
	m_wszSectionName = wsz;
	}


// arguments to the test termination thread
typedef struct _TerminationThreadParams
	{
	CVsTstParams *pParams;
	IVsTstRunningTest *pTest;
	} TerminationThreadParams;

static LPCWSTR x_wszVssTestController = L"VssTestController.";
static LPCWSTR x_wszVssTestRequestor = L"VssTestRequestor.";
static LPCWSTR x_wszVssTestWriter = L"VssTestWriter.";

// toplevel routine to run a test
// it parses the parameters
// creates a configuration file parser
// creates a message pipe to the server
// creates a thread to terminate the test
// calls the supplied test
//
HRESULT CVsTstRunner::RunVsTest
	(
	WCHAR **argv,
	UINT argc,
	IVsTstRunningTest *pTest,
	bool bCreateTerminationThread
	)
	{
	CVsTstParams params;
	params.ParseCommandLine(argv, argc);
	LPCWSTR wszScenarioFile, wszSectionName, wszQualifier;

	if (!params.GetScenarioFileName(&wszScenarioFile) ||
		!params.GetSectionName(&wszSectionName))
		{
		VSTST_ASSERT(FALSE && "missing scenario");
		return E_FAIL;
		}

	EVsTstINISectionType sectionType;

	if (memcmp(wszSectionName, x_wszVssTestWriter, wcslen(x_wszVssTestWriter) * sizeof(WCHAR)) == 0)
		{
		sectionType = eVsTstSectionType_TestWriter;
		wszQualifier = wszSectionName + wcslen(x_wszVssTestWriter);
		}
	else if (memcmp(wszSectionName, x_wszVssTestRequestor, wcslen(x_wszVssTestRequestor)) == 0)
		{
		sectionType = eVsTstSectionType_TestRequesterApp;
		wszQualifier = wszSectionName + wcslen(x_wszVssTestRequestor);
		}
	else if (memcmp(wszSectionName, x_wszVssTestController, wcslen(x_wszVssTestController)) == 0)
		{
		sectionType = eVsTstSectionType_TestCoordinator;
		wszQualifier = wszSectionName + wcslen(x_wszVssTestController);
		}
	else
		{
		VSTST_ASSERT(FALSE && "bad test type");
		return E_FAIL;
		}

	HRESULT hr = S_OK;
	DWORD tid;

	TerminationThreadParams *pTTParm = NULL;
	HANDLE hTerminationThread = NULL;

	if (bCreateTerminationThread)
		{
        pTTParm = new TerminationThreadParams;
		if (pTTParm == NULL)
			{
			VSTST_ASSERT(FALSE && "Out of memory");
			return E_OUTOFMEMORY;
			}

		pTTParm->pParams = &params;
		pTTParm->pTest = pTest;
		hTerminationThread = CreateThread
								(
								NULL,
								32*1024,
								CVsTstRunner::StartupTerminationThread,
								pTTParm,
								0,
								&tid
								);

		if(hTerminationThread == NULL)
			{
			VSTST_ASSERT(FALSE && "Thread creation failed");
			delete pTTParm;
			return HRESULT_FROM_WIN32(GetLastError());
			}
		}

	try
		{
		InitMsgTypes();
		unsigned cwc = (unsigned)wcslen(wszScenarioFile);
		WCHAR *wszFileName = new WCHAR[cwc * 2];
		if (!ExpandEnvironmentStrings(wszScenarioFile, wszFileName, cwc * 2))
			{
			VSTST_ASSERT(FALSE && "ExpandEnvironmentStrings failed");
			LogUnexpectedFailure(L"ExpandEnvironmentStrings failed with error %d", GetLastError());
			throw E_UNEXPECTED;
			}

		CVsTstINIConfig config(sectionType, wszQualifier, FALSE, wszFileName);
		CVsTstClientMsg client;
		ULONGLONG processId;
		if (!params.GetProcessId(&processId))
			{
			VSTST_ASSERT(FALSE && "no process id");
			throw(E_FAIL);
			}

		client.Init(processId, 1024, false);
		hr = pTest->RunTest(&config, &client, &params);
		}
	catch(...)
		{
		VSTST_ASSERT(FALSE && "unexpected exception");
		hr = E_FAIL;
		}

	HANDLE hTestTerminationEvent;

	if (!params.GetTestTerminationEvent(&hTestTerminationEvent))
		LogUnexpectedFailure(L"Test Termination Event wasn't created");
	else if (!SetEvent(hTestTerminationEvent))
		LogUnexpectedFailure(L"SetEvent failed with error %d", GetLastError());
	else
		{
        if (hTerminationThread != NULL &&
			WaitForSingleObject(hTerminationThread, INFINITE) == WAIT_FAILED)
			LogUnexpectedFailure(L"WaitForSingleObject failed with error %d", GetLastError());
		}

	if (hTerminationThread != NULL)
		CloseHandle(hTerminationThread);

	return hr;
	}

// termination thread routine waits until either
// test lifetime is exceeded
// termination event is set by controller
// test termination event is set when test completes
//
DWORD CVsTstRunner::StartupTerminationThread(void *pv)
	{
	TerminationThreadParams *pTTParms = (TerminationThreadParams *) pv;
	CVsTstParams *pParams = pTTParms->pParams;
	IVsTstRunningTest *pTest = pTTParms->pTest;

	delete pTTParms;

	HANDLE hTestTerminationEvent;
	HANDLE hTerminationEvent = NULL;
	if (!pParams->GetTestTerminationEvent(&hTestTerminationEvent))
		{
		LogUnexpectedFailure(L"No Test Termination event was created.");
		return 0xffffffff;
		}

	pParams->GetTerminationEvent(&hTerminationEvent);

	UINT ulLifetime;
	bool bLifetime = pParams->GetLifetime(&ulLifetime);

	// more than one months worth of lifetime is infinite
	if (bLifetime && ulLifetime < 3600 * 24 * 30)
		ulLifetime = ulLifetime * 1000;
	else
		ulLifetime = INFINITE;

	HANDLE rghEvt[2];
	unsigned cEvt = 1;

	rghEvt[0] = hTestTerminationEvent;
	if (hTerminationEvent != NULL)
		{
		rghEvt[1] = hTerminationEvent;
		cEvt++;
		}

	DWORD dwWait = WaitForMultipleObjects(cEvt, rghEvt, FALSE, ulLifetime);

	if (dwWait == WAIT_FAILED)
		LogUnexpectedFailure(L"Wait failed for reason %d", GetLastError());
	else if (dwWait == WAIT_TIMEOUT)
		pTest->ShutdownTest(VSTST_SR_LIFETIME_EXCEEDED);
	else if (dwWait == WAIT_OBJECT_0 + 1)
		pTest->ShutdownTest(VSTST_SR_CONTROLLER_SIGNALLED);

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\common\test\commontest.cxx ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    client.cpp

Abstract:

    Test program to drive the 

Author:

    Stefan R. Steiner   [ssteiner]        01-30-2000

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
//  Defines

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes

#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdio.h>
#include <objbase.h>

#include "vststtools.hxx"
#include "tstiniconfig.hxx"

static BOOL AssertPrivilege( LPCWSTR privName );

/////////////////////////////////////////////////////////////////////////////
//  WinMain

extern "C" int __cdecl wmain( int argc, WCHAR *argv[] )
{
    HRESULT hr;
    if ( !AssertPrivilege( SE_BACKUP_NAME ) )
    {
        wprintf( L"AssertPrivilege returned error, rc:%d\n", GetLastError() );
        return 2;
    }
    
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( FAILED( hr ) )
    {
        wprintf( L"CoInitialize() returned rc:%d\n", GetLastError() );
        return 1;
    }
  
    try 
    {
        CVsTstINIConfig cINIConfigWriter( eVsTstSectionType_TestWriter );
        BOOL bOverridden;
        CBsString cwsString;
        cINIConfigWriter.GetOptionValue( L"UserAccount", &cwsString, &bOverridden );
        wprintf( L"Writer: UserAccount: '%s' %s\n", cwsString.c_str(),
            bOverridden ? L" - Overridden" : L"" );

        CVsTstINIConfig cINIConfigCoordinator( eVsTstSectionType_TestCoordinator );

        LONGLONG llMaxValue;
        LONGLONG llMinValue;
        cINIConfigCoordinator.GetOptionValue( L"Coordinatorstoptime", &llMinValue, &llMaxValue, &bOverridden );
        wprintf( L"Coordinator: CoordinatorStopTime: %I64d...%I64d %s\n", llMinValue, llMaxValue,
            bOverridden ? L" - Overridden" : L"" );

        cINIConfigCoordinator.GetOptionValue( L"Coordinatorstart", &cwsString, &bOverridden );
        wprintf( L"Coordinator: CoordinatorStart: '%s' %s\n", cwsString.c_str(),
            bOverridden ? L" - Overridden" : L"" );

        CVsTstINIConfig cINIConfigProvider( eVsTstSectionType_TestProvider );
        CVsTstINIConfig cINIConfigRequester( eVsTstSectionType_TestRequesterApp );
        //
        //  The next call will cause an exception.
        //
//        cINIConfigWriter.GetOptionValue( L"Level", &eBoolVal );
    }
    catch( CVsTstINIConfigException cConfigException )
    {
        wprintf( L"Error: %s\n", cConfigException.GetExceptionString().c_str() );
    }
    catch( HRESULT hr )
    {
        wprintf( L"Caught HRESULT exception, hr = 0x%08x\n", hr );
    }
    catch( ... )
    {
        wprintf( L"Caught expected exception\n" );
    }
     
    // Uninitialize COM library
    CoUninitialize();

    return 0;

    UNREFERENCED_PARAMETER( argv );
    UNREFERENCED_PARAMETER( argc );
}


static BOOL AssertPrivilege( LPCWSTR privName )
{
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if ( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &tokenHandle ) )
    {
        LUID value;

        if ( LookupPrivilegeValue( NULL, privName, &value ) )
        {
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            /*
            * We will always call GetLastError below, so clear
            * any prior error values on this thread.
            */
            SetLastError( ERROR_SUCCESS );

            stat =  AdjustTokenPrivileges( 
                tokenHandle,
                FALSE,
                &newState,
                (DWORD)0,
                NULL,
                NULL );
            /*
            * Supposedly, AdjustTokenPriveleges always returns TRUE
            * (even when it fails). So, call GetLastError to be
            * extra sure everything's cool.
            */
            if ( (error = GetLastError()) != ERROR_SUCCESS )
            {
                stat = FALSE;
            }

            if ( !stat )
            {
                wprintf( L"AdjustTokenPrivileges for %s failed with %d",
                    privName,
                    error );
            }
        }
        CloseHandle( tokenHandle );
    }
    return stat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\controller\controller.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    controller.cpp

Abstract:

    main module of controller exe


    Brian Berkowitz  [brianb]  05/23/2000

TBD:
	

Revision History:

    Name        Date        Comments
    brianb      05/23/2000  Created

--*/

#include <stdafx.h>
#include <bsstring.hxx>
#include <vststmsg.hxx>
#include <tstiniconfig.hxx>
#include <vststmsghandler.hxx>
#include <vststprocess.hxx>
#include <winsvc.h>
#include <vss.h>
#include <vscoordint.h>
#include <vststutil.hxx>


#ifdef _DEBUG
#pragma warning(disable: 4701)  // local variable *may* be used without init
#endif

CVsTstNtLog *g_pcTstNtLog = NULL;

void LogUnexpectedFailure(LPCWSTR, ...);

static LPCWSTR x_wszVssTestController = L"VssTestController.";
static LPCWSTR x_wszVssTestRequestor = L"VssTestRequestor.";
static LPCWSTR x_wszVssTestWriter = L"VssTestWriter.";
static LPCWSTR x_wszProcessExecutable = L"ProcessExecutable";
static LPCWSTR x_wszMaxTestTime = L"MaxTestTime";
static LPCWSTR x_wszProcessesToStart = L"ProcessesToStart";
static LPCWSTR x_wszProcessCommandLine = L"ProcessCommandLine";
static LPCWSTR x_wszConformingExecutable = L"ConformingExecutable";
static LPCWSTR x_wszCoordinatorStart = L"CoordinatorStart";
static LPCWSTR x_wszNo = L"No";
static LPCWSTR x_wszStart = L"Start";
static LPCWSTR x_wszStop = L"Stop";
static LPCWSTR x_wszRestart = L"Restart";
static LPCWSTR x_wszDeleteExistingSnapshots = L"DeleteExistingSnapshots";



// name of volume snapshot service
static LPCWSTR x_wszVSS = L"VSS";


BOOL EnableDebugPriv(VOID)

/*++

Routine Description:

    Changes the process's privilege so that controller works properly.

Arguments:


Return Value:

    TRUE             - success
    FALSE            - failure

--*/

	{
    HANDLE hToken;
    LUID DebugValue;
    TOKEN_PRIVILEGES tkp;

    //
    // Enable the SE_DEBUG_NAME privilege
    //
    if (!LookupPrivilegeValue
			(
			NULL,
            SE_DEBUG_NAME,
            &DebugValue
			))
		{
        LogUnexpectedFailure(L"LookupPrivilegeValue failed with %d\n", GetLastError());
        return FALSE;
		}

    //
    // Retrieve a handle of the access token
    //
    if (!OpenProcessToken
			(
			GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken
			))
		{
        LogUnexpectedFailure(L"OpenProcessToken failed with %d\n", GetLastError());
        return FALSE;
		}

	tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = DebugValue;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges
		(
		hToken,
        FALSE,
        &tkp,
        sizeof(TOKEN_PRIVILEGES),
        (PTOKEN_PRIVILEGES) NULL,
        (PDWORD) NULL
		);

	DWORD dwErr = GetLastError();

	CloseHandle(hToken);

    //
    // The return value of AdjustTokenPrivileges can't be tested
    //
    if (dwErr != ERROR_SUCCESS)
		{
        LogUnexpectedFailure(L"AdjustTokenPrivileges failed with %d\n", dwErr);
		return FALSE;
		}

    return TRUE;
	}

// stop and possibly restart the service
// if bTerminateIfCantStop is true, then try terminating the process
// if bRestart is true, then try restarting the process if it was
// able to be stopped or terminated.
HRESULT StartStopVssService
	(
	bool bStop,
	bool bTerminateIfCantStop,
	bool bRestart
	)
	{
	SC_HANDLE hSCM = NULL;
	SC_HANDLE hService = NULL;
	HANDLE hProcess = NULL;
	HRESULT hr = S_OK;

	try
		{
		SERVICE_STATUS_PROCESS info;
		DWORD cbNeeded;


		hSCM = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
		if (hSCM == NULL)
			{
			DWORD dwErr = GetLastError();
			LogUnexpectedFailure(L"OpenSCManager failed with error code %d.", dwErr);
			throw(HRESULT_FROM_WIN32(dwErr));
			}

		hService = OpenService(hSCM, x_wszVSS, SERVICE_START|SERVICE_STOP|SERVICE_QUERY_STATUS);
		if (hService == NULL)
			{
			DWORD dwErr = GetLastError();
			LogUnexpectedFailure(L"OpenService failed with error code %d.", dwErr);
			throw(HRESULT_FROM_WIN32(dwErr));
			}

		if (bStop)
			{
			for(UINT i = 0; i < 10; i++)
				{
				if (!QueryServiceStatusEx
						(
						hService,
						SC_STATUS_PROCESS_INFO,
						(LPBYTE) &info,
						sizeof(info),
						&cbNeeded
						))
					{
					DWORD dwErr = GetLastError();
					LogUnexpectedFailure(L"QueryServiceStatusEx failed with error code %d.", dwErr);
					throw(HRESULT_FROM_WIN32(dwErr));
					}
				
				if (info.dwCurrentState == SERVICE_STOPPED)
					break;

				if (info.dwCurrentState != SERVICE_STOP_PENDING)
					{
					SERVICE_STATUS status;
					if (!ControlService
							(
							hService,
							SERVICE_CONTROL_STOP,
							&status
							))
						{
						DWORD dwErr = GetLastError();

						if (dwErr != ERROR_SERVICE_NOT_ACTIVE &&
							dwErr != ERROR_SERVICE_CANNOT_ACCEPT_CTRL)
							{
							LogUnexpectedFailure(L"ServiceControl failed with error %d", dwErr);
							throw(HRESULT_FROM_WIN32(dwErr));
							}
						}
					}
				
				Sleep(6000);
				}

			if (info.dwCurrentState != SERVICE_STOPPED &&
				bTerminateIfCantStop)
				{
				if (info.dwServiceType != SERVICE_WIN32_OWN_PROCESS)
					{
					LogUnexpectedFailure(L"Service %s is not running in its own process", x_wszVSS);
					throw(E_FAIL);
					}

				hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, info.dwProcessId);
				if (hProcess == NULL)
					{
					DWORD dwErr = GetLastError();
					if (dwErr != ERROR_PROCESS_ABORTED)
						{
						LogUnexpectedFailure(L"OpenProcess failed with error %d", dwErr);
						throw(HRESULT_FROM_WIN32(dwErr));
						}
					}
				else
					{
					if (!TerminateProcess(hProcess, 0xffffffff))
						{
						DWORD dwErr = GetLastError();
						if (dwErr != ERROR_PROCESS_ABORTED)
							{
							LogUnexpectedFailure(L"TerminateProcess failed with error %d", dwErr);
							throw(HRESULT_FROM_WIN32(dwErr));
							}
						}
					}
				}
			}

		if (bRestart)
			{
			bool bStopped = true;

			if (!bStop)
				{
				if (!QueryServiceStatusEx
						(
						hService,
						SC_STATUS_PROCESS_INFO,
						(LPBYTE) &info,
						sizeof(info),
						&cbNeeded
						))
					{
					DWORD dwErr = GetLastError();
					LogUnexpectedFailure(L"QueryServiceStatusEx failed with error code %d.", dwErr);
					throw(HRESULT_FROM_WIN32(dwErr));
					}
				
				if (info.dwCurrentState == SERVICE_RUNNING ||
					info.dwCurrentState == SERVICE_START_PENDING)
					bStopped = false;
				}

			if (bStopped)
				{
				if (!StartService(hService, 0, NULL))
					{
					DWORD dwErr = GetLastError();
					LogUnexpectedFailure(L"ServiceStart failed with error %d.", dwErr);
					throw(HRESULT_FROM_WIN32(dwErr));
					}
				}

			for(UINT i = 0; i < 10; i++)
				{
				if (!QueryServiceStatusEx
						(
						hService,
						SC_STATUS_PROCESS_INFO,
						(LPBYTE) &info,
						sizeof(info),
						&cbNeeded
						))
					{
					DWORD dwErr = GetLastError();
					LogUnexpectedFailure(L"QueryServiceStatusEx failed with error code %d.", dwErr);
					throw(HRESULT_FROM_WIN32(dwErr));
					}

				if (info.dwCurrentState == SERVICE_RUNNING)
					break;
				else if (info.dwCurrentState != SERVICE_START_PENDING)
					{
					LogUnexpectedFailure(L"Cannot start service %s.", x_wszVSS);
					throw(E_FAIL);
					}

				Sleep(6000);
				}
			}
		}
	catch(HRESULT hrFailure)
		{
		hr = hrFailure;
		}
	catch(...)
		{
		hr = E_UNEXPECTED;
		}

	if (hProcess)
		CloseHandle(hProcess);

	if (hService)
		CloseServiceHandle(hService);

	if (hSCM)
		CloseServiceHandle(hSCM);

	return hr;
	}
	

void StartupProcess
	(
	CVsTstProcessList &processList,
	LPCWSTR wszSectionName,
	UINT maxTestTime,
	LPCWSTR wszScenarioFile
	)
	{
    ULONGLONG processId;
	LPCWSTR wszQualifier;
	EVsTstINISectionType sectionType;
	VSTST_PROCESS_TYPE processType;

	if (memcmp(wszSectionName, x_wszVssTestWriter, wcslen(x_wszVssTestWriter) * sizeof(WCHAR)) == 0)
		{
		sectionType = eVsTstSectionType_TestWriter;
		processType = VSTST_PT_WRITER;
		wszQualifier = wszSectionName + wcslen(x_wszVssTestWriter);
		}
	else if (memcmp(wszSectionName, x_wszVssTestRequestor, wcslen(x_wszVssTestRequestor)) == 0)
		{
		sectionType = eVsTstSectionType_TestRequesterApp;
		wszQualifier = wszSectionName + wcslen(x_wszVssTestRequestor);
		processType =  VSTST_PT_BACKUP;
		}


	CVsTstINIConfig config
		(
		sectionType,
		wszQualifier,
		false,
		wszScenarioFile
		);

	CBsString bssExeName;
	config.GetOptionValue(x_wszProcessExecutable, &bssExeName);

	EVsTstINIBoolType boolVal;
	config.GetOptionValue(x_wszConformingExecutable, &boolVal);

	CBsString bssCmdLine;
	config.GetOptionValue(x_wszProcessCommandLine, &bssCmdLine);

	bool bConforming = boolVal == eVsTstBool_True;

	if (bConforming)
		{
		processType = (processType == VSTST_PT_WRITER)
					? VSTST_PT_TESTWRITER : VSTST_PT_TESTBACKUP;

        g_pcTstNtLog->Log( eSevLev_Info, L"Controller: Conforming exe: '%s', cmdline: '%s'",
            bssExeName.c_str(), bssCmdLine.c_str() );

		processList.CreateConformingExe
			(
			processType,
			VSTST_AT_ADMIN,
			bssExeName,
			wszScenarioFile,
			wszSectionName,
			(UINT) -1,
			maxTestTime,
			false,
			NULL,
			processId
			);

        if(processType == VSTST_PT_WRITER || processType ==  VSTST_PT_TESTWRITER)
			Sleep(10000);
		}
	else
		processList.CreateNonConformingExe
			(
			processType,
			VSTST_AT_ADMIN,
			bssCmdLine,
			maxTestTime,
			NULL,
			processId
			);
    }

void DeleteExistingSnapshots()
	{
	CComPtr<IVssCoordinator> pCoord;
	HRESULT hrResult = S_OK;

	HRESULT hr = CoCreateInstance
					(
					CLSID_VSSCoordinator,
					NULL,
					CLSCTX_LOCAL_SERVER,
					IID_IVssCoordinator,
					(void **) &pCoord
					);

    if (FAILED(hr))
		{
		LogUnexpectedFailure(L"CoCreating the coordinator failed.  hr = 0x%08lx", hr);
		throw(hr);
		}

	WCHAR bufVolume[MAX_PATH];

	HANDLE hVolumes = FindFirstVolume(bufVolume, sizeof(bufVolume));
	
	if (hVolumes == INVALID_HANDLE_VALUE)
		{
		DWORD dwErr = GetLastError();
		LogUnexpectedFailure(L"FindFirstVolume failed with error %d", dwErr);
		throw(HRESULT_FROM_WIN32(dwErr));
		}

	try
		{
		do
			{
			WCHAR wszVolume[MAX_PATH];
			if (!GetVolumeNameForVolumeMountPoint
					(
					bufVolume,
					wszVolume,
					sizeof(wszVolume)/sizeof(WCHAR)
					))
				{
				DWORD dwErr = GetLastError();
				LogUnexpectedFailure(L"GetVolumeNameFromVolumeMountPoint failed with error %d", dwErr);
				throw(HRESULT_FROM_WIN32(dwErr));
				}

			if (wszVolume[wcslen(wszVolume) - 1] == L'\\')
				wszVolume[wcslen(wszVolume) - 1] = L'\0';

			VSTST_ASSERT(memcmp(wszVolume, L"\\\\?\\Volume{", 22) == 0);
			LPCWSTR wsz = wszVolume + 10;
			VSTST_ASSERT(wsz[wcslen(wsz) - 1] == L'}');
			CVssID id;
			id.Initialize(wsz, E_OUTOFMEMORY);

			LONG lDeletedSnapshots;
			VSS_ID SnapshotIDNotDeleted;
			hr = pCoord->DeleteSnapshots
					(
					id,
					VSS_OBJECT_VOLUME,
					false,
					&lDeletedSnapshots,
					&SnapshotIDNotDeleted
					);

			} while(FindNextVolume(hVolumes, bufVolume, sizeof(bufVolume)));

        DWORD dwErr = GetLastError();
		if (dwErr != ERROR_NO_MORE_FILES)
			{
			LogUnexpectedFailure(L"FindNextVolume failed with error %d", GetLastError());
			throw(HRESULT_FROM_WIN32(dwErr));
			}
		}
	catch(HRESULT hr)
		{
		hrResult = hr;
		}
	catch(...)
		{
		LogUnexpectedFailure(L"DeleteExistingSnapshots got unexpected exception");
		hrResult = E_UNEXPECTED;
		}

	FindVolumeClose(hVolumes);
	if (FAILED(hrResult))
		throw(hrResult);
	}


void RunScenario(LPCWSTR wszScenarioFile, LPCWSTR wszSectionName)
	{
	try
		{
		CVsTstINIConfig config
			(
			eVsTstSectionType_TestCoordinator,
			wszSectionName,
			FALSE,
			wszScenarioFile
			);

        EVsTstINIBoolType boolVal;
		config.GetOptionValue(x_wszDeleteExistingSnapshots, &boolVal);
		if (boolVal == eVsTstBool_True)
			DeleteExistingSnapshots();

        LONGLONG llTestTime, llMaxTestTime;
		CBsString bssProcesses;
		CBsString bssCoordinatorStart;

		config.GetOptionValue(x_wszMaxTestTime, &llTestTime, &llMaxTestTime);

		// stop, start, or restart coordinator service based on
		// configuration
		config.GetOptionValue(x_wszCoordinatorStart, &bssCoordinatorStart);
		if (wcscmp(bssCoordinatorStart, x_wszStop) == 0)
			StartStopVssService(true, true, false);
		else if (wcscmp(bssCoordinatorStart, x_wszStart) == 0)
			StartStopVssService(false, false, true);
		else if (wcscmp(bssCoordinatorStart, x_wszRestart) == 0)
			StartStopVssService(true, true, true);


		config.GetOptionValue(x_wszProcessesToStart, &bssProcesses);

		bssProcesses.CopyBeforeWrite();

		CVsTstProcessList processList;
				

		HANDLE hevtDone = CreateEvent(NULL, TRUE, FALSE, NULL);
		if (hevtDone == NULL)
			{
			LogUnexpectedFailure(L"Cannot create termination event for reason %d", GetLastError());
			exit(-1);
			}


		processList.Initialize((UINT) llTestTime, hevtDone);

		LPCWSTR wsz = bssProcesses;
		LPCWSTR wszTop = wsz;
		if (wsz == NULL || *wsz == L'\0')
			{
			LogUnexpectedFailure(L"no processes to start");
			exit(-1);
			}

		bool fMoreToRun = true;
		while(fMoreToRun)
			{
			while(*wsz == L' ')
				wsz++;

			LPCWSTR pwc = wsz;
			while(*pwc != L'\0' && *pwc != L',')
				pwc++;

			if (*pwc == L'\0')
				fMoreToRun = false;
			else
				bssProcesses.SetAt((UINT) (pwc - wszTop), L'\0');

			g_pcTstNtLog->Log( eSevLev_Info, L"Controller: Starting process '%s'", wsz );

			StartupProcess
				(
				processList,
				wsz,
				(UINT) llTestTime,
				wszScenarioFile
				);

			wsz = pwc + 1;
			}

		WaitForSingleObject(hevtDone, INFINITE);
		}
	catch(...)
		{
		LogUnexpectedFailure(L"Failure running scenario %s.%s.", wszScenarioFile, wszSectionName);
		}
	}

class CSeriesReader
	{
public:
	CSeriesReader(HANDLE hFile, LPCWSTR wszFile) :
		m_hFile(hFile),
		m_pch((char *) m_buf),
		m_pchEnd((char *) m_buf),
		m_fMoreToRead(true),
		m_wszFile(wszFile)
		{
		}

	~CSeriesReader()
		{
		CloseHandle(m_hFile);
		}

	bool FillBuffer();

	bool TrimSpaces(bool fStopAtEol);

	bool ReadToComma(LPSTR *pszRead);
private:

	// buffer
	BYTE m_buf[1024];

	// current position
	char *m_pch;

	// end of buffer
	char *m_pchEnd;

	// where to preserve from when filling buffer
	char *m_pchPreserve;

	// is there more to read
	bool m_fMoreToRead;

	// handle to file
	HANDLE m_hFile;

	// file name
	LPCWSTR m_wszFile;
	};

bool CSeriesReader::FillBuffer()
	{
	if (!m_fMoreToRead)
		return false;

	DWORD cbPreserved = m_pch - m_pchPreserve;
	DWORD cbRead;
	memmove(m_buf, m_pchPreserve, cbPreserved);
	if (!ReadFile
			(
			m_hFile,
			m_buf + cbPreserved,
			// allow trailing null to be placed in buffer
			sizeof(m_buf) - cbPreserved - 1,
			&cbRead,
			NULL
			))
       LogUnexpectedFailure(L"Failure to read %s due to error %d", m_wszFile, GetLastError());

   m_pch = (char *) m_buf + cbPreserved;
   m_pchEnd = (char *) m_buf + cbPreserved + cbRead;
   if (cbRead == 0)
	   {
	   DWORD dwErr = GetLastError();
	   if (dwErr == ERROR_HANDLE_EOF)
		   m_fMoreToRead = false;
	   else
		   LogUnexpectedFailure(L"Read failure %d.", dwErr);

	   return false;
	   }
   else if (cbRead + cbPreserved < sizeof(m_buf) - 1)
	   m_fMoreToRead = false;

   return true;
   }

bool CSeriesReader::TrimSpaces(bool fStopAtEol)
	{
	while(TRUE)
		{
		if (m_pch >= m_pchEnd)
			{
			m_pchPreserve = m_pch;
			if (!FillBuffer())
				return false;
			}

		if (*m_pch == ' ' ||
			*m_pch == '\t')
			m_pch++;

		else if (*m_pch == '\r' ||
			*m_pch == '\n')
			{
			if (fStopAtEol)
				return false;
			else
				m_pch++;
			}
		else
			break;
		}

	return true;
	}


bool CSeriesReader::ReadToComma(LPSTR *psz)
	{
	if (!TrimSpaces(true))
		return(false);
	m_pchPreserve = m_pch;
	while (TRUE)
		{
		if (m_pch >= m_pchEnd)
			{
			if (!FillBuffer())
				{
				if (m_pch - m_pchPreserve > 0)
					break;
				else
					return false;
				}
			}
		else if (*m_pch == ',' || *m_pch == '\r' || *m_pch == '\n')
			break;

		m_pch++;
		}

	*m_pch++ = '\0';
	*psz = m_pchPreserve;
	return true;
	}
		

void ProcessTestSeriesFile(LPCWSTR wszFile)
	{
	HANDLE hFile;

	hFile = CreateFile
				(
				wszFile,
				GENERIC_READ,
				FILE_SHARE_READ,
				NULL,
				OPEN_EXISTING,
				0,
				NULL
				);

    if (hFile == INVALID_HANDLE_VALUE)
		{
		LogUnexpectedFailure(L"Cannot open file %s due to error %d", wszFile, GetLastError());
		return;
		}

   CSeriesReader reader(hFile, wszFile);

   while(TRUE)
	   {
	   if(!reader.TrimSpaces(false))
		   // no more data in file
		   break;

	   LPSTR szScenarioFile;

	   if (!reader.ReadToComma(&szScenarioFile))
		   break;

	   WCHAR wszScenarioFile[1024];
	   mbstowcs(wszScenarioFile, szScenarioFile, sizeof(wszScenarioFile)/sizeof(WCHAR));

	   bool fSectionFound = false;
	   while(TRUE)
		   {
		   LPSTR szSection;

		   if (!reader.ReadToComma(&szSection))
			   break;

		   WCHAR wszSection[257];
		   mbstowcs(wszSection, szSection, sizeof(wszSection)/sizeof(WCHAR));
		   RunScenario(wszScenarioFile, wszSection);
		   fSectionFound = true;
		   }

	   if (!fSectionFound)
		   RunScenario(wszScenarioFile, L"Default");
	   }
   }

extern "C" __cdecl wmain(int argc, WCHAR **argv)
	{
	bool bCoInitializeSucceeded = false;
	try
		{
		HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if (FAILED(hr))
			{
			LogUnexpectedFailure(L"CoInitialize Failed hr = 0x%08lx", hr);
			throw hr;
			}

		CVsTstParams params;
		params.ParseCommandLine(argv, argc);

		if (!EnableDebugPriv())
			exit(-1);

		CVsTstMsgHandler handler;

		g_pcTstNtLog = handler.GetTstNtLogP();
		handler.Initialize(1024);
		handler.LaunchReader();
		handler.StartProcessingMessages();
				


		LPCWSTR wszScenarioFile;
		LPCWSTR wszSectionName;
		LPCWSTR wszTestSeriesFile;

		if (params.GetTestSeries(&wszTestSeriesFile))
			ProcessTestSeriesFile(wszTestSeriesFile);
		else if (params.GetScenarioFileName(&wszScenarioFile) &&
				 params.GetSectionName(&wszSectionName))
			RunScenario(wszScenarioFile, wszSectionName);
		else
			LogUnexpectedFailure(L"Bad Input parameters");
		
		handler.StopProcessingMessages();
		g_pcTstNtLog = NULL;
		}
	catch( HRESULT hr )
    	{
        LogUnexpectedFailure( L"Caught HRESULT: 0x%08x", hr );
	    }
	catch(...)
		{
        LogUnexpectedFailure( L"Caught an unexpected exception" );
		}

	if (bCoInitializeSucceeded)
		CoUninitialize();

	return 0;
	}

void CVsTstMsgHandlerRoutines::PrintMessage(VSTST_MSG_HDR *phdr, VOID *pPrivateData)
	{
	VSTST_ASSERT(phdr->type == VSTST_MT_TEXT || phdr->type == VSTST_MT_IMMEDIATETEXT);
	CVsTstNtLog *pcTestLog = (CVsTstNtLog *)pPrivateData;
	VSTST_TEXTMSG *pmsg = (VSTST_TEXTMSG *) phdr->rgb;
	
	printf("%d: %s\n", (UINT) phdr->sequence, pmsg->pch);

	pcTestLog->Log( eSevLev_Info, L"(%I64u) %S", phdr->processId, pmsg->pch );
	}

void CVsTstMsgHandlerRoutines::HandleUnexpectedException(VSTST_MSG_HDR *phdr, VOID *pPrivateData)
	{
	VSTST_ASSERT(phdr->type == VSTST_MT_UNEXPECTEDEXCEPTION);
	CVsTstNtLog *pcTestLog = (CVsTstNtLog *)pPrivateData;
	VSTST_UNEXPECTEDEXCEPTIONMSG *pmsg = (VSTST_UNEXPECTEDEXCEPTIONMSG *) phdr->rgb;
	
	printf("!!!Unexpected Exception caught in routine %s\n", pmsg->szFailedRoutine);
  	pcTestLog->Log( eSevLev_Severe,
  	    L"(%I64u) !!!Unexpected Exception caught in routine %S", phdr->processId, pmsg->szFailedRoutine );
	}

void CVsTstMsgHandlerRoutines::HandleFailure(VSTST_MSG_HDR *phdr, VOID *pPrivateData)
	{
	VSTST_ASSERT(phdr->type == VSTST_MT_FAILURE);
	CVsTstNtLog *pcTestLog = (CVsTstNtLog *)pPrivateData;
	VSTST_FAILUREMSG *pmsg = (VSTST_FAILUREMSG *) phdr->rgb;
	printf("!!!FAILURE: %s\n", pmsg->szFailure);
  	pcTestLog->Log( eSevLev_Severe,
    	L"(%I64u) !!!FAILURE: %S", phdr->processId, pmsg->szFailure);
	}

void CVsTstMsgHandlerRoutines::HandleSuccess(VSTST_MSG_HDR *phdr, VOID *pPrivateData)
	{
	VSTST_ASSERT(phdr->type == VSTST_MT_SUCCESS);
	CVsTstNtLog *pcTestLog = (CVsTstNtLog *)pPrivateData;
	VSTST_SUCCESSMSG *pmsg = (VSTST_SUCCESSMSG *) phdr->rgb;
	printf("SUCCESS: %s\n", phdr->processId, pmsg->szMsg);
  	pcTestLog->Log( eSevLev_Pass,
    	L"(%I64u) Success: %S", pmsg->szMsg);
	}

void CVsTstMsgHandlerRoutines::HandleOperationFailure(VSTST_MSG_HDR *phdr, VOID *pPrivateData)
	{
	VSTST_ASSERT(phdr->type == VSTST_MT_OPERATIONFAILURE);
	CVsTstNtLog *pcTestLog = (CVsTstNtLog *)pPrivateData;
	VSTST_OPERATIONFAILUREMSG *pmsg = (VSTST_OPERATIONFAILUREMSG *) phdr->rgb;
	printf("!!!Operation %s failed. hr = 0x%08lx\n", pmsg->szFailedOperation, pmsg->hr);
  	pcTestLog->Log( eSevLev_Severe,
    	L"(%I64u) !!!Operation %S failed. hr = 0x%08lx\n", phdr->processId, pmsg->szFailedOperation, pmsg->hr);
	}

void LogInvalidMessage(VSTST_MSG_HDR *phdr)
	{
	UNREFERENCED_PARAMETER(phdr);

	VSTST_ASSERT(FALSE);

    printf( "Controller: !!! Invalid harness message\n" );

  	if ( g_pcTstNtLog != NULL )
      	g_pcTstNtLog->Log( eSevLev_Severe, L"Controller: !!! Invalid harness message" );
	}

void ReadPipeError(DWORD dwErr)
	{
	UNREFERENCED_PARAMETER(dwErr);

	VSTST_ASSERT(FALSE);

  	printf( "Controller: !!! Pipe read error\n" );

  	if ( g_pcTstNtLog != NULL )
      	g_pcTstNtLog->Log( eSevLev_Severe, L"Controller: !!! Pipe read error" );
	}

void LogUnexpectedFailure(LPCWSTR wsz, ...)
	{
	va_list args;
	va_start(args, wsz);

    VSTST_ASSERT( "In LogUnexpectedFailure" && FALSE);
	CBsString cwsErrorMessage;

	cwsErrorMessage.FormatV( wsz, args );

  	wprintf( L"Controller: %s\n", cwsErrorMessage.c_str() );

  	if ( g_pcTstNtLog != NULL )
      	g_pcTstNtLog->Log( eSevLev_Severe, L"Controller: %s", cwsErrorMessage.c_str() );

	va_end( args );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\inc\ntlog.h ===
/*---------------------------------------------------------------------------*\
| NTLOG OBJECT
|   This module defines the NTLOG object.  This header must be include in all
|   modules which make NTLOG calls, or utilizes the definitions.
|
|
| Copyright (C) 1990-1994 Microsoft Corp.
|
| created: 01-Oct-90
| history: 01-Oct-90 <chriswil> created.
|          05-Feb-91 <chriswil> added NOPROLOG style.
|          23-Feb-91 <chriswil> expanded log-flags to DWORD.
|          28-May-91 <chriswil> added per-thread variation tracking.
|          19-Mar-92 <chriswil> redefined struct for shared memory.
|          10-Oct-92 <martys>   added thread macros
|          05-Oct-93 <chriswil> unicode enabled.
|          10-Oct-96 (darrenf)  fixed _FILE_ for unicode, added _NTLOG_LOGPATH handling
|
\*---------------------------------------------------------------------------*/

#ifndef _NTLOG_
#define _NTLOG_

// If doing C++ stuff, this needs to be here to
// prevent decorating of symbols.
//
#ifdef __cplusplus
extern "C" {
#endif

// **NEW** 10/26/96 Log path environment variable **NEW**
// if the environment variable _NTLOG_LOGPATH is set to a non-empty string
// the value of this variable will be prepended to the log name
// The path should NOT include a trailing backslash.

// No validation is performed on the path, however, if the value is invalid,
// the call to tlCreateLog will fail because CreateFile will fail.

// Basically should be used to force logfiles to a location other than the current directory
// without changing the source file.

// **NEW** 1/20/97 environment variable to force diffable files **NEW**
// if the environment variable _NTLOG_DIFFABLE is set, then log files
// will not contain process and thread specific data, and time and date data.
//


// NTLOG STYLES
//  The folowing are logging levels in which the Log Object can prejudice
//  itself.  These are used by the tlLogCreate() in initializing the
//  Log Object information.  A combination of characteristics is obtained
//  by bitwise OR'ing these identifiers together.
//
#define LOG_LEVELS    0x0000FFFFL    // These are used to mask out the
#define LOG_STYLES    0xFFFF0000L    // styles or levels from log object.

#define TLS_LOGALL    0x0000FFFFL    // Log output.  Logs all the time.
#define TLS_LOG       0x00000000L    // Log output.  Logs all the time.
#define TLS_INFO      0x00002000L    // Log information.
#define TLS_ABORT     0x00000001L    // Log Abort, then kill process.
#define TLS_SEV1      0x00000002L    // Log at Severity 1 level
#define TLS_SEV2      0x00000004L    // Log at Severity 2 level
#define TLS_SEV3      0x00000008L    // Log at Severity 3 level
#define TLS_WARN      0x00000010L    // Log at Warn level
#define TLS_PASS      0x00000020L    // Log at Pass level
#define TLS_BLOCK     0x00000400L    // Block the variation.
#define TLS_BREAK     0x00000800L    // Debugger break;
#define TLS_CALLTREE  0x00000040L    // Log call-tree (function tracking).
#define TLS_SYSTEM    0x00000080L    // Log System debug.
#define TLS_TESTDEBUG 0x00001000L    // Debug level.
#define TLS_TEST      0x00000100L    // Log Test information (user).
#define TLS_VARIATION 0x00000200L    // Log testcase level.

#define TLS_REFRESH   0x00010000L    // Create new file || trunc to zero.
#define TLS_SORT      0x00020000L    // Sort file output by instance.
#define TLS_DEBUG     0x00040000L    // Output to debug (com) monitor).
#define TLS_MONITOR   0x00080000L    // Output to 2nd screen.
#define TLS_VIDCOLOR  0x00100000L    // Use different colors for display output
#define TLS_PROLOG    0x00200000L    // Prolog line information.
#define TLS_WINDOW    0x00400000L    // Log to windows.
#define TLS_ACCESSON  0x00800000L    // Keep log-file open.
#define TLS_DIFFABLE  0x01000000L    // make log file windiff'able (no dates..)
#define TLS_NOHEADER  0x02000000L    // suppress headers so it is more diffable
#define TLS_TIMESTAMP 0x04000000L    // To print the timestamps
#define TLS_VIDEOLOG  0x08000000L    // convert ?.log to ?.bpp.log (color depth)
#define TLS_HTML      0x10000000L    // write log file as an html.


// NTLOG tlLogOut() PARAMETERS
//   The following defines are used in the tlLogOut() function to output the
//   filename and line numbers associated with the caller.  This uses the
//   preprocessors capabilities for obtaining the file/line.
//
#define TL_LOG       TLS_LOG      ,TEXT(__FILE__),(int)__LINE__
#define TL_ABORT     TLS_ABORT    ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV1      TLS_SEV1     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV2      TLS_SEV2     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV3      TLS_SEV3     ,TEXT(__FILE__),(int)__LINE__
#define TL_WARN      TLS_WARN     ,TEXT(__FILE__),(int)__LINE__
#define TL_PASS      TLS_PASS     ,TEXT(__FILE__),(int)__LINE__
#define TL_BLOCK     TLS_BLOCK    ,TEXT(__FILE__),(int)__LINE__
#define TL_INFO      TLS_INFO     ,TEXT(__FILE__),(int)__LINE__
#define TL_BREAK     TLS_BREAK    ,TEXT(__FILE__),(int)__LINE__
#define TL_CALLTREE  TLS_CALLTREE ,TEXT(__FILE__),(int)__LINE__
#define TL_SYSTEM    TLS_SYSTEM   ,TEXT(__FILE__),(int)__LINE__
#define TL_TESTDEBUG TLS_TESTDEBUG,TEXT(__FILE__),(int)__LINE__
#define TL_TEST      TLS_TEST     ,TEXT(__FILE__),(int)__LINE__
#define TL_VARIATION TLS_VARIATION,TEXT(__FILE__),(int)__LINE__


//  Struct used by tlGet/SetVar/TestStats
//
typedef struct _NTLOGSTATS {
    int nAbort;
    int nBlock;
    int nSev1;
    int nSev2;
    int nSev3;
    int nWarn;
    int nPass;
}
NTLOGSTATS, *LPNTLOGSTATS;


//  Use enumerated indexes to access palette.
//  Colors are defined in wincon.h

typedef struct _VIDEOPALETTE {
    WORD  wINDEX_DEFAULT;
    WORD  wINDEX_INFO;
    WORD  wINDEX_SEV1;
    WORD  wINDEX_SEV2;
    WORD  wINDEX_SEV3;
    WORD  wINDEX_BLOCK;
    WORD  wINDEX_ABORT;
    WORD  wINDEX_WARN;
    WORD  wINDEX_PASS;
}
VIDEOPALETTE, *LPVIDEOPALETTE;


// NTLOG API (EXPORT METHODS)
//   These routines are exported from the library.  These should be the only
//   interface with the NTLOG object.
//
HANDLE APIENTRY  tlCreateLog_W(LPCWSTR,DWORD);
HANDLE APIENTRY  tlCreateLog_A(LPCSTR,DWORD);
HANDLE APIENTRY  tlCreateLogEx_W(LPCWSTR,DWORD,LPSECURITY_ATTRIBUTES);
HANDLE APIENTRY  tlCreateLogEx_A(LPCSTR,DWORD,LPSECURITY_ATTRIBUTES);
BOOL   APIENTRY  tlDestroyLog(HANDLE);
BOOL   APIENTRY  tlAddParticipant(HANDLE,DWORD,int);
BOOL   APIENTRY  tlRemoveParticipant(HANDLE);
DWORD  APIENTRY  tlParseCmdLine_W(LPCWSTR);
DWORD  APIENTRY  tlParseCmdLine_A(LPCSTR);
int    APIENTRY  tlGetLogFileName_W(HANDLE,LPWSTR);
int    APIENTRY  tlGetLogFileName_A(HANDLE,LPSTR);
BOOL   APIENTRY  tlSetLogFileName_W(HANDLE,LPCWSTR);
BOOL   APIENTRY  tlSetLogFileName_A(HANDLE,LPCSTR);
DWORD  APIENTRY  tlGetLogInfo(HANDLE);
DWORD  APIENTRY  tlSetLogInfo(HANDLE,DWORD);
HANDLE APIENTRY  tlPromptLog(HWND,HANDLE);
int    APIENTRY  tlGetTestStat(HANDLE,DWORD);
int    APIENTRY  tlGetVariationStat(HANDLE,DWORD);
VOID   APIENTRY  tlClearTestStats(HANDLE);
VOID   APIENTRY  tlClearVariationStats(HANDLE);
VOID   APIENTRY  tlSetTestStats(HANDLE,LPNTLOGSTATS);
VOID   APIENTRY  tlSetVariationStats(HANDLE,LPNTLOGSTATS);
BOOL   APIENTRY  tlStartVariation(HANDLE);
DWORD  APIENTRY  tlEndVariation(HANDLE);
VOID   APIENTRY  tlReportStats(HANDLE);
BOOL   APIENTRY  tlLogX_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR);
BOOL   APIENTRY  tlLogX_A(HANDLE,DWORD,LPCSTR,int,LPCSTR);
BOOL   FAR __cdecl tlLog_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR,...);
BOOL   FAR __cdecl tlLog_A(HANDLE,DWORD,LPCSTR,int,LPCSTR,...);
BOOL   APIENTRY  tlGetVideoPalette(HANDLE,LPVIDEOPALETTE);
BOOL   APIENTRY  tlSetVideoPalette(HANDLE,LPVIDEOPALETTE);
BOOL   APIENTRY  tlResetVideoPalette(HANDLE);
VOID   APIENTRY  tlAdjustFileName_W(HANDLE,LPWSTR,UINT);
VOID   APIENTRY  tlAdjustFileName_A(HANDLE,LPSTR,UINT);
BOOL   APIENTRY  tlIsTerminalServerSession();

#ifdef UNICODE
#define tlCreateLog         tlCreateLog_W
#define tlCreateLogEx       tlCreateLogEx_W
#define tlParseCmdLine      tlParseCmdLine_W
#define tlGetLogFileName    tlGetLogFileName_W
#define tlSetLogFileName    tlSetLogFileName_W
#define tlLogX              tlLogX_W
#define tlLog               tlLog_W
#define tlAdjustFileName    tlAdjustFileName_W
#else
#define tlCreateLog         tlCreateLog_A
#define tlCreateLogEx       tlCreateLogEx_A
#define tlParseCmdLine      tlParseCmdLine_A
#define tlGetLogFileName    tlGetLogFileName_A
#define tlSetLogFileName    tlSetLogFileName_A
#define tlLogX              tlLogX_A
#define tlLog               tlLog_A
#define tlAdjustFileName    tlAdjustFileName_A
#endif



// RATS MACROS
//   These macros are provided as a common logging interface which is
//   compatible with the RATS logging-macros.
//
#define TESTDATA                 HANDLE        hLog;
#define TESTOTHERDATA            extern HANDLE hLog;


//  These must be useless.  TL_* macros do not include TLS_TEST or
//  TLS_VARIATION, so they DO NOT count in the stats.  Leaving them around
//  for 'backwards compatibility, if anyone was actually using them...
//
#define L_PASS                   hLog,TL_PASS
#define L_WARN                   hLog,TL_WARN
#define L_DEBUG                  hLog,TL_TESTDEBUG
#define L_TRACE                  hLog,TL_SYSTEM
#define L_FAIL                   hLog,TL_SEV1
#define L_FAIL2                  hLog,TL_SEV2
#define L_FAIL3                  hLog,TL_SEV3
#define L_BLOCK                  hLog,TL_BLOCK


//  macros for incrementing test/variation counts for various log levels
//
#define L_TESTPASS                   hLog,TLS_TEST | TL_PASS
#define L_TESTWARN                   hLog,TLS_TEST | TL_WARN
#define L_TESTDEBUG                  hLog,TLS_TEST | TL_TESTDEBUG
#define L_TESTTRACE                  hLog,TLS_TEST | TL_SYSTEM
#define L_TESTFAIL                   hLog,TLS_TEST | TL_SEV1
#define L_TESTFAIL2                  hLog,TLS_TEST | TL_SEV2
#define L_TESTFAIL3                  hLog,TLS_TEST | TL_SEV3
#define L_TESTBLOCK                  hLog,TLS_TEST | TL_BLOCK
#define L_TESTABORT                  hLog,TLS_TEST | TL_ABORT

#define L_VARPASS                   hLog,TLS_VARIATION | TL_PASS
#define L_VARWARN                   hLog,TLS_VARIATION | TL_WARN
#define L_VARDEBUG                  hLog,TLS_VARIATION | TL_TESTDEBUG
#define L_VARTRACE                  hLog,TLS_VARIATION | TL_SYSTEM
#define L_VARFAIL                   hLog,TLS_VARIATION | TL_SEV1
#define L_VARFAIL2                  hLog,TLS_VARIATION | TL_SEV2
#define L_VARFAIL3                  hLog,TLS_VARIATION | TL_SEV3
#define L_VARBLOCK                  hLog,TLS_VARIATION | TL_BLOCK
#define L_VARABORT                  hLog,TLS_VARIATION | TL_ABORT


#define TESTBEGIN(cmd,logfilename){                                                       \
                                      DWORD __tlFlags;                                    \
                                      __tlFlags = tlParseCmdLine(cmd);                    \
                                      hLog      = tlCreateLog(logfilename,__tlFlags);     \
                                      tlAddParticipant(hLog,0l,0);

#define TESTEND                       tlRemoveParticipant(hLog);                          \
                                      tlDestroyLog(hLog);                                 \
                                  }

#define VARIATION(name,flags)    if(tlStartVariation(hLog))                                                  \
                                 {                                                                           \
                                     DWORD __dwResult;                                                       \
                                     tlLog(hLog,TL_VARIATION,TEXT("%s"),(LPTSTR)name);

#define ENDVARIATION                 __dwResult = tlEndVariation(hLog);                                      \
                                     tlLog(hLog,__dwResult | TL_VARIATION,TEXT("End Variation reported"));   \
                                 }


#define ENTERTHREAD(_hLG,_szNM)  {                                                                           \
                                    LPTSTR _lpFN = _szNM;                                                    \
                                    tlAddParticipant(_hLG,0,0);                                              \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVETHREAD(_hLG,_ret)                                                                               \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);             \
                                    tlRemoveParticipant(_hLG);                                               \
                                    return(_ret);                                                            \
                                 }

#define LEAVETHREADVOID(_hLG)                                                                                \
                                     tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);            \
                                     tlRemoveParticipant(_hLG);                                              \
                                     return;                                                                 \
                                 }


// Macro to report variation PASS/FAIL statistic (based on an expression)
//
#define THPRINTF                tlLog
#define TESTRESULT(expr,msg)    (expr) ? tlLog(L_TESTPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg)
#define TESTFAIL(msg)           TESTSEV2(msg)
#define TESTSEV1(msg)           tlLog(L_TESTFAIL ,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV2(msg)           tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV3(msg)           tlLog(L_TESTFAIL3,TEXT("%s"),(LPTSTR)msg);
#define TESTPASS(msg)           tlLog(L_TESTPASS ,TEXT("%s"),(LPTSTR)msg);
#define TESTABORT(msg)          tlLog(L_TESTABORT,TEXT("%s"),(LPTSTR)msg);
#define TESTWARN(expr,msg)      if(expr) tlLog(L_TESTWARN,TEXT("%s"),(LPTSTR)msg);
#define TESTBLOCK(expr,msg)     if(expr) tlLog(L_TESTBLOCK,TEXT("%s"),(LPTSTR)msg);

#define VARRESULT(expr,msg)    (expr) ? tlLog(L_VARPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg)
#define VARFAIL(msg)           VARSEV2(msg)
#define VARSEV1(msg)           tlLog(L_VARFAIL ,TEXT("%s"),(LPTSTR)msg);
#define VARSEV2(msg)           tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg);
#define VARSEV3(msg)           tlLog(L_VARFAIL3,TEXT("%s"),(LPTSTR)msg);
#define VARPASS(msg)           tlLog(L_VARPASS ,TEXT("%s"),(LPTSTR)msg);
#define VARABORT(msg)          tlLog(L_VARABORT,TEXT("%s"),(LPTSTR)msg);
#define VARWARN(expr,msg)      if(expr) tlLog(L_VARWARN,TEXT("%s"),(LPTSTR)msg);
#define VARBLOCK(expr,msg)     if(expr) tlLog(L_VARBLOCK,TEXT("%s"),(LPTSTR)msg);


#define VAR_SI          0x01                                 // Ship Issue
#define VAR_NSI         0x02                                 // Non-ship Issue
#define VAR_LI          0x03                                 // Less Important
#define VAR_ISSUE_MASK  0x03                                 // To get ship-issue bits only
#define VAR_TIMEABLE    0x04                                 // Var. used in timing suites
#define CORE_API        0x08                                 // API is in most used list
#define CORE_SI         (CORE_API | VAR_TIMEABLE | VAR_SI )  //
#define CORE_NSI        (CORE_API | VAR_TIMEABLE | VAR_NSI)  //
#define NONCORE_SI      (VAR_TIMEABLE | VAR_SI )             //
#define NONCORE_NSI     (VAR_TIMEABLE | VAR_NSI)             //



// CALLTREE Macros
//   These macros are useful for bracketing function-calls.
//
#define ENTER(_hLG,_szNM) {                                                                 \
                              LPTSTR _lpFN = _szNM;                                         \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVE(_hLG,_ret)                                                                    \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return(_ret);                                                 \
                          }

#define LEAVEVOID(_hLG)                                                                     \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return;                                                       \
                          }

#ifdef __cplusplus
}
#endif

#define LPSZ_KEY_EMPTY    TEXT("None")
#define LPSZ_TERM_SERVER  TEXT("Terminal Server")

#endif  // _NTLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\writer\writer.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    writer.cpp

Abstract:

    main module of test writer


    Brian Berkowitz  [brianb]  06/02/2000

TBD:
	

Revision History:

    Name        Date        Comments
    brianb      06/02/2000  Created

--*/

#include <stdafx.h>
#include <vststmsgclient.hxx>
#include <tstiniconfig.hxx>
#include <vststprocess.hxx>

#include <vss.h>
#include <vswriter.h>

#include <writer.h>

void LogUnexpectedFailure(LPCWSTR wsz, ...);

#define IID_PPV_ARG( Type, Expr ) IID_##Type, reinterpret_cast< void** >( static_cast< Type** >( Expr ) )
#define SafeQI( Type, Expr ) QueryInterface( IID_PPV_ARG( Type, Expr ) )

static BYTE x_rgbIcon[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
static unsigned x_cbIcon = 10;


static VSS_ID s_WRITERID =
	{
	0xc0577ae6, 0xd741, 0x452a,
	0x8c, 0xba, 0x99, 0xd7, 0x44, 0x00, 0x8c, 0x04
	};

static LPCWSTR s_WRITERNAME = L"Test Writer";



HRESULT CVsWriterTest::RunTest
	(
	CVsTstINIConfig *pConfig,
	CVsTstClientMsg *pClient,
	CVsTstParams *pParams
	)
	{
	try
		{
		m_pConfig = pConfig;
		m_pParams = pParams;
		SetClientMsg(pClient);

		HANDLE hShutdownEvent;
		UINT lifetime;
		if (!m_pParams->GetTerminationEvent(&hShutdownEvent))
			{
			LogFailure("NoShutdownEvent");
			throw E_FAIL;
			}

		if (!m_pParams->GetLifetime(&lifetime) || lifetime > 30 * 24 * 3600)
			lifetime = INFINITE;
		else
			lifetime = lifetime * 1000;


		if (!Initialize())
			{
			LogFailure("CVsWriterTest::Initialize failed");
			throw E_FAIL;
			}

		HRESULT hr = Subscribe();
		ValidateResult(hr, "CVssWriter::Subscribe");
			

		DWORD dwResult = WaitForSingleObject(hShutdownEvent, lifetime);
		Unsubscribe();

		UNREFERENCED_PARAMETER( dwResult );
		}
	catch(HRESULT hr)
		{
		return hr;
		}

	catch(...)
		{
		LogUnexpectedException("CVsWriterTest::RunTest");
		return E_UNEXPECTED;
		}

	return S_OK;
	}


extern "C" __cdecl wmain(int argc, WCHAR **argv)
	{
	bool bCoinitializeSucceeded = false;
	CVsWriterTest *pTest = NULL;
	try
		{
		HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if (FAILED(hr))
			{
			LogUnexpectedFailure(L"CoInitializeEx failed. hr=0x%08lx", hr);
			throw E_UNEXPECTED;
			}

		bCoinitializeSucceeded = true;

		pTest = new CVsWriterTest;
		if (pTest == NULL)
			{
			LogUnexpectedFailure(L"Cannot create test writer");
			throw E_OUTOFMEMORY;
			}

		hr = CVsTstRunner::RunVsTest(argv, argc, pTest, false);
		if (FAILED(hr))
			{
			LogUnexpectedFailure(L"CVsTstRunner::RunVsTest failed.  hr = 0x%08lx", hr);
			throw hr;
			}
		}
	catch(...)
		{
		}

	delete pTest;
	if (bCoinitializeSucceeded)
		CoUninitialize();

	return 0;
	}

void PrintMessage(VSTST_MSG_HDR *phdr)
	{
	VSTST_ASSERT(phdr->type == VSTST_MT_TEXT || phdr->type == VSTST_MT_IMMEDIATETEXT);
	VSTST_TEXTMSG *pmsg = (VSTST_TEXTMSG *) phdr->rgb;
	printf("%d: %s", (UINT) phdr->sequence, pmsg->pch);
	}

void LogUnexpectedFailure(LPCWSTR wsz, ...)
	{
	va_list args;

	va_start(args, wsz);

	VSTST_ASSERT(FALSE);
	wprintf(L"\n!!!UNEXPECTED FAILURE!!!\n");
	vwprintf(wsz, args);
	wprintf(L"\n");
	}


bool CVsWriterTest::Initialize()
	{
	try
		{
		HRESULT hr = CVssWriter::Initialize
					(
					s_WRITERID,
					s_WRITERNAME,
					VSS_UT_USERDATA,
					VSS_ST_OTHER
					);

		ValidateResult(hr, "CVssWriter::Initialize");
		}
	catch(HRESULT)
		{
		return false;
		}
	catch(...)
		{
		LogUnexpectedException("CVsWriterTest::Initialize");
		return false;
		}

	return true;
	}

bool STDMETHODCALLTYPE CVsWriterTest::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
	{
	try
		{
		HRESULT hr = pMetadata->AddIncludeFiles
					(
					L"%systemroot%\\config",
					L"mytestfiles.*",
					false,
					NULL
					);

		ValidateResult(hr, "IVssCreateWriterMetadata::AddIncludeFiles");

		hr = pMetadata->AddExcludeFiles
						(
						L"%systemroot%\\config",
						L"*.tmp",
						true
						);

		ValidateResult(hr, "IVssCreateWriterMetadata::AddExcludeFiles");

		hr = pMetadata->AddComponent
						(
						VSS_CT_DATABASE,
						L"\\mydatabases",
						L"db1",
						L"this is my main database",
						x_rgbIcon,
						x_cbIcon,
						true,
						true,
						true
						);

        ValidateResult(hr, "IVssCreateWriterMetadata::AddComponent");

		hr = pMetadata->AddDatabaseFiles
					(
					L"\\mydatabases",
					L"db1",
					L"e:\\databases",
					L"foo.db"
					);

	    ValidateResult(hr, "IVssCreateWriterMetadata::AddDatabaseFiles");

		hr = pMetadata->AddDatabaseLogFiles
					(
					L"\\mydatabases",
					L"db1",
					L"e:\\logs",
					L"foo.log"
					);

        ValidateResult(hr, "IVssCreateWriterMetadata::AddDatabaseLogFiles");

		hr = pMetadata->SetRestoreMethod
					(
					VSS_RME_RESTORE_TO_ALTERNATE_LOCATION,
					NULL,
					NULL,
					VSS_WRE_ALWAYS,
					true
					);

        ValidateResult(hr, "IVssCreateWriterMetadata::SetRestoreMethod");

		hr = pMetadata->AddAlternateLocationMapping
					(
					L"c:\\databases",
					L"*.db",
					false,
					L"e:\\databases\\restore"
					);

		ValidateResult(hr, "IVssCreateWriterMetadata::AddAlternateLocationMapping");

		hr = pMetadata->AddAlternateLocationMapping
					(
					L"d:\\logs",
					L"*.log",
					false,
					L"e:\\databases\\restore"
					);

		ValidateResult(hr, "IVssCreateWriterMetadata::AddAlternateLocationMapping");
		}
	catch(HRESULT)
		{
		return false;
		}
	catch(...)
		{
		LogUnexpectedException("CVsWriterTest::OnIdentify");
		return false;
		}

	return true;
	}

bool STDMETHODCALLTYPE CVsWriterTest::OnPrepareBackup(IN IVssWriterComponents *pWriterComponents)
	{
	try
		{
		unsigned cComponents;
		LPCWSTR wszBackupType;
		switch(GetBackupType())
			{
			default:
				wszBackupType = L"undefined";
				break;

			case VSS_BT_FULL:
				wszBackupType = L"full";
				break;

			case VSS_BT_INCREMENTAL:
				wszBackupType = L"incremental";
				break;

			case VSS_BT_DIFFERENTIAL:
				wszBackupType = L"differential";
				break;

			case VSS_BT_OTHER:
				wszBackupType = L"other";
				break;
			}

		if (!pWriterComponents)
			return true;

	    HRESULT hr = pWriterComponents->GetComponentCount(&cComponents);
		ValidateResult(hr, "IVssWriterComponents::GetComponentCount");

		for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
			{
			CComPtr<IVssComponent> pComponent;
			VSS_COMPONENT_TYPE ct;
			CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;

			hr = pWriterComponents->GetComponent(iComponent, &pComponent);
			ValidateResult(hr, "IVssWriterComponents::GetComponent");
			hr = pComponent->GetLogicalPath(&bstrLogicalPath);
			ValidateResult(hr, "IVssComponent::GetLogicalPath");
			hr = pComponent->GetComponentType(&ct);
			ValidateResult(hr, "IVssComponent::GetComponentType");
			hr = pComponent->GetComponentName(&bstrComponentName);
			ValidateResult(hr, "IVssComponent::GetComponentName");
			CComPtr<IXMLDOMNode> pNode;
			hr = pComponent->SetPrivateXMLMetadata(L"BACKUPINFO", &pNode);
			ValidateResult(hr, "IVssComponent::SetPrivateXMLMetadata");

			CComPtr<IXMLDOMElement> pElement;
			hr = pNode->SafeQI(IXMLDOMElement, &pElement);
			ValidateResult(hr, "IXMLDOMNode::QueryInterface");

			CComBSTR bstrAttributeName = L"backupTime";
			if (bstrAttributeName.Length() == 0)
				throw(E_OUTOFMEMORY);

			CComVariant varValue = (INT) time(NULL);
	
			// Set the attribute
		    hr = pElement->setAttribute(bstrAttributeName, varValue);
			ValidateResult(hr, "IXMLDOMElement::setAttribute");
			}
		}
	catch(HRESULT)
		{
		return false;
		}
	catch(...)
		{
		LogUnexpectedException("CVsWriterTest::OnPrepareBackup");
		return false;
		}

	return true;
	}

bool STDMETHODCALLTYPE CVsWriterTest::OnPrepareSnapshot()
	{
	Sleep(5000);
	return true;
	}


bool STDMETHODCALLTYPE CVsWriterTest::OnFreeze()
	{
	Sleep(1000);
	return true;
	}

bool STDMETHODCALLTYPE CVsWriterTest::OnThaw()
	{
	Sleep(1000);
	return true;
	}

bool STDMETHODCALLTYPE CVsWriterTest::OnBackupComplete(IN IVssWriterComponents *pWriterComponents)
	{
	try
		{
		HRESULT hr;
		unsigned cComponents;

		hr = pWriterComponents->GetComponentCount(&cComponents);
		ValidateResult(hr, "IVssWriterComponents::GetComponentCount");

		for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
			{
			CComPtr<IVssComponent> pComponent;
			VSS_COMPONENT_TYPE ct;
			CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;
			bool bBackupSucceeded;

			hr = pWriterComponents->GetComponent(iComponent, &pComponent);
			ValidateResult(hr, "IVssWriterComponents::GetComponent");
			hr = pComponent->GetLogicalPath(&bstrLogicalPath);
			ValidateResult(hr, "IVssComponent::GetLogicalPath");
			hr = pComponent->GetComponentType(&ct);
            ValidateResult(hr, "IVssComponent::GetComponentType");
		    hr = pComponent->GetComponentName(&bstrComponentName);
			ValidateResult(hr, "IVssComponent::GetComponentName");
			hr = pComponent->GetBackupSucceeded(&bBackupSucceeded);
			ValidateResult(hr, "IVssComponent::GetBackupSucceeded");

			CComPtr<IXMLDOMNode> pNode;
			hr = pComponent->GetPrivateXMLData(L"BACKUPINFO", &pNode);
			ValidateResult(hr, "IVssComponent::GetPrivateXMLData");

			// create attribute map if one doesn't exist
			CComPtr<IXMLDOMNamedNodeMap>pAttributeMap;
			hr = pNode->get_attributes(&pAttributeMap);
			ValidateResult(hr, "IVssDOMNamedNodeMap::get_attributes");

			bool bFound = false;
			CComPtr<IXMLDOMNode> pNodeT = NULL;
			if (pAttributeMap != NULL)
				{
				// get attribute
				HRESULT hr = pAttributeMap->getNamedItem(L"backupTime", &pNodeT);
				if (SUCCEEDED(hr))
					bFound = true;
				if (bFound)
					{
					CComBSTR bstrAttrValue;
					hr = pNodeT->get_text(&bstrAttrValue);
					ValidateResult(hr, "IXMLDOMNode::get_text");
					}
				else
					{
					LogFailure("didn't find private backupTime attribute");
					}
				}
			}
		}
	catch(HRESULT)
		{
		return false;
		}
	catch(...)
		{
		LogUnexpectedException("CVsWriterTest::OnBackupComplete");
		return false;
		}

	return true;
	}

bool STDMETHODCALLTYPE CVsWriterTest::OnRestore(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);
	Sleep(10000);
	return true;
	}

bool STDMETHODCALLTYPE CVsWriterTest::OnAbort()
	{
	return true;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\mptest\backup\debug.h ===
inline void CHECK_SUCCESS(HRESULT hr)
	{
	if (hr != S_OK)
		{
		wprintf(L"operation failed with HRESULT=%08x\n", hr);
		DebugBreak();
		}
	}

inline void CHECK_NOFAIL(HRESULT hr)
	{
	if (FAILED(hr))
		{
		wprintf(L"operation failed with HRESULT=%08x\n", hr);
		DebugBreak();
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\metasnap\metasnap.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	metasnap.cpp
**
**
** Abstract:
**
**	Test program to obtain and display the Writer metadata.
**
**
** Author:
**
**	Michael C. Johnson   [mikejohn]        21-Jul-2000
**
**	(Based on another test program BETEST by Brian Berkowitz)
**
**
** Revision History:
**
**--
*/

/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/
#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>


#include <oleauto.h>

#define ATLASSERT(_condition)

#include <atlconv.h>
#include <atlbase.h>

extern CComModule _Module;
#include <atlcom.h>



inline void CHECK_SUCCESS (HRESULT hr)
    {
    if (hr != S_OK)
	{
	wprintf(L"operation failed with HRESULT =0x%08x\n", hr);
	DebugBreak();
	}
    }

inline void CHECK_NOFAIL (HRESULT hr)
    {
    if (FAILED(hr))
	{
	wprintf(L"operation failed with HRESULT =0x%08x\n", hr);
	DebugBreak();
	}
    }



BOOL AssertPrivilege( LPCWSTR privName )
    {
    HANDLE		 tokenHandle;
    TOKEN_PRIVILEGES	 newState;
    TOKEN_PRIVILEGES	*pTokens = NULL;
    BOOL		 stat    = FALSE;
    LUID		 value;
    DWORD		 error;
    DWORD		 cbTokens;


    if (OpenProcessToken (GetCurrentProcess(),
			  TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,
			  &tokenHandle))
	{

	if (LookupPrivilegeValue (NULL, privName, &value))
	    {
	    newState.PrivilegeCount            = 1;
	    newState.Privileges [0].Luid       = value;
	    newState.Privileges [0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED;

	    /*
	    ** We will always call GetLastError below, so clear
	    ** any prior error values on this thread.
	    */
	    SetLastError (ERROR_SUCCESS);

	    stat = AdjustTokenPrivileges (tokenHandle,
					  FALSE,
					  &newState,
					  (DWORD)0,
					  NULL,
					  NULL);

	    /*
	    ** Supposedly, AdjustTokenPriveleges always returns TRUE
	    ** (even when it fails). So, call GetLastError to be
	    ** extra sure everything's cool.
	    */
	    if ((error = GetLastError()) != ERROR_SUCCESS)
		{
		stat = FALSE;
		}

	    if (!stat)
		{
		wprintf (L"AdjustTokenPrivileges for %s failed with %d",
			 privName,
			 error);
		}
	    }



	GetTokenInformation (tokenHandle,
			     TokenPrivileges,
			     NULL,
			     0,
			     &cbTokens);


	pTokens = (TOKEN_PRIVILEGES *) new BYTE[cbTokens];

	GetTokenInformation (tokenHandle,
			     TokenPrivileges,
			     pTokens,
			     cbTokens,
			     &cbTokens);

	delete pTokens;
	CloseHandle (tokenHandle);
	}


    return stat;
    }


LPCWSTR GetStringFromUsageType (VSS_USAGE_TYPE eUsageType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eUsageType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszRetString = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszRetString = L"SystemService";       break;
	case VSS_UT_USERDATA:            pwszRetString = L"UserData";            break;
	case VSS_UT_OTHER:               pwszRetString = L"Other";               break;
					
	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eSourceType)
	{
	case VSS_ST_TRANSACTEDDB:    pwszRetString = L"TransactionDb";    break;
	case VSS_ST_NONTRANSACTEDDB: pwszRetString = L"NonTransactionDb"; break;
	case VSS_ST_OTHER:           pwszRetString = L"Other";            break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromRestoreMethod (VSS_RESTOREMETHOD_ENUM eRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eRestoreMethod)
	{
	case VSS_RME_RESTORE_IF_NOT_THERE:          pwszRetString = L"RestoreIfNotThere";          break;
	case VSS_RME_RESTORE_IF_CAN_REPLACE:        pwszRetString = L"RestoreIfCanReplace";        break;
	case VSS_RME_STOP_RESTORE_START:            pwszRetString = L"StopRestoreStart";           break;
	case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION: pwszRetString = L"RestoreToAlternateLocation"; break;
	case VSS_RME_RESTORE_AT_REBOOT:             pwszRetString = L"RestoreAtReboot";            break;
	case VSS_RME_CUSTOM:                        pwszRetString = L"Custom";                     break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromWriterRestoreMethod (VSS_WRITERRESTORE_ENUM eWriterRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eWriterRestoreMethod)
	{
	case VSS_WRE_NEVER:            pwszRetString = L"RestoreNever";           break;
	case VSS_WRE_IF_REPLACE_FAILS: pwszRetString = L"RestoreIfReplaceFailsI"; break;
	case VSS_WRE_ALWAYS:           pwszRetString = L"RestoreAlways";          break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eComponentType)
	{
	case VSS_CT_DATABASE:  pwszRetString = L"Database";  break;
	case VSS_CT_FILEGROUP: pwszRetString = L"FileGroup"; break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromFailureType (HRESULT hrStatus)
    {
    LPCWSTR pwszFailureType;

    switch (hrStatus)
	{
	case NOERROR:                                pwszFailureType = L"";                     break;
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT: pwszFailureType = L"InconsistentSnapshot"; break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:       pwszFailureType = L"OutOfResources";       break;
	case VSS_E_WRITERERROR_TIMEOUT:              pwszFailureType = L"Timeout";              break;
	case VSS_E_WRITERERROR_NONRETRYABLE:         pwszFailureType = L"Non-Retryable";        break;
	case VSS_E_WRITERERROR_RETRYABLE:            pwszFailureType = L"Retryable";            break;
	default:                                     pwszFailureType = L"UNDEFINED";            break;
	}

    return (pwszFailureType);
    }





void PrintFiledesc (IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription)
    {
    CComBSTR bstrPath;
    CComBSTR bstrFilespec;
    CComBSTR bstrAlternate;
    bool     bRecursive;


    CHECK_SUCCESS (pFiledesc->GetPath (&bstrPath));
    CHECK_SUCCESS (pFiledesc->GetFilespec (&bstrFilespec));
    CHECK_NOFAIL  (pFiledesc->GetRecursive (&bRecursive));
    CHECK_NOFAIL  (pFiledesc->GetAlternateLocation (&bstrAlternate));

    wprintf (L"%s\n            Path = %s, Filespec = %s, Recursive = %s\n",
	     wszDescription,
	     bstrPath,
	     bstrFilespec,
	     bRecursive ? L"yes" : L"no");

    if (bstrAlternate && wcslen (bstrAlternate) > 0)
	{
	wprintf(L"            Alternate Location = %s\n", bstrAlternate);
	}
    }



extern "C" __cdecl wmain(int argc, WCHAR **argv)
    {
    HRESULT	hr                     = NOERROR;
    bool	bCoInitializeSucceeded = false;


    UNREFERENCED_PARAMETER (argc);
    UNREFERENCED_PARAMETER (argv);


    try
	{
	unsigned cWriters;
	CComBSTR bstrXML;
	CComBSTR bstrXMLOut;
	CComBSTR strSnapshotSetId = "12345678-1234-1234-1234-1234567890ab";
	CComPtr<IVssBackupComponents> pvbc;
	CComPtr<IVssAsync> pAsync;


        CHECK_SUCCESS (CoInitializeEx (NULL, COINIT_MULTITHREADED));

	bCoInitializeSucceeded = true;

	if (!AssertPrivilege (SE_BACKUP_NAME))
	    {
	    wprintf(L"AssertPrivilege returned error, rc:%d\n", GetLastError ());
	    return 2;
	    }

	CHECK_SUCCESS (CreateVssBackupComponents (&pvbc));

	CHECK_SUCCESS (pvbc->InitializeForBackup  ());
	CHECK_SUCCESS (pvbc->SetBackupState       (true, false, VSS_BT_FULL));
	CHECK_NOFAIL  (pvbc->GatherWriterMetadata (&pAsync));
	CHECK_NOFAIL  (pAsync->Wait ());
	CHECK_NOFAIL  (pvbc->GetWriterMetadataCount (&cWriters));


	for (unsigned iWriter = 0; iWriter < cWriters; iWriter++)
	    {
	    CComPtr<IVssExamineWriterMetadata> pMetadata;

	    VSS_ID           idInstance;
	    VSS_ID           idInstanceT;
	    VSS_ID           idWriter;
	    CComBSTR         bstrWriterName;
	    VSS_USAGE_TYPE   usage;
	    VSS_SOURCE_TYPE  source;
	    WCHAR           *pwszInstanceId;
	    WCHAR           *pwszWriterId;
	    unsigned cIncludeFiles, cExcludeFiles, cComponents;
	    CComBSTR bstrPath;
	    CComBSTR bstrFilespec;
	    CComBSTR bstrAlternate;
	    CComBSTR bstrDestination;



	    CHECK_SUCCESS (pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata));

	    CHECK_SUCCESS (pMetadata->GetIdentity (&idInstanceT,
						   &idWriter,
						   &bstrWriterName,
						   &usage,
						   &source));

	    wprintf (L"\n\n");

            if (memcmp (&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
		{
		wprintf(L"Instance id mismatch\n");
		DebugBreak();
		}


	    UuidToString (&idInstance, &pwszInstanceId);
	    UuidToString (&idWriter,   &pwszWriterId);

	    wprintf (L"WriterName = %s\n\n"
		     L"    WriterId   = %s\n"
		     L"    InstanceId = %s\n"
		     L"    UsageType  = %d (%s)\n"
		     L"    SourceType = %d (%s)\n",
		     bstrWriterName,
		     pwszWriterId,
		     pwszInstanceId,
		     usage,
		     GetStringFromUsageType (usage),
		     source,
		     GetStringFromSourceType (source));

	    RpcStringFree (&pwszInstanceId);
	    RpcStringFree (&pwszWriterId);

	    CHECK_SUCCESS(pMetadata->GetFileCounts (&cIncludeFiles,
						    &cExcludeFiles,
						    &cComponents));

	    for(unsigned i = 0; i < cIncludeFiles; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;

		CHECK_SUCCESS (pMetadata->GetIncludeFile (i, &pFiledesc));

		PrintFiledesc(pFiledesc, L"\n    Include File");
		}


	    for(i = 0; i < cExcludeFiles; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;

		CHECK_SUCCESS (pMetadata->GetExcludeFile (i, &pFiledesc));

		PrintFiledesc (pFiledesc, L"\n    Exclude File");
		}


	    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
		CComPtr<IVssWMComponent> pComponent;
		PVSSCOMPONENTINFO pInfo;

		CHECK_SUCCESS (pMetadata->GetComponent      (iComponent, &pComponent));
		CHECK_SUCCESS (pComponent->GetComponentInfo (&pInfo));

		wprintf (L"\n"
			 L"    Component %d, type = %d (%s)\n"
			 L"        LogicalPath = %s\n"
			 L"        Name        = %s\n"
			 L"        Caption     = %s\n"
			 L"        Icon size   = %u\n",
			 iComponent,
			 pInfo->type,
			 GetStringFromComponentType (pInfo->type),
			 pInfo->bstrLogicalPath,
			 pInfo->bstrComponentName,
			 pInfo->bstrCaption,
			 pInfo->cbIcon );
					
		wprintf (L"        RestoreMetadata        = %s\n"
			 L"        NotifyOnBackupComplete = %s\n"
			 L"        Selectable             = %s\n",
			 pInfo->bRestoreMetadata        ? L"yes" : L"no",
			 pInfo->bNotifyOnBackupComplete ? L"yes" : L"no",
			 pInfo->bSelectable             ? L"yes" : L"no");


		if (pInfo->cFileCount > 0)
		    {
		    for(i = 0; i < pInfo->cFileCount; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;

			CHECK_SUCCESS (pComponent->GetFile (i, &pFiledesc));

			PrintFiledesc (pFiledesc, L"        FileGroupFile");
			}
		    }

		if (pInfo->cDatabases > 0)
		    {
		    for(i = 0; i < pInfo->cDatabases; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;

			CHECK_SUCCESS (pComponent->GetDatabaseFile (i, &pFiledesc));

			PrintFiledesc (pFiledesc, L"        DatabaseFile");
			}
		    }


		if (pInfo->cLogFiles > 0)
		    {
		    for(i = 0; i < pInfo->cLogFiles; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;

			CHECK_SUCCESS (pComponent->GetDatabaseLogFile (i, &pFiledesc));

			PrintFiledesc (pFiledesc, L"        DatabaseLogFile");
			}
		    }

		pComponent->FreeComponentInfo (pInfo);
		}



	    VSS_RESTOREMETHOD_ENUM method;
	    CComBSTR bstrUserProcedure;
	    CComBSTR bstrService;
	    VSS_WRITERRESTORE_ENUM writerRestore;
	    unsigned cMappings;
	    bool bRebootRequired;

	    CHECK_NOFAIL (pMetadata->GetRestoreMethod (&method,
						       &bstrService,
						       &bstrUserProcedure,
						       &writerRestore,
						       &bRebootRequired,
						       &cMappings));


	    wprintf (L"\n"
		     L"    Restore method = %d (%s)\n"
		     L"    Service        = %d\n"
		     L"    User Procedure = %s\n"
		     L"    WriterRestore  = %d (%s)\n"
		     L"    RebootRequired = %s\n",
		     method,
		     GetStringFromRestoreMethod (method),
		     bstrService,
		     bstrUserProcedure,
		     writerRestore,
		     GetStringFromWriterRestoreMethod (writerRestore),
		     bRebootRequired ? L"yes" : L"no");

	    for(i = 0; i < cMappings; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;

		CHECK_SUCCESS (pMetadata->GetAlternateLocationMapping (i, &pFiledesc));

		PrintFiledesc (pFiledesc, L"    AlternateMapping");
		}
	    }


	CHECK_SUCCESS (pvbc->FreeWriterMetadata());
	}
    catch(...)
	{
	hr = E_UNEXPECTED;
	}


    if (FAILED(hr))             wprintf (L"Failed with 0x%08X.\n", hr);
    if (bCoInitializeSucceeded) CoUninitialize();

    return (0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\harness\writer\writer.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    writer.h

Abstract:

    definitions for test writer


    Brian Berkowitz  [brianb]  06/02/2000

TBD:
	

Revision History:

    Name        Date        Comments
    brianb      06/02/2000  Created
    mikejohn	09/19/2000  176860: Added calling convention methods where missing


--*/


class CVsWriterTest :
	public IVsTstRunningTest,
	public CVssWriter,
	public CVsTstClientLogger
	{
public:
	HRESULT RunTest
		(
		CVsTstINIConfig *pConfig,
		CVsTstClientMsg *pMsg,
		CVsTstParams *pParams
		);


	HRESULT ShutdownTest(VSTST_SHUTDOWN_REASON reason)
		{
		UNREFERENCED_PARAMETER(reason);
		VSTST_ASSERT(FALSE && "shouldn't get here");
		return S_OK;
		}

   	virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

	virtual bool STDMETHODCALLTYPE OnPrepareBackup(IN IVssWriterComponents *pComponent);

	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

	virtual bool STDMETHODCALLTYPE OnFreeze();

	virtual bool STDMETHODCALLTYPE OnThaw();

	virtual bool STDMETHODCALLTYPE OnAbort();

	virtual bool STDMETHODCALLTYPE OnBackupComplete(IN IVssWriterComponents *pComponent);

	virtual bool STDMETHODCALLTYPE OnRestore(IN IVssWriterComponents *pComponent);

private:
	bool Initialize();

	// configuration file
	CVsTstINIConfig *m_pConfig;

	// command line parameters
	CVsTstParams *m_pParams;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\mptest\backup\main.cpp ===
#include "stdafx.hxx"
#include "vs_idl.hxx"
#include "vswriter.h"
#include "vsbackup.h"
#include <debug.h>
#include <vsswprv.h>



CComModule _Module;

static LPCWSTR s_rgwszStates[] =
	{
	NULL,
	L"STABLE",
	L"WAIT_FOR_FREEZE",
	L"WAIT_FOR_THAW",
	L"WAIT_FOR_COMPLETION",
	L"FAILED_AT_IDENTIFY",
	L"FAILED_AT_PREPARE_BACKUP",
	L"FAILED_AT_PREPARE_SNAPSHOT",
	L"FAILED_AT_FREEZE",
	L"FAILED_AT_THAW"
	};



void CheckStatus(IVssBackupComponents *pvbc, LPCWSTR wszWhen)
	{
	unsigned cWriters;
	CComPtr<IVssAsync> pAsync;

	CHECK_NOFAIL(pvbc->GatherWriterStatus(&pAsync));
	CHECK_NOFAIL(pAsync->Wait());
	CHECK_NOFAIL(pvbc->GetWriterStatusCount(&cWriters));


	wprintf(L"status %s\n%d writers\n\n", wszWhen, cWriters);
	for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
		{
		VSS_ID idInstance;
		VSS_ID idWriter;
		CComBSTR bstrWriter;
		VSS_WRITER_STATE status;
		HRESULT hrWriterFailure;

		CHECK_SUCCESS(pvbc->GetWriterStatus
							(
							iWriter,
							&idInstance,
							&idWriter,
							&bstrWriter,
							&status,
							&hrWriterFailure
							));

		wprintf
			(
			L"Status for writer %s: %s(0x%08lx)\n",
			bstrWriter,
			s_rgwszStates[status],
			hrWriterFailure
			);
        }

	pvbc->FreeWriterStatus();
	}


void PrintFiledesc(IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription)
	{
	CComBSTR bstrPath;
	CComBSTR bstrFilespec;
	CComBSTR bstrAlternate;
	CComBSTR bstrDestination;
	bool bRecursive;

	CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
	CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
	CHECK_NOFAIL(pFiledesc->GetRecursive(&bRecursive));
	CHECK_NOFAIL(pFiledesc->GetAlternateLocation(&bstrAlternate));
	CHECK_NOFAIL(pFiledesc->GetAlternateLocation(&bstrDestination));

	wprintf
		(
		L"%s\nPath=%s,Filespec=%s, Recursive=%s\n",
		wszDescription,
		bstrPath,
		bstrFilespec,
		bRecursive ? L"yes" : L"no"
		);

    if (bstrAlternate && wcslen(bstrAlternate) > 0)
		wprintf(L"Alternate Location = %s\n", bstrAlternate);

	if (bstrDestination && wcslen(bstrDestination) > 0)
		wprintf(L"Destination Location = %s\n", bstrDestination);
	}

HANDLE LaunchWriterProcess()
	{
	HANDLE hEventW = CreateEvent(NULL, TRUE, FALSE, L"TESTWRITEREVENT");
	if (hEventW == NULL)
		{
		wprintf(L"CreateEvent failed with error %d.\n", GetLastError());
		DebugBreak();
		}

	HANDLE hEventB = CreateEvent(NULL, TRUE, FALSE, L"TESTBACKUPEVENT");
	if (hEventB == NULL)
		{
		wprintf(L"CreateEvent failed with error %d.\n", GetLastError());
		DebugBreak();
		}

	WaitForSingleObject(hEventB, INFINITE);
	return hEventW;
	}

void DoAddToSnapshotSet
	(
	IN IVssBackupComponents *pvbc,
	IN BSTR bstrPath,
	IN LPWSTR wszVolumes
	)
	{
	WCHAR wszVolume[100];
	WCHAR *pwc = bstrPath;
	WCHAR *pwcDest = wszVolume;


	for(; *pwc != ':'; pwc++, pwcDest++)
		*pwcDest = *pwc;

	*pwcDest++ = L':';
	*pwcDest++ = L'\\';
	*pwcDest++ = L'\0';
	pwc = wszVolumes;
	while(*pwc != '\0')
		{
		if (wcsncmp(pwc, wszVolume, wcslen(wszVolume)) == 0)
			return;

		pwc = wcschr(pwc, L';');
		if (pwc == NULL)
			break;
		}

	pwc = wszVolumes + wcslen(wszVolumes);
	wcscpy(pwc, wszVolume);
	VSS_ID SnapshotId;
	CHECK_SUCCESS(pvbc->AddToSnapshotSet
						(
						wszVolume,
						VSS_SWPRV_ProviderId,
						&SnapshotId
						));
    }



extern "C" __cdecl wmain(int argc, WCHAR **argv)
	{
	HANDLE hEvent = NULL;
	HRESULT hr = S_OK;

	try
		{
		WCHAR wszVolumes[100];
        CHECK_SUCCESS(CoInitializeEx(NULL, COINIT_MULTITHREADED));
		hEvent = LaunchWriterProcess();

		CComBSTR strSnapshotSetId = "12345678-1234-1234-1234-1234567890ab";

		CComPtr<IVssBackupComponents> pvbc;

		CHECK_SUCCESS(CreateVssBackupComponents(&pvbc));

		CHECK_SUCCESS(pvbc->InitializeForBackup());
		CHECK_SUCCESS(pvbc->SetBackupState
						(
						true,
						false,
						VSS_BT_INCREMENTAL
						));

		unsigned cWriters;
		CComPtr<IVssAsync> pAsync;

		CHECK_NOFAIL(pvbc->GatherWriterMetadata(&pAsync));
		CHECK_NOFAIL(pAsync->Wait());
		CHECK_NOFAIL(pvbc->GetWriterMetadataCount(&cWriters));

		VSS_ID id;

		CHECK_SUCCESS(pvbc->StartSnapshotSet(&id));

		for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
			{
			CComPtr<IVssExamineWriterMetadata> pMetadata;
			VSS_ID idInstance;

			CHECK_SUCCESS(pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata));
			VSS_ID idInstanceT;
			VSS_ID idWriter;
			CComBSTR bstrWriterName;
			VSS_USAGE_TYPE usage;
			VSS_SOURCE_TYPE source;

			CHECK_SUCCESS(pMetadata->GetIdentity
							(
							&idInstanceT,
							&idWriter,
							&bstrWriterName,
							&usage,
							&source
							));

            if (memcmp(&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
				{
				wprintf(L"Instance id mismatch\n");
				DebugBreak();
				}

			WCHAR *pwszInstanceId;
			WCHAR *pwszWriterId;
			UuidToString(&idInstance, &pwszInstanceId);
			UuidToString(&idWriter, &pwszWriterId);
			wprintf
				(
				L"InstanceId=%s\nWriterId=%s\nWriterName=%s\nUsageType=%d\nSourceType=%d\n",
				pwszInstanceId,
				pwszWriterId,
				bstrWriterName,
				usage,
				source
				);

			RpcStringFree(&pwszInstanceId);
			RpcStringFree(&pwszWriterId);

			unsigned cIncludeFiles, cExcludeFiles, cComponents;
			CHECK_SUCCESS(pMetadata->GetFileCounts
								(
								&cIncludeFiles,
								&cExcludeFiles,
								&cComponents
								));

			CComBSTR bstrPath;
			CComBSTR bstrFilespec;
			CComBSTR bstrAlternate;
			CComBSTR bstrDestination;
			bool bRecursive;

			for(unsigned i = 0; i < cIncludeFiles; i++)
				{
				CComPtr<IVssWMFiledesc> pFiledesc;
				CHECK_SUCCESS(pMetadata->GetIncludeFile(i, &pFiledesc));

				PrintFiledesc(pFiledesc, L"Include File");
				}

			for(i = 0; i < cExcludeFiles; i++)
				{
				CComPtr<IVssWMFiledesc> pFiledesc;
				CHECK_SUCCESS(pMetadata->GetExcludeFile(i, &pFiledesc));
				PrintFiledesc(pFiledesc, L"Exclude File");
				}

			for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
				{
				CComPtr<IVssWMComponent> pComponent;
				PVSSCOMPONENTINFO pInfo;
				CHECK_SUCCESS(pMetadata->GetComponent(iComponent, &pComponent));
				CHECK_SUCCESS(pComponent->GetComponentInfo(&pInfo));
				wprintf
					(
					L"Component %d, type=%d\nLogicalPath=%s,Name=%s\nCaption=%s\n",
					i,
					pInfo->type,
					pInfo->bstrLogicalPath,
					pInfo->bstrComponentName,
					pInfo->bstrCaption
					);

				wprintf
					(
					L"RestoreMetadata=%s,NotifyOnBackupComplete=%s,Selectable=%s\n",
					pInfo->bRestoreMetadata ? L"yes" : L"no",
					pInfo->bNotifyOnBackupComplete ? L"yes" : L"no",
					pInfo->bSelectable ? L"yes" : L"no"
					);


				CHECK_SUCCESS(pvbc->AddComponent
								(
								idInstance,
								idWriter,
								pInfo->type,
								pInfo->bstrLogicalPath,
								pInfo->bstrComponentName
								));


				if (pInfo->cFileCount > 0)
					{
					for(i = 0; i < pInfo->cFileCount; i++)
						{
						CComPtr<IVssWMFiledesc> pFiledesc;
						CHECK_SUCCESS(pComponent->GetFile(i, &pFiledesc));

						CComBSTR bstrPath;
						CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
						DoAddToSnapshotSet(pvbc, bstrPath, wszVolumes);

						PrintFiledesc(pFiledesc, L"FileGroupFile");
						}
					}

				if (pInfo->cDatabases > 0)
					{
					for(i = 0; i < pInfo->cDatabases; i++)
						{
						CComPtr<IVssWMFiledesc> pFiledesc;
						CHECK_SUCCESS(pComponent->GetDatabaseFile(i, &pFiledesc));

						CComBSTR bstrPath;
						CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
						DoAddToSnapshotSet(pvbc, bstrPath, wszVolumes);
						PrintFiledesc(pFiledesc, L"DatabaseFile");
						}
					}

				if (pInfo->cLogFiles > 0)
					{
					for(i = 0; i < pInfo->cLogFiles; i++)
						{
						CComPtr<IVssWMFiledesc> pFiledesc;
						CHECK_SUCCESS(pComponent->GetDatabaseLogFile(i, &pFiledesc));

						CComBSTR bstrPath;
						CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
						DoAddToSnapshotSet(pvbc, bstrPath, wszVolumes);
						PrintFiledesc(pFiledesc, L"DatabaseLogFile");
						}
					}

				pComponent->FreeComponentInfo(pInfo);
				}

			VSS_RESTOREMETHOD_ENUM method;
			CComBSTR bstrUserProcedure;
			CComBSTR bstrService;
			VSS_WRITERRESTORE_ENUM writerRestore;
			unsigned cMappings;
			bool bRebootRequired;

			CHECK_SUCCESS(pMetadata->GetRestoreMethod
							(
							&method,
							&bstrService,
							&bstrUserProcedure,
							&writerRestore,
							&bRebootRequired,
							&cMappings
							));


			wprintf
				(
				L"Restore method=%d\nService=%s\nUser Procedure=%s\nwriterRestore=%d\nrebootRequired=%s\n\n",
				method,
				bstrService,
				bstrUserProcedure,
				writerRestore,
				bRebootRequired ? L"yes" : L"no"
				);

			for(i = 0; i < cMappings; i++)
				{
				CComPtr<IVssWMFiledesc> pFiledesc;

				CHECK_SUCCESS(pMetadata->GetAlternateLocationMapping(i, &pFiledesc));

				PrintFiledesc(pFiledesc, L"AlternateMapping");
				}
			}

		CHECK_SUCCESS(pvbc->FreeWriterMetadata());

			{
			CComPtr<IVssAsync> pAsync;
			HRESULT hr;
			INT nPercentDone;

			CHECK_SUCCESS(pvbc->PrepareForBackup(&pAsync));
			CHECK_SUCCESS(pAsync->Wait());
			CHECK_SUCCESS(pAsync->QueryStatus(&hr, &nPercentDone));
			CHECK_NOFAIL(hr);
			}

		CheckStatus(pvbc, L"After Prepare Backup");
		unsigned cWriterComponents;
		CHECK_SUCCESS(pvbc->GetWriterComponentsCount(&cWriterComponents));
		for(iWriter = 0; iWriter < cWriterComponents; iWriter++)
			{
			CComPtr<IVssWriterComponentsExt> pWriter;
			CHECK_SUCCESS(pvbc->GetWriterComponents(iWriter, &pWriter));

			unsigned cComponents;
			CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
			VSS_ID idWriter, idInstance;
			CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));
			for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
				{
				CComPtr<IVssComponent> pComponent;
				CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
				
				VSS_COMPONENT_TYPE ct;
				CComBSTR bstrLogicalPath;
				CComBSTR bstrComponentName;
				bool bBackupSucceeded;

				CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
				CHECK_SUCCESS(pComponent->GetComponentType(&ct));
				CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
				CHECK_SUCCESS(pvbc->SetBackupSucceeded
								(
								idInstance,
								idWriter,
								ct,
								bstrLogicalPath,
								bstrComponentName,
								true
								));
				}
			}

			{
			CComPtr<IVssAsync> pAsync;
			INT nPercentDone;
			CHECK_SUCCESS(pvbc->DoSnapshotSet
								(
								&pAsync
								));


			CHECK_SUCCESS(pAsync->Wait());
			CHECK_SUCCESS(pAsync->QueryStatus(&hr, &nPercentDone));
			}

        if (FAILED(hr))
			{
			wprintf(L"Creating the snapshot failed.  hr = 0x%08lx\n", hr);
			CheckStatus(pvbc, L"After Do Snapshot");
			}
		else
			{
			CheckStatus(pvbc, L"After Do Snapshot");
			LONG lSnapshotsNotDeleted;
			VSS_ID rgSnapshotsNotDeleted[10];

            	{
				CComPtr<IVssAsync> pAsync;
				HRESULT hr;
				INT nPercentDone;

				CHECK_SUCCESS(pvbc->BackupComplete(&pAsync));
				CHECK_SUCCESS(pAsync->Wait());
				CHECK_SUCCESS(pAsync->QueryStatus(&hr, &nPercentDone));
				CHECK_NOFAIL(hr);
				}

			CheckStatus(pvbc, L"After Backup Complete");
			hr  = pvbc->DeleteSnapshots
					(
					id,
					VSS_OBJECT_SNAPSHOT_SET,
					false,
					&lSnapshotsNotDeleted,
					rgSnapshotsNotDeleted
					);

			if (FAILED(hr))
				wprintf(L"Deletion of Snapshots failed.  hr = 0x%08lx\n", hr);
			}
		}
	catch(...)
		{
		hr = E_UNEXPECTED;
		}

	if (hEvent)
		SetEvent(hEvent);

	if (FAILED(hr))
		wprintf(L"Failed with %08x.\n", hr);

	return(0);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\jettest\main.cpp ===
#include <stdafx.h>

#include <vss.h>
#include <vswriter.h>

#include <jetwriter.h>
#include <esent98.h>

#define	DATABASE_ROOT		L"%SystemDrive%\\JetTestDatabases"
#define	DATABASE_ROOT_A		 "%SystemDrive%\\JetTestDatabases"
#define INCLUDED_DATABASES	L"\\IncludedDatabases"
#define INCLUDED_DATABASES_A	 "\\IncludedDatabases"
#define	EXCLUDED_DATABASES	L"\\ExcludedDatabases"
#define	EXCLUDED_DATABASES_A	 "\\ExcludedDatabases"



#if 1
#define FilesToInclude	L"X:\\Element-00\\/s;"						\
			L"x:\\Element-01\\/s;"						\
			L"x:\\Element-02\\*      /S     ;"				\
			L" x:\\Element-03\\a very long path\\with a long dir\\a.bat"

#define FilesToExclude	DATABASE_ROOT EXCLUDED_DATABASES L"\\" L" /s"

#else

/*
** These are the paths used by RSS at one point.
*/
#define	FilesToExclude	L"%SystemRoot%\\System32\\RemoteStorage\\FsaDb\\*;"	\
			L"%SystemRoot%\\System32\\RemoteStorage\\Trace\\*"

#define	FilesToInclude	L""

#endif




#define	GET_STATUS_FROM_BOOL(_bSucceeded)	((_bSucceeded)       ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_HANDLE(_handle)		((NULL != (_handle)) ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_POINTER(_ptr)		((NULL != (_ptr))    ? NOERROR : E_OUTOFMEMORY)


static const PCHAR achDatabaseNames [] =
    {
    DATABASE_ROOT_A INCLUDED_DATABASES_A "\\jettest_db0.jdb",
    DATABASE_ROOT_A EXCLUDED_DATABASES_A "\\jettest_db1.jdb",
    DATABASE_ROOT_A INCLUDED_DATABASES_A "\\jettest_db2.jdb",
    DATABASE_ROOT_A EXCLUDED_DATABASES_A "\\jettest_db3.jdb",
    DATABASE_ROOT_A INCLUDED_DATABASES_A "\\jettest_db4.jdb",
    DATABASE_ROOT_A EXCLUDED_DATABASES_A "\\jettest_db5.jdb",
    DATABASE_ROOT_A INCLUDED_DATABASES_A "\\jettest_db6.jdb",
    DATABASE_ROOT_A EXCLUDED_DATABASES_A "\\jettest_db7.jdb"
    };


#define MAX_DATABASE_COUNT		(sizeof (achDatabaseNames) / sizeof (PWCHAR))

static CHAR achExpandedDatabaseNames [MAX_DATABASE_COUNT] [MAX_PATH + 1];



static const char szUser []		= "admin";
static const char szPassword []		= "\0";

static const char szTable1 []		= "table1";
static const char szTable2 []		= "table2";

static const char szF1Name []		= "F1PAD";
static const char szF2Name []		= "F2";
static const char szF3Name []		= "F3";
static const char szV1Name []		= "V1";
static const char szT1Name []		= "T1";
static const char szT2Name []		= "T2";
					
static const char szXF1Name []		= "XF1";
static const char szXF3F2Name []	= "XF3F2";
static const char szXV1Name []		= "XV1";
static const char szXT1Name []		= "XT1";
static const char szXT2Name []		= "XT2";


HANDLE *g_phEventHandles = NULL;

typedef enum
    {
    eHandleControlC = 0,
    eHandleStepToNextConfig,
    eHandleMaxHandleCount
    } EHANDLEOFFSETS;



typedef struct
    {
	PCHAR		pszDatabaseName;
	JET_DBID	idDatabase;
} CONTEXTDB, *PCONTEXTDB, **PPCONTEXTDB;

typedef struct
    {
	JET_INSTANCE	idInstance;
	JET_SESID	idSession;

	CONTEXTDB	aDatabase [MAX_DATABASE_COUNT];
} CONTEXTJET, *PCONTEXTJET, **PPCONTEXTJET;





class CVssJetWriterLocal : public CVssJetWriter
    {
public:

	virtual bool STDMETHODCALLTYPE OnThawEnd (bool fJetThawSucceeded);

	virtual void STDMETHODCALLTYPE OnAbortEnd ();

	virtual bool STDMETHODCALLTYPE OnPostRestoreEnd(IVssWriterComponents *pComponents, bool bSucceeded);
};


bool STDMETHODCALLTYPE CVssJetWriterLocal::OnThawEnd (bool fJetThawSucceeded)
    {
	UNREFERENCED_PARAMETER(fJetThawSucceeded);
	wprintf(L"OnThawEnd\n");
    SetEvent (g_phEventHandles [eHandleStepToNextConfig]);

    return (true);
    }

void STDMETHODCALLTYPE CVssJetWriterLocal::OnAbortEnd ()
    {
	wprintf(L"OnAbortEnd\n");
    SetEvent (g_phEventHandles [eHandleStepToNextConfig]);
    }

// This function displays the formatted message at the console and throws
void Error(
    IN  INT nReturnCode,
    IN  const WCHAR* pwszMsgFormat,
    IN  ...
    )
	{
    va_list marker;
    va_start( marker, pwszMsgFormat );
    vwprintf( pwszMsgFormat, marker );
    va_end( marker );

	BS_ASSERT(FALSE);
    // throw that return code.
    throw(nReturnCode);
	}

// Convert a component type into a string
LPCWSTR GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eComponentType)
	{
	case VSS_CT_DATABASE:  pwszRetString = L"Database";  break;
	case VSS_CT_FILEGROUP: pwszRetString = L"FileGroup"; break;

	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a failure type into a string
LPCWSTR GetStringFromFailureType(HRESULT hrStatus)
{
    LPCWSTR pwszFailureType = L"";

    switch (hrStatus)
	{
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:        pwszFailureType = L"VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT";    break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:              pwszFailureType = L"VSS_E_WRITERERROR_OUTOFRESOURCES";          break;
	case VSS_E_WRITERERROR_TIMEOUT:                     pwszFailureType = L"VSS_E_WRITERERROR_TIMEOUT";                 break;
	case VSS_E_WRITERERROR_NONRETRYABLE:                pwszFailureType = L"VSS_E_WRITERERROR_NONRETRYABLE";            break;
	case VSS_E_WRITERERROR_RETRYABLE:                   pwszFailureType = L"VSS_E_WRITERERROR_RETRYABLE";               break;
	case VSS_E_BAD_STATE:                               pwszFailureType = L"VSS_E_BAD_STATE";                           break;
	case VSS_E_PROVIDER_ALREADY_REGISTERED:             pwszFailureType = L"VSS_E_PROVIDER_ALREADY_REGISTERED";         break;
	case VSS_E_PROVIDER_NOT_REGISTERED:                 pwszFailureType = L"VSS_E_PROVIDER_NOT_REGISTERED";             break;
	case VSS_E_PROVIDER_VETO:                           pwszFailureType = L"VSS_E_PROVIDER_VETO";                       break;
	case VSS_E_PROVIDER_IN_USE:				            pwszFailureType = L"VSS_E_PROVIDER_IN_USE";                     break;
	case VSS_E_OBJECT_NOT_FOUND:						pwszFailureType = L"VSS_E_OBJECT_NOT_FOUND";                    break;						
	case VSS_S_ASYNC_PENDING:							pwszFailureType = L"VSS_S_ASYNC_PENDING";                       break;
	case VSS_S_ASYNC_FINISHED:						    pwszFailureType = L"VSS_S_ASYNC_FINISHED";                      break;
	case VSS_S_ASYNC_CANCELLED:						    pwszFailureType = L"VSS_S_ASYNC_CANCELLED";                     break;
	case VSS_E_VOLUME_NOT_SUPPORTED:					pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED";                break;
	case VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER:		pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER";    break;
	case VSS_E_OBJECT_ALREADY_EXISTS:					pwszFailureType = L"VSS_E_OBJECT_ALREADY_EXISTS";               break;
	case VSS_E_UNEXPECTED_PROVIDER_ERROR:				pwszFailureType = L"VSS_E_UNEXPECTED_PROVIDER_ERROR";           break;
	case VSS_E_CORRUPT_XML_DOCUMENT:				    pwszFailureType = L"VSS_E_CORRUPT_XML_DOCUMENT";                break;
	case VSS_E_INVALID_XML_DOCUMENT:					pwszFailureType = L"VSS_E_INVALID_XML_DOCUMENT";                break;
	case VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED:       pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED";   break;
	case VSS_E_FLUSH_WRITES_TIMEOUT:                    pwszFailureType = L"VSS_E_FLUSH_WRITES_TIMEOUT";                break;
	case VSS_E_HOLD_WRITES_TIMEOUT:                     pwszFailureType = L"VSS_E_HOLD_WRITES_TIMEOUT";                 break;
	case VSS_E_UNEXPECTED_WRITER_ERROR:                 pwszFailureType = L"VSS_E_UNEXPECTED_WRITER_ERROR";             break;
	case VSS_E_SNAPSHOT_SET_IN_PROGRESS:                pwszFailureType = L"VSS_E_SNAPSHOT_SET_IN_PROGRESS";            break;
	case VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED:     pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED"; break;
	case VSS_E_WRITER_INFRASTRUCTURE:	 		        pwszFailureType = L"VSS_E_WRITER_INFRASTRUCTURE";               break;
	case VSS_E_WRITER_NOT_RESPONDING:			        pwszFailureType = L"VSS_E_WRITER_NOT_RESPONDING";               break;
    case VSS_E_WRITER_ALREADY_SUBSCRIBED:		        pwszFailureType = L"VSS_E_WRITER_ALREADY_SUBSCRIBED";           break;
	
	case NOERROR:
	default:
	    break;
	}

    return (pwszFailureType);
}



// Execute the given call and check that the return code must be S_OK
#define CHECK_SUCCESS( Call )                                                                           \
    {                                                                                                   \
        hr = Call;                                                                                    \
		if (hr != S_OK)                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }


#define CHECK_NOFAIL( Call )                                                                            \
    {                                                                                                   \
        hr = Call;                                                                                    \
        if (FAILED(hr))                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }


bool STDMETHODCALLTYPE CVssJetWriterLocal::OnPostRestoreEnd(IVssWriterComponents *pWriter, bool bRestoreSucceeded)
	{
	wprintf(L"Restore invoked.\n");
	if (bRestoreSucceeded)
		wprintf(L"Restore succeeded.\n");
	else
		wprintf(L"Restore failed.");

	try
		{
		HRESULT hr;

		unsigned cComponents;
		CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
		VSS_ID idWriter, idInstance;
		CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));
		for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
			{
			CComPtr<IVssComponent> pComponent;
			CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
				
			VSS_COMPONENT_TYPE ct;
			CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;

			CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
			CHECK_SUCCESS(pComponent->GetComponentType(&ct));
			CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
			wprintf(L"COMPONENT path = %s, type=%s, name=%s\n", bstrLogicalPath, GetStringFromComponentType(ct), bstrComponentName);
			}
		}
	catch(...)
		{
		wprintf(L"***Unexpected exception thrown.***\n");
		}

	return true;
	}


#define DO_CALL(xCall) \
    { \
	JET_ERR jetStatus = xCall; \
    if (jetStatus < JET_errSuccess) \
		Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n" \
			  L"\t  Error code = 0x%08lx.\n", \
			  __FILE__, __LINE__, #xCall, jetStatus); \
	 }


BOOL WINAPI Ctrl_C_Handler_Routine(IN DWORD type)
    {
    UNREFERENCED_PARAMETER(type);

    if (g_phEventHandles [eHandleControlC])
	{
	SetEvent (g_phEventHandles [eHandleControlC]);
	}

    return TRUE;
    }







JET_ERR CreateAndPopulateDatabase (JET_SESID	idSession,
				   const char	*szDatabase,
				   JET_DBID *pidDatabase)
    {
    JET_DBID		idDatabase;
    JET_TABLEID		idTable;
    JET_COLUMNDEF	columndef;
    JET_COLUMNID	idColumnF1;
    JET_COLUMNID	idColumnF2;
    JET_COLUMNID	idColumnF3;
    JET_COLUMNID	idColumnV1;
    JET_COLUMNID	idColumnT1;
    JET_COLUMNID	idColumnT2;

    const unsigned short	usCodePage = 1252;
    const unsigned short	usLanguage = 0x409;
    const long			lOne       = 1;


    DO_CALL (JetCreateDatabase (idSession, szDatabase, NULL, &idDatabase, 0));
    DO_CALL (JetCloseDatabase  (idSession, idDatabase, 0));

    /*
    **	check multiple opens of same database
    */
    DO_CALL (JetOpenDatabase (idSession, szDatabase, NULL, &idDatabase, 0));


    DO_CALL (JetBeginTransaction (idSession));

    DO_CALL (JetCreateTable      (idSession, idDatabase, szTable1, 0, 100, &idTable));
    DO_CALL (JetCloseTable       (idSession, idTable));


    DO_CALL (JetOpenTable        (idSession, idDatabase, szTable1, NULL, 0, JET_bitTableDenyRead, &idTable));


    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypLong;
    columndef.cbMax    = 0;
    columndef.grbit    = 0;

    DO_CALL (JetAddColumn (idSession, idTable, szF1Name, &columndef, &lOne, sizeof(lOne), &idColumnF1));



    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypUnsignedByte;
    columndef.cbMax    = 0;
    columndef.grbit    = 0;

    DO_CALL (JetAddColumn (idSession, idTable, szF2Name, &columndef, NULL, 0, &idColumnF2));



    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypLong;
    columndef.cbMax    = 0;
    columndef.grbit    = 0;

    DO_CALL (JetAddColumn (idSession, idTable, szF3Name, &columndef, NULL, 0, &idColumnF3));



    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypText;
    columndef.cbMax    = 0;
    columndef.grbit    = 0;

    DO_CALL (JetAddColumn (idSession, idTable, szV1Name, &columndef, NULL, 0, &idColumnV1));



    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypLongText;
    columndef.cbMax    = 0;
    columndef.grbit    = JET_bitColumnTagged | JET_bitColumnMultiValued;

    DO_CALL (JetAddColumn (idSession, idTable, szT1Name, &columndef, NULL, 0, &idColumnT1));



    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypBinary;
    columndef.cbMax    = 0;
    columndef.grbit    = JET_bitColumnTagged | JET_bitColumnMultiValued;

    DO_CALL (JetAddColumn (idSession, idTable, szT2Name, &columndef, NULL, 0, &idColumnT2));


    {
    char		rgbCols[50];
    sprintf( rgbCols, "+%s", szF1Name);

    rgbCols[ 1 + strlen(szF1Name) + 1] = '\0';
    *(unsigned short *)(&rgbCols[ 1 + strlen(szF1Name) + 1 + 1]) = usLanguage;
    rgbCols[ 1 + strlen(szF1Name) + 1 + 1 + sizeof(usLanguage) ]    = '\0';
    rgbCols[ 1 + strlen(szF1Name) + 1 + 1 + sizeof(usLanguage) + 1] = '\0';

    DO_CALL (JetCreateIndex (idSession,
			  idTable,
			  szXF1Name,
			  JET_bitIndexPrimary | JET_bitIndexUnique,
			  rgbCols,
			  1 + strlen( szF1Name) + 1 + 1 + sizeof(usLanguage) + 1 + 1,
			  100));
    }

    DO_CALL (JetCloseTable (idSession, idTable));
    DO_CALL (JetCommitTransaction (idSession, 0));

	*pidDatabase = idDatabase;


    return (JET_errSuccess);
    }


void DatabaseSetup (PCONTEXTJET pctxJet, ULONG ulDatabaseCount)
    {
    JET_ERR		jetStatus;


    DO_CALL (JetBeginSession (pctxJet->idInstance, &pctxJet->idSession, szUser, szPassword));


    while (ulDatabaseCount-- > 0)
	{
	jetStatus = JetAttachDatabase (pctxJet->idSession,
				       pctxJet->aDatabase [ulDatabaseCount].pszDatabaseName,
				       0);


	if (jetStatus >= JET_errSuccess)
	    {
	    DO_CALL (JetOpenDatabase (pctxJet->idSession,
				   pctxJet->aDatabase [ulDatabaseCount].pszDatabaseName,
				   NULL,
				   &pctxJet->aDatabase [ulDatabaseCount].idDatabase,
				   0));
	    }
	else
	    {
	    DO_CALL (CreateAndPopulateDatabase (pctxJet->idSession,
					     pctxJet->aDatabase [ulDatabaseCount].pszDatabaseName,
						 &pctxJet->aDatabase [ulDatabaseCount].idDatabase));
	    }

	}
    }


void DatabaseCleanup (PCONTEXTJET pctxJet, ULONG ulDatabaseCount)
    {
    while (ulDatabaseCount-- > 0)
	{
	DO_CALL (JetCloseDatabase (pctxJet->idSession,
				pctxJet->aDatabase [ulDatabaseCount].idDatabase,
				0));


	DO_CALL (JetDetachDatabase (pctxJet->idSession,
				 pctxJet->aDatabase [ulDatabaseCount].pszDatabaseName));
	}


    DO_CALL (JetEndSession (pctxJet->idSession, 0));
    }




extern "C" int _cdecl wmain(int argc, WCHAR **argv)
    {
	UNREFERENCED_PARAMETER(argc);
	UNREFERENCED_PARAMETER(argv);

    HRESULT		hrStatus        = NOERROR;
    DWORD		dwStatus        = 0;
    GUID		idWriter        = GUID_NULL;
    CVssJetWriter	*pWriter        = NULL;
    bool		bContinue       = true;
    BOOL		bSucceeded      = FALSE;
    ULONG		ulDatabaseCount = 3;
    ULONG		ulIndex;
    HANDLE		hEventHandles [eHandleMaxHandleCount];
    CONTEXTJET		ctxJet;
	WCHAR		wszBufferName [MAX_PATH + 1];
    DWORD		dwCharCount;



    dwCharCount = ExpandEnvironmentStringsW (DATABASE_ROOT, wszBufferName, sizeof (wszBufferName));

    hrStatus = GET_STATUS_FROM_BOOL (0 != dwCharCount);

    if (FAILED (hrStatus))
	{
	wprintf (L"ExpandEnvironmentStringsW (%s) FAILED with error code %08x\n",
		 DATABASE_ROOT,
		 hrStatus);
	}


    bSucceeded = CreateDirectoryW (wszBufferName, NULL);

    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

    if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_ALREADY_EXISTS) != hrStatus))
	{
	wprintf (L"CreateDirectoryW (%s) FAILED with error code %08x\n",
		 wszBufferName,
		 hrStatus);
	}




    dwCharCount = ExpandEnvironmentStringsW (DATABASE_ROOT INCLUDED_DATABASES, wszBufferName, sizeof (wszBufferName));

    hrStatus = GET_STATUS_FROM_BOOL (0 != dwCharCount);

    if (FAILED (hrStatus))
	{
	wprintf (L"ExpandEnvironmentStringsW (%s) FAILED with error code %08x\n",
		 DATABASE_ROOT INCLUDED_DATABASES,
		 hrStatus);
	}


    bSucceeded = CreateDirectoryW (wszBufferName, NULL);

    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

    if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_ALREADY_EXISTS) != hrStatus))
	{
	wprintf (L"CreateDirectoryW (%s) FAILED with error code %08x\n",
		 wszBufferName,
		 hrStatus);
	}




    dwCharCount = ExpandEnvironmentStringsW (DATABASE_ROOT EXCLUDED_DATABASES, wszBufferName, sizeof (wszBufferName));

    hrStatus = GET_STATUS_FROM_BOOL (0 != dwCharCount);

    if (FAILED (hrStatus))
	{
	wprintf (L"ExpandEnvironmentStringsW (%s) FAILED with error code %08x\n",
		 DATABASE_ROOT EXCLUDED_DATABASES,
		 hrStatus);
	}


    bSucceeded = CreateDirectoryW (wszBufferName, NULL);

    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

    if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_ALREADY_EXISTS) != hrStatus))
	{
	wprintf (L"CreateDirectoryW (%s) FAILED with error code %08x\n",
		 wszBufferName,
		 hrStatus);
	}




    hrStatus = NOERROR;



    /*
    ** Initialise the database contexts
    */
    ctxJet.idInstance = 0;
    ctxJet.idSession  = 0;

    for (ulIndex = 0; ulIndex < MAX_DATABASE_COUNT; ulIndex++)
	{
	dwCharCount = ExpandEnvironmentStringsA (achDatabaseNames [ulIndex],
						 achExpandedDatabaseNames [ulIndex],
						 sizeof (achExpandedDatabaseNames [ulIndex]));

	ctxJet.aDatabase [ulIndex].idDatabase      = 0;
	ctxJet.aDatabase [ulIndex].pszDatabaseName = achExpandedDatabaseNames [ulIndex];
	}



    /*
    ** Initialise the event handles array
    */
    for (ulIndex = 0; ulIndex < eHandleMaxHandleCount; ulIndex++)
	{
	if (SUCCEEDED (hrStatus))
	    {
	    hEventHandles [ulIndex] = CreateEvent (NULL, FALSE, FALSE, NULL);

	    hrStatus = GET_STATUS_FROM_HANDLE (hEventHandles [ulIndex] );

	    if (NULL == hEventHandles [ulIndex])
		{
		wprintf (L"CreateEvent %u failed with error code %08X\n", ulIndex, hrStatus);
		}
	    }
	}



    /*
    ** Hook up the console GetOutOfJail device
    */
    if (SUCCEEDED (hrStatus))
	{
	g_phEventHandles = hEventHandles;

	::SetConsoleCtrlHandler (Ctrl_C_Handler_Routine, TRUE);
	}



    /*
    ** Tally-ho chaps!
    */
    try
	{
	DO_CALL (JetInit(&ctxJet.idInstance));

	hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	if (FAILED (hrStatus))
	    {
	    wprintf (L"CoInitializeEx failed with error code %08x\n", hrStatus);
	    }


    hrStatus = CoInitializeSecurity
			(
			NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
			-1,                                  //  IN LONG                         cAuthSvc,
			NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
			NULL,                                //  IN void                        *pReserved1,
			RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
			RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
			NULL,                                //  IN void                        *pAuthList,
			EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
			NULL                                 //  IN void                        *pReserved3
			);


	if (FAILED (hrStatus))
	    {
	    wprintf (L"CoInitializeSecurity failed with error code %08x\n", hrStatus);
	    }

	if (SUCCEEDED (hrStatus))
	    {
	    pWriter = new CVssJetWriterLocal;

	    if (NULL == pWriter)
		{
		wprintf (L"new CVssJetWriter failed");

		hrStatus = HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY);
		}
	    }



	if (SUCCEEDED (hrStatus))
	    {
	    hrStatus = pWriter->Initialize (idWriter,		// id of writer
					    L"JetTest Writer",	// name of writer
					    true,		// system service
					    false,		// bootable state
					    FilesToInclude,	// files to include
					    FilesToExclude);	// files to exclude

	    if (FAILED (hrStatus))
		{
		wprintf (L"CVssJetWriter::Initialize failed with error code %08x\n", hrStatus);
		}
	    }




	while (SUCCEEDED (hrStatus) && bContinue)
	    {
	    DatabaseSetup (&ctxJet, ulDatabaseCount);


	    dwStatus = WaitForMultipleObjects (eHandleMaxHandleCount, hEventHandles, FALSE, INFINITE);


	    DatabaseCleanup (&ctxJet, ulDatabaseCount);

	    switch (dwStatus - WAIT_OBJECT_0)
		{
		case (eHandleControlC):
		    bContinue = FALSE;
		    break;


		case (eHandleStepToNextConfig):
		    ulDatabaseCount = (ulDatabaseCount + 1) % (MAX_DATABASE_COUNT + 1);
		    break;


		default:
		    BS_ASSERT (0);
		    break;
		}
	    }
	}



    catch(...)
	{
	wprintf(L"unexpected exception\n");
	exit(-1);
	}



    for (ulIndex = 0; ulIndex < eHandleMaxHandleCount; ulIndex++)
	{
	if (NULL != hEventHandles [ulIndex])
	    {
	    CloseHandle (hEventHandles [ulIndex]);

	    hEventHandles [ulIndex] = NULL;
	    }
	}



    if (NULL != pWriter)
	{
	pWriter->Uninitialize();
	delete pWriter;
	pWriter = NULL;
	}


    DO_CALL (JetTerm (ctxJet.idInstance));


    return (hrStatus);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\shimtest\shimtest.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    client.cpp

Abstract:

    Test program to drive the VSS Writer Shim contained in VssAPI.DLL

Author:

    Stefan R. Steiner   [ssteiner]        01-30-2000

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
//  Defines

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes

#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdio.h>
#include <objbase.h>

#include <vss.h>

typedef HRESULT ( APIENTRY *PFUNC_RegisterSnapshotSubscriptions )( void );
typedef HRESULT ( APIENTRY *PFUNC_UnregisterSnapshotSubscriptions )( void );
typedef HRESULT ( APIENTRY *PFUNC_SimulateSnapshotFreeze )( PWCHAR pwszSnapshotSetId, PWCHAR pwszVolumeNamesList );
typedef HRESULT ( APIENTRY *PFUNC_SimulateSnapshotThaw )( PWCHAR pwszSnapshotSetId );



static BOOL AssertPrivilege( LPCWSTR privName );

/////////////////////////////////////////////////////////////////////////////
//  WinMain

extern "C" int __cdecl wmain( int argc, WCHAR *argv[] )
{
    HINSTANCE hInstLib;
    PFUNC_RegisterSnapshotSubscriptions pFnRegisterSS;
    PFUNC_UnregisterSnapshotSubscriptions pFnUnregisterSS;
    HRESULT hr;

    if ( !AssertPrivilege( SE_BACKUP_NAME ) )
    {
        wprintf( L"AssertPrivilege returned error, rc:%d\n", GetLastError() );
        return 2;
    }

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( FAILED( hr ) )
    {
        wprintf( L"CoInitialize() returned rc:%d\n", GetLastError() );
        return 1;
    }

    //  Get a handle to the DLL module
    hInstLib = LoadLibrary( L"VssAPI.dll" );

    if ( hInstLib != NULL )
    {
        pFnRegisterSS = ( PFUNC_RegisterSnapshotSubscriptions )GetProcAddress( hInstLib, "RegisterSnapshotSubscriptions" );
        if ( pFnRegisterSS != NULL )
            wprintf( L"pFnRegisterSS returned: 0x%08x\n", ( pFnRegisterSS )() );
        else
            wprintf( L"Couldn't import RegisterSnapshotSubscriptions function, rc:%d\n", GetLastError() );

        wprintf( L"\nPress return to continue...\n" );
        getchar();
        wprintf( L"continuing...\n" );

        pFnUnregisterSS = ( PFUNC_UnregisterSnapshotSubscriptions )GetProcAddress( hInstLib, "UnregisterSnapshotSubscriptions" );
        if ( pFnUnregisterSS != NULL )
            wprintf( L"pFnUnregisterSS returned: 0x%08x\n", ( pFnUnregisterSS )() );
        else
            wprintf( L"Couldn't import UnregisterSnapshotSubscriptions function, rc:%d\n", GetLastError() );

        FreeLibrary( hInstLib );
    }
    else
        printf( "LoadLibrary error, rc:%d\n", GetLastError() );


    // Uninitialize COM library
    CoUninitialize();

    return 0;

    UNREFERENCED_PARAMETER( argv );
    UNREFERENCED_PARAMETER( argc );
}


static BOOL AssertPrivilege( LPCWSTR privName )
{
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if ( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &tokenHandle ) )
    {
        LUID value;

        if ( LookupPrivilegeValue( NULL, privName, &value ) )
        {
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            /*
            * We will always call GetLastError below, so clear
            * any prior error values on this thread.
            */
            SetLastError( ERROR_SUCCESS );

            stat =  AdjustTokenPrivileges(
                tokenHandle,
                FALSE,
                &newState,
                (DWORD)0,
                NULL,
                NULL );
            /*
            * Supposedly, AdjustTokenPriveleges always returns TRUE
            * (even when it fails). So, call GetLastError to be
            * extra sure everything's cool.
            */
            if ( (error = GetLastError()) != ERROR_SUCCESS )
            {
                stat = FALSE;
            }

            if ( !stat )
            {
                wprintf( L"AdjustTokenPrivileges for %s failed with %d",
                    privName,
                    error );
            }
        }
        CloseHandle( tokenHandle );
    }
    return stat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\mptest\writer\debug.h ===
inline void CHECK_SUCCESS(HRESULT hr)
	{
	if (hr != S_OK)
		{
		wprintf(L"operation failed with HRESULT=%08x\n", hr);
		DebugBreak();
		}
	}

inline void CHECK_NOFAIL(HRESULT hr)
	{
	if (FAILED(hr))
		{
		wprintf(L"operation failed with HRESULT=%08x\n", hr);
		DebugBreak();
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\mptest\writer\cwriter.cpp ===
#include "stdafx.hxx"
#include "vss.h"
#include "vswriter.h"
#include "cwriter.h"
#include "debug.h"
#include "time.h"
#include "msxml.h"

#define IID_PPV_ARG( Type, Expr ) IID_##Type, reinterpret_cast< void** >( static_cast< Type** >( Expr ) )
#define SafeQI( Type, Expr ) QueryInterface( IID_PPV_ARG( Type, Expr ) )

static BYTE x_rgbIcon[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
static unsigned x_cbIcon = 10;


static VSS_ID s_WRITERID =
	{
	0xc0577ae6, 0xd741, 0x452a,
	0x8c, 0xba, 0x99, 0xd7, 0x44, 0x00, 0x8c, 0x05
	};

static LPCWSTR s_WRITERNAME = L"MP Test Writer";

void CTestVssWriter::Initialize()
	{
	CHECK_SUCCESS(CVssWriter::Initialize
					(
					s_WRITERID,
					s_WRITERNAME,
					VSS_UT_USERDATA,
					VSS_ST_OTHER
					));
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
	{
	CHECK_SUCCESS(pMetadata->AddIncludeFiles
					(
					L"%systemroot%\\config",
					L"mytestfiles.*",
					false,
					NULL
					));

    CHECK_SUCCESS(pMetadata->AddExcludeFiles
						(
						L"%systemroot%\\config",
						L"*.tmp",
						true
						));

    CHECK_SUCCESS(pMetadata->AddComponent
						(
						VSS_CT_DATABASE,
						L"\\mydatabases",
						L"db1",
						L"this is my main database",
						x_rgbIcon,
						x_cbIcon,
						true,
						true,
						true
						));

    CHECK_SUCCESS(pMetadata->AddDatabaseFiles
					(
					L"\\mydatabases",
					L"db1",
					L"e:\\databases",
					L"foo.db"
					));

    CHECK_SUCCESS(pMetadata->AddDatabaseLogFiles
					(
					L"\\mydatabases",
					L"db1",
					L"e:\\logs",
					L"foo.log"
					));

    CHECK_SUCCESS(pMetadata->SetRestoreMethod
					(
					VSS_RME_RESTORE_TO_ALTERNATE_LOCATION,
					NULL,
					NULL,
					VSS_WRE_ALWAYS,
					true
					));

    CHECK_SUCCESS(pMetadata->AddAlternateLocationMapping
					(
					L"c:\\databases",
					L"*.db",
					false,
					L"e:\\databases\\restore"
					));

    CHECK_SUCCESS(pMetadata->AddAlternateLocationMapping
					(
					L"d:\\logs",
					L"*.log",
					false,
					L"e:\\databases\\restore"
					));


	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPrepareBackup(IN IVssWriterComponents *pWriterComponents)
	{
	unsigned cComponents;
	LPCWSTR wszBackupType;
	switch(GetBackupType())
		{
		default:
			wszBackupType = L"undefined";
			break;

		case VSS_BT_FULL:
			wszBackupType = L"full";
			break;

        case VSS_BT_INCREMENTAL:
			wszBackupType = L"incremental";
			break;

        case VSS_BT_DIFFERENTIAL:
			wszBackupType = L"differential";
			break;

        case VSS_BT_OTHER:
			wszBackupType = L"other";
			break;
		}

	wprintf(L"\n\n****WRITER*****\nBackup Type = %s\n", wszBackupType);

	wprintf
		(
		L"AreComponentsSelected = %s\n",
		AreComponentsSelected() ? L"yes" : L"no"
		);

	wprintf
		(
		L"BootableSystemStateBackup = %s\n\n",
		IsBootableSystemStateBackedUp() ? L"yes" : L"no"
		);

	if (pWriterComponents)
		{
		pWriterComponents->GetComponentCount(&cComponents);
		for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
			{
			CComPtr<IVssComponent> pComponent;
			VSS_COMPONENT_TYPE ct;
			CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;


			CHECK_SUCCESS(pWriterComponents->GetComponent(iComponent, &pComponent));
			CHECK_SUCCESS(pComponent->GetLogicalPath(&bstrLogicalPath));
			CHECK_SUCCESS(pComponent->GetComponentType(&ct));
			CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
			if (ct != VSS_CT_DATABASE)
				{
				wprintf(L"component type is incorrect\n");
				DebugBreak();
				}

			wprintf
				(
				L"Backing up database %s\\%s.\n",
				bstrLogicalPath,
				bstrComponentName
				);

            WCHAR buf[100];

			swprintf (buf, L"backupTime = %d", (INT) time(NULL));

			CHECK_SUCCESS(pComponent->SetBackupMetadata(buf));
			wprintf(L"%s\n", buf);
			}
		}

	wprintf(L"\n******END WRITER******\n\n");
	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPrepareSnapshot()
	{
	wprintf(L"OnPrepareSnapshot\n");
	return true;
	}


bool STDMETHODCALLTYPE CTestVssWriter::OnFreeze()
	{
	wprintf(L"OnFreeze\n");
	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnThaw()
	{
	wprintf(L"OnThaw\n");
	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnBackupComplete(IN IVssWriterComponents *pWriterComponents)
	{
	unsigned cComponents;
	if (pWriterComponents == NULL)
		return true;

	pWriterComponents->GetComponentCount(&cComponents);
	for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
		CComPtr<IVssComponent> pComponent;
		VSS_COMPONENT_TYPE ct;
		CComBSTR bstrLogicalPath;
		CComBSTR bstrComponentName;
		bool bBackupSucceeded;

		CHECK_SUCCESS(pWriterComponents->GetComponent(iComponent, &pComponent));
		CHECK_SUCCESS(pComponent->GetLogicalPath(&bstrLogicalPath));
		CHECK_SUCCESS(pComponent->GetComponentType(&ct));
		CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
		CHECK_SUCCESS(pComponent->GetBackupSucceeded(&bBackupSucceeded));
		if (ct != VSS_CT_DATABASE)
			{
			wprintf(L"component type is incorrect\n");
			DebugBreak();
			}

		wprintf
			(
			L"Database %s\\%s backup %s.\n",
			bstrLogicalPath,
			bstrComponentName,
			bBackupSucceeded ? L"succeeded" : L"failed"
			);

        CComBSTR bstrMetadata;
		CHECK_SUCCESS(pComponent->GetBackupMetadata(&bstrMetadata));
		wprintf(L"%s\n", bstrMetadata);
		}

	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPostRestore(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);
	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnAbort()
	{
	return true;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\mptest\writer\cwriter.h ===
//
//  ATL debugging support turned on at debug version
//  BUGBUG: the ATL thunking support is not enable yet in IA64
//  When this will be enabled then enable it here also!
//
#ifdef _DEBUG
#ifdef _M_IX86
#define _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_QI
#define _ATL_DEBUG_REFCOUNT
#endif
#endif // _DEBUG

class CTestVssWriter : public CVssWriter
	{
public:
	void Initialize();

	virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

	virtual bool STDMETHODCALLTYPE OnPrepareBackup(IN IVssWriterComponents *pComponent);

	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

	virtual bool STDMETHODCALLTYPE OnFreeze();

	virtual bool STDMETHODCALLTYPE OnThaw();

	virtual bool STDMETHODCALLTYPE OnAbort();

	virtual bool STDMETHODCALLTYPE OnBackupComplete(IN IVssWriterComponents *pComponent);

	virtual bool STDMETHODCALLTYPE OnPostRestore(IN IVssWriterComponents *pComponent);
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\sqltest\main.cpp ===
// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes

#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>
#include <stdio.h>


#include "vss.h"
#include "vswriter.h"
#include "sqlsnap.h"
#include "sqlwriter.h"

DWORD g_dwMainThreadId;

/////////////////////////////////////////////////////////////////////////////
//  Control-C handler routine


BOOL WINAPI CtrlC_HandlerRoutine(
	IN DWORD /* dwType */
	)
	{
	// End the message loop
	if (g_dwMainThreadId != 0)
		PostThreadMessage(g_dwMainThreadId, WM_QUIT, 0, 0);

	// Mark that the break was handled.
	return TRUE;
	}

CVssSqlWriterWrapper g_Wrapper;

extern "C" int __cdecl wmain(HINSTANCE /*hInstance*/,
    HINSTANCE /*hPrevInstance*/, LPTSTR /*lpCmdLine*/, int /*nShowCmd*/)
	{
	int nRet = 0;

    try
		{
    	// Preparing the CTRL-C handling routine - only for testing...
		g_dwMainThreadId = GetCurrentThreadId();
		::SetConsoleCtrlHandler(CtrlC_HandlerRoutine, TRUE);

        // Initialize COM library
        HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if (FAILED(hr))
			throw hr;

		// Declare a CVssTSubWriter instance
		hr = g_Wrapper.CreateSqlWriter();
		if (FAILED(hr))
			throw hr;

        // message loop - need for STA server
        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

		// Subscribe the object.
		g_Wrapper.DestroySqlWriter();

        // Uninitialize COM library
        CoUninitialize();
		}
	catch(...)
		{
		}

    return nRet;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\mptest\writer\main.cpp ===
#include "stdafx.hxx"
#include "vss.h"
#include "vswriter.h"
#include <debug.h>
#include <cwriter.h>

CComModule _Module;

HANDLE g_hEvent = NULL;


BOOL WINAPI CtrlCHandler(DWORD type)
	{
	wprintf(L"Control handler called.\n");
	if (g_hEvent)
        SetEvent(g_hEvent);

	return TRUE;
	}


BOOL AssertPrivilege( LPCWSTR privName )
    {
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if ( OpenProcessToken (GetCurrentProcess(),
			   TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,
			   &tokenHandle))
	{
	LUID value;

	if ( LookupPrivilegeValue( NULL, privName, &value ) )
	    {
	    TOKEN_PRIVILEGES newState;
	    DWORD            error;

	    newState.PrivilegeCount           = 1;
	    newState.Privileges[0].Luid       = value;
	    newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED;

	    /*
	     * We will always call GetLastError below, so clear
	     * any prior error values on this thread.
	     */
	    SetLastError( ERROR_SUCCESS );

	    stat = AdjustTokenPrivileges (tokenHandle,
					  FALSE,
					  &newState,
					  (DWORD)0,
					  NULL,
					  NULL );

	    /*
	     * Supposedly, AdjustTokenPriveleges always returns TRUE
	     * (even when it fails). So, call GetLastError to be
	     * extra sure everything's cool.
	     */
	    if ( (error = GetLastError()) != ERROR_SUCCESS )
		{
		stat = FALSE;
		}

	    if ( !stat )
		{
		wprintf( L"AdjustTokenPrivileges for %s failed with %d",
			 privName,
			 error );
		}
	    }

	DWORD cbTokens;
	GetTokenInformation (tokenHandle,
			     TokenPrivileges,
			     NULL,
			     0,
			     &cbTokens);

	TOKEN_PRIVILEGES *pTokens = (TOKEN_PRIVILEGES *) new BYTE[cbTokens];
	GetTokenInformation (tokenHandle,
			     TokenPrivileges,
			     pTokens,
			     cbTokens,
			     &cbTokens);

	delete pTokens;
	CloseHandle( tokenHandle );
	}


    return stat;
    }



extern "C" __cdecl wmain(int argc, WCHAR **argv)
	{
	CTestVssWriter *pInstance;
	bool bCreated = false;
	bool bSubscribed = false;
	HRESULT hr = S_OK;
	SetConsoleCtrlHandler(CtrlCHandler, TRUE);
	BS_ASSERT(FALSE);
			
	try
		{
        CHECK_SUCCESS(CoInitializeEx(NULL, COINIT_MULTITHREADED));

	    if ( !AssertPrivilege( SE_BACKUP_NAME ) )
	        {
	        wprintf( L"AssertPrivilege returned error, rc:%d\n", GetLastError() );
	        return 2;
	        }


        CHECK_SUCCESS
		(
		CoInitializeSecurity
			(
			NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
			-1,                                  //  IN LONG                         cAuthSvc,
			NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
			NULL,                                //  IN void                        *pReserved1,
			RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
			RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
			NULL,                                //  IN void                        *pAuthList,
			EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
			NULL                                 //  IN void                        *pReserved3
			)
		);


		pInstance = new CTestVssWriter;
		if (pInstance == NULL)
			{
			wprintf(L"allocation failure\n");
			DebugBreak();
			}

		bCreated = true;
		pInstance->Initialize();
		pInstance->Subscribe();
		bSubscribed = true;
		HANDLE hEventW = CreateEvent(NULL, TRUE, FALSE, L"TESTWRITEREVENT");
		if (hEventW == NULL)
			{
			wprintf(L"CreateEvent failed with error %d.\n", GetLastError());
			DebugBreak();
			}

		g_hEvent = hEventW;

		wprintf(L"Ready to receive events.\n");

		HANDLE hEventB = CreateEvent(NULL, TRUE, FALSE, L"TESTBACKUPEVENT");
		if (hEventB == NULL)
			{
			wprintf(L"CreateEvent failed with error %d.\n", GetLastError());
			DebugBreak();
			}

		SetEvent(hEventB);
		WaitForSingleObject(hEventW, INFINITE);
		}
	catch(...)
		{
		_ASSERTE(FALSE && "Unexpected exception");
		hr = E_UNEXPECTED;
		}

	SetConsoleCtrlHandler(CtrlCHandler, FALSE);
	if (bSubscribed)
		CHECK_SUCCESS(pInstance->Unsubscribe());

	if (bCreated)
		delete pInstance;

	if (FAILED(hr))
		wprintf(L"Failed with %08x.\n", hr);

	return(0);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\psub\psub.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module psub.h | Declaration of the permanent subscriber
    @end

Author:

    Adi Oltean  [aoltean]  08/18/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     08/18/1999  Created
    mikejohn	09/18/2000  176860: Added calling convention methods where missing

--*/


#ifndef __VSS_PSUB_WRITER_H_
#define __VSS_PSUB_WRITER_H_


#ifdef _DEBUG
#define _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_QI
#define _ATL_DEBUG_REFCOUNT
#endif // _DEBUG


/////////////////////////////////////////////////////////////////////////////
//  globals

extern GUID CLSID_PSub;


/////////////////////////////////////////////////////////////////////////////
// CVssWriter


class CVssPSubWriter :
	public CComCoClass<CVssPSubWriter, &CLSID_PSub>,
	public CVssWriter
{

// Constructors and destructors
public:
	CVssPSubWriter();

// ATL stuff
public:

	DECLARE_REGISTRY_RESOURCEID(IDR_VSS_PSUB)

// Ovverides
public:

	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

	virtual bool STDMETHODCALLTYPE OnFreeze();

	virtual bool STDMETHODCALLTYPE OnThaw();

	virtual bool STDMETHODCALLTYPE OnAbort();

};


#endif //__VSS_PSUB_WRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\psub\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by writer.rc
//
#define IDS_PROJNAME                    100
#define IDR_Writer_1                    100
#define IDR_VSS_PSUB           			101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\simsnap\simsnap.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	simsnap.cpp
**
**
** Abstract:
**
**	Test program to drive the VSS Writer Shim contained in VssAPI.DLL
**
**
** Author:
**
**	Michael C. Johnson   [mikejohn]        24-May-2000
**
**
** Revision History:
**
**	X-5	MCJ		Michael C. Johnson		15-Sep-2000
**		Add test for invalid volume array pointer, interleaved calls
**		and so on.
**
**	X-4	MCJ		Michael C. Johnson		15-Sep-2000
**		Add test for invalid bits in options parameter of call to
**		SimulateSnapshotFreeze()
**
**	X-3	MCJ		Michael C. Johnson		30-Jun-2000
**		Remove calls to RegisterSnapshotSubscriptions() and 
**		UnregisterSnapshotSubscriptions() as these are no longer 
**		required.
**
**	X-2	MCJ		Michael C. Johnson		26-May-2000
**		Add some extra tests to validate shim is properly sensitive
**		to volume name array contents.
**--
*/

/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/
#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdio.h>
#include <objbase.h>
#include <guiddef.h>

#include "vs_idl.hxx"

#include <vswriter.h>
#include <vsbackup.h>


static BOOL AssertPrivilege (LPCWSTR privName);

static HRESULT DoTest01 (VOID);
static HRESULT DoTest02 (VOID);
static HRESULT DoTest03 (VOID);
static HRESULT DoTest05 (VOID);
static HRESULT DoTest06 (VOID);
static HRESULT DoTest07 (VOID);
static HRESULT DoTest08 (VOID);
static HRESULT DoTest09 (VOID);
static HRESULT DoTest10 (VOID);
static HRESULT DoTest11 (VOID);
static HRESULT DoTest12 (VOID);
static HRESULT DoTest13 (VOID);
static HRESULT DoTest14 (VOID);




extern "C" int __cdecl wmain (int argc, char *argv[])
    {
    HRESULT	hrStatus;


    UNREFERENCED_PARAMETER (argv);
    UNREFERENCED_PARAMETER (argc);


    wprintf (L"Test for SimulateSnapshotXxxx calls (ProcessId 0x%04x)\nChecking privileges\n", 
	     GetCurrentProcessId ());


    if (!AssertPrivilege (SE_BACKUP_NAME))
	{
        wprintf (L"AssertPrivilege returned error 0x%08X\n", GetLastError ());
        return 2;
	}



    wprintf (L"Initializing COM\n");

    hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);

    if (FAILED (hrStatus))
	{
        wprintf (L"CoInitialize() returned 0x%08X\n", GetLastError ());
        return 1;
	}



    if ( argc == 1 )
    {
        hrStatus = DoTest01 ();

        hrStatus = DoTest02 ();

        hrStatus = DoTest05 ();

        hrStatus = DoTest06 ();

        hrStatus = DoTest02 ();

        hrStatus = DoTest07 ();

        hrStatus = DoTest08 ();

        hrStatus = DoTest09 ();

        hrStatus = DoTest10 ();

        hrStatus = DoTest11 ();

        hrStatus = DoTest12 ();

        hrStatus = DoTest13 ();

        hrStatus = DoTest14 ();
    }
    else
    {
        hrStatus = DoTest03();
    }


    CoUninitialize();

    return 0;
    }




static BOOL AssertPrivilege (LPCWSTR privName)
    {
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if (OpenProcessToken (GetCurrentProcess (), TOKEN_ADJUST_PRIVILEGES, &tokenHandle))
	{
        LUID value;

        if (LookupPrivilegeValue (NULL, privName, &value))
	    {
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            /*
            ** We will always call GetLastError below, so clear
            ** any prior error values on this thread.
            */
            SetLastError (ERROR_SUCCESS);

            stat = AdjustTokenPrivileges (tokenHandle,
					  FALSE,
					  &newState,
					  (DWORD)0,
					  NULL,
					  NULL);

            /*
            ** Supposedly, AdjustTokenPriveleges always returns TRUE
            ** (even when it fails). So, call GetLastError to be
            ** extra sure everything's cool.
            */
            if ((error = GetLastError()) != ERROR_SUCCESS)
		{
                stat = FALSE;
		}

            if (!stat)
		{
                wprintf (L"AdjustTokenPrivileges for %s failed with 0x%08X",
			 privName,
			 error);
		}
	    }


        CloseHandle (tokenHandle);
	}

    return stat;
    }



static HRESULT DoTest01 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = VSS_SW_BOOTABLE_STATE;
    GUID	guidSnapshotSetId;
    
    ::CoCreateGuid( &guidSnapshotSetId );
    
    IVssAsync *pIAsync = NULL;
    
    wprintf (L"\n\nTest  1 - Bootable State, Synchronous\n\n");
    wprintf (L"Simulating snapshot freeze - should work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }
    
    wprintf (L"Simulating snapshot thaw\n");
        
    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}


    return (hrStatus);
    }



static HRESULT DoTest02 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = 0;
    GUID	guidSnapshotSetId;

    ::CoCreateGuid( &guidSnapshotSetId );

    IVssAsync *pIAsync = NULL;

    wprintf (L"\n\nTest  2 - Service State, Synchronous\n\n");
    wprintf (L"Simulating snapshot freeze - should work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }
    

    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }


static HRESULT DoTest03()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = VSS_SW_BOOTABLE_STATE;
    GUID	guidSnapshotSetId;

    ::CoCreateGuid( &guidSnapshotSetId );

    IVssAsync *pIAsync = NULL;

    wprintf (L"\n\nTest  3 - Bootable State, Asynchronous\n\n");
    wprintf (L"Simulating snapshot freeze with Cancel - should work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        wprintf (L"Waiting 5 seconds and then calling Cancel\n" );
        Sleep( 5000 );
        wprintf (L"Cancelling\n" );
        pIAsync->Cancel();

        do {
                Sleep( 1000 );
                hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
                wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);
        } while ( !FAILED( hrStatus ) && hrStatusAsync == VSS_S_ASYNC_PENDING );
        
        pIAsync->Release();
        }
#if 0
    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}
#endif
    return (hrStatus);
    }



static HRESULT DoTest05 ()
    {
    HRESULT	hrStatus;
    ULONG	ulOptionFlags       = VSS_SW_BOOTABLE_STATE;
    GUID	guidSnapshotSetId;

    ::CoCreateGuid( &guidSnapshotSetId );

    IVssAsync *pIAsync = NULL;

    wprintf (L"\n\nTest  5 - Bootable State, Synchronous, no volumes\n\n");
    wprintf (L"Simulating snapshot freeze - should work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					0,
					NULL,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }
    

    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }



static HRESULT DoTest06 ()
    {
    HRESULT	hrStatus;
    ULONG	ulOptionFlags       = 0;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest  6 - Service State, Synchronous, no volumes\n\n");
    wprintf (L"Simulating snapshot freeze - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					0,
					NULL,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }
    
    
    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }




static HRESULT DoTest07 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = 0x40 | VSS_SW_BOOTABLE_STATE;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest  7 - Bootable State, Synchronous, Extra Options set\n\n");
    wprintf (L"Simulating snapshot freeze - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }
    


    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }



static HRESULT DoTest08 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = 0x40;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest  8 - Service State, Synchronous, Extra Options set\n\n");
    wprintf (L"Simulating snapshot freeze - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }
    

    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }


static HRESULT DoTest09 ()
    {
    HRESULT	hrStatus;
    ULONG	ulOptionFlags       = 0x0 | VSS_SW_BOOTABLE_STATE;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest  9 - Bootable State, Synchronous, No volume list\n\n");
    wprintf (L"Simulating snapshot freeze - should work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					0,
					NULL,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }
    

    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }


static HRESULT DoTest10 ()
    {
    HRESULT	hrStatus;
    ULONG	ulOptionFlags       = 0x0;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest 10 - Service State, Synchronous, No volume list\n\n");
    wprintf (L"Simulating snapshot freeze - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					0,
					NULL,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }
    

    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }


static HRESULT DoTest11 ()
    {
    HRESULT	hrStatus;
    ULONG	ulOptionFlags       = 0x0;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest 11 - Service State, Synchronous, One volume with bad volume list pointer\n\n");
    wprintf (L"Simulating snapshot freeze - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					01,
					NULL,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }
    

    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }


static HRESULT DoTest12 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = 0x0;
    GUID	guidSnapshotSetId1;
    GUID	guidSnapshotSetId2;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId1 );
    ::CoCreateGuid( &guidSnapshotSetId2 );

    wprintf (L"\n\nTest 12 - Service State, Synchronous, nested call\n\n");
    wprintf (L"Simulating snapshot freeze (GUID1)\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId1,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze(GUID1) returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }
    

    IVssAsync *pIAsync2 = NULL;

    wprintf (L"Simulating snapshot freeze (GUID2) - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId2,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync2);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze(GUID2) returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync2 != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync2->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync2->Wait();

        hrStatus = pIAsync2->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync2->Release();
        }
    
    wprintf (L"Simulating snapshot thaw (GUID2)\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId2);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw(GUID2) returned 0x%08X\n", hrStatus);
	}


    wprintf (L"Simulating snapshot thaw (GUID1)\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId1);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw(GUID1) returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }



static HRESULT DoTest13 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = 0x0;
    GUID	guidSnapshotSetId1;
    GUID	guidSnapshotSetId2;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId1 );
    ::CoCreateGuid( &guidSnapshotSetId2 );

    wprintf (L"\n\nTest 13 - Service State, Synchronous, nested call (reverse thaw)\n\n");
    wprintf (L"Simulating snapshot freeze (GUID1)\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId1,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze(GUID1) returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }
    

    IVssAsync *pIAsync2 = NULL;


    wprintf (L"Simulating snapshot freeze (GUID2)\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId2,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync2);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze(GUID2) returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync2 != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync2->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync2->Wait();

        hrStatus = pIAsync2->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync2->Release();
        }
    

    wprintf (L"Simulating snapshot thaw (GUID1)\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId1);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw(GUID1) returned 0x%08X\n", hrStatus);
	}


    wprintf (L"Simulating snapshot thaw (GUID2)\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId2);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw(GUID2) returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }




static HRESULT DoTest14 ()
    {
    HRESULT			 hrStatus               = NOERROR;
    HRESULT			 hrStatusAsync          = NOERROR;
    IVssBackupComponents	*pIVssBackupComponents = NULL;
    VSS_ID		     SnapshotId             = GUID_NULL;
    IVssAsync			*pIVssAsync         = NULL;
    GUID			 guidSnapshotSetId      = GUID_NULL;
    GUID			 guidSnapshotSetId2;

    ::CoCreateGuid( &guidSnapshotSetId2 );

    wprintf (L"\n\nTest 14 - Bootable State, Synchronous, during DoSnapshot\n\n");

    wprintf (L"Calling CreateVssBackupComponents ()\n");

    hrStatus = CreateVssBackupComponents (&pIVssBackupComponents);

    if (FAILED (hrStatus))
	{
	wprintf (L"CreateVssBackupComponents () returned 0x%08X\n", hrStatus);
	}



    wprintf (L"Calling InitializeForBackup ()\n");

    hrStatus = pIVssBackupComponents->InitializeForBackup ();

    if (FAILED (hrStatus))
	{
	wprintf (L"InitializeForBackup () returned 0x%08X\n", hrStatus);
	}





    wprintf (L"Calling SetBackupState ()\n");

    hrStatus = pIVssBackupComponents->SetBackupState (true, true, VSS_BT_FULL);

    if (FAILED (hrStatus))
	{
	wprintf (L"SetBackupState () returned 0x%08X\n", hrStatus);
	}



    wprintf (L"Calling GatherWriterMetadata ()\n");

    hrStatus = pIVssBackupComponents->GatherWriterMetadata (&pIVssAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"GatherWriterMetadata () returned 0x%08X\n", hrStatus);
	}


    wprintf (L"Calling Wait () (for GatherWriterMetadata() to complete)\n");

    hrStatus = pIVssAsync->Wait ();

    if (FAILED (hrStatus))
	{
	wprintf (L"Wait () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling StartSnapshotSet ()\n");

    hrStatus = pIVssBackupComponents->StartSnapshotSet (&guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"StartSnapshotSet () returned 0x%08X\n", hrStatus);
	}


        

    wprintf (L"Calling AddToSnapshotSet ()\n");

    hrStatus = pIVssBackupComponents->AddToSnapshotSet (L"E:\\",
							GUID_NULL,
							&SnapshotId);

    if (FAILED (hrStatus))
	{
	wprintf (L"AddToSnapshotSet () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling PrepareForBackup ()\n");

    hrStatus = pIVssBackupComponents->PrepareForBackup (&pIVssAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"PrepareForBackup () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling Wait () (for PrepareForBackup() to complete)\n");

    hrStatus = pIVssAsync->Wait ();

    if (FAILED (hrStatus))
	{
	wprintf (L"Wait () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling QueryStatus ()\n");

    hrStatus = pIVssAsync->QueryStatus (&hrStatusAsync, 0);

    if (FAILED (hrStatus))
	{
	wprintf (L"QueryStatus () returned 0x%08X\n", hrStatus);
	}


    

    wprintf (L"Calling DoSnapshotSet ()\n");

    hrStatus = pIVssBackupComponents->DoSnapshotSet (&pIVssAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"DoSnapshotSet () returned 0x%08X\n", hrStatus);
	}



    wprintf (L"Calling SimulateSnapshotFreeze () - should NOT work\n");

    IVssAsync *pIAsync = NULL;

    hrStatus = SimulateSnapshotFreeze (guidSnapshotSetId2,
				       VSS_SW_BOOTABLE_STATE,
				       0,
				       NULL,
  				       &pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze () returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }
    

    wprintf (L"Calling SimulateSnapshotThaw ()\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId2);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw () returned 0x%08X\n", hrStatus);
	}


    wprintf (L"Calling Wait () (for DoSnapshotSet () to complete) ()\n");

    hrStatus = pIVssAsync->Wait();

    if (FAILED (hrStatus))
	{
	wprintf (L"Wait () returned 0x%08X\n", hrStatus);
	}

    pIVssAsync->Release();
    pIVssBackupComponents->Release();
    
    return (hrStatus);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\psub\psub.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module psub.cpp | Implementation of Writer
    @end

Author:

    Adi Oltean  [aoltean]  08/18/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     08/18/1999  Created
    aoltean	09/22/1999  Making console output clearer
    mikejohn	09/19/2000  176860: Added calling convention methods where missing

--*/


/////////////////////////////////////////////////////////////////////////////
//  Defines

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes

#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>
#include <comadmin.h>

#include "vs_assert.hxx"

// ATL
#include <atlconv.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include "vs_inc.hxx"

#include "vss.h"

#include "comadmin.hxx"
#include "vsevent.h"
#include "vswriter.h"
#include "resource.h"

#include "psub.h"


/////////////////////////////////////////////////////////////////////////////
//  constants

const WCHAR g_wszPSubApplicationName[]	= L"PSub";
const MAX_BUFFER = 1024;


// {621D30C6-EC47-4b66-A91A-D3FA03472FCA}
GUID CLSID_PSub =
{ 0x621d30c6, 0xec47, 0x4b66, { 0xa9, 0x1a, 0xd3, 0xfa, 0x3, 0x47, 0x2f, 0xca } };



CVssPSubWriter::CVssPSubWriter()
	{
	Initialize
		(
		CLSID_PSub,
		L"PSUB",
		VSS_UT_USERDATA,
		VSS_ST_OTHER
		);
    }



/////////////////////////////////////////////////////////////////////////////
//  class CVssPSubWriter

bool STDMETHODCALLTYPE CVssPSubWriter::OnPrepareSnapshot()
{
	WCHAR wszBuffer[MAX_BUFFER];
	WCHAR wszBuffer2[MAX_BUFFER];
	
	swprintf( wszBuffer, L"OnPrepare\n\t#volumes = %ld\n", GetCurrentVolumeCount() );
	for(int nIndex = 0; nIndex < GetCurrentVolumeCount(); nIndex++) {
		swprintf( wszBuffer2, L"\tVolume no. %ld: %s\n", nIndex, GetCurrentVolumeArray()[nIndex]);
		wcscat( wszBuffer, wszBuffer2 );
	}

	WCHAR wszPwd[MAX_PATH];
	DWORD dwChars = GetCurrentDirectoryW( MAX_PATH, wszPwd);

	bool bPwdIsAffected = IsPathAffected( wszPwd );
	if (dwChars > 0) {
		swprintf( wszBuffer2, L"Current directory %s is affected by snapshot? %s\n\n",
			wszPwd, bPwdIsAffected? L"Yes": L"No");
		wcscat( wszBuffer, wszBuffer2 );
	}

	MessageBoxW( NULL, wszBuffer, L"Writer test", MB_OK | MB_SERVICE_NOTIFICATION );

	return true;
}


bool STDMETHODCALLTYPE CVssPSubWriter::OnFreeze()
{
	WCHAR wszBuffer[MAX_BUFFER];
	swprintf( wszBuffer, L"OnFreeze\n\tmy level = %d\n\n", GetCurrentLevel() );

	MessageBoxW( NULL, wszBuffer, L"Writer test", MB_OK | MB_SERVICE_NOTIFICATION );

	return true;
}


bool STDMETHODCALLTYPE CVssPSubWriter::OnThaw()
{
	MessageBoxW( NULL, L"OnThaw", L"Writer test", MB_OK | MB_SERVICE_NOTIFICATION );

	return true;
}


bool STDMETHODCALLTYPE CVssPSubWriter::OnAbort()
{
	MessageBoxW( NULL, L"OnAbort", L"Writer test", MB_OK | MB_SERVICE_NOTIFICATION );

	return true;
}


/////////////////////////////////////////////////////////////////////////////
//  DLL methods

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_PSub, CVssPSubWriter)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        //  Set the correct tracing context. This is an inproc DLL
        g_cDbgTrace.SetContextNum(VSS_CONTEXT_DELAYED_DLL);

        //  initialize COM module
        _Module.Init(ObjectMap, hInstance);

        //  optimization
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();

    return TRUE;    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
{
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\testprv\src\delete.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Delete.hxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Adi Oltean  [aoltean]   02/01/2000

Revision History:

    Name        Date        Comments

    aoltean     02/01/2000  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL header
#include "vss.h"
#include "vscoordint.h"
#include "vsswprv.h"
#include "vsprov.h"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"
#include "snapshot.hxx"


#include "ntddsnap.h"


/////////////////////////////////////////////////////////////////////////////
//  Implementation


STDMETHODIMP CVsTestProvider::DeleteSnapshots(
    IN      VSS_ID          SourceObjectId,
	IN      VSS_OBJECT_TYPE eSourceObjectType,
	IN		BOOL			bForceDelete,			
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
    )

/*++

Description:

	This routine deletes all snapshots that match the proper filter criteria.
	If one snapshot fails to be deleted but other snapshots were deleted
	then pNondeletedSnapshotID must ve filled. Otherwise it must be GUID_NULL.

	At first error the deletion process stops.

	If snapshot set cannot be found then S_OK is returned.

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsTestProvider::DeleteSnapshots" );

    try
    {
    	// Zero out parameters
		::VssZeroOut(plDeletedSnapshots);
		::VssZeroOut(pNondeletedSnapshotID);

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
				L"  SourceObjectId = " WSTR_GUID_FMT L"\n"
				L"  eSourceObjectType = %d\n"
				L"  bForceDelete = %d"
				L"  plDeletedSnapshots = %p"
				L"  pNondeletedSnapshotID = %p",
				GUID_PRINTF_ARG( SourceObjectId ),
				eSourceObjectType,
				bForceDelete,			
				plDeletedSnapshots,		
				pNondeletedSnapshotID
             	);

		// Check arguments
		BS_ASSERT(plDeletedSnapshots);
		if (plDeletedSnapshots == NULL)
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"plDeletedSnapshots == NULL");
		BS_ASSERT(pNondeletedSnapshotID);
		if (pNondeletedSnapshotID == NULL)
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pNondeletedSnapshotID == NULL");

		// Delete snapshots based on the given filter
		switch(eSourceObjectType) {
		case VSS_OBJECT_SNAPSHOT_SET:
			// Delete all snapshots in the snapshot set
			ft.hr = InternalDeleteSnapshotSet(SourceObjectId,
						bForceDelete,
						plDeletedSnapshots,
						pNondeletedSnapshotID);
			break;
			
		case VSS_OBJECT_SNAPSHOT:
			// Delete the snapshot
			ft.hr = InternalDeleteSnapshot(SourceObjectId,
						bForceDelete);

			// Fill the out parameters
			if (ft.HrSucceeded())
				(*plDeletedSnapshots)++;
			else
				(*pNondeletedSnapshotID) = SourceObjectId;
				
			break;
			
		case VSS_OBJECT_VOLUME:
			// Delete all snapshots on the volume
			// bForceDelete ignored.
			ft.hr = InternalDeleteSnapshotOnVolume(SourceObjectId,
						plDeletedSnapshots,
						pNondeletedSnapshotID);
			break;
			
		default:
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Incompatible type %d", eSourceObjectType);
		}
		
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// Internal methods


HRESULT CVsTestProvider::InternalDeleteSnapshotSet(
    IN      VSS_ID			SnapshotSetId,
	IN		BOOL			bForceDelete,			
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
    )

/*++

Description:

	This routine deletes all snapshots in the snapshot set.
	If one snapshot fails to be deleted but other snapshots were deleted
	then pNondeletedSnapshotID must ve filled. Otherwise it must be GUID_NULL.

	At first error the deletion process stops.

	If snapshot set cannot be found then VSS_E_OBJECT_NOT_FOUND is returned.

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsTestProvider::InternalDeleteSnapshotSet" );
	HANDLE hSearch = INVALID_HANDLE_VALUE;
	LPWSTR pwszSnapshotName = NULL;

    try
    {
		BS_ASSERT(*plDeletedSnapshots == 0);
		BS_ASSERT(*pNondeletedSnapshotID == GUID_NULL);

        // Trace
        ft.Trace( VSSDBG_SWPRV, L"SnapshotSetId = " WSTR_GUID_FMT,
					  GUID_PRINTF_ARG( SnapshotSetId ));

		// Enumerate snapshots through all the volumes
		CVssIOCTLChannel volumeIChannel;	// For enumeration of snapshots on a volume
		CVssIOCTLChannel volumeIChannel2;	// For snapshots deletion
		CVssIOCTLChannel snapshotIChannel;	// For snapshots attributes
		WCHAR wszVolumeName[MAX_PATH+1];
		bool bFirstVolume = true;
		bool bSnapshotSetFound = false;

		// Search for snapshots in all mounted volumes
		while(true) {
		
			// Get the volume name
			if (bFirstVolume) {
				hSearch = ::FindFirstVolumeW( wszVolumeName, MAX_PATH);
				if (hSearch == INVALID_HANDLE_VALUE)
					ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Error on FindFirstVolume 0x%08lx", GetLastError());
				bFirstVolume = false;
			} else {
				if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
					if (GetLastError() == ERROR_NO_MORE_FILES)
						break;	// End of iteration
					else
						ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Error on FindNextVolume 0x%08lx", GetLastError());
				}
			}

			// Eliminate the last backslash in order to open the volume
			EliminateLastBackslash(wszVolumeName);

			// Check if the snapshot(s) within this snapshot set is belonging to that volume
			// Open a IOCTL channel on that volume
			volumeIChannel.Open(ft, wszVolumeName);

			// Get the list of snapshots
			// If IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS not
			// supported then try with the next volume.

			ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, false);
			if (ft.HrFailed()) {
				ft.hr = S_OK;
				continue;
			}

			// Get the length of snapshot names multistring
			ULONG ulMultiszLen;
			volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
			// Try to find the snapshot with the corresponding Id
			DWORD dwInitialOffset = volumeIChannel.GetCurrentOutputOffset();
#endif

			bool bFirstSnapshot = true;
			while(volumeIChannel.UnpackZeroString(ft, pwszSnapshotName)) {
				// Compose the snapshot name in a user-mode style
				WCHAR wszUserModeSnapshotName[MAX_PATH];
				if (::_snwprintf(wszUserModeSnapshotName, MAX_PATH - 1,
						L"\\\\?\\GLOBALROOT%s", pwszSnapshotName) < 0)
					ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Not enough memory." );
			
				// Open that snapshot and verify if it has our ID
				snapshotIChannel.Open(ft, wszUserModeSnapshotName);

				// Get the application buffer
				snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO);

				// Get the length of the application buffer
				ULONG ulLen;
				snapshotIChannel.Unpack(ft, &ulLen);

				if (ulLen == 0) {
					ft.Warning(VSSDBG_SWPRV, L"Warning: zero-size snapshot detected: %s", pwszSnapshotName);
					continue;
				}

				// Get the snapshot Id
				VSS_ID CurrentSnapshotId;
				snapshotIChannel.Unpack(ft, &CurrentSnapshotId);

				// Get the snapshot set Id
				VSS_ID CurrentSnapshotSetId;
				snapshotIChannel.Unpack(ft, &CurrentSnapshotSetId);

				// Check if this snapshot belongs to the snapshot set.
				if (SnapshotSetId != CurrentSnapshotSetId) {
					// Go to the next snapshot
					bFirstSnapshot = false;
					continue;
				}

				// We found a snapshot belonging to the set.
				bSnapshotSetFound = true;

				// Set in order to deal with failure cases
				(*pNondeletedSnapshotID) = CurrentSnapshotId;
				
				// We found a snapshot. Delete it if the first one or if bForceDelete is enabled.
				if (bFirstSnapshot) {
					// Open another IOCTL channel on that volume
					volumeIChannel2.Open(ft, wszVolumeName);

					// Delete the snapshot
					volumeIChannel2.Call(ft, IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT);
					
					(*plDeletedSnapshots)++;
				} else if (bForceDelete) {
					ft.Throw( VSSDBG_SWPRV, E_NOTIMPL, L"Not implemented since there are no multiple snapshots");
					// TBD: Enumerate again all previous snapshots and delete them including this snapshot
				}
				else
					ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"A snapshot cannot be deleted if is not the oldest one");
			}

#ifdef _DEBUG
			// Check if all strings were browsed correctly
			DWORD dwFinalOffset = volumeIChannel.GetCurrentOutputOffset();
			BS_ASSERT( dwFinalOffset - dwInitialOffset == ulMultiszLen);
#endif
		}

		if (!bSnapshotSetFound)
			ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"Snapshot set not found");
    }
    VSS_STANDARD_CATCH(ft)

	// Close the search handle, if needed
	if (hSearch != INVALID_HANDLE_VALUE) {
		if (!::FindVolumeClose(hSearch))
			ft.Trace( VSSDBG_SWPRV, L"Error while closing the search handle 0x%08lx", GetLastError());
	}

	// Delete the temporary snapshot name
	::VssFreeString(pwszSnapshotName);

	if (ft.HrSucceeded())
		(*pNondeletedSnapshotID) = GUID_NULL;

    return ft.hr;
}


HRESULT CVsTestProvider::InternalDeleteSnapshot(
    IN      VSS_ID			SnapshotId,
	IN		BOOL			bForceDelete
    )

/*++

Description:

	This routine deletes a snapshot.

	If snapshot cannot be found then VSS_E_OBJECT_NOT_FOUND is returned.

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsTestProvider::InternalDeleteSnapshot" );
	HANDLE hSearch = INVALID_HANDLE_VALUE;
	LPWSTR pwszSnapshotName = NULL;

    try
    {
        // Trace
        ft.Trace( VSSDBG_SWPRV, L"SnapshotId = " WSTR_GUID_FMT L" bForceDelete = %d ",
					  GUID_PRINTF_ARG( SnapshotId ), bForceDelete );

		// Enumerate snapshots through all the volumes
		CVssIOCTLChannel volumeIChannel;	// For enumeration of snapshots on a volume
		CVssIOCTLChannel volumeIChannel2;	// For deletion of snapshots
		CVssIOCTLChannel snapshotIChannel;	// For snapshots attributes
		WCHAR wszVolumeName[MAX_PATH+1];
		bool bFirstVolume = true;
		bool bSnapshotFound = false;
		
		// Search for snapshots in all mounted volumes
		while(true) {
		
			// Get the volume name
			if (bFirstVolume) {
				hSearch = ::FindFirstVolumeW( wszVolumeName, MAX_PATH);
				if (hSearch == INVALID_HANDLE_VALUE)
					ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Error on FindFirstVolume 0x%08lx", GetLastError());
				bFirstVolume = false;
			} else {
				if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
					if (GetLastError() == ERROR_NO_MORE_FILES)
						break;	// End of iteration
					else
						ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Error on FindNextVolume 0x%08lx", GetLastError());
				}
			}

			// Eliminate the last backslash in order to open the volume
			EliminateLastBackslash(wszVolumeName);

			// Check if the snapshot(s) within this snapshot set is belonging to that volume
			// Open a IOCTL channel on that volume
			volumeIChannel.Open(ft, wszVolumeName);

			// Get the list of snapshots
			// If IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS not
			// supported then try with the next volume.
			ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, false);
			if (ft.HrFailed()) {
				ft.hr = S_OK;
				continue;
			}

			// Get the length of snapshot names multistring
			ULONG ulMultiszLen;
			volumeIChannel.Unpack(ft, &ulMultiszLen);

			// Try to find the snapshot with the corresponding Id
			bool bFirstSnapshot = true;
			while(volumeIChannel.UnpackZeroString(ft, pwszSnapshotName)) {
				// Compose the snapshot name in a user-mode style
				WCHAR wszUserModeSnapshotName[MAX_PATH];
				if (::_snwprintf(wszUserModeSnapshotName, MAX_PATH - 1,
						L"\\\\?\\GLOBALROOT%s", pwszSnapshotName) < 0)
					ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Not enough memory." );
			
				// Open that snapshot and verify if it has our ID
				snapshotIChannel.Open(ft, wszUserModeSnapshotName);

				// Get the application buffer
				snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO);

				// Get the length of the application buffer
				ULONG ulLen;
				snapshotIChannel.Unpack(ft, &ulLen);

				if (ulLen == 0) {
					ft.Warning(VSSDBG_SWPRV, L"Warning: zero-size snapshot detected: %s", pwszSnapshotName);
					bFirstSnapshot = false;
					continue;
				}

				// Get the snapshot Id
				VSS_ID CurrentSnapshotId;
				snapshotIChannel.Unpack(ft, &CurrentSnapshotId);

				// Check if this is the snapshot.
				if (SnapshotId != CurrentSnapshotId) {
					// Go to the next snapshot
					bFirstSnapshot = false;
					continue;
				}

				bSnapshotFound = true;

				// We found the snapshot. Delete it if the first one or if bForceDelete is enabled.
				if (bFirstSnapshot)
				{
					// Open another IOCTL channel on that volume
					volumeIChannel2.Open(ft, wszVolumeName);

					// Delete the snapshot
					volumeIChannel2.Call(ft, IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT);
				}
				else if (bForceDelete)
				{
					ft.Throw( VSSDBG_SWPRV, E_NOTIMPL, L"Not implemented since there are no multiple snapshots");
					// TBD: Enumerate again all previous snapshots and delete them including this snapshot
				}
				else
					ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"A snapshot cannot be deleted if is not the oldest one");

				// If a snapshot was found then end the cycle
				break;
			}

			// If a snapshot was found then do not continue to search it on other volumes.
			if (bSnapshotFound)
				break;
		}
		
		if (!bSnapshotFound)
			ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"Snapshot set not found");
    }
    VSS_STANDARD_CATCH(ft)

	// Close the search handle, if needed
	if (hSearch != INVALID_HANDLE_VALUE) {
		if (!::FindVolumeClose(hSearch))
			ft.Trace( VSSDBG_SWPRV, L"Error while closing the search handle 0x%08lx", GetLastError());
	}

	// Delete the temporary snapshot name
	::VssFreeString(pwszSnapshotName);

    return ft.hr;
}


HRESULT CVsTestProvider::InternalDeleteSnapshotOnVolume(
    IN      VSS_ID			VolumeId,
	OUT		LONG*			pDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
    )

/*++

Description:

	This routine deletes a snapshot.

	If snapshot cannot be found then VSS_E_OBJECT_NOT_FOUND is returned.

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsTestProvider::InternalDeleteSnapshotOnVolume" );
	HANDLE hSearch = INVALID_HANDLE_VALUE;
	LPWSTR pwszSnapshotName = NULL;

    try
    {
		BS_ASSERT(*pDeletedSnapshots == 0);
		BS_ASSERT(*pNondeletedSnapshotID == GUID_NULL);

        // Trace
        ft.Trace( VSSDBG_SWPRV, L"VolumeId = " WSTR_GUID_FMT, GUID_PRINTF_ARG( VolumeId ) );

		// Enumerate snapshots through all the volumes
		CVssIOCTLChannel volumeIChannel;	// For enumeration of snapshots on a volume
		CVssIOCTLChannel volumeIChannel2;	// For enumeration of snapshots on a volume
		CVssIOCTLChannel snapshotIChannel;	// For snapshots attributes
		WCHAR wszVolumeName[MAX_PATH+1];

		// Get the volume name
		::swprintf( wszVolumeName, L"\\\\?\\Volume" WSTR_GUID_FMT, GUID_PRINTF_ARG(VolumeId));

		// Open a IOCTL channel on that volume
		ft.hr = volumeIChannel.Open(ft, wszVolumeName, false);
		if (ft.HrFailed())
			ft.Throw( VSSDBG_SWPRV, ft.hr, L"Error on opening the volume %s", wszVolumeName);

		// Open another IOCTL channel on that volume
		volumeIChannel2.Open(ft, wszVolumeName);

		// Get the list of snapshots
		// If IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS not
		// supported then try with the next volume.
		ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, false);
		if (ft.HrFailed())
			ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED,
				L"The volume %s does not support the IOCTL",
				wszVolumeName);

		// Get the length of snapshot names multistring
		ULONG ulMultiszLen;
		volumeIChannel.Unpack(ft, &ulMultiszLen);

		// Try to find the snapshot with the corresponding Id
		while(volumeIChannel.UnpackZeroString(ft, pwszSnapshotName)) {
			// Compose the snapshot name in a user-mode style
			WCHAR wszUserModeSnapshotName[MAX_PATH];
			if (::_snwprintf(wszUserModeSnapshotName, MAX_PATH - 1,
					L"\\\\?\\GLOBALROOT%s", pwszSnapshotName) < 0)
				ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Not enough memory." );
		
			// Open that snapshot and verify if it has our ID
			ft.hr = snapshotIChannel.Open(ft, wszUserModeSnapshotName, false);
			if (ft.HrFailed())
				ft.Warning( VSSDBG_SWPRV, L"Error 0x%08lx on opening the snapshot %s",
							wszUserModeSnapshotName);
			else {
				// Get the application buffer
				snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO);

				// Get the length of the application buffer
				ULONG ulLen;
				snapshotIChannel.Unpack(ft, &ulLen);

				if (ulLen == 0)
					ft.Warning(VSSDBG_SWPRV, L"Warning: zero-size snapshot detected: %s", pwszSnapshotName);
				else
					// Get the snapshot Id in eventuality of an error
					snapshotIChannel.Unpack(ft, pNondeletedSnapshotID);
			}

			// Delete the snapshot
			volumeIChannel2.Call(ft, IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT);

			// Increment the number of deleted snapshots
			(*pDeletedSnapshots)++;
		}
    }
    VSS_STANDARD_CATCH(ft)

	// Close the search handle, if needed
	if (hSearch != INVALID_HANDLE_VALUE) {
		if (!::FindVolumeClose(hSearch))
			ft.Trace( VSSDBG_SWPRV, L"Error while closing the search handle 0x%08lx", GetLastError());
	}

	// Delete the temporary snapshot name
	::VssFreeString(pwszSnapshotName);

	if (ft.HrSucceeded())
		(*pNondeletedSnapshotID) = GUID_NULL;

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\testprv\src\enum.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Enum.cxx | Implementation of class VSS_OBJECT_PROP_Manager
    @end

Author:

    Adi Oltean  [aoltean]  09/01/1999

Revision History:

    Name        Date        Comments
    aoltean     09/01/1999  Created
    aoltean     09/09/1999  dss -> vss
	aoltean		09/20/1999	VSS_OBJECT_PROP_Copy renamed as VSS_OBJECT_PROP_Manager
	aoltean		09/21/1999  Adding headers for the _Ptr class

--*/

/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "bsdebug.hxx"
#include "bsexcept.hxx"
#include "snap_gen.hxx"
#include "snap_err.hxx"

// Generated file from Coord.IDL
#include "vss.h"
#include "vscoordint.h"
#include "vsevent.h"
#include "vsprov.h"

#include "swprv.hxx"
#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"


// Static methods that define the Copy class
#include "copy.inl"
#include "pointer.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\snapcp\snapcp.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	SnapCp.cpp
**
**
** Abstract:
**
**	Test program to accept commands and drive the snapshot stuff
**
**
** Author:
**
**	Michael C. Johnson   [mikejohn]        15-Mar-2001
**
**	Based in part on test programs :-
**		BETEST		by Brian Berkowitz
**		metasnap	by Michael C. Johnson
**
**
** Revision History:
**
**	X-3			Michael C. Johnson		 7-May-2001
**		Still more updates needed to keep up.
**
**	X-2			Michael C. Johnson		11-Apr-2001
**		Update to cater for recent changes to AddToSnapshotSet() API
**		Also clean up a few 64 bit compilation troubles.
**
**
**
** ToDo:
**	Allow for multiple (simultaneous) snapshot sets
**	Assign drive letters (manual and automatically) (mapping?)
**	Proper error handling
**	Better user feedback for operation in progress...
**	Logging
**	Default drive list
**	Comma separated drive list
**	Command line prompt
**	auto add all local hard drives
**
**--
*/

#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string.h>

#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>


#include <oleauto.h>

#define ATLASSERT(_condition)

#include <atlconv.h>
#include <atlbase.h>

extern CComModule _Module;
#include <atlcom.h>



#define	PROGRAM_TITLE				L"SnapCp - Snapshot Control Program V0.3"


#if !defined (SIZEOF_ARRAY)
#define SIZEOF_ARRAY(_arrayname)		(sizeof (_arrayname) / sizeof ((_arrayname)[0]))
#endif

#define MAX_COMMAND				(SIZEOF_ARRAY (CommandTable))
#define MAX_COMMAND_LINE_LENGTH			(1024)
#define MAX_VOLUMES_IN_SNAPSHOT_SET		(64)
#define VolumeNameTemplate			"\\\\?\\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\\"



#define HandleInvalid(_Handle)			((NULL == (_Handle)) || (INVALID_HANDLE_VALUE == (_Handle)))

#define	GET_STATUS_FROM_BOOL(_bSucceeded)	((_bSucceeded)             ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_HANDLE(_handle)		((!HandleInvalid(_handle)) ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_POINTER(_ptr)		((NULL != (_ptr))          ? NOERROR : E_OUTOFMEMORY)



typedef	IVssBackupComponents		*PIVssBackupComponents;
typedef IVssExamineWriterMetadata	*PIVssExamineWriterMetadata;
typedef IVssWMComponent			*PIVssWMComponent;
typedef IVssAsync			*PIVssAsync;



typedef enum _SnapshotSetState
    {
     STATE_MIN_STATE = 50
    ,STATE_INITIALISED
    ,STATE_SNAPSHOT_SET_CREATED
    ,STATE_SNAPSHOT_CREATED
    ,STATE_SNAPSHOT_BEING_DESTROYED
    ,STATE_UNKNOWN
    ,STATE_MAX_STATE
    } SNAPSHOTSET_STATE, *PSNAPSHOTSET_STATE;

typedef enum _CommandCode
    {
     COMMAND_MIN_COMMAND = 20
    ,COMMAND_QUIT
    ,COMMAND_EXIT
    ,COMMAND_HELP
    ,COMMAND_SHOW_METADATA
    ,COMMAND_SHOW_WRITERS
    ,COMMAND_ADD_VOLUME
    ,COMMAND_CREATE_SNAPSHOT_SET
    ,COMMAND_CREATE_SNAPSHOT
    ,COMMAND_DELETE_SNAPSHOT_SET
    ,COMMAND_SET_DEFAULT_VOLUME_LIST
    ,COMMAND_SET_BACKUP_TYPE
    ,COMMAND_SET_LOGGING_LEVEL
    ,COMMAND_SET_LOGGING_FILE
    ,COMMAND_NOT_IMPLEMENTED
    ,COMMAND_UNKNOWN
    ,COMMAND_MAX_COMMAND
    } COMMAND_CODE, *PCOMMAND_CODE;


typedef struct _CommandDescriptor
    {
    COMMAND_CODE	eCommandCode;
    PWCHAR		pwszCommandString;
    } COMMANDDESCRIPTOR, *PCOMMANDDESCRIPTOR;



typedef struct _ContextSnapshotSet
    {
    COMMAND_CODE		eCommand;
    SNAPSHOTSET_STATE		eState;
    bool			bIncludeBootableState;
    ULONG			ulVolumesInSnapshotSet;
    PWSTR			pwszVolumeArgument [MAX_VOLUMES_IN_SNAPSHOT_SET];
    PWSTR			pwszVolumeName     [MAX_VOLUMES_IN_SNAPSHOT_SET];
    PWSTR			pwszVolumeDevice   [MAX_VOLUMES_IN_SNAPSHOT_SET];
    PWSTR			pwszSnapshotDevice [MAX_VOLUMES_IN_SNAPSHOT_SET];
    VSS_ID		        SnapshotId         [MAX_VOLUMES_IN_SNAPSHOT_SET];
    VSS_SNAPSHOT_PROP		SnapshotProperties [MAX_VOLUMES_IN_SNAPSHOT_SET];

    PIVssBackupComponents	pIVssBackupComponents;
    PIVssAsync			pIVssAsyncDoSnapshotSet;

    GUID			guidSnapshotSetId;
    } CONTEXTSNAPSHOTSET, *PCONTEXTSNAPSHOTSET;







inline void CHECK_SUCCESS (HRESULT hr);
inline void CHECK_NOFAIL  (HRESULT hr);


BOOL WINAPI CtrlC_HandlerRoutine (DWORD dwCtrlType);

HRESULT AssertPrivilege (LPCWSTR privName);

ULONG FormatGUID (GUID guidValue, PWCHAR pszFormattedGUID, ULONG ulBufferLength);
void PrintFiledesc (IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription);

LPCWSTR GetStringFromUsageType           (VSS_USAGE_TYPE         eUsageType);
LPCWSTR GetStringFromSourceType          (VSS_SOURCE_TYPE        eSourceType);
LPCWSTR GetStringFromRestoreMethod       (VSS_RESTOREMETHOD_ENUM eRestoreMethod);
LPCWSTR GetStringFromWriterRestoreMethod (VSS_WRITERRESTORE_ENUM eWriterRestoreMethod);
LPCWSTR GetStringFromComponentType       (VSS_COMPONENT_TYPE     eComponentType);
LPCWSTR GetStringFromFailureType         (HRESULT hrStatus);


HRESULT GetNextCommandLine (PWSTR pwszCommandLineBuffer, ULONG ulCommandLineBufferLength);
HRESULT ParseCommandLine   (PWSTR pwszCommandLineBuffer, PCOMMAND_CODE peReturnedCommandCode);

HRESULT InitialiseSnapshotSetContext (PCONTEXTSNAPSHOTSET pctxSnapshotSet);
HRESULT GetVolumeNameFromArgument (LPCWSTR pwszVolumeArgument, LPWSTR *ppwszReturnedVolumeName);


HRESULT ShowAnnouncement   (void);
HRESULT ShowHelp           (void);
HRESULT ShowMetadata       (void);
HRESULT ShowWriters        (void);
HRESULT AddVolume          (PCONTEXTSNAPSHOTSET pctxSnapshotSet);
HRESULT CreateSnapshotSet  (PCONTEXTSNAPSHOTSET pctxSnapshotSet);
HRESULT CreateSnapshot     (PCONTEXTSNAPSHOTSET pctxSnapshotSet);
HRESULT DeleteSnapshot     (PCONTEXTSNAPSHOTSET pctxSnapshotSet);
HRESULT CleanupSnapshotSet (PCONTEXTSNAPSHOTSET pctxSnapshotSet);






COMMANDDESCRIPTOR CommandTable [] = 
    {
    { COMMAND_QUIT,                    L"Quit"     },
    { COMMAND_EXIT,                    L"Exit"     },
    { COMMAND_HELP,                    L"Help"     },
    { COMMAND_SHOW_METADATA,           L"Metadata" },
    { COMMAND_SHOW_WRITERS,            L"Writers"  },
    { COMMAND_ADD_VOLUME,              L"Add"      },
    { COMMAND_CREATE_SNAPSHOT_SET,     L"Set"      },
    { COMMAND_CREATE_SNAPSHOT,         L"Create"   },
    { COMMAND_DELETE_SNAPSHOT_SET,     L"Delete"   },
    { COMMAND_SET_DEFAULT_VOLUME_LIST, L"Default"  },
    { COMMAND_SET_BACKUP_TYPE,         L"Type"     },
    { COMMAND_SET_LOGGING_LEVEL,       L"Level"    },
    { COMMAND_SET_LOGGING_FILE,        L"File"     }
    };


WCHAR			g_awchCommandLine [MAX_COMMAND_LINE_LENGTH];
PWCHAR			g_pwchNextArgument       = NULL;
PCONTEXTSNAPSHOTSET	g_pctxSnapshotSet        = NULL;
BOOL			g_bCoInitializeSucceeded = false;





extern "C" __cdecl wmain(int argc, WCHAR **argv)
    {
    HRESULT		hrStatus        = NOERROR;
    PCONTEXTSNAPSHOTSET	pctxSnapshotSet = NULL;
    CONTEXTSNAPSHOTSET	ctxSnapshotSet;


    UNREFERENCED_PARAMETER (argc);
    UNREFERENCED_PARAMETER (argv);



    InitialiseSnapshotSetContext (&ctxSnapshotSet);

    g_pctxSnapshotSet = &ctxSnapshotSet;


    SetConsoleCtrlHandler (CtrlC_HandlerRoutine, TRUE);



    ShowAnnouncement ();

    hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);

    g_bCoInitializeSucceeded = SUCCEEDED (hrStatus);

    if (FAILED (hrStatus))
	{
	wprintf (L"SnapCp (wmain) - CoInitializeEx() returned error 0x%08X\n", hrStatus);
	}



    if (SUCCEEDED (hrStatus))
	{
	hrStatus = AssertPrivilege (SE_BACKUP_NAME);

	if (FAILED (hrStatus))
	    {
	    wprintf (L"SnapCp (wmain) - AssertPrivilege() returned error 0x%08X\n", hrStatus);
	    }
	}



    /*
    ** Parse command loop here
    */
    while (SUCCEEDED (hrStatus) && 
	   (COMMAND_EXIT != ctxSnapshotSet.eCommand) && 
	   (COMMAND_QUIT != ctxSnapshotSet.eCommand))
	{
	hrStatus = GetNextCommandLine (g_awchCommandLine, sizeof (g_awchCommandLine));
 	hrStatus = ParseCommandLine (g_awchCommandLine, &ctxSnapshotSet.eCommand);

	switch (ctxSnapshotSet.eCommand)
	    {
	    case COMMAND_EXIT:                                                                    break;
	    case COMMAND_QUIT:                                                                    break;
	    case COMMAND_HELP:                    hrStatus = ShowHelp          ();                break;
	    case COMMAND_SHOW_METADATA:           hrStatus = ShowMetadata      ();                break;
	    case COMMAND_SHOW_WRITERS:            hrStatus = ShowWriters       ();                break;
	    case COMMAND_CREATE_SNAPSHOT_SET:     hrStatus = CreateSnapshotSet (&ctxSnapshotSet); break;
	    case COMMAND_ADD_VOLUME:              hrStatus = AddVolume         (&ctxSnapshotSet); break;
	    case COMMAND_CREATE_SNAPSHOT:         hrStatus = CreateSnapshot    (&ctxSnapshotSet); break;
	    case COMMAND_DELETE_SNAPSHOT_SET:     hrStatus = DeleteSnapshot    (&ctxSnapshotSet); break;

	    case COMMAND_SET_DEFAULT_VOLUME_LIST:
	    case COMMAND_SET_BACKUP_TYPE:
	    case COMMAND_SET_LOGGING_LEVEL:
	    case COMMAND_SET_LOGGING_FILE:

	    default:
		ctxSnapshotSet.eCommand = COMMAND_UNKNOWN;
		break;
	    }
	}



    pctxSnapshotSet = (PCONTEXTSNAPSHOTSET) InterlockedExchangePointer ((PVOID *)&g_pctxSnapshotSet, NULL);

    if (NULL != pctxSnapshotSet)   CleanupSnapshotSet (pctxSnapshotSet);
    if (g_bCoInitializeSucceeded)  CoUninitialize ();
    if (FAILED(hrStatus))          wprintf (L"Failed with 0x%08X.\n", hrStatus);

    return (0);
    }
	



BOOL WINAPI CtrlC_HandlerRoutine (DWORD dwCtrlType)
    {
    PCONTEXTSNAPSHOTSET	pctxSnapshotSet = NULL;


    UNREFERENCED_PARAMETER (dwCtrlType);


    pctxSnapshotSet = (PCONTEXTSNAPSHOTSET) InterlockedExchangePointer ((PVOID *)&g_pctxSnapshotSet, NULL);

    if (NULL != pctxSnapshotSet)   CleanupSnapshotSet (pctxSnapshotSet);
    if (g_bCoInitializeSucceeded)  CoUninitialize ();


    return (false);
    }




HRESULT AssertPrivilege (LPCWSTR privName)
    {
    HRESULT		 hrStatus   = NOERROR;
    BOOL		 bSucceeded = FALSE;
    TOKEN_PRIVILEGES	*pTokens    = NULL;
    TOKEN_PRIVILEGES	 newState;
    HANDLE		 tokenHandle;
    LUID		 value;
    DWORD		 cbTokens;


    if (OpenProcessToken (GetCurrentProcess(),
			  TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,
			  &tokenHandle))
	{
	if (LookupPrivilegeValue (NULL, privName, &value))
	    {
	    newState.PrivilegeCount            = 1;
	    newState.Privileges [0].Luid       = value;
	    newState.Privileges [0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED;


	    /*
	    ** We will always call GetLastError below, so clear
	    ** any prior error values on this thread.
	    */
	    SetLastError (ERROR_SUCCESS);

	    bSucceeded = AdjustTokenPrivileges (tokenHandle,
						FALSE,
						&newState,
						(DWORD)0,
						NULL,
						NULL);

	    /*
	    ** Supposedly, AdjustTokenPriveleges always returns TRUE
	    ** (even when it fails). So, call GetLastError to be
	    ** extra sure everything's cool.
	    */
	    hrStatus = GET_STATUS_FROM_BOOL (FALSE);


	    if (FAILED (hrStatus))
		{
		wprintf (L"AdjustTokenPrivileges for %s failed with 0x%08X",
			 privName,
			 hrStatus);
		}
	    }


	if (SUCCEEDED (hrStatus))
	    {
	    GetTokenInformation (tokenHandle,
				 TokenPrivileges,
				 NULL,
				 0,
				 &cbTokens);


	    pTokens = (TOKEN_PRIVILEGES *) new BYTE[cbTokens];

	    GetTokenInformation (tokenHandle,
				 TokenPrivileges,
				 pTokens,
				 cbTokens,
				 &cbTokens);
	    }

	delete pTokens;
	CloseHandle (tokenHandle);
	}


    return (hrStatus);
    }




inline void CHECK_SUCCESS (HRESULT hr)
    {
    if (hr != S_OK)
	{
	wprintf(L"operation failed with HRESULT =0x%08x\n", hr);
	DebugBreak();
	}
    }


inline void CHECK_NOFAIL (HRESULT hr)
    {
    if (FAILED(hr))
	{
	wprintf(L"operation failed with HRESULT =0x%08x\n", hr);
	DebugBreak();
	}
    }




LPCWSTR GetStringFromUsageType (VSS_USAGE_TYPE eUsageType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eUsageType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszRetString = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszRetString = L"SystemService";       break;
	case VSS_UT_USERDATA:            pwszRetString = L"UserData";            break;
	case VSS_UT_OTHER:               pwszRetString = L"Other";               break;
					
	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eSourceType)
	{
	case VSS_ST_TRANSACTEDDB:    pwszRetString = L"TransactionDb";    break;
	case VSS_ST_NONTRANSACTEDDB: pwszRetString = L"NonTransactionDb"; break;
	case VSS_ST_OTHER:           pwszRetString = L"Other";            break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromRestoreMethod (VSS_RESTOREMETHOD_ENUM eRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eRestoreMethod)
	{
	case VSS_RME_RESTORE_IF_NOT_THERE:          pwszRetString = L"RestoreIfNotThere";          break;
	case VSS_RME_RESTORE_IF_CAN_REPLACE:        pwszRetString = L"RestoreIfCanReplace";        break;
	case VSS_RME_STOP_RESTORE_START:            pwszRetString = L"StopRestoreStart";           break;
	case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION: pwszRetString = L"RestoreToAlternateLocation"; break;
	case VSS_RME_RESTORE_AT_REBOOT:             pwszRetString = L"RestoreAtReboot";            break;
	case VSS_RME_CUSTOM:                        pwszRetString = L"Custom";                     break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromWriterRestoreMethod (VSS_WRITERRESTORE_ENUM eWriterRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eWriterRestoreMethod)
	{
	case VSS_WRE_NEVER:            pwszRetString = L"RestoreNever";           break;
	case VSS_WRE_IF_REPLACE_FAILS: pwszRetString = L"RestoreIfReplaceFailsI"; break;
	case VSS_WRE_ALWAYS:           pwszRetString = L"RestoreAlways";          break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eComponentType)
	{
	case VSS_CT_DATABASE:  pwszRetString = L"Database";  break;
	case VSS_CT_FILEGROUP: pwszRetString = L"FileGroup"; break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromFailureType (HRESULT hrStatus)
    {
    LPCWSTR pwszFailureType;

    switch (hrStatus)
	{
	case NOERROR:                                pwszFailureType = L"";                     break;
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT: pwszFailureType = L"InconsistentSnapshot"; break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:       pwszFailureType = L"OutOfResources";       break;
	case VSS_E_WRITERERROR_TIMEOUT:              pwszFailureType = L"Timeout";              break;
	case VSS_E_WRITERERROR_NONRETRYABLE:         pwszFailureType = L"Non-Retryable";        break;
	case VSS_E_WRITERERROR_RETRYABLE:            pwszFailureType = L"Retryable";            break;
	default:                                     pwszFailureType = L"UNDEFINED";            break;
	}

    return (pwszFailureType);
    }


/*
** {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX} 
*/
ULONG FormatGUID (GUID guidValue, PWCHAR pszFormattedGUID, ULONG ulBufferLength)
    {
    DWORD	dwStatus = 0;


    if (sizeof (L"{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}") > ulBufferLength)
	{
	dwStatus = ERROR_INSUFFICIENT_BUFFER;
	}


    if (0 == dwStatus)
	{
	_snwprintf (pszFormattedGUID, 
		    ulBufferLength / sizeof (WCHAR), 
		    L"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
		    guidValue.Data1,
		    guidValue.Data2,
		    guidValue.Data3,
		    guidValue.Data4[0],
		    guidValue.Data4[1],
		    guidValue.Data4[2],
		    guidValue.Data4[3],
		    guidValue.Data4[4],
		    guidValue.Data4[5],
		    guidValue.Data4[6],
		    guidValue.Data4[7]);
	}


    return (dwStatus);
    }


void PrintFiledesc (IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription)
    {
    CComBSTR bstrPath;
    CComBSTR bstrFilespec;
    CComBSTR bstrAlternate;
    bool     bRecursive;


    CHECK_SUCCESS (pFiledesc->GetPath (&bstrPath));
    CHECK_SUCCESS (pFiledesc->GetFilespec (&bstrFilespec));
    CHECK_NOFAIL  (pFiledesc->GetRecursive (&bRecursive));
    CHECK_NOFAIL  (pFiledesc->GetAlternateLocation (&bstrAlternate));

    wprintf (L"%s\n            Path = %s, Filespec = %s, Recursive = %s\n",
	     wszDescription,
	     bstrPath,
	     bstrFilespec,
	     bRecursive ? L"yes" : L"no");

    if (bstrAlternate && wcslen (bstrAlternate) > 0)
	{
	wprintf(L"            Alternate Location = %s\n", bstrAlternate);
	}
    }




HRESULT GetNextCommandLine (PWSTR pwszCommandLineBuffer, ULONG ulCommandLineBufferLength)
    {
    UNREFERENCED_PARAMETER (pwszCommandLineBuffer);
    UNREFERENCED_PARAMETER (ulCommandLineBufferLength);


    g_pwchNextArgument = NULL;

    _getws (pwszCommandLineBuffer);


    return (NOERROR);
    }



HRESULT ParseCommandLine (PWSTR pwszCommandLineBuffer, PCOMMAND_CODE peReturnedCommandCode)
    {
    ULONG		ulIndexCommandTable;
    COMMAND_CODE	eCommandCode = COMMAND_UNKNOWN;


    for (ulIndexCommandTable = 0; 
	 (ulIndexCommandTable < MAX_COMMAND) && (COMMAND_UNKNOWN == eCommandCode);
	 ulIndexCommandTable++)
	{
	if (0 == _wcsnicmp (pwszCommandLineBuffer, 
			    CommandTable [ulIndexCommandTable].pwszCommandString,
			    wcslen (CommandTable [ulIndexCommandTable].pwszCommandString)))
	    {
	    size_t ulCommandStringLength = wcslen (CommandTable [ulIndexCommandTable].pwszCommandString);

	    eCommandCode = CommandTable [ulIndexCommandTable].eCommandCode;

	    if ((pwszCommandLineBuffer [ulCommandStringLength + 0] == ' ') &&
		(pwszCommandLineBuffer [ulCommandStringLength + 1] != '\0'))
		{
		g_pwchNextArgument = &pwszCommandLineBuffer [ulCommandStringLength + 1];
		}
	    }
	}
	

    *peReturnedCommandCode = eCommandCode;

    return (NOERROR);
    }





HRESULT InitialiseSnapshotSetContext (PCONTEXTSNAPSHOTSET pctxSnapshotSet)
    {
    HRESULT	hrStatus = NOERROR;
    ULONG	ulIndex;


    pctxSnapshotSet->eCommand                = COMMAND_UNKNOWN;
    pctxSnapshotSet->bIncludeBootableState   = false;
    pctxSnapshotSet->ulVolumesInSnapshotSet  = 0;
    pctxSnapshotSet->pIVssBackupComponents   = NULL;
    pctxSnapshotSet->pIVssAsyncDoSnapshotSet = NULL;
    pctxSnapshotSet->guidSnapshotSetId       = GUID_NULL;

    for (ulIndex = 0; ulIndex < SIZEOF_ARRAY (pctxSnapshotSet->pwszVolumeName); ulIndex++)
	{
	pctxSnapshotSet->pwszVolumeArgument [ulIndex]              = NULL;
	pctxSnapshotSet->pwszVolumeName     [ulIndex]              = NULL;
	pctxSnapshotSet->pwszVolumeDevice   [ulIndex]              = NULL;
	pctxSnapshotSet->pwszSnapshotDevice [ulIndex]              = NULL;
	pctxSnapshotSet->SnapshotProperties [ulIndex].m_SnapshotId = GUID_NULL;
	pctxSnapshotSet->SnapshotId         [ulIndex]              = GUID_NULL;
	}


    pctxSnapshotSet->eState = STATE_INITIALISED;


    return (hrStatus);
    }



HRESULT CleanupSnapshotSet (PCONTEXTSNAPSHOTSET pctxSnapshotSet)
    {
    HRESULT	hrStatus = NOERROR;
    ULONG	ulIndex;


    pctxSnapshotSet->eState = STATE_SNAPSHOT_BEING_DESTROYED;


    if (GUID_NULL != pctxSnapshotSet->guidSnapshotSetId)
	{
	hrStatus = pctxSnapshotSet->pIVssBackupComponents->AbortBackup ();

	hrStatus = pctxSnapshotSet->pIVssBackupComponents->DeleteSnapshots (pctxSnapshotSet->guidSnapshotSetId,
									    VSS_OBJECT_SNAPSHOT_SET,
									    true,
									    NULL,
									    NULL);
	}

    for (ulIndex = 0; ulIndex < pctxSnapshotSet->ulVolumesInSnapshotSet; ulIndex++)
	{
	if (NULL != pctxSnapshotSet->pwszVolumeArgument [ulIndex]) 
	    {
	    free (pctxSnapshotSet->pwszVolumeArgument [ulIndex]);
	    }

	if (NULL != pctxSnapshotSet->pwszVolumeName [ulIndex])
	    {
	    free (pctxSnapshotSet->pwszVolumeName [ulIndex]);
	    }

	if (NULL != pctxSnapshotSet->pwszVolumeDevice [ulIndex])
	    {
	    free (pctxSnapshotSet->pwszVolumeDevice [ulIndex]);
	    }

	if (NULL != pctxSnapshotSet->pwszSnapshotDevice [ulIndex])
	    {
	    CoTaskMemFree (pctxSnapshotSet->pwszSnapshotDevice [ulIndex]);
	    }

	if (GUID_NULL != pctxSnapshotSet->SnapshotProperties [ulIndex].m_SnapshotId)
	    {
	    VssFreeSnapshotProperties (&pctxSnapshotSet->SnapshotProperties [ulIndex]);
	    }
	}


    if (NULL != pctxSnapshotSet->pIVssBackupComponents)   pctxSnapshotSet->pIVssBackupComponents->Release ();
    if (NULL != pctxSnapshotSet->pIVssAsyncDoSnapshotSet) pctxSnapshotSet->pIVssAsyncDoSnapshotSet->Release ();


    InitialiseSnapshotSetContext (pctxSnapshotSet);



    return (hrStatus);
    }



HRESULT GetVolumeNameFromArgument (LPCWSTR pwszVolumeArgument, LPWSTR *ppwszReturnedVolumeName)
    {
    HRESULT	hrStatus                   = NOERROR;
    PWCHAR	pwszPath                   = NULL;
    PWCHAR	pwszMountPointName         = NULL;
    PWCHAR	pwszVolumeName             = NULL;
    ULONG	ulPathLength               = 0;
    ULONG	ulMountpointBufferLength   = 0;
    BOOL	bSucceeded                 = FALSE;
    ULONG	ulVolumeNameCharacterCount = sizeof (VolumeNameTemplate);



    pwszVolumeName = (PWCHAR) calloc (ulVolumeNameCharacterCount, sizeof (WCHAR));

    bSucceeded = (NULL != pwszVolumeName);


    if (bSucceeded)
	{
	ulPathLength = ExpandEnvironmentStringsW (pwszVolumeArgument, NULL, 0);

	pwszPath = (PWCHAR) calloc (ulPathLength, sizeof (WCHAR));

	bSucceeded = (NULL != pwszPath);
	}


    if (bSucceeded)
	{
	ulPathLength = ExpandEnvironmentStringsW (pwszVolumeArgument, pwszPath, ulPathLength);

	ulMountpointBufferLength = GetFullPathName (pwszPath, 0, NULL, NULL);

	pwszMountPointName = (PWCHAR) calloc (ulMountpointBufferLength, sizeof (WCHAR));

	bSucceeded = (NULL != pwszMountPointName);
	}


    if (bSucceeded)
	{
	bSucceeded = GetVolumePathNameW (pwszPath, pwszMountPointName, ulMountpointBufferLength);
	}


    if (bSucceeded)
	{
	bSucceeded = GetVolumeNameForVolumeMountPointW (pwszMountPointName, 
							pwszVolumeName, 
							ulVolumeNameCharacterCount);
	}


    if (bSucceeded)
	{
	*ppwszReturnedVolumeName = pwszVolumeName;
	pwszVolumeName = NULL;
	}


    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

    if (NULL != pwszPath)           free (pwszPath);
    if (NULL != pwszMountPointName) free (pwszMountPointName);
    if (NULL != pwszVolumeName)     free (pwszVolumeName);


    return (hrStatus);
    }






HRESULT ShowMetadata (void)
    {
    HRESULT	hr = NOERROR;

    try
	{
	unsigned cWriters;
	CComBSTR bstrXML;
	CComBSTR bstrXMLOut;
	CComBSTR strSnapshotSetId = "12345678-1234-1234-1234-1234567890ab";
	CComPtr<IVssBackupComponents> pvbc;
	CComPtr<IVssAsync> pAsync;


	CHECK_SUCCESS (CreateVssBackupComponents (&pvbc));

	CHECK_SUCCESS (pvbc->InitializeForBackup  ());
	CHECK_SUCCESS (pvbc->SetBackupState       (true, false, VSS_BT_FULL));
	CHECK_NOFAIL  (pvbc->GatherWriterMetadata (&pAsync));
	CHECK_NOFAIL  (pAsync->Wait ());
	CHECK_NOFAIL  (pvbc->GetWriterMetadataCount (&cWriters));


	for (unsigned iWriter = 0; iWriter < cWriters; iWriter++)
	    {
	    CComPtr<IVssExamineWriterMetadata> pMetadata;

	    VSS_ID           idInstance;
	    VSS_ID           idInstanceT;
	    VSS_ID           idWriter;
	    CComBSTR         bstrWriterName;
	    VSS_USAGE_TYPE   usage;
	    VSS_SOURCE_TYPE  source;
	    WCHAR           *pwszInstanceId;
	    WCHAR           *pwszWriterId;
	    unsigned cIncludeFiles, cExcludeFiles, cComponents;
	    CComBSTR bstrPath;
	    CComBSTR bstrFilespec;
	    CComBSTR bstrAlternate;
	    CComBSTR bstrDestination;



	    CHECK_SUCCESS (pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata));

	    CHECK_SUCCESS (pMetadata->GetIdentity (&idInstanceT,
						   &idWriter,
						   &bstrWriterName,
						   &usage,
						   &source));

	    wprintf (L"\n\n");

            if (memcmp (&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
		{
		wprintf(L"Instance id mismatch\n");
		DebugBreak();
		}


	    UuidToString (&idInstance, &pwszInstanceId);
	    UuidToString (&idWriter,   &pwszWriterId);

	    wprintf (L"WriterName = %s\n\n"
		     L"    WriterId   = %s\n"
		     L"    InstanceId = %s\n"
		     L"    UsageType  = %d (%s)\n"
		     L"    SourceType = %d (%s)\n",
		     bstrWriterName,
		     pwszWriterId,
		     pwszInstanceId,
		     usage,
		     GetStringFromUsageType (usage),
		     source,
		     GetStringFromSourceType (source));

	    RpcStringFree (&pwszInstanceId);
	    RpcStringFree (&pwszWriterId);

	    CHECK_SUCCESS(pMetadata->GetFileCounts (&cIncludeFiles,
						    &cExcludeFiles,
						    &cComponents));

	    for(unsigned i = 0; i < cIncludeFiles; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;

		CHECK_SUCCESS (pMetadata->GetIncludeFile (i, &pFiledesc));

		PrintFiledesc(pFiledesc, L"\n    Include File");
		}


	    for(i = 0; i < cExcludeFiles; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;

		CHECK_SUCCESS (pMetadata->GetExcludeFile (i, &pFiledesc));

		PrintFiledesc (pFiledesc, L"\n    Exclude File");
		}


	    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
		CComPtr<IVssWMComponent> pComponent;
		PVSSCOMPONENTINFO pInfo;

		CHECK_SUCCESS (pMetadata->GetComponent      (iComponent, &pComponent));
		CHECK_SUCCESS (pComponent->GetComponentInfo (&pInfo));

		wprintf (L"\n"
			 L"    Component %d, type = %d (%s)\n"
			 L"        LogicalPath = %s\n"
			 L"        Name        = %s\n"
			 L"        Caption     = %s\n",
			 iComponent,
			 pInfo->type,
			 GetStringFromComponentType (pInfo->type),
			 pInfo->bstrLogicalPath,
			 pInfo->bstrComponentName,
			 pInfo->bstrCaption);

					

                if (pInfo->cbIcon > 0)
		    {
		    if (pInfo->cbIcon != 10 ||
			pInfo->pbIcon[0] != 1 ||
			pInfo->pbIcon[1] != 2 ||
			pInfo->pbIcon[2] != 3 ||
			pInfo->pbIcon[3] != 4 ||
			pInfo->pbIcon[4] != 5 ||
			pInfo->pbIcon[5] != 6 ||
			pInfo->pbIcon[6] != 7 ||
			pInfo->pbIcon[7] != 8 ||
			pInfo->pbIcon[8] != 9 ||
			pInfo->pbIcon[9] != 10)
			{
			wprintf(L"        Icon is not valid.\n");
			DebugBreak();
			}
		    else
			wprintf(L"        Icon is valid.\n");
		    }

		wprintf (L"        RestoreMetadata        = %s\n"
			 L"        NotifyOnBackupComplete = %s\n"
			 L"        Selectable             = %s\n",
			 pInfo->bRestoreMetadata        ? L"yes" : L"no",
			 pInfo->bNotifyOnBackupComplete ? L"yes" : L"no",
			 pInfo->bSelectable             ? L"yes" : L"no");


		if (pInfo->cFileCount > 0)
		    {
		    for(i = 0; i < pInfo->cFileCount; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;

			CHECK_SUCCESS (pComponent->GetFile (i, &pFiledesc));

			PrintFiledesc (pFiledesc, L"        FileGroupFile");
			}
		    }

		if (pInfo->cDatabases > 0)
		    {
		    for(i = 0; i < pInfo->cDatabases; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;

			CHECK_SUCCESS (pComponent->GetDatabaseFile (i, &pFiledesc));

			PrintFiledesc (pFiledesc, L"        DatabaseFile");
			}
		    }


		if (pInfo->cLogFiles > 0)
		    {
		    for(i = 0; i < pInfo->cLogFiles; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;

			CHECK_SUCCESS (pComponent->GetDatabaseLogFile (i, &pFiledesc));

			PrintFiledesc (pFiledesc, L"        DatabaseLogFile");
			}
		    }

		pComponent->FreeComponentInfo (pInfo);
		}



	    VSS_RESTOREMETHOD_ENUM method;
	    CComBSTR bstrUserProcedure;
	    CComBSTR bstrService;
	    VSS_WRITERRESTORE_ENUM writerRestore;
	    unsigned cMappings;
	    bool bRebootRequired;

	    CHECK_NOFAIL (pMetadata->GetRestoreMethod (&method,
						       &bstrService,
						       &bstrUserProcedure,
						       &writerRestore,
						       &bRebootRequired,
						       &cMappings));


	    wprintf (L"\n"
		     L"    Restore method = %d (%s)\n"
		     L"    Service        = %d\n"
		     L"    User Procedure = %s\n"
		     L"    WriterRestore  = %d (%s)\n"
		     L"    RebootRequired = %s\n",
		     method,
		     GetStringFromRestoreMethod (method),
		     bstrService,
		     bstrUserProcedure,
		     writerRestore,
		     GetStringFromWriterRestoreMethod (writerRestore),
		     bRebootRequired ? L"yes" : L"no");

	    for(i = 0; i < cMappings; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;

		CHECK_SUCCESS (pMetadata->GetAlternateLocationMapping (i, &pFiledesc));

		PrintFiledesc (pFiledesc, L"    AlternateMapping");
		}
	    }


	CHECK_SUCCESS (pvbc->FreeWriterMetadata());
	}

    catch(...)
	{
	hr = E_UNEXPECTED;
	}


    if (FAILED(hr)) wprintf (L"Failed with 0x%08X.\n", hr);

    return (hr);
    }




HRESULT ShowWriters (void)
    {
    HRESULT	hr = NOERROR;

    try
	{
	unsigned cWriters;
	CComBSTR bstrXML;
	CComBSTR bstrXMLOut;
	CComBSTR strSnapshotSetId = "12345678-1234-1234-1234-1234567890ab";
	CComPtr<IVssBackupComponents> pvbc;
	CComPtr<IVssAsync> pIVssAsync;


	CHECK_SUCCESS (CreateVssBackupComponents (&pvbc));

	CHECK_SUCCESS (pvbc->InitializeForBackup  ());
	CHECK_SUCCESS (pvbc->SetBackupState       (true, false, VSS_BT_FULL));
	CHECK_NOFAIL  (pvbc->GatherWriterMetadata (&pIVssAsync));
	CHECK_NOFAIL  (pIVssAsync->Wait ());
	CHECK_NOFAIL  (pvbc->GetWriterMetadataCount (&cWriters));


	for (unsigned iWriter = 0; iWriter < cWriters; iWriter++)
	    {
	    CComPtr<IVssExamineWriterMetadata> pMetadata;

	    VSS_ID           idInstance;
	    VSS_ID           idInstanceT;
	    VSS_ID           idWriter;
	    CComBSTR         bstrWriterName;
	    VSS_USAGE_TYPE   usage;
	    VSS_SOURCE_TYPE  source;
	    WCHAR           *pwszInstanceId;
	    WCHAR           *pwszWriterId;
	    CComBSTR	 bstrPath;
	    CComBSTR bstrFilespec;
	    CComBSTR bstrAlternate;
	    CComBSTR bstrDestination;



	    CHECK_SUCCESS (pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata));

	    CHECK_SUCCESS (pMetadata->GetIdentity (&idInstanceT,
						   &idWriter,
						   &bstrWriterName,
						   &usage,
						   &source));

	    wprintf (L"\n\n");

            if (memcmp (&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
		{
		wprintf(L"Instance id mismatch\n");
		DebugBreak();
		}


	    UuidToString (&idInstance, &pwszInstanceId);
	    UuidToString (&idWriter,   &pwszWriterId);

	    wprintf (L"WriterName = %s\n\n"
		     L"    WriterId   = %s\n"
		     L"    InstanceId = %s\n"
		     L"    UsageType  = %d (%s)\n"
		     L"    SourceType = %d (%s)\n",
		     bstrWriterName,
		     pwszWriterId,
		     pwszInstanceId,
		     usage,
		     GetStringFromUsageType (usage),
		     source,
		     GetStringFromSourceType (source));

	    RpcStringFree (&pwszInstanceId);
	    RpcStringFree (&pwszWriterId);
	    }


	CHECK_SUCCESS (pvbc->FreeWriterMetadata());
	}
    catch(...)
	{
	hr = E_UNEXPECTED;
	}


    if (FAILED(hr)) wprintf (L"Failed with 0x%08X.\n", hr);

    return (hr);
    }




HRESULT ShowAnnouncement (void)
    {
    wprintf (L"\n"
	     L"\t%s\n\n"
	     L"\t\n",
	     PROGRAM_TITLE);


    return (NOERROR);
    }



HRESULT ShowHelp (void)
    {
    wprintf (L"\n\n"
	     L"\t%s\n\n"
	     L"\t\n"
	     L"\t    Commands:\n"
	     L"\t\n"
	     L"\t        help\n"
	     L"\t        exit\n"
	     L"\t        quit\n"
	     L"\t        metadata\n"
	     L"\t        writers\n"
	     L"\t        set\n"
	     L"\t        add\n"
	     L"\t        create\n"
	     L"\t        delete\n"
	     L"\t\n"
	     L"\t\n"
	     L"\tOnce the snapshots are created use DosDev to map a drive letter to\n"
	     L"\tthe snapshot devices for convenient access\n"
	     L"\t\n"
	     L"\te.g. DosDev u: \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeSnapshot1\n"
	     L"\t\n",
	     PROGRAM_TITLE);


    return (NOERROR);
    }







HRESULT CreateSnapshotSet (PCONTEXTSNAPSHOTSET pctxSnapshotSet)
    {
    HRESULT	hrStatus = NOERROR;
    PIVssAsync  pIVssAsync;


    hrStatus = CreateVssBackupComponents (&pctxSnapshotSet->pIVssBackupComponents);

    hrStatus = pctxSnapshotSet->pIVssBackupComponents->InitializeForBackup ();


    hrStatus = pctxSnapshotSet->pIVssBackupComponents->GatherWriterMetadata (&pIVssAsync);
    hrStatus = pIVssAsync->Wait ();
    hrStatus = pIVssAsync->QueryStatus (&hrStatus, NULL);


    hrStatus = pctxSnapshotSet->pIVssBackupComponents->SetBackupState (true, 
								       pctxSnapshotSet->bIncludeBootableState, 
								       VSS_BT_FULL);

    hrStatus = pctxSnapshotSet->pIVssBackupComponents->StartSnapshotSet (&pctxSnapshotSet->guidSnapshotSetId);


    if (SUCCEEDED (hrStatus))
	{
	WCHAR awchGuidBuffer [65];


	FormatGUID (pctxSnapshotSet->guidSnapshotSetId,
		    awchGuidBuffer,
		    sizeof (awchGuidBuffer));

	wprintf (L"Created snapshot set %s\n\n", awchGuidBuffer);

	pctxSnapshotSet->eState = STATE_SNAPSHOT_SET_CREATED;
	}

    else
	{
	wprintf (L"ERROR - Unable to create snapshot set (0x%08X)\n\n", hrStatus);
	}


    return (hrStatus);
    }



HRESULT AddVolume (PCONTEXTSNAPSHOTSET pctxSnapshotSet)
    {
    HRESULT	hrStatus         = NOERROR;
    size_t	ulArgumentLength = 0;
    ULONG	ulIndexVolume    = 0;
    BOOL	bSupported       = FALSE;


    if (STATE_SNAPSHOT_SET_CREATED != pctxSnapshotSet->eState)
	{
	wprintf (L"ERROR - Unable to add volumes add this time (%d)\n\n", pctxSnapshotSet->eState);
	}


    else if (pctxSnapshotSet->ulVolumesInSnapshotSet >= SIZEOF_ARRAY (pctxSnapshotSet->pwszVolumeArgument))
	{
	wprintf (L"ERROR - Maximum number of volumes already present in snapshot set\n\n");
	}


    else if ((NULL != g_pwchNextArgument) && (ulArgumentLength = wcslen (g_pwchNextArgument)) > 0)
	{
	ulIndexVolume = pctxSnapshotSet->ulVolumesInSnapshotSet;

	pctxSnapshotSet->pwszVolumeArgument [ulIndexVolume] = (PWSTR) calloc (ulArgumentLength + 1, sizeof (WCHAR));

	wcscpy (pctxSnapshotSet->pwszVolumeArgument [ulIndexVolume], g_pwchNextArgument);

	hrStatus = GetVolumeNameFromArgument (pctxSnapshotSet->pwszVolumeArgument [ulIndexVolume],
					      &pctxSnapshotSet->pwszVolumeName [ulIndexVolume]);

	hrStatus = pctxSnapshotSet->pIVssBackupComponents->IsVolumeSupported (GUID_NULL, 
									      pctxSnapshotSet->pwszVolumeName [ulIndexVolume], 
									      &bSupported);

	if (bSupported)
	    {
	    hrStatus = pctxSnapshotSet->pIVssBackupComponents->AddToSnapshotSet (pctxSnapshotSet->pwszVolumeName [ulIndexVolume],
										 GUID_NULL, 
										 &pctxSnapshotSet->SnapshotId [ulIndexVolume]);

	    if (SUCCEEDED (hrStatus))
		{
		pctxSnapshotSet->ulVolumesInSnapshotSet++;

		wprintf (L"Added volume '%s' (%s) to snapshot set\n\n",
			 pctxSnapshotSet->pwszVolumeName     [ulIndexVolume],
			 pctxSnapshotSet->pwszVolumeArgument [ulIndexVolume]);
		}

	    else
		{
		wprintf (L"ERROR - Unable to add volume '%s' (%s) to snapshot set (0x%08X)\n\n",
			 pctxSnapshotSet->pwszVolumeName     [ulIndexVolume],
			 pctxSnapshotSet->pwszVolumeArgument [ulIndexVolume],
			 hrStatus);
		}
	    }
	}


    else
	{
	wprintf (L"ERROR - Missing argument\n\n");
	}




    return (hrStatus);
    }


HRESULT CreateSnapshot (PCONTEXTSNAPSHOTSET pctxSnapshotSet)
    {
    HRESULT	hrStatus      = NOERROR;
    ULONG	ulIndexVolume = 0;
    PIVssAsync  pIVssAsync;



    hrStatus = pctxSnapshotSet->pIVssBackupComponents->PrepareForBackup (&pIVssAsync);
    hrStatus = pIVssAsync->Wait ();
    hrStatus = pIVssAsync->QueryStatus (&hrStatus, NULL);


    /*
    ** Could check the status of all the writers at this point but we choose to press on regardless.
    */


    hrStatus = pctxSnapshotSet->pIVssBackupComponents->DoSnapshotSet (&pctxSnapshotSet->pIVssAsyncDoSnapshotSet);
    hrStatus = pctxSnapshotSet->pIVssAsyncDoSnapshotSet->Wait ();
    hrStatus = pctxSnapshotSet->pIVssAsyncDoSnapshotSet->QueryStatus (&hrStatus, NULL);


    /*
    ** Could check the status of all the writers at this point but we choose to press on regardless.
    */


    for (ulIndexVolume = 0; ulIndexVolume < pctxSnapshotSet->ulVolumesInSnapshotSet; ulIndexVolume++) 
	{
	hrStatus = pctxSnapshotSet->pIVssBackupComponents->GetSnapshotProperties (pctxSnapshotSet->SnapshotId [ulIndexVolume], 
										  &pctxSnapshotSet->SnapshotProperties [ulIndexVolume]);
	}



    wprintf (L"Created snapshots for the following volume%s:\n", 
	     pctxSnapshotSet->ulVolumesInSnapshotSet > 1 ? "s" : "");

    for (ulIndexVolume = 0; ulIndexVolume < pctxSnapshotSet->ulVolumesInSnapshotSet; ulIndexVolume++) 
	{
	wprintf (L"    %s for volume %s (%s)\n",
		 pctxSnapshotSet->SnapshotProperties [ulIndexVolume].m_pwszSnapshotDeviceObject,
		 pctxSnapshotSet->pwszVolumeName     [ulIndexVolume], // or SnapshotProperties [ulIndexVolume].m_pwszSnapshotOriginalVolumeName
		 pctxSnapshotSet->pwszVolumeArgument [ulIndexVolume]);
	}


    wprintf (L"\n");


    return (hrStatus);
    }


HRESULT DeleteSnapshot (PCONTEXTSNAPSHOTSET pctxSnapshotSet)
    {
    HRESULT	hrStatus = NOERROR;

    CleanupSnapshotSet (pctxSnapshotSet);


    return (hrStatus);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\testprv\src\diff.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Diff.cxx | Diff area object implementation
    @end

Author:

    Adi Oltean  [aoltean]   01/24/2000

Revision History:

    Name        Date        Comments

    aoltean     01/24/2000  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL headers
#include "vss.h"
#include "vscoordint.h"
#include "vsswprv.h"
#include "vsprov.h"

#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "diff.hxx"

#include "ntddsnap.h"


/////////////////////////////////////////////////////////////////////////////
//  Operations


CVsDiffArea::CVsDiffArea()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsDiffArea::CVsDiffArea" );

	try
	{
		m_cs.Init();
	}
	VSS_STANDARD_CATCH(ft)

}


CVsDiffArea::~CVsDiffArea()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsDiffArea::~CVsDiffArea" );

	try
	{
		m_cs.Term();
	}
	VSS_STANDARD_CATCH(ft)

}


HRESULT CVsDiffArea::Initialize(
    IN      LPCWSTR pwszVolumeMountPoint	// DO NOT transfer ownership
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::Initialize" );

    try
    {
		// Test the arguments
		if ((pwszVolumeMountPoint == NULL) ||
			(pwszVolumeMountPoint[0] == L'\0'))
			ft.Throw(VSSDBG_SWPRV, E_INVALIDARG, L"NULL volume mount point");

    	// Convert the volume mount point into a volume name
    	WCHAR wszVolumeName[MAX_PATH];
		if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeMountPoint,
				wszVolumeName, ARRAY_LEN(wszVolumeName)))
			ft.Throw( VSSDBG_COORD, E_INVALIDARG,
					  L"Invalid pwszVolumeMountPoint. GetVolumeNameForVolumeMountPoint "
					  L"failed with error code 0x%08lx", pwszVolumeMountPoint, GetLastError());
		BS_ASSERT(::wcslen(wszVolumeName) != 0);
    		
		// Eliminate the last backslash from the volume name.
        EliminateLastBackslash(wszVolumeName);

		// Opening the channel
        // (if already opened then it will be closed automatically)
		m_volumeIChannel.Open(ft, wszVolumeName);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  Interface methods

STDMETHODIMP CVsDiffArea::AddVolume(                      			
    IN      VSS_PWSZ pwszVolumeMountPoint						
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::AddVolume" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

		// Test arguments
        if (pwszVolumeMountPoint == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pwszVolumeName");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock lock(m_cs);

		BS_ASSERT(m_volumeIChannel.IsOpen());

    	// Convert the volume mount point into a volume name
    	WCHAR wszVolumeName[MAX_PATH];
		if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeMountPoint,
				wszVolumeName, ARRAY_LEN(wszVolumeName)))
			ft.Throw( VSSDBG_COORD, E_INVALIDARG,
					  L"Invalid pwszVolumeMountPoint. GetVolumeNameForVolumeMountPoint "
					  L"failed with error code 0x%08lx", pwszVolumeMountPoint, GetLastError());
		BS_ASSERT(::wcslen(wszVolumeName) != 0);

		if (!::ConvertVolMgmtVolumeNameIntoKernelObject(wszVolumeName))
			ft.Throw( VSSDBG_COORD, E_INVALIDARG,
					  L"ConvertVolMgmtVolumeNameIntoKernelObject failed. Invalid volume name %s",
					  wszVolumeName);

		// Send the IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA ioctl
    	m_volumeIChannel.PackSmallString(ft, wszVolumeName);
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsDiffArea::Query(									
    OUT     IVssEnumObject **ppEnum					
    )												
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::Query" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"ppEnum = %p", ppEnum);

        // Argument validation
		BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock lock(m_cs);

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// GEt the list of volumes that are part of the diff area
		BS_ASSERT(m_volumeIChannel.IsOpen());
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_DIFF_AREA);

		// Get the length of snapshot names multistring
		ULONG ulMultiszLen;
		m_volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
		// Try to find the snapshot with the corresponding Id
		DWORD dwInitialOffset = m_volumeIChannel.GetCurrentOutputOffset();
#endif

		LPWSTR pwszVolumeName = NULL;
		while(m_volumeIChannel.UnpackZeroString(ft, pwszVolumeName))
		{
			// Compose the volume name in a user-mode style
			WCHAR wszMountPoint[MAX_PATH];
			if (::_snwprintf(wszMountPoint, MAX_PATH - 1,
					L"\\\\?\\GLOBALROOT%s\\", pwszVolumeName) < 0)
				ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Not enough memory." );

			// Get the mount point for the volume name
	    	WCHAR wszUserModeVolumeName[MAX_PATH];
			if (!::GetVolumeNameForVolumeMountPointW( wszMountPoint,
					wszUserModeVolumeName, MAX_PATH))
				ft.Throw( VSSDBG_COORD, E_INVALIDARG,
						  L"Invalid wszMountPoint. GetVolumeNameForVolumeMountPoint "
						  L"failed with error code 0x%08lx", wszMountPoint, GetLastError());
			BS_ASSERT(::wcslen(wszUserModeVolumeName) != 0);

			// Get the volume ID
			VSS_ID VolumeId;
			if (!GetVolumeGuid(wszUserModeVolumeName, VolumeId))
			{
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
						L"Cannot get the volume Id for %s.",
						wszUserModeVolumeName);
			}

			// Initialize an empty volume properties structure
			VSS_OBJECT_PROP_Ptr ptrVolProp;
			ptrVolProp.InitializeAsVolume( ft,
				VolumeId,
				0,
				wszUserModeVolumeName,
				pwszVolumeName,
				VSS_SWPRV_ProviderId);

			if (!pArray->Add(ptrVolProp))
				ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Cannot add element to the array");

			// Reset the current pointer to NULL
			ptrVolProp.Reset(); // The internal pointer was detached into pArray.
		}

#ifdef _DEBUG
		// Check if all strings were browsed correctly
		DWORD dwFinalOffset = m_volumeIChannel.GetCurrentOutputOffset();
		BS_ASSERT( dwFinalOffset - dwInitialOffset == ulMultiszLen);
#endif

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
		// So if a throw occurs the enumerator object will be safely destroyed by the smart ptr.
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object.
		// The array's reference count becomes now 2, because IEnumOnSTLImpl::m_spUnk is also a smart ptr.
        BS_ASSERT(pArray);
		ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Cannot initialize enumerator instance. [0x%08lx]", ft.hr);

        // Initialize the enumerator object.
		// The enumerator reference count becomes now 2.
        ft.hr = pUnknown->SafeQI(IVssEnumObject, ppEnum);
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Error querying the IVssEnumObject interface. hr = 0x%08lx", ft.hr);
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsDiffArea::Clear(                      				
    )												
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::Clear" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock lock(m_cs);

		// Clear the diff area on the current volume
		BS_ASSERT(m_volumeIChannel.IsOpen());
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_CLEAR_DIFF_AREA);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsDiffArea::GetUsedVolumeSpace(
    OUT      LONGLONG* pllBytes						
    )												
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::GetUsedVolumeSpace" );

    try
    {
		::VssZeroOut(pllBytes);

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"pllBytes = %p", pllBytes);

        // Argument validation
		BS_ASSERT(pllBytes);
        if (pllBytes == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pllBytes");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock lock(m_cs);

		VOLSNAP_DIFF_AREA_SIZES strSizes;

		// Get the sizes
		BS_ASSERT(m_volumeIChannel.IsOpen());
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES);
    	m_volumeIChannel.Unpack(ft, &strSizes);

		*pllBytes = strSizes.UsedVolumeSpace;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsDiffArea::GetAllocatedVolumeSpace(               	
    OUT      LONGLONG* pllBytes						
    )												
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::GetAllocatedVolumeSpace" );

    try
    {
		::VssZeroOut(pllBytes);

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"pllBytes = %p", pllBytes);

        // Argument validation
		BS_ASSERT(pllBytes);
        if (pllBytes == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pllBytes");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock lock(m_cs);

		VOLSNAP_DIFF_AREA_SIZES strSizes;

		// Get the sizes
		BS_ASSERT(m_volumeIChannel.IsOpen());
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES);
    	m_volumeIChannel.Unpack(ft, &strSizes);

		*pllBytes = strSizes.AllocatedVolumeSpace;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsDiffArea::GetMaximumVolumeSpace(              		
    OUT      LONGLONG* pllBytes						
    )												
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::GetMaximumVolumeSpace" );

    try
    {
		::VssZeroOut(pllBytes);

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"pllBytes = %p", pllBytes);

        // Argument validation
		BS_ASSERT(pllBytes);
        if (pllBytes == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pllBytes");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock lock(m_cs);

		VOLSNAP_DIFF_AREA_SIZES strSizes;

		// Get the sizes
		BS_ASSERT(m_volumeIChannel.IsOpen());
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES);
    	m_volumeIChannel.Unpack(ft, &strSizes);

		*pllBytes = strSizes.MaximumVolumeSpace;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsDiffArea::SetAllocatedVolumeSpace(               	
    IN      LONGLONG llBytes						
    )												
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::SetAllocatedVolumeSpace" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"llBytes = " WSTR_LONGLONG_FMT, LONGLONG_PRINTF_ARG(llBytes));

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock lock(m_cs);

		VOLSNAP_DIFF_AREA_SIZES strSizes;

		// Get the sizes
		BS_ASSERT(m_volumeIChannel.IsOpen());
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES);
    	m_volumeIChannel.Unpack(ft, &strSizes);

        // Argument validation
        // TBD: Supplementary checks?
        if (llBytes < strSizes.UsedVolumeSpace)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG,
            			L"Used volume space bigger: " WSTR_LONGLONG_FMT,
            			LONGLONG_PRINTF_ARG(strSizes.UsedVolumeSpace));

		strSizes.AllocatedVolumeSpace = llBytes;

		if (strSizes.MaximumVolumeSpace < llBytes)
			strSizes.MaximumVolumeSpace = llBytes;

		// Set the sizes
    	m_volumeIChannel.Pack(ft, strSizes);
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_SET_DIFF_AREA_SIZES);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsDiffArea::SetMaximumVolumeSpace(
    IN      LONGLONG llBytes						
    )												
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::SetMaximumVolumeSpace" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"llBytes = " WSTR_LONGLONG_FMT, LONGLONG_PRINTF_ARG(llBytes));

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock lock(m_cs);

		VOLSNAP_DIFF_AREA_SIZES strSizes;

		// Get the sizes
		BS_ASSERT(m_volumeIChannel.IsOpen());
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES);
    	m_volumeIChannel.Unpack(ft, &strSizes);

        // Argument validation
        // TBD: Supplementary checks?
        if (llBytes < strSizes.UsedVolumeSpace)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG,
            			L"Used volume space bigger: " WSTR_LONGLONG_FMT,
            			LONGLONG_PRINTF_ARG(strSizes.UsedVolumeSpace));

		strSizes.MaximumVolumeSpace = llBytes;

		// Set the sizes
    	m_volumeIChannel.Pack(ft, strSizes);
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_SET_DIFF_AREA_SIZES);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\testprv\src\find.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Find.hxx | Defines the internal snapshot persistency-related methods.
    @end

Author:

    Adi Oltean  [aoltean]   01/10/2000

Revision History:

    Name        Date        Comments

    aoltean     01/10/2000  Created.


--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL header
#include "vss.h"
#include "vscoordint.h"
#include "vsswprv.h"
#include "vsprov.h"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"

#include "ntddsnap.h"


/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot::SaveXXX methods
//


void CVssQueuedSnapshot::EnumerateSnasphots(
	IN	CVssFunctionTracer& ft,
	IN	VSS_QUERY_TYPE eQueryType,
	IN	VSS_OBJECT_TYPE eObjectType,
	IN	LONG lMask,
	IN	VSS_ID&	FilterID,
	VSS_OBJECT_PROP_Array* pArray
	) throw(HRESULT)

/*++

Description:

	This method enumerates all snapshots

	It throws VSS_E_OBJECT_NOT_FOUND if no filter object was found.

--*/

{	
	// Reset the error code
	ft.hr = S_OK;
		
	HANDLE hSearch = INVALID_HANDLE_VALUE;
	LPWSTR pwszSnapshotName = NULL;

	try
	{
		// Enumerate snapshots through all the volumes
		CVssIOCTLChannel volumeIChannel;
		CVssIOCTLChannel snapshotIChannel;
		WCHAR wszVolumeName[MAX_PATH+1];
		bool bFirstVolume = true;
		bool bContinueWithVolumes = true;
		bool bFilterObjectFound = false;
		while(true) {
			// Get the volume name
			if (bFirstVolume) {
				hSearch = ::FindFirstVolumeW( wszVolumeName, MAX_PATH);
				if (hSearch == INVALID_HANDLE_VALUE)
					ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Error on FindFirstVolume 0x%08lx", GetLastError());
				bFirstVolume = false;
			} else {
				if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
					if (GetLastError() == ERROR_NO_MORE_FILES)
						break;	// End of iteration
					else
						ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Error on FindNextVolume 0x%08lx", GetLastError());
				}
			}

			// Get the volume Id
			VSS_ID OriginalVolumeId;
			if (!GetVolumeGuid(wszVolumeName, OriginalVolumeId)) {
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
						L"Cannot get the original volume Id for %s.",
						wszVolumeName);
			}

			// Eliminate the last backslash in order to open the volume
			EliminateLastBackslash(wszVolumeName);

			// Check if the snapshot is belonging to that volume
			// Open a IOCTL channel on that volume
			volumeIChannel.Open(ft, wszVolumeName);

			// Get the list of snapshots
			// If IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS not
			// supported then try with the next volume.

			ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, false);
			if (ft.HrFailed()) {
				ft.hr = S_OK;
				continue;
			}

			// If we want to find a certain volume
			if ( (eObjectType == VSS_OBJECT_VOLUME) && ( eQueryType == VSS_FIND_BY_VOLUME) )
			{
				// Test if condition is reached
				if (OriginalVolumeId != FilterID)
					continue;
			
				// Initialize an empty volume properties structure
				VSS_OBJECT_PROP_Ptr ptrVolProp;
				ptrVolProp.InitializeAsVolume( ft,
					OriginalVolumeId,
					0,
					(lMask & VSS_PM_NAME_FLAG)? wszVolumeName: NULL,
					NULL,
					VSS_SWPRV_ProviderId);

				if (!pArray->Add(ptrVolProp))
					ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
							  L"Cannot add element to the array");

				// Reset the current pointer to NULL
				ptrVolProp.Reset(); // The internal pointer was detached into pArray.

				// Mark that an object (i.e. a volume) was found
				bFilterObjectFound = true;
			}
			// If we want to find all supported volumes
			else if ( (eObjectType == VSS_OBJECT_VOLUME) && (eQueryType == VSS_FIND_ALL) )
			{
				// Initialize an empty volume properties structure
				VSS_OBJECT_PROP_Ptr ptrVolProp;
				ptrVolProp.InitializeAsVolume( ft,
					OriginalVolumeId,
					0,
					(lMask & VSS_PM_NAME_FLAG)? wszVolumeName: NULL,
					NULL,
					VSS_SWPRV_ProviderId);

				if (!pArray->Add(ptrVolProp))
					ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
							  L"Cannot add element to the array");

				// Since there is no filter criteria, the returned error cannot be VSS_E_OBJECT_NOT_FOUND
				bFilterObjectFound = true;
				
				// Reset the current pointer to NULL
				ptrVolProp.Reset(); // The internal pointer was detached into pArray.
			// If we want to find a other kind of objects that require a snapshot opening
			} else {
				// Get the length of snapshot names multistring
				ULONG ulMultiszLen;
				volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
				// Try to find the snapshot with the corresponding Id
				DWORD dwInitialOffset = volumeIChannel.GetCurrentOutputOffset();
#endif

				bool bContinueWithSnapshots = true;
				while(volumeIChannel.UnpackZeroString(ft, pwszSnapshotName)) {
					// Compose the snapshot name in a user-mode style
					WCHAR wszUserModeSnapshotName[MAX_PATH];
					if (::_snwprintf(wszUserModeSnapshotName, MAX_PATH - 1,
							L"\\\\?\\GLOBALROOT%s", pwszSnapshotName) < 0)
						ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Not enough memory." );
				
					// Open that snapshot and verify if it has our ID
					ft.hr = snapshotIChannel.Open(ft, wszUserModeSnapshotName, false);
					if (ft.HrFailed()) {
						ft.Warning( VSSDBG_SWPRV, L"Warning: Error opening the snapshot device name %s [0x%08lx]",
									wszUserModeSnapshotName, ft.hr );
						continue;
					}

					// Get the application buffer
					ft.hr = snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, false);
					if (ft.HrFailed()) {
						ft.Warning( VSSDBG_SWPRV,
									L"Warning: Error sending the query IOCTL to the snapshot device name %s [0x%08lx]",
									wszUserModeSnapshotName, ft.hr );
						continue;
					}

					// Get the length of the application buffer
					ULONG ulLen;
					snapshotIChannel.Unpack(ft, &ulLen);

					if (ulLen == 0) {
						ft.Warning(VSSDBG_SWPRV, L"Warning: zero-size snapshot detected: %s", pwszSnapshotName);
						continue;
					}

					// Get the snapshot Id
					VSS_ID CurrentSnapshotId;
					snapshotIChannel.Unpack(ft, &CurrentSnapshotId);

					// Get the snapshot set Id
					VSS_ID CurrentSnapshotSetId;
					snapshotIChannel.Unpack(ft, &CurrentSnapshotSetId);

					// Process the snapshot that was just found
					ProcessSnapshot( ft, eQueryType, eObjectType, lMask,
					 	FilterID, CurrentSnapshotId, CurrentSnapshotSetId,OriginalVolumeId,
						snapshotIChannel,
					 	wszVolumeName,pwszSnapshotName,
					 	bContinueWithSnapshots, bContinueWithVolumes, bFilterObjectFound, pArray);
					if (!bContinueWithSnapshots)
						break;
				}

#ifdef _DEBUG
				// Check if all strings were browsed correctly
				DWORD dwFinalOffset = volumeIChannel.GetCurrentOutputOffset();
				BS_ASSERT( dwFinalOffset - dwInitialOffset == ulMultiszLen);
#endif
			}
			
			// If a snapshot was found with that Id then stop.
			if (!bContinueWithVolumes)
				break;

		}

		// If the filter object was not found then throw the proper error
		if (!bFilterObjectFound)
			ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"Object not found");

	}
	VSS_STANDARD_CATCH(ft)

	// Close the search handle, if needed
	if (hSearch != INVALID_HANDLE_VALUE) {
		if (!::FindVolumeClose(hSearch))
			ft.Trace( VSSDBG_SWPRV, L"Error while closing the search handle 0x%08lx", GetLastError());
	}

	::VssFreeString(pwszSnapshotName);

	if (ft.HrFailed())
		ft.Throw( VSSDBG_SWPRV, ft.hr, L"Error while searching the snapshot 0x%08lx", ft.hr);
}


void CVssQueuedSnapshot::ProcessSnapshot(
	IN	CVssFunctionTracer& ft,
	IN	VSS_QUERY_TYPE eQueryType,
	IN	VSS_OBJECT_TYPE eObjectType,
	IN	LONG lMask,
	IN	VSS_ID&	FilterID,
	IN	VSS_ID&	SnapshotID,
	IN	VSS_ID&	SnapshotSetID,
	IN	VSS_ID& OriginalVolumeId,
	IN	CVssIOCTLChannel& snapshotIChannel,
	IN	LPWSTR	wszVolumeName,
	IN	LPWSTR	wszSnapshotName,
	OUT bool& bContinueWithSnapshots,
	OUT bool& bContinueWithVolumes,
	OUT bool& bFilterObjectFound,
	IN OUT	VSS_OBJECT_PROP_Array* pArray
	) throw(HRESULT)

/*++

Description:

	It is called to process each snapshot enumerated in process above.
	Mainly based on the parameters it will construct the appropriate objects and fill the array.

TBD:

	Optimize the lMask thing.

--*/

{
	WCHAR wszFunctionName[] = L"CVssQueuedSnapshot::ProcessSnapshot";

	// Reset the error code
	ft.hr = S_OK;
		
	// Perform filtering
	switch(eQueryType) {
	case VSS_FIND_BY_SNAPSHOT_SET_ID:
		if (SnapshotSetID != FilterID)
			return;
		else
			break;
	case VSS_FIND_BY_SNAPSHOT_ID:
		if (SnapshotID != FilterID)
			return;
		else
			break;
	case VSS_FIND_BY_VOLUME:
		if (OriginalVolumeId != FilterID)
			return;
		else
			break;
	case VSS_FIND_ALL:
		break;
		
	default:
		BS_ASSERT(false);
		ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Invalid query type %d", eQueryType);
	}

	// Mark that the filter object was found
	bFilterObjectFound = true;

	// Compute properties for the final objects
	switch(eObjectType) {
 	case VSS_OBJECT_SNAPSHOT_SET: {

			// Load the snapshot set properties
			LONG lSnapshotsCount;
			snapshotIChannel.Unpack(ft, &lSnapshotsCount);
			VSS_OBJECT_PROP_Ptr ptrSnapSetProp;
			ptrSnapSetProp.InitializeAsSnapshotSet(ft, SnapshotSetID, lSnapshotsCount);
			
			// Detect duplicates
			bool bSnapshotSetAlreadyInserted = false;
			for (int nIndex = 0; nIndex < pArray->GetSize(); nIndex++) {
				// Get the snapshot set structure object from the array
				VSS_OBJECT_PROP_Ptr& ptrProcessedSnapSet = (*pArray)[nIndex];

				// Get the snapshot structure
		        if (ptrProcessedSnapSet.GetStruct() == NULL) {
		        	BS_ASSERT(false);
		        	continue;
		        }
		
				if (ptrProcessedSnapSet.GetStruct()->Type != VSS_OBJECT_SNAPSHOT_SET) {
					BS_ASSERT(false);
					continue;
				}

				// Check if the snapshot set was already inserted
				VSS_SNAPSHOT_SET_PROP& SSProp = ptrProcessedSnapSet.GetStruct()->Obj.Set;
				if (SSProp.m_SnapshotSetId == SnapshotSetID) {
					bSnapshotSetAlreadyInserted = true;

					// Check if the SS properties are identical in each snapshot.
					if (SSProp.m_lSnapshotsCount != lSnapshotsCount)
						ft.Trace( VSSDBG_SWPRV, L"Bad number of snapshots %ld in snapshot set definition %ld",
							lSnapshotsCount, SSProp.m_lSnapshotsCount);
					break;
				}
			}

			// Add the snapshot set into the array, if not already added.
			if (!bSnapshotSetAlreadyInserted)
			{
				if (!pArray->Add(ptrSnapSetProp))
					ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
							  L"%s: Cannot add element to the array", wszFunctionName);
			}

			// Reset the current pointer to NULL
			ptrSnapSetProp.Reset(); // The internal pointer was detached into pArray.
		} break;
		
	case VSS_OBJECT_SNAPSHOT: {
			// Initialize an empty snapshot properties structure
			VSS_OBJECT_PROP_Ptr ptrSnapProp;
			ptrSnapProp.InitializeAsSnapshot( ft,
				SnapshotID,
				SnapshotSetID,
				NULL,
				(lMask & VSS_PM_NAME_FLAG)? wszSnapshotName: NULL,
				OriginalVolumeId,
				(lMask & VSS_PM_ORIGINAL_NAME_FLAG)? wszVolumeName: NULL,
				VSS_SWPRV_ProviderId,
				NULL,
				0,
				0,
				VSS_SS_UNKNOWN,
				0,0,0,NULL);

			// Get the snapshot structure
			VSS_OBJECT_PROP* pObj = ptrSnapProp.GetStruct();
			BS_ASSERT(pObj);
			VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);

			// Temporary variables (ignored)
			// TBD: get rid of them
			LONG lSnapshotsCount;
			DWORD dwGlobalReservedField;
			USHORT usNumberOfNonstdSnapProperties;
			CVssGenericSnapProperties* pOpaqueSnapPropertiesList = NULL;
			USHORT usReserved;

			// Load the rest of properties
			// Do not load the Name and the Original volume name fields
			// twice since they are already known
			lMask &= ~(VSS_PM_ORIGINAL_NAME_FLAG | VSS_PM_NAME_FLAG);
			LoadSnapshotStructuresExceptIDs(ft, snapshotIChannel,pSnap,lMask, true,
				lSnapshotsCount,dwGlobalReservedField,
				usNumberOfNonstdSnapProperties,pOpaqueSnapPropertiesList,usReserved);

			if (!pArray->Add(ptrSnapProp))
				ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
						  L"%s: Cannot add element to the array", wszFunctionName);

			// Reset the current pointer to NULL
			ptrSnapProp.Reset(); // The internal pointer was detached into pArray.
		} break;
		
 	case VSS_OBJECT_VOLUME: {
			// Initialize an empty volume properties structure
			VSS_OBJECT_PROP_Ptr ptrVolProp;
			ptrVolProp.InitializeAsVolume( ft,
				OriginalVolumeId,
				0,
				(lMask & VSS_PM_NAME_FLAG)? wszVolumeName: NULL,
				NULL,
				VSS_SWPRV_ProviderId);

			if (!pArray->Add(ptrVolProp))
				ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
						  L"%s: Cannot add element to the array", wszFunctionName);

			// Reset the current pointer to NULL
			ptrVolProp.Reset(); // The internal pointer was detached into pArray.
		} break;
		
	default:
		BS_ASSERT(false);
		ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Invalid query type %d", eObjectType);
	}

	bContinueWithSnapshots =
		(eQueryType == VSS_FIND_BY_VOLUME || eQueryType == VSS_FIND_ALL)
		&& (eObjectType == VSS_OBJECT_SNAPSHOT_SET || eObjectType == VSS_OBJECT_SNAPSHOT );

	bContinueWithVolumes = (eQueryType == VSS_FIND_BY_SNAPSHOT_SET_ID)
		&& (eObjectType == VSS_OBJECT_SNAPSHOT || eObjectType == VSS_OBJECT_VOLUME )
		|| (eQueryType == VSS_FIND_ALL);
}


bool CVssQueuedSnapshot::FindDeviceNameFromID(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)

/*++

Description:

	Finds a snapshot device name based on its ID.

--*/
{
	// Reset the error code
	ft.hr = S_OK;
		
 	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	if (pProp == NULL) {
		BS_ASSERT(false);
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
	}

	BS_ASSERT(IsDuringCreation());
	BS_ASSERT(pProp->m_SnapshotId != GUID_NULL);
	BS_ASSERT(pProp->m_pwszSnapshotDeviceObject == NULL);

    // Create the collection object. Initial reference count is 0.
    VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
    if (pArray == NULL)
        ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

    // Get the pointer to the IUnknown interface.
	// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
	// Now pArray's reference count becomes 1 (because of the smart pointer).
    CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
    BS_ASSERT(pArrayItf);

    // Put into the array only one element.
    EnumerateSnasphots(ft,
    	VSS_FIND_BY_SNAPSHOT_ID,
    	VSS_OBJECT_SNAPSHOT,
    	VSS_PM_DEVICE_FLAG,
    	pProp->m_SnapshotId,
    	pArray);

    // Extract the element from the array.
    if (pArray->GetSize() == 0)
    	return false;

	VSS_OBJECT_PROP_Ptr& ptrObj = (*pArray)[0];
	VSS_OBJECT_PROP* pObj = ptrObj.GetStruct();
	BS_ASSERT(pObj);
	BS_ASSERT(pObj->Type == VSS_OBJECT_SNAPSHOT);
	VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);
	BS_ASSERT(pSnap->m_pwszSnapshotDeviceObject);
	::VssSafeDuplicateStr(ft, pProp->m_pwszSnapshotDeviceObject, pSnap->m_pwszSnapshotDeviceObject);

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\testprv\src\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cxx | The file used to compile the precompiled header
    @end

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.

--*/


#include "stdafx.hxx"
#include "swprv.hxx"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#pragma warning( disable: 4189 )  /* local variable is initialized but not referenced */
#include <atlimpl.cpp>
#pragma warning( default: 4189 )  /* local variable is initialized but not referenced */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\testprv\src\persist.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Persist.hxx | Defines the internal snapshot persistency-related methods.
    @end

Author:

    Adi Oltean  [aoltean]   01/10/2000

Revision History:

    Name        Date        Comments

    aoltean     01/10/2000  Created.


Storage Format for all structures:

	The snapshot structures for the MS Software Snapshot Provider
	have the following format:

	+-----------------+
	| Snapshot ID     |   GUID: Snapshot ID
	|                 |
	|                 |
	|                 |
	+-----------------+
	| Snapshot Set ID |   GUID: Snapshot Set ID
	|                 |
	|                 |
	|                 |
	+-----------------+
	| Snapshots count |   LONG: Snapshots count in the snapshot set.
	+-----------------+
	| Reserved        |   DWORD: Global reserved field. Can be zero.
	+-----------------+
	| #Structs  |      USHORT: Number of structures
	+--------------+
	| Struct1 ID   |   GUID: Unique structure format ID
	|              |
	+--------------+
	| Struct1 Len  |   DWORD: Structure length, in bytes.
	+--------------+
	| Struct1 data |   BYTE[]: Structure data
	| ...          |
	|              |
	+--------------+
	| Struct2 ID   |
	|              |
	+--------------+
	| Struct2 Len  |
	+--------------+
	| Struct2 data |
	| ...          |
	|              |
	+--------------+
	| ....         |
	+--------------+
	| StructN ID   |
	|              |
	+--------------+
	| StructN Len  |
	+--------------+
	| StructN data |
	| ...          |
	|              |
	+--------------+

	Each structure format may be dependent on the used CPU (alignment, byte ordering).
	The snapshot ID, snapshot set ID, etc. members above follows the x86 alignment and byte ordering format.

Storage format for the structure data for MS Software Provider version 1.0 for x86 and ia64 families:
	
	+--------+
	|Magic no|   USHORT: The magic number. Must be the VSS_SNAPSHOT_PROP length.
	+--------+
	|Reserved|   ULONG: Reserved field. Can be zero.
	+--------+
	| Len    |   USHORT: Details length, in WCHARs
	+--------+
	| Name   |   WCHAR[]: Details
	| ...    |
	+--------+
	| Flags  |   LONG: Commit flags
	+----------------+
	| Timestamp      |   VSS_TIMESTAMP: Creation timestamp
	|                |
	+----------------+
	| Status |   USHORT: Snapshot state
	+----------------+
	| Inc. no        |   LONGLONG: Incarnation number
	|                |
	+----------------+
	| Data len       |   LONG: Data length, in bytes
	+----------------+
	|Data|   BYTE[]: Data.
	|    |
	|    |
	+----+

Conventions:

	The meaning of fields set by this version of the MS Software Provider:

	 1) if "field value can be X" the provider:
	 - will write X onto that field when writing snapshot attributes at creation time.
	 - will write X' onto that field when writing snapshot attributes after creation time.
	   (X' = the previous value).
	 - will ignore the meaning of the field when reading snapshot attributes

	 2) if "field value must be X" the provider:
	 - will write X onto that field when writing snapshot attributes
	 - will throw an error if the field is not X when reading snapshot attributes

Storage place:

	typedef struct _VSS_SNAPSHOT_SET_PROP {						Method 						Set IOCTL								Get IOCTL								Remarks
		VSS_ID			m_SnapshotSetId;					//	SaveSnapshotPropertiesIoctl	IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO
		LONG			m_lSnapshotsCount;					//	SaveSnapshotPropertiesIoctl	IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO
	} VSS_SNAPSHOT_SET_PROP, *PVSS_SNAPSHOT_SET_PROP;

	typedef struct _VSS_SNAPSHOT_PROP {
		VSS_ID			m_SnapshotId;						//	SaveSnapshotPropertiesIoctl	IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO	We need a special IOCTL in the future
		VSS_ID			m_SnapshotSetId;					//	SaveSnapshotPropertiesIoctl	IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO	Mentioned above
		VSS_PWSZ		m_pwszSnapshotVolumeName;			//	GetSnapshotVolumeName		None									None									Computed at request from the snapshot device name.
		VSS_PWSZ		m_pwszSnapshotDeviceObject; 		//	None						IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS	None
		VSS_ID			m_OriginalVolumeId; 				//	LoadOriginalVolumeNameIoctl	IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME None									
		VSS_PWSZ		m_pwszOriginalVolumeName;			//	LoadOriginalVolumeNameIoctl	IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME None									Passed at creation
		VSS_ID			m_ProviderId;						//	None																None 									Already known (constant)
		LONG			m_lSnapshotAttributes;				//  Get/SetAttributes 			IOCTL_VOLSNAP_SET_ATTRIBUTE_INFO		IOCTL_VOLSNAP_QUERY_CONFIG_INFO			Also specified at creation
		VSS_PWSZ		m_pwszDetails;						//	SaveStandardStructure		IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO
		LONG			m_lCommitFlags; 					//	SaveStandardStructure		IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO
		VSS_TIMESTAMP	m_tsCreationTimestamp;				//	SaveStandardStructure		IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO
		VSS_SNAPSHOT_STATE	m_eStatus;						//	SaveStandardStructure		IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO
		LONGLONG		m_llIncarnationNumber;				//	SaveStandardStructure		IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO
		LONG			m_lDataLength;						//	SaveStandardStructure		IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO
		[size_is(m_lDataLength)] BYTE* m_pbOpaqueData;		//	SaveStandardStructure		IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO
	} VSS_SNAPSHOT_PROP, *PVSS_SNAPSHOT_PROP;				

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL header
#include "vss.h"
#include "vscoordint.h"
#include "vsswprv.h"
#include "vsprov.h"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"

#include "ntddsnap.h"


/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot::SaveXXX methods
//


HRESULT CVssQueuedSnapshot::SaveSnapshotPropertiesIoctl()

/*++

Description:

	This function will save the properties related to the snapshot

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::SaveSnapshotPropertiesIoctl");

	try
	{
		PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
		if (pProp == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
		}

		// Open the snapshot channel, if needed.
		OpenSnapshotChannel(ft);

		// Pack the length of the entire buffer
		PULONG pulBufferLength = m_snapIChannel.Pack(ft, (ULONG)0 ); // unknown right now
		
		// Start counting entire buffer length
		DWORD dwInitialOffset = m_snapIChannel.GetCurrentInputOffset();
		
		// Pack the Snapshot ID
		m_snapIChannel.Pack(ft, pProp->m_SnapshotId);
		
		// Pack the Snapshot Set ID
		m_snapIChannel.Pack(ft, pProp->m_SnapshotSetId);
		
		// Pack the number of snapshots in this snapshot set
		m_snapIChannel.Pack(ft, m_lSnapshotsCount);

		// Pack the reserved field - default value = 0
		m_snapIChannel.Pack(ft, m_dwGlobalReservedField);

		// Pack the number of structures (one standard and the rest nonstandard)
		m_snapIChannel.Pack(ft, (USHORT)(m_usNumberOfNonstdSnapProperties + 1));

		// Pack the standard properties structure,Save as the first one.
		SaveStandardStructure( ft, pProp );

		// Pack the non-standard properties structures (that were loaded by a previous call).
		if (CVssGenericSnapProperties* pNonstdElement = m_pOpaqueSnapPropertiesList)
			pNonstdElement->SaveRecursivelyIntoStream( ft, m_snapIChannel );
		
		// Compute the entire buffer length and save it.
		// TBD: move to ULONG
		DWORD dwFinalOffset = m_snapIChannel.GetCurrentInputOffset();
		
		BS_ASSERT( dwFinalOffset > dwInitialOffset );
		DWORD dwBufferLength = dwFinalOffset - dwInitialOffset;
		if ( dwBufferLength > (DWORD)((USHORT)(-1)) )
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
					L"Error: the buffer length cannot be stored in a USHORT %ld", dwBufferLength );
					
		BS_ASSERT( pulBufferLength );
		(*pulBufferLength) = (ULONG)dwBufferLength;
		BS_ASSERT( (DWORD)*pulBufferLength == dwBufferLength );

		// send the IOCTL
		m_snapIChannel.Call(ft, IOCTL_VOLSNAP_SET_APPLICATION_INFO);
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


void CVssQueuedSnapshot::SaveStandardStructure(
		IN	CVssFunctionTracer& ft,
		IN	PVSS_SNAPSHOT_PROP pProp
		) throw(HRESULT)
/*++

Description:

	This function will save the standard set of attributes (in this version of the provider)
	in the x86 and IA64 format.

--*/

{
	// Reset the error code
	ft.hr = S_OK;
		
	// Pack the structure Format ID
	m_snapIChannel.Pack(ft, guidSnapshotPropVersion10 );

	// Pack the length of the data structure
	PDWORD pdwStructureLength = m_snapIChannel.Pack(ft, (DWORD)0 ); // unknown right now

	// Start counting structure length
	DWORD dwInitialOffset = m_snapIChannel.GetCurrentInputOffset();
	
	// Pack the magic number
	m_snapIChannel.Pack(ft, (USHORT)sizeof(VSS_SNAPSHOT_PROP));
	
	// Pack the reserved field
	m_snapIChannel.Pack(ft, m_usReserved);
	
	//
	// Pack the contents of the snapshot structure
	//
	BS_ASSERT(pProp != NULL);
	
	// Pack the Details
	m_snapIChannel.PackSmallString(ft, pProp->m_pwszDetails);

	// Pack the Commit flags
	m_snapIChannel.Pack(ft, pProp->m_lCommitFlags);

	// Pack the creation timestamp
	m_snapIChannel.Pack(ft, pProp->m_tsCreationTimestamp);

	// Pack the status
	m_snapIChannel.Pack(ft, (USHORT)pProp->m_eStatus);

	// Pack the incarnation number
	m_snapIChannel.Pack(ft, pProp->m_llIncarnationNumber);

	// Pack the opaque length and data
	m_snapIChannel.Pack(ft, pProp->m_lDataLength);

	if (pProp->m_lDataLength)
	{
		BS_ASSERT(pProp->m_pbOpaqueData);
		m_snapIChannel.PackArray(ft, pProp->m_pbOpaqueData, pProp->m_lDataLength);
	}
	else
		BS_ASSERT(pProp->m_pbOpaqueData == NULL);
		
	// Complete the length of the data structure
	DWORD dwFinalOffset = m_snapIChannel.GetCurrentInputOffset();
	BS_ASSERT( dwFinalOffset > dwInitialOffset );
	
	BS_ASSERT(pdwStructureLength);
	(*pdwStructureLength) = dwFinalOffset - dwInitialOffset;
}


void CVssQueuedSnapshot::SetAttributes(
	IN	CVssFunctionTracer& ft,
	IN	ULONG lNewAttributes,		// New attributes
	IN	ULONG lBitsToChange 		// Mask of bits to be changed
	) throw(HRESULT)

/*++

Description:

	Load the snapshot attributes mask.
	Uses IOCTL_VOLSNAP_QUERY_CONFIG_INFO and IOCTL_VOLSNAP_SET_ATTRIBUTE_INFO.

Warning:

	The snapshot device name must be already known!

--*/

{
	/*

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	if (pProp == NULL)
	{
		BS_ASSERT(false);
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
	}

	// Open the snapshot channel, if needed.
	OpenSnapshotChannel(ft);

	// For all bits to be set
	for( LONG lRemainingBits = lBitsToChange; lRemainingBits; lRemainingBits &= lRemainingBits-1)
	{
		// Get the next bit (starting with the least signifiant bit that is set)
		LONG lNextBit = lRemainingBits ^ ~(lRemainingBits - 1);
		BS_ASSERT(lNextBit);

		// We do not rollback these changes!
		m_snapIChannel.Pack(ft, lNextBit);
		m_snapIChannel.Pack(ft, lNextBit & lNewAttibutes);
		
		// Send the IOCTL.
		m_snapIChannel.Call(ft, IOCTL_VOLSNAP_SET_ATTRIBUTE_INFO);
	}

	*/

	// Reset the error code
	ft.hr = S_OK;
		
	ft.Throw( VSSDBG_SWPRV, E_NOTIMPL, L"Set attributs not implemented");
	UNREFERENCED_PARAMETER(lNewAttributes);
	UNREFERENCED_PARAMETER(lBitsToChange);
}



/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot::LoadXXX methods
//



void CVssQueuedSnapshot::LoadSnapshotProperties(
	IN	CVssFunctionTracer& ft,
	IN	LONG lMask,
	IN	bool bGetOnly
	) throw(HRESULT)

/*++

Description:

	This method loads various properties of a snapshot.
	It can call:
		- LoadDeviceNameFromID to load the device name
		- LoadStandardStructures to load the properties kept in the Application data
		- LoadAttributes to load the attributes mask
		- GetSnapshotVolumeName to get the snapshot volume name
		- LoadOriginalVolumeIoctl for getting the original volume name

	If bGetOnly == true then this method was called in a Get call.
	Otherwise it was called in a Set call.

--*/

{
	// Reset the error code
	ft.hr = S_OK;
		
	// Get the snapshot properties structure
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	if (pProp == NULL)
	{
		BS_ASSERT(false);
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
	}

	// Assume that the Snapshot is completed
	BS_ASSERT(!IsDuringCreation());
	BS_ASSERT(pProp->m_SnapshotId != GUID_NULL);
	
	// If the device name is not completed, search for it
	if (pProp->m_pwszSnapshotDeviceObject == NULL)
	{
		// Try to find a created snapshot with this ID
		bool bFound = FindDeviceNameFromID(ft);
		
		// Handle the "snapshot not found" special error
		if (!bFound)
			ft.Throw(VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND,
					L"A snapshot with Id" WSTR_GUID_FMT L"was not found",
					GUID_PRINTF_ARG(pProp->m_SnapshotId) );
		BS_ASSERT(pProp->m_pwszSnapshotDeviceObject != NULL);
	}

	// Load the needed fields saved in snapshot header and standard structure
	// Do not load the non-standard structures since this is only a Get call
	ft.hr = LoadSnapshotStructures(lMask, bGetOnly);
	if (ft.HrFailed())
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Error loading snapshot properties");

	// Load the snapshot attributes, if needed
	if (lMask & VSS_PM_ATTRIBUTES_FLAG)
		LoadAttributes(ft);
	else
		pProp->m_lSnapshotAttributes = 0;

	if (pProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_VISIBLE)
	{
		// Get the snapshot volume name
		if (lMask & VSS_PM_NAME_FLAG)
			GetSnapshotVolumeName(ft, pProp);
	}

	// Get the original volume name and Id, if needed
	if (lMask & VSS_PM_ORIGINAL_NAME_FLAG)
		LoadOriginalVolumeNameIoctl(ft);
}


HRESULT CVssQueuedSnapshot::LoadSnapshotStructures(
	IN	LONG lMask,
	IN	bool bForGetOnly
	)

/*++

Description:

	Called for retrieving the attributes of snapshots.

	If bForGetOnly is true we will NOT load the non-standard structures and we
	will load only the fields indicated in the mask.
	
	If bForGetOnly is false then this call precedes a Set call. In consequence
	we will load the non-standard structures and all fields in the standard structure.

	For searchig for a certain snapshot use SearchSnapshot


TBD:

	Optimize to not load non-std structs when bForGetOnly = true.

Warning:

	The snapshot device name must be already known!

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadSnapshotStructures");

	try
	{

		// If the call is part of a Set then ignore lMask
		if (!bForGetOnly)
			lMask = VSS_PM_ALL_FLAGS;

		// Get the snapshot structure
		PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
		if (pProp == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
		}

		// Open the snapshot channel, if needed.
		OpenSnapshotChannel(ft);

		// send the IOCTL.
		m_snapIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO);

		// Unpack the length of the entire buffer
		ULONG ulBufferLength = 0;
		m_snapIChannel.Unpack(ft, &ulBufferLength );
		
#ifdef _DEBUG
		// Start counting entire buffer length, for checking
		DWORD dwInitialOffset = m_snapIChannel.GetCurrentOutputOffset();
#endif
		
		// Unpack the Snapshot ID
		m_snapIChannel.Unpack(ft, &(pProp->m_SnapshotId));
		
		// Unpack the Snapshot Set ID
		m_snapIChannel.Unpack(ft, &(pProp->m_SnapshotSetId));
		m_SSID = pProp->m_SnapshotSetId;

		// Load the rest of properties, except IDs
		LoadSnapshotStructuresExceptIDs(ft, m_snapIChannel, pProp, lMask, bForGetOnly,
			m_lSnapshotsCount,m_dwGlobalReservedField,
			m_usNumberOfNonstdSnapProperties,m_pOpaqueSnapPropertiesList, m_usReserved);
		
		// Compute the entire buffer length and check it.
#ifdef _DEBUG
		DWORD dwFinalOffset = m_snapIChannel.GetCurrentOutputOffset();
		BS_ASSERT( dwFinalOffset > dwInitialOffset );
		BS_ASSERT( dwFinalOffset - dwInitialOffset == ulBufferLength );
#endif
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


void CVssQueuedSnapshot::LoadSnapshotStructuresExceptIDs(
	IN	CVssFunctionTracer& ft,
	IN	CVssIOCTLChannel& snapIChannel,
	IN	PVSS_SNAPSHOT_PROP pProp,
	IN	LONG lMask,
	IN	bool bForGetOnly,
	OUT LONG& lSnapshotsCount,
	OUT DWORD& dwGlobalReservedField,
	OUT USHORT& usNumberOfNonstdSnapProperties,
	OUT CVssGenericSnapProperties* & pOpaqueSnapPropertiesList,
	OUT USHORT& usReserved
	) throw(HRESULT)
{
	// Reset the error code
	ft.hr = S_OK;
		
	// Unpack the number of snapshots in this snapshot set
	snapIChannel.Unpack(ft, &lSnapshotsCount);

	// Unpack the reserved field
	snapIChannel.Unpack(ft, &dwGlobalReservedField);

	// Unpack the number of structures (one standard and the rest nonstandard)
	USHORT usStructuresCount;
	snapIChannel.Unpack(ft, &usStructuresCount);
	usNumberOfNonstdSnapProperties = 0;

	// Unpack each structure
	for(USHORT usIndex = 0; usIndex < usStructuresCount; usIndex++)
	{
		VSS_ID CurrentStructureID;
		snapIChannel.Unpack(ft, &CurrentStructureID);

		if (CurrentStructureID == guidSnapshotPropVersion10)
		{
			// The structure is a standard one
			LoadStandardStructure( ft, snapIChannel, pProp,
				lMask, usReserved );
		}
		else if (!bForGetOnly)
		{
			// The structure is a non-standard one
			CVssGenericSnapProperties* pStr = new CVssGenericSnapProperties;
			if (pStr == NULL)
				ft.Throw(VSSDBG_SWPRV, E_OUTOFMEMORY, L"Out of memory");

			// Initialize the structure from the stream
			pStr->InitializeFromStream( ft, snapIChannel, CurrentStructureID);

			// Append the structure to the list of opaque
			// (i.e. non-standard) structures.
			pStr->AppendToList(pOpaqueSnapPropertiesList);
		}
	}
}


void CVssQueuedSnapshot::LoadStandardStructure(
		IN	CVssFunctionTracer& ft,
		IN	CVssIOCTLChannel& snapIChannel,
		IN	PVSS_SNAPSHOT_PROP pProp,
		IN	LONG lMask,
		OUT USHORT& usReserved
		) throw(HRESULT)
		
/*++

Description:

	This function will load the standard set of attributes (in this version of the provider)
	in the x86 / IA64 format.

TBD:

	Use mask

--*/

{
	// Reset the error code
	ft.hr = S_OK;
		
	// Unpack the length of the data structure
	DWORD dwStructureLength;
	snapIChannel.Unpack(ft, &dwStructureLength ); // unknown right now

#ifdef _DEBUG
	// Start counting structure length
	DWORD dwInitialOffset = snapIChannel.GetCurrentOutputOffset();
#endif
	
	// Unpack the magic number
	USHORT usMagicNumber;
	snapIChannel.Unpack(ft, &usMagicNumber);
	if (usMagicNumber != (USHORT)sizeof(VSS_SNAPSHOT_PROP))
		ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Invalid magic number %u", (UINT)usMagicNumber);
	
	// Unpack the reserved field
	snapIChannel.Unpack(ft, &usReserved);
	
	//
	// Unpack the contents of the snapshot structure
	//
	BS_ASSERT(pProp != NULL);
	
	// Unpack the Details
	snapIChannel.UnpackSmallString(ft, pProp->m_pwszDetails);

	// Unpack the Commit flags
	snapIChannel.Unpack(ft, &(pProp->m_lCommitFlags));

	// Unpack the creation timestamp
	snapIChannel.Unpack(ft, &(pProp->m_tsCreationTimestamp));

	// Unpack the status
	USHORT usStatus;
	snapIChannel.Unpack(ft, &usStatus);
	pProp->m_eStatus = (VSS_SNAPSHOT_STATE)usStatus;

	// Unpack the incarnation number
	snapIChannel.Unpack(ft, &(pProp->m_llIncarnationNumber));

	// Unpack the opaque length and data
	snapIChannel.Unpack(ft, &(pProp->m_lDataLength));

	BS_ASSERT(pProp->m_pbOpaqueData == NULL);
	::VssFreeOpaqueData(pProp->m_pbOpaqueData);
	if (pProp->m_lDataLength > 0)
	{
		// Allocate the opaque data buffer
		pProp->m_pbOpaqueData = ::VssAllocOpaqueData(ft, pProp->m_lDataLength);
		BS_ASSERT(pProp->m_pbOpaqueData);

		// Extract the opaque data
		snapIChannel.Unpack(ft, pProp->m_pbOpaqueData, pProp->m_lDataLength);
	}
	else if (pProp->m_lDataLength == 0)
	{
		// Now the opaque data must remain NULL
		BS_ASSERT(pProp->m_pbOpaqueData == NULL);
	}
	else
	{
		BS_ASSERT(false);
		ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Invalid data length %ld", pProp->m_lDataLength);
	}

#ifdef _DEBUG
	// Complete the length of the data structure
	DWORD dwFinalOffset = snapIChannel.GetCurrentOutputOffset();
	BS_ASSERT( dwFinalOffset > dwInitialOffset );
	BS_ASSERT( dwFinalOffset - dwInitialOffset == dwStructureLength );
#endif

    UNREFERENCED_PARAMETER( lMask );
}


void CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)

/*++

Description:

	Load the original volume name and ID.
	Uses IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME.

Warning:

	The snapshot device name must be already known!

--*/

{
	// Reset the error code
	ft.hr = S_OK;
		
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	if (pProp == NULL)
	{
		BS_ASSERT(false);
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
	}

	// Open the snapshot channel, if needed.
	OpenSnapshotChannel(ft);

	// send the IOCTL.
	m_snapIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME);

	// Load the Original volume name
	m_snapIChannel.UnpackSmallString(ft, pProp->m_pwszOriginalVolumeName);

	// Get the user-mode style device name
	WCHAR wszVolNameUsermode[MAX_PATH];
	if (::_snwprintf(wszVolNameUsermode, MAX_PATH - 1,
			L"\\\\?\\GLOBALROOT%s\\", pProp->m_pwszOriginalVolumeName) < 0)
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Not enough memory" );

	// Get the mount point for the original volume
	WCHAR wszMPMVolumeName[MAX_PATH];
	BOOL bSucceeded = ::GetVolumeNameForVolumeMountPointW(
							wszVolNameUsermode,
							wszMPMVolumeName, MAX_PATH );			
	if (!bSucceeded)
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
				  L"Unexpected error while getting the volume name 0x%08lx",
				  GetLastError());

	// Load the Original Volume ID
	if (!GetVolumeGuid(wszMPMVolumeName, pProp->m_OriginalVolumeId))
	{
		BS_ASSERT(false); // The volume name is expected in a predefined format
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
				L"Cannot get the original volume Id for %s.",
				pProp->m_pwszOriginalVolumeName);
	}
}


void CVssQueuedSnapshot::LoadAttributes(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)

/*++

Description:

	Load the snapshot attributes mask.
	Uses IOCTL_VOLSNAP_QUERY_CONFIG_INFO.

Warning:

	The snapshot device name must be already known!

--*/

{
	// Reset the error code
	ft.hr = S_OK;
		
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	if (pProp == NULL)
	{
		BS_ASSERT(false);
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
	}

	// Open the snapshot channel, if needed.
	OpenSnapshotChannel(ft);

	// Send the IOCTL.
	m_snapIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_CONFIG_INFO);

	// Load the snapshot attributes
	m_snapIChannel.Unpack(ft, &(pProp->m_lSnapshotAttributes));
}


/////////////////////////////////////////////////////////////////////////////
// CVssGenericSnapProperties
//


void CVssGenericSnapProperties::InitializeFromStream(
	IN	CVssFunctionTracer& ft,
	IN	CVssIOCTLChannel& snapIChannel,
	IN	GUID& guidFormatID
	) throw(HRESULT)

/*++

Description:

	Will retrieve the snapshot property structures that are different
	than the standard property structure from the snapshot IOCTL stream

--*/

{
	// Reset the error code
	ft.hr = S_OK;
		
	// The Format ID is already known
	m_guidFormatID = guidFormatID;

	// Unpack the length of the opaque data
	snapIChannel.Unpack(ft, &m_dwStructureLength);

	// Unpack the opaque data
	if (m_dwStructureLength != 0)
	{
		m_pbData = new BYTE[m_dwStructureLength];
		if (m_pbData == NULL)
			ft.Throw(VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");
		snapIChannel.Unpack(ft, m_pbData, m_dwStructureLength);
	}
}


void CVssGenericSnapProperties::SaveRecursivelyIntoStream(
	IN	CVssFunctionTracer& ft,
	IN	CVssIOCTLChannel& snapIChannel
	) throw(HRESULT)

/*++

Description:

	Will save the snapshot property structures that are different
	than the standard property structure from the snapshot IOCTL stream

--*/

{
	// Reset the error code
	ft.hr = S_OK;
		
	// Save the previous nodes
	if (m_pPrevious!= NULL)
		m_pPrevious->SaveRecursivelyIntoStream( ft, snapIChannel );

	// Pack the Format ID
	snapIChannel.Pack(ft, m_guidFormatID);

	// Pack the structure length
	snapIChannel.Pack(ft, m_dwStructureLength);

	// Pack the opaque data
	if (m_dwStructureLength)
	{
		BS_ASSERT(m_pbData);
		snapIChannel.PackArray(ft, m_pbData, m_dwStructureLength);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\testprv\src\query.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Query.hxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Adi Oltean  [aoltean]   09/15/1999

Revision History:

    Name        Date        Comments

    aoltean     09/23/1999  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL header
#include "vss.h"
#include "vscoordint.h"
#include "vsswprv.h"
#include "vsprov.h"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"
#include "snapshot.hxx"


/////////////////////////////////////////////////////////////////////////////
//  Implementation


STDMETHODIMP CVsTestProvider::Query(
    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    IN      LONG            lMask,
    OUT     IVssEnumObject**ppEnum
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsTestProvider::Query" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        ft.Trace( VSSDBG_SWPRV, L"Parameters: QueriedObjectId = " WSTR_GUID_FMT
				  L"eQueriedObjectType = %d. eReturnedObjectsType = %d, lPropertiesMask = 0x%08lx, ppEnum = %p",
				  GUID_PRINTF_ARG( QueriedObjectId ),
				  eQueriedObjectType,
				  eReturnedObjectsType,
				  lMask,
				  ppEnum);

        // Argument validation
		BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// Establish the filtering
		CVssQueuedSnapshot::VSS_QUERY_TYPE eQueryType = CVssQueuedSnapshot::VSS_FIND_UNKNOWN;
		switch(eQueriedObjectType)
		{
		case VSS_OBJECT_SNAPSHOT_SET:
			eQueryType = CVssQueuedSnapshot::VSS_FIND_BY_SNAPSHOT_SET_ID;
			break;
			
		case VSS_OBJECT_SNAPSHOT:
			eQueryType = CVssQueuedSnapshot::VSS_FIND_BY_SNAPSHOT_ID;
			break;
			
		case VSS_OBJECT_VOLUME:
			eQueryType = CVssQueuedSnapshot::VSS_FIND_BY_VOLUME;
			break;
			
		case VSS_OBJECT_NONE:
			eQueryType = CVssQueuedSnapshot::VSS_FIND_ALL;
			break;
			
		default:
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Incompatible types %d/%d",
					  eQueriedObjectType, eReturnedObjectsType);
		}
		
        // Fill now the collection
		switch(eReturnedObjectsType)
		{
		case VSS_OBJECT_SNAPSHOT_SET:
		case VSS_OBJECT_SNAPSHOT:
		case VSS_OBJECT_VOLUME:
			CVssQueuedSnapshot::EnumerateSnasphots(ft,
				eQueryType,
				eReturnedObjectsType,
				lMask,
				QueriedObjectId,
				pArray);
			break;

		default:
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Incompatible types %d/%d",
					  eQueriedObjectType, eReturnedObjectsType);
		}

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
		// So if a throw occurs the enumerator object will be safely destroyed by the smart ptr.
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object.
		// The array's reference count becomes now 2, because IEnumOnSTLImpl::m_spUnk is also a smart ptr.
        BS_ASSERT(pArray);
		ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Cannot initialize enumerator instance. [0x%08lx]", ft.hr);

        // Initialize the enumerator object.
		// The enumerator reference count becomes now 2.
        ft.hr = pUnknown->SafeQI(IVssEnumObject, ppEnum);
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Error querying the IVssEnumObject interface. hr = 0x%08lx", ft.hr);
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\testprv\src\provider.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Provider.hxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.
    aoltean     08/17/1999  Change CommitSnapshots to CommitSnapshot
    aoltean     09/23/1999  Using CComXXX classes for better memory management
                            Renaming back XXXSnapshots -> XXXSnapshot
    aoltean     09/26/1999  Returning a Provider Id in OnRegister
    aoltean     09/09/1999  Adding PostCommitSnapshots
                            dss->vss
	aoltean		09/20/1999	Making asserts more cleaner.
	aoltean		09/21/1999	Small renames

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL header
#include "vss.h"
#include "vscoordint.h"
#include "vsswprv.h"
#include "vsprov.h"

#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"
#include "snapshot.hxx"
#include "diff.hxx"


/////////////////////////////////////////////////////////////////////////////
//  Macros for debugging



#undef VSSDBG_SWPRV
#define VSSDBG_SWPRV   CVssDebugInfo(__WFILE__, __LINE__, m_nTestIndex, 0)


/////////////////////////////////////////////////////////////////////////////
//  Definitions


STDMETHODIMP CVsTestProvider::BeginPrepareSnapshot(
    IN      VSS_ID          SnapshotSetId,
    IN      VSS_PWSZ		pwszVolumeName,
    IN      VSS_PWSZ        pwszDetails,
    IN      LONG            lAttributes,
    IN      LONG            lDataLength,
    IN      BYTE*           pbOpaqueData,
    OUT     IVssSnapshot**  ppSnapshot
    )

/*++

Description:

	Creates a Queued Snapshot object to be commited later.

Algorithm:

	1) Creates an internal VSS_SNAPSHOT_PROP structure that will keep most of the properties.
	2) Creates an CVssQueuedSnapshot object and insert it into the global queue of snapshots pending to commit.
	3) Set the state of the snapshot as PREPARING.
	4) If needed, create the snapshot object and return it to the caller.

Remarks:

	The queued snapshot object keeps a reference count. At the end of this function it will be:
		1 = the queued snap obj is reffered by the global queue (if no snapshot COM object was returned)
		2 = reffered by the global queue and by the returned snapshot COM object

Called by:

	IVssCoordinator::AddToSnapshotSet

--*/


{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsTestProvider::BeginPrepareSnapshot" );

    try
    {
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  SnapshotSetId = " WSTR_GUID_FMT 	L"\n"
             L"  VolumeName = %s,\n"
             L"  pwszDetails = %s,\n"
             L"  lAttributes = 0x%08lx,\n"
             L"  lDataLength = %ld,\n"
             L"  pbOpaqueData = %p,\n"
             L"  ppSnapshot = %p,\n",
             GUID_PRINTF_ARG( SnapshotSetId ),
             pwszVolumeName,
             pwszDetails? pwszDetails: L"NULL",
             lAttributes,
             lDataLength,
             pbOpaqueData,
             ppSnapshot);

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");
        if ( pwszVolumeName == NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pwszVolumeName is NULL");
        if ( pwszDetails == NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pwszDetails is NULL");
        if (lDataLength < 0)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Negative lDataLength");
        if ((lDataLength > 0) && (pbOpaqueData == NULL))
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pbOpaqueData");
        if ((lDataLength == 0) && (pbOpaqueData != NULL))
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid pbOpaqueData length");

		// Eliminate the last backslash from the volume name.
		BS_ASSERT(pwszVolumeName[0] != L'\0');
		BS_ASSERT(::wcslen(pwszVolumeName) == nLengthOfVolMgmtVolumeName);
		BS_ASSERT(pwszVolumeName[nLengthOfVolMgmtVolumeName - 1] == L'\\');
		pwszVolumeName[nLengthOfVolMgmtVolumeName - 1] = L'\0';

		// Remark: Volume ID is not computed right now.
		// TBD: change this in the future?

		// Create the structure that will keep the prepared snapshot state.
		VSS_OBJECT_PROP_Ptr ptrSnapshot;
		ptrSnapshot.InitializeAsSnapshot( ft,
			GUID_NULL,
			SnapshotSetId,
			NULL,
			NULL,
			GUID_NULL,
			pwszVolumeName,
			VSS_SWPRV_ProviderId,
			pwszDetails,
			lAttributes,
			CVsFileTime(),
			VSS_SS_PREPARING,
			0,
			0,
			lDataLength,
			pbOpaqueData
			);

		// Create the snapshot object. After this assignment the ref count becomes 1.
		CComPtr<CVssQueuedSnapshot> ptrQueuedSnap = new CVssQueuedSnapshot(ptrSnapshot);
		if (ptrQueuedSnap == NULL)
			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");

		// The structure was detached into the queued object
		// since the ownership was passed to the constructor.
		ptrSnapshot.Reset();

		// Add the snapshot object to the global queue. No exceptions should be thrown here.
		// The reference count will be 2.
		ptrQueuedSnap->AttachToGlobalList(ft);

		// Create the Snapshot COM object to be returned, if needed.
        if (ppSnapshot != NULL)
        {
            if ( (*ppSnapshot) != NULL)
			{
                (*ppSnapshot)->Release();
				(*ppSnapshot) = NULL;
			}

            // [Create the snapshot object. The reference count will be 3]
            ft.hr = CVsSoftwareSnapshot::CreateInstance(
						ptrQueuedSnap,
						reinterpret_cast<IUnknown**>(ppSnapshot) );
            if ( ft.HrFailed() )
                ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
						  L"Error calling CVsSoftwareSnapshot::CreateInstance. hr = 0x%08lx", ft.hr);
            BS_ASSERT( (*ppSnapshot) != NULL );
        }

        // The destructor for the smart pointer will be called. The reference count will be 1 [or 2]
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  Global declarations


CVssDLList<CVssQueuedSnapshot*>	 CVssQueuedSnapshot::m_list;


STDMETHODIMP CVsTestProvider::EndPrepareSnapshots(
    IN      VSS_ID          SnapshotSetId,
    IN      LONG			lCommitFlags,
    OUT     LONG*           plSnapshotsCount
    )

/*++

Description:

	This function gets called by the coordinator as a rendez-vous method
    in order to finish the prepare phase for snapshots
    (like ending the background prepare tasks or performing the lengthly operations before
    issuing the snapshots freeze).

	This function acts on the given snapshot set (i.e. to call IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT
    on each snapshotted volume)

Algorithm:

	For each preparing snapshot (but not prepared yet) in this snapshot set:
		1) Set the remaining properties to be set: lCommitFlags
		2) Call IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT
		3) Change the state of the snapshot to VSS_SS_PREPARED

	Compute the number of prepared snapshots.

	If a snapshot fails in operations above then set the state of all snapshots
    to PREPARING and return E_UNEXPECTED. The coordinator is responsible to Abort
    all prepared snapshots.

Called by:

	IVssCoordiantor::DoSnapshotsSet in the first phase (i.e. EndPrepare All Snapshots).

Remarks:

	- While calling this, Lovelace is not holding yet writes on snapshotted volumes.
	- The coordinator may issue many EndPrepareSnapshots calls for the same Snapshot Set ID.
	- This function can be called on a subsequent retry of DoSnapshotSet or immediately
	after PrepareSnasphots therefore the state of all snapshots must be PREPARING before calling this function.

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsTestProvider::EndPrepareSnapshots" );
	LONG lProcessedSnapshotsCount = 0;

    try
    {
        // Initialize [out] arguments
        VssZeroOut( plSnapshotsCount );

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");
		BS_ASSERT(plSnapshotsCount);
		if ( plSnapshotsCount == NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"plSnapshotsCount = NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
			L"  lCommitFlags = 0x%04x\n",
			GUID_PRINTF_ARG( SnapshotSetId ),
			lCommitFlags
			);

		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNext(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  pwszDetails = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  lDataLength = %ld\n"
                 L"  pbOpaqueData = %p\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
				 pProp->m_pwszOriginalVolumeName,
                 pProp->m_pwszDetails? pProp->m_pwszDetails: L"NULL",
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
                 pProp->m_lDataLength,
                 pProp->m_pbOpaqueData,
				 pProp->m_eStatus);

			// Deal only with the snapshots that must be pre-commited.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case  VSS_SS_PREPARING:

				// End the preparation for this snapshot
				try
				{
					// Set the per-snapshot commit information
					ptrQueuedSnapshot->SetCommitInfo( lCommitFlags );

					// Open the volume IOCTL channel for that snapshot.
					ptrQueuedSnapshot->OpenVolumeChannel(ft);
					if (ft.HrFailed())
						ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
								 L"Opening the channel failed 0x%08lx", ft.hr);
						
					// Send the IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT ioctl.
					ft.hr = ptrQueuedSnapshot->PrepareForSnapshotIoctl();
					if (ft.HrFailed())
						ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
								 L"sending IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT failed 0x%08lx", ft.hr);

					// Increment the number of processed snapshots
					lProcessedSnapshotsCount++;

					// Mark the snapshot as prepared
					ptrQueuedSnapshot->MarkAsPrepared();
				}
				VSS_STANDARD_CATCH(ft)
				{
					if (ft.HrFailed())
					{
						// Abort current prepared/precommited snapshot
						ft.hr = ptrQueuedSnapshot->AbortPreparedSnapshotIoctl();
						if (ft.HrFailed())
							ft.Warning( VSSDBG_SWPRV, L"sending IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT failed");

						// Mark the state of this snapshot as failed
						ptrQueuedSnapshot->MarkAsFailed();

						// If Throw an error and abort all snapshots.
						ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
									L"Opening the channel failed 0x%08lx", ft.hr);
					}
				}
				break;

			case VSS_SS_PREPARED:

				// Snapshot was already prepared in another call
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        }

        ft.Trace( VSSDBG_SWPRV, L"%ld snasphots were prepared", lProcessedSnapshotsCount);
    }
    VSS_STANDARD_CATCH(ft)

	// If an error occured then reset all snapshots to the PREPARING state. This will prepare
	// the provider for another series of EndPrepare/PreCommit/Commit/PostCommit calls.
	if ( ft.HrFailed() )
		ResetSnasphotSet(ft, SnapshotSetId); // This methods should not throw errors
	else
		// Set the out parameter
		(*plSnapshotsCount) = lProcessedSnapshotsCount;

    return ft.hr;
}


STDMETHODIMP CVsTestProvider::PreCommitSnapshots(
    IN      VSS_ID          SnapshotSetId,
    IN      LONG			lCommitFlags,
    OUT     LONG*           plSnapshotsCount
    )

/*++

Description:

	This function gets called by the coordinator in order to pre-commit all snapshots
	on the given snapshot set

Algorithm:

	For each prepared snapshot (but not precommited yet) in this snapshot set:
		1) Change the state of the snapshot to VSS_SS_PRECOMMITED

	Compute the number of pre-commited snapshots.

	If a snapshot fails in operations above then set the state of all snapshots to PREPARING and return E_UNEXPECTED.
	The coordinator is responsible to Abort all pre-commited snapshots.

Called by:

	IVssCoordiantor::DoSnapshotsSet in the second phase (i.e. Pre-Commit All Snapshots).

Remarks:

	- While calling this, Lovelace is not holding yet writes on snapshotted volumes.
	- The coordinator may issue many PreCommitSnapshots calls for the same Snapshot Set ID.
	- This function can be called on a subsequent retry of DoSnapshotSet or immediately
	after EndPrepareSnasphots therefore the state of all snapshots must be PREPARED before calling this function.

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsTestProvider::PreCommitSnapshots" );
	LONG lProcessedSnapshotsCount = 0;

    try
    {
        // Initialize [out] arguments
        VssZeroOut( plSnapshotsCount );

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");
		BS_ASSERT(plSnapshotsCount);
		if ( plSnapshotsCount == NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"plSnapshotsCount = NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
			L"  lCommitFlags = 0x%04x\n",
			GUID_PRINTF_ARG( SnapshotSetId ),
			lCommitFlags
			);

		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNext(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  pwszDetails = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  lDataLength = %ld\n"
                 L"  pbOpaqueData = %p\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
				 pProp->m_pwszOriginalVolumeName,
                 pProp->m_pwszDetails? pProp->m_pwszDetails: L"NULL",
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
                 pProp->m_lDataLength,
                 pProp->m_pbOpaqueData,
				 pProp->m_eStatus);

			// Deal only with the snapshots that must be pre-commited.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case  VSS_SS_PREPARED:

				// Pre-commit this snapshot

				// Increment the number of processed snapshots
				lProcessedSnapshotsCount++;

				// Mark the snapshot as pre-commited
                // Do nothing in Babbage provider
				ptrQueuedSnapshot->MarkAsPreCommited();

				break;

			case VSS_SS_PRECOMMITED:

				// Snapshot was already pre-commited in another call
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        }

        ft.Trace( VSSDBG_SWPRV, L"%ld snasphots were pre-commited", lProcessedSnapshotsCount);
    }
    VSS_STANDARD_CATCH(ft)

	// If an error occured then reset all snapshots to the PREPARED state. This will prepare
	// the provider for another series of PreCommit/Commit/PostCommit calls.
	if ( ft.HrFailed() )
		ResetSnasphotSet(ft, SnapshotSetId); // This methods should not throw errors
	else
		// Set the out parameter
		(*plSnapshotsCount) = lProcessedSnapshotsCount;

    return ft.hr;
}


STDMETHODIMP CVsTestProvider::CommitSnapshots(
    IN      VSS_ID          SnapshotSetId,
    OUT     LONG*           plSnapshotsCount
    )

/*++

Description:

	This function gets called by the coordinator in order to commit all snapshots
	on the given snapshot set (i.e. to call IOCTL_VOLSNAP_COMMIT_SNAPSHOT on each snapshotted volume)

Algorithm:

	For each precommited (but not yet commited) snapshot in this snapshot set:
		2) Call IOCTL_VOLSNAP_COMMIT_SNAPSHOT
		3) Change the state of the snapshot to VSS_SS_COMMITED

	Return the number of commited snapshots, if success.
	Otherwise return 0 (even if some snapshots were commited).

	If a snapshot fails in operations above then set the state of all snapshots to PREPARED and return E_UNEXPECTED.
	The coordinator is responsible to Abort all snapshots if he does not want to retry anymore.
	Anyway commited snapshots MUST be deleted by coordinator in this error case.

Called by:

	IVssCoordinator::DoSnapshotsSet in the third phase (i.e. Commit All Snapshots).

Remarks:

	- While calling this, Lovelace is already holding writes on snapshotted volumes.
	- The coordinator may issue many CommitSnapshots calls for the same Snapshot Set ID.

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsTestProvider::CommitSnapshots" );
	LONG lProcessedSnapshotsCount = 0;

    try
    {
        // Initialize [out] arguments
        VssZeroOut( plSnapshotsCount );

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");
		BS_ASSERT(plSnapshotsCount);
		if ( plSnapshotsCount == NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"plSnapshotsCount == NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
			L"  plSnapshotsCount = %p\n",
			GUID_PRINTF_ARG( SnapshotSetId ),
			plSnapshotsCount);

		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNext(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  pwszDetails = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  lDataLength = %ld\n"
                 L"  pbOpaqueData = %p\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
				 pProp->m_pwszOriginalVolumeName,
                 pProp->m_pwszDetails? pProp->m_pwszDetails: L"NULL",
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
                 pProp->m_lDataLength,
                 pProp->m_pbOpaqueData,
				 pProp->m_eStatus);

			// Commit the snapshot, if not failed in pre-commit phase.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case VSS_SS_PRECOMMITED:

				// Send the IOCTL_VOLSNAP_COMMIT_SNAPSHOT ioctl.
				ft.hr = ptrQueuedSnapshot->CommitSnapshotIoctl();
				if (ft.HrFailed())
				{
					// Send IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT.
					ft.hr = ptrQueuedSnapshot->AbortPreparedSnapshotIoctl();
					if (ft.HrFailed())
						ft.Warning( VSSDBG_SWPRV,
								  L"Sending IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT failed. hr = 0x%08lx", ft.hr);

					// Mark that snapshot as failed anyway
					ptrQueuedSnapshot->MarkAsFailed();
					
					// Throw an error and abort all snapshots.
					ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
								L"sending IOCTL_VOLSNAP_COMMIT_SNAPSHOT failed 0x%08lx", ft.hr);

					BS_ASSERT(ft.HrSucceeded());
				}
				else
				{
					// Increment the number of processed snapshots
					lProcessedSnapshotsCount++;

					// Mark the snapshot as commited
					ptrQueuedSnapshot->MarkAsCommited();
				}
				break;

			case VSS_SS_COMMITED:

				// Commit was already done.
				// The provider may receive many CommitSnapshots
				// calls for the same Snapshot Set ID.
				break;

			default:
				BS_ASSERT(false);
			}
        }

        ft.Trace( VSSDBG_SWPRV, L"%ld snasphots were commited", lProcessedSnapshotsCount);
    }
    VSS_STANDARD_CATCH(ft)

	// If an error occured then reset all snapshots to the PREPARED state. This will prepare
	// the snapshot set for another series of PreCommit/Commit/PostCommit calls.
	// The coordinator is responsible to delete all commited snapshots until now.
	if ( ft.HrFailed() )
	{
		// This methods should not throw errors
		ResetSnasphotSet(ft, SnapshotSetId);
	}
	else
		// Set the out parameter
		(*plSnapshotsCount) = lProcessedSnapshotsCount;

	return ft.hr;
}


STDMETHODIMP CVsTestProvider::PostCommitSnapshots(
    IN      VSS_ID          SnapshotSetId,
    IN      LONG            lSnapshotsCount
    )

/*++

Description:

	This function gets called by the coordinator as a last phase after commit for all snapshots
	on the given snapshot set

Algorithm:

	For each commited snapshot in this snapshot set:
		1) Call IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT. The purpose of this
			IOCTL is to get the Snapshot Device object name.
		2) Create a unique snapshot ID
		3) Change the state of the snapshot to VSS_SS_CREATED
		4) Set the "number of commited snapshots" attribute of the snapshot set
		5) Save the snapshot properties using the IOCTL_VOLSNAP_SET_APPLICATION_INFO ioctl.
		6) If everything is OK then remove all snapshots from the global list.

	Keep the number of post-commited snapshots.

	If a snapshot fails in operations above then return an error. The coordinator is responsible to
	issue a DeleteSnapshots call on all snapshots in this snapshot set when an error occurs in this case.

Called by:

	IVssCoordinator::DoSnapshotsSet in the third phase (i.e. Commit All Snapshots), after releasing writes
	by Lovelace

Remarks:

	- While calling this, Lovelace is not holding writes anymore.
	- The coordinator may issue many PostCommitSnapshots calls for the same Snapshot Set ID.

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsTestProvider::PostCommitSnapshots" );
	LPWSTR pwszSnapshotDeviceObject = NULL;
	LONG lProcessedSnapshotsCount = 0;

    try
    {
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
				  L"  SnapshotSetId = " WSTR_GUID_FMT L" \n"
				  L"  lSnapshotsCount = %ld",
				  GUID_PRINTF_ARG( SnapshotSetId ),
				  lSnapshotsCount);

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");
		if ( lSnapshotsCount < 0 )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"lSnapshotsCount < 0");

		// On each commited snapshot store the lSnapshotsCount
		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNext(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  pwszDetails = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  lDataLength = %ld\n"
                 L"  pbOpaqueData = %p\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
				 pProp->m_pwszOriginalVolumeName,
                 pProp->m_pwszDetails? pProp->m_pwszDetails: L"NULL",
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
                 pProp->m_lDataLength,
                 pProp->m_pbOpaqueData,
				 pProp->m_eStatus);

			try
			{
				// Get the snapshot volume name and set the snapshot data.
				switch(ptrQueuedSnapshot->GetStatus())
				{
				case VSS_SS_COMMITED:

					// Send the IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT ioctl.
					// Get the snapshot device name
					ft.hr = ptrQueuedSnapshot->EndCommitSnapshotIoctl(
								pwszSnapshotDeviceObject);
					if (ft.HrFailed())
						ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
								L"sending IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT failed. 0x%08lx", ft.hr);

					BS_ASSERT(pwszSnapshotDeviceObject);
					BS_ASSERT(pProp->m_pwszSnapshotDeviceObject == NULL);
					pProp->m_pwszSnapshotDeviceObject = pwszSnapshotDeviceObject;
					pwszSnapshotDeviceObject = NULL;

					// Create the snapshot ID
					BS_ASSERT(pProp->m_SnapshotId == GUID_NULL);
					ft.hr = ::CoCreateGuid(&(pProp->m_SnapshotId));
					if (ft.HrFailed())
						ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Guid generation failed. 0x%08lx", ft.hr);
									
					// Remark: the snapshot device name will not be persisted

					// Mark the snapshot as created
					ptrQueuedSnapshot->MarkAsCreated(lSnapshotsCount);

					// Save the snapshot properties to the store.
					ft.hr = ptrQueuedSnapshot->SaveSnapshotPropertiesIoctl();
					if (ft.HrFailed())
						ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Saving snapshot info failed. 0x%08lx", ft.hr);

					// Increment the number of processed snapshots
					lProcessedSnapshotsCount++;

					ft.Trace( VSSDBG_SWPRV, L"Snapshot created at %s", pwszSnapshotDeviceObject);
					break;

				case VSS_SS_CREATED:

					// This snapshot is already created.
					// The provider may receive many PostCommitSnapshots
					// calls for the same Snapshot Set ID.
					break;

				default:
					BS_ASSERT(false);
				}
			}
			VSS_STANDARD_CATCH(ft)

			// Check if an error occured during post-commit of this snapshot.
			if (ft.HrFailed())
			{
				// Delete the snapshot.
				ft.hr = ptrQueuedSnapshot->DeleteSnapshotIoctl();
				if (ft.HrFailed())
					ft.Warning( VSSDBG_SWPRV,
							  L"Deleting the snapshot failed. hr = 0x%08lx", ft.hr);

				// Mark that snapshot as failed anyway
				ptrQueuedSnapshot->MarkAsFailed();
				
				// Throw an error to let know
				// the Coordinator to delete all snapshots.
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
							L"Error while post-commiting the snapshot");
			}
			else
				ft.hr = S_OK;
        } // end while(true)

		// As the last step detach from the global list the snapshots in discussion
        RemoveSnapshotSetFromGlobalList(ft, SnapshotSetId);
    }
    VSS_STANDARD_CATCH(ft)

	// Free the snapshot device name, if needed.
	::VssFreeString(pwszSnapshotDeviceObject);

	// If an error occured then reset all snapshots to the PREPARED state. This will prepare
	// the provider for another series of PreCommit/Commit/PostCommit calls.
	if ( ft.HrFailed() )
	{
		// This methods should not throw errors
		ResetSnasphotSet(ft, SnapshotSetId);
	}

    return ft.hr;
}


STDMETHODIMP CVsTestProvider::AbortSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator as to abort all snapshots from the given snapshot set

Algorithm:

 	For each pre-commited snapshot in this snapshot set calls IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT.
 	After that remove all snapshots from the global list.

Called by:

	IVssCoordinator::DoSnapshotsSet to abort precommited snapshots

Remarks:

	- While calling this, Lovelace may be holding writes on snapshotted volumes.
	- The coordinator may receive many AbortSnapshots calls for the same Snapshot Set ID.

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsTestProvider::AbortSnapshots" );

    try
    {
        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId ));

		LONG lProcessedSnapshotsCount = 0;
		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNext(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  pwszDetails = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  lDataLength = %ld\n"
                 L"  pbOpaqueData = %p\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
				 pProp->m_pwszOriginalVolumeName,
                 pProp->m_pwszDetails? pProp->m_pwszDetails: L"NULL",
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
                 pProp->m_lDataLength,
                 pProp->m_pbOpaqueData,
				 pProp->m_eStatus);

			// Set the correct state
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case VSS_SS_PREPARED:
			case VSS_SS_PRECOMMITED:

				// If snapshot was prepared, send IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT.
				ft.hr = ptrQueuedSnapshot->AbortPreparedSnapshotIoctl();
				if (ft.HrFailed())
					ft.Warning( VSSDBG_SWPRV, L"sending IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT failed");

				// Mark the snapshot state as "aborted"
				ptrQueuedSnapshot->MarkAsAborted();

                break;

			case VSS_SS_PREPARING:

				// Mark the snapshot state as "aborted"
				ptrQueuedSnapshot->MarkAsAborted();

				break;

			case VSS_SS_COMMITED:

				// The coordinator must delete the snapshot explicitely.
                // It might be there if the snapshot is garbage collected.

                break;

			default:
				BS_ASSERT(false);
			}

			lProcessedSnapshotsCount++;
        }

        ft.Trace( VSSDBG_SWPRV, L"%ld snasphots were aborted", lProcessedSnapshotsCount);

		// As the last step detach from the global list the snapshots in discussion
        RemoveSnapshotSetFromGlobalList(ft, SnapshotSetId);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


void CVsTestProvider::ResetSnasphotSet(
	IN	CVssFunctionTracer& ft,
	IN	VSS_ID SnapshotSetId
	) throw(HRESULT)

/*++

Description:

	Reset the snapshots in this set. Prepare all snapshots to be subject for another
	EndPrepareSnapshots call.

Remark:

	We change the state of all snapshots to PREPARING and free any internal data
	that was possibly created during EndPrepareSnapshots, PreCommitSnapshots,
    CommitSnapshots, PostCommitSnapshots.

	This function should not throw errors!

Called by:

	EndPrepareSnasphots, PreCommitSnapshots, CommitSnapshots, PostCommitSnapshots

--*/

{
	// Reset the error code
	ft.hr = S_OK;
		
	try
	{
		BS_ASSERT(SnapshotSetId != GUID_NULL);

		// For each snapshot in the snapshot set...
		LONG lProcessedSnapshotsCount = 0;
		CVssSnapIterator snapIterator;
	    while (true)
	    {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNext(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Reset the snapshot state (change the snapshot state to PREPARE)
			// and deallocate all structures that were allocated during PreCommit, Commit and PostCommit.
			ptrQueuedSnapshot->ResetAsPreparing();
			
			lProcessedSnapshotsCount++;
		}

		ft.Trace( VSSDBG_SWPRV, L" %ld snapshots were reset to PREPARING", lProcessedSnapshotsCount);
	}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		ft.Trace( VSSDBG_SWPRV, L"Suspect error while resetting all snapshots to PREPARE 0x%08lx", ft.hr);
}


void CVsTestProvider::RemoveSnapshotSetFromGlobalList(
	IN	CVssFunctionTracer& ft,
	IN	VSS_ID SnapshotSetId
	) throw(HRESULT)

/*++

Description:

	Detach from the global list all snapshots in this snapshot set

Remark:

	We detach all snapshots at once only in case of total success or total failure.
	This is because we want to be able to retry DoSnapshotSet if a failure happens.
	Therefore we must keep the list of snapshots as long as the client wants.

Called by:

	PostCommitSnapshots, AbortSnapshots

--*/

{
	// Reset the error code
	ft.hr = S_OK;
		
	BS_ASSERT(SnapshotSetId != GUID_NULL);

	// For each snapshot in the snapshot set...
	LONG lProcessedSnapshotsCount = 0;
	CVssSnapIterator snapIterator;
    while (true)
    {
		CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNext(SnapshotSetId);

		// End of enumeration?
		if (ptrQueuedSnapshot == NULL)
			break;
			
		// Detach that element from the list. Release is called.
		ptrQueuedSnapshot->DetachFromGlobalList();
		
		lProcessedSnapshotsCount++;
	}

	ft.Trace( VSSDBG_SWPRV, L" %ld snapshots were detached", lProcessedSnapshotsCount);
}


STDMETHODIMP CVsTestProvider::GetSnapshot(
    IN      VSS_ID          SnapshotId,
    IN      REFIID          SnapshotInterfaceId,
    OUT     IUnknown**      ppSnapshot
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsTestProvider::GetSnapshot" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr(ppSnapshot);

        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  SnapshotId = " WSTR_GUID_FMT 	L"\n"
             L"  ppSnapshot = %p,\n",
             GUID_PRINTF_ARG( SnapshotId ),
             ppSnapshot);

        // Argument validation
		if ( SnapshotId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotId == GUID_NULL");
		BS_ASSERT(ppSnapshot);
        if ( ppSnapshot == NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppSnapshot");

		//	Search for that snapshot

		// Get an enumeration interface
		CComPtr<IVssEnumObject> pEnum;
		ft.hr = CVsTestProvider::Query( SnapshotId, VSS_OBJECT_SNAPSHOT, VSS_OBJECT_SNAPSHOT,
					VSS_PM_ALL_FLAGS, &pEnum);

		//  Create the structure that will keep the prepared snapshot properties.
		VSS_OBJECT_PROP_Ptr ptrSnapshot;
		ptrSnapshot.InitializeAsEmpty(ft);

		// Get the Next object in the newly allocated structure object.
		VSS_OBJECT_PROP* pProp = ptrSnapshot.GetStruct();
		BS_ASSERT(pProp);
		ULONG ulFetched;
		ft.hr = pEnum->Next(1, pProp, &ulFetched);

		// end of enumeration - this means no snapshots
		if (ft.hr == S_FALSE)
			ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"Snapshot not found");
		if (ft.HrFailed())
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Error while getting hte snapshot structure 0x%08lx", ft.hr);

		// The returned object must be a snapshot
		BS_ASSERT(pProp->Type == VSS_OBJECT_SNAPSHOT);
		
		// Create the snapshot object.

		// After this assignment the ref count becomes 1.
		CComPtr<CVssQueuedSnapshot> ptrQueuedSnap = new CVssQueuedSnapshot(ptrSnapshot);
		if (ptrQueuedSnap == NULL)
			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");

		// The structure was detached into the queued object
		// since the ownership was passed to the constructor.
		ptrSnapshot.Reset();

        // Create the snapshot object. The reference count will be 2
        ft.hr = CVsSoftwareSnapshot::CreateInstance( ptrQueuedSnap, ppSnapshot, SnapshotInterfaceId );
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
					  L"Error calling CVsSoftwareSnapshot::CreateInstance. hr = 0x%08lx", ft.hr);
        BS_ASSERT( (*ppSnapshot) != NULL );

        // The destructor for the smart pointer will be called. The reference count will be 1 again
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsTestProvider::GetExtension(	
	IN VSS_PWSZ pwszObjectConstructor,			
	IN REFIID InterfaceId, 				
	OUT IUnknown** ppProviderExtensionObject
	)												
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsTestProvider::GetExtension" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppProviderExtensionObject );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  pwszObjectConstructor = %s\n"
             L"  InterfaceId = " WSTR_GUID_FMT L"\n"
             L"  ppProviderExtensionObject = %p\n",
             pwszObjectConstructor? pwszObjectConstructor: L"NULL",
             GUID_PRINTF_ARG( InterfaceId ),
             ppProviderExtensionObject);

        // Argument validation
		BS_ASSERT(ppProviderExtensionObject);
        if (ppProviderExtensionObject == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppProviderExtensionObject");

		ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Unknown interface ID.");
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsTestProvider::OnLoad(
	IN  	IUnknown* pCallback	
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsTestProvider::OnLoad" );

    return S_OK;
    UNREFERENCED_PARAMETER(pCallback);
}


STDMETHODIMP CVsTestProvider::OnUnload(
	IN  	BOOL	bForceUnload				
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsTestProvider::OnUnload" );

	// TBD - abort all snapshots

    return S_OK;
    UNREFERENCED_PARAMETER(bForceUnload);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\testprv\src\snapshot.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Snapshot.cxx | Snapshot object implementation
    @end

Author:

    Adi Oltean  [aoltean]   07/30/1999

Revision History:

    Name        Date        Comments

    aoltean     07/30/1999  Created.
    aoltean     08/21/1999  Making CI simpler
    aoltean     09/09/1999  dss->vss

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL headers
#include "vss.h"
#include "vscoordint.h"
#include "vsswprv.h"
#include "vsprov.h"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"
#include "vs_sec.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "snapshot.hxx"



/////////////////////////////////////////////////////////////////////////////
//  Operations


CVsSoftwareSnapshot::CVsSoftwareSnapshot()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsSoftwareSnapshot::CVsSoftwareSnapshot" );

	try
	{
		m_cs.Init();
	}
	VSS_STANDARD_CATCH(ft)

}


CVsSoftwareSnapshot::~CVsSoftwareSnapshot()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsSoftwareSnapshot::~CVsSoftwareSnapshot" );

	try
	{
		m_cs.Term();
	}
	VSS_STANDARD_CATCH(ft)

}


HRESULT CVsSoftwareSnapshot::CreateInstance(
    IN      CVssQueuedSnapshot* pQElem,
    OUT		IUnknown** ppSnapItf,
    IN 		const IID iid /* = IID_IVssSnapshot */
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareSnapshot::CreateInstance" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr(ppSnapItf);
        BS_ASSERT(ppSnapItf);

        // Allocate the COM object.
        CComObject<CVsSoftwareSnapshot>* pObject;
        ft.hr = CComObject<CVsSoftwareSnapshot>::CreateInstance(&pObject);
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Error creating the CVsSoftwareSnapshot instance. hr = 0x%08lx", ft.hr);
        BS_ASSERT(pObject);

        // Setting internal data
        BS_ASSERT(pQElem);
		BS_ASSERT(pObject->m_ptrQueuedSnapshot == NULL);

		// Now the reference count to the queued object will be increased by 1.
		pObject->m_ptrQueuedSnapshot = pQElem;	

        // Querying the IVssSnapshot interface
        CComPtr<IUnknown> pUnknown = pObject->GetUnknown();
        BS_ASSERT(pUnknown);
        ft.hr = pUnknown->QueryInterface(iid, reinterpret_cast<void**>(ppSnapItf) );
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Error querying the interface. hr = 0x%08lx", ft.hr);
        BS_ASSERT(*ppSnapItf);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  Interface methods


STDMETHODIMP CVsSoftwareSnapshot::GetProperties(
    IN      LONG                lMask,
    OUT     PVSS_SNAPSHOT_PROP  pSavedProp
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareSnapshot::GetProperties" );

    try
    {
        // Initialize [out] arguments
        VssZeroOut( pSavedProp );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: lMask = %ld, pSavedProp = %p", lMask, pSavedProp );

        // Argument validation
		BS_ASSERT(pSavedProp);
        if (pSavedProp == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pSavedProp");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock lock(m_cs);

		// Internal state validation
		if (m_ptrQueuedSnapshot == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL snapshot internal object." );
		}

		// Get the internal snapshot structure
		PVSS_SNAPSHOT_PROP pProp = m_ptrQueuedSnapshot->GetSnapshotProperties();
		if (pProp == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
		}

		// If the snapshot is not during creation make sure that the required fields are loaded
		// Otherwise we will just copy only the existing fields
		BS_ASSERT(m_ptrQueuedSnapshot != NULL);
		if (m_ptrQueuedSnapshot->IsDuringCreation())
		{
			// Copy the snapshot to the output parameter
			ft.hr = VSS_OBJECT_PROP_Copy::copySnapshot(pSavedProp, pProp, lMask);
			if (ft.HrFailed())
				ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
						  L"Error copying the structure to the out parameter");
		}
		else
		{
			// Load the needed properties into the internal structure
			m_ptrQueuedSnapshot->LoadSnapshotProperties(ft, lMask, true);
				
			// Copy the snapshot to the output parameter
			ft.hr = VSS_OBJECT_PROP_Copy::copySnapshot(pSavedProp, pProp, lMask);
			if (ft.HrFailed())
				ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
						  L"Error copying the structure to the out parameter");

			// Reset the internal fields that can change between Get calls.
			// Cache only the immutable fields (for the future Gets on the same interface)
			m_ptrQueuedSnapshot->ResetSnapshotProperties(ft, true);
		}
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareSnapshot::SetProperties(
    IN      LONG                lMask,
    IN      PVSS_SNAPSHOT_PROP  pNewProp
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareSnapshot::SetProperties" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: lMask = %ld, pNewProp = %p", lMask, pNewProp );

        // Argument validation
        if (pNewProp == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pNewProp");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock lock(m_cs);

		// Internal state validation
		if (m_ptrQueuedSnapshot == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL snapshot internal object." );
		}

		// Get the internal snapshot structure
		PVSS_SNAPSHOT_PROP pProp = m_ptrQueuedSnapshot->GetSnapshotProperties();
		if (pProp == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
		}

		// If the snapshot is not during creation make sure that the required fields are loaded
		// Otherwise we will just copy only the existing fields
		if (m_ptrQueuedSnapshot->IsDuringCreation())
		{
			// Copy the setable fields from the given argument
			BS_ASSERT(m_ptrQueuedSnapshot != NULL);
			if (lMask & VSS_PM_DETAILS_FLAG)
			{
				::VssFreeString(pProp->m_pwszDetails);
				::VssSafeDuplicateStr(ft, pProp->m_pwszDetails, pNewProp->m_pwszDetails);
			}
			
			if (lMask & VSS_PM_OPAQUE_FLAG)
			{
				::VssFreeOpaqueData(pProp->m_pbOpaqueData);
				pProp->m_lDataLength = pNewProp->m_lDataLength;
				::VssSafeDuplicateOpaqueData(ft,
					pProp->m_pbOpaqueData,
					pNewProp->m_pbOpaqueData,
					pNewProp->m_lDataLength);
			}
		}
		else
		{
			// Load the needed properties into the internal structure
			m_ptrQueuedSnapshot->LoadSnapshotProperties(ft,
				lMask & (VSS_PM_DETAILS_FLAG |VSS_PM_OPAQUE_FLAG), false);
				
			// Copy the setable fields from the given argument
			BS_ASSERT(m_ptrQueuedSnapshot != NULL);
			if (lMask & VSS_PM_DETAILS_FLAG)
			{
				::VssFreeString(pProp->m_pwszDetails);
				::VssSafeDuplicateStr(ft, pProp->m_pwszDetails, pNewProp->m_pwszDetails);
			}
			
			if (lMask & VSS_PM_OPAQUE_FLAG)
			{
				::VssFreeOpaqueData(pProp->m_pbOpaqueData);
				pProp->m_lDataLength = pNewProp->m_lDataLength;
				::VssSafeDuplicateOpaqueData(ft,
					pProp->m_pbOpaqueData,
					pNewProp->m_pbOpaqueData,
					pNewProp->m_lDataLength);
			}

			// Save the new properties on disk
			ft.hr = m_ptrQueuedSnapshot->SaveSnapshotPropertiesIoctl();
			if (ft.HrFailed())
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"The properties cannot be saved 0x%08lx", ft.hr);

			// Reset the internal fields that can change between Get calls.
			// Cache only the immutable fields (for the future Gets on the same interface)
			m_ptrQueuedSnapshot->ResetSnapshotProperties(ft, true);
		}
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareSnapshot::GetID(										
    OUT     VSS_ID*				pSnapshotId
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareSnapshot::GetID" );

    try
    {
        // Initialize [out] arguments
        VssZeroOut( pSnapshotId );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

		// Check parameters
		BS_ASSERT(pSnapshotId);
		if (pSnapshotId == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pSnapshotId");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: pSnapshotId = %p", pSnapshotId );

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock lock(m_cs);

		// Internal state validation
		if (m_ptrQueuedSnapshot == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL snapshot internal object." );
		}

		// Get the internal snapshot structure
		PVSS_SNAPSHOT_PROP pProp = m_ptrQueuedSnapshot->GetSnapshotProperties();
		if (pProp == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
		}

		// If the snapshot is not during creation make sure that the required fields are loaded
		BS_ASSERT(m_ptrQueuedSnapshot != NULL);
		if (m_ptrQueuedSnapshot->IsDuringCreation())
			(*pSnapshotId) = GUID_NULL;
		else
			(*pSnapshotId) = pProp->m_SnapshotId;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVsSoftwareSnapshot::GetOriginalVolumeName(						
    OUT     VSS_PWSZ*			ppwszVolumeName
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareSnapshot::GetOriginalVolumeName" );

    try
    {
        // Initialize [out] arguments
        VssZeroOut( ppwszVolumeName );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

		// Check parameters
		BS_ASSERT(ppwszVolumeName);
		if (ppwszVolumeName == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppwszVolumeName");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: ppwszVolumeName = %p", ppwszVolumeName );

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock lock(m_cs);

		// Internal state validation
		if (m_ptrQueuedSnapshot == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL snapshot internal object." );
		}

		// Get the internal snapshot structure
		PVSS_SNAPSHOT_PROP pProp = m_ptrQueuedSnapshot->GetSnapshotProperties();
		if (pProp == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
		}

		// If the snapshot is not during creation make sure that the required fields are loaded
		// Otherwise we will just copy only the existing fields
		BS_ASSERT(m_ptrQueuedSnapshot != NULL);
		if (m_ptrQueuedSnapshot->IsDuringCreation())
		{
			::VssSafeDuplicateStr(ft, (*ppwszVolumeName), pProp->m_pwszOriginalVolumeName);
		}
		else
		{
			// If the device name is not completed, search for it
			if (pProp->m_pwszSnapshotDeviceObject == NULL)
			{
				// Try to find a created snapshot with this ID
				bool bFound = m_ptrQueuedSnapshot->FindDeviceNameFromID(ft);
				
				// Handle the "snapshot not found" special error
				if (!bFound)
					ft.Throw(VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND,
							L"A snapshot with Id" WSTR_GUID_FMT L"was not found",
							GUID_PRINTF_ARG(pProp->m_SnapshotId) );
				BS_ASSERT(pProp->m_pwszSnapshotDeviceObject != NULL);
			}
			
			// Load the needed properties into the internal structure
			m_ptrQueuedSnapshot->LoadOriginalVolumeNameIoctl(ft);
				
			::VssSafeDuplicateStr(ft, (*ppwszVolumeName), pProp->m_pwszOriginalVolumeName);

			// Reset the internal fields that can change between Get calls.
			// Cache only the immutable fields (for the future Gets on the same interface)
			m_ptrQueuedSnapshot->ResetSnapshotProperties(ft, true);
		}
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVsSoftwareSnapshot::GetAttributes(								
    OUT     LONG*				plAttributes			
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareSnapshot::GetOriginalVolumeName" );

    try
    {
        // Initialize [out] arguments
        VssZeroOut( plAttributes );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

		// Check parameters
		BS_ASSERT(plAttributes);
		if (plAttributes == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL plAttributes");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: plAttributes = %p", plAttributes );

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock lock(m_cs);

		// Internal state validation
		if (m_ptrQueuedSnapshot == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL snapshot internal object." );
		}

		// Get the internal snapshot structure
		PVSS_SNAPSHOT_PROP pProp = m_ptrQueuedSnapshot->GetSnapshotProperties();
		if (pProp == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
		}

		// If the snapshot is not during creation make sure that the required fields are loaded
		// Otherwise we will just copy only the existing fields
		BS_ASSERT(m_ptrQueuedSnapshot != NULL);
		if (m_ptrQueuedSnapshot->IsDuringCreation())
		{
			(*plAttributes) = pProp->m_lSnapshotAttributes;
		}
		else
		{
			// If the device name is not completed, search for it
			if (pProp->m_pwszSnapshotDeviceObject == NULL)
			{
				// Try to find a created snapshot with this ID
				bool bFound = m_ptrQueuedSnapshot->FindDeviceNameFromID(ft);
				
				// Handle the "snapshot not found" special error
				if (!bFound)
					ft.Throw(VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND,
							L"A snapshot with Id" WSTR_GUID_FMT L"was not found",
							GUID_PRINTF_ARG(pProp->m_SnapshotId) );
				BS_ASSERT(pProp->m_pwszSnapshotDeviceObject != NULL);
			}
			
			// Load the needed properties into the internal structure
			m_ptrQueuedSnapshot->LoadAttributes(ft);
				
			(*plAttributes) = pProp->m_lSnapshotAttributes;

			// Reset the internal fields that can change between Get calls.
			// Cache only the immutable fields (for the future Gets on the same interface)
			m_ptrQueuedSnapshot->ResetSnapshotProperties(ft, true);
		}
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVsSoftwareSnapshot::SetAttributes(								
	IN	ULONG lNewAttributes,
	IN	ULONG lBitsToChange 		// Mask of bits to be changed
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareSnapshot::SetAttributes" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV,
				  L"Parameters: lNewAttributes = %lx, lBitsToChange = %lx",
				  lNewAttributes, lBitsToChange );

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock lock(m_cs);

		// Internal state validation
		if (m_ptrQueuedSnapshot == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL snapshot internal object." );
		}

		m_ptrQueuedSnapshot->SetAttributes(ft, lNewAttributes, lBitsToChange);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVsSoftwareSnapshot::GetCustomProperty(
    IN      VSS_PWSZ			pwszPropertyName,
    OUT     VARIANT*			pPropertyValue
    )
{
    return E_NOTIMPL;

    UNREFERENCED_PARAMETER(pwszPropertyName);
    UNREFERENCED_PARAMETER(pPropertyValue);
}



STDMETHODIMP CVsSoftwareSnapshot::SetCustomProperty(
    IN      VSS_PWSZ			pwszPropertyName,
    IN      VARIANT			    PropertyValue
    )
{
    return E_NOTIMPL;

    UNREFERENCED_PARAMETER(pwszPropertyName);
    UNREFERENCED_PARAMETER(PropertyValue);
}



STDMETHODIMP CVsSoftwareSnapshot::GetDevice(									
    OUT     VSS_PWSZ*			ppwszSnapshotDeviceName
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareSnapshot::GetDevice" );

    try
    {
        // Initialize [out] arguments
        VssZeroOut( ppwszSnapshotDeviceName );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

		// Check parameters
		BS_ASSERT(ppwszSnapshotDeviceName);
		if (ppwszSnapshotDeviceName == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppwszSnapshotDeviceName");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: ppwszSnapshotDeviceName = %p", ppwszSnapshotDeviceName );

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock lock(m_cs);

		// Internal state validation
		if (m_ptrQueuedSnapshot == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL snapshot internal object." );
		}

		// Get the internal snapshot structure
		PVSS_SNAPSHOT_PROP pProp = m_ptrQueuedSnapshot->GetSnapshotProperties();
		if (pProp == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
		}

		// If the snapshot is not during creation make sure that the required fields are loaded
		// Otherwise we will just copy only the existing fields
		BS_ASSERT(m_ptrQueuedSnapshot != NULL);
		if (m_ptrQueuedSnapshot->IsDuringCreation())
		{
			// TBD: Return the volume name instead?
			::VssSafeDuplicateStr(ft, (*ppwszSnapshotDeviceName), pProp->m_pwszSnapshotDeviceObject);
		}
		else
		{
			// If the device name is not completed, search for it
			if (pProp->m_pwszSnapshotDeviceObject == NULL)
			{
				// Try to find a created snapshot with this ID
				bool bFound = m_ptrQueuedSnapshot->FindDeviceNameFromID(ft);
				
				// Handle the "snapshot not found" special error
				if (!bFound)
					ft.Throw(VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND,
							L"A snapshot with Id" WSTR_GUID_FMT L"was not found",
							GUID_PRINTF_ARG(pProp->m_SnapshotId) );
				BS_ASSERT(pProp->m_pwszSnapshotDeviceObject != NULL);
			}
				
			::VssSafeDuplicateStr(ft, (*ppwszSnapshotDeviceName), pProp->m_pwszSnapshotDeviceObject);
		}
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\testprv\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by swprv.rc
//
#define IDS_PROJNAME                    100
#define IDR_SWPRV                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\testprv\src\qsnap.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module QSnap.hxx | Defines the internal data structure attached to a snapshot.
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     11/??/1999  Created.


--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL header
#include "vss.h"
#include "vscoordint.h"
#include "vsswprv.h"
#include "vsprov.h"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"

#include "ntddsnap.h"


/////////////////////////////////////////////////////////////////////////////
//  CVssQueuedSnapshot IOCTL commands


void CVssQueuedSnapshot::OpenVolumeChannel(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT)

/*++

Description:

	Open the volume IOCTL.

Warning:

	The original volume name must be already known!

--*/

{
	// Reset the error code
	ft.hr = S_OK;
		
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	if (pProp == NULL)
	{
		BS_ASSERT(false);
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
	}

	// Reset the error code
	ft.hr = S_OK;
		
	// Open the volume channel, if needed.
	if( !m_snapIChannel.IsOpen() )
	{
		if (pProp->m_pwszOriginalVolumeName == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Unknown volume name." );
		}

		LPWSTR wszVolumeName = pProp->m_pwszOriginalVolumeName;

		// Open the channel
		BS_ASSERT(wszVolumeName[0] != L'\0');
		BS_ASSERT(::wcslen(wszVolumeName) == nLengthOfVolMgmtVolumeName - 1);
		m_volumeIChannel.Open(ft, wszVolumeName);
	}
}


void CVssQueuedSnapshot::OpenSnapshotChannel(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT)

/*++

Description:

	Open the snapshot IOCTL.

Warning:

	The snapshot device name must be already known!

--*/

{
	// Reset the error code
	ft.hr = S_OK;
		
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	if (pProp == NULL)
	{
		BS_ASSERT(false);
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
	}

	// Open the snapshot channel, if needed.
	if( !m_snapIChannel.IsOpen() )
	{
		if (pProp->m_pwszSnapshotDeviceObject == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Unknown device object." );
		}

		// Get the user-mode style device name
		WCHAR wszVolSnap[MAX_PATH];
		if (::_snwprintf(wszVolSnap, MAX_PATH - 1,
				L"\\\\?\\GLOBALROOT%s", pProp->m_pwszSnapshotDeviceObject) < 0)
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Not enough memory for computing the snapshot device object name." );
		
		for(int nRetriesCount = 0; nRetriesCount < nNumberOfPnPRetries; nRetriesCount++)
		{
			ft.hr = m_snapIChannel.Open(ft, wszVolSnap, false);

			if (ft.HrSucceeded())
				break;
			else if (ft.hr != VSS_E_OBJECT_NOT_FOUND)
				ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Error while opening the VolSnap channel" );
			
			::Sleep(nMillisecondsBetweenPnPRetries);
		}
		if (ft.HrFailed())
			ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Error while opening the VolSnap channel" );
	}
}


HRESULT CVssQueuedSnapshot::PrepareForSnapshotIoctl()
{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::PrepareForSnapshotIoctl");

	try
	{
		BS_ASSERT(m_volumeIChannel.IsOpen());

		// Pack snapshot attributes
		PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
		BS_ASSERT(pProp != NULL);
		ULONG ulTmp = static_cast<ULONG>(pProp->m_lSnapshotAttributes);
		m_volumeIChannel.Pack(ft, ulTmp);

		// Pach the reserved field
		ulTmp = 0;
		m_volumeIChannel.Pack(ft, ulTmp);

		// Pack initial allocation size
		m_volumeIChannel.Pack(ft, m_llInitialAllocation);

		// Send the IOCTL
		m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT);
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


HRESULT CVssQueuedSnapshot::CommitSnapshotIoctl()
{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::CommitSnapshotIoctl");

	try
	{
		BS_ASSERT(m_volumeIChannel.IsOpen());

		// Send the IOCTL
		m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_COMMIT_SNAPSHOT);
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


HRESULT CVssQueuedSnapshot::EndCommitSnapshotIoctl(
	OUT	LPWSTR & rwszSnapVolumeName			// Ownership transferred to the caller.
	)
{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::EndCommitSnapshotIoctl");

	try
	{
		BS_ASSERT(m_volumeIChannel.IsOpen());

		// Send the IOCTL
		m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT);

		// Get the volume name length
		USHORT uVolumeNameLengthInBytes;
		m_volumeIChannel.Unpack(ft, &uVolumeNameLengthInBytes);
		INT nVolumeNameLength = uVolumeNameLengthInBytes/sizeof(WCHAR);

		// Allocate the volume name (allocate place for the zero character also)
		rwszSnapVolumeName = ::VssAllocString( ft, nVolumeNameLength );

		// Unpack ulVolumeNameLength wide characters.
		m_volumeIChannel.Unpack( ft, rwszSnapVolumeName, nVolumeNameLength );	
		rwszSnapVolumeName[nVolumeNameLength] = L'\0';
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


HRESULT CVssQueuedSnapshot::AbortPreparedSnapshotIoctl()
{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::AbortPreparedSnapshotIoctl");

	try
	{
		BS_ASSERT(m_volumeIChannel.IsOpen());

		// send the IOCTL
		m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT);
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


HRESULT CVssQueuedSnapshot::DeleteSnapshotIoctl()
{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::DeleteSnapshotIoctl");

	try
	{
		BS_ASSERT(m_volumeIChannel.IsOpen());

		// send the IOCTL
		m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT);
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  CVssQueuedSnapshot constructor


CVssQueuedSnapshot::CVssQueuedSnapshot(
	IN  VSS_OBJECT_PROP_Ptr& ptrSnap	// Ownership passed to the Constructor
	):
	m_cookie(VSS_NULL_COOKIE),
	m_llInitialAllocation(nDefaultInitialSnapshotAllocation),			// Babbage-related properties
	m_ptrSnap(ptrSnap),					// Properties related to the standard structure.
	m_SSID(GUID_NULL),					
	m_lSnapshotsCount(0),
	m_usReserved(0),
	m_usNumberOfNonstdSnapProperties(0),	// Properties related to other structures
	m_pOpaqueSnapPropertiesList(NULL),
	m_dwGlobalReservedField(0),
	m_lRefCount(0)						// Life-management
{
	if (ptrSnap.GetStruct() != NULL)
	{
		if (ptrSnap.GetStruct()->Type == VSS_OBJECT_SNAPSHOT)
			m_SSID = ptrSnap.GetStruct()->Obj.Snap.m_SnapshotSetId; // for caching.
		else
			BS_ASSERT(false);
	}
	else
		BS_ASSERT(false);
}


CVssQueuedSnapshot::~CVssQueuedSnapshot()
{
	delete m_pOpaqueSnapPropertiesList;
}


/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot Operations


void CVssQueuedSnapshot::GetSnapshotVolumeName(
		IN	CVssFunctionTracer& ft,
		IN	PVSS_SNAPSHOT_PROP pProp
		) throw(HRESULT)

/*

Description:

	This function will fill the VSS_SNAPSHOT_PROP::m_pwszSnapshotVolumeName field.

*/

{
	// Reset the error code
	ft.hr = S_OK;
		
	// Test arguments validity
	BS_ASSERT(pProp);
	BS_ASSERT(pProp->m_pwszSnapshotDeviceObject);

	// Free the previous volume name
	::VssFreeString(pProp->m_pwszSnapshotVolumeName);

	// Get the volume name only if the snashot must be visible.
	if (pProp->m_lSnapshotAttributes | VSS_VOLSNAP_ATTR_VISIBLE)
	{
		// Get the user-mode style device name
		WCHAR wszVolSnap[MAX_PATH];
		if (::_snwprintf(wszVolSnap, MAX_PATH - 1,
				L"\\\\?\\GLOBALROOT%s\\", pProp->m_pwszSnapshotDeviceObject) < 0)
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Not enough memory for computing the snapshot device object name." );

		// Retry a number of times to get the snapshot volume name from the Mount Manager
		WCHAR wszSnapshotMountPoint[MAX_PATH];
		for(int nRetriesCount = 0; nRetriesCount < nNumberOfMountMgrRetries; nRetriesCount++)
		{
			BOOL bSucceeded = ::GetVolumeNameForVolumeMountPointW( wszVolSnap, wszSnapshotMountPoint, MAX_PATH );
			if (bSucceeded)
			{							
				ft.Trace( VSSDBG_SWPRV, L"A snapshot mount point was found at %s", wszSnapshotMountPoint );
				::VssSafeDuplicateStr(ft, pProp->m_pwszSnapshotVolumeName, wszSnapshotMountPoint );
				break;
			}

			// DWORD dwError = GetLastError();
			// TBD: Deal with runtime errors (i.e. getting the snapshot volume name after deleting the snapshot.
							
			::Sleep(nMillisecondsBetweenMountMgrRetries);
		}
	}
}


PVSS_SNAPSHOT_PROP CVssQueuedSnapshot::GetSnapshotProperties()
{
	if (m_ptrSnap.GetStruct() != NULL)
	{
		if (m_ptrSnap.GetStruct()->Type == VSS_OBJECT_SNAPSHOT)
			return &(m_ptrSnap.GetStruct()->Obj.Snap);
		else
			BS_ASSERT(false);
	}
	else
		BS_ASSERT(false);

	return NULL;
}

void CVssQueuedSnapshot::SetInitialAllocation(
	LONGLONG llInitialAllocation
	)
{
	m_llInitialAllocation = llInitialAllocation;
}


LONGLONG CVssQueuedSnapshot::GetInitialAllocation()
{
	return m_llInitialAllocation;
}


VSS_SNAPSHOT_STATE CVssQueuedSnapshot::GetStatus()	
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);
	return pProp->m_eStatus;
}


bool CVssQueuedSnapshot::IsDuringCreation()

/*++

Description:

	This method returns true if the snapshot is during creation

--*/

{
	VSS_SNAPSHOT_STATE eState = GetStatus();

	switch(eState)
	{
	case VSS_SS_PREPARING:
	case VSS_SS_PREPARED:
	case VSS_SS_PRECOMMITED:
	case VSS_SS_COMMITED:
		return true;
	default:
		return false;
	}
}


void CVssQueuedSnapshot::ResetSnapshotProperties(
	IN	CVssFunctionTracer& ft,
	IN	bool bGetOnly
	) throw(HRESULT)

/*++

Description:

	Reset the internal fields that can change between Get calls.
	Cache only the immutable fields (for the future Gets on the same interface):
	- Snapshot ID
	- Snapshot Set ID
	- Provider ID
	- Snasphot Device name
	- m_lSnapshotsCount
	
--*/

{
	// Reset the error code
	ft.hr = S_OK;
		
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);

	// Reset the non-immutable property fields
	::VssFreeString(pProp->m_pwszSnapshotVolumeName);
	pProp->m_OriginalVolumeId = GUID_NULL;
	::VssFreeString(pProp->m_pwszOriginalVolumeName);
	pProp->m_lSnapshotAttributes = 0;
	::VssFreeString(pProp->m_pwszDetails);
	pProp->m_lCommitFlags = 0;
	pProp->m_tsCreationTimestamp = 0;
	pProp->m_eStatus = VSS_SS_UNKNOWN;
	pProp->m_llIncarnationNumber = 0;
	pProp->m_lDataLength = 0;
	::VssFreeOpaqueData(pProp->m_pbOpaqueData);

	// These fields are completed only inside a Set call
	if (bGetOnly)
	{
		BS_ASSERT(m_usReserved == 0);		
		BS_ASSERT(m_usNumberOfNonstdSnapProperties == 0);
		BS_ASSERT(m_pOpaqueSnapPropertiesList == NULL);
		BS_ASSERT(m_dwGlobalReservedField == 0);
	}
	else
	{
		m_usReserved = 0;		
		m_usNumberOfNonstdSnapProperties = 0;
		delete m_pOpaqueSnapPropertiesList;
		m_pOpaqueSnapPropertiesList = NULL;
		m_dwGlobalReservedField = 0;
	}

	// Close the opened IOCTL channels.
	m_volumeIChannel.Close();
	m_snapIChannel.Close();
}


void CVssQueuedSnapshot::ResetAsPreparing()	
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);
	BS_ASSERT((pProp->m_eStatus == VSS_SS_PREPARING)||
        (pProp->m_eStatus == VSS_SS_PREPARED)||
		(pProp->m_eStatus == VSS_SS_PRECOMMITED) ||
		(pProp->m_eStatus == VSS_SS_COMMITED)||
		(pProp->m_eStatus == VSS_SS_CREATED));

	// Reset the properties/members that were completed during PreCommit, Commit or PostCommit
	m_lSnapshotsCount = 0;
	pProp->m_SnapshotId = GUID_NULL;
	::VssFreeString(pProp->m_pwszSnapshotDeviceObject);
	::VssFreeString(pProp->m_pwszSnapshotVolumeName);
	pProp->m_OriginalVolumeId = GUID_NULL;
	pProp->m_lCommitFlags = 0;
	pProp->m_tsCreationTimestamp = 0;
	pProp->m_llIncarnationNumber = 0;

	// We will not Reset the properties/members that were allocated during Prepare
	// These allocation might not be executed in ResetToPrepare state!

	// These fields are completed only after a Get call that occured after creation.
	BS_ASSERT(m_usReserved == 0);		
	BS_ASSERT(m_usNumberOfNonstdSnapProperties == 0);
	BS_ASSERT(m_pOpaqueSnapPropertiesList == NULL);
	BS_ASSERT(m_dwGlobalReservedField == 0);

	// Close the opened IOCTL channels.
	m_volumeIChannel.Close();
	m_snapIChannel.Close();
		
	pProp->m_eStatus = VSS_SS_PREPARING;
}


void CVssQueuedSnapshot::MarkAsPrepared()	
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PREPARING);
	pProp->m_eStatus = VSS_SS_PREPARED;
}


void CVssQueuedSnapshot::MarkAsPreCommited()	
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PREPARED);
	pProp->m_eStatus = VSS_SS_PRECOMMITED;
}


void CVssQueuedSnapshot::MarkAsCommited()	
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PRECOMMITED);
	pProp->m_eStatus = VSS_SS_COMMITED;
}


void CVssQueuedSnapshot::MarkAsCreated(LONG lSnapshotsCount)
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);
	
	// Set the snapshot state
	BS_ASSERT(pProp->m_eStatus == VSS_SS_COMMITED);
	pProp->m_eStatus = VSS_SS_CREATED;

	// Set the snapshots count
	BS_ASSERT(lSnapshotsCount != 0);
	BS_ASSERT(m_lSnapshotsCount == 0);
	m_lSnapshotsCount = lSnapshotsCount;
}


void CVssQueuedSnapshot::MarkAsFailed()
{
}


void CVssQueuedSnapshot::MarkAsAborted()
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);

	BS_ASSERT((pProp->m_eStatus == VSS_SS_PREPARING)
		|| (pProp->m_eStatus == VSS_SS_PRECOMMITED));

	pProp->m_eStatus = VSS_SS_ABORTED;
}


void CVssQueuedSnapshot::SetCommitInfo(
	LONG			lCommitFlags
	)
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);

	BS_ASSERT(pProp->m_lCommitFlags == 0)
	pProp->m_lCommitFlags = lCommitFlags;
}


LONG CVssQueuedSnapshot::GetCommitFlags()
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);

	return pProp->m_lCommitFlags;
}


void CVssQueuedSnapshot::AttachToGlobalList(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
	// The caller must have a separate reference to the object
	AddRef();

	BS_ASSERT( m_cookie == VSS_NULL_COOKIE );
	m_cookie = m_list.AddTail( ft, this );
}


void CVssQueuedSnapshot::DetachFromGlobalList()
{
	BS_ASSERT( m_cookie != VSS_NULL_COOKIE );

	CVssQueuedSnapshot* pThis;
	m_list.ExtractByCookie( m_cookie, pThis );
	BS_ASSERT( this == pThis );
	m_cookie = VSS_NULL_COOKIE;

	// The caller must have a separate reference to the object
	Release();
}


/////////////////////////////////////////////////////////////////////////////
// CVssSnapIterator
//


CVssSnapIterator::CVssSnapIterator():
	CVssDLListIterator<CVssQueuedSnapshot*>(CVssQueuedSnapshot::m_list)
{}


CVssQueuedSnapshot* CVssSnapIterator::GetNext(
	IN		VSS_ID SSID
	)
{
	CVssQueuedSnapshot* pObj;
	while (CVssDLListIterator<CVssQueuedSnapshot*>::GetNext(pObj))
		if (pObj->m_SSID == SSID)
			return pObj;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\tsub\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by writer.rc
//
#define IDS_PROJNAME                    100
#define IDR_Writer_1                    100
#define IDR_DSSSNAPSHOTWRITER           101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\testprv\src\swprv.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module swprv.hxx | Definition the COM server of the Software Snapshot provider
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.
    aoltean     09/09/1999  dss->vss

--*/


///////////////////////////////////////////////////////////////////////////////
//   Includes
//


#include "stdafx.hxx"
#include <process.h>
#include "initguid.h"

// Generated MIDL header
#include "vss.h"
#include "vscoordint.h"
#include "vsprov.h"
#include "vsswprv.h"

#include "resource.h"
#include "vs_inc.hxx"

#include "swprv.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provider.hxx"

#include "vs_test.hxx"


///////////////////////////////////////////////////////////////////////////////
//   Static objects
//

CSwPrvSnapshotSrvModule _Module;


///////////////////////////////////////////////////////////////////////////////
//   COM classes and defines for debugging.
//

const CLSID* PCLSID_TestProvider1 = &CLSID_TestProvider1;
const CLSID* PCLSID_TestProvider2 = &CLSID_TestProvider2;
const CLSID* PCLSID_TestProvider3 = &CLSID_TestProvider3;
const CLSID* PCLSID_TestProvider4 = &CLSID_TestProvider4;


class CInstantiatedTestProvider1: public CVsTestProviderTemplate<DEBUG_TRACE_TEST1,PCLSID_TestProvider1> {};
class CInstantiatedTestProvider2: public CVsTestProviderTemplate<DEBUG_TRACE_TEST2,PCLSID_TestProvider2> {};
class CInstantiatedTestProvider3: public CVsTestProviderTemplate<DEBUG_TRACE_TEST3,PCLSID_TestProvider3> {};
class CInstantiatedTestProvider4: public CVsTestProviderTemplate<DEBUG_TRACE_TEST4,PCLSID_TestProvider4> {};


BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_TestProvider1, CInstantiatedTestProvider1)
    OBJECT_ENTRY(CLSID_TestProvider2, CInstantiatedTestProvider2)
    OBJECT_ENTRY(CLSID_TestProvider3, CInstantiatedTestProvider3)
    OBJECT_ENTRY(CLSID_TestProvider4, CInstantiatedTestProvider4)
END_OBJECT_MAP()


///////////////////////////////////////////////////////////////////////////////
//   DLL Entry point
//

//
// The real DLL Entry Point is _DLLMainCrtStartup (initializes global objects and after that calls DllMain
// this is defined in the runtime libaray
//

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        //  Set the correct tracing context. This is an inproc DLL
        g_cDbgTrace.SetContextNum(VSS_CONTEXT_DELAYED_DLL);

        //  initialize COM module
        _Module.Init(ObjectMap, hInstance);

        //  optimization
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
//   DLL Exports
//


// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}


// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\testxml\main.cpp ===
#include "stdafx.hxx"
#include "vs_inc.hxx"
#include "vss.h"
#include "vsevent.h"
#include "vswriter.h"
#include "vsbackup.h"


inline void CHECK_SUCCESS(HRESULT hr)
	{
	if (hr != S_OK)
		{
		wprintf(L"operation failed with HRESULT=%08x\n", hr);
		DebugBreak();
		}
	}

inline void CHECK_NOFAIL(HRESULT hr)
	{
	if (FAILED(hr))
		{
		wprintf(L"operation failed with HRESULT=%08x\n", hr);
		DebugBreak();
		}
	}


void PrintFiledesc(IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription)
	{
	CComBSTR bstrPath;
	CComBSTR bstrFilespec;
	CComBSTR bstrAlternate;
	CComBSTR bstrDestination;
	bool bRecursive;

	CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
	CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
	CHECK_NOFAIL(pFiledesc->GetRecursive(&bRecursive));
	CHECK_NOFAIL(pFiledesc->GetAlternateLocation(&bstrAlternate));
	CHECK_NOFAIL(pFiledesc->GetAlternateLocation(&bstrDestination));

	wprintf
		(
		L"%s\nPath=%s,Filespec=%s, Recursive=%s\n",
		wszDescription,
		bstrPath,
		bstrFilespec,
		bRecursive ? L"yes" : L"no"
		);

    if (bstrAlternate && wcslen(bstrAlternate) > 0)
		wprintf(L"Alternate Location = %s\n", bstrAlternate);

	if (bstrDestination && wcslen(bstrDestination) > 0)
		wprintf(L"Destination Location = %s\n", bstrDestination);
	}

BSTR ProcessWMXML(BSTR bstrXML)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"ProcessWMXML");
	CVssExamineWriterMetadata wm;
    CVssCreateWriterMetadata cwm;
	try
		{
		wm.Initialize(ft, bstrXML);
		}
	VSS_STANDARD_CATCH(ft);
	CHECK_SUCCESS(ft.hr);

	VSS_ID idInstance, idWriter;
	CComBSTR bstrWriterName;
	VSS_USAGE_TYPE usage;
	VSS_SOURCE_TYPE source;
	CHECK_SUCCESS(wm.GetIdentity(&idInstance, &idWriter, &bstrWriterName, &usage, &source));
	CHECK_SUCCESS
		(
		cwm.Initialize
			(
			idInstance,
			idWriter,
			bstrWriterName,
			usage,
			source
			)
		);

	WCHAR *pwszInstanceId;
	WCHAR *pwszWriterId;
	UuidToString(&idInstance, &pwszInstanceId);
	UuidToString(&idWriter, &pwszWriterId);
	wprintf
		(
		L"InstanceId=%s\nWriterId=%s\nWriterName=%s\nUsageType=%d\nSourceType=%d\n",
		pwszInstanceId,
		pwszWriterId,
		bstrWriterName,
		usage,
		source
		);

    RpcStringFree(&pwszInstanceId);
	RpcStringFree(&pwszWriterId);

	unsigned cIncludeFiles, cExcludeFiles, cComponents;
    CHECK_SUCCESS(wm.GetFileCounts(&cIncludeFiles, &cExcludeFiles, &cComponents));

	CComBSTR bstrPath;
	CComBSTR bstrFilespec;
	CComBSTR bstrAlternate;
	CComBSTR bstrDestination;
	bool bRecursive;

	for(unsigned i = 0; i < cIncludeFiles; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;
		CHECK_SUCCESS(wm.GetIncludeFile(i, &pFiledesc));

		CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
		CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
		CHECK_SUCCESS(pFiledesc->GetRecursive(&bRecursive));
		CHECK_SUCCESS(pFiledesc->GetAlternateLocation(&bstrAlternate));
		CHECK_SUCCESS
			(
			cwm.AddIncludeFiles
				(
				bstrPath,
				bstrFilespec,
				bRecursive,
				bstrAlternate
				)
			);

		PrintFiledesc(pFiledesc, L"Include File");
		}

	for(i = 0; i < cExcludeFiles; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;
		CHECK_SUCCESS(wm.GetExcludeFile(i, &pFiledesc));
		CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
		CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
		CHECK_SUCCESS(pFiledesc->GetRecursive(&bRecursive));
		CHECK_SUCCESS
			(
			cwm.AddExcludeFiles
				(
				bstrPath,
				bstrFilespec,
				bRecursive
				)
			);

		PrintFiledesc(pFiledesc, L"Exclude File");
		}

	for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
		CComPtr<IVssWMComponent> pComponent;
		PVSSCOMPONENTINFO pInfo;
		CHECK_SUCCESS(wm.GetComponent(iComponent, &pComponent));
		CHECK_SUCCESS(pComponent->GetComponentInfo(&pInfo));
		wprintf
			(
			L"Component %d, type=%d\nLogicalPath=%s,Name=%s\nCaption=%s\n",
			i,
			pInfo->type,
			pInfo->bstrLogicalPath,
			pInfo->bstrComponentName,
			pInfo->bstrCaption
			);

        wprintf
			(
			L"RestoreMetadata=%s,NotifyOnBackupComplete=%s,Selectable=%s\n",
			pInfo->bRestoreMetadata ? L"yes" : L"no",
			pInfo->bNotifyOnBackupComplete ? L"yes" : L"no",
			pInfo->bSelectable ? L"yes" : L"no"
			);

        CHECK_SUCCESS
			(
			cwm.AddComponent
				(
				pInfo->type,
				pInfo->bstrLogicalPath,
				pInfo->bstrComponentName,
				pInfo->bstrCaption,
				pInfo->bstrIcon,
				pInfo->bRestoreMetadata,
				pInfo->bNotifyOnBackupComplete,
				pInfo->bSelectable
				)
			);

        if (pInfo->cFileCount > 0)
			{
			for(i = 0; i < pInfo->cFileCount; i++)
				{
				CComPtr<IVssWMFiledesc> pFiledesc;
				CHECK_SUCCESS(pComponent->GetFile(i, &pFiledesc));
				CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
				CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
				CHECK_SUCCESS(pFiledesc->GetRecursive(&bRecursive));
				CHECK_SUCCESS
					(
					cwm.AddFilesToFileGroup
						(
						pInfo->bstrLogicalPath,
						pInfo->bstrComponentName,
						bstrPath,
						bstrFilespec,
						bRecursive
						)
					);

				PrintFiledesc(pFiledesc, L"FileGroupFile");
				}
			}

		if (pInfo->cDatabases > 0)
			{
			for(i = 0; i < pInfo->cDatabases; i++)
				{
				CComPtr<IVssWMFiledesc> pFiledesc;
				CHECK_SUCCESS(pComponent->GetDatabaseFile(i, &pFiledesc));
				CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
				CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
				CHECK_SUCCESS
					(
					cwm.AddDatabaseFiles
						(
						pInfo->bstrLogicalPath,
						pInfo->bstrComponentName,
						bstrPath,
						bstrFilespec
						)
					);

				PrintFiledesc(pFiledesc, L"DatabaseFile");
				}
			}

		if (pInfo->cLogFiles > 0)
			{
			for(i = 0; i < pInfo->cLogFiles; i++)
				{
				CComPtr<IVssWMFiledesc> pFiledesc;
				CHECK_SUCCESS(pComponent->GetDatabaseLogFile(i, &pFiledesc));
				CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
				CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
				CHECK_SUCCESS
					(
					cwm.AddDatabaseLogFiles
						(
						pInfo->bstrLogicalPath,
						pInfo->bstrComponentName,
						bstrPath,
						bstrFilespec
						)
					);

				PrintFiledesc(pFiledesc, L"DatabaseLogFile");
				}
			}

		pComponent->FreeComponentInfo(pInfo);
		}

	VSS_RESTOREMETHOD_ENUM method;
	VSS_WRITERRESTORE_ENUM writerRestore;
	CComBSTR bstrUserProcedure;
	CComBSTR bstrService;
	unsigned cMappings;

	CHECK_SUCCESS
		(
		wm.GetRestoreMethod
			(
			&method,
			&bstrService,
			&bstrUserProcedure,
			&writerRestore,
			&cMappings
			)
		);

    CHECK_SUCCESS
		(
		cwm.SetRestoreMethod
			(
			method,
			bstrService,
			bstrUserProcedure,
			writerRestore
			)
		);

    wprintf
		(
		L"Restore method=%d\nService=%s\nUser Procedure=%s\nwriterRestore=%d\n",
		method,
		bstrService,
		bstrUserProcedure,
		writerRestore
		);

	for(i = 0; i < cMappings; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;

		CHECK_SUCCESS(wm.GetAlternateLocationMapping(i, &pFiledesc));
		CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
		CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
		CHECK_SUCCESS(pFiledesc->GetRecursive(&bRecursive));
		CHECK_SUCCESS(pFiledesc->GetAlternateLocation(&bstrDestination));
		CHECK_SUCCESS
			(
			cwm.AddAlternateLocationMapping
				(
				bstrPath,
				bstrFilespec,
				bRecursive,
				bstrDestination
				)
			);

		PrintFiledesc(pFiledesc, L"AlternateMapping");
		}

	CHECK_SUCCESS(cwm.SaveAsXML(&bstrXML));
	return bstrXML;
	}


void SetBackupMetadata
	(
	IVssBackupComponents *pBackup,
	VSS_ID idInstance,
	VSS_ID idWriter,
	VSS_COMPONENT_TYPE ct,
	BSTR bstrLogicalPath,
	BSTR bstrComponentName,
	LPCWSTR wszMetadata
	)
	{
	unsigned cWriters;

	CHECK_SUCCESS(pBackup->GetWriterComponentsCount(&cWriters));
	for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
		{
		CComPtr<IVssWriterComponentsExt> pWriter;
		CHECK_SUCCESS(pBackup->GetWriterComponents(iWriter, &pWriter));
		VSS_ID idWriterT, idInstanceT;
		CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstanceT, &idWriterT));
		if (memcmp(&idInstance, &idInstanceT, sizeof(GUID)) == 0 &&
			memcmp(&idWriter, &idWriterT, sizeof(GUID)) == 0)
			{
			unsigned cComponents;
			CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));

			for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
				{
				IVssComponent *pComponent;
				CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));

				VSS_COMPONENT_TYPE ctT;
				CComBSTR bstrLogicalPathT;
				CComBSTR bstrComponentNameT;

				CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPathT));
				CHECK_SUCCESS(pComponent->GetComponentType(&ctT));
				CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentNameT));

				if (ct == ctT &&
					((bstrLogicalPath == NULL && bstrLogicalPathT.Length() == 0) ||
					 (bstrLogicalPath != NULL &&
					  bstrLogicalPathT.Length() != 0 &&
					  wcscmp(bstrLogicalPath, bstrLogicalPathT) == 0)) &&
					wcscmp(bstrComponentName, bstrComponentNameT) == 0)
					{
					CHECK_SUCCESS(pComponent->SetBackupMetadata(wszMetadata));
					break;
					}
				}
			}
		}
	}


BSTR ProcessCMXML(BSTR bstrXML)
	{
	CComPtr<IVssBackupComponents> pvbc;
	CComPtr<IVssBackupComponents> pvbcCreated;

	CHECK_SUCCESS(CreateVssBackupComponents(&pvbc));
	CHECK_SUCCESS(CreateVssBackupComponents(&pvbcCreated));


	BS_ASSERT(pvbc);
	BS_ASSERT(pvbcCreated);


	CHECK_SUCCESS(pvbc->LoadFromXML(bstrXML));
	CHECK_SUCCESS(pvbcCreated->Initialize(true, true));
	unsigned cWriters;
	CHECK_SUCCESS(pvbc->GetWriterComponentsCount(&cWriters));
	for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
		{
		CComPtr<IVssWriterComponentsExt> pWriter;
		CHECK_SUCCESS(pvbc->GetWriterComponents(iWriter, &pWriter));
		VSS_ID idWriter, idInstance;
		CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));
		unsigned cComponents;
		CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));

		for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
			{
			IVssComponent *pComponent;
			CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));

			VSS_COMPONENT_TYPE ct;
			CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;
			bool bBackupSucceeded;

			CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
			CHECK_SUCCESS(pComponent->GetComponentType(&ct));
			CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
			CHECK_SUCCESS(pComponent->GetBackupSucceeded(&bBackupSucceeded));
			CHECK_SUCCESS
				(
				pvbcCreated->AddComponent
					(
					idInstance,
					idWriter,
					ct,
					bstrLogicalPath,
					bstrComponentName
					)
				);

			CHECK_SUCCESS
				(
				pvbcCreated->SetBackupSucceeded
					(
					idInstance,
					idWriter,
					ct,
					bstrLogicalPath,
					bstrComponentName,
					bBackupSucceeded
					)
                );

			CComBSTR bstrMetadata;

            CHECK_SUCCESS(pComponent->GetBackupMetadata(&bstrMetadata));
			SetBackupMetadata
				(
				pvbcCreated,
				idInstance,
				idWriter,
				ct,
				bstrLogicalPath,
				bstrComponentName,
				bstrMetadata
				);

			unsigned cMappings;
			CHECK_SUCCESS(pComponent->GetAlternateLocationMappingCount(&cMappings));
			for(unsigned iMapping = 0; iMapping < cMappings; iMapping++)
				{
				CComPtr<IVssWMFiledesc> pFiledesc;
				CHECK_SUCCESS(pComponent->GetAlternateLocationMapping(iMapping, &pFiledesc));
				CComBSTR bstrPath;
				CComBSTR bstrFilespec;
				CComBSTR bstrDestination;
				bool bRecursive;

				CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
				CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
				CHECK_SUCCESS(pFiledesc->GetAlternateLocation(&bstrDestination));
				CHECK_SUCCESS(pFiledesc->GetRecursive(&bRecursive));
				CHECK_SUCCESS
					(
					pvbcCreated->AddAlternativeLocationMapping
						(
						idWriter,
						ct,
						bstrLogicalPath,
						bstrComponentName,
						bstrPath,
						bstrFilespec,
						bRecursive,
						bstrDestination
						)
					);
				}
			}
		}

	BSTR bstrRet;
	CHECK_SUCCESS(pvbcCreated->SaveAsXML(&bstrRet));
	return bstrRet;
	}


extern "C" __cdecl wmain(int argc, WCHAR **argv)
	{
	CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
	if (argc != 3)
		{
		wprintf(L"testxml writer-metadata-file component-file");
		exit(-1);
		}


	CVssFunctionTracer ft(VSSDBG_GEN, L"main");

	try
		{
		CXMLDocument doc;
		CComBSTR bstrXML;
		CComBSTR bstrXMLOut;

		if (!doc.LoadFromFile(ft, argv[1]))
            {
			wprintf(L"couldn't load xml document %s", argv[1]);
			exit(-1);
			}

		bstrXML = doc.SaveAsXML(ft);
		bstrXMLOut = ProcessWMXML(bstrXML);
		bstrXML = ProcessWMXML(bstrXMLOut);
		wprintf(L"\n\n%s\n\n%s\n", bstrXMLOut, bstrXML);
		if (wcscmp(bstrXML, bstrXMLOut) == 0)
			wprintf(L"\n\nSUCCESS\n");
		else
			wprintf(L"\n\nFAILURE\n");

	    if (!doc.LoadFromFile(ft, argv[2]))
			{
			wprintf(L"couldn't load xml document %s", argv[1]);
			exit(-1);
			}

		bstrXML = doc.SaveAsXML(ft);
		bstrXMLOut = ProcessCMXML(bstrXML);
		bstrXML = ProcessCMXML(bstrXML);
		wprintf(L"\n\n%s\n\n%s\n", bstrXMLOut, bstrXML);
		if (wcscmp(bstrXML, bstrXMLOut) == 0)
			wprintf(L"\n\nSUCCESS\n");
		else
			wprintf(L"\n\nFAILURE\n");
		}
	VSS_STANDARD_CATCH(ft)

	if (FAILED(ft.hr))
		wprintf(L"Failed with %08x.\n", ft.hr);

	return(0);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_demo\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vss_demo.rc
//
#define IDS_PROJNAME                    100
#define IDR_Writer_1                    100
#define IDR_DSSSNAPSHOTWRITER           101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\tsub\tsub.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module tsub.h | Declaration of the transient subscriber
    @end

Author:

    Adi Oltean  [aoltean]  08/18/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     08/18/1999  Created
    mikejohn	09/18/2000  176860: Added calling convention methods where missing

--*/


#ifndef __VSS_TSUB_WRITER_H_
#define __VSS_TSUB_WRITER_H_


#ifdef _DEBUG
#define _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_QI
#define _ATL_DEBUG_REFCOUNT
#endif // _DEBUG


/////////////////////////////////////////////////////////////////////////////
// Utility functions


LPWSTR QueryString(LPWSTR wszPrompt);
INT QueryInt(LPWSTR wszPrompt);


/////////////////////////////////////////////////////////////////////////////
// CVssWriter


class CVssTSubWriter : public CVssWriter
{

// Constructors and destructors
public:
	CVssTSubWriter();

// Ovverides
public:

	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

	virtual bool STDMETHODCALLTYPE OnFreeze();

	virtual bool STDMETHODCALLTYPE OnThaw();

	virtual bool STDMETHODCALLTYPE OnAbort();

};


#endif //__VSS_TSUB_WRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\aboutdlg.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module AboutDlg.cpp | Implementation of the About dialog
    @end

Author:

    Adi Oltean  [aoltean]  08/05/1999

Revision History:

    Name        Date        Comments

    aoltean     08/05/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
// Includes


#include "stdafx.hxx"
#include "resource.h"

#include "AboutDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About


CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_demo\vss_demo.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module vss_demo.cpp | Implementation of the Volume Snapshots demo
    @end

Author:

    Adi Oltean  [aoltean]  09/17/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/17/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes

#include "vss_demo.h"


/////////////////////////////////////////////////////////////////////////////
//  Implementation


const nMaxSnapshots = 10;			// Maximum number of snapshots in this demo.
const nInitialAllocatedSize = 20;	// 20 Mb by default for the diff area

const nStringBufferMax = 2048;		// Maximum size for the output buffer.

const LPWSTR wszDefaultSnapVolume = L"G:\\";

/////////////////////////////////////////////////////////////////////////////
//  Implementation


LPWSTR QueryString(
		IN	CVssFunctionTracer& ft,
		IN	LPWSTR wszPrompt,
		IN  LPWSTR wszDefaultValue = L""
		)
{
	static WCHAR wszBuffer[nStringBufferMax]; // No check for buffer overrun...

    if (wszDefaultValue[0])
	    ::wprintf(L"%s [\"%s\"]: ", wszPrompt, wszDefaultValue);
    else
	    ::wprintf(L"%s", wszPrompt);

	::_getws(wszBuffer);

	LPWSTR wszNewString = NULL;
	if (wszBuffer[0] != L'\0')
		::VssSafeDuplicateStr( ft, wszNewString, wszBuffer );
	else
		::VssSafeDuplicateStr( ft, wszNewString, wszDefaultValue );
	return wszNewString;
}


INT QueryInt(
		IN	LPWSTR wszPrompt,
		IN	INT nDefaultValue = 0
		)
{
	static WCHAR wszBuffer[nStringBufferMax];

	::wprintf(L"%s [%d]:", wszPrompt, nDefaultValue);
	_getws(wszBuffer);

	if (wszBuffer[0] != L'\0')
		return _wtoi(wszBuffer);
	else
		return nDefaultValue;
}


bool Question(
		IN	LPWSTR wszPrompt,
		IN	bool bDefaultTrue = true
		)
{
	static WCHAR wszBuffer[nStringBufferMax]; // No check for buffer overrun...
	::wprintf(L"%s [%c/%c] ", wszPrompt, bDefaultTrue? L'Y': L'y', bDefaultTrue? L'n': L'N' );
	::_getws(wszBuffer);

	if (bDefaultTrue)
		return (towupper(wszBuffer[0]) != 'N');
	else
		return (towupper(wszBuffer[0]) == 'Y');
}


HRESULT DemoMain()
{
    CVssFunctionTracer ft( VSSDBG_VSSDEMO, L"DemoMain" );
	LPWSTR wszVolumeName = NULL;
	CComPtr<IVssSnapshot> objSnapshotsArray[nMaxSnapshots];

    try
    {
		// Get the Snapshot Service object.
		CComPtr<IVssCoordinator> pICoord;
        ft.hr = pICoord.CoCreateInstance( CLSID_VSSCoordinator );
        if ( ft.HrFailed() )
            ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"Connection failed with hr = 0x%08lx", ft.hr);

        // Start the snapshot set
		VSS_ID SnapshotSetId;
		ft.hr = pICoord->StartSnapshotSet(&SnapshotSetId);
        if ( ft.HrFailed() )
            ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, 
					L"Error starting the snapshot set. hr = 0x%08lx", ft.hr);

        ft.Msg( L"\nSnapshot Set creation succeeded. GUID = " WSTR_GUID_FMT, 
				GUID_PRINTF_ARG( SnapshotSetId ), ft.hr);

		//
		// Add a volume to the new snapshot set. 
		//

		INT nSnapshotsCount = 0;
        while(true)
		{
            wszVolumeName = QueryString( ft, 
                L" If you want to add another volume, enter it now, using a terminating backslash, for example C:\\\n"
                L" Otherwise press enter to commit the snapshot set: ");
            if (wszVolumeName[0] == L'\0')
                break;

			CComPtr<IVssSnapshot> & pSnapshot = objSnapshotsArray[nSnapshotsCount];
			ft.hr = pICoord->AddToSnapshotSet( 
				wszVolumeName, 
				GUID_NULL, 
				&pSnapshot
				);
			if ( ft.HrFailed() )
				ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"Error on calling AddToSnapshotSet. hr = 0x%08lx", ft.hr);
			BS_ASSERT( objSnapshotsArray[nSnapshotsCount] );

			VssFreeString( wszVolumeName );

			ft.Msg( L"\nA Volume Snapshot was succesfully added to the snapshot set.", ft.hr);
/*							  
			// Access extended functionality on our particular snapshot.
			// The generic snapshot object obtained above is used.
			CComPtr<IVsSoftwareSnapshot> pSwSnapshot;
			ft.hr = pSnapshot->SafeQI( IVsSoftwareSnapshot, &pSwSnapshot );
			if ( ft.HrFailed() )
				ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"Error on querying IVsSoftwareSnapshot. hr = 0x%08lx", ft.hr);
			BS_ASSERT( pSwSnapshot );

			// Configure our volume snapshot.
			ft.hr = pSwSnapshot->SetInitialAllocation( lInitialAllocatedSize * 1024 * 1024 );
			if ( ft.HrFailed() )
				ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"Error on calling SetInitialAllocation. hr = 0x%08lx", ft.hr);

			ft.Msg( L"\nThe Volume Snapshot was succesfully configured. ");
*/
			if (++nSnapshotsCount == nMaxSnapshots)
				break;
		}

		//
		// Commit all prepared snapshots.
		//

        ft.Msg( L"\nCommiting the snapshot(s)..", ft.hr);

        ft.hr = pICoord->DoSnapshotSet( NULL,
					NULL);
        if ( ft.HrFailed() )
            ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"Error on commiting snapshot(s). hr = 0x%08lx", ft.hr);

		ft.Msg( L"\nThe snapshot(s) were succesfully created. \n");

		// Display the volume names for the created snapshots.
		for(int nIndex = 0; nIndex < nSnapshotsCount; nIndex++)
		{
			CComPtr<IVssSnapshot> & pSnapshot = objSnapshotsArray[nIndex];

			BS_ASSERT(pSnapshot);

			// Getting all the properties
			VSS_OBJECT_PROP_Ptr ptrSnapshot;
			ptrSnapshot.InitializeAsSnapshot( ft, 
				GUID_NULL,
				GUID_NULL,
				0,
				NULL,
				NULL,
				NULL,
				VSS_SWPRV_ProviderId,
				0,
				0,
				VSS_SS_UNKNOWN);
			VSS_SNAPSHOT_PROP* pSnap = &(ptrSnapshot.GetStruct()->Obj.Snap);

			ft.hr = pSnapshot->GetProperties( pSnap);
			WCHAR wszBuffer[nStringBufferMax];
			ptrSnapshot.Print(ft, wszBuffer, nStringBufferMax);

			ft.Msg( L"The properties of the snapshot #%d : %s\n", nIndex, wszBuffer);
				
			// Getting the snapshot name
			LPWSTR wszName;
			ft.hr = pSnapshot->GetDevice( &wszName );
			if (ft.HrFailed())
				ft.Err( VSSDBG_VSSTEST, E_UNEXPECTED, 
							L"Error on getting the snapshot name 0x%08lx at index %d",
							ft.hr, nIndex);

			ft.Msg( L"The name of snapshot #%d : %s\n", nIndex, wszName);
			::VssFreeString(wszName);
		}
    }
    VSS_STANDARD_CATCH(ft)

	VssFreeString( wszVolumeName );

    return ft.hr;
}

extern "C" int WINAPI _tWinMain(HINSTANCE /*hInstance*/, 
    HINSTANCE /*hPrevInstance*/, LPTSTR /*lpCmdLine*/, int /*nShowCmd*/)
{
    CVssFunctionTracer ft( VSSDBG_VSSDEMO, L"_tWinMain" );

    try
    {
		// Initialize COM library
		ft.hr = CoInitialize(NULL);
		if (ft.HrFailed())
			ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"Failure in initializing the COM library 0x%08lx", ft.hr);

		// Run the demo
		ft.hr = DemoMain();

		WCHAR wszBuffer[10]; 
		::wprintf(L"Press enter...");
		::_getws(wszBuffer);

		// Uninitialize COM library
		CoUninitialize();
	}
    VSS_STANDARD_CATCH(ft)

    return ft.HrSucceeded();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\tsub\tsub.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Writer.cpp | Implementation of Writer
    @end

Author:

    Adi Oltean  [aoltean]  08/18/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     08/18/1999  Created
    aoltean	09/22/1999  Making console output clearer
    mikejohn	09/19/2000  176860: Added calling convention methods where missing

--*/


/////////////////////////////////////////////////////////////////////////////
//  Defines

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes

#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>
#include <stdio.h>

#include "vs_assert.hxx"

#include "vss.h"
#include "vsevent.h"
#include "vswriter.h"
#include "tsub.h"


/////////////////////////////////////////////////////////////////////////////
//  constants

const WCHAR g_wszTSubApplicationName[]	= L"TSub";


/////////////////////////////////////////////////////////////////////////////
//  globals


DWORD g_dwMainThreadId = 0;

VSS_ID s_WRITERID =
	{
    0xac510e8c, 0x6bef, 0x4c78,
	0x86, 0xb7, 0xcb, 0x99, 0xcd, 0x93, 0x45, 0x6c
	};

LPCWSTR s_WRITERNAME = L"TESTWRITER";

CVssTSubWriter::CVssTSubWriter()
	{
	Initialize
		(
		s_WRITERID,
		s_WRITERNAME,
		VSS_UT_USERDATA,
		VSS_ST_OTHER,
		VSS_APP_FRONT_END,
		60 * 1000 * 10
		);	// Timeout - ten minutes
	}



/////////////////////////////////////////////////////////////////////////////
//  class CVssTSubWriter

bool STDMETHODCALLTYPE CVssTSubWriter::OnPrepareSnapshot()
{
	wprintf( L"OnPrepare\n\t#volumes = %ld\n", GetCurrentVolumeCount() );
	for(UINT nIndex = 0; nIndex < GetCurrentVolumeCount(); nIndex++)
		wprintf( L"\tVolume no. %ld: %s\n", nIndex, GetCurrentVolumeArray()[nIndex]);

	WCHAR wszPwd[MAX_PATH];
	DWORD dwChars = GetCurrentDirectoryW( MAX_PATH, wszPwd);

	bool bPwdIsAffected = IsPathAffected( wszPwd );
	if (dwChars > 0)
		wprintf( L"Current directory %s is affected by snapshot? %s\n\n",
			wszPwd, bPwdIsAffected? L"Yes": L"No");

	return true;
}


bool STDMETHODCALLTYPE CVssTSubWriter::OnFreeze()
	{
	wprintf
		(
		L"OnFreeze\n\tmy level = %d\n\n",
		GetCurrentLevel()
		);

	return true;
}


bool STDMETHODCALLTYPE CVssTSubWriter::OnThaw()
	{
	wprintf( L"OnThaw\n\n");

	return true;
	}


bool STDMETHODCALLTYPE CVssTSubWriter::OnAbort()
	{
	wprintf( L"OnAbort\n\n");

	return true;
	}


/////////////////////////////////////////////////////////////////////////////
//  Control-C handler routine


BOOL WINAPI CtrlC_HandlerRoutine(
	IN DWORD /* dwType */
	)
	{
	// End the message loop
	if (g_dwMainThreadId != 0)
		PostThreadMessage(g_dwMainThreadId, WM_QUIT, 0, 0);

	// Mark that the break was handled.
	return TRUE;
	}


/////////////////////////////////////////////////////////////////////////////
//  WinMain

extern "C" int __cdecl wmain(HINSTANCE /*hInstance*/,
    HINSTANCE /*hPrevInstance*/, LPTSTR /*lpCmdLine*/, int /*nShowCmd*/)
	{
    int nRet = 0;

    try
		{
    	// Preparing the CTRL-C handling routine - only for testing...
		g_dwMainThreadId = GetCurrentThreadId();
		::SetConsoleCtrlHandler(CtrlC_HandlerRoutine, TRUE);

        // Initialize COM library
        HRESULT hr = CoInitialize(NULL);
        if (FAILED(hr))
			{
			_ASSERTE(FALSE && "Failure in initializing the COM library");
			throw hr;
			}

		// Declare a CVssTSubWriter instance
		CVssTSubWriter *pInstance = new CVssTSubWriter;
		if (pInstance == NULL)
			throw E_OUTOFMEMORY;

		// Subscribe the object.
		pInstance->Subscribe();

        // message loop - need for STA server
        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

		// Subscribe the object.
		pInstance->Unsubscribe();
		delete pInstance;

        // Uninitialize COM library
        CoUninitialize();
		}
	catch(...)
		{
		_ASSERTE(FALSE && "Unexpected exception");
		}

    return nRet;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\asyncdlg.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module asyncdlg.cpp | Implementation of the CAsyncDlg dialog
    @end

Author:

    Adi Oltean  [aoltean]  10/10/1999

Revision History:

    Name        Date        Comments

    aoltean     10/10/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
// Includes


#include "stdafx.hxx"
#include "resource.h"

#include "GenDlg.h"

#include "VssTest.h"
#include "AsyncDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CAsyncDlg dialog

CAsyncDlg::CAsyncDlg(
        IVssAsync *pIAsync,
        CWnd* pParent
	)
    : CVssTestGenericDlg(CAsyncDlg::IDD, pParent),
    m_pIAsync(pIAsync)
{
    //{{AFX_DATA_INIT(CAsyncDlg)
	//}}AFX_DATA_INIT
    m_strState.Empty();
    m_strPercentCompleted.Empty();
}

CAsyncDlg::~CAsyncDlg()
{
}

void CAsyncDlg::DoDataExchange(CDataExchange* pDX)
{
    CVssTestGenericDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAsyncDlg)
	DDX_Text(pDX, IDC_ASYNC_STATUS,   m_strState);
	DDX_Text(pDX, IDC_ASYNC_PERF,     m_strPercentCompleted);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAsyncDlg, CVssTestGenericDlg)
    //{{AFX_MSG_MAP(CAsyncDlg)
    ON_BN_CLICKED(IDC_NEXT, OnNext)
    ON_BN_CLICKED(IDC_ASYNC_WAIT, OnWait)
    ON_BN_CLICKED(IDC_ASYNC_CANCEL, OnCancel)
    ON_BN_CLICKED(IDC_ASYNC_QUERY, OnQueryStatus)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAsyncDlg message handlers


BOOL CAsyncDlg::OnInitDialog()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CAsyncDlg::OnInitDialog" );
    USES_CONVERSION;

    try
    {
        CVssTestGenericDlg::OnInitDialog();



        UpdateData(FALSE);
    }
    VSS_STANDARD_CATCH(ft)

    return TRUE;  // return TRUE  unless you set the focus to a control
}


void CAsyncDlg::OnNext()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CAsyncDlg::OnNext" );

    try
    {
		EndDialog(IDOK);
    }
    VSS_STANDARD_CATCH(ft)
}


void CAsyncDlg::OnWait()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CCoordDlg::OnWait" );

	try
	{
		ft.hr = m_pIAsync->Wait();
		if (ft.hr != S_OK)
			ft.MsgBox( L"Return value", L"Wait returned 0x%08lx", ft.hr );
    }
    VSS_STANDARD_CATCH(ft)
}


void CAsyncDlg::OnCancel()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CCoordDlg::OnCancel" );

	try
	{
		ft.hr = m_pIAsync->Cancel();
		if (ft.hr != S_OK)
			ft.MsgBox( L"Return value", L"Cancel returned 0x%08lx", ft.hr );
    }
    VSS_STANDARD_CATCH(ft)
}


void CAsyncDlg::OnQueryStatus()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CCoordDlg::OnQueryStatus" );

	try
	{
		HRESULT hrResult = S_OK;
		INT nPercentDone = 0;

		ft.hr = m_pIAsync->QueryStatus(&hrResult, &nPercentDone);

		WCHAR wszBuffer[30];

		wsprintfW(wszBuffer, L"0x%08lx", hrResult);
		m_strState = W2T(wszBuffer);

		wsprintfW(wszBuffer, L"%3d.%02d %%", nPercentDone/100, nPercentDone%100 );
		m_strPercentCompleted = W2T(wszBuffer);

		if (ft.hr != S_OK)
			ft.MsgBox( L"Return value", L"Cancel returned 0x%08lx", ft.hr );

		UpdateData(FALSE);
    }
    VSS_STANDARD_CATCH(ft)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\aboutdlg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module AboutDlg.h | Definition of About Dialog
    @end

Author:

    Adi Oltean  [aoltean]  07/22/1999

Revision History:

    Name        Date        Comments

    aoltean     07/22/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_demo\vss_demo.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module vss_demo.cpp | header of VSS demo
    @end

Author:

    Adi Oltean  [aoltean]  09/17/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/17/1999  Created

--*/


#ifndef __VSS_DEMO_H_
#define __VSS_DEMO_H_


/////////////////////////////////////////////////////////////////////////////
//  Defines and pragmas

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>
#include <comadmin.h>

#include "vs_assert.hxx"

// ATL
#include <atlconv.h>
#include <atlbase.h>

// Application specific
#include "vs_inc.hxx"

// Generated MIDL headers
#include "vss.h"
#include "vscoordint.h"
#include "vsswprv.h"
#include "vsprov.h"

#include "copy.hxx"
#include "pointer.hxx"

#endif //__VSS_DEMO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\asyncdlg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module asyncdlg.h | Header file for the Async dialog
    @end

Author:

    Adi Oltean  [aoltean]  10/10/1999

Revision History:

    Name        Date        Comments

    aoltean     10/10/1999  Created

--*/


#if !defined(__VSS_ASYNC_DLG_H__)
#define __VSS_ASYNC_DLG_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


/////////////////////////////////////////////////////////////////////////////
// CAsyncDlg dialog

class CAsyncDlg : public CVssTestGenericDlg
{
// Construction
public:
    CAsyncDlg(
        IVssAsync *pIAsync,
        CWnd* pParent = NULL); 
    ~CAsyncDlg();

// Dialog Data
    //{{AFX_DATA(CAsyncDlg)
	enum { IDD = IDD_ASYNC };
	CString	    m_strState;
	CString	    m_strPercentCompleted;
	//}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAsyncDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    CComPtr<IVssAsync> m_pIAsync;

    // Generated message map functions
    //{{AFX_MSG(CAsyncDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnNext();
    afx_msg void OnWait();
    afx_msg void OnCancel();
    afx_msg void OnQueryStatus();
//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(__VSS_ASYNC_DLG_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\conndlg.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module ConnDlg.cpp | Implementation of the main dialog
    @end

Author:

    Adi Oltean  [aoltean]  07/22/1999

Revision History:

    Name        Date        Comments

    aoltean     07/22/1999  Created
    aoltean     08/05/1999  Splitting wizard functionality in a base class
    aoltean     09/26/1999  Better interface pointers management with ATL smart pointers

--*/


/////////////////////////////////////////////////////////////////////////////
// Includes


#include "stdafx.hxx"
#include "resource.h"

#include "GenDlg.h"

#include "VssTest.h"
#include "CoordDlg.h"
#include "ConnDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Utility defines

#define STR2W(str) ((LPTSTR)((LPCTSTR)(str)))



/////////////////////////////////////////////////////////////////////////////
// CConnectDlg dialog

CConnectDlg::CConnectDlg(CWnd* pParent /*=NULL*/)
    : CVssTestGenericDlg(CConnectDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CConnectDlg)
	m_strMachineName = _T("");
	//}}AFX_DATA_INIT
    m_bRemote = FALSE;
}

CConnectDlg::~CConnectDlg()
{
}

void CConnectDlg::DoDataExchange(CDataExchange* pDX)
{
    CVssTestGenericDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConnectDlg)
	DDX_Text(pDX, IDC_CONN_MACHINE_NAME, m_strMachineName);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CConnectDlg, CVssTestGenericDlg)
    //{{AFX_MSG_MAP(CConnectDlg)
    ON_BN_CLICKED(IDC_NEXT, OnNext)
    ON_BN_CLICKED(IDC_CONN_LOCAL, OnLocal)
    ON_BN_CLICKED(IDC_CONN_REMOTE, OnRemote)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConnectDlg message handlers

BOOL CConnectDlg::OnInitDialog()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CConnectDlg::OnInitDialog" );
    USES_CONVERSION;

    try
    {
        CVssTestGenericDlg::OnInitDialog();

        UpdateData( FALSE );

        BOOL bRes = ::CheckRadioButton( m_hWnd, IDC_CONN_LOCAL, IDC_CONN_REMOTE, IDC_CONN_LOCAL );
        _ASSERTE( bRes );
    }
    VSS_STANDARD_CATCH(ft)

    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CConnectDlg::OnNext()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CConnectDlg::OnNext" );
    USES_CONVERSION;

    CComPtr<IVssCoordinator> pICoord;

    try
    {
        UpdateData();

        if (m_bRemote)
        {
            COSERVERINFO serverInfo;
            MULTI_QI sMultiQI;
            IID iid = IID_IVssCoordinator;

            // Zero out these structures
            VssZeroOut(&serverInfo);
            VssZeroOut(&sMultiQI);

            serverInfo.pwszName = STR2W(m_strMachineName);
            sMultiQI.pIID = &iid;
            ft.hr = ::CoCreateInstanceEx( CLSID_VSSCoordinator,
                NULL, CLSCTX_REMOTE_SERVER, &serverInfo, 1, &sMultiQI);
            if ( ft.HrFailed() )
                ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Connection failed.\n hr = 0x%08lx", ft.hr);

            BS_ASSERT(sMultiQI.pItf != NULL);
            BS_ASSERT(sMultiQI.hr == S_OK);
            pICoord.Attach(reinterpret_cast<IVssCoordinator*>(sMultiQI.pItf));
        }
        else
        {
            ft.hr = pICoord.CoCreateInstance( CLSID_VSSCoordinator );
            if ( ft.HrFailed() )
                ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Connection failed with hr = 0x%08lx", ft.hr);
        }

        BS_ASSERT( pICoord != NULL );

        ShowWindow(SW_HIDE);
        CCoordDlg dlg(pICoord);
        if (dlg.DoModal() == IDCANCEL)
            EndDialog(IDCANCEL);
        else
            ShowWindow(SW_SHOW);
    }
    VSS_STANDARD_CATCH(ft)
}


void CConnectDlg::OnLocal()
{
    CWnd *pWnd;
    pWnd = GetDlgItem(IDC_CONN_STATIC_MACHINE_NAME);
    if (pWnd)
        pWnd->EnableWindow(FALSE);
    pWnd = GetDlgItem(IDC_CONN_MACHINE_NAME);
    if (pWnd)
        pWnd->EnableWindow(FALSE);

    m_bRemote = FALSE;
}


void CConnectDlg::OnRemote()
{
    CWnd *pWnd;
    pWnd = GetDlgItem(IDC_CONN_STATIC_MACHINE_NAME);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_CONN_MACHINE_NAME);
    if (pWnd)
        pWnd->EnableWindow(TRUE);

    m_bRemote = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\coorddlg.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module CoordDlg.cpp | Implementation of the coord dialog
    @end

Author:

    Adi Oltean  [aoltean]  07/22/1999

Revision History:

    Name        Date        Comments

    aoltean     07/22/1999  Created
    aoltean     08/05/1999  Splitting wizard functionality in a base class
    aoltean     08/26/1999  Adding Register providers
    aoltean     08/27/1999  Adding Unregister providers
    aoltean     08/30/1999  Adding Unregister providers error cases
    aoltean     09/09/1999  Improving UI consistency (no results on query, etc)
    aoltean     09/20/1999  Adding Query dialog

--*/


/////////////////////////////////////////////////////////////////////////////
// Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vsswprv.h"

#include "GenDlg.h"

#include "CoordDlg.h"
#include "SsDlg.h"
#include "QueryDlg.h"
#include "DelDlg.h"
#include "DiffDlg.h"
#include "SnapDlg.h"
#include "VolDlg.h"

// Include the test provider stuff
#include "vs_test.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define STR2W(str) ((LPTSTR)((LPCTSTR)(str)))


/////////////////////////////////////////////////////////////////////////////
// CCoordDlg dialog

CCoordDlg::CCoordDlg(
    IVssCoordinator *pICoord,
    CWnd* pParent /*=NULL*/
    )
    : CVssTestGenericDlg(CCoordDlg::IDD, pParent), m_pICoord(pICoord)
{
    //{{AFX_DATA_INIT(CCoordDlg)
	//}}AFX_DATA_INIT
}

CCoordDlg::~CCoordDlg()
{
}

void CCoordDlg::DoDataExchange(CDataExchange* pDX)
{
    CVssTestGenericDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCoordDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CCoordDlg, CVssTestGenericDlg)
    //{{AFX_MSG_MAP(CCoordDlg)
    ON_BN_CLICKED(IDC_NEXT, OnNext)
    ON_BN_CLICKED(IDC_COORD_CREATE,     OnCreateSs)
    ON_BN_CLICKED(IDC_COORD_QUERY,      OnQueryObj)
    ON_BN_CLICKED(IDC_COORD_DELETE,     OnDeleteObj)
    ON_BN_CLICKED(IDC_ADMIN_REGISTER,   OnRegisterProv)
    ON_BN_CLICKED(IDC_ADMIN_UNREGISTER, OnUnregisterProv)
    ON_BN_CLICKED(IDC_ADMIN_QUERY,      OnQueryProv)
    ON_BN_CLICKED(IDC_COORD_DIFF_AREA,  OnDiffArea)
    ON_BN_CLICKED(IDC_COORD_SNAPSHOT,   OnSnapshot)
    ON_BN_CLICKED(IDC_COORD_ISVOLUME,   OnIsVolumeXXX)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCoordDlg message handlers

BOOL CCoordDlg::OnInitDialog()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CCoordDlg::OnInitDialog" );

    try
    {
        CVssTestGenericDlg::OnInitDialog();

        m_eMethodType = VSST_E_CREATE_SS;
        BOOL bRes = ::CheckRadioButton( m_hWnd, IDC_COORD_CREATE, IDC_ADMIN_QUERY, IDC_COORD_CREATE );
        _ASSERTE( bRes );

        CWnd* pWnd = GetDlgItem(IDC_COORD_DIFF_AREA);
        if (pWnd)
            pWnd->EnableWindow(false);

        UpdateData( FALSE );
    }
    VSS_STANDARD_CATCH(ft)

    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CCoordDlg::OnNext()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CCoordDlg::OnNext" );
    USES_CONVERSION;

    try
    {
        UpdateData();

		int nRet;
        switch(m_eMethodType)
        {
        case VSST_E_CREATE_SS:
            {
                VSS_ID SnapshotSetId;

                BS_ASSERT( m_pICoord );
                ft.hr = m_pICoord->StartSnapshotSet( &SnapshotSetId );

                if ( ft.HrFailed() )
                    ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"StartSnapshotSet failed with hr = 0x%08lx", ft.hr);

                ShowWindow(SW_HIDE);
                CSnapshotSetDlg dlg(m_pICoord, SnapshotSetId);
				nRet = (int)dlg.DoModal();

                switch(nRet)
				{
				case IDCANCEL:
                    EndDialog(IDCANCEL);
					break;
				case ID_BACK:
					{
						CComPtr<IVssAdmin> pAdmin;
						ft.hr = m_pICoord->SafeQI( IVssAdmin, &pAdmin);
						if ( ft.HrFailed() )
							ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"SafeQI( IVssAdmin, pAdmin) failed with hr = 0x%08lx", ft.hr);

						ft.hr = pAdmin->AbortAllSnapshotsInProgress();
						if ( ft.HrFailed() )
							ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"AbortAllSnapshotsInProgress() failed with hr = 0x%08lx", ft.hr);
					}
				case IDOK:
                    ShowWindow(SW_SHOW);
					break;
				}
            }
            break;
        case VSST_E_QUERY_OBJ:
			{
                ShowWindow(SW_HIDE);
                CQueryDlg dlg(m_pICoord);
                if (dlg.DoModal() == IDCANCEL)
                    EndDialog(IDCANCEL);
                else
                    ShowWindow(SW_SHOW);
			}
            break;
        case VSST_E_DELETE_OBJ:
			{
                ShowWindow(SW_HIDE);
                CDeleteDlg dlg(m_pICoord);
                if (dlg.DoModal() == IDCANCEL)
                    EndDialog(IDCANCEL);
                else
                    ShowWindow(SW_SHOW);
			}
            break;
        case VSST_E_REGISTER_PROV:
            {
                CComPtr<IVssAdmin> pAdminItf;
                BS_ASSERT(m_pICoord);
                ft.hr = m_pICoord.QueryInterface(&pAdminItf);
                if (ft.HrFailed())
                    ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error calling QI");
                ft.hr = pAdminItf->RegisterProvider( VSS_SWPRV_ProviderId,
                                                     CLSID_VSSoftwareProvider,
                                                     L"Software provider",
													 VSS_PROV_SYSTEM,
                                                     L"1.0.0.6",
                                                     VSS_SWPRV_ProviderVersionId
                                                     );
                if ( ft.HrSucceeded() )
                {
                    ft.MsgBox( L"OK", L"Software provider registered" );
                }
                else if ( ft.hr == VSS_E_PROVIDER_ALREADY_REGISTERED )
                    ft.MsgBox( L"OK", L"Software provider is already registered" );
                else
                    ft.MsgBox( L"Error", L"Registering the Software provider failed. hr = 0x%08lx", ft.hr);

                ft.hr = pAdminItf->RegisterProvider( PROVIDER_ID_Test1,
                                                     CLSID_TestProvider1,
                                                     L"Test provider 1",
													 VSS_PROV_SOFTWARE,
                                                     L"1.0.0.1",
                                                     PROVIDER_ID_Test1 );
                if ( ft.HrSucceeded() )
                {
                    ft.MsgBox( L"OK", L"Test provider 1 registered" );
                }
                else if ( ft.hr == VSS_E_PROVIDER_ALREADY_REGISTERED )
                    ft.MsgBox( L"OK", L"Test provider 1 is already registered" );
                else
                    ft.MsgBox( L"Error", L"Registering the Test provider 1 failed. hr = 0x%08lx", ft.hr);

                ft.hr = pAdminItf->RegisterProvider( PROVIDER_ID_Test2,
                                                     CLSID_TestProvider2,
                                                     L"Test provider 2",
													 VSS_PROV_SOFTWARE,
                                                     L"1.0.0.2",
                                                     PROVIDER_ID_Test2 );
                if ( ft.HrSucceeded() )
                {
                    ft.MsgBox( L"OK", L"Test provider 2 registered" );
                }
                else if ( ft.hr == VSS_E_PROVIDER_ALREADY_REGISTERED )
                    ft.MsgBox( L"OK", L"Test provider 2 is already registered" );
                else
                    ft.MsgBox( L"Error", L"Registering the Test provider 2 failed. hr = 0x%08lx", ft.hr);

                ft.hr = pAdminItf->RegisterProvider( PROVIDER_ID_Test3,
                                                     CLSID_TestProvider3,
                                                     L"Test provider 3",
													 VSS_PROV_HARDWARE,
                                                     L"1.0.0.3",
                                                     PROVIDER_ID_Test3 );
                if ( ft.HrSucceeded() )
                {
                    ft.MsgBox( L"OK", L"Test provider 3 registered" );
                }
                else if ( ft.hr == VSS_E_PROVIDER_ALREADY_REGISTERED )
                    ft.MsgBox( L"OK", L"Test provider 3 is already registered" );
                else
                    ft.MsgBox( L"Error", L"Registering the Test provider 3 failed. hr = 0x%08lx", ft.hr);

                ft.hr = pAdminItf->RegisterProvider( PROVIDER_ID_Test4,
                                                     CLSID_TestProvider4,
                                                     L"Test provider 4",
													 VSS_PROV_HARDWARE,
                                                     L"1.0.0.4",
                                                     PROVIDER_ID_Test4 );
                if ( ft.HrSucceeded() )
                {
                    ft.MsgBox( L"OK", L"Test provider 4 registered" );
                }
                else if ( ft.hr == VSS_E_PROVIDER_ALREADY_REGISTERED )
                    ft.MsgBox( L"OK", L"Test provider 4 is already registered" );
                else
                    ft.MsgBox( L"Error", L"Registering the Test provider 4 failed. hr = 0x%08lx", ft.hr);
            }
            break;
        case VSST_E_UNREGISTER_PROV:
            {
                CComPtr<IVssAdmin> pAdminItf;
                BS_ASSERT(m_pICoord);
                ft.hr = m_pICoord.QueryInterface(&pAdminItf);
                if (ft.HrFailed())
                    ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error calling QI");
                ft.hr = pAdminItf->UnregisterProvider( VSS_SWPRV_ProviderId );
                if ( ft.HrSucceeded() )
                    ft.MsgBox( L"OK", L"Software provider unregistered" );
                else if (ft.hr == VSS_E_PROVIDER_NOT_REGISTERED)
                    ft.MsgBox( L"Error", L"Software provider not registered. Nothing to unregister.");
                else
                    ft.MsgBox( L"Error", L"Unregistering the Software provider failed. hr = 0x%08lx", ft.hr);

                ft.hr = pAdminItf->UnregisterProvider( PROVIDER_ID_Test1 );
                if ( ft.HrSucceeded() )
                    ft.MsgBox( L"OK", L"Test provider 1 unregistered." );
                else if (ft.hr == VSS_E_PROVIDER_NOT_REGISTERED)
                    ft.MsgBox( L"Error", L"Test provider 1 not registered. Nothing to unregister.");
                else
                    ft.MsgBox( L"Error", L"Unregistering the Test provider 1 failed. hr = 0x%08lx", ft.hr);

                ft.hr = pAdminItf->UnregisterProvider( PROVIDER_ID_Test2 );
                if ( ft.HrSucceeded() )
                    ft.MsgBox( L"OK", L"Test provider 2 unregistered." );
                else if (ft.hr == VSS_E_PROVIDER_NOT_REGISTERED)
                    ft.MsgBox( L"Error", L"Test provider 2 not registered. Nothing to unregister.");
                else
                    ft.MsgBox( L"Error", L"Unregistering the Test provider 2 failed. hr = 0x%08lx", ft.hr);

                ft.hr = pAdminItf->UnregisterProvider( PROVIDER_ID_Test3 );
                if ( ft.HrSucceeded() )
                    ft.MsgBox( L"OK", L"Test provider 3 unregistered." );
                else if (ft.hr == VSS_E_PROVIDER_NOT_REGISTERED)
                    ft.MsgBox( L"Error", L"Test provider 3 not registered. Nothing to unregister.");
                else
                    ft.MsgBox( L"Error", L"Unregistering the Test provider 3 failed. hr = 0x%08lx", ft.hr);

                ft.hr = pAdminItf->UnregisterProvider( PROVIDER_ID_Test4 );
                if ( ft.HrSucceeded() )
                    ft.MsgBox( L"OK", L"Test provider 4 unregistered." );
                else if (ft.hr == VSS_E_PROVIDER_NOT_REGISTERED)
                    ft.MsgBox( L"Error", L"Test provider 4 not registered. Nothing to unregister.");
                else
                    ft.MsgBox( L"Error", L"Unregistering the Test provider 4 failed. hr = 0x%08lx", ft.hr);

            }
            break;
        case VSST_E_QUERY_PROV:
            {
                CComPtr<IVssAdmin> pAdminItf;
                BS_ASSERT(m_pICoord);
                ft.hr = m_pICoord.QueryInterface(&pAdminItf);
                if (ft.HrFailed())
                    ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error calling QI");
                CComPtr<IVssEnumObject> pEnum;
                ft.hr = pAdminItf->QueryProviders(&pEnum);
                if (ft.HrFailed())
                    ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error calling QueryProviders");

                ULONG ulFetched;
                VSS_OBJECT_PROP sObjProp;
                CComBSTR bstrList;
                WCHAR wszBuffer[2048];
                while(true)
                {
                    // Next snapshot
                    ft.hr = pEnum->Next(1, &sObjProp, &ulFetched);
                    if (ft.hr == S_FALSE) // end of enumeration
	                    break;
                    if (ft.HrFailed())
                        ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error calling Next");

                    // Build the string
                    ::wsprintf(wszBuffer, L"ID: " WSTR_GUID_FMT L", Name: %s, Type: %d, Version: %s, VersionID: "
                        WSTR_GUID_FMT L", ClassID: " WSTR_GUID_FMT L"\n\n",
                        GUID_PRINTF_ARG( sObjProp.Obj.Prov.m_ProviderId ),
                        sObjProp.Obj.Prov.m_pwszProviderName,
                        sObjProp.Obj.Prov.m_eProviderType,
                        sObjProp.Obj.Prov.m_pwszProviderVersion,
                        GUID_PRINTF_ARG( sObjProp.Obj.Prov.m_ProviderVersionId ),
                        GUID_PRINTF_ARG( sObjProp.Obj.Prov.m_ClassId )
                        );

                    bstrList.Append(T2W(wszBuffer));
                    if (!bstrList)
                        ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Memory allocation error");

                    // release COM allocated pointers at unmarshalling time
                    CoTaskMemFree((void**)sObjProp.Obj.Prov.m_pwszProviderName);
                    CoTaskMemFree((void**)sObjProp.Obj.Prov.m_pwszProviderVersion);
                }
                if (bstrList.Length() != 0)
                    ft.MsgBox( L"Results", bstrList.m_str);
                else
                    ft.MsgBox( L"Results", L"Empty query result");
            }
            break;
        case VSST_E_DIFF_AREA:
            {
                ShowWindow(SW_HIDE);
                CDiffDlg dlg(m_pICoord);
				nRet = (int)dlg.DoModal();

                switch(nRet)
				{
				case IDCANCEL:
                    EndDialog(IDCANCEL);
					break;
				case ID_BACK:
				case IDOK:
                    ShowWindow(SW_SHOW);
					break;
				default:
					BS_ASSERT(false);
				}
            }
            break;
        case VSST_E_SNAPSHOT:
            {
                ShowWindow(SW_HIDE);
                CSnapDlg dlg(m_pICoord);
				nRet = (int)dlg.DoModal();

                switch(nRet)
				{
				case IDCANCEL:
                    EndDialog(IDCANCEL);
					break;
				case ID_BACK:
				case IDOK:
                    ShowWindow(SW_SHOW);
					break;
				default:
					BS_ASSERT(false);
				}
            }
            break;
        case VSST_E_ISVOLUMEXXX:
            {
                ShowWindow(SW_HIDE);
                CVolDlg dlg(m_pICoord);
				nRet = (int)dlg.DoModal();

                switch(nRet)
				{
				case IDCANCEL:
                    EndDialog(IDCANCEL);
					break;
				case ID_BACK:
				case IDOK:
                    ShowWindow(SW_SHOW);
					break;
				default:
					BS_ASSERT(false);
				}
            }
            break;
        default:
            BS_ASSERT(false);
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Invalid method type");
        }

    }
    VSS_STANDARD_CATCH(ft)
}


void CCoordDlg::OnCreateSs()
{
    m_eMethodType = VSST_E_CREATE_SS;
}


void CCoordDlg::OnQueryObj()
{
    m_eMethodType = VSST_E_QUERY_OBJ;
}


void CCoordDlg::OnDeleteObj()
{
    m_eMethodType = VSST_E_DELETE_OBJ;
}


void CCoordDlg::OnRegisterProv()
{
    m_eMethodType = VSST_E_REGISTER_PROV;
}


void CCoordDlg::OnUnregisterProv()
{
    m_eMethodType = VSST_E_UNREGISTER_PROV;
}


void CCoordDlg::OnQueryProv()
{
    m_eMethodType = VSST_E_QUERY_PROV;
}

void CCoordDlg::OnDiffArea()
{
    m_eMethodType = VSST_E_DIFF_AREA;
}

void CCoordDlg::OnSnapshot()
{
    m_eMethodType = VSST_E_SNAPSHOT;
}

void CCoordDlg::OnIsVolumeXXX()
{
    m_eMethodType = VSST_E_ISVOLUMEXXX;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\coorddlg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module CoordDlg.h | Header file for the coord dialog
    @end

Author:

    Adi Oltean  [aoltean]  07/22/1999

Revision History:

    Name        Date        Comments

    aoltean     07/22/1999  Created
    aoltean     08/05/1999  Splitting wizard functionality in a base class

--*/


#if !defined(__VSS_TEST_COORD_H__)
#define __VSS_TEST_COORD_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


/////////////////////////////////////////////////////////////////////////////
// CCoordDlg dialog

class CCoordDlg : public CVssTestGenericDlg
{
    typedef enum _EMethodType {
        VSST_E_CREATE_SS,
        VSST_E_QUERY_OBJ,           
        VSST_E_DELETE_OBJ,          
        VSST_E_REGISTER_PROV,       
        VSST_E_UNREGISTER_PROV,     
        VSST_E_QUERY_PROV,
        VSST_E_DIFF_AREA,
        VSST_E_SNAPSHOT,
        VSST_E_ISVOLUMEXXX,
    } EMethodType;

// Construction
public:
    CCoordDlg(
        IVssCoordinator *pICoord,
        CWnd* pParent = NULL); 
    ~CCoordDlg();

// Dialog Data
    //{{AFX_DATA(CCoordDlg)
	enum { IDD = IDD_COORD };
	//}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCoordDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    CComPtr<IVssCoordinator> m_pICoord;
    EMethodType m_eMethodType;

    // Generated message map functions
    //{{AFX_MSG(CCoordDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnNext();
    afx_msg void OnCreateSs();
    afx_msg void OnQueryObj();
    afx_msg void OnDeleteObj();
    afx_msg void OnRegisterProv();
    afx_msg void OnUnregisterProv();
    afx_msg void OnQueryProv();
    afx_msg void OnDiffArea();
    afx_msg void OnSnapshot();
    afx_msg void OnIsVolumeXXX();
//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(__VSS_TEST_COORD_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\conndlg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module ConnDlg.h | Header file for the main dialog
    @end

Author:

    Adi Oltean  [aoltean]  07/22/1999

Revision History:

    Name        Date        Comments

    aoltean     07/22/1999  Created
    aoltean     08/05/1999  Splitting wizard functionality in a base class

--*/


#if !defined(__VSS_TEST_CONN_H__)
#define __VSS_TEST_CONN_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


/////////////////////////////////////////////////////////////////////////////
// CConnectDlg dialog

class CConnectDlg : public CVssTestGenericDlg
{
// Construction
public:
    CConnectDlg(CWnd* pParent = NULL); // standard constructor
    ~CConnectDlg();

// Dialog Data
    //{{AFX_DATA(CConnectDlg)
	enum { IDD = IDD_CONNECT };
	CString	m_strMachineName;
	//}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConnectDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    BOOL    m_bRemote;
    HICON   m_hIcon;

    // Generated message map functions
    //{{AFX_MSG(CConnectDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnNext();
    afx_msg void OnLocal();
    afx_msg void OnRemote();
//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(__VSS_TEST_CONN_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\diffdlg.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module DiffDlg.cpp | Implementation of the diff dialog
    @end

Author:

    Adi Oltean  [aoltean]  01/25/2000

Revision History:

    Name        Date        Comments

    aoltean     01/25/2000  Created

--*/


/////////////////////////////////////////////////////////////////////////////
// Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vsswprv.h"

#include "GenDlg.h"

#include "VssTest.h"
#include "DiffDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define STR2W(str) ((LPTSTR)((LPCTSTR)(str)))


/////////////////////////////////////////////////////////////////////////////
// CDiffDlg dialog

CDiffDlg::CDiffDlg(
    IVssCoordinator *pICoord,
    CWnd* pParent /*=NULL*/
    )
    : CVssTestGenericDlg(CDiffDlg::IDD, pParent), m_pICoord(pICoord)
{
    //{{AFX_DATA_INIT(CDiffDlg)
	m_strVolumeName.Empty();
	m_strVolumeMountPoint.Empty();
	m_strVolumeDevice.Empty();
	m_strVolumeID.Empty();
	m_strUsedBytes.Empty();
	m_strAllocatedBytes.Empty();
	m_strMaximumBytes.Empty();
	//}}AFX_DATA_INIT
}

CDiffDlg::~CDiffDlg()
{
}

void CDiffDlg::DoDataExchange(CDataExchange* pDX)
{
    CVssTestGenericDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDiffDlg)
	DDX_Text(pDX, IDC_DIFF_VOLUME_NAME,	m_strVolumeName);
	DDX_Text(pDX, IDC_DIFF_MOUNT, 		m_strVolumeMountPoint);
	DDX_Text(pDX, IDC_DIFF_DEVICE, 		m_strVolumeDevice);
	DDX_Text(pDX, IDC_DIFF_VOLUME_ID, 	m_strVolumeID);
	DDX_Text(pDX, IDC_DIFF_USED, 		m_strUsedBytes);
	DDX_Text(pDX, IDC_DIFF_ALLOCATED, 	m_strAllocatedBytes);
	DDX_Text(pDX, IDC_DIFF_MAXIMUM, 	m_strMaximumBytes);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDiffDlg, CVssTestGenericDlg)
    //{{AFX_MSG_MAP(CDiffDlg)
    ON_BN_CLICKED(IDC_NEXT,					OnNext)
    ON_BN_CLICKED(IDC_DIFF_ADD_VOL,			OnAddVol)
    ON_BN_CLICKED(IDC_DIFF_QUERY_DIFF,		OnQueryDiff)
    ON_BN_CLICKED(IDC_DIFF_CLEAR_DIFF,		OnClearDiff)
    ON_BN_CLICKED(IDC_DIFF_GET_SIZES,		OnGetSizes)
    ON_BN_CLICKED(IDC_DIFF_SET_ALLOCATED,	OnSetAllocated)
    ON_BN_CLICKED(IDC_DIFF_SET_MAXIMUM,		OnSetMaximum)
    ON_BN_CLICKED(IDC_DIFF_NEXT_VOLUME,		OnNextVolume)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDiffDlg message handlers

BOOL CDiffDlg::OnInitDialog()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CDiffDlg::OnInitDialog" );

    try
    {
        CVssTestGenericDlg::OnInitDialog();

        m_eMethodType = VSST_F_ADD_VOL;
        BOOL bRes = ::CheckRadioButton( m_hWnd,
			IDC_DIFF_ADD_VOL,
			IDC_DIFF_SET_MAXIMUM,
			IDC_DIFF_ADD_VOL );
        _ASSERTE( bRes );

        UpdateData( FALSE );
    }
    VSS_STANDARD_CATCH(ft)

    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CDiffDlg::OnNext()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CDiffDlg::OnNext" );
    USES_CONVERSION;
/*
    try
    {
        UpdateData();

		// Get the volume mount point
		LPWSTR pwszVolumeMountPoint = T2W(const_cast<LPTSTR>(LPCTSTR(m_strVolumeName)));

		// Get the diff area interface
		m_pIDiffArea = NULL;
		ft.hr = m_pICoord->GetExtension(
			VSS_SWPRV_ProviderId,
			pwszVolumeMountPoint,
			IID_IVsDiffArea,
			reinterpret_cast<IUnknown**>(&m_pIDiffArea)
			);
		if (ft.HrFailed())
			ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error getting the diff area interface 0x%08lx", ft.hr);

        switch(m_eMethodType)
        {
        case VSST_F_ADD_VOL:
            {
				// Get the volume mount point
				LPWSTR pwszVolumeMountPoint = T2W(const_cast<LPTSTR>(LPCTSTR(m_strVolumeMountPoint)));

				// Add the volume
				BS_ASSERT(m_pIDiffArea);
				ft.hr = m_pIDiffArea->AddVolume(pwszVolumeMountPoint);
				if (ft.HrFailed())
					ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
								L"Error adding the volume 0x%08lx", ft.hr);
            }
            break;
        case VSST_F_QUERY_DIFF:
			{
				// Query the diff area
				BS_ASSERT(m_pIDiffArea);
				m_pEnum = NULL;
				ft.hr = m_pIDiffArea->Query(&m_pEnum);
				if (ft.HrFailed())
					ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
								L"Error querying the volumes 0x%08lx", ft.hr);

				// Enable the "Next volume" button
			    if (CWnd *pWnd = GetDlgItem(IDC_DIFF_NEXT_VOLUME))
			        pWnd->EnableWindow(true);

				// Print hte results for the first volume
				OnNextVolume();
			}
            break;
        case VSST_F_CLEAR_DIFF:
			{
				// Query the diff area
				BS_ASSERT(m_pIDiffArea);
				ft.hr = m_pIDiffArea->Clear();
				if (ft.HrFailed())
					ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
								L"Error clearing the diff area 0x%08lx", ft.hr);
			}
            break;
        case VSST_F_GET_SIZES:
            {
				// Get the used space
				BS_ASSERT(m_pIDiffArea);

				LONGLONG llTmp;
				ft.hr = m_pIDiffArea->GetUsedVolumeSpace(&llTmp);
				if (ft.HrFailed())
					ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
								L"Error getting the used disk space 0x%08lx", ft.hr);
				m_strUsedBytes.Format( L"%ld", (LONG)(llTmp / 1024) );
				
				ft.hr = m_pIDiffArea->GetAllocatedVolumeSpace(&llTmp);
				if (ft.HrFailed())
					ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
								L"Error getting the allocated disk space 0x%08lx", ft.hr);
				m_strAllocatedBytes.Format( L"%ld", (LONG)(llTmp / 1024) );
				
				ft.hr = m_pIDiffArea->GetMaximumVolumeSpace(&llTmp);
				if (ft.HrFailed())
					ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
								L"Error getting the max disk space 0x%08lx", ft.hr);
				m_strMaximumBytes.Format( L"%ld", (LONG)(llTmp / 1024) );

				UpdateData( FALSE );
            }
            break;
        case VSST_F_SET_ALLOCATED:
            {
            	LONG lTmp = 0;
            	LPWSTR wszSpace = T2W((LPTSTR)(LPCTSTR)m_strAllocatedBytes);
				if ( 0==swscanf(wszSpace, L"%ld", &lTmp))
					ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
								L"Error getting the allocated disk space from %s", wszSpace);

				if ( lTmp < 0)
					ft.MsgBox(L"Error", L"Negative allocated space %ld", lTmp);

				// Set the allocated space
				BS_ASSERT(m_pIDiffArea);

				LONGLONG llTmp;
				ft.hr = m_pIDiffArea->SetAllocatedVolumeSpace(((LONGLONG)lTmp)*1024);
				if (ft.HrFailed())
					ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
								L"Error setting the allocated disk space 0x%08lx", ft.hr);
            }
            break;
        case VSST_F_SET_MAXIMUM:
            {
            	LONG lTmp = 0;
            	LPWSTR wszSpace = T2W((LPTSTR)(LPCTSTR)m_strMaximumBytes);
				if ( 0==swscanf(wszSpace, L"%ld", &lTmp))
					ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
								L"Error getting the maximum disk space from %s", wszSpace);

				if ( lTmp < 0)
					ft.MsgBox(L"Error", L"Negative maximum space %ld", lTmp);

				// Set the maximum space
				BS_ASSERT(m_pIDiffArea);

				LONGLONG llTmp;
				ft.hr = m_pIDiffArea->SetMaximumVolumeSpace(((LONGLONG)lTmp)*1024);
				if (ft.HrFailed())
					ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
								L"Error setting the maximum disk space 0x%08lx", ft.hr);
            }
            break;
        default:
            BS_ASSERT(false);
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Invalid method type");
        }

    }
    VSS_STANDARD_CATCH(ft)
*/
}


void CDiffDlg::OnAddVol()
{
    m_eMethodType = VSST_F_ADD_VOL;
}


void CDiffDlg::OnQueryDiff()
{
    m_eMethodType = VSST_F_QUERY_DIFF;
}


void CDiffDlg::OnClearDiff()
{
    m_eMethodType = VSST_F_CLEAR_DIFF;
}


void CDiffDlg::OnGetSizes()
{
    m_eMethodType = VSST_F_GET_SIZES;
}


void CDiffDlg::OnSetAllocated()
{
    m_eMethodType = VSST_F_SET_ALLOCATED;
}


void CDiffDlg::OnSetMaximum()
{
    m_eMethodType = VSST_F_SET_MAXIMUM;
}

void CDiffDlg::OnNextVolume()
{
	CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CDiffDlg::OnNextVolume");
	
    if (m_pEnum == NULL)
    	return;
/*
	// Empty the volume fields
	m_strVolumeDevice.Empty();
	m_strVolumeID.Empty();
	m_strVolumeMountPoint.Empty();

	// Get the properties
	VSS_OBJECT_PROP_Ptr ptrObjProp;
	ptrObjProp.InitializeAsEmpty(ft);

	VSS_OBJECT_PROP* pProp = ptrObjProp.GetStruct();
	BS_ASSERT(pProp);
	ULONG ulFetched;
    ft.hr = m_pEnum->Next(1, pProp, &ulFetched);
	if (ft.HrFailed())
		ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
					L"Error querying the next volume 0x%08lx", ft.hr);

	// If this is the last volume then disable enumeration
    if (ft.hr == S_FALSE)
    {
    	ft.Trace( VSSDBG_VSSTEST, L"End of enumeration");
	    if (CWnd *pWnd = GetDlgItem(IDC_DIFF_NEXT_VOLUME))
	        pWnd->EnableWindow(false);
    }

    // Fill the dialog fields
    if (pProp->Type == VSS_OBJECT_VOLUME)
    {
    	VSS_VOLUME_PROP* pVolProp = &(pProp->Obj.Vol);
    	
		if (pVolProp->m_pwszVolumeName)
			m_strVolumeMountPoint.Format(L"%s", pVolProp->m_pwszVolumeName);

		if (pVolProp->m_pwszVolumeDeviceObject)
			m_strVolumeDevice.Format(L"%s", pVolProp->m_pwszVolumeDeviceObject);

		m_strVolumeID.Format( WSTR_GUID_FMT, GUID_PRINTF_ARG(pVolProp->m_VolumeId) );
	}
*/
	UpdateData( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\deldlg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module DelDlg.h | Header file for the delete snapshots dialog
    @end

Author:

    Adi Oltean  [aoltean]  10/10/1999

Revision History:

    Name        Date        Comments

    aoltean     10/10/1999  Created

--*/


#if !defined(__VSS_TEST_DELETE_H__)
#define __VSS_TEST_DELETE_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


/////////////////////////////////////////////////////////////////////////////
// CDeleteDlg dialog

class CDeleteDlg : public CVssTestGenericDlg
{
// Construction
public:
    CDeleteDlg(
        IVssCoordinator *pICoord,
        CWnd* pParent = NULL); 
    ~CDeleteDlg();

// Dialog Data
    //{{AFX_DATA(CDeleteDlg)
	enum { IDD = IDD_DELETE };
	CString	    m_strObjectId;
	BOOL 		m_bForceDelete;
	//}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDeleteDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    CComPtr<IVssCoordinator> m_pICoord;
    VSS_OBJECT_TYPE m_eSrcType;

    // Generated message map functions
    //{{AFX_MSG(CDeleteDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnNext();
    afx_msg void OnSrcSnap();
    afx_msg void OnSrcSet();
    afx_msg void OnSrcProv();
    afx_msg void OnSrcVol();
//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(__VSS_TEST_DELETE_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\deldlg.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module DelDlg.cpp | Implementation of the delete dialog
    @end

Author:

    Adi Oltean  [aoltean]  10/10/1999

Revision History:

    Name        Date        Comments

    aoltean     10/10/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
// Includes


#include "stdafx.hxx"
#include "resource.h"

#include "GenDlg.h"

#include "VssTest.h"
#include "DelDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define STR2W(str) ((LPTSTR)((LPCTSTR)(str)))


/////////////////////////////////////////////////////////////////////////////
// CDeleteDlg dialog

CDeleteDlg::CDeleteDlg(
    IVssCoordinator *pICoord,
    CWnd* pParent /*=NULL*/
    )
    : CVssTestGenericDlg(CDeleteDlg::IDD, pParent), m_pICoord(pICoord)
{
    //{{AFX_DATA_INIT(CDeleteDlg)
	m_strObjectId.Empty();
	m_bForceDelete = FALSE;
	//}}AFX_DATA_INIT
}

CDeleteDlg::~CDeleteDlg()
{
}

void CDeleteDlg::DoDataExchange(CDataExchange* pDX)
{
    CVssTestGenericDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDeleteDlg)
	DDX_Text(pDX, IDC_QUERY_OBJECT_ID, m_strObjectId);
	DDX_Check(pDX,IDC_DELETE_FORCE_DELETE, m_bForceDelete );
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDeleteDlg, CVssTestGenericDlg)
    //{{AFX_MSG_MAP(CDeleteDlg)
    ON_BN_CLICKED(IDC_NEXT, OnNext)
    ON_BN_CLICKED(IDC_QUERY_SRC_SNAP,	OnSrcSnap)
    ON_BN_CLICKED(IDC_QUERY_SRC_SET,	OnSrcSet)
    ON_BN_CLICKED(IDC_QUERY_SRC_PROV,	OnSrcProv)
    ON_BN_CLICKED(IDC_QUERY_SRC_VOL,	OnSrcVol)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeleteDlg message handlers

BOOL CDeleteDlg::OnInitDialog()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CDeleteDlg::OnInitDialog" );

    try
    {
        CVssTestGenericDlg::OnInitDialog();

        m_eSrcType = VSS_OBJECT_SNAPSHOT_SET;
        BOOL bRes = ::CheckRadioButton( m_hWnd, IDC_QUERY_SRC_SET, IDC_QUERY_SRC_SET, IDC_QUERY_SRC_SET );
        _ASSERTE( bRes );

		VSS_ID ObjectId;
		ft.hr = ::CoCreateGuid(&ObjectId);
		if (ft.HrFailed())
			ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
					   L"Cannot create object guid. [0x%08lx]", ft.hr);

        // Initializing Snapshot Set ID
        LPOLESTR strGUID;
        ft.hr = ::StringFromCLSID( ObjectId, &strGUID );
        if ( ft.HrFailed() )
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on calling StringFromCLSID. hr = 0x%08lx", ft.hr);

        m_strObjectId = OLE2T(strGUID);
        ::CoTaskMemFree(strGUID);

        UpdateData( FALSE );
    }
    VSS_STANDARD_CATCH(ft)

    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CDeleteDlg::OnNext()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CDeleteDlg::OnNext" );
    USES_CONVERSION;

    try
    {
        UpdateData();

		// Get the queried object Id.
		LPTSTR ptszObjectId = const_cast<LPTSTR>(LPCTSTR(m_strObjectId));
		VSS_ID ObjectId;
        ft.hr = ::CLSIDFromString(T2OLE(ptszObjectId), &ObjectId);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                      L"Error on converting the object Id %s to a GUID. lRes == 0x%08lx",
                      T2W(ptszObjectId), ft.hr );

		// Get the enumerator
		BS_ASSERT(m_pICoord);
		CComPtr<IVssEnumObject> pEnum;
		LONG lDeletedSnapshots;
		VSS_ID NondeletedSnapshotID;
		ft.hr = m_pICoord->DeleteSnapshots(
			ObjectId,
			m_eSrcType,
			m_bForceDelete,
			&lDeletedSnapshots,
			&NondeletedSnapshotID
			);
		if (ft.HrFailed())
			ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
					   L"Cannot delete (all) snapshots. [0x%08lx]\n"
					   L"%ld snapshot(s) succeeded to be deleted.\n"
					   L"The snapshot that cannot be deleted: " WSTR_GUID_FMT,
					   ft.hr, lDeletedSnapshots,
					   GUID_PRINTF_ARG(NondeletedSnapshotID));

        ft.MsgBox( L"Succeeded", L"%ld Snapshot(s) deleted!", lDeletedSnapshots );
    }
    VSS_STANDARD_CATCH(ft)
}


void CDeleteDlg::OnSrcSnap()
{
    m_eSrcType = VSS_OBJECT_SNAPSHOT;
/*
    m_eDestType = VSS_OBJECT_SNAPSHOT_SET;
    BOOL bRes = ::CheckRadioButton( m_hWnd, IDC_QUERY_DEST_SNAP, IDC_QUERY_DEST_VOL, IDC_QUERY_DEST_SET );
    _ASSERTE( bRes );

    CWnd* pWnd = GetDlgItem(IDC_QUERY_DEST_SNAP);
    if (pWnd)
        pWnd->EnableWindow(FALSE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_SET);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_PROV);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_VOL);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
*/
}



void CDeleteDlg::OnSrcSet()
{
    m_eSrcType = VSS_OBJECT_SNAPSHOT_SET;
/*
    m_eDestType = VSS_OBJECT_SNAPSHOT;
    BOOL bRes = ::CheckRadioButton( m_hWnd, IDC_QUERY_DEST_SNAP, IDC_QUERY_DEST_VOL, IDC_QUERY_DEST_SNAP );
    _ASSERTE( bRes );

    CWnd* pWnd = GetDlgItem(IDC_QUERY_DEST_SNAP);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_SET);
    if (pWnd)
        pWnd->EnableWindow(FALSE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_PROV);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_VOL);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
*/
}


void CDeleteDlg::OnSrcProv()
{
    m_eSrcType = VSS_OBJECT_PROVIDER;
/*
    m_eDestType = VSS_OBJECT_SNAPSHOT_SET;
    BOOL bRes = ::CheckRadioButton( m_hWnd, IDC_QUERY_DEST_SNAP, IDC_QUERY_DEST_VOL, IDC_QUERY_DEST_SNAP );
    _ASSERTE( bRes );

    CWnd* pWnd = GetDlgItem(IDC_QUERY_DEST_SNAP);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_SET);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_PROV);
    if (pWnd)
        pWnd->EnableWindow(FALSE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_VOL);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
*/
}


void CDeleteDlg::OnSrcVol()
{
//    m_eSrcType = VSS_OBJECT_VOLUME;
/*
    m_eDestType = VSS_OBJECT_SNAPSHOT_SET;
    BOOL bRes = ::CheckRadioButton( m_hWnd, IDC_QUERY_DEST_SNAP, IDC_QUERY_DEST_VOL, IDC_QUERY_DEST_SNAP );
    _ASSERTE( bRes );

    CWnd* pWnd = GetDlgItem(IDC_QUERY_DEST_SNAP);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_SET);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_PROV);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_VOL);
    if (pWnd)
        pWnd->EnableWindow(FALSE);
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\diffdlg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module DiffDlg.h | Header file for the diff dialog
    @end

Author:

    Adi Oltean  [aoltean]  01/25/2000

Revision History:

    Name        Date        Comments

    aoltean     01/25/2000  Created

--*/


#if !defined(__VSS_DIFF_DLG_H__)
#define __VSS_DIFF_DLG_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


/////////////////////////////////////////////////////////////////////////////
// CDiffDlg dialog

class CDiffDlg : public CVssTestGenericDlg
{
    typedef enum _EMethodType {
        VSST_F_ADD_VOL,
        VSST_F_QUERY_DIFF,           
        VSST_F_CLEAR_DIFF,          
        VSST_F_GET_SIZES,       
        VSST_F_SET_ALLOCATED,     
        VSST_F_SET_MAXIMUM
    } EMethodType;

// Construction
public:
    CDiffDlg(
        IVssCoordinator *pICoord,
        CWnd* pParent = NULL); 
    ~CDiffDlg();

// Dialog Data
    //{{AFX_DATA(CDiffDlg)
	enum { IDD = IDD_DIFF_AREA };
	CString m_strVolumeName;
	CString m_strVolumeMountPoint;
	CString m_strVolumeDevice;
	CString m_strVolumeID;
	CString m_strUsedBytes;
	CString m_strAllocatedBytes;
	CString m_strMaximumBytes;
	//}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDiffDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    CComPtr<IVssCoordinator>	m_pICoord;
//    CComPtr<IVsDiffArea>		m_pIDiffArea;
	CComPtr<IVssEnumObject> 	m_pEnum;
    EMethodType m_eMethodType;

    // Generated message map functions
    //{{AFX_MSG(CDiffDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnNext();
    afx_msg void OnAddVol();
    afx_msg void OnQueryDiff();
    afx_msg void OnClearDiff();
    afx_msg void OnGetSizes();
    afx_msg void OnSetAllocated();
    afx_msg void OnSetMaximum();
    afx_msg void OnNextVolume();
//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(__VSS_DIFF_DLG_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\gendlg.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module GenDlg.cpp | Implementation of the generic dialog
    @end

Author:

    Adi Oltean  [aoltean]  07/22/1999

Revision History:

    Name        Date        Comments

    aoltean     07/22/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
// Includes


#include "stdafx.hxx"
#include "resource.h"

#include "AboutDlg.h"
#include "GenDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CVssTestGenericDlg dialog

CVssTestGenericDlg::CVssTestGenericDlg(UINT nIDTemplate, CWnd* pParent /*=NULL*/)
    : CDialog(nIDTemplate, pParent)
{
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

CVssTestGenericDlg::~CVssTestGenericDlg()
{
}

void CVssTestGenericDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CVssTestGenericDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CVssTestGenericDlg, CDialog)
    //{{AFX_MSG_MAP(CVssTestGenericDlg)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVssTestGenericDlg message handlers

BOOL CVssTestGenericDlg::OnInitDialog()
{
    /*
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CVssTestGenericDlg::OnInitDialog" );
    USES_CONVERSION;

    try
    {
    */
        CDialog::OnInitDialog();

        // Add "About..." menu item to system menu.

        // IDM_ABOUTBOX must be in the system command range.
        ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
        ASSERT(IDM_ABOUTBOX < 0xF000);

        CMenu* pSysMenu = GetSystemMenu(FALSE);
        if (pSysMenu != NULL)
        {
            CString strAboutMenu;
            strAboutMenu.LoadString(IDS_ABOUTBOX);
            if (!strAboutMenu.IsEmpty())
            {
                pSysMenu->AppendMenu(MF_SEPARATOR);
                pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
            }
        }

        // Set the icon for this dialog.  The framework does this automatically
        //  when the application's main window is not a dialog
        SetIcon(m_hIcon, TRUE);         // Set big icon
        SetIcon(m_hIcon, FALSE);        // Set small icon
    /*
    }
    VSS_STANDARD_CATCH(ft)
    */

    return TRUE;    //  Return TRUE  unless you set the focus to a control. 
                    //  Anyway it does not matter because derived classes ignore it.
}

void CVssTestGenericDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
    if ((nID & 0xFFF0) == IDM_ABOUTBOX)
    {
        CAboutDlg dlgAbout;
        dlgAbout.DoModal();
    }
    else
    {
        CDialog::OnSysCommand(nID, lParam);
    }
}


// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CVssTestGenericDlg::OnPaint() 
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CVssTestGenericDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\querydlg.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module CoordDlg.cpp | Implementation of the query dialog
    @end

Author:

    Adi Oltean  [aoltean]  09/22/1999

Revision History:

    Name        Date        Comments

    aoltean     09/22/1999  Created
	aoltean		09/27/1999	Adding Query mask flags

--*/


/////////////////////////////////////////////////////////////////////////////
// Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vsswprv.h"

#include "GenDlg.h"

#include "VssTest.h"
#include "QueryDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define STR2W(str) ((LPTSTR)((LPCTSTR)(str)))


/////////////////////////////////////////////////////////////////////////////
// CQueryDlg dialog

CQueryDlg::CQueryDlg(
    IVssCoordinator *pICoord,
    CWnd* pParent /*=NULL*/
    )
    : CVssTestGenericDlg(CQueryDlg::IDD, pParent), m_pICoord(pICoord)
{
    //{{AFX_DATA_INIT(CQueryDlg)
	m_strObjectId.Empty();
	m_bCkQueriedObject = FALSE;
	m_bCkName = TRUE;
	m_bCkVersion = TRUE;
	m_bCkDevice = TRUE;
	m_bCkOriginal = TRUE;
	//}}AFX_DATA_INIT
}

CQueryDlg::~CQueryDlg()
{
}

void CQueryDlg::DoDataExchange(CDataExchange* pDX)
{
    CVssTestGenericDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQueryDlg)
	DDX_Text(pDX, IDC_QUERY_OBJECT_ID, m_strObjectId);
	DDX_Check(pDX,IDC_QUERY_CK_OBJECT, m_bCkQueriedObject );
	DDX_Check(pDX,IDC_QUERY_CK_DEVICE  ,m_bCkDevice );
	DDX_Check(pDX,IDC_QUERY_CK_ORIGINAL,m_bCkOriginal );
	DDX_Check(pDX,IDC_QUERY_CK_NAME   ,m_bCkName );
	DDX_Check(pDX,IDC_QUERY_CK_VERSION,m_bCkVersion );
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CQueryDlg, CVssTestGenericDlg)
    //{{AFX_MSG_MAP(CQueryDlg)
    ON_BN_CLICKED(IDC_NEXT, OnNext)
    ON_BN_CLICKED(IDC_QUERY_CK_OBJECT,	OnQueriedChk)
    ON_BN_CLICKED(IDC_QUERY_SRC_SNAP,	OnSrcSnap)
    ON_BN_CLICKED(IDC_QUERY_SRC_SET,	OnSrcSet)
    ON_BN_CLICKED(IDC_QUERY_SRC_PROV,	OnSrcProv)
    ON_BN_CLICKED(IDC_QUERY_SRC_VOL,	OnSrcVol)
    ON_BN_CLICKED(IDC_QUERY_DEST_SNAP,	OnDestSnap)
    ON_BN_CLICKED(IDC_QUERY_DEST_SET,	OnDestSet)
    ON_BN_CLICKED(IDC_QUERY_DEST_PROV,	OnDestProv)
    ON_BN_CLICKED(IDC_QUERY_DEST_VOL,	OnDestVol)
    ON_BN_CLICKED(IDC_QUERY_DEST_WRITER,OnDestWriter)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQueryDlg message handlers

BOOL CQueryDlg::OnInitDialog()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CQueryDlg::OnInitDialog" );

    try
    {
        CVssTestGenericDlg::OnInitDialog();

/*
        m_eSrcType = VSS_OBJECT_PROVIDER;
        BOOL bRes = ::CheckRadioButton( m_hWnd, IDC_QUERY_SRC_PROV, IDC_QUERY_SRC_PROV, IDC_QUERY_SRC_PROV );
        _ASSERTE( bRes );
*/
		m_eDestType = VSS_OBJECT_SNAPSHOT;
		BOOL bRes = ::CheckRadioButton( m_hWnd, IDC_QUERY_DEST_SNAP, IDC_QUERY_DEST_VOL, IDC_QUERY_DEST_SNAP );
		_ASSERTE( bRes );

/*
		// Set destination button
		OnSrcSet();
*/
        // Initializing Snapshot Set ID
		VSS_ID ObjectId = VSS_SWPRV_ProviderId;
        LPOLESTR strGUID;
        ft.hr = ::StringFromCLSID( ObjectId, &strGUID );
        if ( ft.HrFailed() )
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on calling StringFromCLSID. hr = 0x%08lx", ft.hr);

        m_strObjectId = OLE2T(strGUID);
        ::CoTaskMemFree(strGUID);

        UpdateData( FALSE );
    }
    VSS_STANDARD_CATCH(ft)

    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CQueryDlg::OnNext()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CQueryDlg::OnNext" );
    USES_CONVERSION;

	const nBuffLen = 2048; // including the zero character.
	WCHAR wszBuffer[nBuffLen];

    try
    {
        UpdateData();

		// Get the queried object Id.
		LPTSTR ptszObjectId = const_cast<LPTSTR>(LPCTSTR(m_strObjectId));
		VSS_ID ObjectId;
        ft.hr = ::CLSIDFromString(T2OLE(ptszObjectId), &ObjectId);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                      L"Error on converting the object Id %s to a GUID. lRes == 0x%08lx",
                      T2W(ptszObjectId), ft.hr );

		// Get the enumerator
		BS_ASSERT(m_pICoord);
		CComPtr<IVssEnumObject> pEnum;
		ft.hr = m_pICoord->Query(
			m_bCkQueriedObject? ObjectId: GUID_NULL,
			m_bCkQueriedObject? m_eSrcType: VSS_OBJECT_NONE,
			m_eDestType,
			&pEnum
		);
		if (ft.HrFailed())
			ft.ErrBox( VSSDBG_VSSTEST, E_OUTOFMEMORY,
					   L"Cannot interogate enumerator instance. [0x%08lx]", ft.hr);

		if (ft.hr == S_FALSE)
			ft.MsgBox( L"Results", L"Empty result...");

		// Allocate the new structure object, but with zero contents.
		// The internal pointer must not be NULL.
		VSS_OBJECT_PROP_Ptr ptrObjProp;
		ptrObjProp.InitializeAsEmpty(ft);

		while(true)
		{
			// Get the Next object in the newly allocated structure object.
			VSS_OBJECT_PROP* pProp = ptrObjProp.GetStruct();
			BS_ASSERT(pProp);
			ULONG ulFetched;
			ft.hr = pEnum->Next(1, pProp, &ulFetched);
			if (ft.hr == S_FALSE) // end of enumeration
				break;
			if (ft.HrFailed())
				ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error calling Next");

			// Print the contents
			ptrObjProp.Print( ft, wszBuffer, nBuffLen - 1 );

			ft.Trace( VSSDBG_SWPRV, L"Results %s", wszBuffer);
			ft.MsgBox( L"Results", wszBuffer);

			// release COM allocated pointers at unmarshalling time
			// Warning: do not release the union pointer! It is needed for the next cicle.
			VSS_OBJECT_PROP_Copy::destroy(pProp);
		}
    }
    VSS_STANDARD_CATCH(ft)
}


void CQueryDlg::OnSrcSnap()
{
    m_eSrcType = VSS_OBJECT_SNAPSHOT;
/*
    m_eDestType = VSS_OBJECT_SNAPSHOT_SET;
    BOOL bRes = ::CheckRadioButton( m_hWnd, IDC_QUERY_DEST_SNAP, IDC_QUERY_DEST_VOL, IDC_QUERY_DEST_SET );
    _ASSERTE( bRes );

    CWnd* pWnd = GetDlgItem(IDC_QUERY_DEST_SNAP);
    if (pWnd)
        pWnd->EnableWindow(FALSE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_SET);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_PROV);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_VOL);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
*/
}



void CQueryDlg::OnSrcSet()
{
    m_eSrcType = VSS_OBJECT_SNAPSHOT_SET;
/*
    m_eDestType = VSS_OBJECT_SNAPSHOT;
    BOOL bRes = ::CheckRadioButton( m_hWnd, IDC_QUERY_DEST_SNAP, IDC_QUERY_DEST_VOL, IDC_QUERY_DEST_SNAP );
    _ASSERTE( bRes );

    CWnd* pWnd = GetDlgItem(IDC_QUERY_DEST_SNAP);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_SET);
    if (pWnd)
        pWnd->EnableWindow(FALSE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_PROV);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_VOL);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
*/
}


void CQueryDlg::OnSrcProv()
{
    m_eSrcType = VSS_OBJECT_PROVIDER;
/*
    m_eDestType = VSS_OBJECT_SNAPSHOT_SET;
    BOOL bRes = ::CheckRadioButton( m_hWnd, IDC_QUERY_DEST_SNAP, IDC_QUERY_DEST_VOL, IDC_QUERY_DEST_SNAP );
    _ASSERTE( bRes );

    CWnd* pWnd = GetDlgItem(IDC_QUERY_DEST_SNAP);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_SET);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_PROV);
    if (pWnd)
        pWnd->EnableWindow(FALSE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_VOL);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
*/
}


void CQueryDlg::OnSrcVol()
{
//    m_eSrcType = VSS_OBJECT_VOLUME;
/*
    m_eDestType = VSS_OBJECT_SNAPSHOT_SET;
    BOOL bRes = ::CheckRadioButton( m_hWnd, IDC_QUERY_DEST_SNAP, IDC_QUERY_DEST_VOL, IDC_QUERY_DEST_SNAP );
    _ASSERTE( bRes );

    CWnd* pWnd = GetDlgItem(IDC_QUERY_DEST_SNAP);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_SET);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_PROV);
    if (pWnd)
        pWnd->EnableWindow(TRUE);
    pWnd = GetDlgItem(IDC_QUERY_DEST_VOL);
    if (pWnd)
        pWnd->EnableWindow(FALSE);
*/
}


void CQueryDlg::OnDestSnap()
{
    m_eDestType = VSS_OBJECT_SNAPSHOT;
}


void CQueryDlg::OnDestSet()
{
//    m_eDestType = VSS_OBJECT_SNAPSHOT_SET;
}


void CQueryDlg::OnDestProv()
{
    m_eDestType = VSS_OBJECT_PROVIDER;
}


void CQueryDlg::OnDestVol()
{
//    m_eDestType = VSS_OBJECT_VOLUME;
}


void CQueryDlg::OnDestWriter()
{
}


void CQueryDlg::OnQueriedChk()
{
	UpdateData();

	if (CWnd* pWnd = GetDlgItem(IDC_QUERY_OBJECT_ID))
		pWnd->EnableWindow(m_bCkQueriedObject);
	if (CWnd* pWnd = GetDlgItem(IDC_QUERY_SRC_SNAP))
		pWnd->EnableWindow(m_bCkQueriedObject);
	if (CWnd* pWnd = GetDlgItem(IDC_QUERY_SRC_SET))
		pWnd->EnableWindow(m_bCkQueriedObject);
	if (CWnd* pWnd = GetDlgItem(IDC_QUERY_SRC_VOL))
		pWnd->EnableWindow(m_bCkQueriedObject);
	if (CWnd* pWnd = GetDlgItem(IDC_QUERY_SRC_PROV))
		pWnd->EnableWindow(m_bCkQueriedObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\querydlg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module QueryDlg.h | Header file for the query dialog
    @end

Author:

    Adi Oltean  [aoltean]  09/22/1999

Revision History:

    Name        Date        Comments

    aoltean     09/22/1999  Created
	aoltean		09/27/1999	Adding Query mask flags

--*/


#if !defined(__VSS_TEST_QUERY_H__)
#define __VSS_TEST_QUERY_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


/////////////////////////////////////////////////////////////////////////////
// CQueryDlg dialog

class CQueryDlg : public CVssTestGenericDlg
{
// Construction
public:
    CQueryDlg(
        IVssCoordinator *pICoord,
        CWnd* pParent = NULL); 
    ~CQueryDlg();

// Dialog Data
    //{{AFX_DATA(CQueryDlg)
	enum { IDD = IDD_QUERY };
	CString	    m_strObjectId;
	BOOL        m_bCkQueriedObject;
    BOOL        m_bCkDevice;
    BOOL        m_bCkOriginal;
    BOOL        m_bCkName;
    BOOL        m_bCkVersion;
	//}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CQueryDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    CComPtr<IVssCoordinator> m_pICoord;
    VSS_OBJECT_TYPE m_eSrcType;
    VSS_OBJECT_TYPE m_eDestType;

    // Generated message map functions
    //{{AFX_MSG(CQueryDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnNext();
	afx_msg void OnQueriedChk();
    afx_msg void OnSrcSnap();
    afx_msg void OnSrcSet();
    afx_msg void OnSrcProv();
    afx_msg void OnSrcVol();
    afx_msg void OnDestSnap();
    afx_msg void OnDestSet();
    afx_msg void OnDestProv();
    afx_msg void OnDestVol();
	afx_msg void OnDestWriter();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(__VSS_TEST_QUERY_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by VssTest.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_CONNECT_DIALOG              102
#define IDD_CONNECT                     102
#define IDD_COORD                       103
#define IDD_SS                          104
#define IDD_SW_SNAP                     105
#define IDD_SWTST                       105
#define IDD_QUERY                       106
#define IDD_DELETE                      107
#define IDD_ASYNC                       108
#define IDD_INPUT                       109
#define IDD_DIFF_AREA                   110
#define IDD_SNAP                        111
#define IDD_VOLUME                      112
#define IDR_MAINFRAME                   128
#define IDC_SNAP_SET_ID                 202
#define IDC_NEXT                        1001
#define IDC_CONN_LOCAL                  1014
#define IDC_CONN_REMOTE                 1015
#define IDC_CONN_MACHINE_NAME           1016
#define IDC_CONN_STATIC_MACHINE_NAME    1017
#define IDC_SS_DO                       1020
#define IDC_SS_ADD                      1027
#define IDC_COORD_CREATE                1029
#define IDC_COORD_QUERY                 1030
#define IDC_COORD_DELETE                1031
#define IDC_ADMIN_REGISTER              1032
#define IDC_ADMIN_UNREGISTER            1033
#define IDC_ADMIN_QUERY                 1034
#define IDC_SS_ID                       1035
#define IDC_QUERY_SRC_VOL               1035
#define IDC_COORD_DIFF_AREA             1035
#define IDC_SS_COUNT                    1036
#define IDC_COORD_SNAPSHOT              1036
#define IDC_SS_VOLUME                   1037
#define IDC_QUERY_OBJECT_ID             1037
#define IDC_COORD_ISVOLUME              1037
#define IDC_SS_PROVIDER                 1038
#define IDC_SS_WRITER_VETOES            1039
#define IDC_SWTST_LOGFILE               1040
#define IDC_SS_ATTR                     1041
#define IDC_SWTST_READONLY              1041
#define IDC_SWTST_LOGFILE_SIZE          1042
#define IDC_SS_TIMEOUT                  1043
#define IDC_SS_PARTIAL_COMMIT           1043
#define IDC_SS_VOLUMES                  1044
#define IDC_COMBO2                      1045
#define IDC_SS_PROVIDERS                1045
#define IDC_QUERY_SRC_SNAP              1045
#define IDC_QUERY_SRC_SET               1046
#define IDC_SS_ASYNC                    1046
#define IDC_QUERY_SRC_PROV              1047
#define IDC_SS_WRITER_CANCEL            1047
#define IDC_QUERY_DEST_SNAP             1048
#define IDC_QUERY_DEST_SET              1049
#define IDC_QUERY_DEST_PROV             1050
#define IDC_QUERY_DEST_VOL              1051
#define IDC_QUERY_CK_NAME               1052
#define IDC_QUERY_CK_VERSION            1054
#define ID_BACK                         1056
#define IDC_QUERY_DEST_WRITER           1056
#define IDC_ASYNC_STATUS                1057
#define IDC_QUERY_CK_DEVICE             1057
#define IDC_ASYNC_PERF                  1058
#define IDC_QUERY_CK_ORIGINAL           1058
#define IDC_ASYNC_QUERY                 1059
#define IDC_ASYNC_CANCEL                1060
#define IDC_PROMPT_VALUE                1060
#define IDC_ASYNC_WAIT                  1061
#define IDC_PROMPT_TEXT                 1061
#define IDC_DIFF_MOUNT                  1062
#define IDC_DIFF_USED                   1063
#define IDC_DIFF_NEXT_VOLUME            1065
#define IDC_DIFF_ALLOCATED              1066
#define IDC_DIFF_MAXIMUM                1067
#define IDC_DIFF_DEVICE                 1069
#define IDC_DIFF_VOLUME_ID              1070
#define IDC_DIFF_VOLUME_ID2             1071
#define IDC_SNAP_ID                     1071
#define IDC_SNAP_SSID                   1072
#define IDC_VOLUME_NAME                 1073
#define IDC_DIFF_VOLUME_NAME            1073
#define IDC_SNAP_NAME                   1073
#define IDC_DIFF_ADD_VOL                1074
#define IDC_SNAP_DEVICE                 1074
#define IDC_DIFF_QUERY_DIFF             1075
#define IDC_SNAP_ORIGINAL_VOL_NAME      1075
#define IDC_DIFF_CLEAR_DIFF             1076
#define IDC_SNAP_ORIGINAL_VOLUME_ID     1076
#define IDC_DIFF_GET_SIZES              1077
#define IDC_DIFF_SET_MAXIMUM            1078
#define IDC_DIFF_SET_ALLOCATED          1079
#define IDC_SNAP_GET_PROPERTIES         1080
#define IDC_SNAP_SET_ATTRIBUTES         1081
#define IDC_SNAP_READ_ONLY              1084
#define IDC_SNAP_CHK_PERSISTENT         1085
#define IDC_SNAP_COMMIT                 1086
#define IDC_SNAP_INC                    1088
#define IDC_SNAP_STATUS                 1089
#define IDC_NEXT_OBJECT                 1090
#define IDC_DELETE_FORCE_DELETE         1091
#define IDC_QUERY_CK_OBJECT             1092
#define IDC_VOLUME_IS_VOL_SUPPORTED     1093
#define IDC_VOLUME_IS_VOL_SNAPSHOTTED   1094
#define IDC_VOLUME_OBJECT_ID            1095
#define IDC_EDIT1                       1096
#define IDC_VOLUME_IS_VOL_SUPPORTED2    1096
#define IDC_VOLUME_IS_VOL_SNAPSHOTTED2  1097

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1097
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\snapdlg.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module snapdlg.cpp | Implementation of the snapshot dialog
    @end

Author:

    Adi Oltean  [aoltean]  01/25/2000

Revision History:

    Name        Date        Comments

    aoltean     01/25/2000  Created

--*/


/////////////////////////////////////////////////////////////////////////////
// Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vsswprv.h"

#include "GenDlg.h"

#include "VssTest.h"
#include "SnapDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define STR2W(str) ((LPTSTR)((LPCTSTR)(str)))


/////////////////////////////////////////////////////////////////////////////
// CSnapDlg dialog

CSnapDlg::CSnapDlg(
    IVssCoordinator *pICoord,
    CWnd* pParent /*=NULL*/
    )
    : CVssTestGenericDlg(CSnapDlg::IDD, pParent), m_pICoord(pICoord)
{
    //{{AFX_DATA_INIT(CSnapDlg)
	m_ID = GUID_NULL;
	m_SnapshotSetID = GUID_NULL;
	m_strSnapshotDeviceObject.Empty();
	m_strOriginalVolumeName.Empty();
	m_ProviderID = GUID_NULL;
	m_lSnapshotAttributes = 0;
	m_strCreationTimestamp.Empty();
	m_eStatus = 0;
	//}}AFX_DATA_INIT
}

CSnapDlg::~CSnapDlg()
{
}

void CSnapDlg::DoDataExchange(CDataExchange* pDX)
{
    CVssTestGenericDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSnapDlg)
	DDX_Text(pDX, IDC_SNAP_ID, 		m_ID);
	DDX_Text(pDX, IDC_SNAP_SSID, 	m_SnapshotSetID);
	DDX_Text(pDX, IDC_SNAP_DEVICE, 	m_strSnapshotDeviceObject);
	DDX_Text(pDX, IDC_SNAP_ORIGINAL_VOL_NAME, 	m_strOriginalVolumeName);
	DDX_Text(pDX, IDC_SNAP_STATUS,	m_eStatus);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSnapDlg, CVssTestGenericDlg)
    //{{AFX_MSG_MAP(CSnapDlg)
    ON_BN_CLICKED(IDC_NEXT,					OnNext)
    ON_BN_CLICKED(IDC_NEXT_OBJECT,			OnNextSnapshot)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSnapDlg message handlers

BOOL CSnapDlg::OnInitDialog()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CSnapDlg::OnInitDialog" );

    try
    {
        CVssTestGenericDlg::OnInitDialog();

        m_eMethodType = VSST_S_GET_SNAPSHOT;
        BOOL bRes = ::CheckRadioButton( m_hWnd,
			IDC_SNAP_GET_PROPERTIES,
			IDC_SNAP_GET_PROPERTIES,
			IDC_SNAP_GET_PROPERTIES );
        _ASSERTE( bRes );

        UpdateData( FALSE );
    }
    VSS_STANDARD_CATCH(ft)

    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CSnapDlg::OnNext()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CSnapDlg::OnNext" );
    USES_CONVERSION;

    try
    {
        UpdateData();

		// Try to allocate the diff area object, if needed
		if (m_pISnap == NULL)
		{
			// Get the diff area interface
			ft.hr = m_pICoord->GetSnapshot(
				m_ID,
				IID_IVssSnapshot,
				reinterpret_cast<IUnknown**>(&m_pISnap)
				);
			if (ft.HrFailed())
				ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
						L"Error getting the snapshot interface 0x%08lx", ft.hr);
		}

        switch(m_eMethodType)
        {
        case VSST_S_GET_SNAPSHOT:
			{
				// Empty the fields
				m_ID = GUID_NULL;
				m_SnapshotSetID = GUID_NULL;
				m_strSnapshotDeviceObject.Empty();
				m_strOriginalVolumeName.Empty();
				m_ProviderID = GUID_NULL;
				m_lSnapshotAttributes = 0;
				m_strCreationTimestamp.Empty();
				m_eStatus = 0;

				// Get the properties
				VSS_OBJECT_PROP_Ptr ptrObjProp;
				ptrObjProp.InitializeAsEmpty(ft);

				VSS_OBJECT_PROP* pProp = ptrObjProp.GetStruct();
				BS_ASSERT(pProp);
			    VSS_SNAPSHOT_PROP* pSnapProp = &(pProp->Obj.Snap);
				
				// Get the properties
				BS_ASSERT(m_pISnap);
				ft.hr = m_pISnap->GetProperties(pSnapProp);
				if (ft.HrFailed())
					ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
								L"Error getting the properties 0x%08lx", ft.hr);

			    // Fill the dialog fields
				m_ID = pSnapProp->m_SnapshotId;
				m_SnapshotSetID = pSnapProp->m_SnapshotSetId;
				m_strSnapshotDeviceObject = pSnapProp->m_pwszSnapshotDeviceObject;
				m_strOriginalVolumeName = pSnapProp->m_pwszOriginalVolumeName;
				m_ProviderID = pSnapProp->m_ProviderId;
				m_lSnapshotAttributes = pSnapProp->m_lSnapshotAttributes;
				m_strCreationTimestamp.Format( L"0x%08lx%08lx", pSnapProp->m_tsCreationTimestamp);
				m_eStatus = pSnapProp->m_eStatus;

				UpdateData( FALSE );
			}
            break;
        default:
            BS_ASSERT(false);
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Invalid method type");
        }

    }
    VSS_STANDARD_CATCH(ft)
}


void CSnapDlg::OnGetSnapshot()
{
    m_eMethodType = VSST_S_GET_SNAPSHOT;
}


void CSnapDlg::OnNextSnapshot()
{
	CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CSnapDlg::OnNextSnapshot");
	
    if (m_pEnum == NULL)
    	return;

	// Empty the fields
	m_ID = GUID_NULL;
	m_SnapshotSetID = GUID_NULL;
	m_strSnapshotDeviceObject.Empty();
	m_strOriginalVolumeName.Empty();
	m_ProviderID = GUID_NULL;
	m_lSnapshotAttributes = 0;
	m_strCreationTimestamp.Empty();
	m_eStatus = 0;

	// Get the properties
	VSS_OBJECT_PROP_Ptr ptrObjProp;
	ptrObjProp.InitializeAsEmpty(ft);

	VSS_OBJECT_PROP* pProp = ptrObjProp.GetStruct();
	BS_ASSERT(pProp);
	ULONG ulFetched;
    ft.hr = m_pEnum->Next(1, pProp, &ulFetched);
	if (ft.HrFailed())
		ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
					L"Error querying the next volume 0x%08lx", ft.hr);

	VSS_SNAPSHOT_PROP* pSnapProp = &(pProp->Obj.Snap);

	m_ID = pSnapProp->m_SnapshotId;
	m_SnapshotSetID = pSnapProp->m_SnapshotSetId;
	m_strSnapshotDeviceObject = pSnapProp->m_pwszSnapshotDeviceObject;
	m_ProviderID = pSnapProp->m_ProviderId;
	m_lSnapshotAttributes = pSnapProp->m_lSnapshotAttributes;
	m_strCreationTimestamp.Format( L"0x%08lx%08lx", pSnapProp->m_tsCreationTimestamp);
	m_eStatus = pSnapProp->m_eStatus;

	UpdateData( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\gendlg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module GenDlg.h | Header file for the generic dialog
    @end

Author:

    Adi Oltean  [aoltean]  08/05/1999

Revision History:

    Name        Date        Comments

    aoltean     08/05/1999  Created

--*/


#if !defined(__VSS_TEST_GENDLG_H__)
#define __VSS_TEST_GENDLG_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


/////////////////////////////////////////////////////////////////////////////
// CVssTestGenericDlg dialog

class CVssTestGenericDlg : public CDialog
{
// Construction
public:
    CVssTestGenericDlg(UINT nIDTemplate, CWnd* pParent = NULL); // standard constructor
    ~CVssTestGenericDlg();

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CVssTestGenericDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    HICON   m_hIcon;

    // Generated message map functions
    //{{AFX_MSG(CVssTestGenericDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(__VSS_TEST_GENDLG_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\ssdlg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module SsDlg.h | Header file for the Snapshot Set dialog
    @end

Author:

    Adi Oltean  [aoltean]  07/22/1999

Revision History:

    Name        Date        Comments

    aoltean     07/22/1999  Created
    aoltean     08/05/1999  Splitting wizard functionality in a base class

--*/


#if !defined(__VSS_SS_DLG_H__)
#define __VSS_SS_DLG_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


/////////////////////////////////////////////////////////////////////////////
// CGuidList structure

struct GuidList
{
    GuidList(GUID Guid, GuidList* pPrev = NULL)
    {
        m_Guid = Guid;
        m_pPrev = pPrev;
    };

    ~GuidList()
    {
        if (m_pPrev)
            delete m_pPrev;
    };

    GUID        m_Guid;
    GuidList*   m_pPrev;

private:
    GuidList();
    GuidList(const GuidList&);
};



/////////////////////////////////////////////////////////////////////////////
// CSnapshotSetDlg dialog

class CSnapshotSetDlg : public CVssTestGenericDlg
{
// Construction
public:
    CSnapshotSetDlg(
        IVssCoordinator *pICoord,
        VSS_ID SnapshotSetId,
        CWnd* pParent = NULL); 
    ~CSnapshotSetDlg();

// Dialog Data
    //{{AFX_DATA(CSnapshotSetDlg)
	enum { IDD = IDD_SS };
	CString	    m_strSnapshotSetId;
    int         m_nSnapshotsCount;
	CComboBox	m_cbVolumes;
	CComboBox	m_cbProviders;
    int         m_nAttributes;
    BOOL        m_bAsync;
	//}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSnapshotSetDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    CComPtr<IVssCoordinator> m_pICoord;
    VSS_ID      m_SnapshotSetId;
    VSS_ID      m_VolumeId;
    VSS_ID      m_ProviderId;
    bool        m_bDo;
    GuidList*   m_pProvidersList;
	// REMOVED:    GuidList*   m_pVolumesList;
	CComPtr<IVssSnapshot> m_pSnap;

    void EnableGroup();
    void InitMembers();
    void InitVolumes();
    void InitProviders();

    // Generated message map functions
    //{{AFX_MSG(CSnapshotSetDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnNext();
    afx_msg void OnBack();
    afx_msg void OnAdd();
    afx_msg void OnDo();
    afx_msg void OnClose();
//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(__VSS_SS_DLG_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\snapdlg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module SnapDlg.h | Header file for the snapshot dialog
    @end

Author:

    Adi Oltean  [aoltean]  01/25/2000

Revision History:

    Name        Date        Comments

    aoltean     01/25/2000  Created

--*/


#if !defined(__VSS_SNAP_DLG_H__)
#define __VSS_SNAP_DLG_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


/////////////////////////////////////////////////////////////////////////////
// CSnapDlg dialog

class CSnapDlg : public CVssTestGenericDlg
{
    typedef enum _EMethodType {
        VSST_S_GET_SNAPSHOT,
    } EMethodType;

// Construction
public:
    CSnapDlg(
        IVssCoordinator *pICoord,
        CWnd* pParent = NULL); 
    ~CSnapDlg();

// Dialog Data
    //{{AFX_DATA(CSnapDlg)
	enum { IDD = IDD_SNAP };
	VSS_ID	m_ID;
	VSS_ID	m_SnapshotSetID;
	CString	m_strSnapshotDeviceObject;
	CString	m_strOriginalVolumeName;
	VSS_ID 	m_ProviderID;
	LONG 	m_lSnapshotAttributes;
	CString	m_strCreationTimestamp;
	INT		m_eStatus;
	//}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSnapDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    CComPtr<IVssCoordinator>	m_pICoord;
    CComPtr<IVssSnapshot>		m_pISnap;
	CComPtr<IVssEnumObject> 	m_pEnum;
    EMethodType m_eMethodType;

    // Generated message map functions
    //{{AFX_MSG(CSnapDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnNext();
    afx_msg void OnNextSnapshot();
    afx_msg void OnGetSnapshot();
//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(__VSS_SNAP_DLG_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\ssdlg.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module SsDlg.cpp | Implementation of the Snapshot Set dialog
    @end

Author:

    Adi Oltean  [aoltean]  07/23/1999

Revision History:

    Name        Date        Comments

    aoltean     07/23/1999  Created
    aoltean     08/05/1999  Splitting wizard functionality in a base class
                            Removing some memory leaks
                            Adding Test provider
                            Fixing an assert
	aoltean		09/27/1999	Small changes

--*/


/////////////////////////////////////////////////////////////////////////////
// Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vsswprv.h"

#include "GenDlg.h"

#include "SwTstDlg.h"
#include "SsDlg.h"
#include "AsyncDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Constants and defines

#define STR2W(str) ((LPTSTR)((LPCTSTR)(str)))

const WCHAR   wszGUIDDefinition[] = L"{00000000-0000-0000-0000-000000000000}";
const WCHAR   wszVolumeDefinition[] = L"\\\\?\\Volume";
const WCHAR   wszHarddiskDefinition[] = L"\\Device\\Harddisk";
const WCHAR   wszDriveLetterDefinition[] = L"_:\\";

// {F9566CC7-D588-416d-9243-921E93613C92}
static const VSS_ID VSS_TESTAPP_SampleAppId =
{ 0xf9566cc7, 0xd588, 0x416d, { 0x92, 0x43, 0x92, 0x1e, 0x93, 0x61, 0x3c, 0x92 } };


/////////////////////////////////////////////////////////////////////////////
// CSnapshotSetDlg dialog

CSnapshotSetDlg::CSnapshotSetDlg(
    IVssCoordinator *pICoord,
    VSS_ID SnapshotSetId,
    CWnd* pParent /*=NULL*/
    )
    : CVssTestGenericDlg(CSnapshotSetDlg::IDD, pParent),
    m_pICoord(pICoord),
    m_SnapshotSetId(SnapshotSetId)
{
    //{{AFX_DATA_INIT(CSnapshotSetDlg)
	//}}AFX_DATA_INIT
    m_strSnapshotSetId.Empty();
    m_nSnapshotsCount = 0;
    m_nAttributes = 0;
	m_bAsync = TRUE;
    m_bDo = false;              // "Add" enabled by default
	m_pProvidersList = NULL;
}

CSnapshotSetDlg::~CSnapshotSetDlg()
{
    if (m_pProvidersList)
        delete m_pProvidersList;
	/* REMOVED:
    if (m_pVolumesList)
        delete m_pVolumesList;
	*/
}

void CSnapshotSetDlg::DoDataExchange(CDataExchange* pDX)
{
    CVssTestGenericDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSnapshotSetDlg)
	DDX_Text(pDX, IDC_SS_ID,        m_strSnapshotSetId);
	DDX_Text(pDX, IDC_SS_COUNT,     m_nSnapshotsCount);
	DDX_Control(pDX, IDC_SS_VOLUMES,   m_cbVolumes);
	DDX_Control(pDX, IDC_SS_PROVIDERS, m_cbProviders);
	DDX_Text(pDX, IDC_SS_ATTR,      m_nAttributes);
	DDX_Check(pDX,IDC_SS_ASYNC,    m_bAsync);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSnapshotSetDlg, CVssTestGenericDlg)
    //{{AFX_MSG_MAP(CSnapshotSetDlg)
    ON_BN_CLICKED(IDC_NEXT, OnNext)
    ON_BN_CLICKED(ID_BACK, OnBack)
    ON_BN_CLICKED(IDC_SS_ADD, OnAdd)
    ON_BN_CLICKED(IDC_SS_DO, OnDo)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CSnapshotSetDlg message handlers


void CSnapshotSetDlg::InitVolumes()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CSnapshotSetDlg::InitVolumes" );
    USES_CONVERSION;

    try
    {

        HANDLE  hSearch;
        WCHAR   wszVolumeName[MAX_PATH];

        hSearch = ::FindFirstVolume(wszVolumeName, MAX_PATH);
        if (hSearch == INVALID_HANDLE_VALUE)
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"FindfirstVolume cannot start an enumeration");

        while (true)
        {
            WCHAR   wszEnumeratedDosVolumeName[4];
            WCHAR   wszEnumeratedVolumeName[MAX_PATH];
            WCHAR   wszLinkName[MAX_PATH];
            UCHAR   wchDriveLetter;
            WCHAR   chTmp;

            // Check if it is a hard-disk
            // TBD - generalize this code!!!
            chTmp = wszVolumeName[48];
            wszVolumeName[48] = L'\0';
            ::QueryDosDevice(&wszVolumeName[4], wszLinkName, MAX_PATH);
            wszVolumeName[48] = chTmp;
            if (::wcsncmp(wszLinkName, wszHarddiskDefinition, ::wcslen(wszHarddiskDefinition)) == 0)
            {
                // Get the DOS drive letter, if possible
                BOOL bFind = FALSE;
                wcscpy(wszEnumeratedDosVolumeName, wszDriveLetterDefinition);
                for (wchDriveLetter = L'A'; wchDriveLetter <= L'Z'; wchDriveLetter++)
                {
                    wszEnumeratedDosVolumeName[0] = wchDriveLetter;
                    ::GetVolumeNameForVolumeMountPoint(
                        wszEnumeratedDosVolumeName,
                        wszEnumeratedVolumeName,
                        MAX_PATH
                        );
                    if (::wcscmp(wszVolumeName, wszEnumeratedVolumeName) == 0)
                    {
                        bFind = TRUE;
                        break;
                    }
                }

                // Inserting the volume into combo box.
                int nIndex = m_cbVolumes.AddString( W2T(bFind? wszEnumeratedDosVolumeName: wszVolumeName) );
                if (nIndex  < 0)
                    ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error adding string in combo box");

				/* REMOVED
                // Getting the volume GUID
                GUID VolumeId;
                BS_ASSERT(::wcslen(wszVolumeDefinition) + ::wcslen(wszGUIDDefinition) + 1 == ::wcslen(wszVolumeName));
                WCHAR* pwszVolumeGuid = wszVolumeName + ::wcslen(wszVolumeDefinition);
                pwszVolumeGuid[::wcslen(wszGUIDDefinition)] = L'\0';
                ft.hr = ::CLSIDFromString(W2OLE(pwszVolumeGuid), &VolumeId);
                if ( ft.HrFailed() )
                    ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on recognizing Volume Id. hr = 0x%08lx", ft.hr);

                // Allocating a new item in the volume guid list
                GuidList* pVolumeGuid = new GuidList(VolumeId);
                if ( pVolumeGuid == NULL )
                    ft.ErrBox( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");

                // Inserting the volume into combo box.
                int nIndex = m_cbVolumes.AddString( W2T(bFind? wszEnumeratedDosVolumeName: wszVolumeName) );
                if (nIndex  < 0)
                {
                    delete pVolumeGuid;
                    ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error adding string in combo box");
                }

                int nResult = m_cbVolumes.SetItemDataPtr(nIndex, pVolumeGuid);
                if (nResult == CB_ERR)
                {
                    delete pVolumeGuid;
                    ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error setting data to an item in combo box");
                }

                pVolumeGuid->m_pPrev = m_pVolumesList;
                m_pVolumesList = pVolumeGuid;
				*/
            }

            // Find next volume
            BOOL bResult = ::FindNextVolume(hSearch, wszVolumeName, MAX_PATH);
            if (!bResult)
                break;
        }

        // Close enumeration
        ::FindVolumeClose(hSearch);

        // Select the first element
        if (m_cbVolumes.GetCount() > 0)
            m_cbVolumes.SetCurSel(0);
    }
    VSS_STANDARD_CATCH(ft)
}


void CSnapshotSetDlg::InitProviders()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CSnapshotSetDlg::InitProviders" );
    USES_CONVERSION;

    try
    {
        //
        //  Adding the Software provider item
        //

        // Allocating a GUID. It will be deallocated on OnClose
        GuidList* pProviderGuid = new GuidList(VSS_SWPRV_ProviderId);
        if ( pProviderGuid == NULL )
            ft.ErrBox( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");

        // Inserting the software provider name into combo box.
        int nIndex = m_cbProviders.AddString( _T("Software Provider") );
        if (nIndex  < 0)
        {
            delete pProviderGuid;
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error adding string in combo box");
        }

        int nResult = m_cbProviders.SetItemDataPtr(nIndex, &(pProviderGuid->m_Guid));
        if (nResult == CB_ERR)
        {
            delete pProviderGuid;
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error setting data to an item in combo box");
        }

        pProviderGuid->m_pPrev = m_pProvidersList;
        m_pProvidersList = pProviderGuid;

        //
        //  Adding the NULL provider item
        //

        pProviderGuid = new GuidList(GUID_NULL);
        if ( pProviderGuid == NULL )
            ft.ErrBox( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");

        // Inserting the software provider name into combo box.
        nIndex = m_cbProviders.AddString( _T("NULL Provider") );
        if (nIndex  < 0)
        {
            delete pProviderGuid;
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error adding string in combo box");
        }

        nResult = m_cbProviders.SetItemDataPtr(nIndex, &(pProviderGuid->m_Guid));
        if (nResult == CB_ERR)
        {
            delete pProviderGuid;
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error setting data to an item in combo box");
        }

        pProviderGuid->m_pPrev = m_pProvidersList;
        m_pProvidersList = pProviderGuid;

        // Select the first element
        if (m_cbProviders.GetCount() > 0)
            m_cbProviders.SetCurSel(0);
    }
    VSS_STANDARD_CATCH(ft)
}


void CSnapshotSetDlg::InitMembers()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CSnapshotSetDlg::InitMembers" );
    USES_CONVERSION;

    try
    {
        // Initializing the radio buttons                   // bug??
        BOOL bRes = ::CheckRadioButton( m_hWnd, IDC_SS_ADD, IDC_SS_ADD, IDC_SS_ADD );
        _ASSERTE( bRes );

        // Initializing Snapshot Set ID
        LPOLESTR strGUID;
        ft.hr = ::StringFromCLSID( m_SnapshotSetId, &strGUID );
        if ( ft.HrFailed() )
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on calling StringFromCLSID. hr = 0x%08lx", ft.hr);

        m_strSnapshotSetId = OLE2T(strGUID);
        ::CoTaskMemFree(strGUID);
    }
    VSS_STANDARD_CATCH(ft)
}


BOOL CSnapshotSetDlg::OnInitDialog()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CSnapshotSetDlg::OnInitDialog" );
    USES_CONVERSION;

    try
    {
        CVssTestGenericDlg::OnInitDialog();

        InitVolumes();
        InitProviders();
        InitMembers();

        UpdateData(FALSE);
    }
    VSS_STANDARD_CATCH(ft)

    return TRUE;  // return TRUE  unless you set the focus to a control
}


void CSnapshotSetDlg::OnNext()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CSnapshotSetDlg::OnNext" );

    USES_CONVERSION;
	LPTSTR ptszVolumeName = NULL;

    try
    {
        UpdateData();

        if (m_bDo)
        {
			if (m_bAsync)
			{
				CComPtr<IVssAsync> pAsync;

				ft.hr = m_pICoord->DoSnapshotSet(
				            NULL,
							&pAsync
							);

				if ( ft.HrFailed() )
				{
					BS_ASSERT(pAsync == NULL);
					ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
							   L"Error on calling DoSnapshotSet. hr = 0x%08lx", ft.hr);
				}
				BS_ASSERT(pAsync);

                ShowWindow(SW_HIDE);
                CAsyncDlg dlg(pAsync);
                if (dlg.DoModal() == IDCANCEL)
                    EndDialog(IDCANCEL);
                else
                    ShowWindow(SW_SHOW);

			}
			else
			{
				ft.hr = m_pICoord->DoSnapshotSet(
				            NULL,
							NULL
							);

				if ( ft.HrFailed() )
					ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
							   L"Error on calling DoSnapshotSet. hr = 0x%08lx", ft.hr);
			}

			// Get all snapshot attributes
			if (m_pSnap)
			{
			/*
				VSS_OBJECT_PROP_Ptr ptrSnapshot;
				ptrSnapshot.InitializeAsSnapshot( ft,
					GUID_NULL,
					GUID_NULL,
					NULL,
					NULL,
					GUID_NULL,
					NULL,
					VSS_SWPRV_ProviderId,
					NULL,
					0,
					0,
					VSS_SS_UNKNOWN,
					0,
					0,
					0,
					NULL
					);
				VSS_SNAPSHOT_PROP* pSnap = &(ptrSnapshot.GetStruct()->Obj.Snap);

				ft.hr = m_pSnap->GetProperties( pSnap);
				WCHAR wszBuffer[2048];
				ptrSnapshot.Print(ft, wszBuffer, 2048);

				ft.MsgBox( L"Results", wszBuffer);
			*/
				LPWSTR wszName;
				ft.hr = m_pSnap->GetDevice( &wszName );
				if (ft.HrFailed())
					ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
								L"Error on getting the snapshot name 0x%08lx", ft.hr);

				ft.MsgBox( L"Snapshot name = %s", wszName);

				::VssFreeString(wszName);
			}
			
            ft.MsgBox( L"OK", L"Snapshot Set created!" );

            EndDialog(IDOK);
        }
        else
        {
            // Getting the Volume Id
            int nIndex = m_cbVolumes.GetCurSel();
            if (nIndex == CB_ERR)
                ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on getting the currently selected volume");

            // REMOVED: GUID* pVolumeGuid = (GUID*)m_cbVolumes.GetItemDataPtr(nIndex);
			int nBufferLen = m_cbVolumes.GetLBTextLen(nIndex);
            if (nBufferLen == CB_ERR)
                ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on getting the currently selected volume");

			ptszVolumeName = new TCHAR[nBufferLen+1];
			if (ptszVolumeName == NULL)
                ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on getting the currently selected volume");

			if ( m_cbVolumes.GetLBText( nIndex, ptszVolumeName ) == CB_ERR)
				ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on getting the currently selected volume");

			LPWSTR pwszVolumeName = T2W(ptszVolumeName);

            // Getting the Provider Id
            nIndex = m_cbProviders.GetCurSel();
            if (nIndex == CB_ERR)
                ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on getting the currently selected provider");

            GUID* pProviderGuid = (GUID*)m_cbProviders.GetItemDataPtr(nIndex);

            if ( *pProviderGuid == VSS_SWPRV_ProviderId )
            {
			    CComPtr<IVssSnapshot> pSnapshot;
                m_pSnap = NULL;
                ft.hr = m_pICoord->AddToSnapshotSet(
                    pwszVolumeName,
                    VSS_SWPRV_ProviderId,
                    &m_pSnap
                    );

                if ( ft.HrFailed() )
                    ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on calling AddToSnapshotSet. hr = 0x%08lx", ft.hr);

                // Increment the number of snapshots
                m_nSnapshotsCount++;
            }
            else if ( *pProviderGuid == GUID_NULL )
            {

#if 0
                // Software provider
                ShowWindow(SW_HIDE);
                CSoftwareSnapshotTestDlg dlg;
                if (dlg.DoModal() == IDCANCEL)
                    EndDialog(IDCANCEL);
                else
                    ShowWindow(SW_SHOW);

                // See if it is read-only
                if (! dlg.m_bReadOnly)
                    lAttributes |= VSS_VOLSNAP_ATTR_READ_WRITE;
                else
                    lAttributes &= ~VSS_VOLSNAP_ATTR_READ_WRITE;
#endif

                m_pSnap = NULL;
                ft.hr = m_pICoord->AddToSnapshotSet(
                    pwszVolumeName,
                    *pProviderGuid,
                    &m_pSnap
                    );

                if ( ft.HrFailed() )
                    ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on calling AddToSnapshotSet. hr = 0x%08lx", ft.hr);
/*
                CComPtr<IVsSoftwareSnapshot> pSnapshot;
                ft.hr = m_pSnap->SafeQI( IVsSoftwareSnapshot, &pSnapshot );
                if ( ft.HrFailed() )
                    ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
                        L"Error querying the IVssSnapshot interface. hr = 0x%08lx", ft.hr);
                BS_ASSERT( m_pSnap != NULL);

                ft.hr = pSnapshot->SetInitialAllocation( dlg.m_nLogFileSize*1024*1024 );
                if ( ft.HrFailed() )
                    ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
                        L"Error on calling SetInitialAllocation. hr = 0x%08lx", ft.hr);
*/
                // Increment the number of snapshots
                m_nSnapshotsCount++;

            }
            else
            {
                BS_ASSERT( false );
            }

			CWnd* pWnd = GetDlgItem(IDC_SS_DO);
			if (pWnd)
				pWnd->EnableWindow(TRUE);

            UpdateData(FALSE);
        }
    }
    VSS_STANDARD_CATCH(ft)

	delete ptszVolumeName;
}


void CSnapshotSetDlg::OnBack()
{
	EndDialog(ID_BACK);
}


void CSnapshotSetDlg::OnClose()
{
    CVssTestGenericDlg::OnClose();
}


void CSnapshotSetDlg::EnableGroup()
{
    CWnd *pWnd;
    pWnd = GetDlgItem(IDC_SS_VOLUMES);
    if (pWnd)
        pWnd->EnableWindow(!m_bDo);
    pWnd = GetDlgItem(IDC_SS_PROVIDERS);
    if (pWnd)
        pWnd->EnableWindow(!m_bDo);
    /*
    pWnd = GetDlgItem(IDC_SS_ATTR);
    if (pWnd)
        pWnd->EnableWindow(!m_bDo);
    */
    /*
    pWnd = GetDlgItem(IDC_SS_PARTIAL_COMMIT);
    if (pWnd)
        pWnd->EnableWindow(m_bDo);
    pWnd = GetDlgItem(IDC_SS_WRITER_VETOES);
    if (pWnd)
        pWnd->EnableWindow(m_bDo);
    pWnd = GetDlgItem(IDC_SS_WRITER_CANCEL);
    if (pWnd)
        pWnd->EnableWindow(m_bDo);
    pWnd = GetDlgItem(IDC_SS_ASYNC);
    if (pWnd)
        pWnd->EnableWindow(m_bDo);
    */
}

void CSnapshotSetDlg::OnAdd()
{
    m_bDo = FALSE;
    EnableGroup();
}


void CSnapshotSetDlg::OnDo()
{
    m_bDo = TRUE;
    EnableGroup();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\stdafx.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    StdAfx.cpp

Abstract:

    Source file that includes just the standard includes.  stdafx.pch will be
    the pre-compiled header and stdafx.obj will contain the pre-compiled type
    information.

Author:

    Adi Oltean  [aoltean]  11/01/1998

Revision History:
    Name        Date        Comments

--*/

#include "stdafx.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\swtstdlg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module SwTstDlg.h | Header file for the Software Snapshot dialog
    @end

Author:

    Adi Oltean  [aoltean]  07/26/1999

Revision History:

    Name        Date        Comments

    aoltean     07/26/1999  Created
    aoltean     08/05/1999  Splitting wizard functionality in a base class

--*/


#if !defined(__VSS_SWTST_DLG_H__)
#define __VSS_SWTST_DLG_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


/////////////////////////////////////////////////////////////////////////////
// CSoftwareSnapshotTestDlg dialog

class CSoftwareSnapshotTestDlg : public CVssTestGenericDlg
{
// Construction
public:
    CSoftwareSnapshotTestDlg(
        CWnd* pParent = NULL); 
    ~CSoftwareSnapshotTestDlg();

// Dialog Data
    //{{AFX_DATA(CSoftwareSnapshotTestDlg)
	enum { IDD = IDD_SWTST };
//	CString	m_strLogFileName;
    int     m_nLogFileSize;
    BOOL    m_bReadOnly;
	//}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSoftwareSnapshotTestDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CSoftwareSnapshotTestDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnNext();
    afx_msg void OnAdd();
    afx_msg void OnDo();
//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(__VSS_SWTST_DLG_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\voldlg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module QueryDlg.h | Header file for the query dialog
    @end

Author:

    Adi Oltean  [aoltean]  09/22/1999

Revision History:

    Name        Date        Comments

    aoltean     09/22/1999  Created
	aoltean		09/27/1999	Adding Query mask flags

--*/


#if !defined(__VSS_TEST_VOLDLG_H__)
#define __VSS_TEST_VOLDLG_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


/////////////////////////////////////////////////////////////////////////////
// CVolDlg dialog

class CVolDlg : public CVssTestGenericDlg
{
    typedef enum _VSS_IS_VOL_XXX { 
        VSS_IS_VOL_SUPPORTED, 
        VSS_IS_VOL_SNAPSHOTTED,
        VSS_IS_VOL_SUPPORTED2, 
        VSS_IS_VOL_SNAPSHOTTED2 
    } VSS_IS_VOL_XXX;

// Construction
public:
    CVolDlg(
        IVssCoordinator *pICoord,
        CWnd* pParent = NULL); 
    ~CVolDlg();

// Dialog Data
    //{{AFX_DATA(CVolDlg)
	enum { IDD = IDD_VOLUME };
	CString	    m_strObjectId;
	CString     m_strVolumeName;
	//}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CVolDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    CComPtr<IVssCoordinator> m_pICoord;
    VSS_IS_VOL_XXX m_eCallType;

    // Generated message map functions
    //{{AFX_MSG(CVolDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnNext();
	afx_msg void OnIsVolumeSupported();
    afx_msg void OnIsVolumeSnapshotted();
	afx_msg void OnIsVolumeSupported2();
    afx_msg void OnIsVolumeSnapshotted2();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(__VSS_TEST_VOLDLG_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\swtstdlg.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module SwTstDlg.cpp | Implementation of the Software Snapshot dialog
    @end

Author:

    Adi Oltean  [aoltean]  07/26/1999

Revision History:

    Name        Date        Comments

    aoltean     07/26/1999  Created
    aoltean     08/05/1999  Splitting wizard functionality in a base class
    aoltean     09/11/1999  More validation of log file name
    aoltean     09/09/1999  Adding a default value for the log file name

--*/


/////////////////////////////////////////////////////////////////////////////
// Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vsswprv.h"

#include "GenDlg.h"

#include "SwTstDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define STR2W(str) ((LPTSTR)((LPCTSTR)(str)))


/////////////////////////////////////////////////////////////////////////////
// CSoftwareSnapshotTestDlg dialog

CSoftwareSnapshotTestDlg::CSoftwareSnapshotTestDlg(
    CWnd* pParent /*=NULL*/
    )
    : CVssTestGenericDlg(CSoftwareSnapshotTestDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CSoftwareSnapshotTestDlg)
	//}}AFX_DATA_INIT

//    m_strLogFileName = _T("e:\\snap.log");
    m_nLogFileSize = 100;
    m_bReadOnly = TRUE;
}

CSoftwareSnapshotTestDlg::~CSoftwareSnapshotTestDlg()
{
}

void CSoftwareSnapshotTestDlg::DoDataExchange(CDataExchange* pDX)
{
    CVssTestGenericDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSoftwareSnapshotTestDlg)
//	DDX_Text(pDX, IDC_SWTST_LOGFILE,        m_strLogFileName);
	DDX_Text(pDX, IDC_SWTST_LOGFILE_SIZE,   m_nLogFileSize);
	DDX_Check(pDX,IDC_SWTST_READONLY,       m_bReadOnly);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSoftwareSnapshotTestDlg, CVssTestGenericDlg)
    //{{AFX_MSG_MAP(CSoftwareSnapshotTestDlg)
    ON_BN_CLICKED(IDC_NEXT, OnNext)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CSoftwareSnapshotTestDlg message handlers


BOOL CSoftwareSnapshotTestDlg::OnInitDialog()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CCoordDlg::OnInitDialog" );
    USES_CONVERSION;

    try
    {
        CVssTestGenericDlg::OnInitDialog();

        UpdateData(FALSE);
    }
    VSS_STANDARD_CATCH(ft)

    return TRUE;  // return TRUE  unless you set the focus to a control
}


void CSoftwareSnapshotTestDlg::OnNext() 
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CSoftwareSnapshotTestDlg::OnNext" );

    USES_CONVERSION;

    try
    {
        UpdateData();
/*
        // Check if file name is empty
        if (m_strLogFileName.IsEmpty())
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, _T("Invalid value for the Log file name"));

        // Check if file name has a drive letter
		m_strLogFileName.MakeUpper();
        WCHAR* wszLogFileName = T2W((LPTSTR)(LPCTSTR)m_strLogFileName);

        WCHAR wszDrive[_MAX_DRIVE];
        WCHAR wszDir[_MAX_DIR];
        WCHAR wszFileName[_MAX_FNAME];
        WCHAR wszExt[_MAX_EXT];
        _wsplitpath(wszLogFileName, wszDrive, wszDir, wszFileName, wszExt);  
        if (wszDrive[0] == L'\0')
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, _T("Drive letter not specified for the Log file name"));
        if (wszDir[0] == L'\0')
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, _T("Directory not specified for the Log file name"));
*/
        // Check if file name has a drive letter
        if (m_nLogFileSize <= 0)
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, _T("Invalid value for the Log file initial size"));

        EndDialog(IDOK);
    }
    VSS_STANDARD_CATCH(ft)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\writer\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by writer.rc
//
#define IDS_PROJNAME                    100
#define IDR_Writer_1                    100
#define IDR_DSSSNAPSHOTWRITER           101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\vsstest.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module VssTest.cpp | Main file for the Vss test application
    @end

Author:

    Adi Oltean  [aoltean]  07/22/1999

Revision History:

    Name        Date        Comments

    aoltean     07/22/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
// Includes


#include "stdafx.hxx"

#include "GenDlg.h"

#include "VssTest.h"
#include "ConnDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#pragma warning( disable: 4189 )  /* local variable is initialized but not referenced */
#include <atlimpl.cpp>
#pragma warning( default: 4189 )  /* local variable is initialized but not referenced */


/////////////////////////////////////////////////////////////////////////////
// CVssTestApp

BEGIN_MESSAGE_MAP(CVssTestApp, CWinApp)
    //{{AFX_MSG_MAP(CVssTestApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVssTestApp construction

CVssTestApp::CVssTestApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CVssTestApp object

CVssTestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CVssTestApp initialization

BOOL CVssTestApp::InitInstance()
{
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

    CoInitialize(NULL);

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    CConnectDlg dlg;
    m_pMainWnd = &dlg;
    int nResponse = (int)dlg.DoModal();
    if (nResponse == IDOK)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with OK
    }
    else if (nResponse == IDCANCEL)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with Cancel
    }

    // Avoid a AV on lclosing the app.
    m_pMainWnd = NULL;

    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}


BOOL CVssTestApp::ExitInstance()
{
    CoUninitialize();
    return CWinApp::ExitInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\vsstest.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module VssTest.h | Main header file for the test application
    @end

Author:

    Adi Oltean  [aoltean]  07/22/1999

Revision History:

    Name        Date        Comments

    aoltean     07/22/1999  Created

--*/


#if !defined(__VSS_TEST_H__)
#define __VSS_TEST_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.hxx' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CVssTestApp:
// See Test.cpp for the implementation of this class
//

class CVssTestApp : public CWinApp
{
public:
	CVssTestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVssTestApp)
	public:
	virtual BOOL InitInstance();
    virtual BOOL ExitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CVssTestApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


inline void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, GUID& value)
{
   if (pDX->m_bSaveAndValidate)
	{
		CString str;
		DDX_Text(pDX, nIDC, str);

		LPTSTR ptszObjectId = const_cast<LPTSTR>(LPCTSTR(str));
        HRESULT hr = ::CLSIDFromString(T2OLE(ptszObjectId), &value);
        if (hr != S_OK)
			pDX->Fail();        // throws exception
	}
	else
	{
		CString str;
		str.Format(WSTR_GUID_FMT, GUID_PRINTF_ARG(value));
		DDX_Text(pDX, nIDC, str);
	}
}


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(__VSS_TEST_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\vss_test\voldlg.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module VolDlg.cpp | Implementation of the IsVolumeXXX dialog
    @end

Author:

    Adi Oltean  [aoltean]  10/22/2000

Revision History:

    Name        Date        Comments

    aoltean     10/22/2000  Created

--*/


/////////////////////////////////////////////////////////////////////////////
// Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vsswprv.h"

#include "GenDlg.h"

#include "VssTest.h"
#include "VolDlg.h"
#include "vswriter.h"
#include "vsbackup.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define STR2W(str) ((LPTSTR)((LPCTSTR)(str)))


/////////////////////////////////////////////////////////////////////////////
// CVolDlg dialog

CVolDlg::CVolDlg(
    IVssCoordinator *pICoord,
    CWnd* pParent /*=NULL*/
    )
    : CVssTestGenericDlg(CVolDlg::IDD, pParent), m_pICoord(pICoord)
{
    //{{AFX_DATA_INIT(CVolDlg)
	m_strObjectId.Empty();
    m_strVolumeName.Empty();
	//}}AFX_DATA_INIT
}

CVolDlg::~CVolDlg()
{
}

void CVolDlg::DoDataExchange(CDataExchange* pDX)
{
    CVssTestGenericDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CVolDlg)
	DDX_Text(pDX, IDC_VOLUME_OBJECT_ID, m_strObjectId);
	DDX_Text(pDX, IDC_VOLUME_NAME, m_strVolumeName);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CVolDlg, CVssTestGenericDlg)
    //{{AFX_MSG_MAP(CVolDlg)
    ON_BN_CLICKED(IDC_NEXT, OnNext)
    ON_BN_CLICKED(IDC_VOLUME_IS_VOL_SUPPORTED,	OnIsVolumeSupported)
    ON_BN_CLICKED(IDC_VOLUME_IS_VOL_SNAPSHOTTED,OnIsVolumeSnapshotted)
    ON_BN_CLICKED(IDC_VOLUME_IS_VOL_SUPPORTED2,	OnIsVolumeSupported2)
    ON_BN_CLICKED(IDC_VOLUME_IS_VOL_SNAPSHOTTED2,OnIsVolumeSnapshotted2)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVolDlg message handlers

BOOL CVolDlg::OnInitDialog()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CVolDlg::OnInitDialog" );

    try
    {
        CVssTestGenericDlg::OnInitDialog();

        m_eCallType = VSS_IS_VOL_SUPPORTED;
        BOOL bRes = ::CheckRadioButton( m_hWnd, IDC_VOLUME_IS_VOL_SUPPORTED, IDC_VOLUME_IS_VOL_SUPPORTED, IDC_VOLUME_IS_VOL_SUPPORTED );
        _ASSERTE( bRes );

        // Initializing Snapshot Set ID
		VSS_ID ObjectId = VSS_SWPRV_ProviderId;
        LPOLESTR strGUID;
        ft.hr = ::StringFromCLSID( ObjectId, &strGUID );
        if ( ft.HrFailed() )
            ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on calling StringFromCLSID. hr = 0x%08lx", ft.hr);

        m_strObjectId = OLE2T(strGUID);
        ::CoTaskMemFree(strGUID);

        UpdateData( FALSE );
    }
    VSS_STANDARD_CATCH(ft)

    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CVolDlg::OnNext()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CVolDlg::OnNext" );
    USES_CONVERSION;

	const nBuffLen = 2048; // including the zero character.
	WCHAR wszBuffer[nBuffLen];

    try
    {
        UpdateData();

		// Get the provider Id.
		LPTSTR ptszObjectId = const_cast<LPTSTR>(LPCTSTR(m_strObjectId));
		VSS_ID ProviderId;
        ft.hr = ::CLSIDFromString(T2OLE(ptszObjectId), &ProviderId);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                      L"Error on converting the object Id %s to a GUID. lRes == 0x%08lx",
                      T2W(ptszObjectId), ft.hr );

		// Get the enumerator
		BS_ASSERT(m_pICoord);
		BOOL bResult = FALSE;
		LPWSTR pwszFunctionName = L"<unknown function>";
		switch (m_eCallType) {
	    case VSS_IS_VOL_SUPPORTED:
    		ft.hr = m_pICoord->IsVolumeSupported(
    			ProviderId,
    			T2W(LPTSTR((LPCTSTR)m_strVolumeName)),
    			&bResult
    		);
    		pwszFunctionName = L"IsVolumeSupported";
    		break;
	    case VSS_IS_VOL_SNAPSHOTTED:
    		ft.hr = m_pICoord->IsVolumeSnapshotted(
    			ProviderId,
    			T2W(LPTSTR((LPCTSTR)m_strVolumeName)),
    			&bResult
    		);
    		pwszFunctionName = L"IsVolumeSnapshotted";
    		break;
	    case VSS_IS_VOL_SUPPORTED2: 
	        {
    	        CComPtr<IVssBackupComponents> pComp;
    	        ft.hr = CreateVssBackupComponents(&pComp);
        		ft.hr = pComp->IsVolumeSupported(
        			ProviderId,
        			T2W(LPTSTR((LPCTSTR)m_strVolumeName)),
        			&bResult
        		);
        		pwszFunctionName = L"IsVolumeSupported2";
    	    }
    		break;
	    case VSS_IS_VOL_SNAPSHOTTED2:
    		ft.hr = IsVolumeSnapshotted(
    			T2W(LPTSTR((LPCTSTR)m_strVolumeName)),
    			&bResult
    		);
    		pwszFunctionName = L"IsVolumeSnapshotted2";
    		break;
    	default:
			ft.ErrBox( VSSDBG_VSSTEST, E_UNEXPECTED,
					   L"Invalid call type %s().", pwszFunctionName);
		}    		    
    		    
		if (ft.HrFailed())
			ft.ErrBox( VSSDBG_VSSTEST, ft.hr,
					   L"Error on calling %s(). [0x%08lx]", pwszFunctionName, ft.hr);

		ft.MsgBox(L"Function result", L"Function %s("WSTR_GUID_FMT L", %s, ...) returned %s", 
		        pwszFunctionName, 
		        GUID_PRINTF_ARG(ProviderId), 
		        T2W(LPTSTR((LPCTSTR)m_strVolumeName)),
		        bResult? L"TRUE":L"FALSE");
    }
    VSS_STANDARD_CATCH(ft)
}


void CVolDlg::OnIsVolumeSupported()
{
    m_eCallType = VSS_IS_VOL_SUPPORTED;
}


void CVolDlg::OnIsVolumeSnapshotted()
{
    m_eCallType = VSS_IS_VOL_SNAPSHOTTED;
}


void CVolDlg::OnIsVolumeSupported2()
{
    m_eCallType = VSS_IS_VOL_SUPPORTED;
}


void CVolDlg::OnIsVolumeSnapshotted2()
{
    m_eCallType = VSS_IS_VOL_SNAPSHOTTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\writer\resolve.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Resolve.cpp | Implementation of Writer
    @end

Author:

    Adi Oltean  [aoltean]  08/18/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     08/18/1999  Created
	aoltean		09/22/1999	Making console output clearer

--*/


/////////////////////////////////////////////////////////////////////////////
//  Defines

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes

#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>
#include <comadmin.h>

#include "vs_assert.hxx"

// ATL
#include <atlconv.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include "vs_inc.hxx"


#include "comadmin.hxx"
#include "vsevent.h"
#include "writer.h"



/////////////////////////////////////////////////////////////////////////////
// User interaction functions

//
// During ResolveResource
//

void OnAddResource(IVssDependencies* pDep);
void OnAddDependency(IVssDependencies* pDep);
void OnCancel(IVssDependencies* pDep);
void OnPrint(IVssDependencies* pDep);

void AskDuringResolve(
	IN	CVssFunctionTracer& ft,
	IN	IDispatch* pCallback	
	);

/////////////////////////////////////////////////////////////////////////////
// CVssWriter


STDMETHODIMP CVssWriter::ResolveResource(
 		IN BSTR bstrAppInstance,			
 		IN BSTR bstrResourceName,			
		IN BSTR bstrResourceId,	
 		IN BSTR bstrProcessContext,
		IN BSTR bstrProcessId,		
		IN	IDispatch* pDepGraphCallback	
	)
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CVssWriter::ResolveResource" );

    ft.Msg(L"\nReceived Event: ResolveResource\nParameters:");
    ft.Msg(L"\tstrAppInstance = %s", (LPWSTR)bstrAppInstance);
    ft.Msg(L"\tstrResourceName = %s", (LPWSTR)bstrResourceName);
    ft.Msg(L"\tstrResourceId = %s", (LPWSTR)bstrResourceId);
    ft.Msg(L"\tstrProcessContext = %s", (LPWSTR)bstrProcessContext);
    ft.Msg(L"\tstrProcessId = %s", (LPWSTR)bstrProcessId);
    ft.Msg(L"\tstrProcessId = %s", (LPWSTR)bstrProcessId);

	AskDuringResolve( ft, pDepGraphCallback );

	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// Private implementation


void AskDuringResolve(
	IN	CVssFunctionTracer& ft,
	IN IDispatch* pCallback	
	)
{
	while(true)
	{
		ft.Msg(L"\nCommands:");
		ft.Msg(L"\t[1] Done");
		ft.Msg(L"\t[2] Add Resource");
		ft.Msg(L"\t[3] Add Dependency");
		ft.Msg(L"\t[4] Cancel");
		ft.Msg(L"\t[5] Print graph");

		try
		{
			CComPtr<IVssDependencies> pDep;
			ft.hr = pCallback->SafeQI(IVssDependencies, &pDep);
			if (ft.HrFailed())
				ft.Err( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error calling QI 0x%08lx", ft.hr );
			BS_ASSERT(pDep);

			int  nOption = QueryInt(L"Option: ");
			switch(nOption)
			{
			case 1:
				return;

			case 2:
				OnAddResource(pDep);
				break;

			case 3:
				OnAddDependency(pDep);
				break;

			case 4:
				OnCancel(pDep);
				break;

			case 5:
				OnPrint(pDep);
				break;
				
			default:
				break;
			}
		}
		VSS_STANDARD_CATCH(ft)
	}

}

void OnAddResource(IVssDependencies* pDep)
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"OnAddResource" );

	CComBSTR strNewResourceName = QueryString(L"New resource name: ");
	CComBSTR strAppInstance = QueryString(L"App Instance: ");
	WCHAR wchIsExternal = (QueryString(L"External? [y/N] "))[0];
	VSS_RESOURCE_TYPE eType = (towupper(wchIsExternal) == L'Y')?
		VSS_EXTERNAL_RESOURCE: VSS_LOCAL_RESOURCE;
	CComBSTR strVolumeList = QueryString(L"Volume List: ");
	CComBSTR strDetails = QueryString(L"Details: ");

	CComBSTR strResourceId;

	ft.hr = pDep->AddResource(
						strNewResourceName,
						strAppInstance,
						eType,
						strVolumeList,
						strDetails,
						&strResourceId
						);
	if (ft.HrFailed())
		ft.Err( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error calling AddResource 0x%08lx", ft.hr );

	ft.Msg(L"Resource Id = %s ; HRESULT = 0x%08lx", strResourceId, ft.hr );
}


void OnAddDependency(IVssDependencies* pDep)
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"OnAddDependency" );

	CComBSTR strFromResourceId = QueryString(L"From Resource ID: ");
	CComBSTR strToResourceId = QueryString(L"To Resource ID: ");
	CComBSTR strDescription = QueryString(L"Description: ");

	ft.hr = pDep->AddDependency(
						strFromResourceId,
						strToResourceId,
						strDescription
						);
	if (ft.HrFailed())
		ft.Err( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error calling AddDependency 0x%08lx", ft.hr );

	ft.Msg(L"HRESULT = 0x%08lx", ft.hr );
}


void OnCancel(IVssDependencies* pDep)
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"OnCancel" );

	HRESULT hrErrorCode = QueryInt(L"Error code: ");
	CComBSTR bstrCancelReason = QueryString(L"Cancel reason: ");

	ft.hr = pDep->Cancel( hrErrorCode, bstrCancelReason );
	if (ft.HrFailed())
		ft.Err( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error calling AddDependency 0x%08lx", ft.hr );

	ft.Msg(L"HRESULT = 0x%08lx", ft.hr );
}


void OnPrint(IVssDependencies* pDep)
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"OnPrint" );

	CComPtr<IDispatch> pDisp;
	ft.hr = pDep->SaveAsXML( NULL, 1, &pDisp );
	if (ft.HrFailed())
		ft.Err( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error calling SaveAsXML 0x%08lx", ft.hr );
	BS_ASSERT(pDisp);

	// Get the Document interface
	CComPtr<IXMLDOMDocument> pDoc;
	ft.hr = pDisp->SafeQI( IXMLDOMDocument, &pDoc );
	if (ft.HrFailed())
		ft.Err( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error calling QI 0x%08lx", ft.hr );
	BS_ASSERT(pDoc);
/*
	// Get a file name
	CComBSTR bstrOutputFile = QueryString(L"Output file name: ");
*/
	CComBSTR bstrOutputFile = L"output.xml";

	if (!bstrOutputFile)
		ft.Err( VSSDBG_VSSTEST, E_UNEXPECTED, L"NULL file name" );
	
	// Save the document into that file
	CComVariant varFileName = bstrOutputFile;
	ft.hr = pDoc->save(varFileName);
	if (ft.HrFailed())
		ft.Err( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error calling IXMLDOCDocument::save 0x%08lx", ft.hr );

	// Execute the command
	_wsystem(L"start output.xml");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\writer\writer.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Writer.h | Declaration of Writer
    @end

Author:

    Adi Oltean  [aoltean]  08/18/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     08/18/1999  Created

--*/


#ifndef __VSSSNAPSHOTWRITER_H_
#define __VSSSNAPSHOTWRITER_H_


/////////////////////////////////////////////////////////////////////////////
// Utility functions


LPWSTR QueryString(LPWSTR wszPrompt);
INT QueryInt(LPWSTR wszPrompt);


/////////////////////////////////////////////////////////////////////////////
// CVssWriter


class ATL_NO_VTABLE CVssWriter : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IVssWriter
{
// IVssWriter
public:

	STDMETHOD(ResolveResource)(
 		IN BSTR strAppInstance,			    
 		IN BSTR strResourceName,			
		IN BSTR strResourceId,	
 		IN BSTR strProcessContext,
		IN BSTR strProcessId,		
		IN IDispatch* pDepGraphCallback	
		);
	
	STDMETHOD(PrepareForSnapshot)(                          
        IN  BSTR    bstrSnapshotSetId,   
        IN  BSTR    VolumeNamesList,      
        IN  VSS_FLUSH_TYPE		eFlushType,
		IN	BSTR	strFlushContext,
		IN	IDispatch* pDepGraphCallback,
		IN	IDispatch* pAsyncCallback	
        );

    STDMETHOD(Freeze)(
        IN  BSTR    bstrSnapshotSetId,   
        IN  INT     nApplicationLevel            
        );                                           

    STDMETHOD(Thaw)(
        IN  BSTR    bstrSnapshotSetId    
        );

BEGIN_COM_MAP(CVssWriter)
	COM_INTERFACE_ENTRY(IVssWriter)
END_COM_MAP()

// Implementation
private:

	void AskCancelDuringFreezeThaw(
		IN	CVssFunctionTracer& ft
		);

	CComPtr<IVssAsync> m_pAsync;
};

#endif //__VSSSNAPSHOTWRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\xmlint\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	xmlint.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\waitsnap\waitsnap.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	waitsnap.cpp
**
**
** Abstract:
**
**	Test program that starts a VSS writer and waits upon receiving a specific event
**
** Author:
**
**	Charles Chung   [cchung]        04-Dec-2001
**
**
** Revision History:
**      1.0 Altered from Failsnap.cpp
**
**--
*/

/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/
#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <assert.h>

#include <vss.h>
#include <vswriter.h>



#define	GET_STATUS_FROM_BOOL(_bSucceeded)	((_bSucceeded)       ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_HANDLE(_handle)		((NULL != (_handle)) ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_POINTER(_ptr)		((NULL != (_ptr))    ? NOERROR : E_OUTOFMEMORY)

#define SIZEOF_ARRAY(_aBase)			(sizeof (_aBase) / sizeof ((_aBase)[0]))



typedef enum FAIL_PHASE
    {
    PHASE_UNDEFINED = 0,
    PHASE_IDENTIFY,
    PHASE_PREPARE_FOR_BACKUP,
    PHASE_PREPARE_FOR_SNAPSHOT,
    PHASE_FREEZE,
    PHASE_THAW,
    PHASE_ABORT,
    PHASE_BACKUP_COMPLETE,
    PHASE_RESTORE
    } FAIL_PHASE;


HRESULT SelectFailureStatus (VOID)
    {
    HRESULT	hrStatus;

    switch (rand () / (RAND_MAX / 5))
	{
	case 0: hrStatus = VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT; break;
	case 1: hrStatus = VSS_E_WRITERERROR_OUTOFRESOURCES;       break;
	case 2: hrStatus = VSS_E_WRITERERROR_TIMEOUT;              break;
	case 3: hrStatus = VSS_E_WRITERERROR_NONRETRYABLE;         break;
	case 4: hrStatus = VSS_E_WRITERERROR_RETRYABLE;            break;

	default:
	    assert (FALSE);
	    break;
	}

    return (hrStatus);
    }



void ForceSleep(INT sec)
{
  wprintf(L"\tGoing to sleep for %d seconds...\n", sec) ;
  while(sec>0) {
    Sleep(1000) ;
    sec-- ;
    if(sec%10==0) {
      wprintf(L"\tSeconds left=%d\n", sec) ;
    }
  }
  wprintf(L"\tAwaken!\n") ;
}

LPCWSTR GetStringFromFailureType (HRESULT hrStatus)
    {
    LPCWSTR pwszFailureType;

    switch (hrStatus)
	{
	case NOERROR:                                pwszFailureType = L"";                     break;
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT: pwszFailureType = L"InconsistentSnapshot"; break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:       pwszFailureType = L"OutOfResources";       break;
	case VSS_E_WRITERERROR_TIMEOUT:              pwszFailureType = L"Timeout";              break;
	case VSS_E_WRITERERROR_NONRETRYABLE:         pwszFailureType = L"Non-Retryable";        break;
	case VSS_E_WRITERERROR_RETRYABLE:            pwszFailureType = L"Retryable";            break;
	default:                                     pwszFailureType = L"UNDEFINED";            break;
	}

    return (pwszFailureType);
    }



LPCWSTR GetStringFromWriterType (VSS_USAGE_TYPE wtWriterType)
    {
    LPCWSTR pwszWriterType;

    switch (wtWriterType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszWriterType = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszWriterType = L"SystemServiceState";  break;
	case VSS_UT_USERDATA:            pwszWriterType = L"UserData";            break;
	case VSS_UT_OTHER:               pwszWriterType = L"Other";               break;
	default:                         pwszWriterType = L"UNDEFINED";           break;
	}

    return (pwszWriterType);
    }



LPCWSTR GetStringFromWaitPhase (FAIL_PHASE fpWaitPhase)
    {
    LPCWSTR pwszWaitPhase;


    switch (fpWaitPhase)
	{
	case PHASE_IDENTIFY:             pwszWaitPhase = L"Identify";           break;
	case PHASE_PREPARE_FOR_BACKUP:   pwszWaitPhase = L"PrepareForBackup";   break;
	case PHASE_PREPARE_FOR_SNAPSHOT: pwszWaitPhase = L"PrepareForSnapshot"; break;
	case PHASE_FREEZE:               pwszWaitPhase = L"Freeze";             break;
	case PHASE_THAW:                 pwszWaitPhase = L"Thaw";               break;
	case PHASE_ABORT:                pwszWaitPhase = L"Abort";              break;
	case PHASE_BACKUP_COMPLETE:      pwszWaitPhase = L"BackupComplete";     break;
	case PHASE_RESTORE:              pwszWaitPhase = L"Restore";            break;
	default:                         pwszWaitPhase = L"UNDEFINED";          break;
	}
    
    return (pwszWaitPhase);
    }





static volatile BOOL       bContinue   = TRUE;
static volatile FAIL_PHASE fpWaitPhase = PHASE_FREEZE;
static volatile INT        nWaitTime   = 10 ;


class CVssWriterWaitsnap : public CVssWriter
	{
public:
	    bool STDMETHODCALLTYPE OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata);
	    bool STDMETHODCALLTYPE OnPrepareBackup (IVssWriterComponents *pIVssWriterComponents);
	    bool STDMETHODCALLTYPE OnPrepareSnapshot ();
	    bool STDMETHODCALLTYPE OnFreeze ();
	    bool STDMETHODCALLTYPE OnThaw ();
	    bool STDMETHODCALLTYPE OnAbort ();
	    bool STDMETHODCALLTYPE OnBackupComplete (IVssWriterComponents *pIVssWriterComponents);
	    bool STDMETHODCALLTYPE OnPostRestore (IVssWriterComponents *pIVssWriterComponents);
};



bool STDMETHODCALLTYPE CVssWriterWaitsnap::OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata)
    {
    bool	bPhaseSucceeded = (PHASE_IDENTIFY != fpWaitPhase);
    HRESULT	hrStatus        = SelectFailureStatus ();

    if (bPhaseSucceeded)
	{
	hrStatus = pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							    NULL,
							    L"Waitsnap Writer Component",
							    L"Waitsnap Writer Caption",
							    NULL, // icon
							    0,
							    true,
							    false,
							    false);

	bPhaseSucceeded = SUCCEEDED (hrStatus);
	}


    wprintf (L"\nThreadId 0x%04x - Received event - OnIdentify ()%s%s\n", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    

    if (!bPhaseSucceeded)
	{
	  ForceSleep(nWaitTime) ;
	}

    return (TRUE);
    }


bool STDMETHODCALLTYPE CVssWriterWaitsnap::OnPrepareBackup (IVssWriterComponents *pIVssWriterComponents)
    {
    bool	bPhaseSucceeded = (PHASE_PREPARE_FOR_BACKUP != fpWaitPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnPrepareBackup ()%s%s\n", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	  ForceSleep(nWaitTime) ;
	}


    return (TRUE);
    }


bool STDMETHODCALLTYPE CVssWriterWaitsnap::OnPrepareSnapshot ()
    {
    bool	bPhaseSucceeded = (PHASE_PREPARE_FOR_SNAPSHOT != fpWaitPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnPrepareSnapshot ()%s%s\n", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	  ForceSleep(nWaitTime) ;
	}

    return (TRUE);
    }


bool STDMETHODCALLTYPE CVssWriterWaitsnap::OnFreeze ()
    {
    bool	bPhaseSucceeded = (PHASE_FREEZE != fpWaitPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnFreeze ()%s%s\n", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	  ForceSleep(nWaitTime) ;
	}

    return (TRUE);
    }


bool STDMETHODCALLTYPE CVssWriterWaitsnap::OnThaw ()
    {
    bool	bPhaseSucceeded = (PHASE_THAW != fpWaitPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnThaw ()%s%s\n", 
	     GetCurrentThreadId (),
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	  ForceSleep(nWaitTime) ;
	}

    return (TRUE);
    }


bool STDMETHODCALLTYPE CVssWriterWaitsnap::OnAbort ()
    {
    bool	bPhaseSucceeded = (PHASE_ABORT != fpWaitPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnAbort ()%s%s\n",
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	  ForceSleep(nWaitTime) ;
	}

    return (TRUE);
    }


bool STDMETHODCALLTYPE CVssWriterWaitsnap::OnBackupComplete (IVssWriterComponents *pIVssWriterComponents)
    {
    bool	bPhaseSucceeded = (PHASE_BACKUP_COMPLETE != fpWaitPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnBackupComplete ()%s%s\n", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));

    if (!bPhaseSucceeded)
	{
	  ForceSleep(nWaitTime) ;
	}

    return (TRUE);
    }


bool STDMETHODCALLTYPE CVssWriterWaitsnap::OnPostRestore (IVssWriterComponents *pIVssWriterComponents)
    {
    bool	bPhaseSucceeded = (PHASE_RESTORE != fpWaitPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnPostRestore ()%s%s\n", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	  ForceSleep(nWaitTime) ;
	}

    return (TRUE);
    }






static BOOL AssertPrivilege (LPCWSTR privName)
    {
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if (OpenProcessToken (GetCurrentProcess (), TOKEN_ADJUST_PRIVILEGES, &tokenHandle))
	{
        LUID value;

        if (LookupPrivilegeValue (NULL, privName, &value))
	    {
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            /*
            ** We will always call GetLastError below, so clear
            ** any prior error values on this thread.
            */
            SetLastError (ERROR_SUCCESS);

            stat = AdjustTokenPrivileges (tokenHandle,
					  FALSE,
					  &newState,
					  (DWORD)0,
					  NULL,
					  NULL);

            /*
            ** Supposedly, AdjustTokenPriveleges always returns TRUE
            ** (even when it fails). So, call GetLastError to be
            ** extra sure everything's cool.
            */
            if ((error = GetLastError()) != ERROR_SUCCESS)
		{
                stat = FALSE;
		}

            if (!stat)
		{
                wprintf (L"AdjustTokenPrivileges for %s failed with 0x%08X",
			 privName,
			 error);
		}
	    }


        CloseHandle (tokenHandle);
	}

    return stat;
    }



BOOL WINAPI CtrlC_HandlerRoutine (IN DWORD /* dwType */)
	{
	bContinue = FALSE;

	// Mark that the break was handled.
	return TRUE;
	}



extern "C" int __cdecl wmain (int argc, WCHAR *argv[])
    {
    HRESULT		 hrStatus            = NOERROR;
    CVssWriterWaitsnap	*pCVssWriterWaitsnap = NULL;
    BOOL		 bSucceeded          = FALSE;
    BOOL		 bComInitialized     = FALSE;
    BOOL		 bSubscribed         = FALSE;
    VSS_USAGE_TYPE	 wtWriterType        = VSS_UT_USERDATA;
    const GUID		 guidIdWriter        = {0xd335a99e,
						0x57fb,
						0x4b80,
						    {0x85, 0xb1, 0x15, 0xda, 0xa7, 0xc7, 0x4e, 0x14}};


    srand ((unsigned)time (NULL));

    SetConsoleCtrlHandler(CtrlC_HandlerRoutine, TRUE);


    if ((argc >= 2) && (wcslen (argv[1]) > 0))
	{
	  //get the stage which the writer is to fail
	switch (*argv[1])
	    {
	    case L'I': case L'i': fpWaitPhase = PHASE_IDENTIFY;             break;
	    case L'B': case L'b': fpWaitPhase = PHASE_PREPARE_FOR_BACKUP;   break;
	    case L'S': case L's': fpWaitPhase = PHASE_PREPARE_FOR_SNAPSHOT; break;
	    case L'F': case L'f': fpWaitPhase = PHASE_FREEZE;               break;
	    case L'T': case L't': fpWaitPhase = PHASE_THAW;                 break;
	    case L'A': case L'a': fpWaitPhase = PHASE_ABORT;                break;
	    case L'C': case L'c': fpWaitPhase = PHASE_BACKUP_COMPLETE;      break;
	    case L'R': case L'r': fpWaitPhase = PHASE_RESTORE;              break;

	    default:
		wprintf (L"\nWAITSNAP [phase] [writer type] [sec to wait]"
			 L"\n\n\tWaitPhases"
			 L"\n\t\ti - Identify"
			 L"\n\t\tb - PrepareForBackup"
			 L"\n\t\ts - PrepareForSnapshot"
			 L"\n\t\tf - Freeze                (default)"
			 L"\n\t\tt - Thaw"
			 L"\n\t\ta - Abort"
			 L"\n\t\tc - BackupComplete"
			 L"\n\t\tr - PostRestore"

			 L"\n\n\tWriterTypes"
			 L"\n\t\tb - BootableState writer"
			 L"\n\t\ts - ServiceState writer"
			 L"\n\t\tu - UserData writer       (default)"
			 L"\n\t\to - Other writer"
			 L"\n");



		bContinue = FALSE;
		break;
	    }

	
	    //get the amount of time the stage is to wait
	    
	}



    if ((argc >= 3) && (wcslen (argv[2]) > 0))
	{
	switch (*argv[2])
	    {
	    case L'B': case L'b': wtWriterType = VSS_UT_BOOTABLESYSTEMSTATE; break;
	    case L'S': case L's': wtWriterType = VSS_UT_SYSTEMSERVICE;       break;
	    case L'U': case L'u': wtWriterType = VSS_UT_USERDATA;            break;
	    case L'O': case L'o': wtWriterType = VSS_UT_OTHER;               break;

	    default:
		bContinue = FALSE;
		break;
	    }
	}


    //get the amount of seconds to wait
    if ((argc >= 4) && (wcslen (argv[3]) > 0))
	{
	  nWaitTime=_wtoi(argv[3]) ;
	}




    if (bContinue)
	{
	wprintf (L"\nSetting up %s writer to wait %s requests (ProcessId 0x%04x) for %d seconds",
		 GetStringFromWriterType (wtWriterType),
		 GetStringFromWaitPhase  (fpWaitPhase),
		 GetCurrentProcessId (), 
		 nWaitTime);


	wprintf (L"\nChecking privileges");

	bSubscribed = AssertPrivilege (SE_BACKUP_NAME);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);


	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nAssertPrivilege returned error 0x%08X", hrStatus);
	    }

	}


    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nInitializing COM");

	hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nCoInitialize() returned error 0x%08X", hrStatus);
	    }

	else
	    {
	    bComInitialized = TRUE;
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nConstructing Writer");

	pCVssWriterWaitsnap = new CVssWriterWaitsnap;

	if (NULL == pCVssWriterWaitsnap)
	    {
	    hrStatus = HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY);

	    wprintf (L"\nFailed to allocate CVssWriterWaitsnap : 0x%08X", hrStatus);
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	WCHAR	awchWriterName [256];


	wprintf (L"\nInitialising the writer");

	_snwprintf (awchWriterName, 
		    SIZEOF_ARRAY (awchWriterName), 
		    L"Microsoft Test Writer - Waitsnap (%s/%s/0x%04x)",
		    GetStringFromWriterType (wtWriterType),
		    GetStringFromWaitPhase  (fpWaitPhase),
		    GetCurrentProcessId ());


	hrStatus = pCVssWriterWaitsnap->Initialize (guidIdWriter,
						    awchWriterName,
						    wtWriterType,
						    VSS_ST_OTHER);

	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nFailed to initialize the writer : 0x%08X", hrStatus);
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nSubscribing to snapshot events");

	hrStatus = pCVssWriterWaitsnap->Subscribe ();

	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nFailed to subscribe to snapshot events : 0x%08X", hrStatus);
	    }

	else
	    {
	    bSubscribed = TRUE;
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nWaiting for snapshot events (or Ctrl-C)");
	
	while (bContinue)
	    {
	    Sleep (100);
	    }
	}



    if (bSubscribed)
	{
	wprintf (L"\nUn-Subscribing from snapshot events");

	pCVssWriterWaitsnap->Unsubscribe ();
	}


    if (NULL != pCVssWriterWaitsnap)
	{
	wprintf (L"\nDeconstructing Writer");

	delete pCVssWriterWaitsnap;
	}


    if (bComInitialized)
	{
	wprintf (L"\nUnInitialising COM");

	CoUninitialize();
	}

    return (hrStatus);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\writer\util.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Util.cpp | Implementation of utility functions
    @end

Author:

    Adi Oltean  [aoltean]  12/02/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     12/02/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Defines

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes

#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>
#include <comadmin.h>

#include "vs_assert.hxx"

// ATL
#include <atlconv.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include "vs_inc.hxx"

#include "comadmin.hxx"
#include "vsevent.h"
#include "writer.h"


LPWSTR QueryString(LPWSTR wszPrompt)
{
	static WCHAR wszBuffer[200];
	wprintf(wszPrompt);
	return _getws(wszBuffer);
}


INT QueryInt(LPWSTR wszPrompt)
{
	static WCHAR wszBuffer[20];
	wprintf(wszPrompt);
	_getws(wszBuffer);
	return _wtoi(wszBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\xmlint\xmlint.cpp ===
// xmlint.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

//====================================================================================
// Generic wild-card file finder that calls back to specified function with
// given void* arguments.

typedef HRESULT (*FILECALLBACK)(WCHAR* pszFile, void* arg);

WCHAR* WideString(const char* str)
{
    if (str == NULL)
        return NULL;
    WCHAR * result = new WCHAR[strlen(str) + 1];
    WCHAR* p = result;
    while (*str)
        *p++ = (WCHAR)*str++;
    *p = 0;
    return result;
}

int ProcessFiles(const char* pszFiles, FILECALLBACK pFunc, void* pArgs)
{
    HRESULT hr = S_OK;
    int i;

    WCHAR* wszArg = WideString(pszFiles);
    WIN32_FIND_DATA FindFileData;
    HANDLE handle = ::FindFirstFile(wszArg, &FindFileData);
    int failed = 0;

    if (handle == INVALID_HANDLE_VALUE)
    {
        // Then maybe it's a URL.
        hr = (*pFunc)(wszArg, pArgs);
        if (hr != 0) failed++;
        goto CleanUp;
    }
    for ( i = wcslen(wszArg)-1; i >= 0 && wszArg[i] != '\\'; i--)
    {
        wszArg[i] = 0;
    }
    
    while (handle != INVALID_HANDLE_VALUE)
    {
        ULONG len1 = wcslen(wszArg);
        ULONG len2 = wcslen(FindFileData.cFileName);
        WCHAR* buffer = new WCHAR[len1 + len2 + 1];
        if (buffer == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto CleanUp;
        }
        memcpy(buffer, wszArg, sizeof(WCHAR) * len1);
        memcpy(&buffer[len1], FindFileData.cFileName, sizeof(WCHAR) * len2);
        buffer[len1+len2] = '\0';
        
        hr = (*pFunc)(buffer, pArgs);

        if (hr != 0) failed++;

        delete[] buffer;

        if (! ::FindNextFile(handle, &FindFileData))
            break;
    }
    if (handle != INVALID_HANDLE_VALUE)
        ::FindClose(handle);

CleanUp:
    delete wszArg;

    return failed;
}

struct XMLArgs
{
public:
    XMLArgs()
    {
        pDOM = NULL;
        pIE4 = NULL;
    }

    IXMLDOMDocument* pDOM;
    IXMLDocument* pIE4;
};


void FormatError(BSTR bstrReason, BSTR bstrURL, BSTR bstrText, long lLine, long lPos)
{
    if (bstrReason)
    {
        printf("\t%S", bstrReason);
    }
    if (bstrURL)
    {
        printf("\tURL: %S\n", bstrURL);
    }

    if (lLine > 0 && bstrText)
    {
        printf("\tLine %5.5ld: ", lLine);

        long lLen = ::SysStringLen(bstrText);
        for (int i = 0; i < lLen; i++)
        {
            if (bstrText[i] == '\t')
                printf(" ");
            else
                printf("%C", bstrText[i]);
        }
        printf("\n");

        if (lPos > 0 || lLen > 0)
        {
            printf("\tPos  %5.5d: ", lPos);
            for (int i = 1; i < lPos; i++)
            {
                printf("-");
            }
            printf("^\n");
        }
    }
}

void PrintIE4Error(IXMLDocument* pDoc)
{
    IXMLError *pError = NULL ;
    XML_ERROR xmle = { 0, 0, 0, 0, 0, 0 };
    HRESULT hr = S_OK;

    hr = pDoc->QueryInterface(IID_IXMLError, (void **)&pError);
    if (FAILED(hr))
    {
        printf("Error getting error information\n");
        goto done;
    }

    hr = pError->GetErrorInfo(&xmle);
    if (FAILED(hr))
    {
        printf("Error getting error information\n");
        goto done;
    }
    
    FormatError(xmle._pszFound, NULL, xmle._pchBuf, xmle._nLine, xmle._ich);

done:
    SysFreeString(xmle._pszFound);
    SysFreeString(xmle._pszExpected);
    SysFreeString(xmle._pchBuf);
    if (pError) pError->Release();
}

void PrintDOMError(IXMLDOMDocument* pDoc)
{
    IXMLDOMParseError* pError;
    BSTR bstrReason = NULL;
    BSTR bstrText = NULL;
    BSTR bstrURL = NULL;
    long lPos,lLine = 0;
    HRESULT hr = S_OK;

    hr = pDoc->get_parseError( &pError);
    if (FAILED(hr))
    {
        printf("Error getting error information\n");
        goto done;
    }

    pError->get_reason(&bstrReason);
    pError->get_url(&bstrURL);
    pError->get_line(&lLine);
    pError->get_srcText(&bstrText);
    pError->get_linepos(&lPos);

    FormatError(bstrReason, bstrURL, bstrText, lLine, lPos);

done:
    SysFreeString( bstrReason);
    SysFreeString( bstrText);
    SysFreeString( bstrURL);
    if (pError) pError->Release();
}

HRESULT xmlint(WCHAR* pszFile, void* arg)
{
    HRESULT hr = S_OK;
    XMLArgs* pArgs = (XMLArgs*)arg;

    printf("%S\n", pszFile);

    if (pArgs->pIE4)
    {
        IXMLElement * root;
        hr = pArgs->pIE4->put_URL(pszFile);
        pArgs->pIE4->get_root(&root);
        if (FAILED(hr) || ! root)
        {
            PrintIE4Error(pArgs->pIE4);
        }
        if (root) root->Release();
    }
    else
    {
        VARIANT_BOOL bSuccess;
        VARIANT url;
        url.vt = VT_BSTR;
        V_BSTR(&url) = ::SysAllocString(pszFile);
        hr = pArgs->pDOM->load(url, &bSuccess);
        VariantClear(&url);
        if (FAILED(hr) || bSuccess == VARIANT_FALSE)
        {
            PrintDOMError(pArgs->pDOM);
        }
    }
    return hr;
}

void PrintUsage()
{
    printf("Usage: xmlint [options] filename(s)\n");
    printf("Checks well-formedness and validation constraints for one or more XML documents.\n");
    printf("File names can contain wild cards for validating multiple files (e.g. \"*.xml\")\n");
    printf("Example:\n");
    printf("\txmlint *.xml\n\n");
    printf("Checks that all files ending with .xml are valid xml files.\n\n");
    printf("Options:\n");
    printf("-w\tOnly perform well-formedness check (no DTD validation)\n");
    printf("-ie4\tRun in IE4 compatibility mode (instead of new DOM mode)\n");
}

int __cdecl main(int argc, char* argv[])
{
    int count = 0;
    XMLArgs args;
    bool fIE4 = false;
    bool fValidate = true;
    bool fPause = false;
    HRESULT hr;
    int rc = 0;

    CoInitialize(NULL);

    for (int i = 1; i < argc; i++)
    {
        char* pszArg = argv[i];
        if (*pszArg == '-')
        {
            if (strcmp(pszArg,"-ie4") == 0)
            {
                fIE4 = true;
            }
            else
            {
                switch (pszArg[1])
                {
                case 'w':
                    fValidate = false;
                    break;
                case 'p':
                    fPause = true;
                    break;
                default:
                    PrintUsage();
                    rc = 1;
                    goto Error;
                }
            }
        }
        else
        {
            count++;
        }
    }

    if (count == 0)
    {
        PrintUsage();
        rc = 1;
        goto Error;
    }

    if (fIE4)
    {
        hr = CoCreateInstance(CLSID_XMLDocument, NULL, CLSCTX_INPROC_SERVER,
                    IID_IXMLDocument, (void**)&(args.pIE4));
        if (FAILED(hr))
        {
            printf("Error co-creating IE4 XML Document");
            goto Error;
        }
    }
    else
    {
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
                      IID_IXMLDOMDocument, (void**)&(args.pDOM));
        if (FAILED(hr))
        {
            printf("Error co-creating XML DOM Document");
            goto Error;
        }

        args.pDOM->put_validateOnParse(fValidate ? VARIANT_TRUE : VARIANT_FALSE);
        args.pDOM->put_async(VARIANT_FALSE);
    }

    if (fPause)
    {
        printf("Press any key to continue...");
        getchar();
    }

    for (i = 1; i < argc; i++)
    {
        char* pszArg = argv[i];
        if (*pszArg != '-')
        {
            rc += ProcessFiles(pszArg, xmlint, &args);
        }
    }

Error:
    if (args.pDOM) args.pDOM->Release();
    if (args.pIE4) args.pIE4->Release();

    if (fPause)
    {
        printf("Press any key to continue...");
        getchar();
    }

    CoUninitialize();
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\xmlint\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__EA85751A_6947_11D2_9CC8_0060B0EC3D39__INCLUDED_)
#define AFX_STDAFX_H__EA85751A_6947_11D2_9CC8_0060B0EC3D39__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <stdio.h>
#import "msxml.dll" named_guids


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__EA85751A_6947_11D2_9CC8_0060B0EC3D39__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\tests\writer\writer.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Writer.cpp | Implementation of Writer
    @end

Author:

    Adi Oltean  [aoltean]  08/18/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     08/18/1999  Created
	aoltean		09/22/1999	Making console output clearer

--*/


/////////////////////////////////////////////////////////////////////////////
//  Defines

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes

#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>
#include <comadmin.h>

#include "vs_assert.hxx"

// ATL
#include <atlconv.h>
#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>

#include "vs_inc.hxx"

#include "vss.h"

#include "comadmin.hxx"
#include "vsevent.h"
#include "writer.h"



/////////////////////////////////////////////////////////////////////////////
// Constants

const CComBSTR g_bstrEventClassProgID     = L"VssEvent.VssEvent.1";
const CComBSTR g_bstrPublisherID          = L"VSS Publisher";             // Publisher ID

const CComBSTR g_bstrSubscriber1AppName   = L"Writer 1";                  // Subscriber 1 App Name
const CComBSTR g_bstrEventClsIID          = L"{2F7BF5AA-408A-4248-907A-2FD7D497A703}";
const CComBSTR g_bstrResolveResourceMethodName = L"ResolveResource";
const CComBSTR g_bstrPrepareForSnapshotMethodName = L"PrepareForSnapshot";
const CComBSTR g_bstrFreezeMethodName     = L"Freeze";
const CComBSTR g_bstrThawMethodName       = L"Thaw";
const CComBSTR g_bstrMeltMethodName       = L"Melt";


/////////////////////////////////////////////////////////////////////////////
// CVssWriter


STDMETHODIMP CVssWriter::PrepareForSnapshot(
    IN  BSTR    bstrSnapshotSetId,
    IN  BSTR    bstrVolumeNamesList,
    IN  VSS_FLUSH_TYPE		eFlushType,
	IN	BSTR	bstrFlushContext,
	IN	IDispatch* pDepGraphCallback,
	IN	IDispatch* pAsyncCallback	
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CVssWriter::PrepareForSnapshot" );

    wprintf(L"\nReceived Event: PrepareForSnapshot\nParameters:\n");
    wprintf(L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);
    wprintf(L"\tVolumeNamesList = %s\n", (LPWSTR)bstrVolumeNamesList);
    wprintf(L"\tFlush Type = %d\n", eFlushType);
    wprintf(L"\tFlush Context = %s\n", (LPWSTR)bstrFlushContext);

	if (pAsyncCallback)
	{
		// Release the previous interface.
		// A smarter writer will associate one Async interface with one Snapshot Set ID.
		m_pAsync = NULL;	

		// Get the new async interface
		ft.hr = pAsyncCallback->SafeQI(IVssAsync, &m_pAsync);
		if (ft.HrFailed())
			ft.Err( VSSDBG_VSSTEST, E_UNEXPECTED, L"Error calling QI 0x%08lx", ft.hr );
		BS_ASSERT(m_pAsync);
	}

	// Ask for cancel
	AskCancelDuringFreezeThaw(ft);

    return S_OK;
	UNREFERENCED_PARAMETER(pDepGraphCallback);
}


HRESULT CVssWriter::Freeze(
    IN  BSTR    bstrSnapshotSetId,
    IN  INT     nLevel
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CVssWriter::Freeze" );

    wprintf(L"\nReceived Event: Freeze\nParameters:\n");
    wprintf(L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);
    wprintf(L"\tLevel = %d\n", nLevel);

	// Ask for cancel
	AskCancelDuringFreezeThaw(ft);

    return S_OK;
}


HRESULT CVssWriter::Thaw(
    IN  BSTR    bstrSnapshotSetId
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"CVssWriter::Thaw" );

    wprintf(L"\nReceived Event: Thaw\nParameters:\n");
    wprintf(L"\tSnapshotSetId = %s\n", (LPWSTR)bstrSnapshotSetId);

	// Ask for cancel
	AskCancelDuringFreezeThaw(ft);

	// Release the Async interface
	m_pAsync = NULL;	
    return S_OK;
}


IUnknown* GetSubscriptionObject(CVssFunctionTracer& ft)
{
    IUnknown* pUnk;

    CComObject<CVssWriter>* pObj;
    ft.hr = CComObject<CVssWriter>::CreateInstance(&pObj);
    if (ft.HrFailed())
        ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in creating the subscription object 0x%08lx", ft.hr);
    pUnk = pObj->GetUnknown();
    pUnk->AddRef();
    return pUnk;
}


/////////////////////////////////////////////////////////////////////////////
// User interaction


void CVssWriter::AskCancelDuringFreezeThaw(
	IN	CVssFunctionTracer& ft
	)
{
	try
	{
		if(m_pAsync == NULL)
			return;

		WCHAR wchCancelPlease = (QueryString(L"Cancel? [y/N] "))[0];
		if (towupper(wchCancelPlease) == L'Y')
		{
			CComBSTR strReason = QueryString(L"Reason: ");

			ft.hr = m_pAsync->Cancel();
			if (ft.HrFailed())
				ft.Err( VSSDBG_VSSTEST, E_UNEXPECTED,
						L"Error calling AddDependency 0x%08lx", ft.hr );

			ft.Msg(L"HRESULT = 0x%08lx", ft.hr );
		}
	}
	VSS_STANDARD_CATCH(ft)
}


/////////////////////////////////////////////////////////////////////////////
//  WinMain

extern "C" int WINAPI _tWinMain(HINSTANCE /*hInstance*/,
    HINSTANCE /*hPrevInstance*/, LPTSTR /*lpCmdLine*/, int /*nShowCmd*/)
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"_tWinMain" );
    int nRet = 0;

    try
    {
        // Initialize COM library
        ft.hr = CoInitialize(NULL);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in initializing the COM library 0x%08lx", ft.hr);

        // Get the subscriber object
        IUnknown* pUnkSubscriber = GetSubscriptionObject(ft);

        // Initialize the catalog
        CVssCOMAdminCatalog catalog;
        ft.hr = catalog.Attach(g_bstrSubscriber1AppName);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in initializing the catalog object 0x%08lx", ft.hr);

        // Get the list of applications
        CVssCOMCatalogCollection transSubsList(VSS_COM_TRANSIENT_SUBSCRIPTIONS);
        ft.hr = transSubsList.Attach(catalog);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in initializing the subs collection object 0x%08lx", ft.hr);

        // Add our new transient subscription for PrepareForSnapshot
        CVssCOMTransientSubscription subscription;
        ft.hr = subscription.InsertInto(transSubsList);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in creating a new sub object 0x%08lx", ft.hr);

        subscription.m_bstrName = g_bstrSubscriber1AppName;
        subscription.m_bstrPublisherID = g_bstrPublisherID;
        subscription.m_bstrInterfaceID = g_bstrEventClsIID;
        subscription.m_varSubscriberInterface = CComVariant(pUnkSubscriber);
        subscription.m_bstrMethodName = g_bstrResolveResourceMethodName;

        ft.hr = subscription.InsertInto(transSubsList);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in creating a new sub object 0x%08lx", ft.hr);

        subscription.m_bstrName = g_bstrSubscriber1AppName;
        subscription.m_bstrPublisherID = g_bstrPublisherID;
        subscription.m_bstrInterfaceID = g_bstrEventClsIID;
        subscription.m_varSubscriberInterface = CComVariant(pUnkSubscriber);
        subscription.m_bstrMethodName = g_bstrPrepareForSnapshotMethodName;

        // Add our new transient subscription for Freeze
        ft.hr = subscription.InsertInto(transSubsList);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in creating a new sub object 0x%08lx", ft.hr);

        subscription.m_bstrName = g_bstrSubscriber1AppName;
        subscription.m_bstrPublisherID = g_bstrPublisherID;
        subscription.m_bstrInterfaceID = g_bstrEventClsIID;
        subscription.m_varSubscriberInterface = CComVariant(pUnkSubscriber);
        subscription.m_bstrMethodName = g_bstrFreezeMethodName;

        // Add our new transient subscription for Thaw
        ft.hr = subscription.InsertInto(transSubsList);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in creating a new sub object 0x%08lx", ft.hr);

        subscription.m_bstrName = g_bstrSubscriber1AppName;
        subscription.m_bstrPublisherID = g_bstrPublisherID;
        subscription.m_bstrInterfaceID = g_bstrEventClsIID;
        subscription.m_varSubscriberInterface = CComVariant(pUnkSubscriber);
        subscription.m_bstrMethodName = g_bstrThawMethodName;

        // Add our new transient subscription for Melt
        ft.hr = subscription.InsertInto(transSubsList);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in creating a new sub object 0x%08lx", ft.hr);

        subscription.m_bstrName = g_bstrSubscriber1AppName;
        subscription.m_bstrPublisherID = g_bstrPublisherID;
        subscription.m_bstrInterfaceID = g_bstrEventClsIID;
        subscription.m_varSubscriberInterface = CComVariant(pUnkSubscriber);
        subscription.m_bstrMethodName = g_bstrMeltMethodName;

        // Save changes
        ft.hr = transSubsList.SaveChanges();
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in commiting changes. hr = 0x%08lx", ft.hr);

        // message loop - need for STA server
        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);


        // Uninitialize COM library
        CoUninitialize();
    }
    VSS_STANDARD_CATCH(ft)

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\inc\ntrkcomm.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      NtRkComm.h
//
//  Implementation File:
//      NtRkComm.cpp
//
//  Description:
//      Definition of the CWbemServices, CImpersonatedProvider and 
//      CInstanceMgr class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once
#pragma warning( disable : 4100 )

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include <wbemprov.h>
#include <objbase.h>


typedef LPVOID * PPVOID;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWbemServices
//
//  Description:
//      Wraps for IWbemServices. security impersonation is implemented here
//
//--
//////////////////////////////////////////////////////////////////////////////
class CWbemServices
{
protected:
    IWbemServices * m_pWbemServices;

public:
    CWbemServices() : m_pWbemServices( NULL ) { };
    CWbemServices( IWbemServices * );
    virtual ~CWbemServices( void );

    HRESULT STDMETHODCALLTYPE GetObject(
        BSTR                bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject ** ppObjectInout,
        IWbemCallResult **  ppCallResultInout
        );

    HRESULT STDMETHODCALLTYPE PutClass(
        IWbemClassObject *  pObjectIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        );

    HRESULT STDMETHODCALLTYPE DeleteClass(
        BSTR                bstrClassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        );

    HRESULT STDMETHODCALLTYPE CreateClassEnum(
        BSTR                    bstrSuperclassIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        );

    HRESULT STDMETHODCALLTYPE PutInstance(
        IWbemClassObject *  pInstIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        );

    HRESULT STDMETHODCALLTYPE DeleteInstance(
        BSTR                bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        );

    HRESULT STDMETHODCALLTYPE CreateInstanceEnum(
        BSTR                    bstrClassIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        );

    HRESULT STDMETHODCALLTYPE ExecQuery(
        BSTR                    bstrQueryLanguageIn,
        BSTR                    bstrQueryIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        );

    HRESULT STDMETHODCALLTYPE ExecNotificationQuery(
        BSTR                    bstrQueryLanguageIn,
        BSTR                    bstrQueryIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        );

    HRESULT STDMETHODCALLTYPE ExecMethod(
        BSTR                bstrObjectPathIn,
        BSTR                bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemClassObject ** ppOurParamsOut,
        IWbemCallResult **  ppCallResultOut
        );
    HRESULT STDMETHODCALLTYPE ExecMethodAsync(
        BSTR                bstrObjectPathIn,
        BSTR                bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemObjectSink *   pHandlerIn
        );
    IWbemServices ** operator & ()
    {
        return & m_pWbemServices ;
    }
    operator IWbemServices * ()
    {
        return m_pWbemServices;
    }
    CWbemServices & operator = ( CWbemServices * );
}; //*** class CWbemServices

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CImpersonatedProvider
//
//  Description:
//      a middle layer between IWbemservices and actual provider. It takes
//      care of security impersonation
//
//--
//////////////////////////////////////////////////////////////////////////////
class CImpersonatedProvider
    : public IWbemServices
    , public IWbemProviderInit
{
protected:
    ULONG               m_cRef;         //Object reference count
    CWbemServices *     m_pNamespace;

public:
    CImpersonatedProvider(
        BSTR            bstrObjectPathIn    = NULL,
        BSTR            bstrUserIn          = NULL,
        BSTR            bstrPasswordIn      = NULL,
        IWbemContext *  pCtxIn              = NULL
        );
    virtual ~CImpersonatedProvider( void );

    //Non-delegating object IUnknown

    STDMETHODIMP            QueryInterface( REFIID riid, PPVOID ppv );
    STDMETHODIMP_( ULONG )  AddRef( void );
    STDMETHODIMP_( ULONG )  Release( void );

            //IWbemProviderInit

    HRESULT STDMETHODCALLTYPE Initialize(
         LPWSTR                     pszUserIn,
         LONG                       lFlagsIn,
         LPWSTR                     pszNamespaceIn,
         LPWSTR                     pszLocaleIn,
         IWbemServices *            pNamespaceIn,
         IWbemContext *             pCtxIn,
         IWbemProviderInitSink *    pInitSinkIn
         );

     //IWbemServices  

    HRESULT STDMETHODCALLTYPE OpenNamespace(
        const BSTR          bstrNamespaceIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemServices **    ppWorkingNamespaceInout,
        IWbemCallResult **  ppResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE CancelAsyncCall(
        IWbemObjectSink  *  pSinkIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE QueryObjectSink(
        long                lFlagsIn,
        IWbemObjectSink **  ppResponseHandlerOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE GetObject(
        const BSTR          bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject ** ppObjectInout,
        IWbemCallResult **  ppCallResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE GetObjectAsync(
        const BSTR          bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        );

    HRESULT STDMETHODCALLTYPE PutClass(
        IWbemClassObject *  pObjectIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE PutClassAsync(
        IWbemClassObject *  pObjectIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DeleteClass(
        const BSTR          bstrClassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DeleteClassAsync(
        const BSTR          bstrClassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE CreateClassEnum(
        const BSTR              bstrSuperclassIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(
        const BSTR          bstrSuperclassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE PutInstance(
        IWbemClassObject *  pInstIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE PutInstanceAsync(
        IWbemClassObject *  pInstIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        );

    HRESULT STDMETHODCALLTYPE DeleteInstance(
        const BSTR          bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
        const BSTR          bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        );

    HRESULT STDMETHODCALLTYPE CreateInstanceEnum(
        const BSTR               bstrClassIn,
        long                     lFlagsIn,
        IWbemContext *           pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync(
        const BSTR          bstrClassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        );

    HRESULT STDMETHODCALLTYPE ExecQuery(
        const BSTR              bstrQueryLanguageIn,
        const BSTR              bstrQueryIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecQueryAsync(
        const BSTR           bstrQueryLanguageIn,
        const BSTR           bstrQueryIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pResponseHandlerIn
        );

    HRESULT STDMETHODCALLTYPE ExecNotificationQuery(
        const BSTR              bstrQueryLanguageIn,
        const BSTR              bstrQueryIn,
        long                    lFlagsIn,
        IWbemContext*           pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync(
        const BSTR           bstrQueryLanguageIn,
        const BSTR           bstrQueryIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pResponseHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecMethod(
        const BSTR          bstrObjectPathIn,
        const BSTR          bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemClassObject ** ppOurParamsOut,
        IWbemCallResult **  ppCallResultOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecMethodAsync(
        const BSTR          bstrObjectPathIn,
        const BSTR          bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemObjectSink *   pResponseHandlerIn
        );

protected:
    virtual HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync(
        BSTR                bstrRefStrIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync(
        BSTR                bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
        BSTR                bstrObjectPathIn,
        BSTR                bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoExecQueryAsync(
        BSTR                bstrQueryLanguageIn,
        BSTR                bstrQueryIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;
    virtual HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
        BSTR                    bstrObjectPathIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IWbemObjectSink FAR *   pHandlerIn
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoPutInstanceAsync(
        IWbemClassObject *  pInstIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

}; //*** class CImpersonatedProvider

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWbemInstanceMgr
//
//  Description:
//      Manage WMI instance, allow block indicate
//
//--
//////////////////////////////////////////////////////////////////////////////
class CWbemInstanceMgr
{
protected:
    IWbemObjectSink *   m_pSink;
    IWbemClassObject ** m_ppInst;
    DWORD               m_dwThreshHold;
    DWORD               m_dwIndex;

public:

    CWbemInstanceMgr(
        IWbemObjectSink *   pHandlerIn,
        DWORD               dwSizeIn = 50
        );
    
    virtual ~CWbemInstanceMgr( void );

    void Indicate(
        IN IWbemClassObject * pInst
        );

    void SetStatus(
        LONG                lFlagsIn,
        HRESULT             hrIn,
        BSTR                bstrParamIn,
        IWbemClassObject *  pObjParamIn
        );

}; //*** class CWbemInstanceMgr
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\provider\bsconcur.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bsconcur.cxx

Abstract:

    Implementation of CBsXXXX classes that wrap Win32 concurrency controls.

Author:

    Stefan R. Steiner   [SSteiner]      11-Apr-1998

Revision History:

--*/

#include <windows.h>
#include "bsconcur.hxx"

//////////////////////////////////////////////////////////////////////
// CBsAutoLock class implementation
//////////////////////////////////////////////////////////////////////

CBsAutoLock::~CBsAutoLock()
{
    BOOL bStatus = TRUE;

    switch( m_type ) {
    case BS_AUTO_MUTEX_HANDLE: 
        bStatus = ::ReleaseMutex( m_hMutexHandle );
        break;
    case BS_AUTO_CRIT_SEC:
        ::LeaveCriticalSection( m_pCritSec );
        break;
    case BS_AUTO_CRIT_SEC_CLASS:
        m_pcCritSec->Leave();
        break;
    }

    if ( bStatus == FALSE ) {
        throw( ::GetLastError() );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\inc\common.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Common.h
//
//  Description:
//      Definition of common type, constant and header files.
//
//  Author:
//        Henry Wang (HenryWa)    24-AUG-1999
//        MSP Prabu  (mprabu)     04-Dec-2000
//        Jim Benton (jbenton)    15-Oct-2001
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once
#pragma warning( disable : 4786 )

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

using namespace std;

class CProvBase;
class CObjPath;
class CWbemClassObject;

extern long            g_cObj;
extern long            g_cLock;
extern HMODULE     g_hModule;

typedef LPVOID * PPVOID;

typedef CProvBase * (__stdcall * FPNEW)(
    IN LPCWSTR          pwszName,
    IN CWbemServices *  pNamespace
    );

void CreateClass(
    IN const WCHAR *           pwszClassName,
    IN CWbemServices *         pNamespace,
    IN OUT auto_ptr<CProvBase>&    rNewClass
    );

_bstr_t EncodeQuotes(IN WCHAR * wszString);

BOOL MapVssErrorToMsg(
    IN HRESULT hr,
    OUT LONG *plMsgNum
    ) throw( HRESULT );

LPWSTR GetMsg(
    IN  LONG msgId,
    ...
    );

#define GUID_PRINTF_ARG( X )                                \
    (X).Data1,                                              \
    (X).Data2,                                              \
    (X).Data3,                                              \
    (X).Data4[0], (X).Data4[1], (X).Data4[2], (X).Data4[3], \
    (X).Data4[4], (X).Data4[5], (X).Data4[6], (X).Data4[7]

#define IF_WSTR_NULL_THROW( XWSTR, XHR, XMSG ) \
{ if ((WCHAR*)XWSTR == NULL || ((WCHAR*)XWSTR)[0] == L'\0') \
    { ft.hr = XHR;  ft.Throw(VSSDBG_VSSADMIN, ft.hr, XMSG); } }

#define IF_PROP_NULL_THROW( XOBJ, XPROP, XHR, XMSG ) \
{ if (XOBJ.IsPropertyNull(XPROP)) \
    { ft.hr = XHR;  ft.Throw(VSSDBG_VSSADMIN, ft.hr, XMSG); } }

WCHAR* GuidToString(GUID guid);

const int g_cchGUID                                         = 48;
const int g_cchWBEM_MAX_OBJPATH                = 520;
const int g_cchWBEM_DATETIME_FORMAT        = 26;
const int g_cchMAX_I64DEC_STRING                 = 22;

//
// wbem
//
extern const WCHAR * const PVD_WBEM_PROVIDERNAME;
extern const WCHAR * const PVD_WBEM_EXTENDEDSTATUS;
extern const WCHAR * const PVD_WBEM_DESCRIPTION;
extern const WCHAR * const PVD_WBEM_STATUSCODE;
extern const WCHAR * const PVD_WBEM_STATUS;
extern const WCHAR * const PVD_WBEM_CLASS;
extern const WCHAR * const PVD_WBEM_RELPATH;
extern const WCHAR * const PVD_WBEM_PROP_ANTECEDENT;
extern const WCHAR * const PVD_WBEM_PROP_DEPENDENT;
extern const WCHAR * const PVD_WBEM_PROP_ELEMENT;
extern const WCHAR * const PVD_WBEM_PROP_SETTING;
extern const WCHAR * const PVD_WBEM_PROP_DEVICEID;
extern const WCHAR * const PVD_WBEM_PROP_RETURNVALUE;
extern const WCHAR * const PVD_WBEM_PROP_PROVIDERNAME;
extern const WCHAR * const PVD_WBEM_QUA_DYNAMIC;
extern const WCHAR * const PVD_WBEM_QUA_CIMTYPE;

//
// Constants used in partial value maps for localization
//
extern const WCHAR * const PVDR_CONS_UNAVAILABLE;
extern const WCHAR * const PVDR_CONS_ENABLED;
extern const WCHAR * const PVDR_CONS_DISABLED;


class CClassData
{
public:
    const WCHAR * wszClassName;
    FPNEW pfConstruct;
    const char * szType;

}; // *** class CClassData

class CClassCreator
{
public:
    CClassCreator( void )
        : m_pfnConstructor( NULL )
        , m_pbstrClassName( L"" )
        { };
    CClassCreator(
        IN FPNEW           pfn,
        IN const WCHAR *   pwszClassName
        )
        : m_pfnConstructor( pfn )
        , m_pbstrClassName( pwszClassName )
        { };
    FPNEW           m_pfnConstructor;
    _bstr_t         m_pbstrClassName;

}; //*** class CClassCreator

template< class _Ty >
struct strLessThan : binary_function< _Ty, _Ty, bool >
{
    bool operator()( const _Ty& _X, const _Ty& _Y ) const
    {
        return ( _wcsicmp( _X, _Y ) < 0 );
    }

}; //*** struct strLessThan

typedef map< _bstr_t, CClassCreator, strLessThan< _bstr_t > > ClassMap;
typedef map< _bstr_t, _bstr_t, strLessThan< _bstr_t > > TypeNameToClass;
extern TypeNameToClass  g_TypeNameToClass;
extern ClassMap         g_ClassMap;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\inc\provbase.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ProvBase.h
//
//  Implementation File:
//      ProvBase.cpp
//
//  Description:
//      Definition of the CProvBase class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//      MSP Prabu  (mprabu)     06-Jan-2001
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CProvBase;

//////////////////////////////////////////////////////////////////////////////
//  External Declarations
//////////////////////////////////////////////////////////////////////////////

/* main interface class, this class defines all operations can be performed
   on this provider
*/
//class CSqlEval;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProvBase
//
//  Description:
//  interface class defines all operations can be performed
//
//--
//////////////////////////////////////////////////////////////////////////////
class CProvBase
{
public:
    virtual HRESULT EnumInstance(
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

    virtual HRESULT GetObject(
        CObjPath &          rObjPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn 
        ) = 0;

    virtual HRESULT ExecuteMethod(
        BSTR                bstrObjPathIn,
        WCHAR *             pwszMethodNameIn,
        long                lFlagIn,
        IWbemClassObject *  pParamsIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

    virtual HRESULT PutInstance( 
        CWbemClassObject &  rInstToPutIn,
        long                lFlagIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;
    
    virtual HRESULT DeleteInstance(
        CObjPath &          rObjPathIn,
        long                lFlagIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;
    
    CProvBase(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

    virtual  ~CProvBase()
    {
        if ( m_pClass != NULL )
        {
            m_pClass->Release();
        }

    }

protected:
    CWbemServices *     m_pNamespace;
    IWbemClassObject *  m_pClass;
    _bstr_t             m_bstrClassName;

}; //*** class CProvBase
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\inc\provfactory.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ProvFactory.h
//
//  Implementation File:
//      ProvFactory.cpp
//
//  Description:
//      Definition of the CProvFactory class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

typedef HRESULT ( * PFNCREATEINSTANCE )(
    IUnknown *,
    VOID **
    );

struct FactoryData
{
    const CLSID *       m_pCLSID;
    PFNCREATEINSTANCE   pFnCreateInstance;
    LPCWSTR             m_pwszRegistryName;

}; //*** struct FactoryData

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProvFactory
//
//  Description:
//      Handle class creation
//
//--
/////////////////////////////////////////////////////////////////////////////
class CProvFactory
    : public IClassFactory
{
protected:
    ULONG           m_cRef;
    FactoryData *   m_pFactoryData;

public:
    CProvFactory( FactoryData *   pFactoryDataIn )
        : m_pFactoryData( pFactoryDataIn )
        , m_cRef( 0 )
    {
    }

    virtual ~CProvFactory( void )
    {
    }

    STDMETHODIMP            QueryInterface( REFIID riidIn, PPVOID ppvOut );
    STDMETHODIMP_( ULONG )  AddRef( void );
    STDMETHODIMP_( ULONG )  Release( void );

    //IClassFactory members
    STDMETHODIMP CreateInstance(
        LPUNKNOWN   pUnknownOuterIn,
        REFIID      riidIn,
        PPVOID      ppvObjOut
        );
    STDMETHODIMP LockServer( BOOL fLockIn );

}; //*** class CProvFactory
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\provider\assrt.cxx ===
/*++

Copyright (c) 200  Microsoft Corporation

Module Name:

    assrt.cxx

Abstract:
    assertion code used by BS_ASSERT

Author:


Revision History:
    Name        Date        Comments
    brianb        04/19/2000    created
    aoltean     06/20/2000  Adding VssSetDebugReport

--*/


extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <stdio.h>

#undef ASSERT

#include "vs_assert.hxx"
#include "vs_trace.hxx"
//#include "vssmsg.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "TRCASRTC"
//
////////////////////////////////////////////////////////////////////////


// No MP protection...
static LONG g_lVssDebugReportFlags = VSS_DBG_TO_DEBUG_CONSOLE | VSS_DBG_MESSAGE_BOX;

const CHAR x_szEventLogVssSourceName[] = "VSS";


VOID
AssertFail
    (
    IN LPCSTR FileName,
    IN UINT LineNumber,
    IN LPCSTR Condition
    )
    {
    int i;
    CHAR Title[4096];
    CHAR Msg[4096];

    DWORD dwCurrentProcessId = GetCurrentProcessId();
    DWORD dwCurrentThreadId = GetCurrentThreadId();
    
    if (g_lVssDebugReportFlags & VSS_DBG_TO_DEBUG_CONSOLE) 
        {
        sprintf(
            Msg,
            "VSS(PID:%ld,TID:%ld): %s(%d): *** Assertion failure  *** %s\n",
            dwCurrentProcessId,
            dwCurrentThreadId,
            FileName,
            LineNumber,
            Condition
            );


        ::OutputDebugStringA(Msg);
/*
        ::DbgPrintEx(
            DPFLTR_VSS_ID,
            1,
            Msg
            );
 */
        }

    if (g_lVssDebugReportFlags & VSS_DBG_MESSAGE_BOX) 
        {
        LPSTR szCommandLine = GetCommandLineA();

        //
        // Print the assertion and the command line
        //
        sprintf(
            Msg,
            "Assertion failure: %s\nFile: %s\nLine: %u\nCommand: %s\nProcess ID: %ld\nThread ID: %ld",
            Condition,
            FileName,
            LineNumber,
            szCommandLine,
            dwCurrentProcessId,
            dwCurrentThreadId
            );

#ifdef LOG_ERROR
        // Get a handle to use with ReportEvent()
        HANDLE hEventSource = ::RegisterEventSourceA(
            NULL,                           //  IN LPCWSTR lpUNCServerName,
            x_szEventLogVssSourceName       //  IN LPCWSTR lpSourceName
            );
        if (hEventSource)
        {
            LPCSTR ppszStringTable[1];
            ppszStringTable[0] = const_cast<LPCSTR>(Msg);
            
            // Write to event log. Ignore return code.
            ::ReportEventA(
                hEventSource,                           //  IN HANDLE     hEventLog,
                EVENTLOG_ERROR_TYPE,                    //  IN WORD       wType,
                0,                                      //  IN WORD       wCategory,
                VSS_ERROR_ASSERT,                       //  IN DWORD      dwEventID,
                NULL,                                   //  IN PSID       lpUserSid,
                1,                                      //  IN WORD       wNumStrings,
                0,                                      //  IN DWORD      dwDataSize,
                ppszStringTable,                        //  IN LPCWSTR   *lpStrings,
                NULL                                    //  IN LPVOID     lpRawData
                );

            // Close the handle to the event log
            ::DeregisterEventSource( hEventSource );
        }
#endif

        //
        // Use dll name as caption
        //
        sprintf(
            Title,
            "File Services WMI Provider (PID:%ld,TID:%ld)",
            dwCurrentProcessId,
            dwCurrentThreadId
            );

        //
        // Print the assertion and the command line
        //
        sprintf(
            Msg,
            "Assertion failure at line %u in file %s: %s\n\nCommand line: %s\n\nHit Cancel to break into the debugger.",
            LineNumber,
            FileName,
            Condition,
            szCommandLine
            );

        i = MessageBoxA
                (
                NULL,
                Msg,
                Title,
                MB_SYSTEMMODAL | MB_ICONSTOP | MB_OKCANCEL | MB_SERVICE_NOTIFICATION
                );

        if(i == IDCANCEL)
            DebugBreak();
        }
    }

void VssSetDebugReport( LONG lDebugReportFlags )
{
    g_lVssDebugReportFlags = lDebugReportFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\mofs\makefile.inc ===
$(O)\vds.mof $(O)\vds.mfl: vds.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\vdsTmp.mof -MFL:$(O)\vdsTmp.mfl vds.mof
    copy copyright.mof+$(O)\vdsTmp.mof+$(O)\vdsTmp.mfl $(O)\vds.mof
    copy copyright.mof+$(O)\vdsTmp.mfl $(O)\vds.mfl

$(O)\vss.mof $(O)\vss.mfl: vss.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\vssTmp.mof -MFL:$(O)\vssTmp.mfl vss.mof
    copy copyright.mof+$(O)\vssTmp.mof+$(O)\vssTmp.mfl $(O)\vss.mof
    copy copyright.mof+$(O)\vssTmp.mfl $(O)\vss.mfl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\inc\objectpath.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ObjectPath.h
//
//  Implementation File:
//      ObjectPath.cpp
//
//  Description:
//      Definition of the CObjpath class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//      MSP Prabu  (mprabu)     06-Jan-2001
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include <genlex.h>     //wbem sdk header
#include <objpath.h>    //wbem sdk header

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CObjPath;
class CProvException;
class CWbemClassObject;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CObjPath
//
//  Description:
//      CObjpath class make it easier to work with Object path string
//
//--
/////////////////////////////////////////////////////////////////////////////
class CObjPath
{
//
// constructor and desctructor
//
public:

    CObjPath( void );
    virtual ~CObjPath( void );

public:
    _bstr_t GetObjectPathString( void );

    BOOL AddProperty(
        LPCWSTR     pwszNameIn,
        LPCWSTR     pwszValueIn
        );
    
    BOOL AddProperty(
        LPCWSTR     pwszNameIn,
        VARIANT *   pvValueIn
        );
    
    BOOL SetClass(
        IN LPCWSTR pwszValue
        );
    
    _bstr_t GetStringValueForProperty(
        LPCWSTR pwszIn
        );

    long GetLongValueForProperty(
        LPCWSTR pwszIn
        );

    LONGLONG GetI64ValueForProperty(
        LPCWSTR pwszIn
        );

    _bstr_t GetClassName( void );
    
    BOOL Init(
        LPCWSTR     pwszPathIn
        );
    
protected:
    ParsedObjectPath *  m_parsedObj;

}; //*** class CObjPath

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProvException
//
//  Description:
//      Base exception class, declares common interface and member data
//      for all exception subclass
//  
//--
/////////////////////////////////////////////////////////////////////////////
class CProvException
{
public:
    CProvException(
        HRESULT hrIn
        )
        : m_hr( hrIn )
    {
    }

    CProvException(
        DWORD   nWin32ErrorIn
        )
        : m_hr( 0 )
    {
        m_hr = HRESULT_FROM_WIN32( nWin32ErrorIn );
    }

    virtual ~CProvException( void )
    {
    }

    CProvException(
        const CProvException & rhsIn
        )
        : m_hr( 0 )
    {
        m_bstrError = rhsIn.m_bstrError;
        m_bstrErrorHelp = rhsIn.m_bstrErrorHelp;
        m_hr = rhsIn.m_hr;
    }

    CProvException & operator=(
        const CProvException & rhsIn
        )
    {
        m_bstrError = rhsIn.m_bstrError;
        m_bstrErrorHelp = rhsIn.m_bstrErrorHelp;
        m_hr = rhsIn.m_hr;
        return *this;
    }

    LPCWSTR PwszErrorMessage( void ) const;

    BOOL BIsWmiError( void ) const
    {
        return HRESULT_FACILITY( m_hr ) == 4;
    }

    DWORD DwGetError( void ) const throw()
    {
        return HRESULT_CODE( m_hr );
    }

    HRESULT hrGetError( void ) const throw()
    {
        return m_hr;
    }

    void SetErrorHelpInfo( LPCWSTR pwsz )
    {
        m_bstrErrorHelp = pwsz;
    }

    LPCWSTR    PwszGetErrorHelpInfo( void )
    {
        return m_bstrErrorHelp;
    }
protected:
    mutable _bstr_t m_bstrError;
    mutable _bstr_t m_bstrErrorHelp;
    HRESULT         m_hr;

}; //*** class CProvException

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWbemClassObject
//
//  Description:
//      Wrap for IWbemClassObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class CWbemClassObject
{
protected:
    IWbemClassObject *  m_pClassObject;
    VARIANT             m_v;

public:
    CWbemClassObject( void );
    CWbemClassObject( IWbemClassObject * pInstIn );
    virtual ~CWbemClassObject( void );

    IWbemClassObject ** operator&( void )
    {
        return &m_pClassObject;
    }

    CWbemClassObject & operator=( IWbemClassObject * pInstIn )
    {
        if( pInstIn != NULL )
        {
            pInstIn->AddRef();
            if ( m_pClassObject != NULL )
            {
                m_pClassObject->Release();
            }
            m_pClassObject = pInstIn;
        }
        return *this;
    }

    CWbemClassObject & operator=( CWbemClassObject & rInstIn )
    {
        
        if ( m_pClassObject != NULL )
        {
            m_pClassObject->Release();
        }
        
        m_pClassObject = rInstIn.m_pClassObject;
        if ( m_pClassObject != NULL )
        {
            m_pClassObject->AddRef();
        }
        
        return *this;
    }

    HRESULT SetProperty(
        LPCSTR      pszValueIn,
        LPCWSTR     pwszPropNameIn
        );

    HRESULT SetProperty(
        DWORD       dwValueIn,
        LPCWSTR     pwszPropNameIn
        );

    HRESULT SetPropertyR64(
        double       dblValueIn,
        LPCWSTR     pwszPropNameIn
        );

    HRESULT SetPropertyI64(
        LONGLONG   llValueIn,
        LPCWSTR    pwszPropNameIn
        );

    HRESULT SetPropertyI64(
        ULONGLONG   llValueIn,
        LPCWSTR    pwszPropNameIn
        );

    HRESULT SetProperty(
        LPCWSTR     pwszValueIn,
        LPCWSTR     pwszPropNameIn
        );
    HRESULT SetProperty(
        IWbemClassObject * pWbemClassObjectIn,
        LPCWSTR     pwszPropNameIn
        );
    HRESULT SetProperty(
        DWORD       dwSizeIn,
        PBYTE       pByteIn,
        LPCWSTR     pwszPropNameIn
        );
    HRESULT SetProperty(
        DWORD       dwSizeIn,
        LPCWSTR     pwszMultiSzIn,
        LPCWSTR     pwszPropNameIn
        );

    HRESULT SetProperty(
        DWORD       dwSizeIn,
        BSTR *      pbstrIn,
        LPCWSTR     pwszPropNameIn
        );

    HRESULT GetProperty(
        DWORD *     pdwValueOut,
        LPCWSTR     pwszPropNameIn
        );
    HRESULT GetPropertyR64(
        double *     pdblValueOut,
        LPCWSTR     pwszPropNameIn
        );
    HRESULT GetPropertyI64(
        LONGLONG *  pllValueOut,
        LPCWSTR     pwszPropNameIn
        );
    HRESULT GetProperty(
        DWORD *     pdwSizeOut,
        PBYTE *     ppByteOut,
        LPCWSTR     pwszPropNameIn
        );
    HRESULT GetProperty(
        DWORD *     pdwSizeOut,
        _bstr_t **  ppbstrOut,
        LPCWSTR     pwszPropNameIn
        );
    HRESULT GetPropertyMultiSz(
        DWORD *     pdwSizeOut,
        LPWSTR *    ppwszMultiSzOut,
        LPCWSTR     pwszPropNameIn
        );
    HRESULT GetProperty(
        _bstr_t &   rBstrOut,
        LPCWSTR     pwszPropNameIn
    );

    HRESULT GetProperty(
        BOOL *      pfValueOut,
        LPCWSTR     pwszPropNameIn
        );

    HRESULT GetProperty(
        VARIANT *   pVariantOut,
        LPCWSTR     pwszPropNameIn
        );
    HRESULT GetProperty(
        CWbemClassObject & rWcoInout,
        LPCWSTR     pwszPropNameIn
        );

    HRESULT GetMethod(
        BSTR                bstrMethodNameIn,
        LONG                lFlagIn,
        IWbemClassObject ** ppINOut,
        IWbemClassObject ** ppOUTOut
        );
    HRESULT SpawnInstance(
        LONG                lFlagIn,
        IWbemClassObject ** ppNewOut
        );
    HRESULT SpawnDerivedClass(
        LONG                lFlagIn,
        IWbemClassObject ** ppNewOut
        );

    BOOL IsPropertyNull(
        LPCWSTR     pwszPropNameIn
        );

    IWbemClassObject * data( void )
    {
        return m_pClassObject;
    }

    IWbemClassObject ** dataPtr( void )
    {
        return & m_pClassObject;
    }

}; //*** class CWbemClassObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\provider\bsstring.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bsstring.cxx

Abstract:

    This module implements the CBsString class.  This class manages character
    arrays in a similar manner as the CString class in VC++.  In fact, this
    class is a copy of the CString class with the MFC specific stuff ripped
    out since LTS doesn't use MTF.

Author:

    Stefan R. Steiner   [SSteiner]      1-Mar-1998

Revision History:

    Stefan R. Steiner   [SSteiner]      10-Apr-2000
        Added fixed allocator code and resynced with MFC 6 SR-1 code
        
--*/

#include <windows.h>
#include "bsstring.hxx"
#include "malloc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

struct _BSAFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };
struct _BSAFX_FLOAT   { BYTE floatBits[sizeof(float)]; };

// #define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

TCHAR bsafxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int _bsafxInitData[] = { -1, 0, 0, 0 };
static CBsStringData* _bsafxDataNil = (CBsStringData*)&_bsafxInitData;
static LPCTSTR _bsafxPchNil = (LPCTSTR)(((BYTE*)&_bsafxInitData)+sizeof(CBsStringData));
// special function to make bsafxEmptyString work even during initialization
const CBsString& BSAFXAPI BsAfxGetEmptyString()
	{ return *(CBsString*)&_bsafxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CBsString::CBsString()
{
	Init();
}

CBsString::CBsString(const CBsString& stringSrc)
{
	ASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ASSERT(stringSrc.GetData() != _bsafxDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

CBsString::CBsString(GUID guid)
{
	Init();
	AllocBuffer(38);
    _stprintf( m_pchData, _T("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
               guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1], 
               guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], 
               guid.Data4[6], guid.Data4[7] );
}

#ifndef _DEBUG

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

#define ROUND(x,y) (((x)+(y-1))&~(y-1))
#define ROUND4(x) ROUND(x, 4)
static CBsFixedAlloc _bsafxAlloc8(ROUND4(9*sizeof(TCHAR)+sizeof(CBsStringData)), 1024);
static CBsFixedAlloc _bsafxAlloc16(ROUND4(17*sizeof(TCHAR)+sizeof(CBsStringData)), 512);
static CBsFixedAlloc _bsafxAlloc32(ROUND4(33*sizeof(TCHAR)+sizeof(CBsStringData)), 256);
static CBsFixedAlloc _bsafxAlloc64(ROUND4(65*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc128(ROUND4(129*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc256(ROUND4(257*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc512(ROUND4(513*sizeof(TCHAR)+sizeof(CBsStringData)));

#endif //!_DEBUG

void CBsString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
// Throws E_OUTOFMEMORY when out of memory
{
	ASSERT(nLen >= 0);
	ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CBsStringData* pData;	    
#ifndef _DEBUG
		if (nLen <= 8)
		{
			pData = (CBsStringData*)_bsafxAlloc8.Alloc();
			pData->nAllocLength = 8;
		} 
		else if (nLen <= 16)
		{
			pData = (CBsStringData*)_bsafxAlloc16.Alloc();
			pData->nAllocLength = 16;
		} 
		else if (nLen <= 32)
		{
			pData = (CBsStringData*)_bsafxAlloc32.Alloc();
			pData->nAllocLength = 32;
		} 
		else if (nLen <= 64)
		{
			pData = (CBsStringData*)_bsafxAlloc64.Alloc();
			pData->nAllocLength = 64;
		}
		else if (nLen <= 128)
		{
			pData = (CBsStringData*)_bsafxAlloc128.Alloc();
			pData->nAllocLength = 128;
		}
		else if (nLen <= 256)
		{
			pData = (CBsStringData*)_bsafxAlloc256.Alloc();
			pData->nAllocLength = 256;
		}
		else if (nLen <= 512)
		{
			pData = (CBsStringData*)_bsafxAlloc512.Alloc();
			pData->nAllocLength = 512;
		}
		else
#endif
		{
			pData = (CBsStringData*)
				new BYTE[sizeof(CBsStringData) + (nLen+1)*sizeof(TCHAR)];
			if ( pData == NULL )    // Prefix #118828
			    throw E_OUTOFMEMORY;
			pData->nAllocLength = nLen;
		}
		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		m_pchData = pData->data();
	}
}

void FASTCALL CBsString::FreeData(CBsStringData* pData)
{
#ifndef _DEBUG
	int nLen = pData->nAllocLength;
	if (nLen == 8)
		_bsafxAlloc8.Free(pData);
	else if (nLen == 16)
		_bsafxAlloc16.Free(pData);
	else if (nLen == 32)
		_bsafxAlloc32.Free(pData);
	else if (nLen == 64)
		_bsafxAlloc64.Free(pData);
	else if (nLen == 128)
		_bsafxAlloc128.Free(pData);
	else if (nLen == 256)
		_bsafxAlloc256.Free(pData);
	else  if (nLen == 512)
		_bsafxAlloc512.Free(pData);
	else
	{
		ASSERT(nLen > 512);
		delete[] (BYTE*)pData;
	}
#else
	delete[] (BYTE*)pData;
#endif
}

void CBsString::Release()
{
	if (GetData() != _bsafxDataNil)
	{
		ASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			FreeData(GetData());
		Init();
	}
}

void PASCAL CBsString::Release(CBsStringData* pData)
{
	if (pData != _bsafxDataNil)
	{
		ASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			FreeData(pData);
	}
}

void CBsString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &bsafxChNil;
	ASSERT(GetData()->nDataLength == 0);
	ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

void CBsString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CBsStringData* pData = GetData();
		Release();
		AllocBuffer(pData->nDataLength);
		memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ASSERT(GetData()->nRefs <= 1);
}

void CBsString::AllocBeforeWrite(int nLen)
{
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		AllocBuffer(nLen);
	}
	ASSERT(GetData()->nRefs <= 1);
}

CBsString::~CBsString()
//  free any attached data
{
	if (GetData() != _bsafxDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			FreeData(GetData());
	}
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CBsString::AllocCopy(CBsString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CBsString::CBsString(LPCTSTR lpsz)
{
	Init();
	int nLen = SafeStrlen(lpsz);
	if (nLen != 0)
	{
		AllocBuffer(nLen);
		memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CBsString::CBsString(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen);
		_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
}
#else //_UNICODE
CBsString::CBsString(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen*2);
		_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CBsString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CBsString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	AllocBeforeWrite(nSrcLen);
	memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
	GetData()->nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
}

const CBsString& CBsString::operator=(const CBsString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != _bsafxDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ASSERT(stringSrc.GetData() != _bsafxDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

const CBsString& CBsString::operator=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CBsString& CBsString::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	AllocBeforeWrite(nSrcLen);
	_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
	ReleaseBuffer();
	return *this;
}
#else //!_UNICODE
const CBsString& CBsString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	AllocBeforeWrite(nSrcLen*2);
	_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
	ReleaseBuffer();
	return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CBsString + CBsString
// and for ? = TCHAR, LPCTSTR
//          CBsString + ?
//          ? + CBsString

void CBsString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CBsString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		AllocBuffer(nNewLen);
		memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
		memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
	}
}

CBsString BSAFXAPI operator+(const CBsString& string1, const CBsString& string2)
{
	CBsString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

CBsString BSAFXAPI operator+(const CBsString& string, LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	CBsString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
		CBsString::SafeStrlen(lpsz), lpsz);
	return s;
}

CBsString BSAFXAPI operator+(LPCTSTR lpsz, const CBsString& string)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	CBsString s;
	s.ConcatCopy(CBsString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CBsString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CBsStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ASSERT(pOldData != NULL);
		CBsString::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

const CBsString& CBsString::operator+=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CBsString& CBsString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

const CBsString& CBsString::operator+=(const CBsString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CBsString::GetBuffer(int nMinBufLength)
{
	ASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CBsStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
		GetData()->nDataLength = nOldLen;
		CBsString::Release(pOldData);
	}
	ASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

void CBsString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

LPTSTR CBsString::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

void CBsString::FreeExtra()
{
	ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CBsStringData* pOldData = GetData();
		AllocBuffer(GetData()->nDataLength);
		memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
		ASSERT(m_pchData[GetData()->nDataLength] == '\0');
		CBsString::Release(pOldData);
	}
	ASSERT(GetData() != NULL);
}

LPTSTR CBsString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

void CBsString::UnlockBuffer()
{
	ASSERT(GetData()->nRefs == -1);
	if (GetData() != _bsafxDataNil)
		GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CBsString::Find(TCHAR ch) const
{
	return Find(ch, 0);
}

int CBsString::Find(TCHAR ch, int nStart) const
{
	int nLength = GetData()->nDataLength;
	if (nStart >= nLength)
		return -1;

	// find first single character
	LPTSTR lpsz = _tcschr(m_pchData + nStart, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CBsString::FindOneOf(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

void CBsString::MakeUpper()
{
	CopyBeforeWrite();
	_tcsupr(m_pchData);
}

void CBsString::MakeLower()
{
	CopyBeforeWrite();
	_tcslwr(m_pchData);
}

void CBsString::MakeReverse()
{
	CopyBeforeWrite();
	_tcsrev(m_pchData);
}

void CBsString::SetAt(int nIndex, TCHAR ch)
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CBsString::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
void CBsString::OemToAnsi()
{
	CopyBeforeWrite();
	::OemToAnsi(m_pchData, m_pchData);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CBsString conversion helpers (these use the current system locale)

int BSAFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, (INT)count, NULL, NULL);
	ASSERT(mbstr == NULL || result <= (int)count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

int BSAFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, (INT)count);
	ASSERT(wcstr == NULL || result <= (int)count);
	if (result > 0)
		wcstr[result-1] = 0;
	return result;
}

LPWSTR BSAFXAPI BsAfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	if (lpa == NULL)
		return NULL;
	ASSERT(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
	return lpw;
    UNREFERENCED_PARAMETER( nChars );
}

LPSTR BSAFXAPI BsAfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	if (lpw == NULL)
		return NULL;
	ASSERT(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
    UNREFERENCED_PARAMETER( nChars );
}


//
//  the following is from strex.cpp
//

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CBsString::CBsString(TCHAR ch, int nLength)
{
	Init();
	if (nLength >= 1)
	{
		AllocBuffer(nLength);
#ifdef _UNICODE
		for (int i = 0; i < nLength; i++)
			m_pchData[i] = ch;
#else
		memset(m_pchData, ch, nLength);
#endif
	}
}

CBsString::CBsString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
		ASSERT(BsAfxIsValidAddress(lpch, nLength, FALSE));
		AllocBuffer(nLength);
		memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CBsString::CBsString(LPCSTR lpsz, int nLength)
{
	Init();
	if (nLength != 0)
	{
		AllocBuffer(nLength);
		int n = ::MultiByteToWideChar(CP_ACP, 0, lpsz, nLength, m_pchData, nLength+1);
		ReleaseBuffer(n >= 0 ? n : -1);
	}
}
#else //_UNICODE
CBsString::CBsString(LPCWSTR lpsz, int nLength)
{
	Init();
	if (nLength != 0)
	{
		AllocBuffer(nLength*2);
		int n = ::WideCharToMultiByte(CP_ACP, 0, lpsz, nLength, m_pchData,
			(nLength*2)+1, NULL, NULL);
		ReleaseBuffer(n >= 0 ? n : -1);
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CBsString& CBsString::operator=(TCHAR ch)
{
	AssignCopy(1, &ch);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CBsString BSAFXAPI operator+(const CBsString& string1, TCHAR ch)
{
	CBsString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

CBsString BSAFXAPI operator+(TCHAR ch, const CBsString& string)
{
	CBsString s;
	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// Advanced manipulation

int CBsString::Delete(int nIndex, int nCount /* = 1 */)
{
	if (nIndex < 0)
		nIndex = 0;
	int nNewLength = GetData()->nDataLength;
	if (nCount > 0 && nIndex < nNewLength)
	{
		CopyBeforeWrite();
		int nBytesToCopy = nNewLength - (nIndex + nCount) + 1;

		memcpy(m_pchData + nIndex,
			m_pchData + nIndex + nCount, nBytesToCopy * sizeof(TCHAR));
		GetData()->nDataLength = nNewLength - nCount;
	}

	return nNewLength;
}

int CBsString::Insert(int nIndex, TCHAR ch)
{
	CopyBeforeWrite();

	if (nIndex < 0)
		nIndex = 0;

	int nNewLength = GetData()->nDataLength;
	if (nIndex > nNewLength)
		nIndex = nNewLength;
	nNewLength++;

	if (GetData()->nAllocLength < nNewLength)
	{
		CBsStringData* pOldData = GetData();
		LPTSTR pstr = m_pchData;
		AllocBuffer(nNewLength);
		memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(TCHAR));
		CBsString::Release(pOldData);
	}

	// move existing bytes down
	memcpy(m_pchData + nIndex + 1,
		m_pchData + nIndex, (nNewLength-nIndex)*sizeof(TCHAR));
	m_pchData[nIndex] = ch;
	GetData()->nDataLength = nNewLength;

	return nNewLength;
}

int CBsString::Insert(int nIndex, LPCTSTR pstr)
{
	if (nIndex < 0)
		nIndex = 0;

	int nInsertLength = SafeStrlen(pstr);
	int nNewLength = GetData()->nDataLength;
	if (nInsertLength > 0)
	{
		CopyBeforeWrite();
		if (nIndex > nNewLength)
			nIndex = nNewLength;
		nNewLength += nInsertLength;

		if (GetData()->nAllocLength < nNewLength)
		{
			CBsStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			AllocBuffer(nNewLength);
			memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(TCHAR));
			CBsString::Release(pOldData);
		}

		// move existing bytes down
		memcpy(m_pchData + nIndex + nInsertLength,
			m_pchData + nIndex,
			(nNewLength-nIndex-nInsertLength+1)*sizeof(TCHAR));
		memcpy(m_pchData + nIndex,
			pstr, nInsertLength*sizeof(TCHAR));
		GetData()->nDataLength = nNewLength;
	}

	return nNewLength;
}

int CBsString::Replace(TCHAR chOld, TCHAR chNew)
{
	int nCount = 0;

	// short-circuit the nop case
	if (chOld != chNew)
	{
		// otherwise modify each character that matches in the string
		CopyBeforeWrite();
		LPTSTR psz = m_pchData;
		LPTSTR pszEnd = psz + GetData()->nDataLength;
		while (psz < pszEnd)
		{
			// replace instances of the specified character only
			if (*psz == chOld)
			{
				*psz = chNew;
				nCount++;
			}
			psz = _tcsinc(psz);
		}
	}
	return nCount;
}

int CBsString::Replace(LPCTSTR lpszOld, LPCTSTR lpszNew)
{
	// can't have empty or NULL lpszOld

	int nSourceLen = SafeStrlen(lpszOld);
	if (nSourceLen == 0)
		return 0;
	int nReplacementLen = SafeStrlen(lpszNew);

	// loop once to figure out the size of the result string
	int nCount = 0;
	LPTSTR lpszStart = m_pchData;
	LPTSTR lpszEnd = m_pchData + GetData()->nDataLength;
	LPTSTR lpszTarget;
	while (lpszStart < lpszEnd)
	{
		while ((lpszTarget = _tcsstr(lpszStart, lpszOld)) != NULL)
		{
			nCount++;
			lpszStart = lpszTarget + nSourceLen;
		}
		lpszStart += lstrlen(lpszStart) + 1;
	}

	// if any changes were made, make them
	if (nCount > 0)
	{
		CopyBeforeWrite();

		// if the buffer is too small, just
		//   allocate a new buffer (slow but sure)
		int nOldLength = GetData()->nDataLength;
		int nNewLength =  nOldLength + (nReplacementLen-nSourceLen)*nCount;
		if (GetData()->nAllocLength < nNewLength || GetData()->nRefs > 1)
		{
			CBsStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			AllocBuffer(nNewLength);
			memcpy(m_pchData, pstr, pOldData->nDataLength*sizeof(TCHAR));
			CBsString::Release(pOldData);
		}
		// else, we just do it in-place
		lpszStart = m_pchData;
		lpszEnd = m_pchData + GetData()->nDataLength;

		// loop again to actually do the work
		while (lpszStart < lpszEnd)
		{
			while ( (lpszTarget = _tcsstr(lpszStart, lpszOld)) != NULL)
			{
				int nBalance = nOldLength - (int)(lpszTarget - m_pchData + nSourceLen);
				memmove(lpszTarget + nReplacementLen, lpszTarget + nSourceLen,
					nBalance * sizeof(TCHAR));
				memcpy(lpszTarget, lpszNew, nReplacementLen*sizeof(TCHAR));
				lpszStart = lpszTarget + nReplacementLen;
				lpszStart[nBalance] = '\0';
				nOldLength += (nReplacementLen - nSourceLen);
			}
			lpszStart += lstrlen(lpszStart) + 1;
		}
		ASSERT(m_pchData[nNewLength] == '\0');
		GetData()->nDataLength = nNewLength;
	}

	return nCount;
}

int CBsString::Remove(TCHAR chRemove)
{
	CopyBeforeWrite();

	LPTSTR pstrSource = m_pchData;
	LPTSTR pstrDest = m_pchData;
	LPTSTR pstrEnd = m_pchData + GetData()->nDataLength;

	while (pstrSource < pstrEnd)
	{
		if (*pstrSource != chRemove)
		{
			*pstrDest = *pstrSource;
			pstrDest = _tcsinc(pstrDest);
		}
		pstrSource = _tcsinc(pstrSource);
	}
	*pstrDest = '\0';
	int nCount = ( int )( pstrSource - pstrDest );
	GetData()->nDataLength -= nCount;

	return nCount;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CBsString CBsString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CBsString CBsString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	ASSERT(nFirst >= 0);
	ASSERT(nFirst + nCount <= GetData()->nDataLength);

	// optimize case of returning entire string
	if (nFirst == 0 && nFirst + nCount == GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

CBsString CBsString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	if (nCount >= GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

CBsString CBsString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	if (nCount >= GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
CBsString CBsString::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	return Left((INT)_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CBsString CBsString::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	return Left((INT)_tcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CBsString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CBsString::Find(LPCTSTR lpszSub) const
{
	return Find(lpszSub, 0);
}

int CBsString::Find(LPCTSTR lpszSub, int nStart) const
{
	ASSERT(BsAfxIsValidString(lpszSub));

	int nLength = GetData()->nDataLength;
	if (nStart > nLength)
		return -1;

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData + nStart, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// CBsString formatting

#define TCHAR_ARG   TCHAR
#define WCHAR_ARG   WCHAR
#define CHAR_ARG    char

#ifdef _X86_
	#define DOUBLE_ARG  _BSAFX_DOUBLE
#else
	#define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000
#define FORCE_INT64		0x40000

void CBsString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	ASSERT(BsAfxIsValidString(lpszFormat));

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	int nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
		{
			nMaxLen += (INT)_tclen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
				*lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
				;
		}
		ASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = _tcsinc(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = _tcsinc(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
					;
			}
			ASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		if (_tcsncmp(lpsz, _T("I64"), 3) == 0)
		{
			lpsz += 3;
			nModifier = FORCE_INT64;
#if !defined(_X86_) && !defined(_ALPHA_)
			// __int64 is only available on X86 and ALPHA platforms
			ASSERT(FALSE);
#endif
		}
		else
		{
			switch (*lpsz)
			{
			// modifiers that affect size
			case 'h':
				nModifier = FORCE_ANSI;
				lpsz = _tcsinc(lpsz);
				break;
			case 'l':
				nModifier = FORCE_UNICODE;
				lpsz = _tcsinc(lpsz);
				break;

			// modifiers that do not affect size
			case 'F':
			case 'N':
			case 'L':
				lpsz = _tcsinc(lpsz);
				break;
			}
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR_ARG);
			break;
		case 'c'|FORCE_ANSI:
		case 'C'|FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, CHAR_ARG);
			break;
		case 'c'|FORCE_UNICODE:
		case 'C'|FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR_ARG);
			break;

		// strings
		case 's':
			{
				LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6;  // "(null)"
				else
				{
				   nItemLen = lstrlen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;

		case 'S':
			{
#ifndef _UNICODE
				LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6;  // "(null)"
				else
				{
				   nItemLen = wcslen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
#else
				LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = lstrlenA(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
#endif
			}
			break;

		case 's'|FORCE_ANSI:
		case 'S'|FORCE_ANSI:
			{
				LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = lstrlenA(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;

		case 's'|FORCE_UNICODE:
		case 'S'|FORCE_UNICODE:
			{
				LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = (INT)wcslen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
			nItemLen = max(nItemLen, nWidth);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				if (nModifier & FORCE_INT64)
					va_arg(argList, __int64);
				else
					va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'e':
			case 'g':
			case 'G':
				va_arg(argList, DOUBLE_ARG);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'f':
				{
					double f;
					LPTSTR pszTemp;

					// 312 == strlen("-1+(309 zeroes).")
					// 309 zeroes == max precision of a double
					// 6 == adjustment in case precision is not specified,
					//   which means that the precision defaults to 6
					pszTemp = (LPTSTR)_alloca(max(nWidth, 312+nPrecision+6));

					f = va_arg(argList, double);
					_stprintf( pszTemp, _T( "%*.*f" ), nWidth, nPrecision+6, f );
					nItemLen = (int)_tcslen(pszTemp);
				}
				break;

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

    //  Use the new _vsctprintf() CRT function to get the length of the formatted string
    //  INT nMaxLen = _vsctprintf( lpszFormat, argList );
	GetBuffer( nMaxLen );
	INT i = _vstprintf( m_pchData, lpszFormat, argListSave );
	ASSERT( i <= nMaxLen && i != -1 );
	ReleaseBuffer();

	va_end(argListSave);

	UNREFERENCED_PARAMETER( i );
}

// formatting (using wsprintf style formatting)
void BSAFX_CDECL CBsString::Format(LPCTSTR lpszFormat, ...)
{
	ASSERT(BsAfxIsValidString(lpszFormat));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

void CBsString::TrimRight(LPCTSTR lpszTargetList)
{
	// find beginning of trailing matches
	// by starting at beginning (DBCS aware)

	CopyBeforeWrite();
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;

	while (*lpsz != '\0')
	{
		if (_tcschr(lpszTargetList, *lpsz) != NULL)
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at left-most matching character
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}

void CBsString::TrimRight(TCHAR chTarget)
{
	// find beginning of trailing matches
	// by starting at beginning (DBCS aware)

	CopyBeforeWrite();
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;

	while (*lpsz != '\0')
	{
		if (*lpsz == chTarget)
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at left-most matching character
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}


void CBsString::TrimRight()
{
	// find beginning of trailing spaces by starting at beginning (DBCS aware)

	CopyBeforeWrite();
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	
	while (*lpsz != '\0')
	{
		if (_istspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}

void CBsString::TrimLeft(LPCTSTR lpszTargets)
{
	// if we're not trimming anything, we're not doing any work
	if (SafeStrlen(lpszTargets) == 0)
		return;

	CopyBeforeWrite();
	LPCTSTR lpsz = m_pchData;

	while (*lpsz != '\0')
	{
		if (_tcschr(lpszTargets, *lpsz) == NULL)
			break;
		lpsz = _tcsinc(lpsz);
	}

	if (lpsz != m_pchData)
	{
		// fix up data and length
		int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
		memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
		GetData()->nDataLength = nDataLength;
	}
}

void CBsString::TrimLeft(TCHAR chTarget)
{
	// find first non-matching character

	CopyBeforeWrite();
	LPCTSTR lpsz = m_pchData;

	while (chTarget == *lpsz)
		lpsz = _tcsinc(lpsz);

	if (lpsz != m_pchData)
	{
		// fix up data and length
		int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
		memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
		GetData()->nDataLength = nDataLength;
	}
}

void CBsString::TrimLeft()
{
	// find first non-space character

	CopyBeforeWrite();
	LPCTSTR lpsz = m_pchData;
	
	while (_istspace(*lpsz))
		lpsz = _tcsinc(lpsz);

	if (lpsz != m_pchData)
	{
    	// fix up data and length
    	int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
    	memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
    	GetData()->nDataLength = nDataLength;
	}
}


BOOL CBsString::ExpandEnvironmentStrings( LPCTSTR lpszSrc )
{
    INT nMaxLen;
    nMaxLen = (int)::ExpandEnvironmentStringsW( lpszSrc, NULL, 0 );
    if ( nMaxLen == 0 )
    {
        return FALSE;
    }
    
    GetBufferSetLength( nMaxLen - 1 );

    INT i = (int)::ExpandEnvironmentStringsW( lpszSrc, m_pchData, nMaxLen );
    if ( i == 0 || i > nMaxLen )
    {
        Release();
        return FALSE;
    }
	return TRUE;
}


//
//  From validadd.cpp
//

BOOL BSAFXAPI BsAfxIsValidString(LPCWSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrW(lpsz, nLength) == 0;
}

BOOL BSAFXAPI BsAfxIsValidString(LPCSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrA(lpsz, nLength) == 0;
}

BOOL BSAFXAPI BsAfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\provider\provbase.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CProvBase.cpp
//
//  Description:    
//      Implementation of CProvBase class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//
//////////////////////////////////////////////////////////////////////////////
#pragma warning( disable : 4786 )
#include "Pch.h"
#include "ProvBase.h"

//****************************************************************************
//
//  CProvBase
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProvBase::CProvBase(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase::CProvBase(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : m_pNamespace( NULL )
    , m_pClass( NULL )
{
    HRESULT   sc;

    _ASSERTE(pwszNameIn != NULL);
    _ASSERTE(pNamespaceIn != NULL);
    
    m_pNamespace = pNamespaceIn;
    m_bstrClassName = pwszNameIn;

    sc = m_pNamespace->GetObject(
            m_bstrClassName,
            0,
            0,
            &m_pClass,
            NULL
            );

    // failed to construct object,
    if ( FAILED( sc ) )
    {
        throw CProvException( sc );
    }


} //*** CProvBase::CProvBase()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\provider\ntrkcomm.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      NtRkComm.cpp
//
//  Description:
//      Implementation of CWbemServices, CImpersonatedProvider, CInstanceMgr
//      class.
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "NtRkComm.h"
#include "ObjectPath.h"

//****************************************************************************
//
//  CWbemServices
//      Wraps for IWbemServices. security impersonation is implemented here
//
//****************************************************************************

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemServices::CWbemServices(
//      IWbemServices * pNamespace
//    )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pNamespace  --
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWbemServices::CWbemServices(
    IWbemServices * pNamespace
    )
    : m_pWbemServices( NULL )
{
    m_pWbemServices = pNamespace;
    if ( m_pWbemServices != NULL )
    {
        m_pWbemServices->AddRef( );
    }

} //*** CWbemServices::CWbemServices()

CWbemServices & 
CWbemServices::operator =(
    CWbemServices * Namespace
    )
{
   
    if ( m_pWbemServices != NULL )
    {
        m_pWbemServices->Release( );
    }
    m_pWbemServices = Namespace->m_pWbemServices;
    m_pWbemServices->AddRef();
    return *this;

} //*** CWbemServices::CWbemServices()
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemServices::~CWbemServices( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWbemServices::~CWbemServices( void )
{
    if ( m_pWbemServices != NULL )
    {
        m_pWbemServices->Release();
    }

} //*** CWbemServices::~CWbemServices()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::CreateClassEnum(
//      BSTR                    bstrSuperclassIn,
//      long                    lFlagsIn,
//      IWbemContext *          pCtxIn,
//      IEnumWbemClassObject ** ppEnumOut
//      )
//
//  Description:
//      Returns an enumerator for all classes satisfying the
//      selection criteria
//
//  Arguments:
//      bstrSuperclassIn
//          Specifies a superclass name
//
//      lFlagsIn
//          accepts WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_
//          RETURN_IMMEDIATELY, WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_
//          BIDIRECTIONAL
//
//      pCtxIn
//          Typically NULL
//
//      ppEnumOut
//          Receives the pointer to the enumerator
//
//  Return Value:
//      WBEM stand error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::CreateClassEnum(
    BSTR                    bstrSuperclassIn,
    long                    lFlagsIn,
    IWbemContext *          pCtxIn,
    IEnumWbemClassObject ** ppEnumOut
    )
{
    HRESULT hr;

    hr = m_pWbemServices->CreateClassEnum(
                bstrSuperclassIn,
                lFlagsIn,
                pCtxIn,
                ppEnumOut
                );
    if ( SUCCEEDED( hr ) )
    {
        // WMI may have added privileges to our token; re-impersonate
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::CreateClassEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::CreateInstanceEnum(
//      BSTR                    bstrClassIn,
//      long                    lFlagsIn,
//      IWbemContext *          pCtxIn,
//      IEnumWbemClassObject ** ppEnumOut
//      )
//
//  Description:
//      creates an enumerator that returns the instances of a
//      specified class according to user-specified selection
//      criteria
//
//  Arguments:
//      bstrClassIn
//          Specifies a superclass name
//
//      lFlagsIn
//          accepts WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_
//          RETURN_IMMEDIATELY, WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_
//          BIDIRECTIONAL
//
//      pCtxIn
//          Typically NULL
//
//      ppEnumOut
//          Receives the pointer to the enumerator
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::CreateInstanceEnum(
    BSTR                    bstrClassIn,
    long                    lFlagsIn,
    IWbemContext *          pCtxIn,
    IEnumWbemClassObject ** ppEnumOut
    )
{
    HRESULT hr;

    hr = m_pWbemServices->CreateInstanceEnum(
                bstrClassIn,
                lFlagsIn,
                pCtxIn,
                ppEnumOut
                );
    if ( SUCCEEDED( hr ) )
    {
        // WMI may have added privileges to our token; re-impersonate
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::CreateInstanceEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::DeleteClass(
//      BSTR                bstrClassIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemCallResult **  ppCallResultInout
//    )
//
//  Description:
//      Deletes the specified class from the current namespace.
//
//  Arguments:
//      bstrClassIn
//          The name of the class targeted for deletion.
//
//      lFlagsIn
//          accepts WBEM_FLAG_RETURN_IMMEDIATELY, WBEM_FLAG_
//          OWNER_UPDATE
//
//      pCtxIn
//          Typically NULL
//
//      ppCallResultInout
//          Receives the call result
//
//  Return Value:
//      WBEM stand error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::DeleteClass(
    BSTR                bstrClassIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemCallResult **  ppCallResultInout
    )
{
    HRESULT hr;

    hr = m_pWbemServices->DeleteClass(
                bstrClassIn,
                lFlagsIn,
                pCtxIn,
                ppCallResultInout
                );
    if ( SUCCEEDED( hr ) )
    {
        // WMI may have added privileges to our token; re-impersonate
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::DeleteClass()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::DeleteInstance(
//      BSTR                bstrObjectPathIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemCallResult **  ppCallResultInout
//      )
//
//  Description:
//      deletes an instance of an existing class in the current namespace
//
//  Arguments:
//      bstrObjectPathIn
//          object path to the instance to be deleted.
//
//      lFlagsIn
//          accepts WBEM_FLAG_RETURN_IMMEDIATELY
//
//      pCtxIn
//          Typically NULL
//
//      ppCallResultInout
//          Receives the call result
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::DeleteInstance(
    BSTR                bstrObjectPathIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemCallResult **  ppCallResultInout
    )
{
    HRESULT hr;

    hr = m_pWbemServices->DeleteInstance(
                bstrObjectPathIn,
                lFlagsIn,
                pCtxIn,
                ppCallResultInout
                );
    if ( SUCCEEDED( hr ) )
    {
        // WMI may have added privileges to our token; re-impersonate
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::DeleteInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::ExecMethod(
//      BSTR                bstrObjectPathIn,
//      BSTR                bstrMethodNameIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemClassObject *  pInParamsIn,
//      IWbemClassObject ** ppOurParamsOut,
//      IWbemCallResult **  ppCallResultOut
//      )
//
//  Description:
//      execute methods for the given object
//
//  Arguments:
//      bstrObjectPathIn
//          object path of the object for which the method is executed
//
//      bstrMethodNameIn
//          name of the method to be invoked
//
//      lFlagsIn
//          zero to make this a synchronous call
//
//      pCtxIn
//          Typically NULL
//
//      pInParamsIn
//          Input parameters for the method
//
//      ppOurParamsOut
//          output parameters for the method
//
//      ppCallResultOut
//          To receive call result
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::ExecMethod(
    BSTR                bstrObjectPathIn,
    BSTR                bstrMethodNameIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemClassObject *  pInParamsIn,
    IWbemClassObject ** ppOurParamsOut,
    IWbemCallResult **  ppCallResultOut
    )
{
    HRESULT hr;

    hr = m_pWbemServices->ExecMethod(
                bstrObjectPathIn,
                bstrMethodNameIn,
                lFlagsIn,
                pCtxIn,
                pInParamsIn,
                ppOurParamsOut,
                ppCallResultOut
                );
    if ( SUCCEEDED( hr ) )
    {
        // WMI may have added privileges to our token; re-impersonate
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::ExecMethod()

HRESULT
CWbemServices::ExecMethodAsync(
    BSTR                bstrObjectPathIn,
    BSTR                bstrMethodNameIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemClassObject *  pInParamsIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    HRESULT hr;

    hr = m_pWbemServices->ExecMethodAsync(
                bstrObjectPathIn,
                bstrMethodNameIn,
                lFlagsIn,
                pCtxIn,
                pInParamsIn,
                pHandlerIn
                );
    if ( SUCCEEDED( hr ) )
    {
        // WMI may have added privileges to our token; re-impersonate
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::ExecMethod()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::ExecNotificationQuery(
//      BSTR                    bstrQueryLanguageIn,
//      BSTR                    bstrQueryIn,
//      long                    lFlagsIn,
//      IWbemContext *          pCtxIn,
//      IEnumWbemClassObject ** ppEnumOut
//      )
//
//  Description:
//      Executes a query to receive events.
//
//  Arguments:
//      bstrQueryLanguageIn
//          BSTR containing one of the query languages supported by WMI
//
//      bstrQueryIn
//          text of the event-related query
//
//      lFlagsIn
//          WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_RETURN_IMMEDIATELY
//
//      pCtxIn
//          Typically NULL
//
//      ppEnumOut
//          Receives the enumerator
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::ExecNotificationQuery(
    BSTR                    bstrQueryLanguageIn,
    BSTR                    bstrQueryIn,
    long                    lFlagsIn,
    IWbemContext *          pCtxIn,
    IEnumWbemClassObject ** ppEnumOut
    )
{
    HRESULT hr;

    hr = m_pWbemServices->ExecNotificationQuery(
                bstrQueryLanguageIn,
                bstrQueryIn,
                lFlagsIn,
                pCtxIn,
                ppEnumOut
                );
    if ( SUCCEEDED( hr ) )
    {
        // WMI may have added privileges to our token; re-impersonate
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::ExecNotificationQuery()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::ExecQuery(
//      BSTR                    bstrQueryLanguageIn,
//      BSTR                    bstrQueryIn,
//      long                    lFlagsIn,
//      IWbemContext *          pCtxIn,
//      IEnumWbemClassObject ** ppEnumOut
//      )
//
//  Description:
//      executes a query to retrieve objects.
//
//  Arguments:
//      bstrQueryLanguageIn
//          BSTR containing one of the query languages supported by WMI
//
//      bstrQueryIn
//          containing the text of the query
//
//      lFllFlagsIn
//          WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_RETURN_IMMEDIATELY
//          WBEM_FLAG_BIDIRECTIONAL, WBEM_FLAG_ENSURE_LOCATABLE
//          WBEM_FLAG_PROTOTYPE
//
//      pCtxIn
//          Typically NULL
//
//      ppEnumOut
//          receives the enumerator
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::ExecQuery(
    BSTR                    bstrQueryLanguageIn,
    BSTR                    bstrQueryIn,
    long                    lFlagsIn,
    IWbemContext *          pCtxIn,
    IEnumWbemClassObject ** ppEnumOut
    )
{
    HRESULT hr;

    hr = m_pWbemServices->ExecQuery(
                bstrQueryLanguageIn,
                bstrQueryIn,
                lFlagsIn,
                pCtxIn,
                ppEnumOut
                );
    if ( SUCCEEDED( hr ) )
    {
        // WMI may have added privileges to our token; re-impersonate
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::ExecQuery()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::GetObject(
//      BSTR                bstrObjectPathIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemClassObject ** ppObjectInout,
//      IWbemCallResult **  ppCallResultInout
//      )
//
//  Description:
//      retrieves a class or instance
//
//  Arguments:
//      bstrObjectPathIn
//          The object path of the object to retrieve
//
//      lFlagsIn
//          0
//
//      pCtxIn
//          Typically NULL
//
//      ppObjectInout
//          If not NULL, this receives the object
//
//      ppCallResultInout
//          If the lFlags parameter contains WBEM_FLAG_RETURN_IMMEDIATELY,
//          this call will return immediately with WBEM_S_NO_ERROR. The
//          ppCallResult parameter will receive a pointer to a new
//          IWbemCallResult object
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::GetObject(
    BSTR                bstrObjectPathIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemClassObject ** ppObjectInout,
    IWbemCallResult **  ppCallResultInout
    )
{
    HRESULT hr;

    hr = m_pWbemServices->GetObject(
                bstrObjectPathIn,
                lFlagsIn,
                pCtxIn,
                ppObjectInout,
                ppCallResultInout
                );
    if ( SUCCEEDED( hr ) )
    {
        // WMI may have added privileges to our token; re-impersonate
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::GetObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::PutClass(
//      IWbemClassObject *  pObjectIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemCallResult **  ppCallResultInout
//      )
//
//  Description:
//      Creates a new class or updates an existing one
//
//  Arguments:
//      pObjectIn
//          point to a valid class definition
//
//      lFlagsIn
//          WBEM_FLAG_CREATE_OR_UPDATE,WBEM_FLAG_UPDATE_ONLY,
//          WBEM_FLAG_CREATE_ONLY, WBEM_FLAG_RETURN_IMMEDIATELY,
//          WBEM_FLAG_OWNER_UPDATE, WBEM_FLAG_UPDATE_COMPATIBLE,
//          WBEM_FLAG_UPDATE_SAFE_MODE, WBEM_FLAG_UPDATE_FORCE_MODE
//
//      pCtxIn
//          Typically NULL
//
//      ppCallResultInout
//          If the lFlags parameter contains WBEM_FLAG_RETURN_IMMEDIATELY,
//          this call will return immediately with WBEM_S_NO_ERROR. The
//          ppCallResult parameter will receive a pointer to a new
//          IWbemCallResult object
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::PutClass(
    IWbemClassObject *  pObjectIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemCallResult **  ppCallResultInout
    )
{
    HRESULT hr;

    hr = m_pWbemServices->PutClass(
                pObjectIn,
                lFlagsIn,
                pCtxIn,
                ppCallResultInout
                );
    if ( SUCCEEDED( hr ) )
    {
        // WMI may have added privileges to our token; re-impersonate
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::PutClass()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::PutInstance(
//      IWbemClassObject *  pInstIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemCallResult **  ppCallResultInout
//      )
//
//  Description:
//      Creates or updates an instance of an existing class.
//
//  Arguments:
//      pInstIn
//          Points to the instance to be written
//
//      lFlagsIn
//          WBEM_FLAG_CREATE_OR_UPDATE,WBEM_FLAG_UPDATE_ONLY,
//          WBEM_FLAG_CREATE_ONLY, WBEM_FLAG_RETURN_IMMEDIATELY,
//
//      pCtxIn
//          Typically NULL
//
//      ppCallResultInout
//          If the lFlags parameter contains WBEM_FLAG_RETURN_IMMEDIATELY,
//          this call will return immediately with WBEM_S_NO_ERROR. The
//          ppCallResult parameter will receive a pointer to a new
//          IWbemCallResult object
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::PutInstance(
    IWbemClassObject *  pInstIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemCallResult **  ppCallResultInout
    )
{
    HRESULT hr;

    hr = m_pWbemServices->PutInstance(
                pInstIn,
                lFlagsIn,
                pCtxIn,
                ppCallResultInout
                );
    if ( SUCCEEDED( hr ) )
    {
        // WMI may have added privileges to our token; re-impersonate
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::PutInstance()

//****************************************************************************
//
//  CImpersonatedProvider
//      a middle layer between IWbemservices and actual provider. It takes
//      care of security impersonation
//
//****************************************************************************

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CImpersonatedProvider::CImpersonatedProvider(
//      BSTR            bstrObjectPathIn    = NULL,
//      BSTR            bstrUserIn          = NULL,
//      BSTR            bstrPasswordIn      = NULL,
//      IWbemContext *  pCtxIn              = NULL
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      bstrObjectPathIn    --
//      bstrUserIn          --
//      bstrPasswordIn      --
//      pCtxIn              --
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CImpersonatedProvider::CImpersonatedProvider(
    BSTR            ,// bstrObjectPathIn.
    BSTR            ,// bstrUserIn,
    BSTR            ,// bstrPasswordIn,
    IWbemContext *  // pCtxIn
    )
    : m_cRef( 0 ), m_pNamespace( NULL )
{

} //*** CImpersonatedProvider::CImpersonatedProvider()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CImpersonatedProvider::~CImpersonatedProvider( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CImpersonatedProvider::~CImpersonatedProvider( void )
{
    delete m_pNamespace;

} //*** CImpersonatedProvider::~CImpersonatedProvider()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CImpersonatedProvider::AddRef( void )
//
//  Description:
//      Increment the reference count on the COM object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CImpersonatedProvider::AddRef( void )
{
    return InterlockedIncrement( ( long * ) & m_cRef );

} //*** CImpersonatedProvider::AddRef()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CImpersonatedProvider::Release( void )
//
//  Description:
//      Release a reference on the COM object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      New reference count.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CImpersonatedProvider::Release( void )
{
    ULONG nNewCount = InterlockedDecrement( ( long * ) & m_cRef  );
    if ( 0L == nNewCount )
        delete this;

    return nNewCount;

} //*** CImpersonatedProvider::Release()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::QueryInterface(
//      REFIID  riid,
//      PPVOID  ppv
//      )
//
//  Description:
//      Initialize the provider.
//
//  Arguments:
//      riidIn      -- Interface ID being queried.
//      ppvOut      -- Pointer in which to return interface pointer.
//
//  Return Value:
//      NOERROR
//      E_NOINTERFACE
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CImpersonatedProvider::QueryInterface(
    REFIID  riid,
    PPVOID  ppv
    )
{

    if (ppv == NULL)
    {
        return E_INVALIDARG;
    }
    
    *ppv = NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if ( riid == IID_IWbemServices )
    {
       *ppv = static_cast< IWbemServices * >( this );
    }

    if ( riid == IID_IUnknown || riid == IID_IWbemProviderInit )
    {
        *ppv = static_cast< IWbemProviderInit * >( this );
    }

    if ( NULL != *ppv )
    {
        AddRef();
        return NOERROR;
    }
    else
    {
        return E_NOINTERFACE;
    }

} //*** CImpersonatedProvider::QueryInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::Initialize(
//      LPWSTR                  pszUserIn,
//      LONG                    lFlagsIn,
//      LPWSTR                  pszNamespaceIn,
//      LPWSTR                  pszLocaleIn,
//      IWbemServices *         pNamespaceIn,
//      IWbemContext *          pCtxIn,
//      IWbemProviderInitSink * pInitSinkIn
//      )
//
//  Description:
//      Initialize the provider.
//
//  Arguments:
//      pszUserIn       --
//      lFlagsIn        --
//      pszNamespaeIn   --
//      pszLocaleIn     --
//      pNamespaceIn    --
//      pCtxIn          --
//      pInitSinkIn     --
//
//  Return Value:
//      WBEM_S_NO_ERROR
//      WBEM_E_OUT_OF_MEMORY
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CImpersonatedProvider::Initialize(
    LPWSTR                  ,// pszUserIn,
    LONG                    ,// lFlagsIn,
    LPWSTR                  ,// pszNamespaceIn,
    LPWSTR                  ,// pszLocaleIn,
    IWbemServices *         pNamespaceIn,
    IWbemContext *          ,// pCtxIn,
    IWbemProviderInitSink * pInitSinkIn
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    LONG lStatus = WBEM_S_INITIALIZED;

    if (pNamespaceIn == NULL || pInitSinkIn == NULL)
    {
        return E_INVALIDARG;
    }

    m_pNamespace = new CWbemServices( pNamespaceIn );
    if ( m_pNamespace == NULL )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        lStatus = WBEM_E_FAILED;
    } // if: error allocating memory

    //Let CIMOM know you are initialized
    //==================================

    pInitSinkIn->SetStatus( lStatus, 0 );
    return hr;

} //*** CImpersonatedProvider::Initialize()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::CreateInstanceEnumAsync(
//      const BSTR          bstrClassIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Create an instance asynchronously.
//
//  Arguments:
//      bstrClassIn         --
//      lFlagsIn            --
//      pCtxIn              --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoCreateInstanceEnumAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::CreateInstanceEnumAsync(
    const BSTR          bstrClassIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoCreateInstanceEnumAsync(
                    bstrClassIn,
                    lFlagsIn,
                    pCtxIn,
                    pResponseHandlerIn
                    );
    } // if:

    return hr;

} //*** CImpersonatedProvider::CreateInstanceEnumAsync()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::DeleteInstanceAsync(
//      const BSTR          bstrObjectPathIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Delete an instance asynchronously.
//
//  Arguments:
//      bstrObjectPathIn    --
//      lFlagsIn            --
//      pCtxIn              --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoDeleteInstanceAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::DeleteInstanceAsync(
    const BSTR          bstrObjectPathIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoDeleteInstanceAsync(
                bstrObjectPathIn,
                lFlagsIn,
                pCtxIn,
                pResponseHandlerIn
                );
    } // if:

    return hr;

} //*** CImpersonatedProvider::DeleteInstanceAsync()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::ExecMethodAsync(
//      const BSTR          bstrObjectPathIn,
//      const BSTR          bstrMethodNameIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemClassObject *  pInParamsIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Execute a method asynchronously.
//
//  Arguments:
//      bstrObjectPathIn    --
//      bstrMethodNameIn    --
//      lFlagsIn            --
//      pCtxIn              --
//      pInParamsIn         --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoExecMethodAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::ExecMethodAsync(
    const BSTR          bstrObjectPathIn,
    const BSTR          bstrMethodNameIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemClassObject *  pInParamsIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoExecMethodAsync(
                bstrObjectPathIn,
                bstrMethodNameIn,
                lFlagsIn,
                pCtxIn,
                pInParamsIn,
                pResponseHandlerIn
                );
    } // if:

    return hr;

} //*** CImpersonatedProvider::ExecMethodAsync()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::ExecQueryAsync(
//      const BSTR          bstrQueryLanguageIn,
//      const BSTR          bstrQueryIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Execute a query asynchronously.
//
//  Arguments:
//      bstrQueryLanguageIn --
//      bstrQueryIn         --
//      lFlagsIn            --
//      pCtxIn              --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoExecQueryAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::ExecQueryAsync(
    const BSTR          bstrQueryLanguageIn,
    const BSTR          bstrQueryIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoExecQueryAsync(
                bstrQueryLanguageIn,
                bstrQueryIn,
                lFlagsIn,
                pCtxIn,
                pResponseHandlerIn
                );
    } // if:

    return hr;

} //*** CImpersonatedProvider::ExecQueryAsync()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::GetObjectAsync(
//      const BSTR          bstrObjectPathIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Get an instance asynchronously.
//
//  Arguments:
//      bstrObjectPathIn    --
//      lFlagsIn            --
//      pCtxIn              --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoGetObjectAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::GetObjectAsync(
    const BSTR          bstrObjectPathIn,
    long                lFlagsIn,
    IWbemContext  *     pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoGetObjectAsync(
                bstrObjectPathIn,
                lFlagsIn,
                pCtxIn,
                pResponseHandlerIn
                );
    } // if:

    return hr;

} //*** CImpersonatedProvider::GetObjectAsync()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::PutInstanceAsync(
//      IWbemClassObject *  pInstIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Save an instance asynchronously.
//
//  Arguments:
//      pInstIn             --
//      lFlagsIn            --
//      pCtxIn              --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoPutInstanceAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::PutInstanceAsync(
    IWbemClassObject *  pInstIn,
    long                lFlagsIn,
    IWbemContext  *     pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoPutInstanceAsync(
                pInstIn,
                lFlagsIn,
                pCtxIn,
                pResponseHandlerIn
                );
    } // if:

    return hr;

} //*** CImpersonatedProvider::PutInstanceAsync()

//****************************************************************************
//
//  CWbemInstanceMgr
//      Manage WMI instance, allow block indicate
//
//****************************************************************************

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemInstanceMgr::CWbemInstanceMgr(
//      IWbemObjectSink *   pHandlerIn,
//      DWORD               dwSizeIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pHandlerIn      -- WMI sink.
//      dwSizeIn        --
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWbemInstanceMgr::CWbemInstanceMgr(
    IWbemObjectSink *   pHandlerIn,
    DWORD               dwSizeIn    // = 50
    )
    : m_pSink( NULL )
    , m_ppInst( NULL )
    , m_dwIndex( 0 )
{
    DWORD dwIndex = 0;

    m_pSink = pHandlerIn;
    if ( m_pSink == NULL )
    {
        throw static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER );
    } // if: no sink specified

    m_pSink->AddRef( );
    m_dwThreshHold = dwSizeIn;
    m_ppInst = new IWbemClassObject*[ dwSizeIn ];

    if ( m_ppInst == NULL )
        throw static_cast< HRESULT >( E_OUTOFMEMORY );

    for ( dwIndex = 0 ; dwIndex < dwSizeIn ; dwIndex++ )
    {
        m_ppInst[ dwIndex ] = NULL;
    } // for each in m_ppInst

} //*** CWbemInstanceMgr::CWbemInstanceMgr()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemInstanceMgr::CWbemInstanceMgr( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWbemInstanceMgr::~CWbemInstanceMgr( void )
{
    if ( m_ppInst != NULL )
    {
        if ( m_dwIndex > 0 )
        {
            m_pSink->Indicate( m_dwIndex, m_ppInst );
        }
        DWORD dwIndex = 0;
        for ( dwIndex = 0; dwIndex < m_dwIndex; dwIndex++ )
        {
            if ( m_ppInst[ dwIndex ] != NULL )
            {
                ( m_ppInst[ dwIndex ] )->Release( );
            }
        }
        delete [] m_ppInst;
    }

    m_pSink->Release( );

} //*** CWbemInstanceMgr::~CWbemInstanceMgr()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CWbemInstanceMgr::Indicate(
//      IN IWbemClassObject *   pInstIn
//    )
//
//  Description:
//      Notify an instance to WMI sink
//
//  Arguments:
//      pInstIn     -- Instance to send to WMI
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWbemInstanceMgr::Indicate(
    IN IWbemClassObject *   pInstIn
    )
{
    if ( pInstIn == NULL )
    {
        throw static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER );
    }

    m_ppInst[ m_dwIndex++ ] = pInstIn;
    pInstIn->AddRef( );
    if ( m_dwIndex == m_dwThreshHold )
    {
        HRESULT sc = WBEM_S_NO_ERROR;
        sc = m_pSink->Indicate( m_dwIndex, m_ppInst );
        if( FAILED( sc ) )
        {
            if ( sc == WBEM_E_CALL_CANCELLED )
            {
                sc = WBEM_S_NO_ERROR;
            }
            throw CProvException( sc );
        }

        // reset state
        DWORD dwIndex = 0;
        for ( dwIndex = 0; dwIndex < m_dwThreshHold; dwIndex++ )
        {
            if ( m_ppInst[ dwIndex ] != NULL )
            {
                ( m_ppInst[ dwIndex ] )->Release( );
            } //*** if m_ppInst[ _dwIndex ] != NULL

            m_ppInst[ dwIndex ] = NULL;

        } //*** for each in m_ppInst

        m_dwIndex = 0;

    } //*** if( m_dwIndex == m_dwThreshHold )
    return;

} //*** CWbemInstanceMgr::Indicate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemInstanceMgr::SetStatus
//
//  Description:
//      send status to WMI sink
//
//  Arguments:
//      lFlagsIn        -- WMI flag
//      hrIn            -- HResult
//      bstrParamIn     -- Message
//      pObjParamIn     -- WMI extended error object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWbemInstanceMgr::SetStatus(
    LONG                lFlagsIn,
    HRESULT             hrIn,
    BSTR                bstrParamIn,
    IWbemClassObject *  pObjParamIn
    )
{
    m_pSink->SetStatus(
        lFlagsIn,
        hrIn,
        bstrParamIn,
        pObjParamIn
        );

} //*** CWbemInstanceMgr::SetStatus()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\provider\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      David Potter (DavidP) 05-APR-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////


#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#pragma warning( disable : 4786 )
#include <wbemprov.h>
#include <objbase.h>
#include <map>
#include <comdef.h>

#include "vs_assert.hxx"

#include <atlbase.h>

#include "vs_inc.hxx"

#include "NtRkComm.h"
#include "ObjectPath.h"

#include "Common.h"

// constants
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\wmiprov\provider\objectpath.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ObjectPath.cpp
//
//  Description:    
//      Implementation of class CObjpath, CProvException, CProvExceptionHr,
//      and CProvExceptionWin32.
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//        MSP Prabu  (mprabu)  06-Jan-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ObjectPath.h"

//****************************************************************************
//
//  COb