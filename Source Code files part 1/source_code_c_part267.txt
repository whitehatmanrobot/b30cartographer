                         this._filterList});
            this._pnlMain.Location = new System.Drawing.Point(6, 27);
            this._pnlMain.Size = new System.Drawing.Size(434, 253);
            this._pnlMain.Anchor = (System.Windows.Forms.AnchorStyles.Bottom
                | System.Windows.Forms.AnchorStyles.Left);
            this._filterList.Size = new System.Drawing.Size(198, 224);
            this._filterList.Location = new System.Drawing.Point(0, 0);
            this._rbCompare.Location = new System.Drawing.Point(8, 21);
            this._rbCompare.Size = new System.Drawing.Size(211, 17);
            this._lblCompare.Location = new System.Drawing.Point(0, 4);
            this._lblCompare.Size = new System.Drawing.Size(211, 16);
            this._dialogButtons.Location = new System.Drawing.Point(197, 230);
            this._dialogButtons.Size = new System.Drawing.Size(237, 23);
            this._lblType.Location = new System.Drawing.Point(0, 4);
            this._lblType.Size = new System.Drawing.Size(211, 16);
            this._txtMethod.Location = new System.Drawing.Point(0, 64);
            this._txtMethod.Size = new System.Drawing.Size(211, 20);
            this._txtArgument.Location = new System.Drawing.Point(0, 64);
            this._txtArgument.Size = new System.Drawing.Size(211, 20);
            this._pnlRight.Controls.AddRange(new System.Windows.Forms.Control[] {this._pnlCompare,
                                                                                 this._pnlDelegate,
                                                                                 this._glAttributes,
                                                                                 this._glType,
                                                                                 this._rbDelegate,
                                                                                 this._rbCompare});
            this._pnlRight.Location = new System.Drawing.Point(215, 0);
            this._pnlRight.Size = new System.Drawing.Size(219, 226);
            this._lblMethod.Location = new System.Drawing.Point(0, 48);
            this._lblMethod.Size = new System.Drawing.Size(211, 16);
            this._glAttributes.Location = new System.Drawing.Point(0, 73);
            this._glAttributes.Size = new System.Drawing.Size(216, 16);
            this._rbDelegate.Location = new System.Drawing.Point(8, 46);
            this._rbDelegate.Size = new System.Drawing.Size(211, 17);
            this._glType.Size = new System.Drawing.Size(216, 16);
            this._pnlCompare.Controls.AddRange(new System.Windows.Forms.Control[] {this._txtArgument,
                                                                                     this._lblArgument,
                                                                                     this._cbCompare,
                                                                                     this._lblCompare});
            this._pnlCompare.Location = new System.Drawing.Point(8, 90);
            this._pnlCompare.Size = new System.Drawing.Size(211, 136);
            this._cbCompare.DropDownWidth = 211;
            this._cbCompare.Location = new System.Drawing.Point(0, 20);
            this._cbCompare.Size = new System.Drawing.Size(211, 21);
            this._cbCompare.Sorted = true;
            this._lblArgument.Location = new System.Drawing.Point(0, 48);
            this._lblArgument.Size = new System.Drawing.Size(211, 16);
            this._pnlDelegate.Controls.AddRange(new System.Windows.Forms.Control[] {this._txtType,
                                                                                      this._txtMethod,
                                                                                      this._lblMethod,
                                                                                      this._lblType});
            this._pnlDelegate.Location = new System.Drawing.Point(8, 90);
            this._pnlDelegate.Size = new System.Drawing.Size(211, 136);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.ClientSize = new System.Drawing.Size(448, 289);
            this.AcceptButton = _dialogButtons.CmdOK;
            this.CancelButton = _dialogButtons.CmdCancel;
            this.HelpRequested += new HelpEventHandler(this.OnHelpRequested);
            this.Controls.AddRange(new System.Windows.Forms.Control[] {this._pnlHeader, this._pnlMain});
        }
        
        private void LoadAvailableCapabilities()
        {
            Type type = typeof(System.Web.Mobile.MobileCapabilities);
            PropertyInfo[] properties = type.GetProperties();
            foreach(PropertyInfo property in properties)
            {
                _cbCompare.Items.Add(property.Name);
            }
        }

        private void UpdateButtonsEnabling()
        {
            _filterList.UpdateButtonsEnabling();
            bool filterIsSelected = (_filterList.SelectedNode != null);
            _rbCompare.Enabled = filterIsSelected;
            _rbDelegate.Enabled = filterIsSelected;
            _cbCompare.Enabled = filterIsSelected;
            _txtArgument.Enabled = filterIsSelected;
            _txtMethod.Enabled = filterIsSelected;
            _txtType.Enabled = filterIsSelected;
        }

        internal void SelectFilterByName(String name)
        {
            foreach(DeviceFilterTreeNode filter in _filterList.TvList.Nodes)
            {
                if(filter.DeviceFilter.Name == name)
                {
                    _filterList.TvList.SelectedNode = filter;
                    break;
                }
            }
        }

        private enum RequirementFlag
        {
            NotAllowed,
            Required,
            Optional
        };

        private bool FilterIsLegal_CheckRow(RequirementFlag[] row1, bool[] row2)
        {
            Debug.Assert(row1.Length == row2.Length);
            for(int i = 0; i < row1.Length; i++)
            {
                if(row1[i] == RequirementFlag.NotAllowed && row2[i] == true)
                {
                    return false;
                }
                else if(row1[i] == RequirementFlag.Required && row2[i] == false)
                {
                    return false;
                }
            }
            return true;
        }
        
        private bool FilterIsLegal(DeviceFilterNode filter)
        {
            Object[] legalCombinations = {
                new RequirementFlag[] {
                    RequirementFlag.Required,         // compare mode
                    RequirementFlag.Required,         // compare
                    RequirementFlag.Optional,         // argument
                    RequirementFlag.Optional,         // method
                    RequirementFlag.Optional          // type
                },
                new RequirementFlag[] {
                    RequirementFlag.NotAllowed,       // compare mode
                    RequirementFlag.Optional,         // compare
                    RequirementFlag.Optional,         // argument
                    RequirementFlag.Required,         // method
                    RequirementFlag.Required          // type
                }
            };
            
            bool[] filterCombination = {
                (filter.Mode == DeviceFilterMode.Compare),
                ((filter.Compare != null) && (filter.Compare.Length > 0)),
                ((filter.Argument != null) && (filter.Argument.Length > 0)),
                ((filter.Type != null) && (filter.Type.Length > 0)),
                ((filter.Method != null) && (filter.Method.Length > 0)),
            };
            
            foreach(RequirementFlag[] legalCombination in legalCombinations)
            {
                if(FilterIsLegal_CheckRow(legalCombination, filterCombination))
                {
                    return true;
                }
            }
            return false;
        }

        #if DEBUG
        private bool Debug_DuplicateFiltersExist(ICollection filters)
        {
            // Filter names are case-sensitive.
            IDictionary namesEncountered = new Hashtable();            
            foreach(DeviceFilterTreeNode node in filters)
            {
                DeviceFilterNode filter = node.DeviceFilter;
                if(namesEncountered[filter.Name] != null)
                {
                    return true;
                }
                namesEncountered[filter.Name] = true;
            }
            return false;
        }
        #endif

        private bool FiltersAreValid()
        {
            #if DEBUG
            Debug.Assert(
                !Debug_DuplicateFiltersExist(_filterList.TvList.Nodes),
                "UI failed to prevent duplicate filters from being created."
            );
            #endif

            ArrayList filtersInErrorList = new ArrayList();
            foreach(DeviceFilterTreeNode filterNode in _filterList.TvList.Nodes)
            {
                DeviceFilterNode filter = filterNode.DeviceFilter;
                if(!FilterIsLegal(filter))
                {
                    filtersInErrorList.Add(filter.Name);
                }
            }
            if(filtersInErrorList.Count != 0)
            {
                GenericUI.ShowWarningMessage(
                    SR.GetString(SR.DeviceFilterEditorDialog_Title),
                    SR.GetString(
                        SR.DeviceFilterEditorDialog_InvalidFilter,
                        GenericUI.BuildCommaDelimitedList(
                            filtersInErrorList
                        )
                    )
                );
                return false;
            }
            return true;
        }
        
        private bool SaveFilters()
        {
            Cursor oldCursor = null;
            try
            {
                oldCursor = this.Cursor;
                this.Cursor = Cursors.WaitCursor;

                ArrayList oldFilters = _webConfig.ReadDeviceFilters();
                foreach(DeviceFilterNode filter in oldFilters)
                {
                    filter.Delete();
                }

                _webConfig.EnsureSystemWebSectionIsPresent();
                foreach(DeviceFilterTreeNode filter in _filterList.TvList.Nodes)
                {
                    filter.DeviceFilter.Save();
                }
                _webConfig.Save();
            }
            catch (FileNotFoundException)
            {
                this.Cursor = oldCursor;
                GenericUI.ShowWarningMessage(
                    SR.GetString(SR.DeviceFilterEditorDialog_Title),
                    SR.GetString(SR.DeviceFilterEditorDialog_WebConfigMissing)
                );
                return false;
            }
            catch (Exception e)
            {
                this.Cursor = oldCursor;
                GenericUI.ShowWarningMessage(
                    SR.GetString(SR.DeviceFilterEditorDialog_Title),
                    SR.GetString(SR.DeviceFilterEditorDialog_WebConfigParsingError, e.Message)
                );
                Debug.Fail(e.ToString());
                return false;
            }
            this.Cursor = oldCursor;
            return true;
        }

        // NOTE: AppliedDeviceFiltersDialog also uses this test...
        internal static bool NewLabelIsLegal(
            ISite site,
            EditableTreeList filterList,
            String oldLabel,
            String newLabel,
            String errorDialogTitle
        ) {
            Debug.Assert(site != null);

            if(newLabel.Length == 0)
            {
                GenericUI.ShowWarningMessage(
                    errorDialogTitle,
                    SR.GetString(SR.DeviceFilterEditorDialog_UnnamedFilter)
                );
                return false;
            }

            /* Removed for DCR 4240
            if (!DesignerUtility.IsValidName(newLabel))
            {
                GenericUI.ShowWarningMessage(
                    errorDialogTitle,
                    SR.GetString(SR.DeviceFilterEditorDialog_IllegalName, newLabel)
                );
                return false;
            }
            */

            return true;
        }

        private void ShowHelpTopic()
        {
            Debug.Assert(_site != null, "Expected the control to be sited.");
 
            IHelpService helpService = (IHelpService)_site.GetService(typeof(IHelpService));
            if (helpService != null) 
            {
                helpService.ShowHelpFromKeyword("net.Mobile.DeviceFilterEditorDialog");
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //  Begin Event Handling
        ////////////////////////////////////////////////////////////////////////

        private void OnClickOK(Object sender, EventArgs e)
        {
            if(!FiltersAreValid())
            {
                return;
            }
            if(!SaveFilters())
            {
                return;
            }
            Close();
            DialogResult = DialogResult.OK;
        }
        
        private void OnClickCancel(Object sender, EventArgs e)
        {
            Close();
            DialogResult = DialogResult.Cancel;
        }
        
        private void OnClickHelp(Object sender, EventArgs e)
        {
            ShowHelpTopic();
        }
        
        private void OnHelpRequested(Object Control, HelpEventArgs hevent)
        {
            ShowHelpTopic();
            hevent.Handled = true;
        }

        private void CompareMode()
        {
            DeviceFilterTreeNode node = (DeviceFilterTreeNode)_filterList.SelectedNode;
            node.DeviceFilter.Mode = DeviceFilterMode.Compare;
            _pnlCompare.Visible = true;
            _pnlDelegate.Visible = false;
            _rbCompare.Checked = true;
            // We set Text proprety twice to preserve casing.  (See AUI 3964 /
            // URT 99595)
            String compare = node.DeviceFilter.Compare;
            _cbCompare.Text = compare;
            _cbCompare.Text = compare;
            _txtArgument.Text = node.DeviceFilter.Argument;
        }

        private void DelegateMode()
        {
            DeviceFilterTreeNode node = (DeviceFilterTreeNode)_filterList.SelectedNode;
            node.DeviceFilter.Mode = DeviceFilterMode.Delegate;
            _pnlCompare.Visible = false;
            _pnlDelegate.Visible = true;
            _rbDelegate.Checked = true;
            _txtType.Text = node.DeviceFilter.Type;
            _txtMethod.Text = node.DeviceFilter.Method;
        }

        private void OnClickRemoveButton(Object sender, EventArgs e)
        {
            if (_filterList.SelectedNode == null)
            {
                _pnlCompare.Visible = true;
                _pnlDelegate.Visible = false;
                _rbCompare.Checked = false;
                _rbDelegate.Checked = false;
                _cbCompare.Text = String.Empty;
                _txtArgument.Text = String.Empty;
                UpdateButtonsEnabling();
            }
        }

        private void OnClickAddButton(Object sender, EventArgs e)
        {
            DeviceFilterTreeNode node = new DeviceFilterTreeNode(_webConfig);
            node.Text = _filterList.GetUniqueLabel(node.Text);
            _filterList.TvList.Nodes.Add(node);
            _filterList.TvList.SelectedNode = node;
            node.EnsureVisible();
            UpdateButtonsEnabling();
            node.BeginEdit();
        }
        
        private void OnClickCompareRadioButton(Object Sender, EventArgs e)
        {
            CompareMode();
        }
        
        private void OnClickDelegateRadioButton(Object Sender, EventArgs e)
        {
            DelegateMode(); 
        }

        private void OnFilterSelected(Object sender, TreeViewEventArgs e)
        {
            DeviceFilterTreeNode node = (DeviceFilterTreeNode) e.Node;
            UpdateButtonsEnabling();
            if(node.DeviceFilter.Mode == DeviceFilterMode.Compare)
            {
                CompareMode();
            }
            else
            {
                DelegateMode();
            }
        }

        private void OnAfterLabelEdit(Object sender, NodeLabelEditEventArgs e)
        {
            // null still returned if label unmodified (verified 2310)
            if(e.Label == null)
            {
                return;
            }

            String oldLabel = e.Node.Text;
            String newLabel = e.Label;
            
            if(String.Compare(oldLabel, newLabel, true, CultureInfo.InvariantCulture) != 0
                && _filterList.LabelExists(newLabel))
            {
                // if the filter is duplicate
                GenericUI.ShowWarningMessage(
                    SR.GetString(SR.DeviceFilterEditorDialog_Title),
                    SR.GetString(SR.DeviceFilterEditorDialog_DuplicateName, newLabel)
                );
            }
            else if(String.Compare(newLabel, _nameOfDefaultFilter, true, CultureInfo.InvariantCulture) == 0)
            {
                GenericUI.ShowWarningMessage(
                    SR.GetString(SR.DeviceFilterEditorDialog_Title),
                    SR.GetString(SR.DeviceFilterEditorDialog_IllegalDefaultName, newLabel)
                );
            }
            else if(NewLabelIsLegal(_site, _filterList, oldLabel, newLabel,
                SR.GetString(SR.DeviceFilterEditorDialog_Title)
            )) {
                // if the filter name is legal
                ((DeviceFilterTreeNode)e.Node).DeviceFilter.Name = e.Label;
                return;
            }
            // if the filter name was duplicate or not legal
            e.CancelEdit = true;
        }

        private void OnTextChanged(Object sender, EventArgs e)
        {
            if (null != _filterList.SelectedNode)
            {
                DeviceFilterNode node = ((DeviceFilterTreeNode)_filterList.SelectedNode).DeviceFilter;
                if(sender == _cbCompare)
                {
                    node.Compare = _cbCompare.Text;
                }
                else if(sender == _txtArgument)
                {
                    node.Argument = _txtArgument.Text;
                }
                else if(sender == _txtType)
                {
                    node.Type = _txtType.Text;
                }
                else if(sender == _txtMethod)
                {
                    node.Method = _txtMethod.Text;
                }
                else
                {
                    Debug.Fail("Unknown sender.");
                }
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //  End Event Handling
        ////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////
        //  Begin Private Class
        ////////////////////////////////////////////////////////////////////////

        // AppliedDeviceFiltersDialog also needs access to this class.
        [
            System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        private class DeviceFilterTreeNode : TreeNode, ICloneable
        {
            internal readonly DeviceFilterNode DeviceFilter;
        
            internal DeviceFilterTreeNode(WebConfigManager webConfig) : base()
            {
                DeviceFilter = new DeviceFilterNode(webConfig);
                base.Text = DeviceFilter.Name;
            }

            internal DeviceFilterTreeNode(DeviceFilterNode node)
            {
                DeviceFilter = node;
                base.Text = node.Name;
            }

            internal new String Text
            {
                get
                {
                    Debug.Assert(DeviceFilter.Name == base.Text);
                    return DeviceFilter.Name;
                }

                set
                {
                    base.Text = value;
                    DeviceFilter.Name = value;
                }
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //  End Private Class
        ////////////////////////////////////////////////////////////////////////
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\externdll.cs ===
//------------------------------------------------------------------------------
// <copyright file="ExternDll.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System {
    internal class ExternDll {

        internal const string Gdiplus = "gdiplus.dll";
        internal const string User32 = "user32.dll";
        internal const string Shfolder = "shfolder.dll";
        internal const string Imm32 = "imm32.dll";
        internal const string Advapi32 = "advapi32.dll";
        internal const string Shell32 = "shell32.dll";
        internal const string Kernel32 = "kernel32.dll";
        internal const string Comctl32 = "comctl32.dll";
        internal const string Oleaut32 = "oleaut32.dll";
        internal const string Olepro32 = "olepro32.dll";
        internal const string Ole32 = "ole32.dll";
        internal const string Gdi32 = "gdi32.dll";
        internal const string Comdlg32 = "comdlg32.dll";
        internal const string Uxtheme = "uxtheme.dll";
        internal const string Oleacc = "oleacc.dll";
        internal const string Hhctrl = "hhctrl.ocx";
        internal const string Winspool = "winspool.drv";
        internal const string Psapi = "psapi.dll";
        internal const string Ntdll = "ntdll.dll";
        internal const string Version = "version.dll";
        internal const string Vsassert = "vsassert.dll";
        internal const string Mscoree = "mscoree.dll";
        internal const string Msi = "msi.dll";
        internal const string Mqrt = "mqrt.dll";
        internal const string Activeds = "activeds.dll";
        internal const string Loadperf = "Loadperf.dll";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\idevicespecificdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDeviceSpecificDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Windows.Forms;

using System.Web.UI.MobileControls;

namespace System.Web.UI.Design.MobileControls
{
    internal interface IDeviceSpecificDesigner
    {
        System.Web.UI.Control UnderlyingControl
        {
            get;
        }

        Object UnderlyingObject
        {
            get;
        }

        System.Windows.Forms.Control Header
        {
            get;
        }

        String CurrentDeviceSpecificID
        {
            get;
        }

        bool GetDeviceSpecific(String deviceSpecificID, out DeviceSpecific ds);
        void SetDeviceSpecificEditor(IRefreshableDeviceSpecificEditor editor);
        void SetDeviceSpecific(String deviceSpecificID, DeviceSpecific deviceSpecific);
        void InitHeader(int mergingContext);
        void RefreshHeader(int mergingContext);
        void UseCurrentDeviceSpecificID();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\devicespecificdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="DeviceSpecificDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Globalization;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Web.UI;
    using System.Web.UI.Design;
    using System.Web.UI.Design.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Util;
    using System.Web.UI.MobileControls;
    using System.Windows.Forms;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DeviceSpecificDesigner : MobileTemplatedControlDesigner, IDeviceSpecificDesigner
    {
        internal static BooleanSwitch DeviceSpecificDesignerSwitch =
            new BooleanSwitch("DeviceSpecificDesigner", "Enable DeviceSpecific designer general purpose traces.");

        private DeviceSpecific _ds;
        private bool _isDuplicate;
        private System.Web.UI.MobileControls.Panel _parentContainer;

        internal static readonly String _strictlyFormPanelContainmentErrorMessage = 
            SR.GetString(SR.MobileControl_StrictlyFormPanelContainmentErrorMessage);

        private const String _designTimeHTML =
            @"
                <table cellpadding=4 cellspacing=0 width='100%' style='font-family:tahoma;font-size:8pt;color:buttontext;background-color:buttonface;border: solid 1px;border-top-color:buttonhighlight;border-left-color:buttonhighlight;border-bottom-color:buttonshadow;border-right-color:buttonshadow'>
                  <tr><td colspan=2><span style='font-weight:bold'>DeviceSpecific</span> - {0}</td></tr>
                  <tr><td style='padding-top:0;padding-bottom:0;width:55%;padding-left:10px;font-weight:bold'>Template Device Filter:</td><td style='padding-top:0;padding-bottom:0'>{1}</td></tr>
                  <tr><td colspan=2 style='padding-top:4px'>{2}</td></tr>
                </table>
             ";

        private const String _duplicateDesignTimeHTML =
            @"
                <table cellpadding=4 cellspacing=0 width='100%' style='font-family:tahoma;font-size:8pt;color:buttontext;background-color:buttonface;border: solid 1px;border-top-color:buttonhighlight;border-left-color:buttonhighlight;border-bottom-color:buttonshadow;border-right-color:buttonshadow'>
                  <tr><td colspan=2><span style='font-weight:bold'>DeviceSpecific</span> - {0}</td></tr>
                  <tr><td style='padding-top:0;padding-bottom:0;width:55%;padding-left:10px;font-weight:bold'>Template Device Filter:</td><td colspan=2 style='padding-top:0;padding-bottom:0'>{1}</td></tr>
                  <tr><td colspan=2 style='padding-top:4px'>{2}</td></tr>
                  <tr><td colspan=2>
                    <table style='font-size:8pt;color:window;background-color:ButtonShadow'>
                      <tr><td valign='top'><img src='{3}'/></td><td>{4}</td></tr>
                    </table>
                  </td></tr>
                </table>
             ";

        private const String _propertyOverridesPropName = "PropertyOverrides";
        private const String _dataBindingsPropName = "DataBindings";

        private const int _headerFooterTemplates            = 0;
        private const int _contentTemplate                  = 0;

        private bool FormDeviceSpecific
        {
            get
            {
                Debug.Assert(_parentContainer != null);
                return _parentContainer is System.Web.UI.MobileControls.Form;
            }
        }

        private static readonly String[] _templateFramesForForm =
            new String [] { Constants.HeaderTemplateTag, Constants.FooterTemplateTag };

        private static readonly String[] _templateFramesForPanel = 
            new String [] { Constants.ContentTemplateTag };

        protected override void Dispose(bool disposing) 
        {
            if (disposing)
            {
                ParentContainerInvalid();
            }

            base.Dispose(disposing);
        }

        protected override TemplateEditingVerb[] GetCachedTemplateEditingVerbs() 
        {
            if (_isDuplicate)
            {
                return null;
            }

            return base.GetCachedTemplateEditingVerbs();
        }

        private void ParentContainerInvalid()
        {
            // MessageBox.Show("ParentContainerInvalid call");
            if (null != _parentContainer && _ds == _parentContainer.DeviceSpecific)
            {
                _parentContainer.DeviceSpecific = null;

                // container's enabled deviceSpecific control is deleted.
                // another disabled deviceSpecific child may need to be enabled.
                foreach (System.Web.UI.Control control in _parentContainer.Controls)
                {
                    if (control is DeviceSpecific && control != _ds)
                    {
                        // found a valid candidate
                        DeviceSpecific newDS = (DeviceSpecific) control;
                        if (newDS.Site != null)
                        {
                            IDesignerHost host = (IDesignerHost) newDS.Site.GetService(typeof(IDesignerHost));
                            Debug.Assert(host != null, "host is null in DeviceSpecificDesigner");
                            IDesigner designer = host.GetDesigner((IComponent) newDS);

                            // this designer could be null if the page is disposing the controls (Page.Dispose).
                            if (designer != null)
                            {
                                _parentContainer.DeviceSpecific = newDS;
                                DeviceSpecificDesigner dsd = (DeviceSpecificDesigner) designer;
                                dsd.TreatAsDuplicate(false);
                                break;
                            }
                        }
                    }
                }
            }
        }

        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.DeviceSpecific,
                         "DeviceSpecificControlDesigner.Initialize - Invalid DeviceSpecific Control");

            _ds = (System.Web.UI.MobileControls.DeviceSpecific) component;
            base.Initialize(component);

            _isDuplicate = false;
        }

        public override DeviceSpecific CurrentDeviceSpecific
        {
            get
            {
                Debug.Assert(null != _ds);
                return _ds;
            }
        }

        protected override String GetDesignTimeNormalHtml()
        {
            String curChoice, message;
            bool _isNonHtmlSchema = false;

            if (null == CurrentChoice)
            {
                curChoice = SR.GetString(SR.DeviceSpecific_PropNotSet);
                message = SR.GetString(SR.DeviceSpecific_DefaultMessage);
            }
            else
            {
                if (String.Empty == CurrentChoice.Filter)
                {
                    curChoice = SR.GetString(SR.DeviceFilter_DefaultChoice);
                }
                else
                {
                    curChoice = HttpUtility.HtmlEncode(DesignerUtility.ChoiceToUniqueIdentifier(CurrentChoice));
                }

                if (IsHTMLSchema(CurrentChoice))
                {
                    message = SR.GetString(SR.DeviceSpecific_TemplateEditingMessage);
                }
                else
                {
                    _isNonHtmlSchema = true;
                    message = SR.GetString(SR.DeviceSpecific_DefaultMessage);
                }
            }

            if (_isDuplicate || _isNonHtmlSchema)
            {
                return String.Format(_duplicateDesignTimeHTML,
                                     new Object[]
                                     {
                                         _ds.Site.Name,
                                         curChoice,
                                         message,
                                         _isDuplicate ? MobileControlDesigner.errorIcon : 
                                         MobileControlDesigner.infoIcon,
                                         _isDuplicate ? 
                                         SR.GetString(SR.DeviceSpecific_DuplicateWarningMessage) :
                                         SR.GetString(SR.DeviceSpecific_NonHTMLSchemaMessage) 
                                     });
            }
            else
            {
                return String.Format(_designTimeHTML, _ds.Site.Name, curChoice, message);
            }
        }

        private bool ValidContainment
        {
            get
            {
                return (ContainmentStatus == ContainmentStatus.InForm ||
                        ContainmentStatus == ContainmentStatus.InPanel);
            }
        }

        protected override String GetErrorMessage(out bool infoMode)
        {
            infoMode = false;

            if (!DesignerAdapterUtil.InMobileUserControl(_ds))
            {
                if (DesignerAdapterUtil.InUserControl(_ds))
                {
                    infoMode = true;
                    return MobileControlDesigner._userControlWarningMessage;
                }

                if (!DesignerAdapterUtil.InMobilePage(_ds))
                {
                    return MobileControlDesigner._mobilePageErrorMessage;
                }
            }
            
            if (!ValidContainment)
            {
                return _strictlyFormPanelContainmentErrorMessage;
            }

            // No error condition, return null;
            return null;
        }

        internal void TreatAsDuplicate(bool isDuplicate)
        {
            if (isDuplicate != _isDuplicate)
            {
                _isDuplicate = isDuplicate;
                SetTemplateVerbsDirty();
                // MessageBox.Show("TreatAsDuplicate: Changing status of " + _ds.Site.Name + " to _isDuplicate=" + _isDuplicate.ToString());
            }
            UpdateDesignTimeHtml();
        }

        public override void OnSetParent() 
        {
            // MessageBox.Show("OnSetParent call for _ds.Site.Name=" + _ds.Site.Name + ", _ds.ID=" + _ds.ID);
            base.OnSetParent();

            Debug.Assert(_ds.Parent != null, "_ds.Parent is null");

            if (null != _parentContainer)
            {
                ParentContainerInvalid();
            }

            System.Web.UI.Control parentContainer = _ds.Parent;

            if (parentContainer is System.Web.UI.MobileControls.Panel)
            {
                _parentContainer = (System.Web.UI.MobileControls.Panel) parentContainer;
                _ds.SetOwner(_parentContainer);

                if (null != _parentContainer.DeviceSpecific &&
                    0 != String.Compare(_ds.ID, _parentContainer.DeviceSpecific.ID, true, CultureInfo.InvariantCulture))
                {
                    // the parent container already has a deviceSpecific child.
                    // this instance is a duplicate and needs to update its rendering.
                    // MessageBox.Show("OnSetParent - this instance is a duplicate");
                    TreatAsDuplicate(true);

                    // the current valid DeviceSpecific is intentionaly refreshed because
                    // if this deviceSpecific instance is recreated via a Undo operation
                    // the current valid DeviceSpecific appears as a duplicate if not refreshed.
                    IDesignerHost host = (IDesignerHost) GetService(typeof(IDesignerHost));
                    Debug.Assert(host != null, "Did not get a valid IDesignerHost reference");
                    IDesigner designer = host.GetDesigner((IComponent) _parentContainer.DeviceSpecific);
                    Debug.Assert(designer != null, "designer is null in DeviceSpecificDesigner");
                    DeviceSpecificDesigner dsd = (DeviceSpecificDesigner) designer;
                    dsd.UpdateRendering();
                }
                else
                {
                    // MessageBox.Show("OnSetParent - this instance becomes the valid ds");
                    _parentContainer.DeviceSpecific = _ds;
                    if (_isDuplicate)
                    {
                        TreatAsDuplicate(false);
                    }
                }
            }
            else
            {
                _parentContainer = null;
            }

            // Invalidate the type descriptor so that the PropertyOverrides
            // property browsable status gets updated
            TypeDescriptor.Refresh(Component);
        }

        protected override String[] GetTemplateFrameNames(int index)
        {
            Debug.Assert(index == 0);
            return FormDeviceSpecific ? _templateFramesForForm : _templateFramesForPanel;
        }

        protected override void PreFilterProperties(IDictionary properties) 
        {
            base.PreFilterProperties(properties);

            PropertyDescriptor prop = (PropertyDescriptor)properties[_propertyOverridesPropName];
            Debug.Assert(prop != null);
            properties[_propertyOverridesPropName] = 
                TypeDescriptor.CreateProperty(
                    GetType(), prop,
                    InTemplateMode || _parentContainer == null? BrowsableAttribute.No : BrowsableAttribute.Yes);

            // hide (DataBindings) property since DeviceSpecific does not have any bindable properties.
            prop = (PropertyDescriptor)properties[_dataBindingsPropName];
            Debug.Assert(prop != null);
            properties[_dataBindingsPropName] = 
                TypeDescriptor.CreateProperty(
                    GetType(), prop,
                    BrowsableAttribute.No);
        }

        protected override TemplateEditingVerb[] GetTemplateVerbs()
        {
            TemplateEditingVerb[] templateVerbs = new TemplateEditingVerb[1];

            if (FormDeviceSpecific)
            {
                templateVerbs[0] = new TemplateEditingVerb(
                    SR.GetString(SR.TemplateFrame_HeaderFooterTemplates),
                    _headerFooterTemplates,
                    this);
            }
            else
            {
                templateVerbs[0] = new TemplateEditingVerb(
                    SR.GetString(SR.TemplateFrame_ContentTemplate),
                    _contentTemplate,
                    this);
            }

            return templateVerbs;
        }
        
        ////////////////////////////////////////////////////////////////////////
        //  Begin IDeviceSpecificDesigner Implementation
        ////////////////////////////////////////////////////////////////////////

        Object IDeviceSpecificDesigner.UnderlyingObject
        {
            get
            {
                return _parentContainer == null ? (Object)_ds : _parentContainer;
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //  End IDeviceSpecificDesigner Implementation
        ////////////////////////////////////////////////////////////////////////
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\ilistdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="IListDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Windows.Forms;

using System.Web.UI.MobileControls;

namespace System.Web.UI.Design.MobileControls
{
    internal interface IListDesigner
    {
        String DataTextField
        {
            get;
            set;
        }

        String DataValueField
        {
            get;
            set;
        }

        String DataSource
        {
            get;
            set;
        }

        String DataMember
        {
            get;
            set;
        }

        MobileListItemCollection Items
        {
            get;
        }

        void OnDataSourceChanged();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\idevicespecificchoicedesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDeviceSpecificChoiceDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;

    internal interface IDeviceSpecificChoiceDesigner
    {
        Object UnderlyingObject { get; }
        System.Web.UI.Control UnderlyingControl { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\imobiledesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="IMobileDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{

    /// <summary>
    ///    <para>
    ///       Provides a contract for all mobile control designers.
    ///    </para>
    /// </summary>
    public interface IMobileDesigner
    {
        void UpdateRendering();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\fieldcollectioneditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="FieldCollectionEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing.Design;
    using System.Web.UI.WebControls;
    using System.Runtime.Serialization.Formatters;

    using ObjectList = System.Web.UI.MobileControls.ObjectList;

    /// <summary>
    ///    <para>
    ///       The editor for column collections.
    ///    </para>
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class FieldCollectionEditor : UITypeEditor 
    {
        /// <summary>
        ///    <para>
        ///       Edits the value specified.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    An <see cref='System.ComponentModel.ITypeDescriptorContext'/> that specifies the context of the value to edit.
        /// </param>
        /// <param name=' provider'>
        ///    An <see cref='System.IServiceProvider'/> .
        /// </param>
        /// <param name=' value'>
        ///    The object to edit.
        /// </param>
        /// <returns>
        ///    <para>
        ///       The updated value.
        ///    </para>
        /// </returns>
        public override Object EditValue(ITypeDescriptorContext context, IServiceProvider provider, Object value) 
        {
            IDesignerHost designerHost = (IDesignerHost)context.GetService(typeof(IDesignerHost));
            Debug.Assert(designerHost != null, "Did not get DesignerHost service.");

            Debug.Assert(context.Instance is ObjectList, "Expected objectlist");
            ObjectList _objectList = (ObjectList)context.Instance;

            ObjectListDesigner _designer = (ObjectListDesigner)designerHost.GetDesigner(_objectList);
            Debug.Assert(_designer != null, "Did not get designer for component");

            _designer.InvokePropertyBuilder(ObjectListComponentEditor.IDX_FIELDS);
            return value;
        }

        /// <summary>
        ///    <para>
        ///       Gets the edit style.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    An <see cref='System.ComponentModel.ITypeDescriptorContext'/> that specifies the associated context.
        /// </param>
        /// <returns>
        ///    <para>
        ///       A <see cref='System.Drawing.Design.UITypeEditorEditStyle'/> that represents the edit style.
        ///    </para>
        /// </returns>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) 
        {
            return UITypeEditorEditStyle.Modal;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\imobilewebformservices.cs ===
//------------------------------------------------------------------------------
// <copyright file="IMobileWebFormServices.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Web.UI.MobileControls;

    /// <summary>
    ///    <para>
    ///       Provides a contract for mobile webform designer.
    ///    </para>
    /// </summary>
    public interface IMobileWebFormServices
    {
        Object GetCache(String controlID, Object key);
        void SetCache(String controlID, Object key, Object value);
        void RefreshPageView();
        void UpdateRenderingRecursive(Control rootControl);
        void ClearUndoStack();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\formdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="FormDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Drawing;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Web.UI.Design.MobileControls.Util;
    using System.Web.UI.Design.MobileControls.Adapters;
    using System.Web.UI.MobileControls;

    using Microsoft.Win32;

    /// <summary>
    ///    <para>
    ///       Provides design-time support for the <see cref='System.Web.UI.MobileControls.Form'/>
    ///       mobile control.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.Web.UI.MobileControls.Form'/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class FormDesigner : MobileContainerDesigner
    {
        private Form   _form;
        private TemporaryBitmapFile _backgroundBmpFile = null;
        private static readonly Attribute[] _emptyAttrs = new Attribute[0];
        private const String _titlePropertyName = "Title";

        public override String ID 
        {
            get 
            {
                return base.ID; 
            }
           
            set 
            {
                base.ID = value;
                ChangeBackgroundImage();
            }
        }

        public virtual String Title
        {
            get
            {
                return _form.Title;
            }

            set
            {
                _form.Title = value;
                ChangeBackgroundImage();
            }
        }

        private bool ValidContainment
        {
            get
            {
                return (ContainmentStatus == ContainmentStatus.AtTopLevel);
            }
        }

        private void ChangeBackgroundImage()
        {
            bool infoMode = false;
            String newMessage = GetErrorMessage(out infoMode);
            OnBackgroundImageChange(newMessage, infoMode);
        }

        protected override void Dispose(bool disposing) 
        {
            if (disposing)
            {
                SystemEvents.UserPreferenceChanged -= 
                    new UserPreferenceChangedEventHandler(this.OnUserPreferenceChanged);
            }

            base.Dispose(disposing);
        }

        protected override String GetErrorMessage(out bool infoMode)
        {
            infoMode = false;

            if (!DesignerAdapterUtil.InMobileUserControl(_form))
            {
                if (DesignerAdapterUtil.InUserControl(_form))
                {
                    infoMode = true;
                    return MobileControlDesigner._userControlWarningMessage;
                }

                if (!DesignerAdapterUtil.InMobilePage(_form))
                {
                    return SR.GetString(SR.MobileControl_MobilePageErrorMessage);
                }
            }

            if (!ValidContainment)
            {
                return SR.GetString(SR.MobileControl_TopPageContainmentErrorMessage);
            }

            return null;
        }

        /// <summary>
        ///    <para>
        ///       Initializes the designer using
        ///       the specified component.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element being designed.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component being
        ///       designed.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is Form,
                         "FormDesigner.Initialize - Invalid Form Control");

            // This must be called first in order to get properties from runtime control.
            base.Initialize(component);

            _form = (Form) component;

            SystemEvents.UserPreferenceChanged += 
                new UserPreferenceChangedEventHandler(this.OnUserPreferenceChanged);
        }

        internal override void OnBackgroundImageChange(String message, bool infoMode)
        {
            ImageCreator.CreateBackgroundImage(
                ref _backgroundBmpFile,
                _form.ID,
                _form.Title,
                message,
                infoMode,
                GetDefaultSize().Width
            );

            SetBehaviorStyle("backgroundImage",
                "url(" + _backgroundBmpFile.Url + ")");
            SetBehaviorStyle(
                "paddingTop",
                _backgroundBmpFile.UnderlyingBitmap.Height + 8
            );
        }

        private void OnUserPreferenceChanged(Object sender, UserPreferenceChangedEventArgs e)
        {
            if (e.Category == UserPreferenceCategory.Color)
            {
                bool infoMode;
                String newMessage = GetErrorMessage(out infoMode);
                OnBackgroundImageChange(newMessage, infoMode);
            }            
        }

        /// <summary>
        ///   Adjust the appearance based on current status.
        /// </summary>
        protected override void OnContainmentChanged()
        {
            base.OnContainmentChanged();

            SetBehaviorStyle("marginTop", ValidContainment ? "5px" : "3px");
            SetBehaviorStyle("marginBottom", ValidContainment ? "5px" : "3px");
            SetBehaviorStyle("marginRight", ValidContainment ? "30%" : "5px");
        }

        protected override void PreFilterProperties(IDictionary properties) 
        {
            base.PreFilterProperties(properties);

            PropertyDescriptor prop = (PropertyDescriptor)properties[_titlePropertyName];
            Debug.Assert(prop != null);
            properties[_titlePropertyName] = 
                TypeDescriptor.CreateProperty(GetType(), prop, _emptyAttrs);
        }

        protected override void SetControlDefaultAppearance()
        {
            base.SetControlDefaultAppearance();

            // Customized border style
            SetBehaviorStyle("borderStyle", "solid");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\irefreshabledevicespecificeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="IRefreshableDeviceSpecificEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System.Web.UI.MobileControls;

    internal interface IRefreshableDeviceSpecificEditor
    {
        bool RequestRefresh();
        void Refresh(String deviceSpecificID, DeviceSpecific deviceSpecific);
        void UnderlyingObjectsChanged();
        void BeginExternalDeviceSpecificEdit();
        void EndExternalDeviceSpecificEdit(bool commitChanges);
        void DeviceSpecificRenamed(String oldDeviceSpecificID, String newDeviceSpecificID);
        void DeviceSpecificDeleted(String DeviceSpecificID);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\imageurleditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageUrlEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    /// <include file='doc\ImageUrlEditor.uex' path='docs/doc[@for="ImageUrlEditor"]/*' />
    /// <devdoc>
    /// </devdoc>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class ImageUrlEditor: System.Web.UI.Design.UrlEditor
    {
        /// <include file='doc\ImageUrlEditor.uex' path='docs/doc[@for="ImageUrlEditor.Caption"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override String Caption
        {
            get
            {
                return SR.GetString(SR.ImageUrlPicker_ImageCaption);
            }
        }

        /// <include file='doc\ImageUrlEditor.uex' path='docs/doc[@for="ImageUrlEditor.Filter"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override String Filter
        {
            get
            {
                return SR.GetString(SR.ImageUrlPicker_ImageFilter);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\linkdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinkDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Web.UI;
    using System.Web.UI.Design;
    using System.Web.UI.Design.MobileControls.Converters;
    using System.Web.UI.MobileControls;
    using System.Web.UI.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Adapters;

    /// <summary>
    ///    <para>
    ///       Provides a designer for the <see cref='System.Web.UI.MobileControls.Link'/>
    ///       control.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.Web.UI.MobileControls.Link'/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class LinkDesigner : MobileControlDesigner
    {
        private System.Web.UI.MobileControls.Link _link;

        /// <summary>
        ///    <para>
        ///       Initializes the designer with the component for design.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element for design.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component for
        ///       design.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.Link,
                         "LinkDesigner.Initialize - Invalid Link Control");
            _link = (System.Web.UI.MobileControls.Link) component;
            base.Initialize(component);
        }

        /// <summary>
        ///    <para>
        ///       Returns the design-time HTML of the <see cref='System.Web.UI.MobileControls.Link'/>
        ///       mobile control
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The HTML of the control.
        ///    </para>
        /// </returns>
        /// <seealso cref='System.Web.UI.MobileControls.Link'/>
        protected override String GetDesignTimeNormalHtml()
        {
            Debug.Assert(null != _link.Text);

            DesignerTextWriter tw;
            Control[] children = null;

            String originalText  = _link.Text;
            bool blankText = (originalText.Trim().Length == 0);
            bool hasControls = _link.HasControls();

            if (blankText)
            {
                if (hasControls) 
                {
                    children = new Control[_link.Controls.Count];
                    _link.Controls.CopyTo(children, 0);
                }
                _link.Text = "[" + _link.ID + "]";
            }
            try
            {
                tw = new DesignerTextWriter();
                _link.Adapter.Render(tw);
            }
            finally
            {
                if (blankText)
                {
                    _link.Text = originalText;
                    if (hasControls) 
                    {
                        foreach (Control c in children) 
                        {
                            _link.Controls.Add(c);
                        }
                    }
                }
            }

            return tw.ToString();
        }

        /// <summary>
        ///    <para>
        ///       Represents the method that will handle the component change event.
        ///    </para>
        /// </summary>
        /// <param name='sender'>
        ///    The source of the event.
        /// </param>
        /// <param name=' e'>
        ///    The <see cref='System.ComponentModel.Design.ComponentChangedEventArgs'/> that provides data about the event.
        /// </param>
        public override void OnComponentChanged(Object sender, ComponentChangedEventArgs e) 
        {
            if ((e.Member != null) && e.Member.Name.Equals("NavigateUrl"))
            {
                _link.NavigateUrl = NavigateUrlConverter.GetUrl(
                    _link,
                    e.NewValue.ToString(),
                    e.OldValue.ToString()
                );

                e = new ComponentChangedEventArgs(e.Component, e.Member, e.OldValue, _link.NavigateUrl);
            }

            base.OnComponentChanged(sender, e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\imagedesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.IO;
    using System.Text;
    using System.Web.UI;
    using System.Web.UI.Design;
    using System.Web.UI.MobileControls;
    using System.Web.UI.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Converters;
    using System.Web.UI.Design.MobileControls.Util;

    using Image = System.Web.UI.MobileControls.Image;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class ImageDesigner : MobileControlDesigner
    {
        private Image                   _image;
        private TemporaryBitmapFile     _tempBmpFile;
        private Uri                     _cachedWbmpUri;
        private String                  _baseUrl = String.Empty;

        private String BaseUrl
        {
            get
            {
                if (_baseUrl == String.Empty)
                {
                    IWebFormsDocumentService wfServices =
                        (IWebFormsDocumentService)GetService(typeof(IWebFormsDocumentService));

                                        Debug.Assert(wfServices != null);
                    _baseUrl = wfServices.DocumentUrl;
                }
                return _baseUrl;
            }
        }

        /// <summary>
        ///    <para>
        ///       Initializes the designer.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element being designed.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component being
        ///       designed.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.Image,
                         "ImageDesigner.Initialize - Invalid Image Control");
            _image = (System.Web.UI.MobileControls.Image) component;
            base.Initialize(component);
        }

        /// <summary>
        ///    <para>
        ///       Disposes of the resources (other than memory) used by the
        ///    <see cref='System.Web.UI.Design.MobileControls.ListDesigner'/>.
        ///    </para>
        /// </summary>
        /// <remarks>
        ///    <para>
        ///       Call <see langword='Dispose'/> when
        ///       you are finished using the <see cref='System.Web.UI.Design.MobileControls.ListDesigner'/>. The <see langword='Dispose'/> method leaves the <see cref='System.Web.UI.Design.WebControls.DataListDesigner'/> in an unusable state. After
        ///       calling <see langword='Dispose'/>, you must release all
        ///       references to the <see cref='System.Web.UI.Design.MobileControls.ListDesigner'/> so the memory it was occupying
        ///       can be reclaimed by garbage collection.
        ///    </para>
        ///    <note type="note">
        ///       Always call <see langword='Dispose'/> before you release your last reference to
        ///       the <see cref='System.Web.UI.Design.MobileControls.ListDesigner'/>. Otherwise, the resources
        ///       the <see cref='System.Web.UI.Design.MobileControls.ListDesigner'/> is using will not be freed
        ///       until garbage collection calls the <see cref='System.Web.UI.Design.MobileControls.ListDesigner'/> object's
        ///       destructor.
        ///    </note>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
                protected override void Dispose(bool disposing) 
                {
                        if (disposing && _tempBmpFile != null)
                        {
                                _tempBmpFile.Dispose();
                                _cachedWbmpUri = null;
                                _tempBmpFile = null;
                        }

            base.Dispose(disposing);
        }

        private String GetConvertedImageURI(String imageUriString)
        {
            Uri baseUri = new Uri(BaseUrl);
            Uri imageUri = new Uri(baseUri, imageUriString);
            String extension = Path.GetExtension(imageUriString);

            if(extension.Equals(".wbmp"))
            {
                if(_tempBmpFile != null)
                {
                    if(_cachedWbmpUri != null
                        && _cachedWbmpUri.Equals(imageUri))
                    {
                        return _tempBmpFile.Url;
                    }
                    else
                    {
                        _tempBmpFile.Dispose();
                        _tempBmpFile = null;
                        _cachedWbmpUri = null;
                    }
                }

                Byte[] buffer = FileReader.Read(imageUri);
                if(buffer == null)
                {
                    // Could not read image from URI, return original URI to
                    // Trident and let it render as a broken image.
                    goto ConversionError;
                }
                Bitmap bitmap = WbmpConverter.Convert(buffer);
                if(bitmap == null)
                {
                    // .wbmp appears to be corrupt, return original URI to
                    // Trident and let it render as a broken image.
                    goto ConversionError;
                }
                _tempBmpFile = new TemporaryBitmapFile(bitmap);
                imageUriString = _tempBmpFile.Url;
                _cachedWbmpUri = imageUri;
            }
ConversionError:
            return imageUriString;
        }


        /// <summary>
        ///    <para>
        ///       Gets the HTML to be used for the design time representation of the control runtime.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The design time HTML.
        ///    </para>
        /// </returns>
        protected override String GetDesignTimeNormalHtml()
        {
            String tempUrl = String.Empty;
            bool replaceUrl = (_image.ImageUrl != String.Empty);
            DesignerTextWriter writer = new DesignerTextWriter();

            tempUrl = _image.ImageUrl;
            _image.ImageUrl = GetConvertedImageURI(_image.ImageUrl);
            _image.Adapter.Render(writer);
            _image.ImageUrl = tempUrl;

            return writer.ToString();
        }

        public override void OnComponentChanged(Object sender, ComponentChangedEventArgs e)
        {
            if ((e.Member != null) && e.Member.Name.Equals("NavigateUrl"))
            {
                _image.NavigateUrl = NavigateUrlConverter.GetUrl(
                    _image,
                    e.NewValue.ToString(),
                    e.OldValue.ToString()
                    );

                e = new ComponentChangedEventArgs(e.Component, e.Member, e.OldValue, _image.NavigateUrl);
            }
             
            base.OnComponentChanged(sender, e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\itemcollectioneditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ItemCollectionEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing.Design;
    using System.Web.UI.MobileControls;
    using System.Web.UI.WebControls;
    using System.Runtime.Serialization.Formatters;

    /// <summary>
    ///    <para>
    ///       The editor for Item collections.
    ///    </para>
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class ItemCollectionEditor : UITypeEditor 
    {
        /// <summary>
        ///    <para>
        ///       Edits the value specified.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    An <see cref='System.ComponentModel.ITypeDescriptorContext'/> that specifies the context of the value to edit.
        /// </param>
        /// <param name=' provider'>
        ///    An <see cref='System.IServiceProvider'/> .
        /// </param>
        /// <param name=' value'>
        ///    The object to edit.
        /// </param>
        /// <returns>
        ///    <para>
        ///       The updated value.
        ///    </para>
        /// </returns>
        public override Object EditValue(ITypeDescriptorContext context, IServiceProvider provider, Object value) 
        {
            IDesignerHost designerHost = (IDesignerHost)context.GetService(typeof(IDesignerHost));
            Debug.Assert(designerHost != null, "Did not get DesignerHost service.");

            Object obj = context.Instance;
            Debug.Assert(obj is List || obj is SelectionList, "Expected List or SelectionList");
            IDesigner designer = designerHost.GetDesigner((IComponent)obj);
            Debug.Assert(designer != null, "Did not get designer for component");

            if (obj is List)
            {
                ((ListDesigner)designer).InvokePropertyBuilder(ListComponentEditor.IDX_ITEMS);
            }
            else
            {
                ((SelectionListDesigner)designer).InvokePropertyBuilder(
                    SelectionListComponentEditor.IDX_ITEMS);
            }

            return value;
        }

        /// <summary>
        ///    <para>
        ///       Gets the edit style.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    An <see cref='System.ComponentModel.ITypeDescriptorContext'/> that specifies the associated context.
        /// </param>
        /// <returns>
        ///    <para>
        ///       A <see cref='System.Drawing.Design.UITypeEditorEditStyle'/> that represents the edit style.
        ///    </para>
        /// </returns>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) 
        {
            return UITypeEditorEditStyle.Modal;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\listcomponenteditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListComponentEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.UI.MobileControls;
    using System.Windows.Forms.Design;

    /// <summary>
    ///    <para>
    ///       Provides a component editor for a Mobile List <see cref='System.Web.UI.MobileControls.List'/>
    ///       control.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.Web.UI.MobileControls.List'/>
    /// <seealso cref='System.Web.UI.Design.MobileControls.ListDesigner'/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class ListComponentEditor : BaseTemplatedMobileComponentEditor 
    {

        // The set of pages used within the List ComponentEditor
        private static Type[] _editorPages = new Type[]
                                             {
                                                 typeof(ListGeneralPage),
                                                 typeof(ListItemsPage)
                                             };

        internal const int IDX_GENERAL = 0;
        internal const int IDX_ITEMS = 1;

        /// <summary>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.MobileControls.ListComponentEditor'/>.
        ///    </para>
        /// </summary>
        public ListComponentEditor() : base(IDX_GENERAL)
        {
        }

        /// <summary>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.MobileControls.ListComponentEditor'/>.
        ///    </para>
        /// </summary>
        /// <param name='initialPage'>
        ///    The index of the initial page.
        /// </param>
        public ListComponentEditor(int initialPage) : base(initialPage)
        {
        }

        /// <summary>
        ///    <para>
        ///       Gets the set of all pages in the <see cref='System.Web.UI.MobileControls.List'/>
        ///       .
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       An array consisting of the set of component editor pages.
        ///    </para>
        /// </returns>
        /// <remarks>
        ///    <note type="inheritinfo">
        ///       This method may
        ///       be overridden to change the set of pages to show.
        ///    </note>
        /// </remarks>
        protected override Type[] GetComponentEditorPages()
        {
            return _editorPages;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\labeldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="LabelDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Web.UI;
    using System.Web.UI.Design;

    using System.Web.UI.MobileControls;
    using System.Web.UI.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Adapters;

    /// <summary>
    ///    <para>
    ///       Provides a designer for the <see cref='System.Web.UI.MobileControls.Label'/>
    ///       control.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.Web.UI.MobileControls.Label'/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class LabelDesigner : MobileControlDesigner
    {
        private System.Web.UI.MobileControls.Label _label;

        /// <summary>
        ///    <para>
        ///       Initializes the designer with the component for design.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element for design.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component for
        ///       design.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.Label,
                         "LabelDesigner.Initialize - Invalid Label Control");
            _label = (System.Web.UI.MobileControls.Label) component;
            base.Initialize(component);
        }

        /// <summary>
        ///    <para>
        ///       Returns the design-time HTML of the <see cref='System.Web.UI.MobileControls.Label'/>
        ///       mobile control
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The HTML of the control.
        ///    </para>
        /// </returns>
        /// <seealso cref='System.Web.UI.MobileControls.Label'/>
        protected override String GetDesignTimeNormalHtml()
        {
            Debug.Assert(null != _label.Text);

            String originalText  = _label.Text;
            DesignerTextWriter tw;
            Control[] children = null;

            bool blankText = (originalText.Trim().Length == 0);
            bool hasControls = _label.HasControls();

            if (blankText)
            {
                if (hasControls) 
                {
                    children = new Control[_label.Controls.Count];
                    _label.Controls.CopyTo(children, 0);
                }
                _label.Text = "[" + _label.ID + "]";
            }
            try
            {
                tw = new DesignerTextWriter();
                _label.Adapter.Render(tw);
            }
            finally
            {
                if (blankText)
                {
                    _label.Text = originalText;
                    if (hasControls) 
                    {
                        foreach (Control c in children) 
                        {
                            _label.Controls.Add(c);
                        }
                    }
                }
            }

            return tw.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\listdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Web.UI;
    using System.Web.UI.Design;
    using System.Web.UI.MobileControls;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;
    using System.Web.UI.Design.MobileControls.Adapters;

    using DataBinding = System.Web.UI.DataBinding;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class ListDesigner :
        MobileTemplatedControlDesigner, IListDesigner, IDataSourceProvider
    {
        private System.Web.UI.MobileControls.List _list;
        private DesignerVerbCollection _designerVerbs;

        private int _numberItems;
        private DataTable _dummyDataTable;
        private DataTable _designTimeDataTable;

        private const String _dataSourcePropertyName        = "DataSource";
        private const String _dataMemberPropertyName        = "DataMember";
        private const String _dataTextFieldPropertyName     = "DataTextField";
        private const String _dataValueFieldPropertyName    = "DataValueField";

        private const int _headerFooterTemplates            = 0;
        private const int _itemTemplates                    = 1;
        private const int _separatorTemplate                = 2;
        private const int _numberOfTemplateFrames           = 3;

        private static readonly String[][] _templateFrameNames =
            new String[][] {
                               new String [] { Constants.HeaderTemplateTag, Constants.FooterTemplateTag },
                               new String [] { Constants.ItemTemplateTag, Constants.AlternatingItemTemplateTag },
                               new String [] { Constants.SeparatorTemplateTag }
                           };
        private static readonly Attribute[] _emptyAttrs = new Attribute[0];

        /// <summary>
        /// </summary>
        public String DataValueField 
        {
            get 
            {
                return _list.DataValueField;
            }
            set
            {
                _list.DataValueField = value;
            }
        }

        /// <summary>
        /// </summary>
        public String DataTextField 
        {
            get 
            {
                return _list.DataTextField;
            }
            set
            {
                _list.DataTextField = value;
            }
        }

        public String DataMember 
        {
            get 
            {
                return _list.DataMember;
            }
            set 
            {
                _list.DataMember = value;
                OnDataSourceChanged();
            }
        }

        public MobileListItemCollection Items
        {
            get
            {
                return _list.Items;
            }
        }

        /// <summary>
        ///    <para>
        ///       Gets or sets the data source property.
        ///    </para>
        /// </summary>
        /// <value>
        ///    <para>
        ///       A string indicating the data source for the designer's control.
        ///    </para>
        /// </value>
        /// <remarks>
        ///    <para>
        ///       Designer implementation of a DataSource property that operates on the
        ///       DataSource property in the control's binding collection.
        ///    </para>
        /// </remarks>
        public String DataSource 
        {
            get 
            {
                DataBinding binding = DataBindings[_dataSourcePropertyName];

                if (binding != null) 
                {
                    return binding.Expression;
                }
                return String.Empty;
            }
            set 
            {
                if ((value == null) || (value.Length == 0)) 
                {
                    DataBindings.Remove(_dataSourcePropertyName);
                }
                else 
                {
                    DataBinding binding = DataBindings[_dataSourcePropertyName];

                    if (binding == null) 
                    {
                        binding = new DataBinding(_dataSourcePropertyName, typeof(IEnumerable), value);
                    }
                    else 
                    {
                        binding.Expression = value;
                    }
                    DataBindings.Add(binding);
                }

                OnDataSourceChanged();
                OnBindingsCollectionChanged(_dataSourcePropertyName);
            }
        }

        /// <summary>
        ///    <para>
        ///       The designer's collection of verbs.
        ///    </para>
        /// </summary>
        /// <value>
        ///    <para>
        ///       An array of type <see cref='DesignerVerb'/> containing the verbs available to the
        ///       designer.
        ///    </para>
        /// </value>
        public override DesignerVerbCollection Verbs 
        {
            get 
            {
                if (_designerVerbs == null)
                {
                    _designerVerbs = base.Verbs;
                    _designerVerbs.Add(new DesignerVerb(SR.GetString(SR.PropertyBuilderVerb), 
                        new EventHandler(this.OnPropertyBuilder)));
                }

                Debug.Assert(_designerVerbs.Count == 2);
                _designerVerbs[0].Enabled = !this.InTemplateMode;
                _designerVerbs[1].Enabled = !this.InTemplateMode;

                return _designerVerbs;
            }
        }

        /// <summary>
        ///    <para>
        ///       Gets sample data matching the schema of the selected data source.
        ///    </para>
        /// </summary>
        /// <param name='minimumRows'>
        ///    The minimum rows of sample data the data source data should contain.
        /// </param>
        /// <param name='dummyDataSource'>
        ///    Whether the data source being returned is a dummy data source.
        /// </param>
        /// <returns>
        ///    <para>
        ///       An IEnumerable containing a live data source for use at
        ///       design time.
        ///    </para>
        /// </returns>
        ///
        private IEnumerable GetDesignTimeDataSource(int minimumRows, out bool dummyDataSource)
        {
            IEnumerable selectedDataSource = GetResolvedSelectedDataSource();
            return GetDesignTimeDataSource(selectedDataSource, minimumRows, out dummyDataSource);
        }

        /// <summary>
        ///    <para>
        ///       Gets sample data matching the schema of the selected data source.
        ///    </para>
        /// </summary>
        /// <param name='selectedDataSource'>
        ///    The selected data source to be used as a reference for the shape of the data.
        /// </param>
        /// <param name='minimumRows'>
        ///    The minimum rows of sample data the data source data should contain.
        /// </param>
        /// <param name='dummyDataSource'>
        ///    Whether the data source being returned is a dummy data source.
        /// </param>
        /// <returns>
        ///    <para>
        ///       An IEnumerable containing
        ///       a live data source for use at design time.
        ///    </para>
        /// </returns>
        ///
        private IEnumerable GetDesignTimeDataSource(IEnumerable selectedDataSource, int minimumRows, out bool dummyDataSource) 
        {
            DataTable dataTable = _designTimeDataTable;
            dummyDataSource = false;

            // use the datatable corresponding to the selected datasource if possible
            if (dataTable == null) 
            {
                if (selectedDataSource != null) 
                {
                    _designTimeDataTable = DesignTimeData.CreateSampleDataTable(selectedDataSource);

                    dataTable = _designTimeDataTable;
                }

                if (dataTable == null) 
                {
                    // fallback on a dummy datasource if we can't create a sample datatable
                    if (_dummyDataTable == null) 
                    {
                        _dummyDataTable = DesignTimeData.CreateDummyDataTable();
                    }

                    dataTable = _dummyDataTable;
                    dummyDataSource = true;
                }
            }

            IEnumerable liveDataSource = DesignTimeData.GetDesignTimeDataSource(dataTable, minimumRows);
            return liveDataSource;
        }

        /// <summary>
        ///    <para>
        ///       Gets the HTML to be used for the design-time representation
        ///       of the control.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The design-time HTML.
        ///    </para>
        /// </returns>
        /// <remarks>
        ///    <para>
        ///       The rule for handing DesignTimeHTML is similar to System.Web.UI.DataList control,
        ///       if list has a HTML templateset, then generate sample data from static data or 
        ///       dynamic data (if static data does not exist). Show the sample data with templates
        ///       applied.
        ///    </para>
        /// </remarks>
        protected override String GetDesignTimeNormalHtml() 
        {
            IEnumerable selectedDataSource = null;
            String oldDataTextField = null, oldDataValueField = null;
            bool dummyDataSource = false;

            DesignerTextWriter writer = new DesignerTextWriter(true);

            // Apply the current device specific
            if (_list.DeviceSpecific != null)
            {
                _list.DeviceSpecific.SetDesignerChoice(CurrentChoice);
            }

            MobileListItemCollection items = _list.Items;
            Debug.Assert(items != null, "Items is null in LisControl");
            MobileListItem[] oldItems = items.GetAll();

            // Hack: If List is templated, use DataBind() to create child controls.
            //       If it is empty, use dummy data source to create fake child controls.
            if (_list.IsTemplated || items.Count == 0)
            {
                int sampleRows = items.Count;

                // If List does not contain any items, use five dummy items.
                if (sampleRows == 0)
                {
                    sampleRows = 5;
                }

                // try designtime databinding.
                selectedDataSource = GetResolvedSelectedDataSource();

                // Recreate the dummy data table, if number of items changed. BUG from webforms
                if (sampleRows != _numberItems)
                {
                    OnDummyDataTableChanged();

                    // keep the new item count
                    _numberItems = sampleRows;
                }

                IEnumerable designTimeDataSource = 
                    GetDesignTimeDataSource(selectedDataSource, sampleRows, out dummyDataSource);

                // If dummy datasource is applied, change the data fields so that 
                // dummy source will be rendered.
                if (dummyDataSource)
                {
                    oldDataTextField = _list.DataTextField;
                    oldDataValueField = _list.DataValueField;
                    _list.DataTextField = "Column0";
                    _list.DataValueField = "Column1";
                }

                try
                {
                    _list.DataSource = designTimeDataSource;
                    _list.DataBind();
                    _list.Adapter.Render(writer);
                }
                finally
                {
                    _list.DataSource = null;

                    // restore the old items since databinding creates items from templates.
                    _list.Items.SetAll(oldItems);

                    // clear all child controls created by databinding.
                    _list.Controls.Clear();

                    if (dummyDataSource)
                    {
                        _list.DataTextField = oldDataTextField;
                        _list.DataValueField = oldDataValueField;
                    }
                }
            }
            // Otherwise, list only contains static items, just render it directly.
            else
            {
                _list.Adapter.Render(writer);
            }

            return writer.ToString();
        }

        public IEnumerable GetResolvedSelectedDataSource() 
        {
            IEnumerable selectedDataSource = null;

            DataBinding binding = DataBindings[_dataSourcePropertyName];

            if (binding != null) 
            {
                selectedDataSource = DesignTimeData.GetSelectedDataSource(_list, binding.Expression, DataMember);
            }

            return selectedDataSource;
        }

        /// <summary>
        ///    <para>
        ///       Gets the selected data source component from the component's container.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       An IEnumerable with the
        ///       selected data source, or <see langword='null'/> if a data source is not found, or if a data
        ///       source with the same name does not exist.
        ///    </para>
        /// </returns>
        /// <seealso cref='System.Web.UI.Design.IDataSourceProvider'/>
        public Object GetSelectedDataSource() 
        {
            Object selectedDataSource = null;

            DataBinding binding = DataBindings[_dataSourcePropertyName];

            if (binding != null) 
            {
                selectedDataSource = DesignTimeData.GetSelectedDataSource(_list, binding.Expression);
            }

            return selectedDataSource;
        }

        public override string GetTemplateContainerDataItemProperty(string templateName) 
        {
            return "DataItem";
        }

        /// <summary>
        ///    <para>
        ///       Gets the template's container's data source.
        ///    </para>
        /// </summary>
        /// <param name='templateName'>
        ///    The name of the template to retrieve the data source for.
        /// </param>
        /// <returns>
        ///    <para>
        ///       An IEnumerable containing the data source or data sources available to
        ///       the template's container.
        ///    </para>
        /// </returns>
        public override IEnumerable GetTemplateContainerDataSource(String templateName) 
        {
            return GetResolvedSelectedDataSource();
        }

        protected override String[] GetTemplateFrameNames(int index)
        {
            Debug.Assert(index >= 0 & index <= _templateFrameNames.Length);
            return _templateFrameNames[index];
        }

        public override Type GetTemplatePropertyParentType(String templateName) 
        {
            return typeof(MobileTemplatedControlDesigner.TemplateContainer);
        }

        protected override TemplateEditingVerb[] GetTemplateVerbs()
        {
            TemplateEditingVerb[] templateVerbs = new TemplateEditingVerb[_numberOfTemplateFrames];

            templateVerbs[_headerFooterTemplates] = new TemplateEditingVerb(
                SR.GetString(SR.TemplateFrame_HeaderFooterTemplates),
                _headerFooterTemplates,
                this);
            templateVerbs[_itemTemplates] = new TemplateEditingVerb(
                SR.GetString(SR.TemplateFrame_ItemTemplates),
                _itemTemplates,
                this);
            templateVerbs[_separatorTemplate] = new TemplateEditingVerb(
                SR.GetString(SR.TemplateFrame_SeparatorTemplate),
                _separatorTemplate,
                this);

            return templateVerbs;
        }

        /// <summary>
        ///    <para>
        ///       Initializes the designer.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element being designed.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component being
        ///       designed.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.List,
                "ListDesigner.Initialize - Invalid List Control");

            _list = (System.Web.UI.MobileControls.List) component;
            base.Initialize(component);

            Debug.Assert(_list.Items != null, "Items cannot be null.");
            _numberItems = _list.Items.Count;
        }

        /// <summary>
        ///    <para>
        ///       Invokes the property builder beginning with the specified page.
        ///    </para>
        /// </summary>
        /// <param name='initialPage'>
        ///    The page to begin with.
        /// </param>
        protected internal void InvokePropertyBuilder(int initialPage) 
        {
            IComponentChangeService changeService = null;
            bool result = false;

            changeService = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            if (changeService != null) 
            {
                try 
                {
                    changeService.OnComponentChanging(_list, null);
                }
                catch (CheckoutException ex) 
                {
                    if (ex == CheckoutException.Canceled)
                    {
                        return;
                    }
                    throw;
                }
            }

            try 
            {
                ListComponentEditor compEditor = new ListComponentEditor(initialPage);
                result = compEditor.EditComponent(_list);
            }
            finally
            {
                if (changeService != null)
                {
                    changeService.OnComponentChanged(_list, null, null, null);

                    if (IMobileWebFormServices != null)
                    {
                        IMobileWebFormServices.ClearUndoStack();
                    }
                }
            }
        }

        /// <summary>
        ///    <para>
        ///       Represents the method that will handle the component change event.
        ///    </para>
        /// </summary>
        /// <param name='sender'>
        ///    The source of the event.
        /// </param>
        /// <param name=' e'>
        ///    The <see cref='System.ComponentModel.Design.ComponentChangedEventArgs'/> that provides data about the event.
        /// </param>
        public override void OnComponentChanged(Object sender, ComponentChangedEventArgs e) 
        {
            if (e.Member != null)
            {
                String memberName = e.Member.Name;
                if (memberName.Equals(_dataSourcePropertyName) || 
                    memberName.Equals(_dataMemberPropertyName))
                {
                    OnDataSourceChanged();
                }
            }

            base.OnComponentChanged(sender, e);
        }

        /// <internalonly/>
        /// <summary>
        ///    <para>
        ///       Raises the DataSourceChanged event.
        ///    </para>
        /// </summary>
        public void OnDataSourceChanged()
        {
            _designTimeDataTable = null;
        }

        private void OnDummyDataTableChanged() 
        {
            _dummyDataTable = null;
        }

        /// <summary>
        ///    <para>
        ///       Represents the method that will handle the property builder event.
        ///    </para>
        /// </summary>
        /// <param name='sender'>
        ///    The source of the event.
        /// </param>
        /// <param name=' e'>
        ///    An EventArgs object that provides data about the event.
        /// </param>
        protected void OnPropertyBuilder(Object sender, EventArgs e) 
        {
            InvokePropertyBuilder(0);
        }

        /// <summary>
        ///    <para>
        ///       Filter the properties to replace the runtime DataSource property
        ///       descriptor with the designer's.
        ///    </para>
        /// </summary>
        /// <param name='properties'>
        ///    The set of properties to filter.
        /// </param>
        /// <seealso cref='IDesignerFilter'/>
        protected override void PreFilterProperties(IDictionary properties) 
        {
            base.PreFilterProperties(properties);

            Type designerType = this.GetType();

            DesignerAdapterUtil.AddAttributesToPropertiesOfDifferentType(
                designerType,
                typeof(String),
                properties,
                _dataSourcePropertyName, 
                new TypeConverterAttribute(typeof(DataSourceConverter)));
            
            DesignerAdapterUtil.AddAttributesToProperty(
                designerType,
                properties,
                _dataMemberPropertyName,
                _emptyAttrs);

            DesignerAdapterUtil.AddAttributesToProperty(
                designerType,
                properties,
                _dataTextFieldPropertyName,
                _emptyAttrs);

            DesignerAdapterUtil.AddAttributesToProperty(
                designerType,
                properties,
                _dataValueFieldPropertyName,
                _emptyAttrs);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\listgeneralpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListGeneralPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Globalization;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Drawing;
    using System.Web.UI;
    using System.Web.UI.MobileControls;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    using System.Web.UI.Design.MobileControls.Util;

    using DataBinding = System.Web.UI.DataBinding;    
    using DataList = System.Web.UI.WebControls.DataList;

    using TextBox = System.Windows.Forms.TextBox;
    using CheckBox = System.Windows.Forms.CheckBox;
    using ComboBox = System.Windows.Forms.ComboBox;
    using Control = System.Windows.Forms.Control;
    using Label = System.Windows.Forms.Label;
    using PropertyDescriptor = System.ComponentModel.PropertyDescriptor;

    /// <summary>
    ///   The General page for the DataList control.
    /// </summary>
    /// <internalonly/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class ListGeneralPage : MobileComponentEditorPage 
    {
        private const int IDX_DECORATION_NONE = 0;
        private const int IDX_DECORATION_BULLETED = 1;
        private const int IDX_DECORATION_NUMBERED = 2;

        private const int IDX_SELECTTYPE_DROPDOWN = 0;
        private const int IDX_SELECTTYPE_LISTBOX = 1;
        private const int IDX_SELECTTYPE_RADIO = 2;
        private const int IDX_SELECTTYPE_MULTISELECTLISTBOX = 3;
        private const int IDX_SELECTTYPE_CHECKBOX = 4;

        private UnsettableComboBox _dataSourceCombo;
        private UnsettableComboBox _dataMemberCombo;
        private UnsettableComboBox _dataTextFieldCombo;
        private UnsettableComboBox _dataValueFieldCombo;
        private ComboBox _decorationCombo;
        private ComboBox _selectTypeCombo;
        private TextBox _itemCountTextBox;
        private TextBox _itemsPerPageTextBox;
        private TextBox _rowsTextBox;

        private DataSourceItem _currentDataSource;
        private bool _dataSourceDirty;
        private bool _isBaseControlList;

        protected override String HelpKeyword 
        {
            get 
            {
                if (_isBaseControlList)
                {
                    return "net.Mobile.ListProperties.General";
                }
                else
                {
                    return "net.Mobile.SelectionListProperties.General";
                }
            }
        }

        /// <summary>
        ///   Initializes the UI of the form.
        /// </summary>
        private void InitForm() 
        {
            Debug.Assert(GetBaseControl() != null);
            _isBaseControlList = (GetBaseControl() is List);   // SelectionList otherwise.

            GroupLabel dataGroup = new GroupLabel();
            Label dataSourceLabel = new Label();
            _dataSourceCombo = new UnsettableComboBox();
            Label dataMemberLabel = new Label();
            _dataMemberCombo = new UnsettableComboBox();
            Label dataTextFieldLabel = new Label();
            _dataTextFieldCombo = new UnsettableComboBox();
            Label dataValueFieldLabel = new Label();
            _dataValueFieldCombo = new UnsettableComboBox();

            GroupLabel appearanceGroup = new GroupLabel();
            GroupLabel pagingGroup = null;
            Label itemCountLabel = null;
            Label itemsPerPageLabel = null;
            Label rowsLabel = null;
            Label decorationLabel = null;
            Label selectTypeLabel = null;

            if (_isBaseControlList)
            {
                pagingGroup = new GroupLabel();
                itemCountLabel = new Label();
                _itemCountTextBox = new TextBox();
                itemsPerPageLabel = new Label();
                _itemsPerPageTextBox = new TextBox();
                decorationLabel = new Label();
                _decorationCombo = new ComboBox();
            }
            else
            {
                rowsLabel = new Label();
                _rowsTextBox = new TextBox();
                selectTypeLabel = new Label();
                _selectTypeCombo = new ComboBox();
            }

            dataGroup.SetBounds(4, 4, 372, 16);
            dataGroup.Text = SR.GetString(SR.ListGeneralPage_DataGroupLabel);
            dataGroup.TabIndex = 0;
            dataGroup.TabStop = false;

            dataSourceLabel.SetBounds(8, 24, 161, 16);
            dataSourceLabel.Text = SR.GetString(SR.ListGeneralPage_DataSourceCaption);
            dataSourceLabel.TabStop = false;
            dataSourceLabel.TabIndex = 1;

            _dataSourceCombo.SetBounds(8, 40, 161, 21);
            _dataSourceCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            _dataSourceCombo.Sorted = true;
            _dataSourceCombo.TabIndex = 2;
            _dataSourceCombo.NotSetText = SR.GetString(SR.ListGeneralPage_UnboundComboEntry);
            _dataSourceCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedDataSource);

            dataMemberLabel.SetBounds(211, 24, 161, 16);
            dataMemberLabel.Text = SR.GetString(SR.ListGeneralPage_DataMemberCaption);
            dataMemberLabel.TabStop = false;
            dataMemberLabel.TabIndex = 3;

            _dataMemberCombo.SetBounds(211, 40, 161, 21);
            _dataMemberCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            _dataMemberCombo.Sorted = true;
            _dataMemberCombo.TabIndex = 4;
            _dataMemberCombo.NotSetText = SR.GetString(SR.ListGeneralPage_NoneComboEntry);
            _dataMemberCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedDataMember);

            dataTextFieldLabel.SetBounds(8, 67, 161, 16);
            dataTextFieldLabel.Text = SR.GetString(SR.ListGeneralPage_DataTextFieldCaption);
            dataTextFieldLabel.TabStop = false;
            dataTextFieldLabel.TabIndex = 5;

            _dataTextFieldCombo.SetBounds(8, 83, 161, 21);
            _dataTextFieldCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            _dataTextFieldCombo.Sorted = true;
            _dataTextFieldCombo.TabIndex = 6;
            _dataTextFieldCombo.NotSetText = SR.GetString(SR.ListGeneralPage_NoneComboEntry);
            _dataTextFieldCombo.SelectedIndexChanged += new EventHandler(this.OnSetPageDirty);

            dataValueFieldLabel.SetBounds(211, 67, 161, 16);
            dataValueFieldLabel.Text = SR.GetString(SR.ListGeneralPage_DataValueFieldCaption);
            dataValueFieldLabel.TabStop = false;
            dataValueFieldLabel.TabIndex = 7;

            _dataValueFieldCombo.SetBounds(211, 83, 161, 21);
            _dataValueFieldCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            _dataValueFieldCombo.Sorted = true;
            _dataValueFieldCombo.TabIndex = 8;
            _dataValueFieldCombo.NotSetText = SR.GetString(SR.ListGeneralPage_NoneComboEntry);
            _dataValueFieldCombo.SelectedIndexChanged += new EventHandler(this.OnSetPageDirty);

            appearanceGroup.SetBounds(4, 120, 372, 16);
            appearanceGroup.Text = SR.GetString(SR.ListGeneralPage_AppearanceGroupLabel);
            appearanceGroup.TabIndex = 9;
            appearanceGroup.TabStop = false;
            
            if (_isBaseControlList)
            {
                decorationLabel.SetBounds(8, 140, 200, 16);
                decorationLabel.Text = SR.GetString(SR.ListGeneralPage_DecorationCaption);
                decorationLabel.TabStop = false;
                decorationLabel.TabIndex = 10;

                _decorationCombo.SetBounds(8, 156, 161, 21);
                _decorationCombo.DropDownStyle = ComboBoxStyle.DropDownList;
                _decorationCombo.SelectedIndexChanged += new EventHandler(this.OnSetPageDirty);
                _decorationCombo.Items.AddRange(new object[] {
                                                               SR.GetString(SR.ListGeneralPage_DecorationNone),
                                                               SR.GetString(SR.ListGeneralPage_DecorationBulleted),
                                                               SR.GetString(SR.ListGeneralPage_DecorationNumbered)
                                                             });
                _decorationCombo.TabIndex = 11;

                pagingGroup.SetBounds(4, 193, 372, 16);
                pagingGroup.Text = SR.GetString(SR.ListGeneralPage_PagingGroupLabel);
                pagingGroup.TabIndex = 12;
                pagingGroup.TabStop = false;
            
                itemCountLabel.SetBounds(8, 213, 161, 16);
                itemCountLabel.Text = SR.GetString(SR.ListGeneralPage_ItemCountCaption);
                itemCountLabel.TabStop = false;
                itemCountLabel.TabIndex = 13;

                _itemCountTextBox.SetBounds(8, 229, 161, 20);
                _itemCountTextBox.TextChanged += new EventHandler(this.OnSetPageDirty);
                _itemCountTextBox.KeyPress += new KeyPressEventHandler(this.OnKeyPressNumberTextBox);
                _itemCountTextBox.TabIndex = 14;
            
                itemsPerPageLabel.SetBounds(211, 213, 161, 16);
                itemsPerPageLabel.Text = SR.GetString(SR.ListGeneralPage_ItemsPerPageCaption);
                itemsPerPageLabel.TabStop = false;
                itemsPerPageLabel.TabIndex = 15;

                _itemsPerPageTextBox.SetBounds(211, 229, 161, 20);
                _itemsPerPageTextBox.TextChanged += new EventHandler(this.OnSetPageDirty);
                _itemsPerPageTextBox.KeyPress += new KeyPressEventHandler(this.OnKeyPressNumberTextBox);
                _itemsPerPageTextBox.TabIndex = 16;
            }
            else
            {
                selectTypeLabel.SetBounds(8, 140, 161, 16);
                selectTypeLabel.Text = SR.GetString(SR.ListGeneralPage_SelectTypeCaption);
                selectTypeLabel.TabStop = false;
                selectTypeLabel.TabIndex = 10;

                _selectTypeCombo.SetBounds(8, 156, 161, 21);
                _selectTypeCombo.DropDownStyle = ComboBoxStyle.DropDownList;
                _selectTypeCombo.SelectedIndexChanged += new EventHandler(this.OnSetPageDirty);
                _selectTypeCombo.Items.AddRange(new object[] {
                                                                SR.GetString(SR.ListGeneralPage_SelectTypeDropDown),
                                                                SR.GetString(SR.ListGeneralPage_SelectTypeListBox),
                                                                SR.GetString(SR.ListGeneralPage_SelectTypeRadio),
                                                                SR.GetString(SR.ListGeneralPage_SelectTypeMultiSelectListBox),
                                                                SR.GetString(SR.ListGeneralPage_SelectTypeCheckBox)
                                                             });
                _selectTypeCombo.TabIndex = 11;

                rowsLabel.SetBounds(211, 140, 161, 16);
                rowsLabel.Text = SR.GetString(SR.ListGeneralPage_RowsCaption);
                rowsLabel.TabStop = false;
                rowsLabel.TabIndex = 12;

                _rowsTextBox.SetBounds(211, 156, 161, 20);
                _rowsTextBox.TextChanged += new EventHandler(this.OnSetPageDirty);
                _rowsTextBox.KeyPress += new KeyPressEventHandler(this.OnKeyPressNumberTextBox);
                _rowsTextBox.TabIndex = 13;
            }

            this.Text = SR.GetString(SR.ListGeneralPage_Title);
            this.Size = new Size(382, 270);
            this.CommitOnDeactivate = true;
            this.Icon = new Icon(
                typeof(System.Web.UI.Design.MobileControls.MobileControlDesigner),
                "General.ico"
            );

            this.Controls.AddRange(new Control[] 
                           {
                               _dataTextFieldCombo,
                               dataTextFieldLabel,
                               _dataValueFieldCombo,
                               dataValueFieldLabel,
                               _dataMemberCombo,
                               dataMemberLabel,
                               _dataSourceCombo,
                               dataSourceLabel,
                               dataGroup,
                               appearanceGroup
                           });

            if (_isBaseControlList)
            {
                this.Controls.AddRange(new Control[] 
                           {
                               _itemsPerPageTextBox,
                               itemsPerPageLabel,
                               _itemCountTextBox,
                               itemCountLabel,
                               pagingGroup,
                               decorationLabel,
                               _decorationCombo
                           });
            }
            else
            {
                this.Controls.AddRange(new Control[] 
                           {
                               _rowsTextBox,
                               rowsLabel,
                               selectTypeLabel,
                               _selectTypeCombo
                           });
            }
        }

        /// <summary>
        ///   Initializes the page before it can be loaded with the component.
        /// </summary>
        private void InitPage() 
        {
            _dataSourceCombo.SelectedIndex = -1;
            _dataSourceCombo.Items.Clear();
            _currentDataSource = null;
            _dataMemberCombo.SelectedIndex = -1;
            _dataMemberCombo.Items.Clear();
            _dataTextFieldCombo.SelectedIndex = -1;
            _dataTextFieldCombo.Items.Clear();
            _dataValueFieldCombo.SelectedIndex = -1;
            _dataValueFieldCombo.Items.Clear();
            _dataSourceDirty = false;
        }

        protected override void LoadComponent() 
        {
            InitPage();
            LoadDataSourceItems();
            IListDesigner listDesigner = (IListDesigner)GetBaseDesigner();

            if (_dataSourceCombo.Items.Count > 0) 
            {
                String dataSourceValue = listDesigner.DataSource;

                if (dataSourceValue != null) 
                {
                    int dataSourcesAvailable = _dataSourceCombo.Items.Count;
                    // starting at index 1 because first entry is (unbound).
                    for (int j = 1; j < dataSourcesAvailable; j++) 
                    {
                        DataSourceItem dataSourceItem =
                            (DataSourceItem)_dataSourceCombo.Items[j];

                        if (String.Compare(dataSourceItem.Name, dataSourceValue, true, CultureInfo.InvariantCulture) == 0)
                        {
                            _dataSourceCombo.SelectedIndex = j;
                            _currentDataSource = dataSourceItem;
                            LoadDataMembers();

                            if (_currentDataSource is ListSourceDataSourceItem) 
                            {
                                String dataMember = listDesigner.DataMember;
                                _dataMemberCombo.SelectedIndex = _dataMemberCombo.FindStringExact(dataMember);

                                if (_dataMemberCombo.IsSet()) 
                                {
                                    ((ListSourceDataSourceItem)_currentDataSource).CurrentDataMember = dataMember;
                                }
                            }

                            LoadDataSourceFields();

                            break;
                        }
                    }
                }
            }

            String dataTextField = listDesigner.DataTextField;
            String dataValueField = listDesigner.DataValueField;

            if (dataTextField.Length != 0) 
            {
                int textFieldIndex = _dataTextFieldCombo.FindStringExact(dataTextField);
                _dataTextFieldCombo.SelectedIndex = textFieldIndex;
            }

            if (dataValueField.Length != 0) 
            {
                int textValueIndex = _dataValueFieldCombo.FindStringExact(dataValueField);
                _dataValueFieldCombo.SelectedIndex = textValueIndex;
            }

            if (_isBaseControlList)
            {
                List list = (List)GetBaseControl();
                _itemCountTextBox.Text = list.ItemCount.ToString();
                _itemsPerPageTextBox.Text = list.ItemsPerPage.ToString();

                switch (list.Decoration) 
                {
                    case ListDecoration.None:
                        _decorationCombo.SelectedIndex = IDX_DECORATION_NONE;
                        break;
                    case ListDecoration.Bulleted:
                        _decorationCombo.SelectedIndex = IDX_DECORATION_BULLETED;
                        break;
                    case ListDecoration.Numbered:
                        _decorationCombo.SelectedIndex = IDX_DECORATION_NUMBERED;
                        break;
                }
            }
            else
            {
                SelectionList selectionList = (SelectionList)GetBaseControl();

                switch (selectionList.SelectType) 
                {
                    case ListSelectType.DropDown:
                        _selectTypeCombo.SelectedIndex = IDX_SELECTTYPE_DROPDOWN;
                        break;
                    case ListSelectType.ListBox:
                        _selectTypeCombo.SelectedIndex = IDX_SELECTTYPE_LISTBOX;
                        break;
                    case ListSelectType.Radio:
                        _selectTypeCombo.SelectedIndex = IDX_SELECTTYPE_RADIO;
                        break;
                    case ListSelectType.MultiSelectListBox:
                        _selectTypeCombo.SelectedIndex = IDX_SELECTTYPE_MULTISELECTLISTBOX;
                        break;
                    case ListSelectType.CheckBox:
                        _selectTypeCombo.SelectedIndex = IDX_SELECTTYPE_CHECKBOX;
                        break;
                }

                _rowsTextBox.Text = selectionList.Rows.ToString();
            }

            UpdateEnabledVisibleState();
        }

        /// <summary>
        /// </summary>
        private void LoadDataMembers() 
        {
            using (new LoadingModeResource(this))
            {
                _dataMemberCombo.SelectedIndex = -1;
                _dataMemberCombo.Items.Clear();
                _dataMemberCombo.EnsureNotSetItem();

                if ((_currentDataSource != null) && (_currentDataSource is ListSourceDataSourceItem)) 
                {
                    String[] dataMembers = ((ListSourceDataSourceItem)_currentDataSource).DataMembers;

                    for (int i = 0; i < dataMembers.Length; i++) 
                    {
                        _dataMemberCombo.AddItem(dataMembers[i]);
                    }
                }
            }
        }

        /// <summary>
        /// </summary>
        private void LoadDataSourceFields() 
        {
            using (new LoadingModeResource(this))
            {
                _dataTextFieldCombo.SelectedIndex = -1;
                _dataTextFieldCombo.Items.Clear();
                _dataTextFieldCombo.EnsureNotSetItem();

                _dataValueFieldCombo.SelectedIndex = -1;
                _dataValueFieldCombo.Items.Clear();
                _dataValueFieldCombo.EnsureNotSetItem();

                if (_currentDataSource != null) 
                {
                    PropertyDescriptorCollection fields = _currentDataSource.Fields;

                    if (fields != null) 
                    {
                        IEnumerator fieldEnum = fields.GetEnumerator();
                        while (fieldEnum.MoveNext()) 
                        {
                            PropertyDescriptor fieldDesc = (PropertyDescriptor)fieldEnum.Current;

                            if (BaseDataList.IsBindableType(fieldDesc.PropertyType)) 
                            {
                                _dataTextFieldCombo.AddItem(fieldDesc.Name);
                                _dataValueFieldCombo.AddItem(fieldDesc.Name);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        ///   Loads the list of available IEnumerable components
        /// </summary>
        private void LoadDataSourceItems() 
        {
            _dataSourceCombo.EnsureNotSetItem();

            ISite thisSite = GetSelectedComponent().Site;

            if (thisSite != null) 
            {
                IContainer container = (IContainer)thisSite.GetService(typeof(IContainer));

                if (container != null) 
                {
                    ComponentCollection allComponents = container.Components;
                    if (allComponents != null) 
                    {
                        foreach (IComponent comp in (IEnumerable)allComponents) 
                        {
                            if ((comp is IEnumerable) || (comp is IListSource)) 
                            {
                                // must have a valid site and a name
                                ISite componentSite = comp.Site;
                                if ((componentSite == null) || (componentSite.Name == null) ||
                                    (componentSite.Name.Length == 0))
                                {
                                    continue;
                                }

                                DataSourceItem dsItem;
                                if (comp is IListSource) 
                                {
                                    // an IListSource
                                    IListSource listSource = (IListSource)comp;
                                    dsItem = new ListSourceDataSourceItem(componentSite.Name, listSource);
                                }
                                else 
                                {
                                    // found an IEnumerable
                                    IEnumerable dataSource = (IEnumerable)comp;
                                    dsItem = new DataSourceItem(componentSite.Name, dataSource);
                                }
                                _dataSourceCombo.AddItem(dsItem);
                            }
                        }
                    }
                }
            }
        }

        private void OnSetPageDirty(Object source, EventArgs e) 
        {
            if (IsLoading())
            {
                return;
            }
            SetDirty();
        }

        private void OnKeyPressNumberTextBox(Object source, KeyPressEventArgs e)
        {
            if (!((e.KeyChar >='0' && e.KeyChar <= '9') ||
                  e.KeyChar == 8))
            {
                e.Handled = true;
                SafeNativeMethods.MessageBeep(unchecked((int)0xFFFFFFFF));
            }
        }

        /// <summary>
        ///   Handles changes in the datamember selection
        /// </summary>
        private void OnSelChangedDataMember(Object source, EventArgs e) 
        {
            if (IsLoading())
            {
                return;
            }

            String newDataMember = null;
            if (_dataMemberCombo.IsSet())
            {
                newDataMember = (String)_dataMemberCombo.SelectedItem;
            }

            Debug.Assert((_currentDataSource != null) && (_currentDataSource is ListSourceDataSourceItem));
            ((ListSourceDataSourceItem)_currentDataSource).CurrentDataMember = newDataMember;

            LoadDataSourceFields();
            _dataSourceDirty = true;

            SetDirty();
            UpdateEnabledVisibleState();
        }

        /// <summary>
        ///   Handles changes in the datasource selection.
        /// </summary>
        private void OnSelChangedDataSource(Object source, EventArgs e) 
        {
            if (IsLoading())
            {
                return;
            }

            DataSourceItem newDataSource = null;

            if (_dataSourceCombo.IsSet())
            {
                newDataSource = (DataSourceItem)_dataSourceCombo.SelectedItem;
            }

            if (newDataSource != null) 
            {
                if (newDataSource.IsSelectable() == false) 
                {
                    using (new LoadingModeResource(this))
                    {
                        if (_currentDataSource == null) 
                        {
                            _dataSourceCombo.SelectedIndex = -1;
                        }
                        else 
                        {
                            _dataSourceCombo.SelectedItem = _currentDataSource;
                        }
                    }
                    return;
                }
            }
            _currentDataSource = newDataSource;
            if (_currentDataSource is ListSourceDataSourceItem)
            {
                ((ListSourceDataSourceItem)_currentDataSource).CurrentDataMember = null;
            }

            LoadDataMembers();
            LoadDataSourceFields();
            _dataSourceDirty = true;

            SetDirty();
            UpdateEnabledVisibleState();
        }

        /// <summary>
        ///   Saves the component loaded into the page.
        /// </summary>
        /// <seealso cref="System.Windows.Forms.Design.ComponentEditorPage"/>
        protected override void SaveComponent() 
        {
            String dataTextField = String.Empty;
            String dataValueField = String.Empty;
            IListDesigner listDesigner = (IListDesigner)GetBaseDesigner();

            if (_dataTextFieldCombo.IsSet())
            {
                dataTextField  = (String)_dataTextFieldCombo.SelectedItem;
            }
            if (_dataValueFieldCombo.IsSet())
            {
                dataValueField = (String)_dataValueFieldCombo.SelectedItem;
            }
            listDesigner.DataTextField  = dataTextField;
            listDesigner.DataValueField = dataValueField;

            if (_dataSourceDirty) 
            {
                // save the datasource as a binding on the control
                DataBindingCollection dataBindings = ((HtmlControlDesigner)listDesigner).DataBindings;

                if (_currentDataSource == null) 
                {
                    listDesigner.DataSource = String.Empty;
                    listDesigner.DataMember = String.Empty;
                }
                else 
                {
                    listDesigner.DataSource = _currentDataSource.ToString();
                    if (_dataMemberCombo.IsSet()) 
                    {
                        listDesigner.DataMember = (String)_dataMemberCombo.SelectedItem;
                    }
                    else 
                    {
                        listDesigner.DataMember = String.Empty;
                    }
                }

                listDesigner.OnDataSourceChanged();
            }

            if (_isBaseControlList)
            {
                List list = (List)GetBaseControl();

                switch (_decorationCombo.SelectedIndex) 
                {
                    case IDX_DECORATION_NONE:
                        list.Decoration = ListDecoration.None;
                        break;
                    case IDX_DECORATION_BULLETED:
                        list.Decoration = ListDecoration.Bulleted;
                        break;
                    case IDX_DECORATION_NUMBERED:
                        list.Decoration = ListDecoration.Numbered;
                        break;
                }

                try
                {
                    int itemCount = 0;

                    if (_itemCountTextBox.Text.Length != 0)
                    {
                        itemCount = Int32.Parse(_itemCountTextBox.Text, CultureInfo.InvariantCulture);
                    }
                    list.ItemCount = itemCount;
                }
                catch (Exception)
                {
                    _itemCountTextBox.Text = list.ItemCount.ToString();
                }

                try
                {
                    int itemsPerPage = 0;

                    if (_itemsPerPageTextBox.Text.Length != 0)
                    {
                        itemsPerPage = Int32.Parse(_itemsPerPageTextBox.Text, CultureInfo.InvariantCulture);
                    }
                    list.ItemsPerPage = itemsPerPage;
                }
                catch (Exception)
                {
                    _itemsPerPageTextBox.Text = list.ItemsPerPage.ToString();
                }

                TypeDescriptor.Refresh(list);
            }
            else
            {
                // BUGBUG: handle case where entry is "000" if we decide to disallow this.
                SelectionList selectionList = (SelectionList)GetBaseControl();

                switch (_selectTypeCombo.SelectedIndex) 
                {
                    case IDX_SELECTTYPE_DROPDOWN:
                        selectionList.SelectType = ListSelectType.DropDown;
                        break;
                    case IDX_SELECTTYPE_LISTBOX:
                        selectionList.SelectType = ListSelectType.ListBox;
                        break;
                    case IDX_SELECTTYPE_RADIO:
                        selectionList.SelectType = ListSelectType.Radio;
                        break;
                    case IDX_SELECTTYPE_MULTISELECTLISTBOX:
                        selectionList.SelectType = ListSelectType.MultiSelectListBox;
                        break;
                    case IDX_SELECTTYPE_CHECKBOX:
                        selectionList.SelectType = ListSelectType.CheckBox;
                        break;
                }

                try
                {
                    int rows = 4;

                    if (_rowsTextBox.Text.Length != 0)
                    {
                        rows = Int32.Parse(_rowsTextBox.Text, CultureInfo.InvariantCulture);
                    }
                    selectionList.Rows = rows;
                }
                catch (Exception)
                {
                    _rowsTextBox.Text = selectionList.Rows.ToString();
                }

                TypeDescriptor.Refresh(selectionList);
            }
        }

        /// <summary>
        ///   Sets the component that is to be edited in the page.
        /// </summary>
        /// <seealso cref="System.Windows.Forms.Design.ComponentEditorPage"/>
        public override void SetComponent(IComponent component) 
        {
            base.SetComponent(component);
            InitForm();
        }

        /// <summary>
        /// </summary>
        private void UpdateEnabledVisibleState() 
        {
            bool dataSourceSelected = (_currentDataSource != null);

            _dataMemberCombo.Enabled = (dataSourceSelected && (_currentDataSource is ListSourceDataSourceItem));
            _dataTextFieldCombo.Enabled = dataSourceSelected;
            _dataValueFieldCombo.Enabled = dataSourceSelected;
        }

        /// <summary>
        ///   This contains information about a datasource and is used to populate
        ///   the datasource combo. This is used in the General page for a List
        /// </summary>
        [
            System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        private class DataSourceItem 
        {
            private IEnumerable runtimeDataSource;
            private String dataSourceName;
            private PropertyDescriptorCollection dataFields;

            internal DataSourceItem(String dataSourceName, IEnumerable runtimeDataSource) 
            {
                Debug.Assert(dataSourceName != null, "invalid name for datasource");

                this.runtimeDataSource = runtimeDataSource;
                this.dataSourceName = dataSourceName;
            }

            internal PropertyDescriptorCollection Fields 
            {
                get 
                {
                    if (dataFields == null) 
                    {
                        IEnumerable ds = RuntimeDataSource;
                        if (ds != null) 
                        {
                            dataFields = DesignTimeData.GetDataFields(ds);
                        }
                    }
                    if (dataFields == null) 
                    {
                        dataFields = new PropertyDescriptorCollection(null);
                    }
                    return dataFields;
                }
            }
            internal String Name 
            {
                get 
                {
                    return dataSourceName;
                }
            }

            protected virtual Object RuntimeComponent 
            {
                get
                {
                    return runtimeDataSource;
                }
            }

            protected virtual IEnumerable RuntimeDataSource 
            {
                get
                {
                    return runtimeDataSource;
                }
            }

            protected void ClearFields() 
            {
                dataFields = null;
            }

            internal bool IsSelectable() 
            {
                Object runtimeComp = this.RuntimeComponent;
                Debug.Assert(runtimeComp != null);

                // the selected datasource must not be private
                MemberAttributes modifiers = 0;
                PropertyDescriptor modifiersProp = TypeDescriptor.GetProperties(runtimeComp)["Modifiers"];
                if (modifiersProp != null) 
                {
                    modifiers = (MemberAttributes)modifiersProp.GetValue(runtimeComp);
                }

                if (modifiers == MemberAttributes.Private)
                {
                    String message = String.Format(SR.GetString(SR.ListGeneralPage_PrivateMemberMessage), dataSourceName);
                    String caption = SR.GetString(SR.ListGeneralPage_PrivateMemberCaption);

                    MessageBox.Show(message, caption, MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                    return false;
                }

                // ok to select
                return true;
            }

            public override String ToString() 
            {
                return this.Name;
            }
        }

        /// <summary>
        /// </summary>
        [
            System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        private class ListSourceDataSourceItem : DataSourceItem 
        {
            private IListSource _runtimeListSource;
            private String _currentDataMember;
            private String[] _dataMembers;

            internal ListSourceDataSourceItem(String dataSourceName, IListSource runtimeListSource) :
                base(dataSourceName, null) 
            {
                Debug.Assert(runtimeListSource != null);
                _runtimeListSource = runtimeListSource;
            }

            internal String CurrentDataMember 
            {
                get 
                {
                    return _currentDataMember;
                }
                set 
                {
                    _currentDataMember = value;
                    ClearFields();
                }
            }

            internal String[] DataMembers 
            {
                get 
                {
                    if (_dataMembers == null) 
                    {
                        _dataMembers = DesignTimeData.GetDataMembers(_runtimeListSource);
                    }
                    return _dataMembers;
                }
            }
                
            protected override Object RuntimeComponent 
            {
                get 
                {
                    return _runtimeListSource;
                }
            }

            protected override IEnumerable RuntimeDataSource 
            {
                get 
                {
                    return DesignTimeData.GetDataMember(_runtimeListSource, _currentDataMember);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\listcomponenteditorpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListComponentEditorPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Globalization;
    using System.Diagnostics;
    using System.Web.UI.MobileControls;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    using System.Web.UI.Design.MobileControls.Util;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal abstract class ListComponentEditorPage : MobileComponentEditorPage
    {
        protected bool CaseSensitive;
        protected EditableTreeList TreeList = null;
        protected ListTreeNode CurrentNode = null;
        protected String TreeViewTitle = String.Empty;
        protected String AddButtonTitle = String.Empty;
        protected String DefaultName = String.Empty;
        protected String MessageTitle = String.Empty;
        protected String EmptyNameMessage = String.Empty;
        // protected String DuplicateNameMessage = String.Empty; // AUI 2292
        // protected String InvalidNameMessage = String.Empty; // AUI 4240
        // private bool _newLabelSetDirty = true;  // AUI 4452

        protected int Y = 16;
        protected static readonly int X = 238;
        protected static readonly int ControlWidth = 152;
        protected static readonly int LabelHeight  = 16;
        protected static readonly int CellSpace    = 27;
        protected static readonly int Index        = 200;
        protected static readonly int CmbHeight    = 20;

        protected virtual bool FilterIllegalName()
        {
            return true;
        }

        protected virtual void InitForm()
        {
            TreeList = new EditableTreeList(true, CaseSensitive, Y);
            TreeList.TabIndex = 0;
            TreeList.LblTitle.Text = TreeViewTitle;
            TreeList.BtnAdd.Text = AddButtonTitle;

            TreeList.TvList.AfterLabelEdit += new NodeLabelEditEventHandler(OnAfterLabelEdit);
            TreeList.TvList.BeforeLabelEdit += new NodeLabelEditEventHandler(OnBeforeLabelEdit);
            TreeList.TvList.AfterSelect += new TreeViewEventHandler(OnNodeSelected);
            TreeList.BtnAdd.Click += new EventHandler(OnClickAddButton);
            TreeList.BtnRemove.Click += new EventHandler(OnClickRemoveButton);
            TreeList.BtnUp.Click += new EventHandler(OnClickUpButton);
            TreeList.BtnDown.Click += new EventHandler(OnClickDownButton);

            this.Controls.AddRange(new Control[] {TreeList /*, grplblProperties*/});
        }

        protected virtual void InitPage()
        {
            TreeList.TvList.Nodes.Clear();
            TreeList.TvList.SelectedNode = null;
        }

        private void InitTree()
        {
            LoadItems();
            if (TreeList.TvList.Nodes.Count > 0)
            {
                CurrentNode = (ListTreeNode)TreeList.TvList.Nodes[0];
                TreeList.TvList.SelectedNode = CurrentNode;
                LoadItemProperties();
            }
        }

        /// <summary>
        ///   Loads the component into the page.
        /// </summary>
        /// <seealso class="System.ComponentModel.ComponentEditorPage"/>
        protected override sealed void LoadComponent() 
        {
            InitPage();
            InitTree();

            UpdateControlsEnabling();
        }

        protected abstract void LoadItems();
        protected abstract void LoadItemProperties();

        protected override void SaveComponent()
        {
            foreach (ListTreeNode node in TreeList.TvList.Nodes)
            {
                if (node.IsEditing)
                {
                    // commit changes if still in editing mode.
                    node.EndEdit(false);
                }
            }
        }

        public override sealed void SetComponent(IComponent component)
        {
            base.SetComponent(component);

            Debug.Assert (component is ObjectList | component is List | 
                component is SelectionList, "Invalid Component");

            InitForm();
        }

        protected virtual String GetNewName()
        {
            int i = 1;
            while (NameExists(DefaultName + i.ToString()))
            {
                i++;
            }
            return DefaultName + i.ToString();
        }

        protected bool NameExists(String name)
        {
            foreach (ListTreeNode node in TreeList.TvList.Nodes)
            {
                if (String.Compare(node.Name, name, !CaseSensitive, CultureInfo.InvariantCulture) == 0)
                {
                    return true;
                }
            }
            return false;
        }

        protected virtual void OnAfterLabelEdit(Object source, NodeLabelEditEventArgs e)
        {
            Debug.Assert(null != e);
            Debug.Assert(e.CancelEdit == false);

            // this happens when the label is unchanged after entering and exiting
            // label editing mode - bizarre behavior. this may be a bug in treeview
            if (null == e.Label)
            {
                return;
            }

            if (FilterIllegalName())
            {
                bool cancel = true;

/* AUI 2292
                if (String.Compare(e.Node.Text, e.Label, true) != 0 && NameExists(e.Label))
                {
                    MessageBox.Show(
                        String.Format(DuplicateNameMessage,  e.Label),
                        MessageTitle,
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Exclamation);
                }
*/
                // can't accept an empty node name
                if (String.Empty == e.Label)
                {
                    MessageBox.Show(
                        EmptyNameMessage, 
                        MessageTitle,
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Exclamation);
                }
                /* Removed for DCR 4240
                // can't accept an illegal node name
                else if (!IsValidName(e.Label))
                {
                    MessageBox.Show(
                        InvalidNameMessage,
                        MessageTitle, 
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Exclamation);
                }
                */
                else
                {
                    cancel = false;
                }

                if (cancel)
                {
                    e.CancelEdit = true;
                    return;
                }
            }

            CurrentNode.Name = e.Label;
            CurrentNode.Dirty = true;

            SetDirty();

            /* pulled out because of 4452
            if (_newLabelSetDirty)
            {
                SetDirty();
            }
            */

            OnNodeRenamed();
        }

        private void OnBeforeLabelEdit(Object source, NodeLabelEditEventArgs e)
        {
            SetDirty();
        }

        private void OnClickDownButton(Object source, EventArgs e)
        {
            if (IsLoading())
            {
                return;
            }

            SetDirty();
        }

        private void OnClickUpButton(Object source, EventArgs e)
        {
            if (IsLoading())
            {
                return;
            }

            SetDirty();
        }

        protected virtual void OnNodeSelected(Object source, TreeViewEventArgs e)
        {
            if (IsLoading())
            {
                return;
            }

            CurrentNode = (ListTreeNode) TreeList.TvList.SelectedNode;

            LoadItemProperties();
            UpdateControlsEnabling();
        }

        protected virtual void OnPropertyChanged(Object source, EventArgs e)
        {
        }

        protected virtual void OnClickAddButton(Object source, EventArgs e)
        {
            if (IsLoading())
            {
                return;
            }

            SetDirty();
        }

        protected virtual void OnClickRemoveButton(Object source, EventArgs e)
        {
            if (IsLoading())
            {
                return;
            }

            if (TreeList.TvList.Nodes.Count == 0)
            {
                CurrentNode = null;
                LoadItemProperties();
            }

            SetDirty();
            UpdateControlsEnabling();
        }

        protected virtual void UpdateControlsEnabling()
        {
        }

        protected virtual void OnNodeRenamed()
        {
        }

        [
            System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        protected class ListTreeNode : TreeNode
        {
            private bool    _dirty;
            private String  _name;

            internal ListTreeNode(String text) : base(text) 
            {
                this._name  = text;
            }

            internal bool Dirty
            {
                get
                {
                    return _dirty;
                }
                set
                {
                    _dirty = value;
                }
            }

            internal String Name
            {
                get
                {
                    return _name;
                }
                set
                {
                    _name = value;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\mobilecomponenteditorpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileComponentEditorPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Drawing;
    using System.Web.UI.Design;
    using System.Web.UI.Design.MobileControls.Util;
    using System.Web.UI.MobileControls;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    using ControlDesigner = System.Web.UI.Design.ControlDesigner;

    /// <summary>
    ///   The base class for all mobile component editor pages.
    /// </summary>
    /// <internalonly/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal abstract class MobileComponentEditorPage : ComponentEditorPage 
    {
        private ControlDesigner         _designer = null;
        private IHelpService            _helpService = null;
        private ISite                   _site = null;
        private MobileControl           _control = null;

        protected abstract String HelpKeyword 
        {
            get;
        }

        protected ISite DesignerSite
        {
            get
            {
                if (_site != null)
                {
                    return _site;
                }

                IComponent selectedComponent = GetSelectedComponent();
                _site = selectedComponent.Site;
                Debug.Assert(_site != null, "Expected the component to be sited.");

                return _site;
            }
        }

        private IHelpService HelpService
        {
            get
            {
                if (_helpService != null)
                {
                    return _helpService;
                }

                _helpService = 
                    (IHelpService)DesignerSite.GetService(typeof(IHelpService));
                Debug.Assert(_helpService != null);

                return _helpService;
            }
        }

        protected MobileControl GetBaseControl()
        {
            if (_control != null)
            {
                return _control;
            }

            IComponent selectedComponent = GetSelectedComponent();
            Debug.Assert(selectedComponent is MobileControl);
            _control = (MobileControl)selectedComponent;

            return _control;
        }

        protected ControlDesigner GetBaseDesigner() 
        {
            if (_designer != null)
            {
                return _designer;
            }

            IDesignerHost designerHost = 
                (IDesignerHost)DesignerSite.GetService(typeof(IDesignerHost));
            Debug.Assert(designerHost != null, "Expected a designer host.");

            _designer = (ControlDesigner)designerHost.GetDesigner(GetSelectedComponent());

            Debug.Assert(_designer != null, "Expected a designer for the selected component");

            return _designer;
        }

        /* Removed for DCR 4240
        protected bool IsValidName(String name)
        {
            return DesignerUtility.IsValidName(name);
        }
        */

        public override void ShowHelp()
        {
            HelpService.ShowHelpFromKeyword(HelpKeyword);
        }

        public override bool SupportsHelp() 
        {
            return true;
        }

        [
            System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        protected class LoadingModeResource : IDisposable
        {
            private MobileComponentEditorPage _page;

            internal LoadingModeResource(MobileComponentEditorPage page)
            {
                _page = page;
                _page.EnterLoadingMode();
            }

            public void Dispose()
            {
                _page.ExitLoadingMode();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\mobilecontroldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileControlDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Web.UI;
    using System.Web.UI.Design;
    using System.Web.UI.Design.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Util;
    using System.Web.UI.MobileControls;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class MobileControlDesigner : 
        ControlDesigner, IMobileDesigner, IDeviceSpecificDesigner
    {
        private bool                            _containmentStatusDirty = true;
        private ContainmentStatus               _containmentStatus;
        private IDesignerHost                   _host;
        private IWebFormsDocumentService        _iWebFormsDocumentService;
        private IMobileWebFormServices          _iMobileWebFormServices;
        private MobileControl                   _mobileControl;
        private System.Windows.Forms.Control    _header;

        internal static readonly String resourceDllUrl =
            "res://" + typeof(MobileControlDesigner).Module.FullyQualifiedName;
        
        internal static readonly String errorIcon = 
            resourceDllUrl + "//ERROR_GIF";

        internal static readonly String infoIcon = 
            resourceDllUrl + "//INFO_GIF";

        internal static readonly String defaultErrorDesignTimeHTML =
            @"
                <table cellpadding=2 cellspacing=0 width='{4}' style='font-family:tahoma;font-size:8pt;color:buttontext;background-color:buttonface;border: solid 1px;border-top-color:buttonhighlight;border-left-color:buttonhighlight;border-bottom-color:buttonshadow;border-right-color:buttonshadow'>
                    <tr><td><span style='font-weight:bold'>&nbsp;{0}</span> - {1}</td></tr>
                    <tr><td>
                        <table style='font-family:tahoma;font-size:8pt;color:window;background-color:ButtonShadow'>
                            <tr>
                                <td valign='top'><img src={3} /></td>
                                <td width='100%'>{2}</td>
                            </tr>
                        </table>
                    </td></tr>
                </table>
             ";

        internal static readonly String _formPanelContainmentErrorMessage = 
            SR.GetString(SR.MobileControl_FormPanelContainmentErrorMessage);

        internal static readonly String _mobilePageErrorMessage =
            SR.GetString(SR.MobileControl_MobilePageErrorMessage);

        internal static readonly String _topPageContainmentErrorMessage = 
            SR.GetString(SR.MobileControl_TopPageContainmentErrorMessage);

        internal static readonly String _userControlWarningMessage =
            SR.GetString(SR.MobileControl_UserControlWarningMessage);

        private const String _appliedDeviceFiltersPropName = "AppliedDeviceFilters";
        private const String _propertyOverridesPropName = "PropertyOverrides";
        private const String _defaultDeviceSpecificIdentifier = "unique";

        // predefined constants used for mergingContext
        internal const int MergingContextChoices = 0;
        internal const int MergingContextTemplates = 1;
        internal const int MergingContextProperties = 2;

        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            Editor(typeof(AppliedDeviceFiltersTypeEditor), typeof(UITypeEditor)),
            MergableProperty(false),
            MobileCategory(SR.Category_DeviceSpecific),
            MobileSysDescription(SR.MobileControl_AppliedDeviceFiltersDescription),
            ParenthesizePropertyName(true),
        ]
        protected String AppliedDeviceFilters
        {
            get
            {
                return String.Empty;
            }
        }

        protected ContainmentStatus ContainmentStatus
        {
            get
            {
                if (!_containmentStatusDirty)
                {
                    return _containmentStatus;
                }

                _containmentStatus = 
                    DesignerAdapterUtil.GetContainmentStatus(_mobileControl);

                _containmentStatusDirty = false;
                return _containmentStatus;
            }
        }

        internal new Object DesignTimeElement
        {
            get
            {
                return base.DesignTimeElement;
            }
        }

        public override bool DesignTimeHtmlRequiresLoadComplete 
        {
            get 
            {
                return true;
            }
        }

        private IDesignerHost Host
        {
            get
            {
                if (_host != null)
                {
                    return _host;
                }
                _host = (IDesignerHost)GetService(typeof(IDesignerHost));
                Debug.Assert(_host != null);
                return _host;
            }
        }

        internal IMobileWebFormServices IMobileWebFormServices
        {
            get
            {
                if (_iMobileWebFormServices == null)
                {
                    _iMobileWebFormServices = 
                        (IMobileWebFormServices)GetService(typeof(IMobileWebFormServices));
                }

                return _iMobileWebFormServices;
            }
        }

        private IWebFormsDocumentService IWebFormsDocumentService
        {
            get
            {
                if (_iWebFormsDocumentService == null)
                {
                    _iWebFormsDocumentService =
                        (IWebFormsDocumentService)GetService(typeof(IWebFormsDocumentService));

                    Debug.Assert(_iWebFormsDocumentService != null);
                }

                return _iWebFormsDocumentService;
            }
        }

        /// <summary>
        ///     Indicates whether the initial page load is completed
        /// </summary>
        protected bool LoadComplete
        {
            get
            {
                return !IWebFormsDocumentService.IsLoading;
            }
        }

        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            Editor(typeof(PropertyOverridesTypeEditor), typeof(UITypeEditor)),
            MergableProperty(false),
            MobileCategory(SR.Category_DeviceSpecific),
            MobileSysDescription(SR.MobileControl_DeviceSpecificPropsDescription),
            ParenthesizePropertyName(true),
        ]
        protected String PropertyOverrides
        {
            get
            {
                return String.Empty;
            }
        }

        private bool ValidContainment
        {
            get
            {
                return (
                    ContainmentStatus == ContainmentStatus.InForm ||
                    ContainmentStatus == ContainmentStatus.InPanel ||
                    ContainmentStatus == ContainmentStatus.InTemplateFrame);
            }
        }

        protected virtual String GetErrorMessage(out bool infoMode)
        {
            infoMode = false;

            // Skip containment checking if the control is placed in MobileUserControl
            if (!DesignerAdapterUtil.InMobileUserControl(_mobileControl))
            {
                if (DesignerAdapterUtil.InUserControl(_mobileControl))
                {
                    infoMode = true;
                    return MobileControlDesigner._userControlWarningMessage;
                }

                if (!DesignerAdapterUtil.InMobilePage(_mobileControl))
                {
                    return _mobilePageErrorMessage;
                }

                if (!ValidContainment)
                {
                    return _formPanelContainmentErrorMessage;
                }
            }

            bool containsTag;
            bool containsDataboundLiteral;
            _mobileControl.GetControlText(out containsTag, out containsDataboundLiteral);

            if (containsTag)
            {
                return SR.GetString(SR.MobileControl_InnerTextCannotContainTagsDesigner);
            }
            
            // Containment is valid, return null;
            return null;
        }

        /// <summary>
        ///    <para>
        ///       Gets the HTML to be used for the design time representation of the control runtime.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The design time HTML.
        ///    </para>
        /// </returns>
        public sealed override String GetDesignTimeHtml()
        {
            if (!LoadComplete)
            {
                return null;
            }

            bool infoMode = false;
            String errorMessage = GetErrorMessage(out infoMode);
            SetStyleAttributes();

            if (null != errorMessage)
            {
                return GetDesignTimeErrorHtml(errorMessage, infoMode);
            }

            String designTimeHTML = null;
            try
            {
                designTimeHTML = GetDesignTimeNormalHtml();
            }
            catch (Exception ex)
            {
                Debug.Fail(ex.ToString());
                designTimeHTML = GetDesignTimeErrorHtml(ex.Message, false);
            }

            return designTimeHTML;
        }

        protected virtual String GetDesignTimeNormalHtml()
        {
            return GetEmptyDesignTimeHtml();
        }

        /// <summary>
        ///    <para>
        ///       Gets the HTML to be used at design time as the representation of the
        ///       control when the control runtime does not return any rendered
        ///       HTML. The default behavior is to return a string containing the name 
        ///       of the component.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The name of the component, by default.
        ///    </para>
        /// </returns>
        protected override String GetEmptyDesignTimeHtml()
        {
            return "<div style='width:100%'>" + base.GetEmptyDesignTimeHtml() + "</div>";
        }

        protected override sealed String GetErrorDesignTimeHtml(Exception e)
        {
            return base.GetErrorDesignTimeHtml(e);
        }

        /// <summary>
        ///  
        /// </summary>
        protected virtual String GetDesignTimeErrorHtml(String errorMessage, bool infoMode)
        {
            return DesignerAdapterUtil.GetDesignTimeErrorHtml(
                errorMessage, infoMode, _mobileControl, Behavior, ContainmentStatus);
        }

        /// <summary>
        ///    <para>
        ///       Gets the HTML to be persisted for the content present within the associated server control runtime.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       Persistable Inner HTML.
        ///    </para>
        /// </returns>
        public override String GetPersistInnerHtml()
        {
            if (!IsDirty) 
            {
                // Returning a null string will prevent the actual save.
                return null;
            }

            StringWriter sw = new StringWriter();

            // HACK ALERT:
            // We need to temporarily swap out the Text property to avoid being
            // persisted into control inner text. However, setting the Text property
            // will wipe out all control collections, therefore we need to cache
            // the Text value too.
            bool hasControls = _mobileControl.HasControls();
            if ((_mobileControl is TextControl || _mobileControl is TextView) 
                && hasControls)
            {
                String originalText = null;
                Control[] children = null;

                // Cache all child controls here.
                children = new Control[_mobileControl.Controls.Count];
                _mobileControl.Controls.CopyTo(children, 0);

                // Replace the text with empty string.
                if (_mobileControl is TextControl)
                {
                    originalText = ((TextControl)_mobileControl).Text;
                    ((TextControl)_mobileControl).Text = String.Empty;
                }
                else
                {
                    originalText = ((TextView)_mobileControl).Text;
                    ((TextView)_mobileControl).Text = String.Empty;
                }

                try
                {
                    // Persist inner properties without Text property.
                    MobileControlPersister.PersistInnerProperties(sw, _mobileControl, Host);
                    // Persist the child collections.
                    foreach (Control c in children)
                    {
                        MobileControlPersister.PersistControl(sw, c, Host);
                    }
                }
                finally
                {
                    // Write the original text back to control.
                    if (_mobileControl is TextControl)
                    {
                        ((TextControl)_mobileControl).Text = originalText;
                    }
                    else
                    {
                        ((TextView)_mobileControl).Text = originalText;
                    }

                    // Add the child controls back.
                    foreach (Control c in children)
                    {
                        _mobileControl.Controls.Add(c);
                    }
                }
            }
            else
            {
                MobileControlPersister.PersistInnerProperties(sw, _mobileControl, Host);
            }

            IsDirty = false;
            return sw.ToString();
        }

        /// <summary>
        ///    <para>
        ///       Initializes the designer with the component for design.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element for design.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component for
        ///       design.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.MobileControl,
                "MobileControlDesigner.Initialize - Invalid MobileControl Control");

            base.Initialize(component);

            _mobileControl = (System.Web.UI.MobileControls.MobileControl) component;
        }

        protected virtual void SetStyleAttributes()
        {
            Debug.Assert(Behavior != null, "Behavior is null, Load completed? " + LoadComplete.ToString());

            DesignerAdapterUtil.SetStandardStyleAttributes(Behavior, ContainmentStatus);
        }

        public override void OnComponentChanged(Object sender, ComponentChangedEventArgs ce) 
        {
            // Delegate to the base class implementation first!
            base.OnComponentChanged(sender, ce);

            MemberDescriptor member = ce.Member;
            if (member != null && 
                member.GetType().FullName.Equals(Constants.ReflectPropertyDescriptorTypeFullName))
            {
                PropertyDescriptor propDesc = (PropertyDescriptor)member;
                String propName = propDesc.Name;

                if ((_mobileControl is TextControl || _mobileControl is TextView) 
                    && propName.Equals("Text")) 
                {
                    _mobileControl.Controls.Clear();
                }
            }
        }

        /// <summary>
        ///    <para>
        ///       Notification that is called when the associated control is parented.
        ///    </para>
        /// </summary>
        public override void OnSetParent()
        {
            base.OnSetParent();

            _containmentStatusDirty = true;
            if (LoadComplete)
            {
                UpdateRendering();
            }
        }

        protected override void PreFilterProperties(IDictionary properties)
        {
            base.PreFilterProperties(properties);

            properties[_appliedDeviceFiltersPropName] =
                TypeDescriptor.CreateProperty(this.GetType(), _appliedDeviceFiltersPropName, typeof(String));

            properties[_propertyOverridesPropName] =
                TypeDescriptor.CreateProperty(this.GetType(), _propertyOverridesPropName, typeof(String));
        }

        /*
         *  IMobileDesigner INTERFACE IMPLEMENTATION
         */

        /// <summary>
        /// 
        /// </summary>
        public void UpdateRendering()
        {
            _mobileControl.RefreshStyle();

            UpdateDesignTimeHtml();
        }

        ////////////////////////////////////////////////////////////////////////
        //  Begin IDeviceSpecificDesigner Implementation
        ////////////////////////////////////////////////////////////////////////

        void IDeviceSpecificDesigner.SetDeviceSpecificEditor
            (IRefreshableDeviceSpecificEditor editor)
        {
        }

        String IDeviceSpecificDesigner.CurrentDeviceSpecificID
        {
            get
            {
                return _defaultDeviceSpecificIdentifier;
            }
        }
        
        System.Windows.Forms.Control IDeviceSpecificDesigner.Header
        {
            get
            {
                return _header;
            }
        }

        System.Web.UI.Control IDeviceSpecificDesigner.UnderlyingControl
        {
            get
            {
                return _mobileControl;
            }
        }

        Object IDeviceSpecificDesigner.UnderlyingObject
        {
            get
            {
                return _mobileControl;
            }
        }

        void IDeviceSpecificDesigner.InitHeader(int mergingContext)
        {
            HeaderPanel panel = new HeaderPanel();
            HeaderLabel lblDescription = new HeaderLabel();

            lblDescription.TabIndex = 0;
            lblDescription.Text = SR.GetString(
                SR.MobileControl_SettingGenericChoiceDescription
            );
            panel.Height = lblDescription.Height;
            panel.Width = lblDescription.Width;
            panel.Controls.Add(lblDescription);
            _header = panel;
        }

        void IDeviceSpecificDesigner.RefreshHeader(int mergingContext)
        {
        }

        bool IDeviceSpecificDesigner.GetDeviceSpecific(String deviceSpecificParentID, out DeviceSpecific ds)
        {
            Debug.Assert(_defaultDeviceSpecificIdentifier == deviceSpecificParentID);
            ds = ((MobileControl) _mobileControl).DeviceSpecific;
            return true;
        }

        void IDeviceSpecificDesigner.SetDeviceSpecific(String deviceSpecificParentID, DeviceSpecific ds)
        {
            Debug.Assert(_defaultDeviceSpecificIdentifier == deviceSpecificParentID);
            if (null != ds)
            {
                ds.SetOwner((MobileControl) _mobileControl);
            }
            _mobileControl.DeviceSpecific = ds;
        }

        void IDeviceSpecificDesigner.UseCurrentDeviceSpecificID()
        {
        }

        ////////////////////////////////////////////////////////////////////////
        //  End IDeviceSpecificDesigner Implementation
        ////////////////////////////////////////////////////////////////////////
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\mobileresource.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileResource.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Web.UI.Design;
    using System.Security.Permissions;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class MobileResource
    {
        private MobileResource()
        {
            // classes with only static methods shouldn't have public
            // constructors.
        }
        
        public static String GetString(String name)
        {
            return SR.GetString(name);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\mobiletemplatedcontroldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileTemplatedControlDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Globalization;
    using System.Text;
    using System.Web.UI;
    using System.Web.UI.Design;
    using System.Web.UI.Design.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Converters;
    using System.Web.UI.Design.MobileControls.Util;
    using System.Web.UI.MobileControls;
    using System.Web.UI.MobileControls.Adapters;

    using WebCtrlStyle = System.Web.UI.WebControls.Style;
    using DialogResult = System.Windows.Forms.DialogResult;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal abstract class MobileTemplatedControlDesigner : TemplatedControlDesigner, IMobileDesigner, IDeviceSpecificDesigner
    {
        #if TRACE
            internal static BooleanSwitch TemplateableControlDesignerSwitch =
                new BooleanSwitch("MobileTemplatedControlDesigner", "Enable TemplateableControl designer general purpose traces.");
        #endif

        private System.Windows.Forms.Control    _header;
        private MobileControl                   _mobileControl;
        private System.Web.UI.Control           _control;
        private DesignerVerbCollection          _designerVerbs = null;
        private DeviceSpecificChoice            _currentChoice = null;
        private bool                            _containmentStatusDirty = true;
        private ContainmentStatus               _containmentStatus;
        private IDesignerHost                   _host;
        private IWebFormsDocumentService        _iWebFormsDocumentService;
        private IMobileWebFormServices          _iMobileWebFormServices;
        private const String                    _htmlString = "html";
        private TemplateEditingVerb[]           _templateVerbs;
        private bool                            _templateVerbsDirty = true;
        private const int                       _templateWidth = 275;

        private static readonly String _noChoiceText = 
            SR.GetString(SR.DeviceFilter_NoChoice);

        private static readonly String _defaultChoiceText = 
            SR.GetString(SR.DeviceFilter_DefaultChoice);

        private static readonly String _nonHtmlSchemaErrorMessage =
            SR.GetString(SR.MobileControl_NonHtmlSchemaErrorMessage);

        private static readonly String _illFormedWarning = 
            SR.GetString(SR.TemplateFrame_IllFormedWarning);

        private const String _illFormedHtml = 
            "<DIV style=\"font-family:tahoma;font-size:8pt; COLOR: infotext; BACKGROUND-COLOR: infobackground\">{0}</DIV>";

        internal const String DefaultTemplateDeviceFilter = "__TemplateDeviceFilter__";
        private const String _templateDeviceFilterPropertyName = "TemplateDeviceFilter";
        private const String _appliedDeviceFiltersPropertyName = "AppliedDeviceFilters";
        private const String _propertyOverridesPropertyName = "PropertyOverrides";
        private const String _defaultDeviceSpecificIdentifier = "unique";

        // used by DesignerAdapterUtil.GetMaxWidthToFit
        // and needs to be exposed in object model because
        // custom controls may need to access the value just like
        // DesignerAdapterUtil.GetMaxWidthToFit does.
        public virtual int TemplateWidth
        {
            get
            {
                return _templateWidth;
            }
        }

        public override bool AllowResize
        {
            get 
            {
                // Non mobilecontrols (ie. DeviceSpecific) does not render templates, no need to resize.
                // When templates are not defined, we render a read-only fixed
                // size block. Once templates are defined or are being edited 
                // the control should allow resizing.
                return InTemplateMode || (_mobileControl != null && _mobileControl.IsTemplated);
            }
        }

        private bool AllowTemplateEditing
        {
            get
            {
                return (CurrentChoice != null && IsHTMLSchema(CurrentChoice) && !ErrorMode);
            }
        }
       
        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            Editor(typeof(AppliedDeviceFiltersTypeEditor), typeof(UITypeEditor)),
            MergableProperty(false),
            MobileCategory("Category_DeviceSpecific"),
            MobileSysDescription(SR.MobileControl_AppliedDeviceFiltersDescription),
            ParenthesizePropertyName(true),
        ]
        protected String AppliedDeviceFilters
        {
            get
            {
                return String.Empty;
            }
        }

        protected ContainmentStatus ContainmentStatus
        {
            get
            {
                if (!_containmentStatusDirty)
                {
                    return _containmentStatus;
                }

                _containmentStatus = 
                    DesignerAdapterUtil.GetContainmentStatus(_control);

                _containmentStatusDirty = false;
                return _containmentStatus;
            }
        }

        public DeviceSpecificChoice CurrentChoice
        {
            get
            {
                return _currentChoice;
            }

            set
            {
                if (_currentChoice != value)    
                {
                    SetTemplateVerbsDirty();

                    _currentChoice = value;
                    OnCurrentChoiceChange();
                }
            }
        }

        public virtual DeviceSpecific CurrentDeviceSpecific
        {
            get
            {
                if (null == _mobileControl)
                {
                    return null;
                }

                return _mobileControl.DeviceSpecific;
            }
        }

        internal new Object DesignTimeElement
        {
            get
            {
                return base.DesignTimeElement;
            }
        }

        public override bool DesignTimeHtmlRequiresLoadComplete 
        {
            get 
            {
                return true;
            }
        }

        // REVIEW: This property is only used to hide the template editing
        //         menu.  Consider better name.

        // Return true only when GetErrorMessage returns non-null string and
        // it is not info mode (warning only).
        protected virtual bool ErrorMode
        {
            get
            {
                bool infoMode;
                return (GetErrorMessage(out infoMode) != null && !infoMode);
            }
        }

        protected IDesignerHost Host
        {
            get
            {
                if (_host != null)
                {
                    return _host;
                }
                _host = (IDesignerHost)GetService(typeof(IDesignerHost));
                Debug.Assert(_host != null);
                return _host;
            }
        }

        protected IMobileWebFormServices IMobileWebFormServices
        {
            get
            {
                if (_iMobileWebFormServices == null)
                {
                    _iMobileWebFormServices = 
                        (IMobileWebFormServices)GetService(typeof(IMobileWebFormServices));
                }

                return _iMobileWebFormServices;
            }
        }

        private IWebFormsDocumentService IWebFormsDocumentService
        {
            get
            {
                if (_iWebFormsDocumentService == null)
                {
                    _iWebFormsDocumentService =
                        (IWebFormsDocumentService)GetService(typeof(IWebFormsDocumentService));

                    Debug.Assert(_iWebFormsDocumentService != null);
                }

                return _iWebFormsDocumentService;
            }
        }

        /// <summary>
        ///     Indicates whether the initial page load is completed
        /// </summary>
        protected bool LoadComplete
        {
            get
            {
                return !IWebFormsDocumentService.IsLoading;
            }
        }

        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            Editor(typeof(PropertyOverridesTypeEditor), typeof(UITypeEditor)),
            MergableProperty(false),
            MobileCategory("Category_DeviceSpecific"),
            MobileSysDescription(SR.MobileControl_DeviceSpecificPropsDescription),
            ParenthesizePropertyName(true),
        ]
        protected String PropertyOverrides
        {
            get
            {
                return String.Empty;
            }
        }

        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            MobileSysDescription(SR.TemplateableDesigner_TemplateChoiceDescription),
            TypeConverter(typeof(ChoiceConverter)),
        ]
        public String TemplateDeviceFilter
        {
            get
            {
                if (null == CurrentChoice)
                {
                    return _noChoiceText;
                }
                if (String.Empty == CurrentChoice.Filter)
                {
                    return _defaultChoiceText;
                }
                else
                {
                    return DesignerUtility.ChoiceToUniqueIdentifier(CurrentChoice);
                }
            }
            set
            {
                if (null == value ||
                    value.Equals(String.Empty) ||
                    value.Equals(SR.GetString(SR.DeviceFilter_NoChoice)))
                {
                    CurrentChoice = null;
                    return;
                }

                if (null == CurrentDeviceSpecific)
                {
                    return;
                }

                Debug.Assert(CurrentDeviceSpecific.Choices != null);

                foreach (DeviceSpecificChoice choice in CurrentDeviceSpecific.Choices)
                {
                    if (DesignerUtility.ChoiceToUniqueIdentifier(choice).Equals(value) ||
                        (String.Empty == choice.Filter && 
                         value.Equals(SR.GetString(SR.DeviceFilter_DefaultChoice))))
                    {
                        CurrentChoice = choice;
                        return;
                    }
                }

                CurrentChoice = null;
            }
        }

        private bool ValidContainment
        {
            get
            {
                return (ContainmentStatus == ContainmentStatus.InForm ||
                        ContainmentStatus == ContainmentStatus.InPanel ||
                        ContainmentStatus == ContainmentStatus.InTemplateFrame);
            }
        }

        public override DesignerVerbCollection Verbs 
        {
            get 
            {
                if (_designerVerbs == null) 
                {
                    _designerVerbs = new DesignerVerbCollection();

                    _designerVerbs.Add(new DesignerVerb(
                        SR.GetString(SR.TemplateableDesigner_SetTemplatesFilterVerb),
                        new EventHandler(this.OnSetTemplatesFilterVerb)));
                }

                _designerVerbs[0].Enabled = !this.InTemplateMode;
                return _designerVerbs;
            }
        }

        protected WebCtrlStyle WebCtrlStyle
        {
            get
            {
                WebCtrlStyle style = new WebCtrlStyle();

                if (_mobileControl != null)
                {
                    _mobileControl.Style.ApplyTo(style);
                }
                else
                {
                    Debug.Assert(_control is DeviceSpecific);
                    if (_control.Parent is Panel)
                    {
                        ((Panel)_control.Parent).Style.ApplyTo(style);
                    }
                }

                return style;
            }
        }

        [
            Conditional("DEBUG")
        ]
        private void CheckTemplateName(String templateName)
        {
            Debug.Assert (
                templateName == Constants.HeaderTemplateTag ||
                templateName == Constants.FooterTemplateTag ||
                templateName == Constants.ItemTemplateTag ||
                templateName == Constants.AlternatingItemTemplateTag ||
                templateName == Constants.SeparatorTemplateTag ||
                templateName == Constants.ItemDetailsTemplateTag ||
                templateName == Constants.ContentTemplateTag);
        }

        protected override ITemplateEditingFrame CreateTemplateEditingFrame(TemplateEditingVerb verb)
        {
            ITemplateEditingService teService = 
                (ITemplateEditingService)GetService(typeof(ITemplateEditingService));
            Debug.Assert(teService != null,
                "How did we get this far without an ITemplateEditingService");

            String[] templateNames = GetTemplateFrameNames(verb.Index);
            ITemplateEditingFrame editingFrame = teService.CreateFrame(
                this, 
                TemplateDeviceFilter,
                templateNames,
                WebCtrlStyle,
                null /* we don't have template styles */);

            editingFrame.InitialWidth = _templateWidth;
            return editingFrame;
        }

        protected override void Dispose(bool disposing) 
        {
            if (disposing) 
            {
                DisposeTemplateVerbs();

                if (IMobileWebFormServices != null)
                {
                    // If the page is in loading mode, it means the remove is trigged by webformdesigner.
                    if (IWebFormsDocumentService.IsLoading)
                    {
                        IMobileWebFormServices.SetCache(_control.ID, (Object) DefaultTemplateDeviceFilter, (Object) this.TemplateDeviceFilter);
                    }
                    else
                    {
                        // setting to null will remove the entry.
                        IMobileWebFormServices.SetCache(_control.ID, (Object) DefaultTemplateDeviceFilter, null);
                    }
                }
            }

            base.Dispose(disposing);
        }

        public override void OnComponentChanged(Object sender, ComponentChangedEventArgs ce) 
        {
            base.OnComponentChanged(sender, ce);

            MemberDescriptor member = ce.Member;
            if (member != null && 
                member.GetType().FullName.Equals(Constants.ReflectPropertyDescriptorTypeFullName))
            {
                PropertyDescriptor propDesc = (PropertyDescriptor)member;
                
                switch (propDesc.Name)
                {
                    case "ID":
                    {
                        // Update the dictionary of device filters stored in the page designer
                        // setting to null will remove the entry.
                        IMobileWebFormServices.SetCache(ce.OldValue.ToString(), (Object) DefaultTemplateDeviceFilter, null);
                        break;
                    }

                    case "BackColor":
                    case "ForeColor":
                    case "Font":
                    case "StyleReference":
                    {
                        SetTemplateVerbsDirty();
                        break;
                    }
                }
            }
        }

        private void DisposeTemplateVerbs()
        {
            if (_templateVerbs != null) 
            {
                for (int i = 0; i < _templateVerbs.Length; i++) 
                {
                    _templateVerbs[i].Dispose();
                }

                _templateVerbs = null;
                _templateVerbsDirty = true;
            }
        }

        protected override TemplateEditingVerb[] GetCachedTemplateEditingVerbs()
        {
            if (ErrorMode)
            {
                return null;
            }

            // dispose template verbs during template editing would cause exiting from editing mode
            // without saving.
            if (_templateVerbsDirty == true && !InTemplateMode) 
            {
                DisposeTemplateVerbs();

                _templateVerbs = GetTemplateVerbs();
                _templateVerbsDirty = false;
            }

            foreach(TemplateEditingVerb verb in _templateVerbs)
            {
                verb.Enabled = AllowTemplateEditing;
            }

            return _templateVerbs;
        }

        // Gets the HTML to be used for the design time representation of the control runtime.
        public sealed override String GetDesignTimeHtml()
        {
            if (!LoadComplete)
            {
                return null;
            }

            bool infoMode;
            String errorMessage = GetErrorMessage(out infoMode);
            SetStyleAttributes();

            if (null != errorMessage)
            {
                return GetDesignTimeErrorHtml(errorMessage, infoMode);
            }

            String designTimeHTML = null;

            // This is to avoiding cascading error rendering.
            try
            {
                designTimeHTML = GetDesignTimeNormalHtml();
            }
            catch (Exception ex)
            {
                Debug.Fail(ex.ToString());
                designTimeHTML = GetDesignTimeErrorHtml(ex.Message, false);
            }

            return designTimeHTML;
        }

        protected virtual String GetDesignTimeErrorHtml(String errorMessage, bool infoMode)
        {
            return DesignerAdapterUtil.GetDesignTimeErrorHtml(
                errorMessage, infoMode, _control, Behavior, ContainmentStatus);
        }

        protected virtual String GetDesignTimeNormalHtml()
        {
            return GetEmptyDesignTimeHtml();
        }

        // We sealed this method because it will never be called
        // by our designers under current structure.
        protected override sealed String GetErrorDesignTimeHtml(Exception e)
        {
            return base.GetErrorDesignTimeHtml(e);
        }

        protected virtual String GetErrorMessage(out bool infoMode)
        {
            infoMode = false;

            if (!DesignerAdapterUtil.InMobileUserControl(_control))
            {
                if (DesignerAdapterUtil.InUserControl(_control))
                {
                    infoMode = true;
                    return MobileControlDesigner._userControlWarningMessage;
                }

                if (!DesignerAdapterUtil.InMobilePage(_control))
                {
                    return MobileControlDesigner._mobilePageErrorMessage;
                }
            
                if (!ValidContainment)
                {
                    return MobileControlDesigner._formPanelContainmentErrorMessage;
                }
            }

            if (CurrentChoice != null && !IsHTMLSchema(CurrentChoice))
            {
                infoMode = true;
                return _nonHtmlSchemaErrorMessage;
            }

            // Containment is valid, return null;
            return null;
        }

        /// <summary>
        ///    <para>
        ///       Gets the HTML to be persisted for the content present within the associated server control runtime.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       Persistable Inner HTML.
        ///    </para>
        /// </returns>
        public override String GetPersistInnerHtml()
        {
            String persist = null;

            if (InTemplateMode)
            {
                SaveActiveTemplateEditingFrame();
            }

            if (IsDirty)
            {
                persist = MobileControlPersister.PersistInnerProperties(Component, Host);
            }

            if (InTemplateMode)
            {
                IsDirty = true;
            }

            return persist;
        }

        public override String GetTemplateContent(
            ITemplateEditingFrame editingFrame,
            String templateName,
            out bool allowEditing)
        {
            Debug.Assert(AllowTemplateEditing);
#if DEBUG
            CheckTemplateName(templateName);
#endif
            allowEditing = true;

            ITemplate template = null;
            String templateContent = String.Empty;

            // Here we trust the TemplateVerbs to give valid template names
            template = (ITemplate)CurrentChoice.Templates[templateName];

            if (template != null) 
            {
                templateContent = GetTextFromTemplate(template);
                if (!IsCompleteHtml(templateContent))
                {
                    allowEditing = false;
                    templateContent = String.Format(_illFormedHtml, _illFormedWarning);
                }
            }

            return templateContent;
        }

        protected abstract String[] GetTemplateFrameNames(int index);

        protected abstract TemplateEditingVerb[] GetTemplateVerbs();

        /// <summary>
        ///    <para>
        ///       Initializes the designer.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element being designed.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component being
        ///       designed.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.MobileControl ||
                         component is System.Web.UI.MobileControls.DeviceSpecific,
                         "MobileTemplatedControlDesigner.Initialize - Invalid (Mobile) Control");

            base.Initialize(component);

            if (component is System.Web.UI.MobileControls.MobileControl)
            {
                _mobileControl = (System.Web.UI.MobileControls.MobileControl) component;
            }
            // else the component is a DeviceSpecific control
            _control = (System.Web.UI.Control) component;

            if (IMobileWebFormServices != null)
            {
                this.TemplateDeviceFilter = (String) IMobileWebFormServices.GetCache(_control.ID, (Object)DefaultTemplateDeviceFilter);
            }
        }

        private bool IsCompleteHtml(String templateContent)
        {
            if (templateContent != null && templateContent != String.Empty)
            {
                return SimpleParser.IsWellFormed(templateContent);
            }

            // if template is empty, it's always editable.
            return true;
        }

        protected bool IsHTMLSchema(DeviceSpecificChoice choice)
        {
            Debug.Assert(choice != null);

            return choice.Xmlns != null && 
                choice.Xmlns.ToLower(CultureInfo.InvariantCulture).IndexOf(_htmlString) != -1;
        }

        // Notification that is called when current choice is changed, it is currently
        // used to notify StyleSheet that template device filter is changed.
        protected virtual void OnCurrentChoiceChange()
        {
        }

        /// <summary>
        ///    <para>
        ///       Notification that is called when internal changes have been made.
        ///    </para>
        /// </summary>
        protected virtual void OnInternalChange() 
        {
            ISite site = _control.Site;
            if (site != null) 
            {
                IComponentChangeService changeService =
                    (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                if (changeService != null) 
                {
                    try 
                    {
                        changeService.OnComponentChanging(_control, null);
                    }
                    catch (CheckoutException ex)
                    {
                        if (ex == CheckoutException.Canceled)
                        {
                            return;
                        }
                        throw;
                    }
                    changeService.OnComponentChanged(_control, null, null, null);
                }
            }
        }

        /// <summary>
        ///    <para>
        ///       Notification that is called when the associated control is parented.
        ///    </para>
        /// </summary>
        public override void OnSetParent() 
        {
            base.OnSetParent();

            // Template verbs may need to be refreshed
            SetTemplateVerbsDirty();

            // this needs to be set before OnLoadComplete;
            _containmentStatusDirty = true;

            if (LoadComplete)
            {
                UpdateRendering();
            }
        }

        private void OnSetTemplatesFilterVerb(Object sender, EventArgs e)
        {
            ShowTemplatingOptionsDialog();
        }

        protected override void OnTemplateModeChanged() 
        {
            base.OnTemplateModeChanged();

            if (InTemplateMode)
            {
                // Set xmlns in view linked document to show HTML intrinsic
                // controls in property grid with same schema used by
                // Intellisense for current choice tag in HTML view.
                
                NativeMethods.IHTMLElement htmlElement = (NativeMethods.IHTMLElement) ((IControlDesignerBehavior) Behavior).DesignTimeElementView;
                Debug.Assert(htmlElement != null, 
                    "Invalid HTML element in MobileTemplateControlDesigner.OnTemplateModeChanged");
                NativeMethods.IHTMLDocument2 htmlDocument2 = (NativeMethods.IHTMLDocument2) htmlElement.GetDocument();
                Debug.Assert(htmlDocument2 != null, 
                    "Invalid HTML Document2 in MobileTemplateControlDesigner.OnTemplateModeChanged");
                NativeMethods.IHTMLElement htmlBody = (NativeMethods.IHTMLElement) htmlDocument2.GetBody();
                Debug.Assert(htmlBody != null, 
                    "Invalid HTML Body in MobileTemplateControlDesigner.OnTemplateModeChanged");
                htmlBody.SetAttribute("xmlns", (Object) CurrentChoice.Xmlns, 0);
            }
        }

        protected override void PreFilterProperties(IDictionary properties) 
        {
            base.PreFilterProperties(properties);

            // DesignTime Property only, we will use this to select choices.
            properties[_templateDeviceFilterPropertyName] = 
                TypeDescriptor.CreateProperty(this.GetType(),
                _templateDeviceFilterPropertyName,
                typeof(String),
                new DefaultValueAttribute(SR.GetString(SR.DeviceFilter_NoChoice)),
                MobileCategoryAttribute.Design,
                InTemplateMode ? BrowsableAttribute.No : BrowsableAttribute.Yes
                );

            // design time only entry used to display dialog box used to create choices.
            properties[_appliedDeviceFiltersPropertyName] = 
                TypeDescriptor.CreateProperty(this.GetType(),
                _appliedDeviceFiltersPropertyName,
                typeof(String),
                InTemplateMode? BrowsableAttribute.No : BrowsableAttribute.Yes
                );

            // design time only entry used to display dialog box to create choices.
            properties[_propertyOverridesPropertyName] =
                TypeDescriptor.CreateProperty(this.GetType(),
                _propertyOverridesPropertyName,
                typeof(String),
                InTemplateMode? BrowsableAttribute.No : BrowsableAttribute.Yes
                );
        }

        protected virtual void SetStyleAttributes()
        {
            Debug.Assert(Behavior != null);
            DesignerAdapterUtil.SetStandardStyleAttributes(Behavior, ContainmentStatus);
        }

        public override void SetTemplateContent(
            ITemplateEditingFrame editingFrame,
            String templateName,
            String templateContent) 
        {
            Debug.Assert(AllowTemplateEditing);

            // Debug build only checking
            CheckTemplateName(templateName);
 
            ITemplate template = null;

            if ((templateContent != null) && (templateContent.Length != 0)) 
            {
                template = GetTemplateFromText(templateContent);
            }
            else
            {
                CurrentChoice.Templates.Remove(templateName);
                return;
            }

            // Here we trust the TemplateVerbs to give valid template names
            CurrentChoice.Templates[templateName] = template;
        }

        protected internal void SetTemplateVerbsDirty()
        {
            _templateVerbsDirty = true;
        }

        protected virtual void ShowTemplatingOptionsDialog()
        {
            IComponentChangeService changeService = 
                (IComponentChangeService)GetService(typeof(IComponentChangeService));
            if (changeService != null) 
            {
                try 
                {
                    changeService.OnComponentChanging(_control, null);
                }
                catch (CheckoutException ex) 
                {
                    if (ex == CheckoutException.Canceled)
                    {
                        return;
                    }
                    throw;
                }
            }
            
            try 
            {
                TemplatingOptionsDialog dialog = new TemplatingOptionsDialog(
                    this, 
                    _control.Site, 
                    MobileControlDesigner.MergingContextTemplates);
                dialog.ShowDialog();
            }
            finally 
            {
                if (changeService != null) 
                {
                    changeService.OnComponentChanged(_control, null, null, null);

                    if (IMobileWebFormServices != null)
                    {
                        IMobileWebFormServices.ClearUndoStack();
                    }
                }
            }
        }

        public void UpdateRendering()
        {
            if (!(null == _mobileControl || _mobileControl is StyleSheet))
            {
                _mobileControl.RefreshStyle();
            }

            // template editing frame need to be recreated because the style
            // (WebCtrlStyle) to use may have to change
            SetTemplateVerbsDirty();

            if (!InTemplateMode)
            {
                UpdateDesignTimeHtml();
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //  Begin IDeviceSpecificDesigner Implementation
        ////////////////////////////////////////////////////////////////////////

        void IDeviceSpecificDesigner.SetDeviceSpecificEditor
            (IRefreshableDeviceSpecificEditor editor)
        {
        }

        String IDeviceSpecificDesigner.CurrentDeviceSpecificID
        {
            get
            {
                return _defaultDeviceSpecificIdentifier;
            }
        }

        System.Windows.Forms.Control IDeviceSpecificDesigner.Header
        {
            get
            {
                return _header;
            }
        }

        System.Web.UI.Control IDeviceSpecificDesigner.UnderlyingControl
        {
            get
            {
                return _control;
            }
        }

        Object IDeviceSpecificDesigner.UnderlyingObject
        {
            get
            {
                return _control;
            }
        }

        void IDeviceSpecificDesigner.InitHeader(int mergingContext)
        {
            HeaderPanel panel = new HeaderPanel();
            HeaderLabel lblDescription = new HeaderLabel();

            lblDescription.TabIndex = 0;
            lblDescription.Height = 24;
            lblDescription.Width = 204;
            panel.Height = 28;
            panel.Width = 204;
            panel.Controls.Add(lblDescription);

            switch (mergingContext)
            {
                case MobileControlDesigner.MergingContextTemplates:
                {
                    lblDescription.Text = SR.GetString(SR.TemplateableDesigner_SettingTemplatingChoiceDescription);
                    break;
                }

                default:
                {
                    lblDescription.Text = SR.GetString(SR.TemplateableDesigner_SettingGenericChoiceDescription);
                    break;
                }
            }
            
            _header = panel;
        }

        void IDeviceSpecificDesigner.RefreshHeader(int mergingContext)
        {
        }

        bool IDeviceSpecificDesigner.GetDeviceSpecific(String deviceSpecificParentID, out DeviceSpecific ds)
        {
            Debug.Assert(_defaultDeviceSpecificIdentifier == deviceSpecificParentID);
            ds = CurrentDeviceSpecific;
            return true;
        }

        void IDeviceSpecificDesigner.SetDeviceSpecific(String deviceSpecificParentID, DeviceSpecific ds)
        {
            Debug.Assert(_defaultDeviceSpecificIdentifier == deviceSpecificParentID);

            if (_mobileControl != null)
            {
                if (null != ds)
                {
                    ds.SetOwner(_mobileControl);
                }
                _mobileControl.DeviceSpecific = ds;
            }
            else if (_control != null && ds == null)
            {
                Debug.Assert(_control is DeviceSpecific);

                // Clear the choices if it is a DeviceSpecific control.
                ((DeviceSpecific)_control).Choices.Clear();
            }

            if (null != CurrentChoice)
            {
                if (null == ds)
                {
                    CurrentChoice = null;
                }
                else
                {
                    // This makes sure that the CurrentChoice value is set to null if
                    // it was deleted during the deviceSpecific object editing
                    if (String.Empty == CurrentChoice.Filter)
                    {
                        TemplateDeviceFilter = SR.GetString(SR.DeviceFilter_DefaultChoice);
                    }
                    else
                    {
                        TemplateDeviceFilter = DesignerUtility.ChoiceToUniqueIdentifier(CurrentChoice);
                    }
                }
            }
        }

        void IDeviceSpecificDesigner.UseCurrentDeviceSpecificID()
        {
        }

        ////////////////////////////////////////////////////////////////////////
        //  End IDeviceSpecificDesigner Implementation
        ////////////////////////////////////////////////////////////////////////

        // Hack : Internal class used to provide TemplateContainerAttribute for Templates.
        [
            System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        internal class TemplateContainer
        {
            [
                TemplateContainer(typeof(MobileListItem))
            ]
            internal ITemplate HeaderTemplate
            {
                get {return null;}
            }

            [
                TemplateContainer(typeof(MobileListItem))
            ]
            internal ITemplate FooterTemplate
            {
                get {return null;}
            }

            [
                TemplateContainer(typeof(MobileListItem))
            ]
            internal ITemplate ItemTemplate
            {
                get {return null;}
            }

            [
                TemplateContainer(typeof(MobileListItem))
            ]
            internal ITemplate AlternatingItemTemplate
            {
                get {return null;}
            }

            [
                TemplateContainer(typeof(MobileListItem))
            ]
            internal ITemplate SeparatorTemplate
            {
                get {return null;}
            }

            [
                TemplateContainer(typeof(MobileListItem))
            ]
            internal ITemplate ContentTemplate
            {
                get {return null;}
            }

            [
                TemplateContainer(typeof(MobileListItem))
            ]
            internal ITemplate LabelTemplate
            {
                get {return null;}
            }

            [
                TemplateContainer(typeof(MobileListItem))
            ]
            internal ITemplate ItemDetailsTemplate
            {
                get {return null;}
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\mobilecontrolpersister.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileControlPersister.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Web.UI;
    using System.Web.UI.HtmlControls;
    using System.Web.UI.MobileControls;
    using System.Web.UI.WebControls;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Text;
    using AttributeCollection = System.Web.UI.AttributeCollection;

    /// <summary>
    ///    <para>
    ///       Provides helper functions used in persisting Controls.
    ///    </para>
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class MobileControlPersister 
    {

        /// <summary>
        ///    We don't want instances of this class to be created, so mark
        ///    the constructor as private.
        /// </summary>
        private MobileControlPersister() {
        }

        /// <summary>
        ///    <para>
        ///       Gets the delarative type for the
        ///       specified type.
        ///    </para>
        /// </summary>
        /// <param name='type'>
        ///    The type of the declarator.
        /// </param>
        /// <param name='host'>
        ///    The services interface exposed by the webforms designer.
        /// </param>
        private static string GetDeclarativeType(Type type, IDesignerHost host) {
            Debug.Assert(host != null, "Need an IDesignerHost to create declarative type names");
            string declarativeType = null;

            if (host != null) {
                IWebFormReferenceManager refMgr =
                    (IWebFormReferenceManager)host.GetService(typeof(IWebFormReferenceManager));
                Debug.Assert(refMgr != null, "Did not get back IWebFormReferenceManager service from host.");

                if (refMgr != null) {
                    string tagPrefix = refMgr.GetTagPrefix(type);
                    if ((tagPrefix != null) && (tagPrefix.Length != 0)) {
                        declarativeType = tagPrefix + ":" + type.Name;
                    }
                }
            }

            if (declarativeType == null) 
            {
/* Begin AUI 7201  */
/* Original declarativeType = type.FullName; */
                if (type == typeof(System.Web.UI.MobileControls.Style))
                {
                    declarativeType = type.Name;
                }
                else
                {
                    declarativeType = type.FullName;
                }
/* End AUI 7201 */
            }

            return declarativeType;
        }

        /// <summary>
        ///    <para>
        ///       Persists a collection property.
        ///    </para>
        /// </summary>
        /// <param name='persistMode'>
        ///    The persistance mode to use.
        /// </param>
        /// <param name=' sw'>
        ///    The string writer to use.
        /// </param>
        /// <param name=' component'>
        ///    The component to persist.
        /// </param>
        /// <param name=' propDesc'>
        ///    A property descriptor for the collection property.
        /// </param>
        /// <param name='host'>
        ///    The services interface exposed by the webforms designer.
        /// </param>
        private static void PersistCollectionProperty(TextWriter sw, object component, PropertyDescriptor propDesc, PersistenceMode persistMode, IDesignerHost host) {
            Debug.Assert(typeof(ICollection).IsAssignableFrom(propDesc.PropertyType),
                "Invalid collection property : " + propDesc.Name);

            ICollection propValue = (ICollection)propDesc.GetValue(component);
            if ((propValue == null) || (propValue.Count == 0))
                return;

// Begin AUI Change #3785
// Original: sw.WriteLine();
            if (!(component is DeviceSpecific))
            {
                sw.WriteLine();
            }
// End of Change #3785

            if (persistMode == PersistenceMode.InnerProperty) {
                sw.Write('<');
                sw.Write(propDesc.Name);
                sw.WriteLine('>');
            }

            IEnumerator e = propValue.GetEnumerator();
            while (e.MoveNext()) {
                object collItem = e.Current;

                // Begin of AUI Change

                //string itemTypeName = GetDeclarativeType(collItem.GetType(), host);
                string itemTypeName;
                
                // AUI : To fix Hashtable objects used in Mobile Controls, only persist the value part
                if (collItem is DictionaryEntry)
                {
                    collItem = ((DictionaryEntry)collItem).Value;
                }
                
                // AUI : First check if the control already has a Default Persist Name,
                //       if not, use the Type as its name

                PersistNameAttribute pna = 
                    (PersistNameAttribute)TypeDescriptor.GetAttributes(collItem.GetType())[typeof(PersistNameAttribute)];

                // attribute should returns default value if it's null.
                // this is unlikely to happen, but just to be on the safe side.
                Debug.Assert (pna != null, "PersistNameAttribute returns null!");

                string persistName = (string)pna.Name;

                if (persistName != null && persistName.Length > 0)
                {
                    itemTypeName = persistName;
                }
/* AUI Change #3911 */
/* Original : else if (collItem is Control) */
                else if (collItem is Control || collItem.GetType() == typeof(System.Web.UI.MobileControls.Style))
                {
                    itemTypeName = GetDeclarativeType(collItem.GetType(), host);
                }
                else
                {
                    itemTypeName = collItem.GetType().Name;
                }
                // End of AUI Change

                sw.Write("<");
                sw.Write(itemTypeName);
                PersistAttributes(sw, collItem, String.Empty, null);
                sw.Write(">");
                
                if (collItem is Control) {
                    PersistChildrenAttribute pca =
                        (PersistChildrenAttribute)TypeDescriptor.GetAttributes(collItem.GetType())[typeof(PersistChildrenAttribute)];

                    if (pca.Persist == true) {
                        // asurt 106696: ensure the parent control's visibility is set to true.
                        Control parentControl = (Control)collItem;
                        if (parentControl.HasControls()) 
                        {
                            bool oldVisible = parentControl.Visible;
                            try 
                            {
                                parentControl.Visible = true;
                                PersistChildControls(sw, parentControl.Controls, host);
                            }
                            finally 
                            {
                                parentControl.Visible = oldVisible;
                            }
                        }
                    }
                    else {
                        PersistInnerProperties(sw, collItem, host);
                    }
                }
                else {
                    PersistInnerProperties(sw, collItem, host);
                }
                
                sw.Write("</");
                sw.Write(itemTypeName);
                sw.WriteLine(">");
            }

            if (persistMode == PersistenceMode.InnerProperty) {
                sw.Write("</");
                sw.Write(propDesc.Name);
                sw.WriteLine('>');
            }
        }

        /// <summary>
        ///    <para>
        ///       Persists a complex property.
        ///    </para>
        /// </summary>
        /// <param name='persistMode'>
        ///    The persistance mode to use.
        /// </param>
        /// <param name=' sw'>
        ///    The string writer to use.
        /// </param>
        /// <param name=' component'>
        ///    The component to persist.
        /// </param>
        /// <param name=' propDesc'>
        ///    A property descriptor for the complex property.
        /// </param>
        /// <param name='host'>
        ///    The services interface exposed by the webforms designer.
        /// </param>
        private static void PersistComplexProperty(TextWriter sw, object component, PropertyDescriptor propDesc, IDesignerHost host) {
            object propValue = propDesc.GetValue(component);

            if (propValue == null) {
                return;
            }

            StringWriter tagProps = new StringWriter();
            StringWriter innerProps = new StringWriter();

            PersistAttributes(tagProps, propValue, String.Empty, null);
            PersistInnerProperties(innerProps, propValue, host);

            // the rule here is that if a complex property has all its subproperties
            // in the default state, then it itself is in the default state.
            // When this is the case, there shouldn't be any tag properties or inner properties
            if ((tagProps.GetStringBuilder().Length != 0) ||
                (innerProps.GetStringBuilder().Length != 0)) {

                sw.WriteLine();
                sw.Write('<');
                sw.Write(propDesc.Name);
                sw.Write(tagProps.ToString());
                sw.WriteLine(">");

                string innerPropsString = innerProps.ToString();
                sw.Write(innerPropsString);
                if (innerPropsString.Length != 0) {
// Begin AUI Change #3785
// Original: sw.WriteLine();
                    if (!propDesc.Name.Equals("DeviceSpecific"))
                    {
                        sw.WriteLine();
                    }
// End AUI Change #3785
                }

                sw.Write("</");
                sw.Write(propDesc.Name);
                sw.WriteLine('>');
            }
        }

        /// <summary>
        ///    <para>
        ///       Persists the data bindings of the specified control using the specified
        ///       string writer.
        ///    </para>
        /// </summary>
        /// <param name='sw'>
        ///    The string writer to use.
        /// </param>
        /// <param name=' control'>
        ///    The control to use.
        /// </param>
        private static void PersistDataBindings(TextWriter sw, Control control) {
            DataBindingCollection bindings = ((IDataBindingsAccessor)control).DataBindings;
            IEnumerator bindingEnum = bindings.GetEnumerator();

            while (bindingEnum.MoveNext()) {
                DataBinding db = (DataBinding)bindingEnum.Current;
                string persistPropName = db.PropertyName.Replace('.', '-');

                sw.Write(" ");
                sw.Write(persistPropName);
                sw.Write("='<%# ");
                sw.Write(HttpUtility.HtmlEncode(db.Expression));
                sw.Write(" %>'");
            }
        }

        /// <overload>
        ///    <para>
        ///       Gets a string that can persist the inner properties of a control.
        ///    </para>
        /// </overload>
        /// <summary>
        ///    <para>
        ///       Gets a string that can persist the inner properties of a control.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The component to persist.
        /// </param>
        /// <param name='host'>
        ///    The services interface exposed by the webforms designer.
        /// </param>
        /// <returns>
        ///    <para>
        ///       A string that contains the persistable information about
        ///       the inner properties
        ///       of the control.
        ///    </para>
        /// </returns>
        internal static string PersistInnerProperties(object component, IDesignerHost host) {
            StringWriter sw = new StringWriter();

            PersistInnerProperties(sw, component, host);
            return sw.ToString();
        }

        /// <summary>
        ///    <para>
        ///       Persists the inner properties of the control.
        ///    </para>
        /// </summary>
        /// <param name='sw'>
        ///    The string writer to use.
        /// </param>
        /// <param name=' component'>
        ///    The component to persist.
        /// </param>
        /// <param name='host'>
        ///    The services interface exposed by the webforms designer.
        /// </param>
        internal static void PersistInnerProperties(TextWriter sw, object component, IDesignerHost host) {
            PropertyDescriptorCollection propDescs = TypeDescriptor.GetProperties(component);

            for (int i = 0; i < propDescs.Count; i++) {
                // Only deal with inner attributes that need to be persisted
                if (propDescs[i].SerializationVisibility == DesignerSerializationVisibility.Hidden)
                    continue;

                PersistenceModeAttribute persistenceMode = (PersistenceModeAttribute)propDescs[i].Attributes[typeof(PersistenceModeAttribute)];
                if (persistenceMode.Mode == PersistenceMode.Attribute) {
                    continue;
                }
                    
                if (propDescs[i].PropertyType == typeof(string)) {
                    // String based property...
                    
                    DataBindingCollection dataBindings = null;
                    if (component is IDataBindingsAccessor) {
                        dataBindings = ((IDataBindingsAccessor)component).DataBindings;
                    }
                    if (dataBindings == null || dataBindings[propDescs[i].Name] == null) {
                        PersistenceMode mode = persistenceMode.Mode;
                        if ((mode == PersistenceMode.InnerDefaultProperty) ||
                            (mode == PersistenceMode.EncodedInnerDefaultProperty)) {
                            PersistStringProperty(sw, component, propDescs[i], mode);
                        }
                        else {
                            Debug.Fail("Cannot persist inner string property marked with PersistenceMode.InnerProperty");
                        }
                    }
                }
                else if (typeof(ITemplate).IsAssignableFrom(propDescs[i].PropertyType)) {
                    // Template based property...
                    if (persistenceMode.Mode == PersistenceMode.InnerProperty) {
                        PersistTemplateProperty(sw, component, propDescs[i]);
                    }
                    else {
                        Debug.Fail("Cannot persist template property " + propDescs[i].Name + " not marked with PersistenceMode.InnerProperty");
                    }
                }
/* AUI change 03/21/01 */
                else if (propDescs[i].DisplayName.Equals("Templates") &&
                    component is DeviceSpecificChoice &&
                    typeof(IDictionary).IsAssignableFrom(propDescs[i].PropertyType)) {

                    IDictionary templateCollection = (IDictionary)propDescs[i].GetValue(component);
                    foreach (String templateName in templateCollection.Keys) {
                        ITemplate template = (ITemplate)templateCollection[templateName];
                        PersistTemplateProperty(sw, templateName, template);
                    }
                }
/* End of AUI change*/        
                else if (typeof(ICollection).IsAssignableFrom(propDescs[i].PropertyType)) {
                    // Collection based property...
                    if ((persistenceMode.Mode == PersistenceMode.InnerProperty) ||
                        (persistenceMode.Mode == PersistenceMode.InnerDefaultProperty)) {
                        PersistCollectionProperty(sw, component, propDescs[i], persistenceMode.Mode, host);
                    }
                    else {
                        Debug.Fail("Cannot persist collection property " + propDescs[i].Name + " not marked with PersistenceMode.InnerProperty or PersistenceMode.InnerDefaultProperty");
                    }
                }
                else {
                    // Other complex property...
                    if (persistenceMode.Mode == PersistenceMode.InnerProperty) {
                        PersistComplexProperty(sw, component, propDescs[i], host);
                    }
                    else {
                        Debug.Fail("Cannot persist complex property " + propDescs[i].Name + " not marked with PersistenceMode.InnerProperty");
                    }
                }
            }
        }

        /// <summary>
        ///    <para>
        ///       Persists the properties of a
        ///       string.
        ///    </para>
        /// </summary>
        /// <param name='persistMode'>
        ///    The persistance mode to use.
        /// </param>
        /// <param name=' sw'>
        ///    The string writer to use.
        /// </param>
        /// <param name=' component'>
        ///    The component to persist.
        /// </param>
        /// <param name=' propDesc'>
        ///    A property descriptor for the string properties.
        /// </param>
        private static void PersistStringProperty(TextWriter sw, object component, PropertyDescriptor propDesc, PersistenceMode mode) {
            Debug.Assert(propDesc.PropertyType == typeof(string),
                "Invalid string property : " + propDesc.Name);
            Debug.Assert((mode == PersistenceMode.InnerDefaultProperty) || (mode == PersistenceMode.EncodedInnerDefaultProperty),
                         "Inner string properties must be marked as either InnerDefaultProperty or EncodedInnerDefaultProperty");

            object propValue = propDesc.GetValue(component);
            if (propValue == null) {
                return;
            }

            if (mode == PersistenceMode.InnerDefaultProperty) {
                sw.Write((string)propValue);
            }
            else {
                HttpUtility.HtmlEncode((string)propValue, sw);
            }
        }
        
        /// <summary>
        ///    <para>
        ///       Persists the properties of a tag.
        ///    </para>
        /// </summary>
        /// <param name='sw'>
        ///    The string writer to use.
        /// </param>
        /// <param name=' component'>
        ///    The component to persist.
        /// </param>
        /// <param name=' prefix'>
        ///    The prefix to store.
        /// </param>
        /// <param name=' propDesc'>
        ///    A property descriptor for the tag properties.
        /// </param>
        private static void PersistAttributes(TextWriter sw, object component, string prefix, PropertyDescriptor propDesc) {
            PropertyDescriptorCollection properties;
            string persistPrefix = String.Empty;
            object value = component;

            if (propDesc != null) {
                value = propDesc.GetValue(component);
                properties = TypeDescriptor.GetProperties(propDesc.PropertyType,
                                                               new Attribute[] {
                                                                   PersistenceModeAttribute.Attribute
                                                               });
            }
            else {
                properties = TypeDescriptor.GetProperties(component,
                                                               new Attribute[] {
                                                                   PersistenceModeAttribute.Attribute
                                                               });
            }

            if (value == null)
                return;

            if (prefix.Length != 0)
                persistPrefix = prefix + "-";

            DataBindingCollection dataBindings = null;
            bool isControl = (component is Control);
            if ((component is IDataBindingsAccessor))
                dataBindings = ((IDataBindingsAccessor)component).DataBindings;

            if (component is DeviceSpecificChoice)
            {
                properties = properties.Sort(new String[] {"Filter"});
            }

            for (int i = 0; i < properties.Count; i++) {
            
                // Skip properties that are hidden to the serializer
                if (properties[i].SerializationVisibility == DesignerSerializationVisibility.Hidden) {
                    continue;
                }
                
                // Skip design-time only properties such as DefaultModifiers and Name
                DesignOnlyAttribute doAttr = (DesignOnlyAttribute)properties[i].Attributes[typeof(DesignOnlyAttribute)];
                if ((doAttr != null) && doAttr.IsDesignOnly) {
                    continue;
                }

                string propName = properties[i].Name;
                Type propType = properties[i].PropertyType;

                object obj = properties[i].GetValue(value);
                if (obj == null)
                    continue;

                DefaultValueAttribute defValAttr =
                    (DefaultValueAttribute)properties[i].Attributes[typeof(DefaultValueAttribute)];
                if ((defValAttr != null) && (obj.Equals(defValAttr.Value)))
                    continue;

                string persistName = propName;
/* AUI Change 3876 -- Change is taken out because of 4347
                if (component is DeviceSpecificChoice && persistName.Equals("Xmlns"))
                {
                    persistName = "xmlns";
                }
   End of Change */

                if (prefix.Length != 0)
                    persistName = persistPrefix + persistName;

                PropertyDescriptorCollection subProps = null;
                if (properties[i].SerializationVisibility == DesignerSerializationVisibility.Content) {
                    subProps = TypeDescriptor.GetProperties(propType);
                }
                if ((subProps == null) || (subProps.Count == 0)) {
                    string persistValue = null;

                    // TODO: Use consts or have DataBinding store both OM name and persist name
                    DataBinding db = null;
                    if (dataBindings != null)
                        db = dataBindings[persistName.Replace('.', '-')];
                    
                    if (db == null) {
                        if (propType.IsEnum) {
                            persistValue = Enum.Format(propType, obj, "G");
                        }
                        else if (propType == typeof(string)) {
                            persistValue = HttpUtility.HtmlEncode(obj.ToString());
                        }
                        else {
                            TypeConverter converter = properties[i].Converter;
                            if (converter != null) {
                                persistValue = converter.ConvertToInvariantString(null, obj);
                            }
                            else {
                                persistValue = obj.ToString();
                            }
                            persistValue = HttpUtility.HtmlEncode(persistValue);
                        }

                        if ((persistValue == null) ||
                            (persistValue.Equals("NotSet")) ||
                            (propType.IsArray && (persistValue.Length == 0)))
                            continue;

                        sw.Write(" ");
                        sw.Write(persistName);
                        sw.Write("=\"");

                        sw.Write(persistValue);
                        sw.Write("\"");
                    }
                }
                else {
/* 
 *  This will force all ListDictionary properties with DesignerSerializationVisibility.Content atttribute be
 *  persisted as a series of attributes eg. <PropertyFoo Key1="Value1" Key2="Value2" ... />. The 
 *  WebControlPersistor is not able to handle this case and will return undesired results.
 */
// AUI Change to handle DeviceSpecificChoice.Contents
                    if (obj is ListDictionary)
                    {
                        IDictionaryEnumerator enumerator = ((ListDictionary)obj).GetEnumerator ();
                        String persistValue = null;

                        while (enumerator.MoveNext ())
                        {
                            propName = enumerator.Key as String;
                            persistValue = enumerator.Value as String;

                            Debug.Assert (propName != null, 
                                "Non-string key in DeviceSpecificChoice Contents.");

                            if ((propName.Length == 0) ||
                                (persistValue == null))
                                continue;

                            sw.Write(" ");
                            sw.Write(propName);
                            sw.Write("=\"");

                            HttpUtility.HtmlEncode((String)persistValue, sw);
                            sw.Write("\"");                            
                        }
                    }
                    else
                    {
// End of AUI Change

                        // there are sub properties, don't persist this object, but
                        // recursively persist the subproperties.
                        PersistAttributes(sw, obj, persistName, null);
                    }
                }
            }

            // Persist all the databindings on this control
            if (isControl) {
                PersistDataBindings(sw, (Control)component);

                AttributeCollection expandos = null;
                if (component is WebControl) {
                    expandos = ((WebControl)component).Attributes;
                }
                else if (component is HtmlControl) {
                    expandos = ((HtmlControl)component).Attributes;
                }
                else if (component is UserControl) 
                {
                    expandos = ((UserControl)component).Attributes;
                }

                if (expandos != null) {
                    foreach (string key in expandos.Keys) {
                        sw.Write(" ");
                        sw.Write(key);
                        sw.Write("=\"");
                        sw.Write(expandos[key]);
                        sw.Write("\"");
                    }
                }
            }
        }

        /// <summary>
        ///    <para>
        ///       Persists a template property including the specified persistance mode,
        ///       string writer and property descriptor.
        ///    </para>
        /// </summary>
        /// <param name='persistMode'>
        ///    The persistence mode to use.
        /// </param>
        /// <param name=' sw'>
        ///    The string writer to use.
        /// </param>
        /// <param name=' component'>
        ///    The component to persist.
        /// </param>
        /// <param name=' propDesc'>
        ///    A property descriptor for the property.
        /// </param>
/* AUI change 03/21/01 added support for persisting Template collection */
        private static void PersistTemplateProperty(TextWriter sw, object component, PropertyDescriptor propDesc) 
        {
            Debug.Assert(typeof(ITemplate).IsAssignableFrom(propDesc.PropertyType),
                "Invalid template property : " + propDesc.Name);

            ITemplate template = (ITemplate)propDesc.GetValue(component);
            String templateName = propDesc.Name;
            PersistTemplateProperty(sw, templateName, template);
        }

/* AUI change 03/21/01 made the following code a seperate method */
        private static void PersistTemplateProperty(TextWriter sw, String templateName, ITemplate template)
        {
            if (template == null) {
                return;
            }

            //string templateContent = ((TemplateBuilder)template).Text;
            string templateContent;
            
            Debug.Assert(template is TemplateBuilder, "Unexpected ITemplate implementation.");
            if (template is TemplateBuilder) {
                templateContent = ((TemplateBuilder)template).Text;
            }
            else {
                templateContent = String.Empty;
            }

            sw.WriteLine();
            sw.Write('<');
// changed propDesc.Name to templateName
            sw.Write(templateName);
            sw.Write('>');
            if (!templateContent.StartsWith("\r\n")) {
                sw.WriteLine();
            }
            
            sw.Write(templateContent);

            if (!templateContent.EndsWith("\r\n")) {
                sw.WriteLine();
            }
            sw.Write("</");
// changed propDesc.Name to templateName
            sw.Write(templateName);
            sw.WriteLine('>');
        }

        /// <overload>
        ///    <para>
        ///       Gets a string that can
        ///       persist a control.
        ///    </para>
        /// </overload>
        /// <summary>
        ///    <para>
        ///       Gets a string that can
        ///       persist a control.
        ///    </para>
        /// </summary>
        /// <param name='control'>
        ///    The control to persist.
        /// </param>
        /// <returns>
        ///    <para>
        ///       A string that contains the persistable information about
        ///       the control.
        ///    </para>
        /// </returns>
        internal static string PersistControl(Control control) {
            StringWriter sw = new StringWriter();

            PersistControl(sw, control);
            return sw.ToString();
        }

        /// <overload>
        ///    <para>
        ///       Returns a string that can
        ///       persist a control.
        ///    </para>
        /// </overload>
        /// <summary>
        ///    <para>
        ///       Returns a string that can
        ///       persist a control.
        ///    </para>
        /// </summary>
        /// <param name='control'>
        ///    The control to persist.
        /// </param>
        /// <param name='host'>
        ///    The services interface exposed by the webforms designer.
        /// </param>
        /// <returns>
        ///    <para>
        ///       A string that contains the persistable information about
        ///       the control.
        ///    </para>
        /// </returns>
        internal static string PersistControl(Control control, IDesignerHost host) {
            StringWriter sw = new StringWriter();

            PersistControl(sw, control, host);
            return sw.ToString();
        }

        /// <summary>
        ///    <para>
        ///       Persists a control using the
        ///       specified string writer.
        ///    </para>
        /// </summary>
        /// <param name='sw'>
        ///    The string writer to use.
        /// </param>
        /// <param name=' control'>
        ///    The control to persist.
        /// </param>
        internal static void PersistControl(TextWriter sw, Control control) {
            if (control is LiteralControl) {
                PersistLiteralControl(sw, (LiteralControl)control);
                return;
            }
            if (control is DesignerDataBoundLiteralControl) {
                PersistDataBoundLiteralControl(sw, (DesignerDataBoundLiteralControl)control);
                return;
            }

            ISite site = control.Site;
            if (site == null) {
                IComponent baseComponent = (IComponent)control.Page;
                Debug.Assert(baseComponent != null, "Control does not have its Page set!");
                if (baseComponent != null) {
                    site = baseComponent.Site;
                }
            }

            IDesignerHost host = null;
            if (site != null) {
                host = (IDesignerHost)site.GetService(typeof(IDesignerHost));
            }

            Debug.Assert(host != null, "Did not get a valid IDesignerHost reference. Expect persistence problems!");

            PersistControl(sw, control, host);
        }

        /// <summary>
        ///    <para>
        ///       Persists a control using the
        ///       specified string writer.
        ///    </para>
        /// </summary>
        /// <param name='sw'>
        ///    The string writer to use.
        /// </param>
        /// <param name=' control'>
        ///    The control to persist.
        /// </param>
        /// <param name='host'>
        ///    The services interface exposed by the webforms designer.
        /// </param>
        internal static void PersistControl(TextWriter sw, Control control, IDesignerHost host) {
            // Literals and DataBoundLiterals must be handled specially, since they
            // don't have a tag around them
            if (control is LiteralControl) {
                PersistLiteralControl(sw, (LiteralControl)control);
                return;
            }
            if (control is DesignerDataBoundLiteralControl) {
                PersistDataBoundLiteralControl(sw, (DesignerDataBoundLiteralControl)control);
                return;
            }

            Debug.Assert(host != null, "Did not get a valid IDesignerHost reference. Expect persistence problems!");

            string tagName = null;
            bool isUserControl = false;

            if (control is HtmlControl) {
                tagName = ((HtmlControl)control).TagName;
            }
            else if (control is UserControl) 
            {
                tagName = ((IUserControlDesignerAccessor)control).TagName;
                Debug.Assert((tagName != null) && (tagName.Length != 0));
                
                if (tagName.Length == 0) 
                {
                    // not enough information to go any further... no options, other than to throw this control out
                    return;
                }
                
                isUserControl = true;
            }
            else {
                tagName = GetDeclarativeType(control.GetType(), host);
            }

            sw.Write('<');
            sw.Write(tagName);
            sw.Write(" runat=\"server\"");
            PersistAttributes(sw, control, String.Empty, null);
            sw.Write('>');

            if (isUserControl == false) 
            {
                PersistChildrenAttribute pca =
                    (PersistChildrenAttribute)TypeDescriptor.GetAttributes(control.GetType())[typeof(PersistChildrenAttribute)];

                if (pca.Persist == true) 
                {
                    if (control.HasControls()) 
                    {
                        // asurt 106696: Ensure parent control's visibility is true.
                        bool oldVisible = control.Visible;
                        try 
                        {
                            control.Visible = true;
                            PersistChildControls(sw, control.Controls, host);
                        }
                        finally 
                        {
                            control.Visible = oldVisible;
                        }
                    }
                }
                else 
                {
                    // controls marked with LiteralContent == true shouldn't have
                    // children in their persisted form. They only build children
                    // collections at runtime.

                    PersistInnerProperties(sw, control, host);
                }
            }
            else 
            {
                string innerText = ((IUserControlDesignerAccessor)control).InnerText;
                if ((innerText != null) && (innerText.Length != 0)) 
                {
                    sw.Write(innerText);
                }
            }

            sw.Write("</");
            sw.Write(tagName);
            sw.WriteLine('>');
        }

        /// <summary>
        ///    <para>
        ///       Persists the child controls of
        ///       the control using the specified string writer.
        ///    </para>
        /// </summary>
        /// <param name='sw'>
        ///    The string writer to use.
        /// </param>
        /// <param name=' controls'>
        ///    The control collection to persist.
        /// </param>
        /// <param name='host'>
        ///    The services interface exposed by the webforms designer.
        /// </param>
        private static void PersistChildControls(TextWriter sw, ControlCollection controls, IDesignerHost host) {
            int children = controls.Count;
  
            for (int i = 0; i < children; i++) {
                PersistControl(sw, controls[i], host);
            }
        }

        private static void PersistDataBoundLiteralControl(TextWriter sw, DesignerDataBoundLiteralControl control) {
            Debug.Assert(((IDataBindingsAccessor)control).HasDataBindings == true);

            DataBindingCollection bindings = ((IDataBindingsAccessor)control).DataBindings;
            DataBinding textBinding = bindings["Text"];
            Debug.Assert(textBinding != null, "Did not get a Text databinding from DesignerDataBoundLiteralControl");
            
            if (textBinding != null) {
                sw.Write("<%# ");
                sw.Write(textBinding.Expression);
                sw.Write(" %>");
            }
        }

        private static void PersistLiteralControl(TextWriter sw, LiteralControl control) {
            Debug.Assert(control.Text != null);
            sw.Write(control.Text);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\listitemspage.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListItemsPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Web.UI.Design.Util;

    using System.Web.UI.MobileControls;
    using System.Web.UI.Design.MobileControls.Util;

    using Button     = System.Windows.Forms.Button;
    using Label      = System.Windows.Forms.Label;
    using TextBox    = System.Windows.Forms.TextBox;
    using CheckBox   = System.Windows.Forms.CheckBox;
    using TreeView   = System.Windows.Forms.TreeView;

    /// <summary>
    ///   The Items page for the List control.
    /// </summary>
    /// <internalonly/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class ListItemsPage : ListComponentEditorPage
    {
        private IListDesigner _listDesigner;
        private CheckBox      _itemsAsLinksCheckBox;
        private TextBox       _txtValue;
        private CheckBox      _ckbSelected;
        private bool          _isBaseControlList;

        public ListItemsPage()
        {
            TreeViewTitle  = SR.GetString(SR.ListItemsPage_ItemCaption);
            AddButtonTitle = SR.GetString(SR.ListItemsPage_NewItemCaption);
            DefaultName    = SR.GetString(SR.ListItemsPage_DefaultItemText);
        }

        protected override String HelpKeyword 
        {
            get 
            {
                if (_isBaseControlList)
                {
                    return "net.Mobile.ListProperties.Items";
                }
                else
                {
                    return "net.Mobile.SelectionListProperties.Items";
                }
            }
        }

        protected override bool FilterIllegalName()
        {
            return false;
        }

        protected override String GetNewName()
        {
            return SR.GetString(SR.ListItemsPage_DefaultItemText);
        }

        protected override void InitForm()
        {
            Debug.Assert(GetBaseControl() != null);
            _isBaseControlList = (GetBaseControl() is List);
            this._listDesigner = (IListDesigner)GetBaseDesigner();

            Y = (_isBaseControlList ? 52 : 24);

            base.InitForm();

            this.Text = SR.GetString(SR.ListItemsPage_Title);
            this.CommitOnDeactivate = true;
            this.Icon = new Icon(
                typeof(System.Web.UI.Design.MobileControls.MobileControlDesigner),
                "Items.ico"
            );
            this.Size = new Size(382, 220);

            if (_isBaseControlList)
            {
                _itemsAsLinksCheckBox = new CheckBox();
                _itemsAsLinksCheckBox.SetBounds(4, 4, 370, 16);
                _itemsAsLinksCheckBox.Text = SR.GetString(SR.ListItemsPage_ItemsAsLinksCaption);
                _itemsAsLinksCheckBox.FlatStyle = FlatStyle.System;
                _itemsAsLinksCheckBox.CheckedChanged += new EventHandler(this.OnSetPageDirty);
                _itemsAsLinksCheckBox.TabIndex = 0;
            }

            GroupLabel grplblItemList = new GroupLabel();
            grplblItemList.SetBounds(4, _isBaseControlList ? 32 : 4, 372, LabelHeight);
            grplblItemList.Text = SR.GetString(SR.ListItemsPage_ItemListGroupLabel);
            grplblItemList.TabIndex = 1;
            grplblItemList.TabStop = false;

            TreeList.TabIndex = 2;

            Label lblValue = new Label();
            lblValue.SetBounds(X, Y, 134, LabelHeight);
            lblValue.Text = SR.GetString(SR.ListItemsPage_ItemValueCaption);
            lblValue.TabStop = false;
            lblValue.TabIndex = Index;

            Y += LabelHeight;
            _txtValue = new TextBox();
            _txtValue.SetBounds(X, Y, 134, CmbHeight);
            _txtValue.TextChanged += new EventHandler(this.OnPropertyChanged);
            _txtValue.TabIndex = Index + 1;

            this.Controls.AddRange(new Control[] 
                                    {
                                        grplblItemList,
                                        lblValue,
                                        _txtValue
                                    });

            if (_isBaseControlList)
            {
                this.Controls.Add(_itemsAsLinksCheckBox);
            }
            else
            {
                Y += CellSpace;
                _ckbSelected = new CheckBox();
                _ckbSelected.SetBounds(X, Y, 134, LabelHeight);
                _ckbSelected.FlatStyle = System.Windows.Forms.FlatStyle.System;
                _ckbSelected.Text = SR.GetString(SR.ListItemsPage_ItemSelectedCaption); 
                _ckbSelected.CheckedChanged += new EventHandler(this.OnPropertyChanged);
                _ckbSelected.TabIndex = Index + 2;
                this.Controls.Add(_ckbSelected);
            }
        }

        protected override void InitPage() 
        {
            base.InitPage();

            if (_isBaseControlList)
            {
                List list = (List)GetBaseControl();
                _itemsAsLinksCheckBox.Checked = list.ItemsAsLinks;
            }
            else
            {
                _ckbSelected.Checked = false;
            }
            _txtValue.Text = String.Empty;
        }

        protected override void LoadItems()
        {
            using (new LoadingModeResource(this))
            {
                foreach (MobileListItem item in _listDesigner.Items)
                {
                    ItemTreeNode newNode = new ItemTreeNode(item);
                    TreeList.TvList.Nodes.Add(newNode);
                }
            }
        }

        protected override void LoadItemProperties() 
        {
            using (new LoadingModeResource(this))
            {
                if (CurrentNode != null)
                {
                    ItemTreeNode currentItemNode = (ItemTreeNode)CurrentNode;
                    _txtValue.Text = currentItemNode.Value;
                    if (!_isBaseControlList)
                    {
                        _ckbSelected.Checked = currentItemNode.Selected;
                    }
                }
                else
                {
                    _txtValue.Text = String.Empty;
                    if (!_isBaseControlList)
                    {
                        _ckbSelected.Checked = false;
                    }
                }
            }
        }

        protected override void OnAfterLabelEdit(Object source, NodeLabelEditEventArgs e)
        {
            base.OnAfterLabelEdit(source, e);

            if (!((ItemTreeNode)CurrentNode).ValueSet)
            {
                _txtValue.Text = ((ItemTreeNode)CurrentNode).Value = CurrentNode.Name;
            }
        }

        protected override void OnClickAddButton(Object source, EventArgs e)
        {
            if (IsLoading())
            {
                return;
            }

            ItemTreeNode newNode = new ItemTreeNode(GetNewName());
            TreeList.TvList.Nodes.Add(newNode);

            TreeList.TvList.SelectedNode = newNode;
            CurrentNode = newNode;
            newNode.Dirty = true;
            newNode.BeginEdit();

            LoadItemProperties();

            SetDirty();
        }

        private void OnSetPageDirty(Object source, EventArgs e) 
        {
            if (IsLoading())
            {
                return;
            }
            SetDirty();
        }

        protected override void OnPropertyChanged(Object source, EventArgs e)
        {
            // This means there are no fields yet. Do nothing
            if (CurrentNode == null || IsLoading())
            {
                return;
            }

            if (source is TextBox)
            {
                ((ItemTreeNode)CurrentNode).Value = _txtValue.Text;
            }
            else
            {
                Debug.Assert(!_isBaseControlList);
                ((ItemTreeNode)CurrentNode).Selected = _ckbSelected.Checked;
            }

            SetDirty();
            CurrentNode.Dirty = true;
        }

        protected override void SaveComponent()
        {
            // Delegate to base implementation first!
            // This will properly close ListTreeNode editing mode.
            base.SaveComponent();

            _listDesigner.Items.Clear();

            foreach (ItemTreeNode itemNode in TreeList.TvList.Nodes)
            {
                if (itemNode.Dirty)
                {
                    itemNode.RuntimeItem.Text  = itemNode.Text;
                    itemNode.RuntimeItem.Value = itemNode.Value;
                    if (!_isBaseControlList)
                    {
                        itemNode.RuntimeItem.Selected = itemNode.Selected;
                    }
                }

                _listDesigner.Items.Add(itemNode.RuntimeItem);
            }

            if (_isBaseControlList)
            {
                List list = (List)GetBaseControl();
                list.ItemsAsLinks = _itemsAsLinksCheckBox.Checked;
                TypeDescriptor.Refresh(list);
            }
            else
            {
                SelectionList selectionList = (SelectionList)GetBaseControl();
                TypeDescriptor.Refresh(selectionList);
            }
        }

        protected override void UpdateControlsEnabling()
        {
            if (TreeList.TvList.SelectedNode == null)
            {
                TreeList.TvList.Enabled = _txtValue.Enabled = false;
                _txtValue.Text = String.Empty;
            }
            else
            {
                TreeList.TvList.Enabled = _txtValue.Enabled = true;
            }

            if (!_isBaseControlList)
            {
                SelectionList selectionListControl = (SelectionList) GetBaseControl();
                if (TreeList.TvList.SelectedNode == null)
                {
                    _ckbSelected.Enabled = false;
                    _ckbSelected.Checked = false;
                }
                else
                {
                    _ckbSelected.Enabled = true;
                }
            }
        }

        /// <summary>
        ///    Internal object used to store all items properties
        /// </summary>
        [
            System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        private class ItemTreeNode : ListTreeNode
        {
            private MobileListItem _runtimeItem;
            private String _value;
            private bool _selected;
            private bool _valueSet = false;

            /// <summary>
            /// </summary>
            internal ItemTreeNode(String itemText) : base(itemText)
            {
                this._runtimeItem = new MobileListItem();
                this._value = null;
                this._selected = false;
            }

            /// <summary>
            /// </summary>
            internal ItemTreeNode(MobileListItem runtimeItem) : base(runtimeItem.Text)
            {
                Debug.Assert(runtimeItem != null, "runtimeItem is null");

                _valueSet = true;
                this._runtimeItem = runtimeItem;
                this._value = _runtimeItem.Value;
                this._selected = _runtimeItem.Selected;
            }

            internal MobileListItem RuntimeItem
            {
                get
                {
                    return _runtimeItem;
                }
            }

            internal String Value
            {
                get
                {
                    return _value;
                }

                set
                {
                    _value = value;
                    _valueSet = true;
                }
            }

            internal bool Selected
            {
                get
                {
                    return _selected;
                }

                set
                {
                    _selected = value;
                }
            }

            internal bool ValueSet
            {
                get
                {
                    return _valueSet;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\mobilecontainerdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileContainerDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Globalization;
    using System.Web.UI.Design.MobileControls.Adapters;
    using System.Web.UI.MobileControls;
    using System.Web.UI.MobileControls.Adapters;

    using IHTMLElement = NativeMethods.IHTMLElement;
    using IHTMLElementCollection = NativeMethods.IHTMLElementCollection;

    /// <summary>
    ///    <para>Provides a base designer class for all mobile container controls.</para>
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal abstract class MobileContainerDesigner : ControlDesigner, IMobileDesigner
    {
        private MobileControl               _mobileControl;
        private readonly Size               _defaultSize;
        private bool                        _containmentStatusDirty = true;
        private bool                        _hasAttributesCached = false;
        private bool                        _shouldDirtyPage = false;
        private ContainmentStatus           _containmentStatus = ContainmentStatus.Unknown;
        private IDictionary                 _behaviorAttributes;
        private String                      _currentErrorMessage = null;
        private IWebFormsDocumentService    _iWebFormsDocumentService;
        private IMobileWebFormServices      _iMobileWebFormServices;
        private EventHandler                _loadComplete = null;

        // cached Behavior object
        private IHtmlControlDesignerBehavior _cachedBehavior = null;

        /// <summary>
        ///    <para>
        ///       Initializes an instance of the <see cref='System.Web.UI.Design.MobileControls.MobileContainerDesigner'/> class.
        ///    </para>
        /// </summary>
        internal MobileContainerDesigner() 
        {
            ReadOnly = false;

            _defaultSize = new Size(300, 100);
            _behaviorAttributes = new HybridDictionary();
        }

        /// <summary>
        /// return the containment status
        /// </summary>
        protected ContainmentStatus ContainmentStatus
        {
            get
            {
                if (!_containmentStatusDirty)
                {
                    return _containmentStatus;
                }

                _containmentStatus = 
                    DesignerAdapterUtil.GetContainmentStatus(_mobileControl);

                _containmentStatusDirty = false;
                return _containmentStatus;
            }
        }

        internal new Object DesignTimeElement
        {
            get
            {
                return base.DesignTimeElement;
            }
        }

        private IMobileWebFormServices IMobileWebFormServices
        {
            get
            {
                if (_iMobileWebFormServices == null)
                {
                    _iMobileWebFormServices = 
                        (IMobileWebFormServices)GetService(typeof(IMobileWebFormServices));
                }

                return _iMobileWebFormServices;
            }
        }

        private IWebFormsDocumentService IWebFormsDocumentService
        {
            get
            {
                if (_iWebFormsDocumentService == null)
                {
                    _iWebFormsDocumentService =
                        (IWebFormsDocumentService)GetService(typeof(IWebFormsDocumentService));

                    Debug.Assert(_iWebFormsDocumentService != null);
                }

                return _iWebFormsDocumentService;
            }
        }

        /// <summary>
        ///     Indicates whether the initial page load is completed
        /// </summary>
        protected bool LoadComplete
        {
            get
            {
                return !IWebFormsDocumentService.IsLoading;
            }
        }

        /// <summary>
        ///    Control's style, available only when page is MobilePage
        /// </summary>
        protected Style Style
        {
            get
            {
                if (!DesignerAdapterUtil.InMobilePage(_mobileControl))
                {
                    return null;
                }

                Style style = ((ControlAdapter)_mobileControl.Adapter).Style;

                // Each MobileControl should have its own style
                Debug.Assert(style != null);

                return style;
            }
        }

        /// <summary>
        ///    Apply style related properties to behavior
        /// </summary>
        /// <param name="propName">
        ///    property that needs to be applied, null to apply all
        /// </param>
        private void ApplyPropertyToBehavior(String propName)
        {
            if (Style == null)
            {
                return;
            }

            if (propName == null || propName.Equals("BackColor"))
            {
                Color backColor = (Color)Style[Style.BackColorKey, true];
                SetBehaviorStyle("backgroundColor", ColorTranslator.ToHtml(backColor));
            }
            if (propName == null || propName.Equals("ForeColor"))
            {
                Color foreColor = (Color)Style[Style.ForeColorKey, true];
                SetBehaviorStyle("color", ColorTranslator.ToHtml(foreColor));
            }
            if (propName == null || propName.Equals("Font"))
            {
                bool bold = 
                    (BooleanOption)Style[Style.BoldKey, true] == BooleanOption.True;
                bool italic = 
                    (BooleanOption)Style[Style.ItalicKey, true] == BooleanOption.True;
                FontSize  fontSize  = (FontSize) Style[Style.FontSizeKey , true];
                String    fontName  = (String)   Style[Style.FontNameKey , true];

                SetBehaviorStyle("fontWeight", bold? "bold" : "normal");
                SetBehaviorStyle("fontStyle", italic? "italic" : "normal");

                if (fontSize == FontSize.Large)
                {
                    SetBehaviorStyle("fontSize", "medium");
                }
                else if (fontSize == FontSize.Small)
                {
                    SetBehaviorStyle("fontSize", "x-small");
                }
                else
                {
                    RemoveBehaviorStyle("fontSize");
                }

                SetBehaviorStyle("fontFamily", fontName);
            }
            if (propName == null || propName.Equals("Alignment"))
            {
                Alignment alignment = (Alignment)Style[Style.AlignmentKey, true];
                bool alignmentNotSet = alignment == Alignment.NotSet;

                SetBehaviorStyle("textAlign", 
                    alignmentNotSet ? "" : Enum.Format(typeof(Alignment), alignment, "G"));
            }
        }

        /// <summary>
        ///   Performs the cleanup of the designer class.
        /// </summary>
        /// <seealso cref='IDesigner'/>
        protected override void Dispose(bool disposing) 
        {
            if (disposing)
            {
                if (_loadComplete != null)
                {
                    IWebFormsDocumentService.LoadComplete -= _loadComplete;
                    _loadComplete = null;
                }
            }

            base.Dispose(disposing);
        }

        /// <summary>
        ///   The default size of Container Control.
        /// </summary>
        protected virtual Size GetDefaultSize()
        {
            return _defaultSize;
        }

        /// <summary>
        ///    non-null string will render the text as an image
        ///    on the top of container control.
        /// </summary>
        protected virtual String GetErrorMessage(out bool infoMode)
        {
            infoMode = false;
            return null;
        }

        /// <summary>
        ///    <para>
        ///       Initializes the designer using
        ///       the specified component.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element being designed.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component being
        ///       designed.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is MobileControl,
                         "MobileContainerDesigner.Initialize - Invalid Mobile Control");

            _mobileControl = (MobileControl) component;
            base.Initialize(component);

            _loadComplete = new EventHandler(this.OnLoadComplete);
            IWebFormsDocumentService.LoadComplete += _loadComplete;
        }

        /// <summary>
        ///    return true if the property is an appearance attribute that needs
        ///    to apply to all child controls.
        /// </summary>
        /// <param name="propertyName">
        /// </param>
        private bool IsAppearanceAttribute(String propertyName)
        {
            return (
                propertyName.Equals("Font") ||
                propertyName.Equals("ForeColor") ||
                propertyName.Equals("BackColor") ||
                propertyName.Equals("Wrapping") ||
                propertyName.Equals("Alignment") ||
                propertyName.Equals("StyleReference"));
        }

        internal virtual void OnBackgroundImageChange(String message, bool infoMode)
        {
        }

        /// <summary>
        ///    <para>
        ///       Notification that is called when the designer is attached to the behavior.
        ///    </para>
        /// </summary>
        protected override void OnBehaviorAttached()
        {
            Debug.Assert(_cachedBehavior == null);
            _cachedBehavior = Behavior;

            PrefixDeviceSpecificTags();
            base.OnBehaviorAttached();

            // Reload the original state if an old Behavior is cached.
            if (_hasAttributesCached)
            {
                ReloadBehaviorState();
            }
        }

        /// <summary>
        ///    Notification that is called when the behavior is detached from designer
        /// </summary>
        protected override void OnBehaviorDetaching()
        {
            // dispose the cached behavior.
            _cachedBehavior = null;
        }

        /// <summary>
        ///    <para>
        ///       Delegate to handle component changed event.
        ///    </para>
        /// </summary>
        /// <param name='sender'>
        ///    The object sending the event.
        /// </param>
        /// <param name='ce'>
        ///    The event object used when firing a component changed notification.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called after a property has been changed. It allows the implementor
        ///       to do any post-processing that may be needed after a property change.
        ///    </para>
        /// </remarks>
        public override void OnComponentChanged(Object sender, ComponentChangedEventArgs ce) 
        {
            // Delegate to the base class implementation first!
            base.OnComponentChanged(sender, ce);

            MemberDescriptor member = ce.Member;
            if (member != null && 
                member.GetType().FullName.Equals(Constants.ReflectPropertyDescriptorTypeFullName))
            {
                PropertyDescriptor propDesc = (PropertyDescriptor)member;
                String propName = propDesc.Name;

                if (IsAppearanceAttribute(propName))
                {
                    // Update control rendering
                    UpdateRenderingRecursive();
                }
            }
        }

        /// <summary>
        ///   Subclasses can override to modify their container appearance,
        ///   this method is invoked by OnLoadComplete()
        /// </summary>
        protected virtual void OnContainmentChanged()
        {
            // do nothing
        }

        /// <summary>
        ///     helper method for external UIs
        /// </summary>
        protected virtual void OnInternalChange() 
        {
            ISite site = _mobileControl.Site;
            if (site != null) 
            {
                IComponentChangeService changeService =
                    (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                if (changeService != null) 
                {
                    try 
                    {
                        changeService.OnComponentChanging(_mobileControl, null);
                    }
                    catch (CheckoutException ex)
                    {
                        if (ex == CheckoutException.Canceled)
                            return;
                        throw;
                    }
                    changeService.OnComponentChanged(_mobileControl, null, null, null);
                }
            }
        }

        /// <summary>
        ///    <para>
        ///       Notification that is called when the page completes loading.
        ///    </para>
        /// </summary>
        private void OnLoadComplete(Object source, EventArgs e) 
        {
            // Need to apply behavior attributes since none are cached
            if (!_hasAttributesCached)
            {
                SetControlDefaultAppearance();

                // Apply the style properties to Behavior
                ApplyPropertyToBehavior(null);
            }

            bool infoMode = false;
            String msg = GetErrorMessage(out infoMode);
            if (msg != _currentErrorMessage || !_hasAttributesCached)
            {
                OnBackgroundImageChange(msg, infoMode);
                _currentErrorMessage = msg;
            }

            // we could reload the attributes
            _hasAttributesCached = true;

            // Change containment related appearance
            OnContainmentChanged();

            // Don't forget the change children appearance,
            // this call is necessary to solve multi-nested control problem.
            UpdateRenderingRecursive();

            // Make the page dirty by calling OnInternalChange if an subsitution occurs.
            if (_shouldDirtyPage)
            {
                OnInternalChange();
                _shouldDirtyPage = false;
            }
        }

        /// <summary>
        ///    <para>
        ///       Notification that is called when the associated control is parented.
        ///    </para>
        /// </summary>
        public override void OnSetParent()
        {
            base.OnSetParent();

            // The containment status is invalidated
            _containmentStatusDirty = true;

            // Make sure the control refreshes when it is moved around
            if (LoadComplete)
            {
                OnLoadComplete(this, EventArgs.Empty);
            }
        }

        /// <summary>
        ///    dynamically transform DeviceSpecific element to a server control,
        ///    called from OnBehaviorAttached
        /// </summary>
        private void PrefixDeviceSpecificTags()
        {
            IHTMLElement htmlElement = (IHTMLElement) DesignTimeElement;
            Debug.Assert(htmlElement != null, 
                "Invalid HTML element in FormDesigner.OnBehaviorAttached");

            IWebFormReferenceManager refMgr =
                (IWebFormReferenceManager) GetService(typeof(IWebFormReferenceManager));
            Debug.Assert(refMgr != null, "Did not get back IWebFormReferenceManager service.");

            String tagPrefix = refMgr.GetTagPrefix(typeof(DeviceSpecific));
            Debug.Assert(tagPrefix != null && tagPrefix.Length > 0, "TagPrefix is invalid");

            IHTMLElementCollection allChildren = (IHTMLElementCollection) htmlElement.GetChildren();
            if (null != allChildren)
            {
                bool substitutions = false;
                int nestingLevel = 0;
                String modifiedInnerHTML = String.Empty;
                for (Int32 i = 0; i < allChildren.GetLength(); i++)
                {
                    IHTMLElement htmlChild = (IHTMLElement) allChildren.Item(i, 0);
                    Debug.Assert(null != htmlChild, "htmlChild is null");
                    String childContent = htmlChild.GetOuterHTML();
                    String childUpperContent = childContent.ToUpper(CultureInfo.InvariantCulture);
                    if (childContent.StartsWith("<") &&
                        !(childContent.StartsWith("</") || (childContent.EndsWith("/>"))))
                    {
                        if (!childUpperContent.StartsWith("<" + tagPrefix.ToUpper(CultureInfo.InvariantCulture) + ":"))
                        {
                            nestingLevel++;
                        }
                    }
                    else if (childContent.StartsWith("</"))
                    {
                        nestingLevel--;
                    }
                    if (1 == nestingLevel && 
                        childUpperContent.StartsWith("<DEVICESPECIFIC") &&
                        childUpperContent.EndsWith(">"))
                    {
                        Debug.Assert(substitutions == false, "substitutions is true");
                        modifiedInnerHTML += "<" + tagPrefix + ":DeviceSpecific runat=\"server\">\r\n";
                        substitutions = true;
                    }
                    else if (1 == nestingLevel && 
                             childUpperContent.StartsWith("<DEVICESPECIFIC") &&
                             childUpperContent.EndsWith("/>"))
                    {
                        modifiedInnerHTML += "<" + tagPrefix + ":DeviceSpecific runat=\"server\"></" + tagPrefix + ":DeviceSpecific>\r\n";
                        substitutions = true;
                    }
                    else if (0 == nestingLevel && 0 == String.Compare(childUpperContent, "</DEVICESPECIFIC>", false))
                    {
                        Debug.Assert(substitutions == true, "substitutions is false");
                        modifiedInnerHTML += "</" + tagPrefix + ":DeviceSpecific>\r\n";
                    }
                    else
                    {
                        modifiedInnerHTML += childContent + "\r\n";
                    }
                }
                if (substitutions)
                {
                    _shouldDirtyPage = true;
                    htmlElement.SetInnerHTML(modifiedInnerHTML);
                }
            }
        }

        /// <summary>
        ///    Reload the cached Behavior states
        /// </summary>
        private void ReloadBehaviorState()
        {
            Debug.Assert(Behavior != null && _behaviorAttributes != null);

            IDictionaryEnumerator enumerator = _behaviorAttributes.GetEnumerator();
            while (enumerator.MoveNext())
            {
                String key = (String)enumerator.Key;
                Object obj = _behaviorAttributes[key];

                Behavior.SetStyleAttribute(key, true, obj, true);
            }
        }

        /// <summary>
        ///    Remove the attribute from Behavior
        /// </summary>
        /// <param name="attribute">
        ///    attribute that need to be removed.
        /// </param>
        protected void RemoveBehaviorStyle(String attribute)
        {
            Debug.Assert (_behaviorAttributes != null);

            if (Behavior != null)
            {
                Behavior.RemoveStyleAttribute(attribute, true, true);
            }

            // also remove the cached attribute
            _behaviorAttributes.Remove(attribute);
        }

        /// <summary>
        ///    Apply the style attribute to Behavior
        /// </summary>
        /// <param name="attribute">
        ///    attribute that needs to be applied to Behavior
        /// </param>
        /// <param name="obj">
        ///    value to apply
        /// </param>
        protected void SetBehaviorStyle(String attribute, Object obj)
        {
            Debug.Assert (obj != null, "null object passed in!");
            Debug.Assert (_behaviorAttributes != null);

            // here we cache the value;
            // Note that the value is cached even if Behavior is not available,
            // this is because this method could be called between Behavior
            // detached and attached events, we want to re-apply these lost
            // attributes when Behavior is attached again.
            _behaviorAttributes[attribute] = obj;

            if (Behavior == null)
            {
                return;
            }
            Behavior.SetStyleAttribute(attribute, true, obj, true);
        }

        /// <summary>
        ///    This method will be called only once when the control is first created.
        /// </summary>
        protected virtual void SetControlDefaultAppearance()
        {
            // Default border appearance 
            SetBehaviorStyle("borderWidth", "1px");
            SetBehaviorStyle("borderColor", ColorTranslator.ToHtml(SystemColors.ControlDark));

            // Default margin, paddings for container controls.
            SetBehaviorStyle("paddingTop", "8px");
            SetBehaviorStyle("paddingBottom", "8px");
            SetBehaviorStyle("paddingRight", "4px");
            SetBehaviorStyle("paddingLeft", "5px");
            SetBehaviorStyle("marginTop", "3px");
            SetBehaviorStyle("marginBottom", "3px");
            SetBehaviorStyle("marginRight", "5px");
            SetBehaviorStyle("marginLeft", "5px");

            // Setup background parameters
            SetBehaviorStyle("backgroundRepeat", "no-repeat");
            SetBehaviorStyle("backgroundAttachment", "fixed");
            SetBehaviorStyle("backgroundPositionX", "left");
            SetBehaviorStyle("backgroundPositionY", "top");

            // Container sze info.
            SetBehaviorStyle("height", GetDefaultSize().Height);
            SetBehaviorStyle("width", GetDefaultSize().Width);
        }

        /// <summary>
        ///   Update the designtime rendering for the container control
        /// </summary>
        public void UpdateRendering()
        {
            _mobileControl.RefreshStyle();
            ApplyPropertyToBehavior(null);
        }

        /// <summary>
        ///   Update the designtime rendering for the container control and all controls
        ///   inside this container control.
        /// </summary>
        private void UpdateRenderingRecursive()
        {
            UpdateRendering();

            if (IMobileWebFormServices != null)
            {
                IMobileWebFormServices.UpdateRenderingRecursive(_mobileControl);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\mobileuitypeeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileUITypeEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing.Design;
    using System.Diagnostics;

    /// <summary>
    ///    <para>
    ///       The editor for column collections.
    ///    </para>
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class MobileUITypeEditor : UITypeEditor 
    {
        protected ControlDesigner GetDesigner(ITypeDescriptorContext context)
        {
            IDesignerHost designerHost = (IDesignerHost)context.GetService(typeof(IDesignerHost));
            Debug.Assert(designerHost != null, "Did not get DesignerHost service.");

            Debug.Assert(context.Instance is Control, "Expected Control");
            Control control = (Control)context.Instance;

            ControlDesigner designer = (ControlDesigner)designerHost.GetDesigner(control);
            Debug.Assert(designer != null, "Did not get designer for component");

            return designer;
        }

        /// <summary>
        ///    <para>
        ///       Gets the edit style.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    An <see cref='System.ComponentModel.ITypeDescriptorContext'/> that specifies the associated context.
        /// </param>
        /// <returns>
        ///    <para>
        ///       A <see cref='System.Drawing.Design.UITypeEditorEditStyle'/> that represents the edit style.
        ///    </para>
        /// </returns>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) 
        {
            return UITypeEditorEditStyle.Modal;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\nativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [System.Runtime.InteropServices.ComVisible(false)]
    internal class NativeMethods {

        internal const int WS_EX_STATICEDGE = 0x00020000;
        internal const int S_OK =      0x00000000;
        internal const int S_FALSE =   0x00000001;
        internal const int E_NOTIMPL = unchecked((int)0x80004001);
        internal const int E_NOINTERFACE = unchecked((int)0x80004002);
        internal const int E_INVALIDARG = unchecked((int)0x80070057);
        internal const int E_FAIL = unchecked((int)0x80004005);

        internal const int
            OLEIVERB_PRIMARY = 0,
            OLEIVERB_SHOW = -1,
            OLEIVERB_OPEN = -2,
            OLEIVERB_HIDE = -3,
            OLEIVERB_UIACTIVATE = -4,
            OLEIVERB_INPLACEACTIVATE = -5,
            OLEIVERB_DISCARDUNDOSTATE = -6,
            OLEIVERB_PROPERTIES = -7;

        internal const int
            OLECLOSE_SAVEIFDIRTY = 0,
            OLECLOSE_NOSAVE = 1,
            OLECLOSE_PROMPTSAVE = 2;

        internal const int
            PM_NOREMOVE = 0x0000,
            PM_REMOVE = 0x0001;

        internal const int
            WM_CHAR = 0x0102;

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        internal static extern bool GetClientRect(IntPtr hWnd, [In, Out] ref RECT rect);

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        internal static extern bool GetClientRect(IntPtr hWnd, [In, Out] COMRECT rect);

        [StructLayout(LayoutKind.Sequential)]
        internal class POINT 
        {
            internal int x;
            internal int y;

            internal POINT() 
            {
            }

            internal POINT(int x, int y) 
            {
                this.x = x;
                this.y = y;
            }
        }

        internal class DOCHOSTUIDBLCLICK 
        {
            internal const int DEFAULT = 0x0;
            internal const int SHOWPROPERTIES = 0x1;
            internal const int SHOWCODE = 0x2;
        }

        internal class DOCHOSTUIFLAG 
        {
            internal const int DIALOG = 0x1;
            internal const int DISABLE_HELP_MENU = 0x2;
            internal const int NO3DBORDER = 0x4;
            internal const int SCROLL_NO = 0x8;
            internal const int DISABLE_SCRIPT_INACTIVE = 0x10;
            internal const int OPENNEWWIN = 0x20;
            internal const int DISABLE_OFFSCREEN = 0x40;
            internal const int FLAT_SCROLLBAR = 0x80;
            internal const int DIV_BLOCKDEFAULT = 0x100;
            internal const int ACTIVATE_CLIENTHIT_ONLY = 0x200;
            internal const int DISABLE_COOKIE = 0x400;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct RECT 
        {
            internal int left;
            internal int top;
            internal int right;
            internal int bottom;

            internal RECT(int left, int top, int right, int bottom) 
            {
                this.left = left;
                this.top = top;
                this.right = right;
                this.bottom = bottom;
            }

            internal static RECT FromXYWH(int x, int y, int width, int height) 
            {
                return new RECT(x,
                    y,
                    x + width,
                    y + height);
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct MSG 
        {
            internal IntPtr hwnd;
            internal int  message;
            internal IntPtr wParam;
            internal IntPtr lParam;
            internal int  time;
            // pt was a by-value POINT structure
            internal int  pt_x;
            internal int  pt_y;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        internal sealed class FORMATETC 
        {
            [MarshalAs(UnmanagedType.I4)]
            internal   int cfFormat;
            [MarshalAs(UnmanagedType.I4)]
            internal   IntPtr ptd;
            [MarshalAs(UnmanagedType.I4)]
            internal   int dwAspect;
            [MarshalAs(UnmanagedType.I4)]
            internal   int lindex;
            [MarshalAs(UnmanagedType.I4)]
            internal   int tymed;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        internal class STGMEDIUM 
        {
            [MarshalAs(UnmanagedType.I4)]
            internal   int tymed;
            internal   IntPtr unionmember;
            internal   IntPtr pUnkForRelease;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
        internal sealed class tagOLEVERB 
        {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)/*leftover(offset=0, lVerb)*/]
            internal int lVerb;

            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPWStr)/*leftover(offset=4, customMarshal="UniStringMarshaller", lpszVerbName)*/]
            internal String lpszVerbName;

            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U4)/*leftover(offset=8, fuFlags)*/]
            internal int fuFlags;

            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U4)/*leftover(offset=12, grfAttribs)*/]
            internal int grfAttribs;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        internal sealed class OLECMD 
        {
            [MarshalAs(UnmanagedType.U4)]
            internal   int cmdID;
            [MarshalAs(UnmanagedType.U4)]
            internal   int cmdf;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        internal sealed class tagLOGPALETTE 
        {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U2)]
            internal short palVersion;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U2)]
            internal short palNumEntries;

            // UNMAPPABLE: palPalEntry: Cannot be used as a structure field.
            //  /* @com.structmap(UNMAPPABLE palPalEntry) */
            //  internal UNMAPPABLE palPalEntry;
        }

        [System.Runtime.InteropServices.ComVisible(true), StructLayout(LayoutKind.Sequential)]
        internal sealed class tagSIZEL 
        {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)]
            internal int cx;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)]
            internal int cy;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal class COMRECT 
        {
            internal int left;
            internal int top;
            internal int right;
            internal int bottom;

            internal COMRECT() 
            {
            }

            internal COMRECT(int left, int top, int right, int bottom) 
            {
                this.left = left;
                this.top = top;
                this.right = right;
                this.bottom = bottom;
            }

            internal static COMRECT FromXYWH(int x, int y, int width, int height) 
            {
                return new COMRECT(x,
                    y,
                    x + width,
                    y + height);
            }
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        internal sealed class tagSIZE 
        {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)]
            internal int cx;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)]
            internal int cy;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        internal sealed class tagOIFI 
        {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U4)]
            internal int cb;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)]
            internal int fMDIApp;
            internal IntPtr hwndFrame;
            internal IntPtr hAccel;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U4)]
            internal int cAccelEntries;
        }

        [System.Runtime.InteropServices.ComVisible(true), StructLayout(LayoutKind.Sequential)]
        internal class DOCHOSTUIINFO 
        {
            [MarshalAs(UnmanagedType.U4)]
            internal int cbSize;
            [MarshalAs(UnmanagedType.I4)]
            internal int dwFlags;
            [MarshalAs(UnmanagedType.I4)]
            internal int dwDoubleClick;
            [MarshalAs(UnmanagedType.I4)]
            internal int dwReserved1;
            [MarshalAs(UnmanagedType.I4)]
            internal int dwReserved2;
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("0000000C-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IStream 
        {

            [return: MarshalAs(UnmanagedType.I4)]
            int Read(
                [In] 
                IntPtr buf,
                [In, MarshalAs(UnmanagedType.I4)] 
                int len);

            [return: MarshalAs(UnmanagedType.I4)]
            int Write(
                [In] 
                IntPtr buf,
                [In, MarshalAs(UnmanagedType.I4)] 
                int len);

            [return: MarshalAs(UnmanagedType.I8)]
            long Seek(
                [In, MarshalAs(UnmanagedType.I8)] 
                long dlibMove,
                [In, MarshalAs(UnmanagedType.I4)] 
                int dwOrigin);

            
            void SetSize(
                [In, MarshalAs(UnmanagedType.I8)] 
                long libNewSize);

            [return: MarshalAs(UnmanagedType.I8)]
            long CopyTo(
                [In, MarshalAs(UnmanagedType.Interface)] 
                IStream pstm,
                [In, MarshalAs(UnmanagedType.I8)] 
                long cb,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                long[] pcbRead);

            
            void Commit(
                [In, MarshalAs(UnmanagedType.I4)] 
                int grfCommitFlags);

            
            void Revert();

            
            void LockRegion(
                [In, MarshalAs(UnmanagedType.I8)] 
                long libOffset,
                [In, MarshalAs(UnmanagedType.I8)] 
                long cb,
                [In, MarshalAs(UnmanagedType.I4)] 
                int dwLockType);

            
            void UnlockRegion(
                [In, MarshalAs(UnmanagedType.I8)] 
                long libOffset,
                [In, MarshalAs(UnmanagedType.I8)] 
                long cb,
                [In, MarshalAs(UnmanagedType.I4)] 
                int dwLockType);

            
            void Stat(
                [In] 
                IntPtr pStatstg,
                [In, MarshalAs(UnmanagedType.I4)] 
                int grfStatFlag);

            [return: MarshalAs(UnmanagedType.Interface)]
            IStream Clone();
        }

		[System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F1FF-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
		internal interface IHTMLElement 
		{
			void SetAttribute(
				[In, MarshalAs(UnmanagedType.BStr)]
				string strAttributeName,
				[In, MarshalAs(UnmanagedType.Struct)]
				Object AttributeValue,
				[In, MarshalAs(UnmanagedType.I4)]
				int lFlags);

            
			void GetAttribute(
				[In, MarshalAs(UnmanagedType.BStr)]
				string strAttributeName,
				[In, MarshalAs(UnmanagedType.I4)]
				int lFlags,
				[Out, MarshalAs(UnmanagedType.LPArray)]
				Object[] pvars);

			[return: MarshalAs(UnmanagedType.Bool)]
			bool RemoveAttribute(
				[In, MarshalAs(UnmanagedType.BStr)]
				string strAttributeName,
				[In, MarshalAs(UnmanagedType.I4)]
				int lFlags);

            
			void SetClassName(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetClassName();

            
			void SetId(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetId();

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetTagName();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElement GetParentElement();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLStyle GetStyle();

            
			void SetOnhelp(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnhelp();

            
			void SetOnclick(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnclick();

            
			void SetOndblclick(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOndblclick();

            
			void SetOnkeydown(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnkeydown();

            
			void SetOnkeyup(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnkeyup();

            
			void SetOnkeypress(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnkeypress();

            
			void SetOnmouseout(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnmouseout();

            
			void SetOnmouseover(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnmouseover();

            
			void SetOnmousemove(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnmousemove();

            
			void SetOnmousedown(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnmousedown();

            
			void SetOnmouseup(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnmouseup();

			[return: MarshalAs(UnmanagedType.Interface)]
			object GetDocument();

            
			void SetTitle(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetTitle();

            
			void SetLanguage(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetLanguage();

            
			void SetOnselectstart(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnselectstart();

            
			void ScrollIntoView(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object varargStart);

			[return: MarshalAs(UnmanagedType.Bool)]
			bool Contains(
				[In, MarshalAs(UnmanagedType.Interface)]
				IHTMLElement pChild);

			[return: MarshalAs(UnmanagedType.I4)]
			int GetSourceIndex();

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetRecordNumber();

            
			void SetLang(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetLang();

			[return: MarshalAs(UnmanagedType.I4)]
			int GetOffsetLeft();

			[return: MarshalAs(UnmanagedType.I4)]
			int GetOffsetTop();

			[return: MarshalAs(UnmanagedType.I4)]
			int GetOffsetWidth();

			[return: MarshalAs(UnmanagedType.I4)]
			int GetOffsetHeight();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElement GetOffsetParent();

            
			void SetInnerHTML(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetInnerHTML();

            
			void SetInnerText(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetInnerText();

            
			void SetOuterHTML(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetOuterHTML();

            
			void SetOuterText(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetOuterText();

            
			void InsertAdjacentHTML(
				[In, MarshalAs(UnmanagedType.BStr)]
				string where,
				[In, MarshalAs(UnmanagedType.BStr)]
				string html);

            
			void InsertAdjacentText(
				[In, MarshalAs(UnmanagedType.BStr)]
				string where,
				[In, MarshalAs(UnmanagedType.BStr)]
				string text);

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElement GetParentTextEdit();

			[return: MarshalAs(UnmanagedType.Bool)]
			bool GetIsTextEdit();

            
			void Click();

			[return: MarshalAs(UnmanagedType.Interface)]
			object GetFilters();
			// UNDONE(CHANGED) IHTMLFiltersCollection -> object

            
			void SetOndragstart(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOndragstart();

			[return: MarshalAs(UnmanagedType.BStr)]
			string toString();

            
			void SetOnbeforeupdate(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnbeforeupdate();

            
			void SetOnafterupdate(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnafterupdate();

            
			void SetOnerrorupdate(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnerrorupdate();

            
			void SetOnrowexit(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnrowexit();

            
			void SetOnrowenter(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnrowenter();

            
			void SetOndatasetchanged(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOndatasetchanged();

            
			void SetOndataavailable(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOndataavailable();

            
			void SetOndatasetcomplete(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOndatasetcomplete();

            
			void SetOnfilterchange(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnfilterchange();

			[return: MarshalAs(UnmanagedType.Interface)]
			object GetChildren();

			[return: MarshalAs(UnmanagedType.Interface)]
			object GetAll();
		}

		[System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("332C4425-26CB-11D0-B483-00C04FD90119"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
		internal interface IHTMLDocument2 
		{
			[return: MarshalAs(UnmanagedType.Interface)]
			object GetScript();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElementCollection GetAll();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElement GetBody();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElement GetActiveElement();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElementCollection GetImages();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElementCollection GetApplets();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElementCollection GetLinks();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElementCollection GetForms();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElementCollection GetAnchors();

            
			void SetTitle(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetTitle();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElementCollection GetScripts();

            
			void SetDesignMode(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetDesignMode();

			[return: MarshalAs(UnmanagedType.Interface)]
			object GetSelection();
			// UNDONE(CHANGED) IHTMLSelectionObject -> object

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetReadyState();

			[return: MarshalAs(UnmanagedType.Interface)]
			object GetFrames();
			// UNDONE(CHANGED) IHTMLFramesCollection2 -> object

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElementCollection GetEmbeds();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElementCollection GetPlugins();

            
			void SetAlinkColor(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			object GetAlinkColor();

            
			void SetBgColor(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			object GetBgColor();

            
			void SetFgColor(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			object GetFgColor();

            
			void SetLinkColor(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			object GetLinkColor();

            
			void SetVlinkColor(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetVlinkColor();

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetReferrer();

			[return: MarshalAs(UnmanagedType.Interface)]
			object GetLocation();
			// UNDONE(CHANGED) IHTMLLocation -> object

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetLastModified();

            
			void SetURL(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetURL();

            
			void SetDomain(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetDomain();

            
			void SetCookie(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetCookie();

            
			void SetExpando(
				[In, MarshalAs(UnmanagedType.Bool)]
				bool p);

			[return: MarshalAs(UnmanagedType.Bool)]
			bool GetExpando();

            
			void SetCharset(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetCharset();

            
			void SetDefaultCharset(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetDefaultCharset();

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetMimeType();

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetFileSize();

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetFileCreatedDate();

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetFileModifiedDate();

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetFileUpdatedDate();

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetSecurity();

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetProtocol();

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetNameProp();

            
			void DummyWrite(
				[In, MarshalAs(UnmanagedType.I4)]
				int psarray);

            
			void DummyWriteln(
				[In, MarshalAs(UnmanagedType.I4)]
				int psarray);

			[return: MarshalAs(UnmanagedType.Interface)]
			object Open(
				[In, MarshalAs(UnmanagedType.BStr)]
				string URL,
				[In, MarshalAs(UnmanagedType.Struct)]
				Object name,
				[In, MarshalAs(UnmanagedType.Struct)]
				Object features,
				[In, MarshalAs(UnmanagedType.Struct)]
				Object replace);

            
			void Close();

            
			void Clear();

			[return: MarshalAs(UnmanagedType.Bool)]
			bool QueryCommandSupported(
				[In, MarshalAs(UnmanagedType.BStr)]
				string cmdID);

			[return: MarshalAs(UnmanagedType.Bool)]
			bool QueryCommandEnabled(
				[In, MarshalAs(UnmanagedType.BStr)]
				string cmdID);

			[return: MarshalAs(UnmanagedType.Bool)]
			bool QueryCommandState(
				[In, MarshalAs(UnmanagedType.BStr)]
				string cmdID);

			[return: MarshalAs(UnmanagedType.Bool)]
			bool QueryCommandIndeterm(
				[In, MarshalAs(UnmanagedType.BStr)]
				string cmdID);

			[return: MarshalAs(UnmanagedType.BStr)]
			string QueryCommandText(
				[In, MarshalAs(UnmanagedType.BStr)]
				string cmdID);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object QueryCommandValue(
				[In, MarshalAs(UnmanagedType.BStr)]
				string cmdID);

			[return: MarshalAs(UnmanagedType.Bool)]
			bool ExecCommand(
				[In, MarshalAs(UnmanagedType.BStr)]
				string cmdID,
				[In, MarshalAs(UnmanagedType.Bool)]
				bool showUI,
				[In, MarshalAs(UnmanagedType.Struct)]
				Object value);

			[return: MarshalAs(UnmanagedType.Bool)]
			bool ExecCommandShowHelp(
				[In, MarshalAs(UnmanagedType.BStr)]
				string cmdID);

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElement CreateElement(
				[In, MarshalAs(UnmanagedType.BStr)]
				string eTag);

            
			void SetOnhelp(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnhelp();

            
			void SetOnclick(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnclick();

            
			void SetOndblclick(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOndblclick();

            
			void SetOnkeyup(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnkeyup();

            
			void SetOnkeydown(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnkeydown();

            
			void SetOnkeypress(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnkeypress();

            
			void SetOnmouseup(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnmouseup();

            
			void SetOnmousedown(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnmousedown();

            
			void SetOnmousemove(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnmousemove();

            
			void SetOnmouseout(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnmouseout();

            
			void SetOnmouseover(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnmouseover();

            
			void SetOnreadystatechange(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnreadystatechange();

            
			void SetOnafterupdate(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnafterupdate();

            
			void SetOnrowexit(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnrowexit();

            
			void SetOnrowenter(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnrowenter();

            
			void SetOndragstart(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOndragstart();

            
			void SetOnselectstart(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnselectstart();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElement ElementFromPoint(
				[In, MarshalAs(UnmanagedType.I4)]
				int x,
				[In, MarshalAs(UnmanagedType.I4)]
				int y);

			[return: MarshalAs(UnmanagedType.Interface)]
				/*IHTMLWindow2*/ object GetParentWindow();

			[return: MarshalAs(UnmanagedType.Interface)]
			object GetStyleSheets();
			// UNDONE(CHANGED) IHTMLStyleSheetsCollection -> object

            
			void SetOnbeforeupdate(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnbeforeupdate();

            
			void SetOnerrorupdate(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnerrorupdate();

			[return: MarshalAs(UnmanagedType.BStr)]
			string toString();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLStyleSheet CreateStyleSheet(
				[In, MarshalAs(UnmanagedType.BStr)]
				string bstrHref,
				[In, MarshalAs(UnmanagedType.I4)]
				int lIndex);
		}

		[System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F485-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
		internal interface IHTMLDocument3 
		{
			void ReleaseCapture();

            
			void Recalc(
				[In, MarshalAs(UnmanagedType.Bool)]
				bool fForce);

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDOMNode CreateTextNode(
				[In, MarshalAs(UnmanagedType.BStr)]
				string text);

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElement GetDocumentElement();

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetUniqueID();

			[return: MarshalAs(UnmanagedType.Bool)]
			bool AttachEvent(
				[In, MarshalAs(UnmanagedType.BStr)]
				string ev,
				[In, MarshalAs(UnmanagedType.Interface)]
				object pdisp);

            
			void DetachEvent(
				[In, MarshalAs(UnmanagedType.BStr)]
				string ev,
				[In, MarshalAs(UnmanagedType.Interface)]
				object pdisp);

            
			void SetOnrowsdelete(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnrowsdelete();

            
			void SetOnrowsinserted(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnrowsinserted();

            
			void SetOncellchange(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOncellchange();

            
			void SetOndatasetchanged(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOndatasetchanged();

            
			void SetOndataavailable(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOndataavailable();

            
			void SetOndatasetcomplete(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOndatasetcomplete();

            
			void SetOnpropertychange(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnpropertychange();

            
			void SetDir(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetDir();

            
			void SetOncontextmenu(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOncontextmenu();

            
			void SetOnstop(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnstop();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDocument2 CreateDocumentFragment();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDocument2 GetParentDocument();

            
			void SetEnableDownload(
				[In, MarshalAs(UnmanagedType.Bool)]
				bool p);

			[return: MarshalAs(UnmanagedType.Bool)]
			bool GetEnableDownload();

            
			void SetBaseUrl(
				[In, MarshalAs(UnmanagedType.BStr)]
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetBaseUrl();

			[return: MarshalAs(UnmanagedType.Interface)]
			object GetChildNodes();

            
			void SetInheritStyleSheets(
				[In, MarshalAs(UnmanagedType.Bool)]
				bool p);

			[return: MarshalAs(UnmanagedType.Bool)]
			bool GetInheritStyleSheets();

            
			void SetOnbeforeeditfocus(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetOnbeforeeditfocus();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElementCollection GetElementsByName(
				[In, MarshalAs(UnmanagedType.BStr)]
				string v);

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElement GetElementById(
				[In, MarshalAs(UnmanagedType.BStr)]
				string v);

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElementCollection GetElementsByTagName(
				[In, MarshalAs(UnmanagedType.BStr)]
				string v);
		}
		[System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F2E3-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
		internal interface IHTMLStyleSheet 
		{
			void SetTitle(
				[In, MarshalAs(UnmanagedType.BStr)] 
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetTitle();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLStyleSheet GetParentStyleSheet();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLElement GetOwningElement();

            
			void SetDisabled(
				[In, MarshalAs(UnmanagedType.Bool)] 
				bool p);

			[return: MarshalAs(UnmanagedType.Bool)]
			bool GetDisabled();

			[return: MarshalAs(UnmanagedType.Bool)]
			bool GetReadOnly();

			[return: MarshalAs(UnmanagedType.Interface)]
			object GetImports();
			// UNDONE(CHANGED) IHTMLStyleSheetsCollection -> object

            
			void SetHref(
				[In, MarshalAs(UnmanagedType.BStr)] 
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetHref();

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetStyleSheetType();

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetId();

			[return: MarshalAs(UnmanagedType.I4)]
			int AddImport(
				[In, MarshalAs(UnmanagedType.BStr)] 
				string bstrURL,
				[In, MarshalAs(UnmanagedType.I4)] 
				int lIndex);

			[return: MarshalAs(UnmanagedType.I4)]
			int AddRule(
				[In, MarshalAs(UnmanagedType.BStr)] 
				string bstrSelector,
				[In, MarshalAs(UnmanagedType.BStr)] 
				string bstrStyle,
				[In, MarshalAs(UnmanagedType.I4)] 
				int lIndex);

            
			void RemoveImport(
				[In, MarshalAs(UnmanagedType.I4)] 
				int lIndex);

            
			void RemoveRule(
				[In, MarshalAs(UnmanagedType.I4)] 
				int lIndex);

            
			void SetMedia(
				[In, MarshalAs(UnmanagedType.BStr)] 
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetMedia();

            
			void SetCssText(
				[In, MarshalAs(UnmanagedType.BStr)] 
				string p);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetCssText();

			[return: MarshalAs(UnmanagedType.Interface)]
			object GetRules();
			// UNDONE(CHANGED) IHTMLStyleSheetRulesCollection -> object
		}

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F25E-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        internal interface IHTMLStyle {
            void SetFontFamily(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontFamily();

            
            void SetFontStyle(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontStyle();

            
            void SetFontObject(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontObject();

            
            void SetFontWeight(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontWeight();

            
            void SetFontSize(
                            [In, MarshalAs(UnmanagedType.Struct)]
                            Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetFontSize();

            
            void SetFont(
                        [In, MarshalAs(UnmanagedType.BStr)]
                        string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFont();

            
            void SetColor(
                         [In, MarshalAs(UnmanagedType.Struct)]
                         Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetColor();

            
            void SetBackground(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackground();

            
            void SetBackgroundColor(
                                   [In, MarshalAs(UnmanagedType.Struct)]
                                   Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundColor();

            
            void SetBackgroundImage(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundImage();

            
            void SetBackgroundRepeat(
                                    [In, MarshalAs(UnmanagedType.BStr)]
                                    string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundRepeat();

            
            void SetBackgroundAttachment(
                                        [In, MarshalAs(UnmanagedType.BStr)]
                                        string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundAttachment();

            
            void SetBackgroundPosition(
                                      [In, MarshalAs(UnmanagedType.BStr)]
                                      string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundPosition();

            
            void SetBackgroundPositionX(
                                       [In, MarshalAs(UnmanagedType.Struct)]
                                       Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundPositionX();

            
            void SetBackgroundPositionY(
                                       [In, MarshalAs(UnmanagedType.Struct)]
                                       Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundPositionY();

            
            void SetWordSpacing(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetWordSpacing();

            
            void SetLetterSpacing(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLetterSpacing();

            
            void SetTextDecoration(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextDecoration();

            
            void SetTextDecorationNone(
                                      [In, MarshalAs(UnmanagedType.Bool)]
                                      bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetTextDecorationNone();

            
            void SetTextDecorationUnderline(
                                           [In, MarshalAs(UnmanagedType.Bool)]
                                           bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetTextDecorationUnderline();

            
            void SetTextDecorationOverline(
                                          [In, MarshalAs(UnmanagedType.Bool)]
                                          bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetTextDecorationOverline();

            
            void SetTextDecorationLineThrough(
                                             [In, MarshalAs(UnmanagedType.Bool)]
                                             bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetTextDecorationLineThrough();

            
            void SetTextDecorationBlink(
                                       [In, MarshalAs(UnmanagedType.Bool)]
                                       bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetTextDecorationBlink();

            
            void SetVerticalAlign(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetVerticalAlign();

            
            void SetTextTransform(
                                 [In, MarshalAs(UnmanagedType.BStr)]
                                 string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextTransform();

            
            void SetTextAlign(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextAlign();

            
            void SetTextIndent(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetTextIndent();

            
            void SetLineHeight(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLineHeight();

            
            void SetMarginTop(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginTop();

            
            void SetMarginRight(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginRight();

            
            void SetMarginBottom(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginBottom();

            
            void SetMarginLeft(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginLeft();

            
            void SetMargin(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetMargin();

            
            void SetPaddingTop(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingTop();

            
            void SetPaddingRight(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingRight();

            
            void SetPaddingBottom(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingBottom();

            
            void SetPaddingLeft(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingLeft();

            
            void SetPadding(
                           [In, MarshalAs(UnmanagedType.BStr)]
                           string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPadding();

            
            void SetBorder(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorder();

            
            void SetBorderTop(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderTop();

            
            void SetBorderRight(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderRight();

            
            void SetBorderBottom(
                                [In, MarshalAs(UnmanagedType.BStr)]
                                string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderBottom();

            
            void SetBorderLeft(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderLeft();

            
            void SetBorderColor(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderColor();

            
            void SetBorderTopColor(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderTopColor();

            
            void SetBorderRightColor(
                                    [In, MarshalAs(UnmanagedType.Struct)]
                                    Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderRightColor();

            
            void SetBorderBottomColor(
                                     [In, MarshalAs(UnmanagedType.Struct)]
                                     Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderBottomColor();

            
            void SetBorderLeftColor(
                                   [In, MarshalAs(UnmanagedType.Struct)]
                                   Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderLeftColor();

            
            void SetBorderWidth(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderWidth();

            
            void SetBorderTopWidth(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderTopWidth();

            
            void SetBorderRightWidth(
                                    [In, MarshalAs(UnmanagedType.Struct)]
                                    Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderRightWidth();

            
            void SetBorderBottomWidth(
                                     [In, MarshalAs(UnmanagedType.Struct)]
                                     Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderBottomWidth();

            
            void SetBorderLeftWidth(
                                   [In, MarshalAs(UnmanagedType.Struct)]
                                   Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderLeftWidth();

            
            void SetBorderStyle(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderStyle();

            
            void SetBorderTopStyle(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderTopStyle();

            
            void SetBorderRightStyle(
                                    [In, MarshalAs(UnmanagedType.BStr)]
                                    string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderRightStyle();

            
            void SetBorderBottomStyle(
                                     [In, MarshalAs(UnmanagedType.BStr)]
                                     string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderBottomStyle();

            
            void SetBorderLeftStyle(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderLeftStyle();

            
            void SetWidth(
                         [In, MarshalAs(UnmanagedType.Struct)]
                         Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetWidth();

            
            void SetHeight(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetHeight();

            
            void SetStyleFloat(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetStyleFloat();

            
            void SetClear(
                         [In, MarshalAs(UnmanagedType.BStr)]
                         string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetClear();

            
            void SetDisplay(
                           [In, MarshalAs(UnmanagedType.BStr)]
                           string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDisplay();

            
            void SetVisibility(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetVisibility();

            
            void SetListStyleType(
                                 [In, MarshalAs(UnmanagedType.BStr)]
                                 string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleType();

            
            void SetListStylePosition(
                                     [In, MarshalAs(UnmanagedType.BStr)]
                                     string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStylePosition();

            
            void SetListStyleImage(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleImage();

            
            void SetListStyle(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyle();

            
            void SetWhiteSpace(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetWhiteSpace();

            
            void SetTop(
                       [In, MarshalAs(UnmanagedType.Struct)]
                       Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetTop();

            
            void SetLeft(
                        [In, MarshalAs(UnmanagedType.Struct)]
                        Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLeft();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPosition();

            
            void SetZIndex(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetZIndex();

            
            void SetOverflow(
                            [In, MarshalAs(UnmanagedType.BStr)]
                            string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetOverflow();

            
            void SetPageBreakBefore(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakBefore();

            
            void SetPageBreakAfter(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakAfter();

            
            void SetCssText(
                           [In, MarshalAs(UnmanagedType.BStr)]
                           string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetCssText();

            
            void SetPixelTop(
                            [In, MarshalAs(UnmanagedType.I4)]
                            int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetPixelTop();

            
            void SetPixelLeft(
                             [In, MarshalAs(UnmanagedType.I4)]
                             int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetPixelLeft();

            
            void SetPixelWidth(
                              [In, MarshalAs(UnmanagedType.I4)]
                              int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetPixelWidth();

            
            void SetPixelHeight(
                               [In, MarshalAs(UnmanagedType.I4)]
                               int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetPixelHeight();

            
            void SetPosTop(
                          [In, MarshalAs(UnmanagedType.R4)]
                          float p);

            [return: MarshalAs(UnmanagedType.R4)]
            float GetPosTop();

            
            void SetPosLeft(
                           [In, MarshalAs(UnmanagedType.R4)]
                           float p);

            [return: MarshalAs(UnmanagedType.R4)]
            float GetPosLeft();

            
            void SetPosWidth(
                            [In, MarshalAs(UnmanagedType.R4)]
                            float p);

            [return: MarshalAs(UnmanagedType.R4)]
            float GetPosWidth();

            
            void SetPosHeight(
                             [In, MarshalAs(UnmanagedType.R4)]
                             float p);

            [return: MarshalAs(UnmanagedType.R4)]
            float GetPosHeight();

            
            void SetCursor(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetCursor();

            
            void SetClip(
                        [In, MarshalAs(UnmanagedType.BStr)]
                        string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetClip();

            
            void SetFilter(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFilter();

            
            void SetAttribute(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string strAttributeName,
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object AttributeValue,
                             [In, MarshalAs(UnmanagedType.I4)]
                             int lFlags);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetAttribute(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string strAttributeName,
                               [In, MarshalAs(UnmanagedType.I4)]
                               int lFlags);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool RemoveAttribute(
                                [In, MarshalAs(UnmanagedType.BStr)]
                                string strAttributeName,
                                [In, MarshalAs(UnmanagedType.I4)]
                                int lFlags);

        }

		[System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F21F-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
		internal interface IHTMLElementCollection 
		{
			[return: MarshalAs(UnmanagedType.BStr)]
			string toString();

            
			void SetLength(
				[In, MarshalAs(UnmanagedType.I4)] 
				int p);

			[return: MarshalAs(UnmanagedType.I4)]
			int GetLength();

			[return: MarshalAs(UnmanagedType.Interface)]
			object Get_newEnum();

			[return: MarshalAs(UnmanagedType.Interface)]
			object Item(
				[In, MarshalAs(UnmanagedType.Struct)] 
				Object name,
				[In, MarshalAs(UnmanagedType.Struct)] 
				Object index);

			[return: MarshalAs(UnmanagedType.Interface)]
			object Tags(
				[In, MarshalAs(UnmanagedType.Struct)] 
				Object tagName);
		}

		[System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F5DA-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
		internal interface IHTMLDOMNode 
		{
			[return: MarshalAs(UnmanagedType.I4)]
			int GetNodeType();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDOMNode GetParentNode();

			[return: MarshalAs(UnmanagedType.Bool)]
			bool HasChildNodes();

			[return: MarshalAs(UnmanagedType.Interface)]
			object GetChildNodes();

			[return: MarshalAs(UnmanagedType.Interface)]
			object GetAttributes();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDOMNode InsertBefore(
				[In, MarshalAs(UnmanagedType.Interface)]
				IHTMLDOMNode newChild,
				[In, MarshalAs(UnmanagedType.Struct)]
				Object refChild);

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDOMNode RemoveChild(
				[In, MarshalAs(UnmanagedType.Interface)]
				IHTMLDOMNode oldChild);

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDOMNode ReplaceChild(
				[In, MarshalAs(UnmanagedType.Interface)]
				IHTMLDOMNode newChild,
				[In, MarshalAs(UnmanagedType.Interface)]
				IHTMLDOMNode oldChild);

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDOMNode CloneNode(
				[In, MarshalAs(UnmanagedType.Bool)]
				bool fDeep);

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDOMNode RemoveNode(
				[In, MarshalAs(UnmanagedType.Bool)]
				bool fDeep);

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDOMNode SwapNode(
				[In, MarshalAs(UnmanagedType.Interface)]
				IHTMLDOMNode otherNode);

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDOMNode ReplaceNode(
				[In, MarshalAs(UnmanagedType.Interface)]
				IHTMLDOMNode replacement);

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDOMNode AppendChild(
				[In, MarshalAs(UnmanagedType.Interface)]
				IHTMLDOMNode newChild);

			[return: MarshalAs(UnmanagedType.BStr)]
			string GetNodeName();

            
			void SetNodeValue(
				[In, MarshalAs(UnmanagedType.Struct)]
				Object p);

			[return: MarshalAs(UnmanagedType.Struct)]
			Object GetNodeValue();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDOMNode GetFirstChild();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDOMNode GetLastChild();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDOMNode GetPreviousSibling();

			[return: MarshalAs(UnmanagedType.Interface)]
			IHTMLDOMNode GetNextSibling();
		}

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("0000011B-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IOleContainer 
        {
            void ParseDisplayName(
                [In, MarshalAs(UnmanagedType.Interface)] 
                object pbc,
                [In, MarshalAs(UnmanagedType.BStr)] 
                string pszDisplayName,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                int[] pchEaten,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                Object[] ppmkOut);

            
            void EnumObjects(
                [In, MarshalAs(UnmanagedType.U4)] 
                int grfFlags,
                [Out, MarshalAs(UnmanagedType.Interface)] 
                out object ppenum);

            
            void LockContainer(
                [In, MarshalAs(UnmanagedType.I4)] 
                int fLock);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000118-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IOleClientSite 
        {
            void SaveObject();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetMoniker(
                [In, MarshalAs(UnmanagedType.U4)] 
                int dwAssign,
                [In, MarshalAs(UnmanagedType.U4)] 
                int dwWhichMoniker);

            [PreserveSig]
            int GetContainer(
                [System.Runtime.InteropServices.Out]
                out IOleContainer ppContainer);

            
            void ShowObject();

            
            void OnShowWindow(
                [In, MarshalAs(UnmanagedType.I4)] 
                int fShow);

            
            void RequestNewObjectLayout();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("B722BCC7-4E68-101B-A2BC-00AA00404770"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IOleDocumentSite 
        {

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int ActivateMe(
                [In, MarshalAs(UnmanagedType.Interface)] 
                IOleDocumentView pViewToActivate);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("B722BCC6-4E68-101B-A2BC-00AA00404770"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IOleDocumentView 
        {
            void SetInPlaceSite(
                [In, MarshalAs(UnmanagedType.Interface)] 
                IOleInPlaceSite pIPSite);

            [return: MarshalAs(UnmanagedType.Interface)]
            IOleInPlaceSite GetInPlaceSite();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetDocument();

            
            void SetRect(
                [In] 
                COMRECT prcView);

            
            void GetRect(
                [Out] 
                COMRECT prcView);

            
            void SetRectComplex(
                [In] 
                COMRECT prcView,
                [In] 
                COMRECT prcHScroll,
                [In] 
                COMRECT prcVScroll,
                [In] 
                COMRECT prcSizeBox);

            
            void Show(
                [In, MarshalAs(UnmanagedType.I4)] 
                int fShow);

            
            void UIActivate(
                [In, MarshalAs(UnmanagedType.I4)] 
                int fUIActivate);

            
            void Open();

            
            void CloseView(
                [In, MarshalAs(UnmanagedType.U4)] 
                int dwReserved);

            
            void SaveViewState(
                [In, MarshalAs(UnmanagedType.Interface)] 
                IStream pstm);

            
            void ApplyViewState(
                [In, MarshalAs(UnmanagedType.Interface)] 
                IStream pstm);

            
            void Clone(
                [In, MarshalAs(UnmanagedType.Interface)] 
                IOleInPlaceSite pIPSiteNew,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                IOleDocumentView[] ppViewNew);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000119-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IOleInPlaceSite 
        {
            IntPtr GetWindow();

            void ContextSensitiveHelp(
                [In, MarshalAs(UnmanagedType.I4)] 
                int fEnterMode);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int CanInPlaceActivate();

            
            void OnInPlaceActivate();

            
            void OnUIActivate();

            
            void GetWindowContext(
                [Out]
                out IOleInPlaceFrame ppFrame,
                [Out]
                out IOleInPlaceUIWindow ppDoc,
                [Out] 
                COMRECT lprcPosRect,
                [Out] 
                COMRECT lprcClipRect,
                [In, Out] 
                tagOIFI lpFrameInfo);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int Scroll(
                [In, MarshalAs(UnmanagedType.U4)] 
                tagSIZE scrollExtant);

            
            void OnUIDeactivate(
                [In, MarshalAs(UnmanagedType.I4)] 
                int fUndoable);

            
            void OnInPlaceDeactivate();

            
            void DiscardUndoState();

            
            void DeactivateAndUndo();

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OnPosRectChange(
                [In] 
                COMRECT lprcPosRect);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000116-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IOleInPlaceFrame 
        {
            IntPtr GetWindow();

            
            void ContextSensitiveHelp(
                [In, MarshalAs(UnmanagedType.I4)]
                int fEnterMode);

            
            void GetBorder(
                [Out]
                COMRECT lprectBorder);

            
            void RequestBorderSpace(
                [In]
                COMRECT pborderwidths);

            
            void SetBorderSpace(
                [In]
                COMRECT pborderwidths);

            
            void SetActiveObject(
                [In, MarshalAs(UnmanagedType.Interface)]
                IOleInPlaceActiveObject pActiveObject,
                [In, MarshalAs(UnmanagedType.LPWStr)]
                string pszObjName);

            
            void InsertMenus(
                [In]
                IntPtr hmenuShared,
                [In, Out]
                object lpMenuWidths);

            
            void SetMenu(
                [In]
                IntPtr hmenuShared,
                [In]
                IntPtr holemenu,
                [In]
                IntPtr hwndActiveObject);

            
            void RemoveMenus(
                [In]
                IntPtr hmenuShared);

            
            void SetStatusText(
                [In, MarshalAs(UnmanagedType.BStr)]
                string pszStatusText);

            
            void EnableModeless(
                [In, MarshalAs(UnmanagedType.I4)]
                int fEnable);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int TranslateAccelerator(
                [In]
                ref MSG lpmsg,
                [In, MarshalAs(UnmanagedType.U2)]
                short wID);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000115-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IOleInPlaceUIWindow 
        {
            IntPtr GetWindow();

            
            void ContextSensitiveHelp(
                [In, MarshalAs(UnmanagedType.I4)] 
                int fEnterMode);

            
            void GetBorder(
                [Out] 
                COMRECT lprectBorder);

            
            void RequestBorderSpace(
                [In] 
                COMRECT pborderwidths);

            
            void SetBorderSpace(
                [In] 
                COMRECT pborderwidths);

            
            void SetActiveObject(
                [In, MarshalAs(UnmanagedType.Interface)] 
                IOleInPlaceActiveObject pActiveObject,
                [In, MarshalAs(UnmanagedType.LPWStr)] 
                string pszObjName);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("BD3F23C0-D43E-11CF-893B-00AA00BDCE1A"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IDocHostUIHandler 
        {

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int ShowContextMenu(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwID,
                [In]
                POINT pt,
                [In, MarshalAs(UnmanagedType.Interface)]
                object pcmdtReserved,
                [In, MarshalAs(UnmanagedType.Interface)]
                object pdispReserved);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int GetHostInfo(
                [In, Out]
                DOCHOSTUIINFO info);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int ShowUI(
                [In, MarshalAs(UnmanagedType.I4)]
                int dwID,
                [In]
                IOleInPlaceActiveObject activeObject,
                [In]
                IOleCommandTarget commandTarget,
                [In]
                IOleInPlaceFrame frame,
                [In]
                IOleInPlaceUIWindow doc);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int HideUI();

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int UpdateUI();

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int EnableModeless(
                [In, MarshalAs(UnmanagedType.Bool)]
                bool fEnable);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OnDocWindowActivate(
                [In, MarshalAs(UnmanagedType.Bool)]
                bool fActivate);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OnFrameWindowActivate(
                [In, MarshalAs(UnmanagedType.Bool)]
                bool fActivate);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int ResizeBorder(
                [In]
                COMRECT rect,
                [In]
                IOleInPlaceUIWindow doc,
                bool fFrameWindow);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int TranslateAccelerator(
                [In]
                ref MSG msg,
                [In]
                ref Guid group,
                [In, MarshalAs(UnmanagedType.I4)]
                int nCmdID);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int GetOptionKeyPath(
                [Out, MarshalAs(UnmanagedType.LPArray)]
                String[] pbstrKey,
                [In, MarshalAs(UnmanagedType.U4)]
                int dw);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int GetDropTarget(
                [In, MarshalAs(UnmanagedType.Interface)]
                IOleDropTarget pDropTarget,
                [Out, MarshalAs(UnmanagedType.Interface)]
                out IOleDropTarget ppDropTarget);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int GetExternal(
                [Out, MarshalAs(UnmanagedType.Interface)]
                out object ppDispatch);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int TranslateUrl(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwTranslate,
                [In, MarshalAs(UnmanagedType.LPWStr)]
                string strURLIn,
                [Out, MarshalAs(UnmanagedType.LPWStr)]
                out string pstrURLOut);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int FilterDataObject(
                [In, MarshalAs(UnmanagedType.Interface)]
                IOleDataObject pDO,
                [Out, MarshalAs(UnmanagedType.Interface)]
                out IOleDataObject ppDORet);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000117-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IOleInPlaceActiveObject 
        {

            int GetWindow(out IntPtr hwnd);

            
            void ContextSensitiveHelp(
                [In, MarshalAs(UnmanagedType.I4)]
                int fEnterMode);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int TranslateAccelerator(
                [In]
                ref MSG lpmsg);

            
            void OnFrameWindowActivate(
                [In, MarshalAs(UnmanagedType.I4)]
                int fActivate);

            
            void OnDocWindowActivate(
                [In, MarshalAs(UnmanagedType.I4)]
                int fActivate);

            
            void ResizeBorder(
                [In]
                COMRECT prcBorder,
                [In]
                IOleInPlaceUIWindow pUIWindow,
                [In, MarshalAs(UnmanagedType.I4)]
                int fFrameWindow);

            
            void EnableModeless(
                [In, MarshalAs(UnmanagedType.I4)]
                int fEnable);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000112-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IOleObject 
        {

            [PreserveSig]
            int SetClientSite(
                [In, MarshalAs(UnmanagedType.Interface)]
                IOleClientSite pClientSite);

            [PreserveSig]
            int GetClientSite(out IOleClientSite site);

            [PreserveSig]
            int SetHostNames(
                [In, MarshalAs(UnmanagedType.LPWStr)]
                string szContainerApp,
                [In, MarshalAs(UnmanagedType.LPWStr)]
                string szContainerObj);

            [PreserveSig]
            int Close(
                [In, MarshalAs(UnmanagedType.I4)]
                int dwSaveOption);

            [PreserveSig]
            int SetMoniker(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwWhichMoniker,
                [In, MarshalAs(UnmanagedType.Interface)]
                object pmk);

            [PreserveSig]
            int GetMoniker(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwAssign,
                [In, MarshalAs(UnmanagedType.U4)]
                int dwWhichMoniker,
                out object moniker);

            [PreserveSig]
            int InitFromData(
                [In, MarshalAs(UnmanagedType.Interface)]
                IOleDataObject pDataObject,
                [In, MarshalAs(UnmanagedType.I4)]
                int fCreation,
                [In, MarshalAs(UnmanagedType.U4)]
                int dwReserved);

            [PreserveSig]
            int GetClipboardData(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwReserved,
                out IOleDataObject data);

            [PreserveSig]
            int DoVerb(
                [In, MarshalAs(UnmanagedType.I4)]
                int iVerb,
                [In]
                IntPtr lpmsg,
                [In, MarshalAs(UnmanagedType.Interface)]
                IOleClientSite pActiveSite,
                [In, MarshalAs(UnmanagedType.I4)]
                int lindex,
                [In]
                IntPtr hwndParent,
                [In]
                COMRECT lprcPosRect);

            [PreserveSig]
            int EnumVerbs(out NativeMethods.IEnumOLEVERB e);

            [PreserveSig]
            int OleUpdate();

            [PreserveSig]
            int IsUpToDate();

            [PreserveSig]
            int GetUserClassID(
                [In, Out]
                ref Guid pClsid);

            [PreserveSig]
            int GetUserType(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwFormOfType,
                [Out, MarshalAs(UnmanagedType.LPWStr)]
                out string userType);

            [PreserveSig]
            int SetExtent(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwDrawAspect,
                [In]
                tagSIZEL pSizel);

            [PreserveSig]
            int GetExtent(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwDrawAspect,
                [Out]
                tagSIZEL pSizel);

            [PreserveSig]
            int Advise(
                [In, MarshalAs(UnmanagedType.Interface)]
                IAdviseSink pAdvSink,
                out int cookie);

            [PreserveSig]
            int Unadvise(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwConnection);

            [PreserveSig]
            int EnumAdvise(out object e);

            [PreserveSig]
            int GetMiscStatus(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwAspect,
                out int misc);

            [PreserveSig]
            int SetColorScheme(
                [In]
                tagLOGPALETTE pLogpal);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("B722BCCB-4E68-101B-A2BC-00AA00404770"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IOleCommandTarget 
        {

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int QueryStatus(
                ref Guid pguidCmdGroup,
                int cCmds,
                [In, Out] 
                OLECMD prgCmds,
                [In, Out] 
                string pCmdText);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int Exec(
                ref Guid pguidCmdGroup,
                int nCmdID,
                int nCmdexecopt,
                // we need to have this an array because callers need to be able to specify NULL or VT_NULL
                [In, MarshalAs(UnmanagedType.LPArray)]
                Object[] pvaIn,
                IntPtr pvaOut);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000122-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IOleDropTarget 
        {

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleDragEnter(
                [In, MarshalAs(UnmanagedType.Interface)]
                IOleDataObject pDataObj,
                [In, MarshalAs(UnmanagedType.U4)]
                int grfKeyState,
                [In, MarshalAs(UnmanagedType.U8)]
                long pt,
                [In, Out, MarshalAs(UnmanagedType.I4)]
                ref int pdwEffect);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleDragOver(
                [In, MarshalAs(UnmanagedType.U4)]
                int grfKeyState,
                [In, MarshalAs(UnmanagedType.U8)]
                long pt,
                [In, Out, MarshalAs(UnmanagedType.I4)]
                ref int pdwEffect);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleDragLeave();

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleDrop(
                [In, MarshalAs(UnmanagedType.Interface)]
                IOleDataObject pDataObj,
                [In, MarshalAs(UnmanagedType.U4)]
                int grfKeyState,
                [In, MarshalAs(UnmanagedType.U8)]
                long pt,
                [In, Out, MarshalAs(UnmanagedType.I4)]
                ref int pdwEffect);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("0000010E-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IOleDataObject 
        {
            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleGetData(
                FORMATETC pFormatetc,
                [Out] 
                STGMEDIUM pMedium);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleGetDataHere(
                FORMATETC pFormatetc,
                [In, Out] 
                STGMEDIUM pMedium);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleQueryGetData(
                FORMATETC pFormatetc);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleGetCanonicalFormatEtc(
                FORMATETC pformatectIn,
                [Out] 
                FORMATETC pformatetcOut);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleSetData(
                FORMATETC pFormatectIn,
                STGMEDIUM pmedium,
                [In, MarshalAs(UnmanagedType.I4)] 
                int fRelease);

            [return: MarshalAs(UnmanagedType.Interface)]
            object OleEnumFormatEtc(
                [In, MarshalAs(UnmanagedType.U4)] 
                int dwDirection);

            [PreserveSig]
            int OleDAdvise(
                FORMATETC pFormatetc,
                [In, MarshalAs(UnmanagedType.U4)] 
                int advf,
                [In, MarshalAs(UnmanagedType.Interface)] 
                object pAdvSink,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                int[] pdwConnection);

            [PreserveSig]
            int OleDUnadvise(
                [In, MarshalAs(UnmanagedType.U4)] 
                int dwConnection);

            [PreserveSig]
            int OleEnumDAdvise(
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                Object[] ppenumAdvise);
        }

        [ComImport(), Guid("00000104-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IEnumOLEVERB 
        {
            [PreserveSig]
            int Next(
                [MarshalAs(UnmanagedType.U4)] 
                int celt,
                [Out]
                NativeMethods.tagOLEVERB rgelt,
                [Out, MarshalAs(UnmanagedType.LPArray)]
                int[] pceltFetched);

            [PreserveSig]
            int Skip(
                [In, MarshalAs(UnmanagedType.U4)] 
                int celt);


            void Reset();


            void Clone(
                out NativeMethods.IEnumOLEVERB ppenum);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("0000010F-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IAdviseSink 
        {
            void OnDataChange(
                [In]
                FORMATETC pFormatetc,
                [In]
                STGMEDIUM pStgmed);

            
            void OnViewChange(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwAspect,
                [In, MarshalAs(UnmanagedType.I4)]
                int lindex);

            
            void OnRename(
                [In, MarshalAs(UnmanagedType.Interface)]
                object pmk);

            
            void OnSave();

            
            void OnClose();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F1D8-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        internal interface IHTMLBodyElement 
        {
            void SetBackground(
                [In, MarshalAs(UnmanagedType.BStr)]
                string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackground();

            
            void SetBgProperties(
                [In, MarshalAs(UnmanagedType.BStr)]
                string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBgProperties();

            
            void SetLeftMargin(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLeftMargin();

            
            void SetTopMargin(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetTopMargin();

            
            void SetRightMargin(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetRightMargin();

            
            void SetBottomMargin(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBottomMargin();

            
            void SetNoWrap(
                [In, MarshalAs(UnmanagedType.Bool)]
                bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetNoWrap();

            
            void SetBgColor(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBgColor();

            
            void SetText(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetText();

            
            void SetLink(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLink();

            
            void SetVLink(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetVLink();

            
            void SetALink(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetALink();

            
            void SetOnload(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnload();

            
            void SetOnunload(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnunload();

            
            void SetScroll(
                [In, MarshalAs(UnmanagedType.BStr)]
                string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetScroll();

            
            void SetOnselect(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnselect();

            
            void SetOnbeforeunload(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforeunload();

            [return: MarshalAs(UnmanagedType.Interface)]
            object CreateTextRange();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("7FD52380-4E07-101B-AE2D-08002B2EC713"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IPersistStreamInit 
        {
            void GetClassID(
                [In, Out] 
                ref Guid pClassID);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int IsDirty();

            
            void Load(
                [In, MarshalAs(UnmanagedType.Interface)] 
                IStream pstm);

            
            void Save(
                [In, MarshalAs(UnmanagedType.Interface)] 
                IStream pstm,
                [In, MarshalAs(UnmanagedType.Bool)] 
                bool fClearDirty);

            
            void GetSizeMax(
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                long pcbSize);

            
            void InitNew();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("25336920-03F9-11CF-8FD0-00AA00686F13")]
        internal class HTMLDocument 
        {
        }

        [System.Runtime.InteropServices.ComVisible(false), System.Runtime.InteropServices.ComImport(), Guid("3050F434-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        internal interface IHTMLElement2 
        {

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetScopeName();

            
            void SetCapture(
                [In, MarshalAs(UnmanagedType.Bool)]
                bool containerCapture);

            
            void ReleaseCapture();

            
            void SetOnlosecapture(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnlosecapture();

            [return: MarshalAs(UnmanagedType.BStr)]
            string ComponentFromPoint(
                [In, MarshalAs(UnmanagedType.I4)]
                int x,
                [In, MarshalAs(UnmanagedType.I4)]
                int y);

            
            void DoScroll(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object component);

            
            void SetOnscroll(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnscroll();

            
            void SetOndrag(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndrag();

            
            void SetOndragend(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragend();

            
            void SetOndragenter(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragenter();

            
            void SetOndragover(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragover();

            
            void SetOndragleave(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragleave();

            
            void SetOndrop(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndrop();

            
            void SetOnbeforecut(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforecut();

            
            void SetOncut(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOncut();

            
            void SetOnbeforecopy(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforecopy();

            
            void SetOncopy(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOncopy();

            
            void SetOnbeforepaste(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforepaste();

            
            void SetOnpaste(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnpaste();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLCurrentStyle GetCurrentStyle();

            
            void SetOnpropertychange(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnpropertychange();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLRectCollection GetClientRects();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLRect GetBoundingClientRect();

            
            void SetExpression(
                [In, MarshalAs(UnmanagedType.BStr)]
                string propname,
                [In, MarshalAs(UnmanagedType.BStr)]
                string expression,
                [In, MarshalAs(UnmanagedType.BStr)]
                string language);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetExpression(
                [In, MarshalAs(UnmanagedType.BStr)]
                Object propname);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool RemoveExpression(
                [In, MarshalAs(UnmanagedType.BStr)]
                string propname);

            
            void SetTabIndex(
                [In, MarshalAs(UnmanagedType.I2)]
                short p);

            [return: MarshalAs(UnmanagedType.I2)]
            short GetTabIndex();

            
            void Focus();

            
            void SetAccessKey(
                [In, MarshalAs(UnmanagedType.BStr)]
                string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetAccessKey();

            
            void SetOnblur(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnblur();

            
            void SetOnfocus(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnfocus();

            
            void SetOnresize(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnresize();

            
            void Blur();

            
            void AddFilter(
                [In, MarshalAs(UnmanagedType.Interface)]
                object pUnk);

            
            void RemoveFilter(
                [In, MarshalAs(UnmanagedType.Interface)]
                object pUnk);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetClientHeight();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetClientWidth();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetClientTop();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetClientLeft();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool AttachEvent(
                [In, MarshalAs(UnmanagedType.BStr)]
                string ev,
                [In, MarshalAs(UnmanagedType.Interface)]
                object pdisp);

            
            void DetachEvent(
                [In, MarshalAs(UnmanagedType.BStr)]
                string ev,
                [In, MarshalAs(UnmanagedType.Interface)]
                object pdisp);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetReadyState();

            
            void SetOnreadystatechange(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnreadystatechange();

            
            void SetOnrowsdelete(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnrowsdelete();

            
            void SetOnrowsinserted(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnrowsinserted();

            
            void SetOncellchange(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOncellchange();

            
            void SetDir(
                [In, MarshalAs(UnmanagedType.BStr)]
                string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDir();

            [return: MarshalAs(UnmanagedType.Interface)]
            object CreateControlRange();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetScrollHeight();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetScrollWidth();

            
            void SetScrollTop(
                [In, MarshalAs(UnmanagedType.I4)]
                int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetScrollTop();

            
            void SetScrollLeft(
                [In, MarshalAs(UnmanagedType.I4)]
                int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetScrollLeft();

            
            void ClearAttributes();

            
            void MergeAttributes(
                [In, MarshalAs(UnmanagedType.Interface)]
                IHTMLElement mergeThis);

            
            void SetOncontextmenu(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOncontextmenu();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement InsertAdjacentElement(
                [In, MarshalAs(UnmanagedType.BStr)]
                string where,
                [In, MarshalAs(UnmanagedType.Interface)]
                IHTMLElement insertedElement);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement ApplyElement(
                [In, MarshalAs(UnmanagedType.Interface)]
                IHTMLElement apply,
                [In, MarshalAs(UnmanagedType.BStr)]
                string where);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetAdjacentText(
                [In, MarshalAs(UnmanagedType.BStr)]
                string where);

            [return: MarshalAs(UnmanagedType.BStr)]
            string ReplaceAdjacentText(
                [In, MarshalAs(UnmanagedType.BStr)]
                string where,
                [In, MarshalAs(UnmanagedType.BStr)]
                string newText);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetCanHaveChildren();

            [return: MarshalAs(UnmanagedType.I4)]
            int AddBehavior(
                [In, MarshalAs(UnmanagedType.BStr)]
                string bstrUrl,
                [In]
                ref Object pvarFactory);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool RemoveBehavior(
                [In, MarshalAs(UnmanagedType.I4)]
                int cookie);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLStyle GetRuntimeStyle();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetBehaviorUrns();

            
            void SetTagUrn(
                [In, MarshalAs(UnmanagedType.BStr)]
                string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTagUrn();

            
            void SetOnbeforeeditfocus(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforeeditfocus();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetReadyStateValue();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetElementsByTagName(
                [In, MarshalAs(UnmanagedType.BStr)]
                string v);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLStyle GetBaseStyle();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLCurrentStyle GetBaseCurrentStyle();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLStyle GetBaseRuntimeStyle();

            
            void SetOnmousehover(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmousehover();

            
            void SetOnkeydownpreview(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnkeydownpreview();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetBehavior(
                [In, MarshalAs(UnmanagedType.BStr)]
                string bstrName,
                [In, MarshalAs(UnmanagedType.BStr)]
                string bstrUrn);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F4A4-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        internal interface IHTMLRectCollection 
        {

            [return: MarshalAs(UnmanagedType.I4)]
            int GetLength();

            [return: MarshalAs(UnmanagedType.Interface)]
            object Get_newEnum();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object Item(
                [In]
                ref Object pvarIndex);

        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F3DB-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        internal interface IHTMLCurrentStyle 
        {

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPosition();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetStyleFloat();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetColor();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundColor();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontFamily();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontStyle();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontObject();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetFontWeight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetFontSize();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundImage();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundPositionX();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundPositionY();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundRepeat();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderLeftColor();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderTopColor();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderRightColor();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderBottomColor();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderTopStyle();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderRightStyle();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderBottomStyle();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderLeftStyle();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderTopWidth();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderRightWidth();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderBottomWidth();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderLeftWidth();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLeft();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetTop();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetWidth();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetHeight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingLeft();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingTop();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingRight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingBottom();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextAlign();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextDecoration();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDisplay();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetVisibility();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetZIndex();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLetterSpacing();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLineHeight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetTextIndent();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetVerticalAlign();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundAttachment();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginTop();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginRight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginBottom();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginLeft();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetClear();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleType();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStylePosition();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleImage();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetClipTop();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetClipRight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetClipBottom();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetClipLeft();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetOverflow();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakBefore();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakAfter();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetCursor();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTableLayout();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderCollapse();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDirection();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBehavior();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetAttribute(
                [In, MarshalAs(UnmanagedType.BStr)]
                string strAttributeName,
                [In, MarshalAs(UnmanagedType.I4)]
                int lFlags);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetUnicodeBidi();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetRight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBottom();

        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F4A3-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        internal interface IHTMLRect 
        {
            void SetLeft(
                [In, MarshalAs(UnmanagedType.I4)] 
                int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetLeft();

            
            void SetTop(
                [In, MarshalAs(UnmanagedType.I4)] 
                int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetTop();

            
            void SetRight(
                [In, MarshalAs(UnmanagedType.I4)] 
                int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetRight();

            
            void SetBottom(
                [In, MarshalAs(UnmanagedType.I4)] 
                int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetBottom();

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\objectlistdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Data;
    using System.Drawing;
    using System.Drawing.Design;
    using System.IO;
    using System.Text;
    using System.Web.UI;
    using System.Web.UI.Design;
    using System.Web.UI.MobileControls;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;

    using System.Web.UI.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Adapters;

    using DataBinding = System.Web.UI.DataBinding;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class ObjectListDesigner : MobileTemplatedControlDesigner, IDataSourceProvider, IMobileDesigner
    {
        private DataTable _dummyDataTable;
        private DataTable _designTimeDataTable;

        private System.Web.UI.MobileControls.ObjectList _objectList;
        private DesignerVerbCollection _designerVerbs;

        private const String _dataSourcePropertyName    = "DataSource";
        private const String _dataMemberPropertyName    = "DataMember";

        private const int _headerFooterTemplates            = 0;
        private const int _itemTemplates                    = 1;
        private const int _separatorTemplate                = 2;
        private const int _numberOfTemplateFrames           = 3;

        private static readonly String[][] _templateFrameNames =
            new String[][] {
                               new String [] { Constants.HeaderTemplateTag, Constants.FooterTemplateTag },
                               new String [] { Constants.ItemTemplateTag, Constants.AlternatingItemTemplateTag, Constants.ItemDetailsTemplateTag },
                               new String [] { Constants.SeparatorTemplateTag },
                           };

        private static readonly Attribute[] _emptyAttrs = new Attribute[0];

        /// <summary>
        ///    <para>
        ///       Initializes the designer.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element being designed.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component being
        ///       designed.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.ObjectList,
                         "ObjectListDesigner.Initialize - Invalid ObjectList Control");

            _objectList = (System.Web.UI.MobileControls.ObjectList) component;
            base.Initialize(component);
        }

        protected override String[] GetTemplateFrameNames(int index)
        {
            Debug.Assert(index >= 0 & index <= _templateFrameNames.Length);
            return _templateFrameNames[index];
        }

        protected override TemplateEditingVerb[] GetTemplateVerbs()
        {
            TemplateEditingVerb[] templateVerbs = new TemplateEditingVerb[_numberOfTemplateFrames];

            templateVerbs[_headerFooterTemplates] = new TemplateEditingVerb(
                SR.GetString(SR.TemplateFrame_HeaderFooterTemplates),
                _headerFooterTemplates,
                this);
            templateVerbs[_itemTemplates] = new TemplateEditingVerb(
                SR.GetString(SR.TemplateFrame_ItemTemplates),
                _itemTemplates,
                this);
            templateVerbs[_separatorTemplate] = new TemplateEditingVerb(
                SR.GetString(SR.TemplateFrame_SeparatorTemplate),
                _separatorTemplate,
                this);

            return templateVerbs;
        }

        /// <summary>
        ///    <para>
        ///       Gets the HTML to be used for the design time representation
        ///       of the control.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The design time HTML.
        ///    </para>
        /// </returns>
        protected override String GetDesignTimeNormalHtml()
        {
            int sampleRows = 5;
            bool dummyDataSource = false;
            String oldLabelField, oldTableFields;
            oldLabelField = _objectList.LabelField;
            oldTableFields = _objectList.TableFields;

            DesignerTextWriter htmlWriter = new DesignerTextWriter(true);

            if (_objectList.DeviceSpecific != null)
            {
                _objectList.DeviceSpecific.SetDesignerChoice(CurrentChoice);
            }

            IEnumerable designTimeDataSource = GetDesignTimeDataSource(sampleRows, out dummyDataSource);

            bool oldAutoGenerateFields = _objectList.AutoGenerateFields;
            if ((oldAutoGenerateFields == false) && (_objectList.Fields.Count == 0))
            {
                // ensure that AutoGenerateFields is true when we don't have
                // any fields defined, so we see atleast something at design time.
                _objectList.AutoGenerateFields = true;
            }

            // Replace original labelfield with empty string to ensure dummy datasource will be rendered 
            if (dummyDataSource)
            {
                _objectList.LabelField  = String.Empty;
                _objectList.TableFields = String.Empty;
            }

            try 
            {
                _objectList.DataSource = designTimeDataSource;
                _objectList.DataBind();
                _objectList.Adapter.Render(htmlWriter);
            }
            finally
            {
                _objectList.DataSource = null;
                _objectList.AutoGenerateFields = oldAutoGenerateFields;

                if (dummyDataSource)
                {
                    _objectList.LabelField = oldLabelField;
                    _objectList.TableFields = oldTableFields;
                }

                // Remove controls created by databinding the DataSource
                _objectList.Controls.Clear();
                _objectList.InvalidateDisplayFieldIndices();
            }

            /*
                AUI 2198
            try
            {
                NativeMethods.IHTMLElement htmlElement = (NativeMethods.IHTMLElement) DesignTimeElement;
                NativeMethods.IHTMLDocument2 htmlDocument2 = (NativeMethods.IHTMLDocument2)htmlElement.GetDocument();
                Object linkColor = htmlDocument2.GetLinkColor();
                htmlDocument2.SetVlinkColor(linkColor);
            }
            catch (Exception)
            {
            }
            */

            return htmlWriter.ToString();
        }

        /// <summary>
        ///    <para>
        ///       Represents the method that will handle the component change event.
        ///    </para>
        /// </summary>
        /// <param name='sender'>
        ///    The source of the event.
        /// </param>
        /// <param name=' e'>
        ///    The <see cref='System.ComponentModel.Design.ComponentChangedEventArgs'/> that provides data about the event.
        /// </param>
        public override void OnComponentChanged(Object sender, ComponentChangedEventArgs e) 
        {
            if (e.Member != null)
            {
                String memberName = e.Member.Name;
                if (memberName.Equals(_dataSourcePropertyName) || 
                    memberName.Equals(_dataMemberPropertyName))
                {
                    OnDataSourceChanged();
                }
            }

            base.OnComponentChanged(sender, e);
        }

        /////////////////////////////////////////////////////////////////////////
        //  BEGIN OBJECTLIST DESIGNER DATASOURCE HANDLING
        /////////////////////////////////////////////////////////////////////////

        /// <summary>
        ///    <para>
        ///       Filter the properties to replace the runtime DataSource property
        ///       descriptor with the designer's.
        ///    </para>
        /// </summary>
        /// <param name='properties'>
        ///    The set of properties to filter.
        /// </param>
        /// <seealso cref='IDesignerFilter'/>
        protected override void PreFilterProperties(IDictionary properties) 
        {
            base.PreFilterProperties(properties);

            Type designerType = this.GetType();

            DesignerAdapterUtil.AddAttributesToPropertiesOfDifferentType(
                designerType,
                typeof(String),
                properties,
                _dataSourcePropertyName, 
                new TypeConverterAttribute(typeof(DataSourceConverter)));

            DesignerAdapterUtil.AddAttributesToProperty(
                designerType,
                properties,
                _dataMemberPropertyName,
                _emptyAttrs);
        }

        public String DataMember 
        {
            get 
            {
                return _objectList.DataMember;
            }
            set 
            {
                _objectList.DataMember = value;
                OnDataSourceChanged();
            }
        }

        /// <summary>
        ///    <para>
        ///       Gets or sets the data source property.
        ///    </para>
        /// </summary>
        /// <value>
        ///    <para>
        ///       A string indicating the data source for the designer's control.
        ///    </para>
        /// </value>
        /// <remarks>
        ///    <para>
        ///       Designer implementation of a DataSource property that operates on the
        ///       DataSource property in the control's binding collection.
        ///    </para>
        /// </remarks>
        public String DataSource 
        {
            get 
            {
                DataBinding binding = DataBindings[_dataSourcePropertyName];

                if (binding != null) 
                {
                    return binding.Expression;
                }
                return String.Empty;
            }
            set 
            {
                if ((value == null) || (value.Length == 0)) 
                {
                    DataBindings.Remove(_dataSourcePropertyName);
                }
                else 
                {
                    DataBinding binding = DataBindings[_dataSourcePropertyName];

                    if (binding == null) 
                    {
                        binding = new DataBinding(
                                      _dataSourcePropertyName,
                                      typeof(IEnumerable),
                                      value);
                    }
                    else 
                    {
                        binding.Expression = value;
                    }
                    DataBindings.Add(binding);
                }

                OnDataSourceChanged();
                OnBindingsCollectionChanged(_dataSourcePropertyName);
            }
        }

        /// <summary>
        ///    <para>
        ///       Gets sample data matching the schema of the selected data source.
        ///    </para>
        /// </summary>
        /// <param name='minimumRows'>
        ///    The minimum rows of sample data the data source data should contain.
        /// </param>
        /// <param name='dummyDataSource'>
        ///    Whether the data source being returned is a dummy data source.
        /// </param>
        /// <returns>
        ///    <para>
        ///       An IEnumerable containing a live data source for use at
        ///       design time.
        ///    </para>
        /// </returns>
        ///
        private IEnumerable GetDesignTimeDataSource(int minimumRows, out bool dummyDataSource) 
        {
            IEnumerable selectedDataSource = GetResolvedSelectedDataSource();
            return GetDesignTimeDataSource(selectedDataSource, minimumRows, out dummyDataSource);
        }

        /// <summary>
        ///    <para>
        ///       Gets sample data matching the schema of the selected data source.
        ///    </para>
        /// </summary>
        /// <param name='selectedDataSource'>
        ///    The selected data source to be used as a reference for the shape of the data.
        /// </param>
        /// <param name='minimumRows'>
        ///    The minimum rows of sample data the data source data should contain.
        /// </param>
        /// <param name='dummyDataSource'>
        ///    Whether the data source being returned is a dummy data source.
        /// </param>
        /// <returns>
        ///    <para>
        ///       An IEnumerable containing
        ///       a live data source for use at design time.
        ///    </para>
        /// </returns>
        ///
        private IEnumerable GetDesignTimeDataSource(IEnumerable selectedDataSource, int minimumRows, out bool dummyDataSource) 
        {
            DataTable dataTable = _designTimeDataTable;
            dummyDataSource = false;

            // use the datatable corresponding to the selected datasource if possible
            if (dataTable == null) 
            {
                if (selectedDataSource != null) 
                {
                    _designTimeDataTable = DesignTimeData.CreateSampleDataTable(selectedDataSource);

                    dataTable = _designTimeDataTable;
                }

                if (dataTable == null) 
                {
                    // fallback on a dummy datasource if we can't create a sample datatable
                    if (_dummyDataTable == null) 
                    {
                        _dummyDataTable = DesignTimeData.CreateDummyDataTable();
                    }

                    dataTable = _dummyDataTable;
                    dummyDataSource = true;
                }
            }

            IEnumerable liveDataSource = DesignTimeData.GetDesignTimeDataSource(dataTable, minimumRows);
            return liveDataSource;
        }

        public IEnumerable GetResolvedSelectedDataSource() 
        {
            IEnumerable selectedDataSource = null;

            DataBinding binding = DataBindings[_dataSourcePropertyName];

            if (binding != null) 
            {
                selectedDataSource = DesignTimeData.GetSelectedDataSource(_objectList, binding.Expression, DataMember);
            }

            return selectedDataSource;
        }

        /// <summary>
        ///    <para>
        ///       Gets the selected data source component from the component's container.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       An IEnumerable with the
        ///       selected data source, or <see langword='null'/> if a data source is not found, or if a data
        ///       source with the same name does not exist.
        ///    </para>
        /// </returns>
        /// <seealso cref='System.Web.UI.Design.IDataSourceProvider'/>
        public Object GetSelectedDataSource() 
        {
            Object selectedDataSource = null;

            DataBinding binding = DataBindings[_dataSourcePropertyName];

            if (binding != null) 
            {
                selectedDataSource = DesignTimeData.GetSelectedDataSource(_objectList, binding.Expression);
            }

            return selectedDataSource;
        }

        /// <summary>
        ///    <para>
        ///       Gets the template's container's data source.
        ///    </para>
        /// </summary>
        /// <param name='templateName'>
        ///    The name of the template to retrieve the data source for.
        /// </param>
        /// <returns>
        ///    <para>
        ///       An IEnumerable containing the data source or data sources available to
        ///       the template's container.
        ///    </para>
        /// </returns>
        public override IEnumerable GetTemplateContainerDataSource(String templateName) 
        {
            return GetResolvedSelectedDataSource();
        }

        public override String GetTemplateContainerDataItemProperty(string templateName) 
        {
            return "DataItem";
        }

        public override Type GetTemplatePropertyParentType(String templateName) 
        {
            return typeof(MobileTemplatedControlDesigner.TemplateContainer);
        }

        /// <internalonly/>
        /// <summary>
        ///    <para>
        ///       Raises the DataSourceChanged event.
        ///    </para>
        /// </summary>
        protected internal virtual void OnDataSourceChanged()
        {
            _designTimeDataTable = null;
        }

        public new void UpdateRendering()
        {
            _objectList.LabelStyle.Refresh();
            _objectList.CommandStyle.Refresh();

            base.UpdateRendering();
        }

        /////////////////////////////////////////////////////////////////////////
        //  END OBJECTLIST DESIGNER DATASOURCE HANDLING
        /////////////////////////////////////////////////////////////////////////

        /////////////////////////////////////////////////////////////////////////
        //  BEGIN DESIGNER VERBS
        /////////////////////////////////////////////////////////////////////////

        /// <summary>
        ///    <para>
        ///       The designer's collection of verbs.
        ///    </para>
        /// </summary>
        /// <value>
        ///    <para>
        ///       An array of type <see cref='DesignerVerb'/> containing the verbs available to the
        ///       designer.
        ///    </para>
        /// </value>
        public override DesignerVerbCollection Verbs 
        {
            get 
            {
                if (null == _designerVerbs)
                {
                    _designerVerbs = base.Verbs;
                    _designerVerbs.Add(new DesignerVerb(SR.GetString(SR.PropertyBuilderVerb),
                                                        new EventHandler(this.OnPropertyBuilder)));
                }
                Debug.Assert(_designerVerbs.Count == 2);

                _designerVerbs[0].Enabled = !this.InTemplateMode;
                _designerVerbs[1].Enabled = !this.InTemplateMode;
                return _designerVerbs;
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  BEGIN OBJECTLIST DESIGNER EVENTHANDLERS
        /////////////////////////////////////////////////////////////////////////

        /// <summary>
        ///    <para>
        ///       Represents the method that will handle the property builder event.
        ///    </para>
        /// </summary>
        /// <param name='sender'>
        ///    The source of the event.
        /// </param>
        /// <param name=' e'>
        ///    An EventArgs object that provides data about the event.
        /// </param>
        protected void OnPropertyBuilder(Object sender, EventArgs e)
        {
            InvokePropertyBuilder(0);
        }

        /// <summary>
        ///    <para>
        ///       Invokes the property builder beginning with the specified page.
        ///    </para>
        /// </summary>
        /// <param name='initialPage'>
        ///    The page to begin with.
        /// </param>
        protected internal void InvokePropertyBuilder(int initialPage)
        {
            IComponentChangeService changeService = null;
            bool result = false;

            changeService = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            if (changeService != null) 
            {
                try 
                {
                    changeService.OnComponentChanging(_objectList, null);
                }
                catch (CheckoutException ex) 
                {
                    if (ex == CheckoutException.Canceled)
                    {
                        return;
                    }
                    throw;
                }
            }

            try 
            {
                ObjectListComponentEditor compEditor = new ObjectListComponentEditor(initialPage);
                result = compEditor.EditComponent(_objectList);
            }
            finally
            {
                if (changeService != null)
                {
                    changeService.OnComponentChanged(_objectList, null, null, null);

                    if (IMobileWebFormServices != null)
                    {
                        IMobileWebFormServices.ClearUndoStack();
                    }
                }
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  END STYLE DESIGNER EVENTHANDLERS
        /////////////////////////////////////////////////////////////////////////
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\objectlistcomponenteditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListComponentEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.UI.MobileControls;
    using System.Windows.Forms.Design;

    /// <summary>
    ///    <para>
    ///       Provides a component editor for a Mobile ObjectList <see cref='System.Web.UI.MobileControls.ObjectList'/>
    ///       control.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.Web.UI.MobileControls.ObjectList'/>
    /// <seealso cref='System.Web.UI.Design.MobileControls.ObjectListDesigner'/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class ObjectListComponentEditor : BaseTemplatedMobileComponentEditor 
    {

        // The set of pages used within the ObjectList ComponentEditor
        private static Type[] _editorPages = new Type[]
                                             {
                                                 typeof(ObjectListGeneralPage),
                                                 typeof(ObjectListCommandsPage),
                                                 typeof(ObjectListFieldsPage)
                                             };

        internal const int IDX_GENERAL = 0;
        internal const int IDX_COMMANDS = 1;
        internal const int IDX_FIELDS = 2;

        /// <summary>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.MobileControls.ObjectListComponentEditor'/>.
        ///    </para>
        /// </summary>
        public ObjectListComponentEditor() : this(IDX_GENERAL)
        {
        }

        /// <summary>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.MobileControls.ObjectListComponentEditor'/>.
        ///    </para>
        /// </summary>
        /// <param name='initialPage'>
        ///    The index of the initial page.
        /// </param>
        public ObjectListComponentEditor(int initialPage) : base(initialPage)
        {
        }

        /// <summary>
        ///    <para>
        ///       Gets the set of all pages in the <see cref='System.Web.UI.MobileControls.ObjectList'/>
        ///       .
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       An array consisting of the set of component editor pages.
        ///    </para>
        /// </returns>
        /// <remarks>
        ///    <note type="inheritinfo">
        ///       This method may
        ///       be overridden to change the set of pages to show.
        ///    </note>
        /// </remarks>
        protected override Type[] GetComponentEditorPages()
        {
            return _editorPages;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\phonecalldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="PhoneCallDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Web.UI;
    using System.Web.UI.Design;

    using System.Web.UI.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Converters;

    /// <summary>
    ///    <para>
    ///       Provides a designer for the <see cref='System.Web.UI.MobileControls.PhoneCall'/>
    ///       control.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.Web.UI.MobileControls.PhoneCall'/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class PhoneCallDesigner : MobileControlDesigner
    {
        private System.Web.UI.MobileControls.PhoneCall _call;

        /// <summary>
        ///    <para>
        ///       Initializes the designer with the component for design.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element for design.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component for
        ///       design.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.PhoneCall,
                         "PhoneCallDesigner.Initialize - Invalid PhoneCall Control");
            _call = (System.Web.UI.MobileControls.PhoneCall) component;
            base.Initialize(component);
        }

        /// <summary>
        ///    <para>
        ///       Returns the design-time HTML of the <see cref='System.Web.UI.MobileControls.PhoneCall'/>
        ///       mobile control
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The HTML of the control.
        ///    </para>
        /// </returns>
        /// <seealso cref='System.Web.UI.MobileControls.PhoneCall'/>
        protected override String GetDesignTimeNormalHtml()
        {
            Debug.Assert(_call.Text != null);

            DesignerTextWriter tw;
            Control[] children = null;

            String originalText = _call.Text;
            bool blankText = (originalText.Trim().Length == 0);
            bool hasControls = _call.HasControls();

            if (blankText)
            {
                if (hasControls) 
                {
                    children = new Control[_call.Controls.Count];
                    _call.Controls.CopyTo(children, 0);
                }
                _call.Text = "[" + _call.ID + "]";
            }
            try
            {
                tw = new DesignerTextWriter();
                _call.Adapter.Render(tw);
            }
            finally
            {
                if (blankText)
                {
                    _call.Text = originalText;
                    if (hasControls) 
                    {
                        foreach (Control c in children) 
                        {
                            _call.Controls.Add(c);
                        }
                    }
                }
            }

            return tw.ToString();
        }
        
        public override void OnComponentChanged(Object sender, ComponentChangedEventArgs e) 
        {
            if ((e.Member != null) && e.Member.Name.Equals("AlternateUrl"))
            {
                _call.AlternateUrl = NavigateUrlConverter.GetUrl(
                    _call,
                    e.NewValue.ToString(),
                    e.OldValue.ToString()
                );

                e = new ComponentChangedEventArgs(e.Component, e.Member, e.OldValue, _call.AlternateUrl);
            }
            base.OnComponentChanged(sender, e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\paneldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="PanelDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Drawing;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.UI.Design.MobileControls.Util;
    using System.Web.UI.Design.MobileControls.Adapters;
    using System.Web.UI.MobileControls;

    using Microsoft.Win32;

    /// <summary>
    ///    <para>
    ///       Provides design-time support for the <see cref='System.Web.UI.MobileControls.Panel'/>
    ///       web control.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.Web.UI.MobileControls.Panel'/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class PanelDesigner : MobileContainerDesigner
    {
        private Panel  _panel;
        private TemporaryBitmapFile _backgroundBmpFile = null;
        private Size   _defaultSize;

        internal PanelDesigner()
        {
            _defaultSize = new Size(300, 45);
        }

        private bool ValidContainment
        {
            get
            {
                return (ContainmentStatus == ContainmentStatus.InForm ||
                    ContainmentStatus == ContainmentStatus.InPanel ||
                    ContainmentStatus == ContainmentStatus.InTemplateFrame);
            }
        }

        protected override void Dispose(bool disposing) 
        {
            if (disposing) 
            {
                SystemEvents.UserPreferenceChanged -= 
                    new UserPreferenceChangedEventHandler(this.OnUserPreferenceChanged);
            }

            base.Dispose(disposing);
        }

        protected override Size GetDefaultSize()
        {
            return _defaultSize;
        }

        protected override String GetErrorMessage(out bool infoMode)
        {
            infoMode = false;

            // Skip containment checking if the control is placed in MobileUserControl
            if (DesignerAdapterUtil.InMobileUserControl(_panel))
            {
                return null;
            }

            if (DesignerAdapterUtil.InUserControl(_panel))
            {
                infoMode = true;
                return MobileControlDesigner._userControlWarningMessage;
            }

            if (!DesignerAdapterUtil.InMobilePage(_panel))
            {
                return SR.GetString(SR.MobileControl_MobilePageErrorMessage);
            }

            if (!ValidContainment)
            {
                return SR.GetString(SR.MobileControl_FormPanelContainmentErrorMessage);
            }

            return null;
        }

        /// <summary>
        ///   Initializes the designer with the Form control that this instance
        ///   of the designer is associated with.
        /// </summary>
        /// <param name='component'>
        ///   The associated Form control.
        /// </param>
        /// <seealso cref='IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is Panel,
                "PanelDesigner.Initialize - Invalid Panel Control");

            // This must be called first in order to get properties from runtime control.
            base.Initialize(component);

            _panel = (Panel) component;

            SystemEvents.UserPreferenceChanged += 
                new UserPreferenceChangedEventHandler(this.OnUserPreferenceChanged);
        }

        internal override void OnBackgroundImageChange(String message, bool infoMode)
        {
            if (message == null)
            {
                RemoveBehaviorStyle("backgroundImage");
                SetBehaviorStyle("paddingTop", 8);
            }
            else
            {
                ImageCreator.CreateBackgroundImage(
                    ref _backgroundBmpFile,
                    String.Empty,
                    String.Empty,
                    message,
                    infoMode,
                    GetDefaultSize().Width
                );

                // redraw the background image here
                SetBehaviorStyle("backgroundImage",
                    "url(" + _backgroundBmpFile.Url + ")");
                SetBehaviorStyle(
                    "paddingTop",
                    _backgroundBmpFile.UnderlyingBitmap.Height + 8
                );
            }
        }

        private void OnUserPreferenceChanged(Object sender, UserPreferenceChangedEventArgs e)
        {
            if (e.Category == UserPreferenceCategory.Color)
            {
                bool infoMode;
                String newMessage = GetErrorMessage(out infoMode);
                OnBackgroundImageChange(newMessage, infoMode);
            }            
        }

        /// <summary>
        ///   Adjust the appearance based on current status.
        /// </summary>
        //protected override void SetStyleAttributes()
        protected override void OnContainmentChanged()
        {
            base.OnContainmentChanged();

            SetBehaviorStyle("marginRight",
                ContainmentStatus == ContainmentStatus.AtTopLevel ? "30%" : "5px");

            SetBehaviorStyle("marginTop", ValidContainment? "3px" : "5px");
            SetBehaviorStyle("marginBottom", ValidContainment? "3px" : "5px");
            SetBehaviorStyle("width", ValidContainment? "100%" : GetDefaultSize().Width.ToString() + "px");
        }

        protected override void SetControlDefaultAppearance()
        {
            base.SetControlDefaultAppearance();

            // Customize styles
            SetBehaviorStyle("borderStyle", "dotted");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\objectlistcommandspage.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListCommandsPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.CodeDom.Compiler;
    using System.Diagnostics;
    using System.Drawing;
    using System.Web.UI.MobileControls;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Web.UI.Design.Util;

    using System.Web.UI.Design.MobileControls.Util;

    using ObjectList = System.Web.UI.MobileControls.ObjectList;
    using Label      = System.Windows.Forms.Label;
    using TextBox    = System.Windows.Forms.TextBox;

    /// <summary>
    ///   The Commands page for the ObjectList control.
    /// </summary>
    /// <internalonly/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class ObjectListCommandsPage : ListComponentEditorPage
    {
        private ComboBox _cmbDefaultCommand;
        private TextBox _txtText = null;
        private ObjectList _objectList = null;

        public ObjectListCommandsPage()
        {
            Y = 24;
            CaseSensitive = false;
            TreeViewTitle           = SR.GetString(SR.ObjectListCommandsPage_CommandNameCaption);
            AddButtonTitle          = SR.GetString(SR.ObjectListCommandsPage_NewCommandBtnCaption);
            DefaultName             = SR.GetString(SR.ObjectListCommandsPage_DefaultCommandName);
            MessageTitle            = SR.GetString(SR.ObjectListCommandsPage_ErrorMessageTitle);
            EmptyNameMessage        = SR.GetString(SR.ObjectListCommandsPage_EmptyNameError);
            // DuplicateNameMessage = SR.GetString(SR.ObjectListCommandsPage_DuplicateNameError);
            // InvalidNameMessage   = SR.GetString(SR.ObjectListCommandsPage_InvalidName);  // DCR 4240
        }

        protected override String HelpKeyword 
        {
            get 
            {
                return "net.Mobile.ObjectListProperties.Commands";
            }
        }

        protected override void InitForm()
        {
            base.InitForm();

            this._objectList = (ObjectList)Component;
            this.CommitOnDeactivate = true;
            this.Icon = new Icon(
                typeof(System.Web.UI.Design.MobileControls.MobileControlDesigner),
                "Commands.ico"
            );
            this.Size = new Size(402, 300);
            this.Text = SR.GetString(SR.ObjectListCommandsPage_Title);

            GroupLabel grplblCommandList = new GroupLabel();
            grplblCommandList.SetBounds(4, 4, 392, LabelHeight);
            grplblCommandList.Text = SR.GetString(SR.ObjectListCommandsPage_CommandListGroupLabel);
            grplblCommandList.TabIndex = 0;
            grplblCommandList.TabStop = false;

            TreeList.TabIndex = 1;

            Label lblText = new Label();
            lblText.SetBounds(X, Y, ControlWidth, LabelHeight);
            lblText.Text = SR.GetString(SR.ObjectListCommandsPage_TextCaption);
            lblText.TabStop = false;
            lblText.TabIndex = TabIndex;

            _txtText = new TextBox();
            Y += LabelHeight;
            _txtText.SetBounds(X, Y, ControlWidth, CmbHeight);
            _txtText.TextChanged += new EventHandler(this.OnPropertyChanged);
            _txtText.TabIndex = TabIndex + 1;

            GroupLabel grplblData = new GroupLabel();
            grplblData.SetBounds(4, 238, 392, LabelHeight);
            grplblData.Text = SR.GetString(SR.ObjectListCommandsPage_DataGroupLabel);
            grplblData.TabIndex = TabIndex + 2;
            grplblData.TabStop = false;

            Label lblDefaultCommand = new Label();
            lblDefaultCommand.SetBounds(8, 260, 182, LabelHeight);
            lblDefaultCommand.Text = SR.GetString(SR.ObjectListCommandsPage_DefaultCommandCaption);
            lblDefaultCommand.TabStop = false;
            lblDefaultCommand.TabIndex = TabIndex + 3;

            _cmbDefaultCommand = new ComboBox();
            _cmbDefaultCommand.SetBounds(8, 276, 182, 64);
            _cmbDefaultCommand.DropDownStyle = ComboBoxStyle.DropDown;
            _cmbDefaultCommand.Sorted = true;
            _cmbDefaultCommand.TabIndex = TabIndex + 4;
            _cmbDefaultCommand.SelectedIndexChanged += new EventHandler(this.OnSetPageDirty);
            _cmbDefaultCommand.TextChanged += new EventHandler(this.OnSetPageDirty);

            this.Controls.AddRange(new Control[] 
                                    {
                                        grplblCommandList,
                                        lblText,
                                        _txtText,
                                        grplblData,
                                        lblDefaultCommand,
                                        _cmbDefaultCommand
                                    });
        }

        protected override void InitPage() 
        {
            base.InitPage();

            _cmbDefaultCommand.Text = _objectList.DefaultCommand;
            _txtText.Text = String.Empty;
        }

        protected override void LoadItems()
        {
            using (new LoadingModeResource(this))
            {
                foreach (ObjectListCommand command in _objectList.Commands)
                {
                    CommandTreeNode newNode = new CommandTreeNode(command.Name, command);
                    TreeList.TvList.Nodes.Add(newNode);
                }
            }
            LoadDefaultCommands();
        }

        protected override void LoadItemProperties() 
        {
            using (new LoadingModeResource(this))
            {
                if (CurrentNode != null)
                {
                    CommandTreeNode currentCommandNode = (CommandTreeNode)CurrentNode;
                    _txtText.Text = currentCommandNode.Text;
                }
                else
                {
                    _txtText.Text = String.Empty;
                }
            }
        }

        private void LoadDefaultCommands()
        {
            _cmbDefaultCommand.Items.Clear();
            foreach (CommandTreeNode commandNode in TreeList.TvList.Nodes)
            {
                _cmbDefaultCommand.Items.Add(commandNode.Name);
            }
        }

        private void OnSetPageDirty(Object source, EventArgs e) 
        {
            if (IsLoading())
            {
                return;
            }
            SetDirty();
        }

        protected override void OnClickAddButton(Object source, EventArgs e)
        {
            if (IsLoading())
            {
                return;
            }

            CommandTreeNode newNode = new CommandTreeNode(GetNewName());
            TreeList.TvList.Nodes.Add(newNode);

            TreeList.TvList.SelectedNode = newNode;
            CurrentNode = newNode;
            newNode.Dirty = true;
            newNode.BeginEdit();

            LoadItemProperties();
            LoadDefaultCommands();
            SetDirty();
        }

        protected override void OnClickRemoveButton(Object source, EventArgs e)
        {
            base.OnClickRemoveButton(source, e);
            LoadDefaultCommands();
        }

        protected override void OnNodeRenamed()
        {
            LoadDefaultCommands();
        }

        protected override void OnPropertyChanged(Object source, EventArgs e)
        {
            if (IsLoading())
            {
                return;
            }

            // This means there are no fields yet. Do nothing
            if (CurrentNode == null)
            {
                return;
            }

            ((CommandTreeNode)CurrentNode).Text = _txtText.Text;

            SetDirty();
            CurrentNode.Dirty = true;
        }

        protected override void SaveComponent()
        {
            // Delegate to base implementation first!
            // This will properly close ListTreeNode editing mode.
            base.SaveComponent();

            _objectList.DefaultCommand = _cmbDefaultCommand.Text;

            _objectList.Commands.Clear();

            foreach (CommandTreeNode commandNode in TreeList.TvList.Nodes)
            {
                if (commandNode.Dirty)
                {
                    commandNode.RuntimeCommand.Text = commandNode.Text;
                    commandNode.RuntimeCommand.Name = commandNode.Name;
                }

                _objectList.Commands.AddAt(-1, commandNode.RuntimeCommand);
            }

            TypeDescriptor.Refresh(_objectList);
        }

        protected override void UpdateControlsEnabling()
        {
            TreeList.TvList.Enabled = 
                _txtText.Enabled = (TreeList.TvList.SelectedNode != null);
        }

        /// <summary>
        ///    Internal object used to store all command properties
        /// </summary>
        [
            System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        private class CommandTreeNode : ListTreeNode
        {
            private ObjectListCommand   _runtimeCommand;
            private String              _text;

            /// <summary>
            /// </summary>
            internal CommandTreeNode(String name) : this(name, new ObjectListCommand())
            {
            }

            /// <summary>
            /// </summary>
            internal CommandTreeNode(String name, ObjectListCommand runtimeCommand) : base(name)
            {
                Debug.Assert(name != null, "invalid name for ObjectListCommand");
                Debug.Assert(runtimeCommand != null, "null ObjectListCommand");

                this._runtimeCommand = runtimeCommand;
                LoadAttributes();
            }

            internal void LoadAttributes()
            {
                this._text = _runtimeCommand.Text;
            }

            internal ObjectListCommand RuntimeCommand
            {
                get
                {
                    return _runtimeCommand;
                }
            }

            internal new String Text
            {
                get
                {
                    return _text;
                }

                set
                {
                    _text = value;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\objectlistfieldspage.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListFieldsPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Web.UI.MobileControls;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Web.UI.Design.MobileControls.Util;

    using DesignTimeData = System.Web.UI.Design.DesignTimeData;
    using Button = System.Windows.Forms.Button;
    using Label = System.Windows.Forms.Label;
    using ComboBox = System.Windows.Forms.ComboBox;
    using TextBox = System.Windows.Forms.TextBox;

    /// <summary>
    ///   The Choices page for the StyleSheet control.
    /// </summary>
    /// <internalonly/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class ObjectListFieldsPage : ListComponentEditorPage
    {
        private CheckBox _ckbAutoGenerateFields;
        private CheckBox _ckbVisible;
        private TextBox _txtDataFormatString;
        private TextBox _txtTitle;
        private UnsettableComboBox _cmbDataField;
        private ObjectList _objectList;

        public ObjectListFieldsPage()
        {
            Y = 52;
            CaseSensitive = false;
            TreeViewTitle           = SR.GetString(SR.ObjectListFieldsPage_FieldNameCaption);
            AddButtonTitle          = SR.GetString(SR.ObjectListFieldsPage_NewFieldBtnCaption);
            DefaultName             = SR.GetString(SR.ObjectListFieldsPage_DefaultFieldName);
            MessageTitle            = SR.GetString(SR.ObjectListFieldsPage_ErrorMessageTitle);
            EmptyNameMessage        = SR.GetString(SR.ObjectListFieldsPage_EmptyNameError);
            // DuplicateNameMessage = SR.GetString(SR.ObjectListFieldsPage_DuplicateNameError);
        }

        protected override String HelpKeyword 
        {
            get 
            {
                return "net.Mobile.ObjectListProperties.Fields";
            }
        }

        protected override void InitForm()
        {
            base.InitForm();

            this._objectList = (ObjectList)Component;

            this.CommitOnDeactivate = true;
            this.Icon = new Icon(
                typeof(System.Web.UI.Design.MobileControls.MobileControlDesigner),
                "Fields.ico"
            );
            this.Size = new Size(402, 300);
            this.Text = SR.GetString(SR.ObjectListFieldsPage_Title);
            
            _ckbAutoGenerateFields = new CheckBox();
            _cmbDataField          = new UnsettableComboBox();
            _ckbVisible            = new CheckBox();
            _txtDataFormatString   = new TextBox();
            _txtTitle              = new TextBox();

            _ckbAutoGenerateFields.SetBounds(4, 4, 396, LabelHeight);
            _ckbAutoGenerateFields.Text = SR.GetString(SR.ObjectListFieldsPage_AutoGenerateFieldsCaption);
            _ckbAutoGenerateFields.FlatStyle = FlatStyle.System;
            _ckbAutoGenerateFields.CheckedChanged += new EventHandler(this.OnSetPageDirty);
            _ckbAutoGenerateFields.TabIndex = 0;

            GroupLabel grplblFieldList = new GroupLabel();
            grplblFieldList.SetBounds(4, 32, 392, LabelHeight);
            grplblFieldList.Text = SR.GetString(SR.ObjectListFieldsPage_FieldListGroupLabel);
            grplblFieldList.TabIndex = 1;
            grplblFieldList.TabStop = false;

            TreeList.TabIndex = 2;

            Label lblDataField = new Label();
            lblDataField.SetBounds(X, Y, ControlWidth, LabelHeight);
            lblDataField.Text = SR.GetString(SR.ObjectListFieldsPage_DataFieldCaption);
            lblDataField.TabStop = false;
            lblDataField.TabIndex = Index;

            Y += LabelHeight;
            _cmbDataField.SetBounds(X, Y, ControlWidth, CmbHeight);
            _cmbDataField.DropDownStyle = ComboBoxStyle.DropDown;
            _cmbDataField.Sorted        = true;
            _cmbDataField.NotSetText    = SR.GetString(SR.ObjectListFieldsPage_NoneComboEntry);
            _cmbDataField.TextChanged   += new EventHandler(this.OnPropertyChanged);
            _cmbDataField.SelectedIndexChanged += new EventHandler(this.OnPropertyChanged);
            _cmbDataField.TabIndex = Index + 1;

            Y += CellSpace;
            Label lblDataFormatString = new Label();
            lblDataFormatString.SetBounds(X, Y, ControlWidth, LabelHeight);
            lblDataFormatString.Text = SR.GetString(SR.ObjectListFieldsPage_DataFormatStringCaption);
            lblDataFormatString.TabStop = false;
            lblDataFormatString.TabIndex = Index + 2;

            Y += LabelHeight;
            _txtDataFormatString.SetBounds(X, Y, ControlWidth, CmbHeight);
            _txtDataFormatString.TextChanged += new EventHandler(this.OnPropertyChanged);
            _txtDataFormatString.TabIndex = Index + 3;

            Y += CellSpace;
            Label lblTitle = new Label();
            lblTitle.SetBounds(X, Y, ControlWidth, LabelHeight);
            lblTitle.Text = SR.GetString(SR.ObjectListFieldsPage_TitleCaption);
            lblTitle.TabStop = false;
            lblTitle.TabIndex = Index + 4;

            Y += LabelHeight;
            _txtTitle.SetBounds(X, Y, ControlWidth, CmbHeight);
            _txtTitle.TextChanged += new EventHandler(this.OnPropertyChanged);
            _txtTitle.TabIndex = Index + 5;

            Y += CellSpace;
            _ckbVisible.SetBounds(X, Y, ControlWidth, CmbHeight);
            _ckbVisible.FlatStyle = System.Windows.Forms.FlatStyle.System;
            _ckbVisible.Text = SR.GetString(SR.ObjectListFieldsPage_VisibleCaption); 
            _ckbVisible.CheckedChanged += new EventHandler(this.OnPropertyChanged);
            _ckbVisible.TabIndex = Index + 6;

            this.Controls.AddRange(new Control[] {
                                                     _ckbAutoGenerateFields,
                                                     grplblFieldList,
                                                     lblDataField,
                                                     _cmbDataField,
                                                     lblDataFormatString,
                                                     _txtDataFormatString,
                                                     lblTitle,
                                                     _txtTitle,
                                                     _ckbVisible
                                                 });
        }

        protected override void InitPage() 
        {
            base.InitPage();

            _cmbDataField.Items.Clear();
            _cmbDataField.SelectedIndex = -1;
            _cmbDataField.EnsureNotSetItem();
            _txtDataFormatString.Text = String.Empty;
            _txtTitle.Text = String.Empty;
            _ckbVisible.Checked = true;
            _ckbAutoGenerateFields.Checked = _objectList.AutoGenerateFields;

            LoadDataSourceFields();
        }

        private void LoadDataSourceFields() 
        {
            using (new LoadingModeResource(this))
            {
                PropertyDescriptorCollection props = null;
                ObjectListDesigner objectListDesigner = (ObjectListDesigner)GetBaseDesigner();

                IEnumerable dataSource = ((IDataSourceProvider)objectListDesigner).GetResolvedSelectedDataSource();
                if (dataSource != null)
                {
                    props = DesignTimeData.GetDataFields(dataSource);
                }

                if (props != null)
                {
                    foreach (PropertyDescriptor propDesc in props)
                    {
                        _cmbDataField.Items.Add(propDesc.Name);
                    }
                }
            }
        }

        protected override void LoadItems()
        {
            using (new LoadingModeResource(this))
            {
                foreach (ObjectListField field in _objectList.Fields)
                {
                    FieldTreeNode newNode = new FieldTreeNode(field.Name, field);
                    TreeList.TvList.Nodes.Add(newNode);
                }
            }
        }

        protected override void LoadItemProperties()
        {
            using (new LoadingModeResource(this))
            {
                if (CurrentNode != null)
                {
                    FieldTreeNode currentFieldNode = (FieldTreeNode)CurrentNode;

                    _cmbDataField.Text          = currentFieldNode.DataField;
                    _txtDataFormatString.Text   = currentFieldNode.DataFormatString;
                    _txtTitle.Text              = currentFieldNode.Title;
                    _ckbVisible.Checked         = currentFieldNode.Visible;
                }
                else
                {
                    _cmbDataField.Text          = String.Empty;
                    _txtDataFormatString.Text   = String.Empty;
                    _txtTitle.Text              = String.Empty;
                    _ckbVisible.Checked         = false;
                }
            }
        }

        private void OnSetPageDirty(Object source, EventArgs e) 
        {
            if (IsLoading())
            {
                return;
            }
            SetDirty();
        }

        protected override void OnClickAddButton(Object source, EventArgs e)
        {
            if (IsLoading())
            {
                return;
            }

            FieldTreeNode newNode = new FieldTreeNode(GetNewName());
            TreeList.TvList.Nodes.Add(newNode);

            TreeList.TvList.SelectedNode = newNode;
            CurrentNode = newNode;
            newNode.Dirty = true;
            newNode.BeginEdit();

            LoadItemProperties();

            SetDirty();
        }

        protected override void OnPropertyChanged(Object source, EventArgs e)
        {
            if (IsLoading())
            {
                return;
            }

            // This means there are no fields yet. Do nothing
            if (CurrentNode == null)
            {
                return;
            }

            FieldTreeNode currentFieldNode = (FieldTreeNode)CurrentNode;

            if (source == _cmbDataField)
            {
                currentFieldNode.DataField = _cmbDataField.Text;
            }
            else if (source == _txtDataFormatString)
            {
                currentFieldNode.DataFormatString = _txtDataFormatString.Text;
            }
            else if (source == _txtTitle)
            {
                currentFieldNode.Title = _txtTitle.Text;
            }
            else if (source == _ckbVisible)
            {
                currentFieldNode.Visible = _ckbVisible.Checked;
            }

            SetDirty();
            CurrentNode.Dirty = true;
        }

        protected override void SaveComponent()
        {
            // Delegate to base implementation first!
            // This will properly close ListTreeNode editing mode.
            base.SaveComponent();

            _objectList.Fields.Clear();

            foreach (FieldTreeNode fieldNode in TreeList.TvList.Nodes)
            {
                if (fieldNode.Dirty)
                {
                    fieldNode.RuntimeField.Name             = fieldNode.Name;
                    fieldNode.RuntimeField.DataField        = fieldNode.DataField;
                    fieldNode.RuntimeField.DataFormatString = fieldNode.DataFormatString;
                    fieldNode.RuntimeField.Title            = fieldNode.Title;
                    fieldNode.RuntimeField.Visible          = fieldNode.Visible;
                }

                Debug.Assert(fieldNode.RuntimeField != null);
                _objectList.Fields.AddAt(-1, fieldNode.RuntimeField);
            }

            _objectList.AutoGenerateFields = _ckbAutoGenerateFields.Checked;

            TypeDescriptor.Refresh(_objectList);
        }

        protected override void UpdateControlsEnabling()
        {
            TreeList.TvList.Enabled = 
            _cmbDataField.Enabled = 
            _txtDataFormatString.Enabled = 
            _txtTitle.Enabled = 
            _ckbVisible.Enabled = (TreeList.TvList.SelectedNode != null);
        }

        [
            System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        private class FieldTreeNode : ListTreeNode
        {
            private ObjectListField _runtimeField;

            private String _dataField;
            private String _dataFormatString;
            private String _title;
            private bool _visible;

            internal FieldTreeNode(String fieldID) : this(fieldID, new ObjectListField())
            {
            }

            /// <summary>
            /// </summary>
            internal FieldTreeNode(String fieldID, ObjectListField runtimeField) : base(fieldID)
            {
                Debug.Assert(fieldID != null, "invalid ID for ObjectListField");
                Debug.Assert(runtimeField != null, "null ObjectListField");

                this._runtimeField  = runtimeField;

                LoadAttributes();
            }

            private void LoadAttributes()
            {
                this.DataField          = RuntimeField.DataField;
                this.DataFormatString   = RuntimeField.DataFormatString;
                this.Title              = RuntimeField.Title;
                this.Visible            = RuntimeField.Visible;
            }

            internal ObjectListField RuntimeField 
            {
                get
                {
                    return _runtimeField;
                }
            }

            internal String DataField
            {
                get
                {
                    return _dataField;
                }

                set
                {
                    _dataField = value;
                }
            }

            internal String DataFormatString
            {
                get
                {
                    return _dataFormatString;
                }

                set
                {
                    _dataFormatString = value;
                }
            }

            internal String Title
            {
                get
                {
                    return _title;
                }

                set
                {
                    _title = value;
                }
            }

            internal bool Visible
            {
                get
                {
                    return _visible;
                }

                set
                {
                    _visible = value;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\safenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class SafeNativeMethods {
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        internal static extern bool MessageBeep(int type);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\propertyoverridestypeeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyOverridesTypeEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing.Design;
    using System.Windows.Forms.Design;

    using DialogResult = System.Windows.Forms.DialogResult;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class PropertyOverridesTypeEditor : UITypeEditor
    {
        private static readonly String _propertyOverridesDescription = "PropertyOverrides";

        public override Object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, Object value)
        {
            Debug.Assert(context.Instance is Control, "Expected control");
            Control ctrl = (Control) context.Instance;

            IServiceProvider serviceProvider;
            ISite site = ctrl.Site;
            if (site == null && ctrl.Page != null)
            {
                site = ctrl.Page.Site;
            }
            if (site != null)
            {
                serviceProvider = site;
            }
            else
            {
                serviceProvider = provider;
            }
            Debug.Assert(serviceProvider != null,
                "Failed to get the serviceProvider");
            
            IComponentChangeService changeService =
                (IComponentChangeService) serviceProvider.GetService(typeof(IComponentChangeService));
            
            IDesignerHost designerHost = 
                (IDesignerHost) serviceProvider.GetService(typeof(IDesignerHost));
            Debug.Assert(designerHost != null,
                "Must always have access to IDesignerHost service");

            IDeviceSpecificDesigner dsDesigner = 
                designerHost.GetDesigner(ctrl) as IDeviceSpecificDesigner;
            Debug.Assert(dsDesigner != null,
                "Expected component designer to implement IDeviceSpecificDesigner");

            IMobileWebFormServices wfServices = 
                (IMobileWebFormServices)serviceProvider.GetService(typeof(IMobileWebFormServices));

            DialogResult result = DialogResult.Cancel;

            DesignerTransaction transaction = designerHost.CreateTransaction(_propertyOverridesDescription);
            try
            {
                if (changeService != null)
                {
                    try
                    {
                        changeService.OnComponentChanging(ctrl, null);
                    }
                    catch (CheckoutException ce)
                    {
                        if (ce == CheckoutException.Canceled)
                        {
                            return value;
                        }
                        throw;
                    }
                }

                try
                {
                    PropertyOverridesDialog dialog = new PropertyOverridesDialog(
                        dsDesigner,
                        MobileControlDesigner.MergingContextProperties
                        );
                    IWindowsFormsEditorService edSvc = 
                        (IWindowsFormsEditorService) provider.GetService(typeof(IWindowsFormsEditorService));
                    result = edSvc.ShowDialog(dialog);
                }
                catch(InvalidChoiceException e)
                {
                    Debug.Fail(e.ToString());
                }
                finally
                {
                    if (changeService != null && result != DialogResult.Cancel)
                    {
                        changeService.OnComponentChanged(ctrl, null, null, null);
                    }
                }
            }
            finally 
            {
                if (transaction != null)
                {
                    if (result == DialogResult.OK)
                    {
                        transaction.Commit();
                    }
                    else 
                    {
                        transaction.Cancel();
                    }
                }
            }

            return value;
        }

        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) 
        {
            return UITypeEditorEditStyle.Modal;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\propertyoverridesdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyOverridesDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Globalization;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Reflection;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    using Control = System.Web.UI.Control;

    using System.Web.UI.MobileControls;
    using System.Web.UI.Design.MobileControls.Converters;
    using System.Web.UI.Design.MobileControls.Util;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class PropertyOverridesDialog :
        System.Windows.Forms.Form, IRefreshableDeviceSpecificEditor, IDeviceSpecificDesigner
    {
        private bool _isDirty = true;
        private IDeviceSpecificDesigner _designer;
        private int _mergingContext;
        private System.Windows.Forms.Control _header;
        private String _currentDeviceSpecificID;
        private IDictionary _cachedDeviceSpecifics =
            new HybridDictionary(true /* make case-insensitive */);
        private bool _ignoreSelectionChanged = true;

        private System.Windows.Forms.Label _lblProperties;
        private System.Windows.Forms.PropertyGrid _pgProperties;
        private System.Windows.Forms.Button _btnEditFilters;
        private System.Windows.Forms.ComboBox _cbChoices;
        private System.Windows.Forms.Label _lblAppliedFilters;
        private System.Windows.Forms.Button _cmdOK;
        private System.Windows.Forms.Button _cmdHelp;
        private System.Windows.Forms.Button _cmdCancel;
        private System.Windows.Forms.Panel _pnlMain;
        
        internal PropertyOverridesDialog(
            IDeviceSpecificDesigner designer,
            int mergingContext
        ) {
            _designer = designer;
            _mergingContext = mergingContext;
           
            // Required for Win Form Designer support
            InitializeComponent();

            this._lblAppliedFilters.Text =
                SR.GetString(SR.PropertyOverridesDialog_AppliedDeviceFilters);
            this._btnEditFilters.Text = SR.GetString(SR.GenericDialog_Edit);
            this._lblProperties.Text =
                SR.GetString(SR.PropertyOverridesDialog_DeviceSpecificProperties);
            this._cmdOK.Text = SR.GetString(SR.GenericDialog_OKBtnCaption);
            this._cmdCancel.Text = SR.GetString(SR.GenericDialog_CancelBtnCaption);
            this._cmdHelp.Text = SR.GetString(SR.GenericDialog_HelpBtnCaption);

            int tabOffset = GenericUI.InitDialog(
                this,
                _designer,
                _mergingContext
            );

            this.Text = _designer.UnderlyingControl.ID
                + " - " + SR.GetString(SR.PropertyOverridesDialog_Title);
            SetTabIndexes(tabOffset);
            _designer.SetDeviceSpecificEditor(this);

            // Note that the following can cause an
            // IDeviceSpecificDesigner.Refresh() to occur as a side-effect.
            _designer.RefreshHeader(_mergingContext);
            _ignoreSelectionChanged = false;

            // NOTE: Calling CurrentDeviceSpecificID will cause a refresh to
            //       happen as a side effect.
            _currentDeviceSpecificID = _designer.CurrentDeviceSpecificID;
            if(_currentDeviceSpecificID != null)
            {
                _cbChoices.Items.Clear();
                LoadChoices(_currentDeviceSpecificID);
                if(!ValidateLoadedChoices())
                {
                    // Throw to prevent dialog from opening.  Caught and hidden
                    // by PropertyOverridesTypeEditor.cs
                    throw new InvalidChoiceException(
                        "Property overrides dialog can not open because there " +
                        "are invalid choices defined in the page."
                    );
                }
            }
            
            // Register Event Handlers
            _cbChoices.SelectedIndexChanged += new EventHandler(
                OnFilterSelected
            );
            _btnEditFilters.Click += new EventHandler(OnEditFilters);
            _cmdOK.Click += new EventHandler(OnOK);
            _cmdCancel.Click += new EventHandler(OnCancel);
            _cmdHelp.Click += new EventHandler(OnHelp);
            UpdateUI();
        }

        internal void SetTabIndexes(int tabOffset)
        {
            this._pnlMain.TabIndex = ++tabOffset;
            this._lblAppliedFilters.TabIndex = ++tabOffset;
            this._cbChoices.TabIndex = ++tabOffset;
            this._btnEditFilters.TabIndex = ++tabOffset;
            this._lblProperties.TabIndex = ++tabOffset;
            this._pgProperties.TabIndex = ++tabOffset;
            this._cmdOK.TabIndex = ++tabOffset;
            this._cmdCancel.TabIndex = ++tabOffset;
            this._cmdHelp.TabIndex = ++tabOffset;
        }
        
        private void InitializeComponent()
        {
            this._cbChoices = new System.Windows.Forms.ComboBox();
            this._cmdOK = new System.Windows.Forms.Button();
            this._cmdHelp = new System.Windows.Forms.Button();
            this._btnEditFilters = new System.Windows.Forms.Button();
            this._pnlMain = new System.Windows.Forms.Panel();
            this._pgProperties = new System.Windows.Forms.PropertyGrid();
            this._lblProperties = new System.Windows.Forms.Label();
            this._lblAppliedFilters = new System.Windows.Forms.Label();
            this._cmdCancel = new System.Windows.Forms.Button();
            this._cbChoices.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this._cbChoices.DropDownWidth = 195;
            this._cbChoices.Location = new System.Drawing.Point(0, 16);
            this._cbChoices.Size = new System.Drawing.Size(195, 21);
            this._cmdOK.Location = new System.Drawing.Point(39, 290);
            this._cmdCancel.Location = new System.Drawing.Point(120, 290);
            this._cmdHelp.Location = new System.Drawing.Point(201, 290);
            this._btnEditFilters.Location = new System.Drawing.Point(201, 15);
            this._btnEditFilters.Size = new System.Drawing.Size(75, 23);
            this._pnlMain.Anchor = (System.Windows.Forms.AnchorStyles.Bottom
                | System.Windows.Forms.AnchorStyles.Left);
            this._pnlMain.Controls.AddRange(new System.Windows.Forms.Control[] {
                this._cmdHelp,
                this._cmdCancel,
                this._cmdOK,
                this._lblProperties,
                this._pgProperties,
                this._btnEditFilters,
                this._cbChoices,
                this._lblAppliedFilters});
            this._pnlMain.Location = new System.Drawing.Point(6, 5);
            this._pnlMain.Size = new System.Drawing.Size(276, 313);
            this._pgProperties.CommandsVisibleIfAvailable = false;
            this._pgProperties.HelpVisible = false;
            this._pgProperties.LargeButtons = false;
            this._pgProperties.LineColor = System.Drawing.SystemColors.ScrollBar;
            this._pgProperties.Location = new System.Drawing.Point(0, 64);
            this._pgProperties.PropertySort = System.Windows.Forms.PropertySort.Alphabetical;
            this._pgProperties.Size = new System.Drawing.Size(275, 220);
            this._pgProperties.Text = "PropertyGrid";
            this._pgProperties.ToolbarVisible = false;
            this._pgProperties.ViewBackColor = System.Drawing.SystemColors.Window;
            this._pgProperties.ViewForeColor = System.Drawing.SystemColors.WindowText;
            this._pgProperties.PropertyValueChanged += new PropertyValueChangedEventHandler(this.OnPropertyValueChanged);
            this._lblProperties.Location = new System.Drawing.Point(0, 48);
            this._lblProperties.Size = new System.Drawing.Size(275, 16);
            this._lblAppliedFilters.Size = new System.Drawing.Size(275, 16);
            this.AcceptButton = _cmdOK;
            this.CancelButton = _cmdCancel;
            this.HelpRequested += new HelpEventHandler(this.OnHelpRequested);
            this.ClientSize = new System.Drawing.Size(285, 325);
            this.Controls.AddRange(new System.Windows.Forms.Control[] {this._pnlMain});
        }
        
        private void CacheState(String deviceSpecificID)
        {
            _cachedDeviceSpecifics[deviceSpecificID] = 
                new PropertyOverridesCachedState(_cbChoices);
        }

        private void CacheCurrentState()
        {
            CacheState(_currentDeviceSpecificID);
        }

        private bool RestoreState(String deviceSpecificID)
        {
            if (null != deviceSpecificID)
            {
                _currentDeviceSpecificID = deviceSpecificID.ToLower(CultureInfo.InvariantCulture);
                PropertyOverridesCachedState state =
                    (PropertyOverridesCachedState) _cachedDeviceSpecifics[
                        _currentDeviceSpecificID
                    ];
                if(state != null)
                {
                    state.Restore(_cbChoices);
                    foreach(ChoiceTreeNode node in state.Choices)
                    {
                        node.Choice.Refresh();
                    }
                    return true;
                }
            }
            else
            {
                _currentDeviceSpecificID = null;
            }
            return false;
        }

        [Conditional("DEBUG")]
        private void debug_CheckChoicesForDuplicate(DeviceSpecificChoice runtimeChoice)
        {
            foreach(ChoiceTreeNode choiceNode in _cbChoices.Items)
            {
                if(choiceNode.Name == runtimeChoice.Filter
                    && choiceNode.RuntimeChoice.Argument == runtimeChoice.Argument)
                {
                    Debug.Fail("Loaded duplicate choice: " + 
                        DesignerUtility.ChoiceToUniqueIdentifier(runtimeChoice));
                }
            }
        }

        private void LoadChoices(String deviceSpecificID)
        {
            DeviceSpecific ds;
            _designer.GetDeviceSpecific(deviceSpecificID, out ds);
            LoadChoices(ds);
        }
        
        private void LoadChoices(DeviceSpecific deviceSpecific)
        {
            if(deviceSpecific != null)
            {
                foreach(DeviceSpecificChoice runtimeChoice in deviceSpecific.Choices)
                {
                    debug_CheckChoicesForDuplicate(runtimeChoice);
                    ChoiceTreeNode newChoiceNode = new ChoiceTreeNode(
                        null,
                        runtimeChoice,
                        _designer
                    );
                    newChoiceNode.IncludeArgument = true;
                    _cbChoices.Items.Add(newChoiceNode);
                }
            }
            UpdateUI();
        }

        private bool ValidateLoadedChoices()
        {
            StringCollection duplicateChoices =
                DesignerUtility.GetDuplicateChoiceTreeNodes(
                    _cbChoices.Items
                );

            if(duplicateChoices.Count > 0)
            {
                if (!_ignoreSelectionChanged)
                {
                    GenericUI.ShowWarningMessage(
                        SR.GetString(SR.PropertyOverridesDialog_Title),
                        SR.GetString(SR.PropertyOverridesDialog_DuplicateChoices,
                        GenericUI.BuildCommaDelimitedList(duplicateChoices))
                        );
                }
                return false;
            }
            return true;
        }
        
        private void SaveChoices()
        {
            if(_currentDeviceSpecificID != null)
            {
                CacheCurrentState();
            }
            foreach (DictionaryEntry entry in _cachedDeviceSpecifics)
            {
                PropertyOverridesCachedState state =
                    (PropertyOverridesCachedState) entry.Value;
                state.SaveChoicesFromComboBox(
                    _designer,
                    (String) entry.Key
                );
            }
        }
        
        private void UpdateUI()
        {
            if(_cbChoices.SelectedItem == null && _cbChoices.Items.Count > 0)
            {
                _cbChoices.SelectedItem = _cbChoices.Items[0];
            }
            
            ChoiceTreeNode choice = (ChoiceTreeNode) _cbChoices.SelectedItem;
            bool isChoiceSelected = (choice != null);
            if (isChoiceSelected)
            {
                _cbChoices.Text = choice.ToString();
                _pgProperties.SelectedObject =
                    choice.Choice;
            }
            else
            {
                _cbChoices.Text = "";
                _pgProperties.SelectedObject = null;
            }
            _cbChoices.Enabled = isChoiceSelected;
            _pgProperties.Enabled = isChoiceSelected;
            _btnEditFilters.Enabled = (_currentDeviceSpecificID != null);
        }

        private void ShowHelpTopic()
        {
            ISite componentSite = ((IComponent)(_designer.UnderlyingControl)).Site;
            Debug.Assert(componentSite != null, "Expected the runtime control to be sited.");
 
            IHelpService helpService = (IHelpService)componentSite.GetService(typeof(IHelpService));
            if (helpService != null) 
            {
                helpService.ShowHelpFromKeyword("net.Mobile.PropertyOverridesDialog");
            }
        }

        private void SetDirty(bool dirty)
        {
            if (dirty)
            {
                if (false == _isDirty)
                {
                    _isDirty = true;
                    _cmdCancel.Text = SR.GetString(SR.GenericDialog_CancelBtnCaption);
                }
            }
            else
            {
                if (true == _isDirty)
                {
                    _isDirty = false;
                    _cmdCancel.Text = SR.GetString(SR.GenericDialog_CloseBtnCaption);
                }
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //  Begin Event Handling
        ////////////////////////////////////////////////////////////////////////

        private void OnEditFilters(Object sender, EventArgs e)
        {
            ISite componentSite = ((IComponent)(_designer.UnderlyingControl)).Site;
            Debug.Assert(componentSite != null, "Expected the runtime control to be sited.");

            IComponentChangeService changeService =
                (IComponentChangeService)componentSite.GetService(typeof(IComponentChangeService));

            IMobileWebFormServices wfServices = 
                (IMobileWebFormServices)componentSite.GetService(typeof(IMobileWebFormServices));

            DialogResult result = DialogResult.Cancel;
            try
            {
                AppliedDeviceFiltersDialog dialog = new
                    AppliedDeviceFiltersDialog(
                    this,
                    _mergingContext
                    );

                result = dialog.ShowDialog();
            }
            finally
            {
                if (result != DialogResult.Cancel)
                {
                    SaveChoices();
                    SetDirty(false);

                    if (changeService != null)
                    {
                        changeService.OnComponentChanged(_designer.UnderlyingControl, null, null, null);
                    }
                }
            }
        }
        
        private void OnFilterSelected(Object sender, EventArgs e)
        {
            UpdateUI();
        }

        private void OnOK(Object sender, EventArgs e)
        {
            SaveChoices();
            Close();
            DialogResult = DialogResult.OK;
        }
        
        private void OnCancel(Object sender, EventArgs e)
        {
            Close();
            DialogResult = DialogResult.Cancel;
        }
        
        private void OnHelp(Object sender, EventArgs e)
        {
            ShowHelpTopic();
        }
        
        private void OnHelpRequested(Object sender, HelpEventArgs e)
        {
            ShowHelpTopic();
            e.Handled = true;
        }

        private void OnPropertyValueChanged(Object sender, 
                                            PropertyValueChangedEventArgs e)
        {
            SetDirty(true);
        }

        ////////////////////////////////////////////////////////////////////////
        //  End Event Handling
        ////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////
        //  Begin IRefreshableComponentEditor Implementation
        ////////////////////////////////////////////////////////////////////////

        bool IRefreshableDeviceSpecificEditor.RequestRefresh()
        {
            return true;
        }
        
        void IRefreshableDeviceSpecificEditor.Refresh(
            String deviceSpecificID,
            DeviceSpecific deviceSpecific
        ) {
            if (_currentDeviceSpecificID != null)
            {
                CacheCurrentState();
            }
            _cbChoices.Items.Clear();

            if (!RestoreState(deviceSpecificID))
            {
                LoadChoices(deviceSpecific);
                if(!ValidateLoadedChoices())
                {
                    _designer.RefreshHeader(
                        MobileControlDesigner.MergingContextProperties
                    );
                }
            }
            UpdateUI();
        }

        void IRefreshableDeviceSpecificEditor.UnderlyingObjectsChanged()
        {
            SaveChoices();
            SetDirty(false);
        }

        private bool InExternalCacheEditMode
        {
            get
            {
                return _cacheBuffer != null;
            }
        }
        
        private IDictionary _cacheBuffer = null;
        
        void IRefreshableDeviceSpecificEditor.BeginExternalDeviceSpecificEdit()
        {
            Debug.Assert(!InExternalCacheEditMode,
                "Call to BeginExternalDeviceSpecificEdit() while already in external "
                + "cache edit mode.");
            if(_currentDeviceSpecificID != null)
            {
                CacheCurrentState();
                _currentDeviceSpecificID = null;
            }
            _cacheBuffer = new HybridDictionary(
                true /* make case-insensitive*/ );
            foreach(DictionaryEntry entry in _cachedDeviceSpecifics)
            {
                _cacheBuffer.Add(entry.Key, entry.Value);
            }
        }
        
        void IRefreshableDeviceSpecificEditor.EndExternalDeviceSpecificEdit(
            bool commitChanges)
        {
            Debug.Assert(InExternalCacheEditMode,
                "Call to EndExternalDeviceSpecificEdit() while not in external "
                + "cache edit mode.");
            if(commitChanges)
            {
                _cachedDeviceSpecifics = _cacheBuffer;
            }
            _cacheBuffer = null;
        }
        
        void IRefreshableDeviceSpecificEditor.DeviceSpecificRenamed(
            String oldDeviceSpecificID, String newDeviceSpecificID)
        {
            Debug.Assert(InExternalCacheEditMode,
                "Call to DeviceSpecificRenamed() while not in external "
                + "cache edit mode.");
            Object value = _cacheBuffer[oldDeviceSpecificID];
            if(value != null)
            {
                _cacheBuffer.Remove(oldDeviceSpecificID);
                _cacheBuffer.Add(newDeviceSpecificID, value);
            }
        }
        
        void IRefreshableDeviceSpecificEditor.DeviceSpecificDeleted(
            String deviceSpecificID)
        {
            Debug.Assert(InExternalCacheEditMode,
                "Call to DeviceSpecificDeleted() while not in external "
                + "cache edit mode.");
            _cacheBuffer.Remove(deviceSpecificID);
        }

        ////////////////////////////////////////////////////////////////////////
        //  End IRefreshableComponentEditor Implementation
        ////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////
        //  Begin IDeviceSpecificDesigner Implementation
        ////////////////////////////////////////////////////////////////////////

        void IDeviceSpecificDesigner.SetDeviceSpecificEditor
            (IRefreshableDeviceSpecificEditor editor)
        {
        }

        String IDeviceSpecificDesigner.CurrentDeviceSpecificID
        {
            get
            {
                return _currentDeviceSpecificID;
            }
        }

        System.Windows.Forms.Control IDeviceSpecificDesigner.Header
        {
            get
            {
                return _header;
            }
        }

        System.Web.UI.Control IDeviceSpecificDesigner.UnderlyingControl
        {
            get
            {
                return _designer.UnderlyingControl;
            }
        }

        Object IDeviceSpecificDesigner.UnderlyingObject
        {
            get
            {
                return _designer.UnderlyingObject;
            }
        }

        bool IDeviceSpecificDesigner.GetDeviceSpecific(String deviceSpecificParentID, out DeviceSpecific ds)
        {
            Debug.Assert(deviceSpecificParentID == _currentDeviceSpecificID);

            ds = null;
            if (_cbChoices.Items.Count > 0)
            {
                ds = new DeviceSpecific();
                foreach (ChoiceTreeNode choiceNode in _cbChoices.Items)
                {
                    DeviceSpecificChoice choice = choiceNode.Choice.RuntimeChoice;
                    ds.Choices.Add(choice);
                }
            }

            return true;
        }

        void IDeviceSpecificDesigner.SetDeviceSpecific(String deviceSpecificParentID, DeviceSpecific ds)
        {
            Debug.Assert(_currentDeviceSpecificID != null);
            _cbChoices.Items.Clear();
            LoadChoices(ds);
            UpdateUI();
        }

        void IDeviceSpecificDesigner.InitHeader(int mergingContext)
        {
            HeaderPanel panel = new HeaderPanel();
            HeaderLabel lblDescription = new HeaderLabel();

            lblDescription.TabIndex = 0;
            lblDescription.Text = SR.GetString(SR.MobileControl_SettingGenericChoiceDescription);
            
            panel.Height = lblDescription.Height;
            panel.Width = lblDescription.Width;
            panel.Controls.Add(lblDescription);
            _header = panel;
        }

        void IDeviceSpecificDesigner.RefreshHeader(int mergingContext)
        {
        }

        void IDeviceSpecificDesigner.UseCurrentDeviceSpecificID()
        {
        }

        /////////////////////////////////////////////////////////////////////////
        //  End IDeviceSpecificDesigner Implementation
        /////////////////////////////////////////////////////////////////////////
    }
    
    ////////////////////////////////////////////////////////////////////////////
    //  Begin Internal Class
    ////////////////////////////////////////////////////////////////////////////

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class ChoicePropertyFilter :
        ICustomTypeDescriptor, IDeviceSpecificChoiceDesigner, IComponent
    {
        private DeviceSpecificChoice _choice;
        private Object _copyOfOriginalObject;
        private Object _underlyingObject;
        private IDeviceSpecificDesigner _designer;
        private Hashtable _specialProp_buffer = new Hashtable();
        private EventHandler _specialProp_delegate = null;
        private ISite _site = null;
        private EventHandlerList _events;
        private static readonly Object _eventDisposed = new Object();
        private static readonly String _alternateUrl = "AlternateUrl";
        private static readonly String _navigateUrl = "NavigateUrl";

        internal ChoicePropertyFilter(
            DeviceSpecificChoice choice,
            IDeviceSpecificDesigner designer,
            ISite site
        ) {
            _events = new EventHandlerList();
            _choice = choice;
            _site = site;
            _designer = designer;

            CreateLocalCopiesOfObjects();
        }

        private void CreateLocalCopiesOfObjects()
        {
            // We make this copy of the original to remove the object from
            // the inheritance chain.
            _copyOfOriginalObject = CloneTarget(_designer.UnderlyingObject);
            _underlyingObject = CloneTarget(_designer.UnderlyingObject);
            
            // We need to pop up editors when certain property values change    
            RegisterForPropertyChangeEvents();
            
            // Copy properties set on DeviceSpecificChoice
            ApplyChoiceToRuntimeControl();
        }

        internal void Refresh()
        {
            ApplyChangesToRuntimeChoice();
            CreateLocalCopiesOfObjects();
        }

        private void RegisterForPropertyChangeEvents()
        {
            foreach(PropertyDescriptor property in TypeDescriptor.GetProperties(
                _underlyingObject.GetType()
            )) {
                if(property.Converter is NavigateUrlConverter &&
                   (property.Name == _navigateUrl ||
                    property.Name == _alternateUrl))
                {
                    // REVIEW: Could this be done more generically?  Based
                    //         on the property type, perhaps?
                    if (property.Name == _navigateUrl)
                    {
                        _specialProp_delegate = new EventHandler(OnNavigateUrlChanged);
                    }
                    else
                    {
                        _specialProp_delegate = new EventHandler(OnAlternateUrlChanged);
                    }
                    _specialProp_buffer[property.Name] = property.GetValue(_underlyingObject);
                    property.AddValueChanged(
                        _underlyingObject,
                        _specialProp_delegate
                    );
                }
            }
        }
        
        private Object CloneTarget(Object target)
        {
            Object clone = Activator.CreateInstance(
                target.GetType()
            );
            // We need to copy the Site over to the new object incase setting
            // properties has a side effect that requires the component model
            // to be intact.  (e.g., Launching UrlPicker for NavigateUrl).
            if(clone is IComponent)
            {
                ((IComponent)clone).Site = ((IComponent)target).Site;
            }
            // We also need to copy the Page over in case runtime properties
            // try to access the page.
            if(clone is System.Web.UI.Control)
            {
                ((Control)clone).Page = ((Control)target).Page;
            }
            CopyOverridableProperties(target, clone);
            return clone;
        }
        
        private void CopyStyleProperties(Style source, Style dest)
        {
            // We copy the StateBag to duplicate the style properties without
            // walking the inheritance.
            dest.State.Clear();
            foreach(String key in source.State.Keys)
            {
                dest.State[key] = source.State[key];
            }
        }

        private void CopyOverridableProperties(Object source, Object dest)
        {
            MobileControl destControl = null;
           
            // HACK: To avoid copying expandable property FontInfo.  We will
            //       need to required that expandable properties implement
            //       ICloneable for our designer extensibility story.
            if(source is Style)
            {
                CopyStyleProperties((Style)source, (Style)dest);
                return;
            }
            
            if(source is MobileControl)
            {
                // If the control is a MobileControl, we copy the style's
                // StateBag to get the non-inherited proprety values.
                destControl = (MobileControl) dest;
                MobileControl sourceControl = (MobileControl) source;
                CopyStyleProperties(sourceControl.Style, destControl.Style);
            }

            // Copy remaining properties not contained in the style (or
            // all properties if not a mobile control.)
            PropertyDescriptorCollection properties = 
                TypeDescriptor.GetProperties(dest.GetType());
            foreach(PropertyDescriptor property in properties)
            {
                if(IsDeviceOverridable(property)
                    && (destControl == null
                    || !PropertyExistsInStyle(property, destControl.Style)))
                {
                    CopyProperty(property, source, dest);
                }
            }
        }

        private void CopyProperty(PropertyDescriptor property,
            Object source,
            Object dest)
        {
            Object value = property.GetValue(source);

            if(property.Converter is ExpandableObjectConverter)
            {
                if(value is ICloneable)
                {
                    value = ((ICloneable)value).Clone();
                }
                else
                {
                    throw new Exception(
                        SR.GetString(
                            SR.PropertyOverridesDialog_NotICloneable,
                            property.Name,
                            property.PropertyType.FullName
                        )
                    );
                }
            }
            property.SetValue(dest, value);
        }
        
        private bool PropertyExistsInStyle(
            PropertyDescriptor property, Style style)
        {
            return style.GetType().GetProperty(property.Name) != null;
        }
        
        public event EventHandler Disposed 
        {
            add 
            {
                _events.AddHandler(_eventDisposed, value);
            }
            remove 
            {
                _events.RemoveHandler(_eventDisposed, value);
            }
        }

        public ISite Site
        {
            get
            {
                Debug.Assert(_site != null);
                return _site;
            }

            set
            {
                _site = value;
            }
        }

        public void Dispose()
        {
            if (_events != null) 
            {
                EventHandler handler = (EventHandler)_events[_eventDisposed];
                if (handler != null) handler(this, EventArgs.Empty);
            }
        }

        private void OnNavigateUrlChanged(Object sender, EventArgs e)
        {
            OnSpecialPropertyChanged(sender, true);
        }

        private void OnAlternateUrlChanged(Object sender, EventArgs e)
        {
            OnSpecialPropertyChanged(sender, false);
        }

        // REVIEW: This function could be renamed OnUrlChanging and the
        //         constant string indicating which property to read/write
        //         from could be passed in rather than the bool.
        private void OnSpecialPropertyChanged(Object sender, bool navigateUrl)
        {
            IComponent component = (IComponent) sender;
            PropertyDescriptor property
                = TypeDescriptor.GetProperties(component)[navigateUrl ? _navigateUrl : _alternateUrl];
            String newValue = (String) property.GetValue(component);
            String oldValue = (String) _specialProp_buffer[navigateUrl ? _navigateUrl : _alternateUrl];
            newValue = NavigateUrlConverter.GetUrl(
                component,
                newValue,
                oldValue
            );
            property.RemoveValueChanged(
                _underlyingObject,
                _specialProp_delegate
            );
            property.SetValue(component, newValue);
            property.AddValueChanged(
                _underlyingObject,
                _specialProp_delegate
            );
        }

        private static bool IsDeviceOverridable(PropertyDescriptor property)
        {
            // REVIEW: This may be overqualified...
            return (
                property.IsBrowsable
                && ((!property.IsReadOnly)
                    || (property.Converter is ExpandableObjectConverter))
                && !property.SerializationVisibility.Equals(
                     DesignerSerializationVisibility.Hidden)
                && property.Name != "ID"
            );
        }

        private void ApplyChoiceToRuntimeControl()
        {
            PropertyDescriptorCollection properties =
                TypeDescriptor.GetProperties(
                    _underlyingObject.GetType());

            foreach(PropertyDescriptor property in properties)
            {
                if(IsDeviceOverridable(property))
                {
                    ApplyChoiceToRuntimeControl_helper(
                        property,
                        _underlyingObject,
                        ""
                    );
                }
            }
        }

        private void ApplyChoiceToRuntimeControl_helper(
            PropertyDescriptor property,
            Object target,
            String prefix
        ) {
            String propertyName = prefix + property.Name;
            String value = ((IAttributeAccessor)_choice).GetAttribute(propertyName) as String;

            if(property.Converter is ExpandableObjectConverter)
            {
                PropertyDescriptorCollection properties =
                    TypeDescriptor.GetProperties(
                        property.PropertyType
                    );
                foreach(PropertyDescriptor embeddedProperty in properties)
                {
                    if(IsDeviceOverridable(embeddedProperty))
                    {
                        ApplyChoiceToRuntimeControl_helper(
                            embeddedProperty,
                            property.GetValue(target),
                            propertyName + "-"
                        );
                    }
                }
                return;
            }
            
            if(value != null)
            {
                try
                {
                    property.SetValue(
                        target,
                        property.Converter.ConvertFromString(value)
                    );
                }
                catch
                {
                    GenericUI.ShowWarningMessage(
                        SR.GetString(SR.PropertyOverridesDialog_Title),
                        SR.GetString(
                            SR.PropertyOverridesDialog_InvalidPropertyValue,
                            value,
                            propertyName
                        )
                    );
                }
            }
        }

        private void ApplyChangesToRuntimeChoice()
        {
            PropertyDescriptorCollection properties =
                TypeDescriptor.GetProperties(
                    _underlyingObject.GetType()
                );

            foreach(PropertyDescriptor property in properties)
            {
                if (IsDeviceOverridable(property))
                {
                    ApplyChangesToRuntimeChoice_helper(
                        property,
                        _copyOfOriginalObject,
                        _underlyingObject,
                        "");
                }
            }
        }
        
        private void ApplyChangesToRuntimeChoice_helper(
            PropertyDescriptor property,
            Object sourceTarget,
            Object destTarget,
            String prefix
        ) {
            Object oldValue = property.GetValue(sourceTarget);
            Object newValue = property.GetValue(destTarget);

            String propertyName = prefix + property.Name;
         
            if(property.Converter is ExpandableObjectConverter)
            {
                PropertyDescriptorCollection properties =
                    TypeDescriptor.GetProperties(
                        newValue.GetType()
                    );
                foreach(PropertyDescriptor embeddedProperty in properties)
                {
                    if(IsDeviceOverridable(embeddedProperty))
                    {
                        ApplyChangesToRuntimeChoice_helper(
                            embeddedProperty,
                            oldValue,
                            newValue,
                            propertyName + "-"
                        );
                    }
                }
            }
            else if(IsDeviceOverridable(property))
            {
                IAttributeAccessor overrides = (IAttributeAccessor)_choice;
                String oldValueString =
                    property.Converter.ConvertToInvariantString(
                        oldValue
                    );
                String newValueString =
                    property.Converter.ConvertToInvariantString(
                        newValue
                    );                
                if(newValueString != oldValueString)
                {
                    overrides.SetAttribute(propertyName, newValueString);
                }
                else
                {
                    // Clear any previous values we might have loaded
                    overrides.SetAttribute(propertyName, null);
                }
            }
        }

        internal DeviceSpecificChoice RuntimeChoice
        {
            get
            {
                ApplyChangesToRuntimeChoice();
                return _choice;
            }
        }

        internal IDeviceSpecificDesigner Designer
        {
            get
            {
                return _designer;
            }
        }

        internal Object Owner
        {
            get
            {
                return _underlyingObject;
            }
        }

        private PropertyDescriptorCollection PreFilterProperties(
            PropertyDescriptorCollection originalProperties
        ) {
            PropertyDescriptorCollection newProperties =
                new PropertyDescriptorCollection(
                    new PropertyDescriptor[] {}
                );
            
            foreach(PropertyDescriptor property in originalProperties)
            {
                if (IsDeviceOverridable(property))
                {
                    newProperties.Add(property);
                }
            }

            PropertyDescriptor[] arpd = new PropertyDescriptor[newProperties.Count];
            for(int i = 0; i < newProperties.Count; i++)
            {
                arpd[i] = newProperties[i];
            }
            newProperties = new PropertyDescriptorCollection(arpd);

            return newProperties;
        }

        ////////////////////////////////////////////////////////////////////
        //  Begin ICustomTypeDescriptor Implementation
        ////////////////////////////////////////////////////////////////////

        System.ComponentModel.AttributeCollection ICustomTypeDescriptor.GetAttributes()
        {
            return TypeDescriptor.GetAttributes(this.GetType());
        }

        String ICustomTypeDescriptor.GetClassName()
        {
            return TypeDescriptor.GetClassName(this.GetType());
        }

        String ICustomTypeDescriptor.GetComponentName()
        {
            return TypeDescriptor.GetComponentName(this.GetType());
        }

        TypeConverter ICustomTypeDescriptor.GetConverter()
        {
            return TypeDescriptor.GetConverter(this.GetType());
        }

        EventDescriptor ICustomTypeDescriptor.GetDefaultEvent()
        {
            return TypeDescriptor.GetDefaultEvent(this.GetType());
        }

        PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty()
        {
            return TypeDescriptor.GetDefaultProperty(this.GetType());
        }

        Object ICustomTypeDescriptor.GetEditor(Type editorBaseType)
        {
            return TypeDescriptor.GetEditor(this.GetType(), editorBaseType);
        }

        EventDescriptorCollection ICustomTypeDescriptor.GetEvents()
        {
            return TypeDescriptor.GetEvents(this.GetType());
        }

        EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes)
        {
            return TypeDescriptor.GetEvents(this.GetType(), attributes);
        }

        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties()
        {
            PropertyDescriptorCollection collection =
                TypeDescriptor.GetProperties(
                    _underlyingObject.GetType()
                );
            collection = PreFilterProperties(collection);
            return collection;
        }

        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes)
        {
            PropertyDescriptorCollection collection =
                TypeDescriptor.GetProperties(
                    _underlyingObject.GetType(),
                    attributes
                );
            collection = PreFilterProperties(collection);
            return collection;
        }

        Object ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor property)
        {
            return _underlyingObject;
        }

        ////////////////////////////////////////////////////////////////////////
        //  End ICustomTypeDescriptor Implementation
        ////////////////////////////////////////////////////////////////////////

        ///////////////////////////////////////////////////////////////////////
        //  Begin IDeviceSpecificChoiceDesigner Implementation
        ///////////////////////////////////////////////////////////////////////

        Object IDeviceSpecificChoiceDesigner.UnderlyingObject
        {
            get
            {
                return _designer.UnderlyingObject;
            }
        }

        Control IDeviceSpecificChoiceDesigner.UnderlyingControl
        {
            get
            {
                return _designer.UnderlyingControl;
            }
        }
        
        ///////////////////////////////////////////////////////////////////////
        //  End IDeviceSpecificChoiceDesigner Implementation
        ///////////////////////////////////////////////////////////////////////
    }

    ////////////////////////////////////////////////////////////////////////////
    //  End Internal Class
    ////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    //  Begin Internal Class
    /////////////////////////////////////////////////////////////////////////

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class PropertyOverridesCachedState : DeviceSpecificDialogCachedState
    {
        private ArrayList _cachedComboBox = null;
        
        internal PropertyOverridesCachedState(
            ComboBox comboBox
        ) {
            _cachedComboBox = new ArrayList();
            foreach(Object o in comboBox.Items)
            {
                _cachedComboBox.Add(o);
            }
        }
        
        internal void Restore(
            ComboBox comboBox
        ) {
            Object selectedItem = comboBox.SelectedItem;
            comboBox.Items.Clear();
            comboBox.Items.AddRange(_cachedComboBox.ToArray());
            if(selectedItem != null)
            {
                int index = comboBox.Items.IndexOf(selectedItem);
                if(index >= 0)
                {
                    comboBox.SelectedItem = comboBox.Items[index];
                }
            }
        }

        internal bool FilterExistsInComboBox(DeviceFilterNode filter)
        {
            foreach(DeviceFilterNode availableFilter in _cachedComboBox)
            {
                if(availableFilter.Name == filter.Name)
                {
                    return true;
                }
            }
            return false;
        }

        internal void SaveChoicesFromComboBox(
            IDeviceSpecificDesigner designer,
            String deviceSpecificID
        ) {
            SaveChoices(designer, deviceSpecificID, _cachedComboBox);
        }

        internal ArrayList Choices
        {
            get
            {
                return _cachedComboBox;
            }
        }
    }
    
    /////////////////////////////////////////////////////////////////////////
    //  End Internal Class
    /////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////
    //  Begin Internal Class
    /////////////////////////////////////////////////////////////////////////

    internal class InvalidChoiceException : ApplicationException
    {
        internal InvalidChoiceException(String message) : base(message)
        {
        }
    }
    
    /////////////////////////////////////////////////////////////////////////
    //  End Internal Class
    /////////////////////////////////////////////////////////////////////////
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\objectlistgeneralpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListGeneralPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Globalization;
    using System.CodeDom;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Drawing;
    using System.Web.UI;
    using System.Web.UI.Design.MobileControls.Util;
    using System.Web.UI.MobileControls;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    using Control = System.Windows.Forms.Control;
    using Label = System.Windows.Forms.Label;
    using CheckBox = System.Windows.Forms.CheckBox;
    using TextBox = System.Windows.Forms.TextBox;
    using ComboBox = System.Windows.Forms.ComboBox;
    using DataBinding = System.Web.UI.DataBinding;

    /// <summary>
    ///   The General page for the ObjectList control.
    /// </summary>
    /// <internalonly/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class ObjectListGeneralPage : MobileComponentEditorPage
    {
        private UnsettableComboBox _cmbDataSource;
        private UnsettableComboBox _cmbDataMember;
        private UnsettableComboBox _cmbLabelField;
        private TextBox _txtBackCommandText;
        private TextBox _txtDetailsCommandText;
        private TextBox _txtMoreText;
        private TextBox _txtItemCount;
        private TextBox _txtItemsPerPage;
        private InterchangeableLists _xLists;

        private DataSourceItem _currentDataSource;
        private bool _dataSourceDirty;

        protected override String HelpKeyword 
        {
            get 
            {
                return "net.Mobile.ObjectListProperties.General";
            }
        }

        private void InitForm()
        {
            this._cmbDataSource     = new UnsettableComboBox();
            this._cmbLabelField     = new UnsettableComboBox();
            this._cmbDataMember     = new UnsettableComboBox();
            this._xLists            = new InterchangeableLists();

            GroupLabel grplblData = new GroupLabel();
            grplblData.SetBounds(4, 4, 392, 16);
            grplblData.Text = SR.GetString(SR.ObjectListGeneralPage_DataGroupLabel);
            grplblData.TabIndex = 0;
            grplblData.TabStop = false;

            Label lblDataSource = new Label();
            lblDataSource.SetBounds(12, 24, 174, 16);
            lblDataSource.Text = SR.GetString(SR.ObjectListGeneralPage_DataSourceCaption);
            lblDataSource.TabStop = false;
            lblDataSource.TabIndex = 1;

            _cmbDataSource.SetBounds(12, 40, 154, 64);
            _cmbDataSource.DropDownStyle = ComboBoxStyle.DropDownList;
            _cmbDataSource.Sorted = true;
            _cmbDataSource.TabIndex = 2;
            _cmbDataSource.NotSetText = SR.GetString(SR.ObjectListGeneralPage_UnboundComboEntry);
            _cmbDataSource.SelectedIndexChanged += new EventHandler(this.OnSelChangedDataSource);

            Label lblDataMember = new Label();
            lblDataMember.SetBounds(206, 24, 174, 16);
            lblDataMember.Text = SR.GetString(SR.ObjectListGeneralPage_DataMemberCaption);
            lblDataMember.TabStop = false;
            lblDataMember.TabIndex = 3;

            _cmbDataMember.SetBounds(206, 40, 154, 64);
            _cmbDataMember.DropDownStyle = ComboBoxStyle.DropDownList;
            _cmbDataMember.Sorted = true;
            _cmbDataMember.TabIndex = 4;
            _cmbDataMember.NotSetText = SR.GetString(SR.ObjectListGeneralPage_NoneComboEntry);
            _cmbDataMember.SelectedIndexChanged += new EventHandler(this.OnSelChangedDataMember);

            Label lblLabelField = new Label();
            lblLabelField.SetBounds(12, 67, 174, 16);
            lblLabelField.Text = SR.GetString(SR.ObjectListGeneralPage_LabelFieldCaption);
            lblLabelField.TabStop = false;
            lblLabelField.TabIndex = 5;

            _cmbLabelField.SetBounds(12, 83, 154, 64);
            _cmbLabelField.DropDownStyle = ComboBoxStyle.DropDownList;
            _cmbLabelField.Sorted = true;
            _cmbLabelField.TabIndex = 6;
            _cmbLabelField.NotSetText = SR.GetString(SR.ObjectListGeneralPage_NoneComboEntry);
            _cmbLabelField.SelectedIndexChanged += new EventHandler(this.OnSetPageDirty);
            _cmbLabelField.TextChanged += new EventHandler(this.OnSetPageDirty);

            GroupLabel grplblTableFields = new GroupLabel();
            grplblTableFields.SetBounds(4, 118, 392, 16);
            grplblTableFields.Text = SR.GetString(SR.ObjectListGeneralPage_TableFieldsGroupLabel);
            grplblTableFields.TabIndex = 9;
            grplblTableFields.TabStop = false;

            _xLists.Location = new System.Drawing.Point(4, 130);
            _xLists.TabIndex = 10;
            _xLists.OnComponentChanged += new EventHandler(this.OnSetPageDirty);
            _xLists.TabStop = true;
            _xLists.SetTitles(SR.GetString(SR.ObjectListGeneralPage_TableFieldsAvailableListLabel),
                              SR.GetString(SR.ObjectListGeneralPage_TableFieldsSelectedListLabel));
            
            GroupLabel grplblAppearance = new GroupLabel();
            grplblAppearance.SetBounds(4, 257, 392, 16);
            grplblAppearance.Text = SR.GetString(SR.ObjectListGeneralPage_AppearanceGroupLabel);
            grplblAppearance.TabIndex = 11;
            grplblAppearance.TabStop = false;

            Label lblBackCommandText = new Label();
            lblBackCommandText.SetBounds(12, 277, 174, 16);
            lblBackCommandText.Text = SR.GetString(SR.ObjectListGeneralPage_BackCommandTextCaption);
            lblBackCommandText.TabStop = false;
            lblBackCommandText.TabIndex = 12;

            _txtBackCommandText = new TextBox();
            _txtBackCommandText.SetBounds(12, 293, 154, 20);
            _txtBackCommandText.TabIndex = 13;
            _txtBackCommandText.TextChanged += new EventHandler(this.OnSetPageDirty);

            Label lblDetailsCommandText = new Label();
            lblDetailsCommandText.SetBounds(206, 277, 174, 16);
            lblDetailsCommandText.Text = SR.GetString(SR.ObjectListGeneralPage_DetailsCommandTextCaption);
            lblDetailsCommandText.TabStop = false;
            lblDetailsCommandText.TabIndex = 14;

            _txtDetailsCommandText = new TextBox();
            _txtDetailsCommandText.SetBounds(206, 293, 154, 20);
            _txtDetailsCommandText.TabIndex = 15;
            _txtDetailsCommandText.TextChanged += new EventHandler(this.OnSetPageDirty);

            Label lblMoreText = new Label();
            lblMoreText.SetBounds(12, 320, 174, 16);
            lblMoreText.Text = SR.GetString(SR.ObjectListGeneralPage_MoreTextCaption);
            lblMoreText.TabStop = false;
            lblMoreText.TabIndex = 16;

            _txtMoreText = new TextBox();
            _txtMoreText.SetBounds(12, 336, 154, 20);
            _txtMoreText.TabIndex = 17;
            _txtMoreText.TextChanged += new EventHandler(this.OnSetPageDirty);

            GroupLabel pagingGroup = new GroupLabel();
            Label itemCountLabel = new Label();
            _txtItemCount = new TextBox();

            Label itemsPerPageLabel = new Label();
            _txtItemsPerPage = new TextBox();

            pagingGroup.SetBounds(4, 371, 392, 16);
            pagingGroup.Text = SR.GetString(SR.ListGeneralPage_PagingGroupLabel);
            pagingGroup.TabIndex = 18;
            pagingGroup.TabStop = false;

            itemCountLabel.SetBounds(12, 391, 174, 16);
            itemCountLabel.Text = SR.GetString(SR.ListGeneralPage_ItemCountCaption);
            itemCountLabel.TabStop = false;
            itemCountLabel.TabIndex = 19;

            _txtItemCount.SetBounds(12, 407, 154, 20);
            _txtItemCount.TextChanged += new EventHandler(this.OnSetPageDirty);
            _txtItemCount.KeyPress += new KeyPressEventHandler(this.OnKeyPressNumberTextBox);
            _txtItemCount.TabIndex = 20;

            itemsPerPageLabel.SetBounds(206, 391, 174, 16);
            itemsPerPageLabel.Text = SR.GetString(SR.ListGeneralPage_ItemsPerPageCaption);
            itemsPerPageLabel.TabStop = false;
            itemsPerPageLabel.TabIndex = 21;

            _txtItemsPerPage.SetBounds(206, 407, 154, 20);
            _txtItemsPerPage.TextChanged += new EventHandler(this.OnSetPageDirty);
            _txtItemsPerPage.KeyPress += new KeyPressEventHandler(this.OnKeyPressNumberTextBox);
            _txtItemsPerPage.TabIndex = 22;

            this.Text = SR.GetString(SR.ObjectListGeneralPage_Title);
            this.Size = new Size(402, 436);
            this.CommitOnDeactivate = true;
            this.Icon = new Icon(
                typeof(System.Web.UI.Design.MobileControls.MobileControlDesigner),
                "General.ico"
            );

            this.Controls.AddRange(new Control[]
                           {
                                grplblData,
                                lblDataSource,
                                _cmbDataSource,
                                lblDataMember,
                                _cmbDataMember,
                                lblLabelField,
                                _cmbLabelField,
                                grplblTableFields,
                                _xLists,
                                grplblAppearance,
                                lblBackCommandText,
                                _txtBackCommandText,
                                lblDetailsCommandText,
                                _txtDetailsCommandText,
                                lblMoreText,
                                _txtMoreText,
                                pagingGroup,
                                itemCountLabel,
                                _txtItemCount,
                                itemsPerPageLabel,
                                _txtItemsPerPage
                           });
        }

        private void InitPage() 
        {
            _cmbDataSource.SelectedIndex = -1;
            _cmbDataSource.Items.Clear();
            _currentDataSource = null;
            _cmbDataMember.SelectedIndex = -1;
            _cmbDataMember.Items.Clear();
            _cmbLabelField.SelectedIndex = -1;
            _cmbLabelField.Items.Clear();
            _xLists.Clear();
            _dataSourceDirty = false;
        }

        bool IsBindableType(Type type)
        {
            return(type.IsPrimitive ||
                (type == typeof(String)) ||
                (type == typeof(DateTime)) ||
                (type == typeof(Decimal)));
        }

        /// <summary>
        ///   Loads the component into the page.
        /// </summary>
        protected override void LoadComponent() 
        {
            InitPage();
            ObjectList objectList = (ObjectList)GetBaseControl();
            LoadDataSourceItems();

            if (_cmbDataSource.Items.Count > 0) 
            {
                ObjectListDesigner objectListDesigner = (ObjectListDesigner)GetBaseDesigner();
                String dataSourceValue = objectListDesigner.DataSource;

                if (dataSourceValue != null) 
                {
                    int dataSourcesAvailable = _cmbDataSource.Items.Count;
                    // 0 is for 'NotSet' case.
                    for (int j = 1; j < dataSourcesAvailable; j++) 
                    {
                        DataSourceItem dataSourceItem =
                            (DataSourceItem)_cmbDataSource.Items[j];

                        if (String.Compare(dataSourceItem.Name, dataSourceValue, true, CultureInfo.InvariantCulture) == 0)
                        {
                            _cmbDataSource.SelectedIndex = j;
                            _currentDataSource = dataSourceItem;
                            LoadDataMembers();

                            if (_currentDataSource is ListSourceDataSourceItem) 
                            {
                                String dataMember = objectListDesigner.DataMember;
                                _cmbDataMember.SelectedIndex = _cmbDataMember.FindStringExact(dataMember);

                                if (_cmbDataMember.IsSet()) 
                                {
                                    ((ListSourceDataSourceItem)_currentDataSource).CurrentDataMember = dataMember;
                                }
                            }

                            LoadDataSourceFields();

                            break;
                        }
                    }
                }
            }

            String _labelField = objectList.LabelField;

            if (_labelField.Length != 0) 
            {
                int textFieldIndex = _cmbLabelField.FindStringExact(_labelField);
                _cmbLabelField.SelectedIndex = textFieldIndex;
            }

            _txtItemCount.Text = objectList.ItemCount.ToString();
            _txtItemsPerPage.Text = objectList.ItemsPerPage.ToString();
            _txtBackCommandText.Text = objectList.BackCommandText;
            _txtDetailsCommandText.Text = objectList.DetailsCommandText;
            _txtMoreText.Text = objectList.MoreText;

            UpdateEnabledVisibleState();
        }

        /// <summary>
        /// </summary>
        private void LoadDataMembers() 
        {
            using (new LoadingModeResource(this))
            {
                _cmbDataMember.SelectedIndex = -1;
                _cmbDataMember.Items.Clear();
                _cmbDataMember.EnsureNotSetItem();

                if ((_currentDataSource != null) && (_currentDataSource is ListSourceDataSourceItem)) 
                {
                    String[] dataMembers = ((ListSourceDataSourceItem)_currentDataSource).DataMembers;

                    for (int i = 0; i < dataMembers.Length; i++) 
                    {
                        _cmbDataMember.AddItem(dataMembers[i]);
                    }
                }
            }
        }

        /// <summary>
        /// </summary>
        private void LoadDataSourceFields() 
        {
            using (new LoadingModeResource(this))
            {
                ObjectList objectList = (ObjectList)GetBaseControl();

                _cmbLabelField.SelectedIndex = -1;
                _cmbLabelField.Items.Clear();
                _cmbLabelField.EnsureNotSetItem();
                _xLists.Clear();

                if (_currentDataSource == null)
                {
                    return;
                }

                // Use StringCollection to preserve the order, note the items
                // are case-sensitivie
                StringCollection availableFieldCollection = new StringCollection();

                // Get available fields from custom defined fields
                foreach(ObjectListField customDefinedField in objectList.Fields)
                {
                    _cmbLabelField.AddItem(customDefinedField.Name);
                    availableFieldCollection.Add(customDefinedField.Name);
                }

                // Get available fields from DataSource
                if (objectList.AutoGenerateFields) 
                {
                    PropertyDescriptorCollection fields = _currentDataSource.Fields;

                    if (fields != null) 
                    {
                        IEnumerator fieldEnum = fields.GetEnumerator();
                        while (fieldEnum.MoveNext()) 
                        {
                            PropertyDescriptor fieldDesc = (PropertyDescriptor)fieldEnum.Current;

                            if (IsBindableType(fieldDesc.PropertyType)) 
                            {
                                _cmbLabelField.AddItem(fieldDesc.Name);
                                availableFieldCollection.Add(fieldDesc.Name);
                            }
                        }
                    }
                }

                // Match selected fields from TableFields
                Debug.Assert(objectList.TableFields != null);
                if (objectList.TableFields != String.Empty && !_dataSourceDirty)
                {
                    Char[] separator = new Char[] {';'};
                    String[] tableFields = objectList.TableFields.Split(separator);

                    foreach(String selectedField in tableFields)
                    {
                        for (int i = 0; i < availableFieldCollection.Count; i++)
                        {
                            String availableField = availableFieldCollection[i];
                            if (String.Compare(selectedField, availableField, true, CultureInfo.InvariantCulture) == 0)
                            {
                                _xLists.AddToSelectedList(availableField);
                                availableFieldCollection.RemoveAt(i);
                                break;
                            }
                        }
                    }
                }

                // Add the remaining unselected available fields back to AvailableList
                foreach (String availableField in availableFieldCollection)
                {
                    _xLists.AddToAvailableList(availableField);
                }
                _xLists.Initialize();
            }        
        }

        /// <summary>
        ///   Loads the list of available IEnumerable components
        /// </summary>
        private void LoadDataSourceItems() 
        {
            _cmbDataSource.EnsureNotSetItem();
            ISite thisSite = GetSelectedComponent().Site;

            if (thisSite != null) 
            {
                IContainer container = (IContainer)thisSite.GetService(typeof(IContainer));
                if (container != null) 
                {
                    ComponentCollection allComponents = container.Components;
                    if (allComponents != null) 
                    {
                        foreach (IComponent comp in (IEnumerable)allComponents) 
                        {
                            if ((comp is IEnumerable) || (comp is IListSource)) 
                            {
                                // must have a valid site and a name
                                ISite componentSite = comp.Site;
                                if ((componentSite == null) || (componentSite.Name == null) ||
                                    (componentSite.Name.Length == 0))
                                {
                                    continue;
                                }

                                DataSourceItem dsItem;
                                if (comp is IListSource) 
                                {
                                    // an IListSource
                                    IListSource listSource = (IListSource)comp;
                                    dsItem = new ListSourceDataSourceItem(componentSite.Name, listSource);
                                }
                                else 
                                {
                                    // found an IEnumerable
                                    IEnumerable dataSource = (IEnumerable)comp;
                                    dsItem = new DataSourceItem(componentSite.Name, dataSource);
                                }
                                _cmbDataSource.AddItem(dsItem);
                            }
                        }
                    }
                }
            }
        }

        private void OnSetPageDirty(Object source, EventArgs e) 
        {
            if (IsLoading())
            {
                return;
            }
            SetDirty();
        }

        /// <summary>
        ///   Handles changes in the datamember selection
        /// </summary>
        private void OnSelChangedDataMember(Object source, EventArgs e) 
        {
            if (IsLoading())
            {
                return;
            }

            String newDataMember = null;
            if (_cmbDataMember.IsSet())
            {
                newDataMember = (String)_cmbDataMember.SelectedItem;
            }

            Debug.Assert((_currentDataSource != null) && (_currentDataSource is ListSourceDataSourceItem));
            ListSourceDataSourceItem dsItem = (ListSourceDataSourceItem)_currentDataSource;

            dsItem.CurrentDataMember = newDataMember;

            _dataSourceDirty = true;
            LoadDataSourceFields();
            
            SetDirty();
            UpdateEnabledVisibleState();
        }

        /// <summary>
        ///   Handles changes in the datasource selection.
        /// </summary>
        private void OnSelChangedDataSource(Object source, EventArgs e) 
        {
            if (IsLoading())
            {
                return;
            }

            DataSourceItem newDataSource = null;

            if (_cmbDataSource.IsSet())
            {
                newDataSource = (DataSourceItem)_cmbDataSource.SelectedItem;
            }

            if (newDataSource != null) 
            {
                if (newDataSource.IsSelectable() == false) 
                {
                    using (new LoadingModeResource(this))
                    {
                        if (_currentDataSource == null) 
                        {
                            _cmbDataSource.SelectedIndex = -1;
                        }
                        else 
                        {
                            _cmbDataSource.SelectedItem = _currentDataSource;
                        }
                    }
                    return;
                }
            }

            _currentDataSource = newDataSource;
            if (_currentDataSource is ListSourceDataSourceItem)
            {
                ((ListSourceDataSourceItem)_currentDataSource).CurrentDataMember = null;
            }

            _dataSourceDirty = true;
            LoadDataMembers();
            LoadDataSourceFields();

            SetDirty();
            UpdateEnabledVisibleState();
        }

        private void OnKeyPressNumberTextBox(Object source, KeyPressEventArgs e)
        {
            if (!((e.KeyChar >='0' && e.KeyChar <= '9') ||
                e.KeyChar == 8))
            {
                e.Handled = true;
                SafeNativeMethods.MessageBeep(unchecked((int)0xFFFFFFFF));
            }
        }

        /// <summary>
        ///   Saves the component loaded into the page.
        /// </summary>
        protected override void SaveComponent() 
        {
            ObjectList objectList = (ObjectList)GetBaseControl();
            ObjectListDesigner objectListDesigner = (ObjectListDesigner)GetBaseDesigner();

            String labelField = String.Empty;
            if (_cmbLabelField.IsSet())
            {
                labelField = (String)_cmbLabelField.SelectedItem;
            }
            objectList.LabelField = labelField;

            String tableFields = String.Empty;
            foreach (String field in _xLists.GetSelectedItems())
            {
                tableFields += (field + ";");
            }
            objectList.TableFields = tableFields;

            if (_dataSourceDirty) 
            {
                // save the datasource as a binding on the control
                DataBindingCollection dataBindings = objectListDesigner.DataBindings;

                if (_currentDataSource == null)
                {
                    objectListDesigner.DataSource = String.Empty;
                    objectListDesigner.DataMember = String.Empty;
                }
                else 
                {
                    objectListDesigner.DataSource = _currentDataSource.ToString();

                    if (_cmbDataMember.IsSet()) 
                    {
                        objectListDesigner.DataMember = (String)_cmbDataMember.SelectedItem;
                    }
                    else 
                    {
                        objectListDesigner.DataMember = String.Empty;
                    }
                }

                objectListDesigner.OnDataSourceChanged();
            }

            try
            {
                int itemCount = 0;

                if (_txtItemCount.Text.Length != 0)
                {
                    itemCount = Int32.Parse(_txtItemCount.Text, CultureInfo.InvariantCulture);
                }
                objectList.ItemCount = itemCount;
            }
            catch (Exception)
            {
                _txtItemCount.Text = objectList.ItemCount.ToString();
            }

            try
            {
                int itemsPerPage = 0;

                if (_txtItemsPerPage.Text.Length != 0)
                {
                    itemsPerPage = Int32.Parse(_txtItemsPerPage.Text, CultureInfo.InvariantCulture);
                }
                objectList.ItemsPerPage = itemsPerPage;
            }
            catch (Exception)
            {
                _txtItemsPerPage.Text = objectList.ItemsPerPage.ToString();
            }

            objectList.BackCommandText = _txtBackCommandText.Text;
            objectList.DetailsCommandText = _txtDetailsCommandText.Text;
            objectList.MoreText = _txtMoreText.Text;

            TypeDescriptor.Refresh(objectList);
        }

        /// <summary>
        ///   Sets the component that is to be edited in the page.
        /// </summary>
        public override void SetComponent(IComponent component) 
        {
            base.SetComponent(component);
            InitForm();
        }

        /// <summary>
        /// </summary>
        private void UpdateEnabledVisibleState() 
        {
            bool dataSourceSelected = (_currentDataSource != null);

            _cmbDataMember.Enabled = (dataSourceSelected && (_currentDataSource is ListSourceDataSourceItem));
            _cmbLabelField.Enabled = _xLists.Enabled = dataSourceSelected;
        }

        /// <summary>
        ///   This contains information about a datasource and is used to populate
        ///   the datasource combo. This is used in the General page for a DataList
        ///   and the Data page for a DataGrid.
        /// </summary>
        [
            System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        private class DataSourceItem 
        {
            private IEnumerable _runtimeDataSource;
            private String _dataSourceName;
            private PropertyDescriptorCollection _dataFields;

            internal DataSourceItem(String dataSourceName, IEnumerable runtimeDataSource) 
            {
                Debug.Assert(dataSourceName != null, "invalid name for datasource");

                this._runtimeDataSource = runtimeDataSource;
                this._dataSourceName = dataSourceName;
            }

            internal PropertyDescriptorCollection Fields 
            {
                get 
                {
                    if (_dataFields == null) 
                    {
                        IEnumerable ds = RuntimeDataSource;
                        if (ds != null) 
                        {
                            _dataFields = DesignTimeData.GetDataFields(ds);
                        }
                    }
                    if (_dataFields == null) 
                    {
                        _dataFields = new PropertyDescriptorCollection(null);
                    }
                    return _dataFields;
                }
            }

            internal virtual bool HasDataMembers 
            {
                get 
                {
                    return false;
                }
            }

            internal String Name 
            {
                get 
                {
                    return _dataSourceName;
                }
            }

            protected virtual Object RuntimeComponent 
            {
                get 
                {
                    return _runtimeDataSource;
                }
            }
            
            protected virtual IEnumerable RuntimeDataSource 
            {   
                get 
                {
                    return _runtimeDataSource;
                }
            }

            protected void ClearFields() 
            {
                _dataFields = null;
            }
            
            internal bool IsSelectable() 
            {
                Object runtimeComp = this.RuntimeComponent;
                Debug.Assert(runtimeComp != null);
                
                // the selected datasource must not be private
                MemberAttributes modifiers = 0;
                PropertyDescriptor modifiersProp = TypeDescriptor.GetProperties(runtimeComp)["Modifiers"];
                if (modifiersProp != null) 
                {
                    modifiers = (MemberAttributes)modifiersProp.GetValue(runtimeComp);
                }

                if (modifiers == MemberAttributes.Private)
                {
                    String message = SR.GetString(SR.ObjectListGeneralPage_PrivateDataSourceMessage, _dataSourceName);
                    String caption = SR.GetString(SR.ObjectListGeneralPage_PrivateDataSourceTitle);

                    MessageBox.Show(message, caption, MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                    return false;
                }

                // ok to select
                return true;
            }

            public override String ToString() 
            {
                return this.Name;
            }
        }

        /// <summary>
        /// </summary>
        [
            System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        private class ListSourceDataSourceItem : DataSourceItem 
        {
            private IListSource _runtimeListSource;
            private String _dataFields;
            private String[] _dataMembers;

            internal ListSourceDataSourceItem(String dataSourceName, IListSource runtimeListSource) :
                base(dataSourceName, null) 
            {
                Debug.Assert(runtimeListSource != null);
                this._runtimeListSource = runtimeListSource;
            }

            internal String CurrentDataMember 
            {
                get 
                {
                    return _dataFields;
                }
                set 
                {
                    _dataFields = value;
                    ClearFields();
                }
            }

            internal string[] DataMembers 
            {
                get 
                {
                    if (_dataMembers == null) 
                    {
                        if (HasDataMembers) 
                        {
                            _dataMembers = DesignTimeData.GetDataMembers(_runtimeListSource);
                        }
                        else 
                        {
                            _dataMembers = new string[0];
                        }
                    }
                    return _dataMembers;
                }
            }
            
            internal override bool HasDataMembers 
            {
                get 
                {
                    return _runtimeListSource.ContainsListCollection;
                }
            }

            protected override Object RuntimeComponent 
            {
                get 
                {
                    return _runtimeListSource;
                }
            }

            protected override IEnumerable RuntimeDataSource 
            {
                get 
                {
                    if (HasDataMembers) 
                    {
                        return DesignTimeData.GetDataMember(_runtimeListSource, _dataFields);
                    }
                    else 
                    {
                        return (IEnumerable)_runtimeListSource.GetList();
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\sr.cs ===
//------------------------------------------------------------------------------
// <copyright file="SR.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Web.UI.Design.MobileControls
{
    // This class exists solely to make the class SR available members of this
    // namespace.  It delegates completely to System.Web.Mobile.SR.
    internal class SR : System.Web.Mobile.SR
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\selectionlistcomponenteditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectionListComponentEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.UI.MobileControls;
    using System.Windows.Forms.Design;

    /// <summary>
    ///    <para>
    ///       Provides a component editor for a Mobile SelectionList 
    ///       <see cref='System.Web.UI.MobileControls.SelectionList'/>
    ///       control.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.Web.UI.MobileControls.List'/>
    /// <seealso cref='System.Web.UI.Design.MobileControls.ListDesigner'/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class SelectionListComponentEditor : WindowsFormsComponentEditor
    {
        private int _initialPage;

        // The set of pages used within the List ComponentEditor
        private static Type[] _editorPages = new Type[]
                                             {
                                                 typeof(ListGeneralPage),
                                                 typeof(ListItemsPage)
                                             };

        internal const int IDX_GENERAL = 0;
        internal const int IDX_ITEMS = 1;

        /// <summary>
        ///    <para>
        ///       Initializes a new instance of 
        ///       <see cref='System.Web.UI.Design.MobileControls.SelectionListComponentEditor'/>.
        ///    </para>
        /// </summary>
        public SelectionListComponentEditor()
        {
            _initialPage = IDX_GENERAL;
        }

        /// <summary>
        ///    <para>
        ///       Initializes a new instance of 
        ///       <see cref='System.Web.UI.Design.MobileControls.SelectionListComponentEditor'/>.
        ///    </para>
        /// </summary>
        /// <param name='initialPage'>
        ///    The index of the initial page.
        /// </param>
        public SelectionListComponentEditor(int initialPage)
        {
            this._initialPage = initialPage;
        }

        /// <summary>
        ///    <para>
        ///       Gets the set of all pages in the <see cref='System.Web.UI.MobileControls.List'/>
        ///       .
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       An array consisting of the set of component editor pages.
        ///    </para>
        /// </returns>
        /// <remarks>
        ///    <note type="inheritinfo">
        ///       This method may
        ///       be overridden to change the set of pages to show.
        ///    </note>
        /// </remarks>
        protected override Type[] GetComponentEditorPages()
        {
            return _editorPages;
        }

        /// <summary>
        ///    <para>
        ///       Gets the index of the initial component editor page.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The index of the initial page.
        ///    </para>
        /// </returns>
        protected override int GetInitialComponentEditorPageIndex()
        {
            return _initialPage;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\selectionlistdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectionListDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Web.UI.MobileControls;
    using System.Web.UI.Design.MobileControls.Adapters;

    using DataBinding = System.Web.UI.DataBinding;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class SelectionListDesigner : 
        MobileControlDesigner, IListDesigner, IDataSourceProvider
    {
        private SelectionList           _selectionList;
        private DesignerVerbCollection  _designerVerbs;

        private DataTable               _dummyDataTable;
        private DataTable               _designTimeDataTable;

        private const String _dataSourcePropertyName = "DataSource";
        private const String _dataMemberPropertyName = "DataMember";
        private const String _dataTextFieldPropertyName = "DataTextField";
        private const String _dataValueFieldPropertyName = "DataValueField";
        private static readonly Attribute[] _emptyAttrs = new Attribute[0];

        /// <summary>
        /// </summary>
        public String DataValueField 
        {
            get 
            {
                return _selectionList.DataValueField;
            }
            set
            {
                _selectionList.DataValueField = value;
            }
        }

        /// <summary>
        /// </summary>
        public String DataTextField 
        {
            get 
            {
                return _selectionList.DataTextField;
            }
            set
            {
                _selectionList.DataTextField = value;
            }
        }

        public String DataMember 
        {
            get 
            {
                return _selectionList.DataMember;
            }
            set 
            {
                _selectionList.DataMember = value;
                OnDataSourceChanged();
            }
        }

        public MobileListItemCollection Items
        {
            get
            {
                return _selectionList.Items;
            }
        }

        /// <summary>
        ///    <para>
        ///       Gets or sets the data source property.
        ///    </para>
        /// </summary>
        /// <value>
        ///    <para>
        ///       A string indicating the data source for the designer's control.
        ///    </para>
        /// </value>
        /// <remarks>
        ///    <para>
        ///       Designer implementation of a DataSource property that operates on the
        ///       DataSource property in the control's binding collection.
        ///    </para>
        /// </remarks>
        public String DataSource 
        {
            get 
            {
                DataBinding binding = DataBindings[_dataSourcePropertyName];

                if (binding != null) 
                {
                    return binding.Expression;
                }
                return String.Empty;
            }
            set 
            {
                if ((value == null) || (value.Length == 0)) 
                {
                    DataBindings.Remove(_dataSourcePropertyName);
                }
                else 
                {
                    DataBinding binding = DataBindings[_dataSourcePropertyName];

                    if (binding == null) 
                    {
                        binding = new DataBinding(_dataSourcePropertyName, typeof(IEnumerable), value);
                    }
                    else 
                    {
                        binding.Expression = value;
                    }
                    DataBindings.Add(binding);
                }

                OnDataSourceChanged();
                OnBindingsCollectionChanged(_dataSourcePropertyName);
            }
        }

        /// <summary>
        ///    <para>
        ///       The designer's collection of verbs.
        ///    </para>
        /// </summary>
        /// <value>
        ///    <para>
        ///       An array of type <see cref='DesignerVerb'/> containing the verbs available to the
        ///       designer.
        ///    </para>
        /// </value>
        public override DesignerVerbCollection Verbs 
        {
            get 
            {
                if (null == _designerVerbs)
                {
                    _designerVerbs = base.Verbs;
                    _designerVerbs.Add(new DesignerVerb(SR.GetString(SR.PropertyBuilderVerb),
                        new EventHandler(this.OnPropertyBuilder)));
                }

                return _designerVerbs;
            }
        }

        /// <summary>
        ///    <para>
        ///       Gets sample data matching the schema of the selected data source.
        ///    </para>
        /// </summary>
        /// <param name='minimumRows'>
        ///    The minimum rows of sample data the data source data should contain.
        /// </param>
        /// <param name='dummyDataSource'>
        ///    Whether the data source being returned is a dummy data source.
        /// </param>
        /// <returns>
        ///    <para>
        ///       An IEnumerable containing a live data source for use at
        ///       design time.
        ///    </para>
        /// </returns>
        ///
        protected IEnumerable GetDesignTimeDataSource(
            int minimumRows, out bool dummyDataSource)
        {
            IEnumerable selectedDataSource = GetResolvedSelectedDataSource();
            return GetDesignTimeDataSource(
                selectedDataSource, minimumRows, out dummyDataSource);
        }

        /// <summary>
        ///    <para>
        ///       Gets sample data matching the schema of the selected data source.
        ///    </para>
        /// </summary>
        /// <param name='selectedDataSource'>
        ///    The selected data source to be used as a reference for the shape of the data.
        /// </param>
        /// <param name='minimumRows'>
        ///    The minimum rows of sample data the data source data should contain.
        /// </param>
        /// <param name='dummyDataSource'>
        ///    Whether the data source being returned is a dummy data source.
        /// </param>
        /// <returns>
        ///    <para>
        ///       An IEnumerable containing
        ///       a live data source for use at design time.
        ///    </para>
        /// </returns>
        ///
        protected IEnumerable GetDesignTimeDataSource(
            IEnumerable selectedDataSource, int minimumRows, out bool dummyDataSource)
        {
            DataTable dataTable = _designTimeDataTable;
            dummyDataSource = false;

            // use the datatable corresponding to the selected datasource if possible
            if (dataTable == null) 
            {
                if (selectedDataSource != null) 
                {
                    _designTimeDataTable = 
                        DesignTimeData.CreateSampleDataTable(selectedDataSource);
                    dataTable = _designTimeDataTable;
                }

                if (dataTable == null) 
                {
                    // fallback on a dummy datasource if we can't create a sample datatable
                    if (_dummyDataTable == null) 
                    {
                        _dummyDataTable = DesignTimeData.CreateDummyDataTable();
                    }

                    dataTable = _dummyDataTable;
                    dummyDataSource = true;
                }
            }

            IEnumerable liveDataSource = 
                DesignTimeData.GetDesignTimeDataSource(dataTable, minimumRows);
            return liveDataSource;
        }

        /// <summary>
        ///    <para>
        ///       Gets the HTML to be used for the design-time representation
        ///       of the control.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The design-time HTML.
        ///    </para>
        /// </returns>
        protected override String GetDesignTimeNormalHtml() 
        {
            const int numberOfStaticItems = 5;
            IEnumerable selectedDataSource = null;
            String oldDataTextField = null, oldDataValueField = null;
            bool dummyDataSource = false;

            DesignerTextWriter htmlWriter = new DesignerTextWriter(true);

            MobileListItemCollection items = _selectionList.Items;
            Debug.Assert(items != null, "Items is null in LisControl");

            if (items.Count > 0)
            {
                _selectionList.Adapter.Render(htmlWriter);
            }
            else
            {
                MobileListItem[] oldItems = items.GetAll();
                int sampleRows = numberOfStaticItems;

                // try designtime databinding.
                selectedDataSource = GetResolvedSelectedDataSource();

                IEnumerable designTimeDataSource = 
                    GetDesignTimeDataSource(
                    selectedDataSource,
                    sampleRows,
                    out dummyDataSource);

                // If dummy datasource is applied, change the data fields so that 
                // dummy source will be rendered.
                if (dummyDataSource)
                {
                    oldDataTextField    = _selectionList.DataTextField;
                    oldDataValueField   = _selectionList.DataValueField;
                    _selectionList.DataTextField    = "Column0";
                    _selectionList.DataValueField   = "Column1";
                }

                try
                {
                    _selectionList.DataSource = designTimeDataSource;
                    _selectionList.DataBind();
                    _selectionList.Adapter.Render(htmlWriter);
                }
                finally
                {
                    _selectionList.DataSource = null;
                    _selectionList.Items.SetAll(oldItems);

                    if (dummyDataSource)
                    {
                        _selectionList.DataTextField = oldDataTextField;
                        _selectionList.DataValueField = oldDataValueField;
                    }
                }
            }

            return htmlWriter.ToString();
        }

        public IEnumerable GetResolvedSelectedDataSource() 
        {
            IEnumerable selectedDataSource = null;

            DataBinding binding = DataBindings["DataSource"];

            if (binding != null) 
            {
                selectedDataSource = 
                    DesignTimeData.GetSelectedDataSource(
                    _selectionList,
                    binding.Expression,
                    DataMember);
            }

            return selectedDataSource;
        }

        /// <summary>
        ///    <para>
        ///       Gets the selected data source component from the component's container.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       An IEnumerable with the
        ///       selected data source, or <see langword='null'/> if a data source is not found, or if a data
        ///       source with the same name does not exist.
        ///    </para>
        /// </returns>
        /// <seealso cref='System.Web.UI.Design.IDataSourceProvider'/>
        public Object GetSelectedDataSource() 
        {
            Object selectedDataSource = null;

            DataBinding binding = DataBindings[_dataSourcePropertyName];

            if (binding != null) 
            {
                selectedDataSource = 
                    DesignTimeData.GetSelectedDataSource(_selectionList, binding.Expression);
            }

            return selectedDataSource;
        }

        /// <summary>
        ///    <para>
        ///       Initializes the designer.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element being designed.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component being
        ///       designed.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.SelectionList,
                "SelectionListDesigner.Initialize - Invalid SelectionList Control");

            _selectionList = (SelectionList) component;
            base.Initialize(component);
        }

        /// <summary>
        ///    <para>
        ///       Invokes the property builder beginning with the specified page.
        ///    </para>
        /// </summary>
        /// <param name='initialPage'>
        ///    The page to begin with.
        /// </param>
        protected internal void InvokePropertyBuilder(int initialPage) 
        {
            IComponentChangeService changeService = null;
            bool result = false;

            changeService = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            if (changeService != null) 
            {
                try 
                {
                    changeService.OnComponentChanging(_selectionList, null);
                }
                catch (CheckoutException ex) 
                {
                    if (ex == CheckoutException.Canceled)
                    {
                        return;
                    }
                    throw;
                }
            }

            try 
            {
                SelectionListComponentEditor compEditor = new SelectionListComponentEditor(initialPage);
                result = compEditor.EditComponent(_selectionList);
            }
            finally
            {
                if (changeService != null)
                {
                    changeService.OnComponentChanged(_selectionList, null, null, null);

                    if (IMobileWebFormServices != null)
                    {
                        IMobileWebFormServices.ClearUndoStack();
                    }
                }
            }
        }

        /// <summary>
        ///    <para>
        ///       Represents the method that will handle the component change event.
        ///    </para>
        /// </summary>
        /// <param name='sender'>
        ///    The source of the event.
        /// </param>
        /// <param name=' e'>
        ///    The <see cref='System.ComponentModel.Design.ComponentChangedEventArgs'/> that provides data about the event.
        /// </param>
        public override void OnComponentChanged(Object sender, ComponentChangedEventArgs e) 
        {
            if (e.Member != null)
            {
                if (e.Member.Name.Equals(_dataSourcePropertyName) || 
                    e.Member.Name.Equals(_dataMemberPropertyName))
                {
                    OnDataSourceChanged();
                }
            }

            base.OnComponentChanged(sender, e);
        }

        /// <internalonly/>
        /// <summary>
        ///    <para>
        ///       Raises the DataSourceChanged event.
        ///    </para>
        /// </summary>
        public void OnDataSourceChanged() 
        {
            _designTimeDataTable = null;
        }

        /// <summary>
        ///    <para>
        ///       Represents the method that will handle the property builder event.
        ///    </para>
        /// </summary>
        /// <param name='sender'>
        ///    The source of the event.
        /// </param>
        /// <param name=' e'>
        ///    An EventArgs object that provides data about the event.
        /// </param>
        protected void OnPropertyBuilder(Object sender, EventArgs e) 
        {
            InvokePropertyBuilder(0);
        }

        /// <summary>
        ///    <para>
        ///       Filter the properties to replace the runtime DataSource property
        ///       descriptor with the designer's.
        ///    </para>
        /// </summary>
        /// <param name='properties'>
        ///    The set of properties to filter.
        /// </param>
        /// <seealso cref='IDesignerFilter'/>
        protected override void PreFilterProperties(IDictionary properties) 
        {
            base.PreFilterProperties(properties);

            Type designerType = this.GetType();

            DesignerAdapterUtil.AddAttributesToPropertiesOfDifferentType(
                designerType,
                typeof(String),
                properties,
                _dataSourcePropertyName, 
                new TypeConverterAttribute(typeof(DataSourceConverter)));

            DesignerAdapterUtil.AddAttributesToProperty(
                designerType,
                properties,
                _dataMemberPropertyName, 
                _emptyAttrs);

            DesignerAdapterUtil.AddAttributesToProperty(
                designerType,
                properties,
                _dataTextFieldPropertyName, 
                _emptyAttrs);

            DesignerAdapterUtil.AddAttributesToProperty(
                designerType,
                properties,
                _dataValueFieldPropertyName, 
                _emptyAttrs);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\stylesheetcomponenteditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="StyleSheetComponentEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.UI.MobileControls;
    using System.Web.UI.Design.MobileControls;
    using System.Web.UI.Design.MobileControls.Adapters;
    using System.Windows.Forms;

    /// <summary>
    ///    <para>
    ///       Provides a component editor for a StyleSheet <see cref='System.Web.UI.MobileControls.StyleSheet'/>
    ///       control.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.Web.UI.MobileControls.StyleSheet'/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class StyleSheetComponentEditor : ComponentEditor 
    {
        public override bool EditComponent(ITypeDescriptorContext context, Object component)  
        {
            Debug.Assert(component is StyleSheet);

            StyleSheet styleSheet = (StyleSheet)component;
            StyleSheetDesigner designer = 
                (StyleSheetDesigner)DesignerAdapterUtil.ControlDesigner(styleSheet);
            //String currentStyle = designer.TemplateStyle;

            if (designer.InTemplateMode)
            {
                MessageBox.Show(SR.GetString(SR.BaseTemplatedMobileComponentEditor_TemplateModeErrorMessage), 
                    SR.GetString(SR.BaseTemplatedMobileComponentEditor_TemplateModeErrorTitle),
                    MessageBoxButtons.OK, MessageBoxIcon.Information);

                return false;
            }

            StylesEditorDialog dialog;
            
            try
            {
                dialog = new StylesEditorDialog(
                    styleSheet,
                    designer,
                    null /*currentStyle*/
                );
            }
            catch//(ArgumentException e)
            {
                // Debug.Fail(e.ToString());
                // Block user from entering StylesEditorDialog until they fix
                // duplicate style declarations.
                return false;
            }

            return (dialog.ShowDialog() == DialogResult.OK);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\stylesheetrefurleditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="StyleSheetRefUrlEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Web.UI.Design;

namespace System.Web.UI.Design.MobileControls
{
    /// <summary>
    ///   Provides an editor for visually picking an ASCX Url.
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class StyleSheetRefUrlEditor: UrlEditor
    {
        /// <summary>
        ///    Caption of the editor UI
        /// </summary>
        protected override String Caption
        {
            get
            {
                return SR.GetString(SR.StyleSheetRefUrlEditor_Caption);
            }
        }

        /// <summary>
        ///    Filter used by the editor
        /// </summary>
        protected override String Filter
        {
            get
            {
                return SR.GetString(SR.StyleSheetRefUrlEditor_Filter);
            }
        }

        /// <summary>
        ///   NoAbsolute = Don't allow absoulte urls.
        ///   None = Otherwise.
        /// </summary>
        protected override UrlBuilderOptions Options 
        {
            get 
            {
                return UrlBuilderOptions.NoAbsolute;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\tablefieldseditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="TableFieldsEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing.Design;
    using System.Web.UI.MobileControls;

    /// <summary>
    ///    <para>
    ///       The editor for column collections.
    ///    </para>
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class TableFieldsEditor : MobileUITypeEditor 
    {
        /// <summary>
        ///    <para>
        ///       Edits the value specified.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    An <see cref='System.ComponentModel.ITypeDescriptorContext'/> that specifies the context of the value to edit.
        /// </param>
        /// <param name=' provider'>
        ///    An <see cref='System.IServiceProvider'/> .
        /// </param>
        /// <param name=' value'>
        ///    The object to edit.
        /// </param>
        /// <returns>
        ///    <para>
        ///       The updated value.
        ///    </para>
        /// </returns>
        public override Object EditValue(ITypeDescriptorContext context, IServiceProvider provider, Object value) 
        {
            Debug.Assert(context != null);

            ObjectList objectList = context.Instance as ObjectList;
            Debug.Assert(objectList != null);

            ObjectListDesigner designer = GetDesigner(context) as ObjectListDesigner;
            Debug.Assert(designer != null);

            designer.InvokePropertyBuilder(ObjectListComponentEditor.IDX_GENERAL);

            return objectList.TableFields;
        }

        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context)
        {
            // Disable the ... button in multi-selected case.
            if (context.Instance is ObjectList)
            {
                return base.GetEditStyle(context);
            }
            return UITypeEditorEditStyle.None;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\textboxdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextBoxDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.IO;
    using System.Web.UI;
    using System.Web.UI.Design;

    using System.Web.UI.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Adapters;

    /// <summary>
    ///    <para>
    ///       Provides a designer for the <see cref='System.Web.UI.MobileControls.TextBox'/>
    ///       control.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.Web.UI.MobileControls.TextBox'/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class TextBoxDesigner : MobileControlDesigner
    {
        private System.Web.UI.MobileControls.TextBox _textBox;

        /// <summary>
        ///    <para>
        ///       Initializes the designer with the component for design.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element for design.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component for
        ///       design.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.TextBox,
                         "TextBoxDesigner.Initialize - Invalid TextBox Control");
            _textBox = (System.Web.UI.MobileControls.TextBox) component;
            base.Initialize(component);
        }

        /// <summary>
        ///    <para>
        ///       Returns the design-time HTML of the <see cref='System.Web.UI.MobileControls.TextBox'/>
        ///       mobile control
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The HTML of the control.
        ///    </para>
        /// </returns>
        /// <seealso cref='System.Web.UI.MobileControls.TextBox'/>
        protected override String GetDesignTimeNormalHtml()
        {
            DesignerTextWriter tw = new DesignerTextWriter();
            _textBox.Adapter.Render(tw);
            return tw.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\templatingoptionsdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplatingOptionsDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Globalization;
    using System.Web.UI.Design.Util;
    using System.Web.UI.Design.MobileControls.Util;
    using System.Web.UI.MobileControls;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    using Panel = System.Windows.Forms.Panel;
    using Button = System.Windows.Forms.Button;
    using Label = System.Windows.Forms.Label;
    using ComboBox = System.Windows.Forms.ComboBox;
    using Form = System.Windows.Forms.Form;
    using UnsettableComboBox = System.Web.UI.Design.MobileControls.Util.UnsettableComboBox;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class TemplatingOptionsDialog : Form, IRefreshableDeviceSpecificEditor, IDeviceSpecificDesigner
    {
        private System.Windows.Forms.Control _header;
        private MobileTemplatedControlDesigner _designer;
        private IDeviceSpecificDesigner _dsd;
        private DeviceSpecific _ds;
        private ISite _site;
        private ComboBox _cmbChoices;
        private UnsettableComboBox _cmbSchemas;
        private Button _btnEditChoices;
        private Button _btnClose;
        private Button _btnHelp;
        private int _mergingContext;
        private StringCollection _strCollSchemas;
        private Label _lblChoices = new Label();
        private Label _lblSchemas = new Label();
        private Panel _pnlMain = new Panel();
        private String[] _schemasFriendly;
        private String[] _schemasUrl;

        private const int _standardSchemaNumber = 2;

        internal TemplatingOptionsDialog(MobileTemplatedControlDesigner designer, 
                                       ISite site, 
                                       int mergingContext)
        {
            _strCollSchemas = new StringCollection();
            _mergingContext = mergingContext;
            _designer = designer;
            _site = site;
            _dsd = (IDeviceSpecificDesigner) designer;
            _dsd.SetDeviceSpecificEditor(this);

            InitializeComponent();

            this.Text = SR.GetString(SR.TemplatingOptionsDialog_Title);
            _btnHelp.Text = SR.GetString(SR.GenericDialog_HelpBtnCaption);
            _btnClose.Text = SR.GetString(SR.GenericDialog_CloseBtnCaption);
            _lblSchemas.Text = SR.GetString(SR.TemplatingOptionsDialog_SchemaCaption);
            _btnEditChoices.Text = SR.GetString(SR.TemplatingOptionsDialog_EditBtnCaption);
            _lblChoices.Text = SR.GetString(SR.TemplatingOptionsDialog_FilterCaption);
            _schemasFriendly = new String[] { SR.GetString(SR.TemplatingOptionsDialog_HTMLSchemaFriendly),
                                              SR.GetString(SR.TemplatingOptionsDialog_CHTMLSchemaFriendly) };
            _schemasUrl = new String[] { SR.GetString(SR.MarkupSchema_HTML32),
                                         SR.GetString(SR.MarkupSchema_cHTML10) };
            
            int tabOffset = GenericUI.InitDialog(
                this,
                _dsd,
                _mergingContext
            );

            SetTabIndexes(tabOffset);
            _dsd.RefreshHeader(_mergingContext);
            String currentDeviceSpecificID = _dsd.CurrentDeviceSpecificID;
            if (null != currentDeviceSpecificID && currentDeviceSpecificID.Length > 0)
            {
                DeviceSpecific ds;
                _dsd.GetDeviceSpecific(currentDeviceSpecificID, out ds);
                ((IRefreshableDeviceSpecificEditor) this).Refresh(currentDeviceSpecificID, ds);
            }
            UpdateControlEnabling();
        }

        private void SetTabIndexes(int tabIndexOffset)
        {
            _pnlMain.TabIndex = ++tabIndexOffset;
            _lblChoices.TabIndex = ++tabIndexOffset;
            _cmbChoices.TabIndex = ++tabIndexOffset;
            _btnEditChoices.TabIndex = ++tabIndexOffset;
            _lblSchemas.TabIndex = ++tabIndexOffset;
            _cmbSchemas.TabIndex = ++tabIndexOffset;
            _btnClose.TabIndex = ++tabIndexOffset;
            _btnHelp.TabIndex = ++tabIndexOffset;
        }

        private void InitializeComponent()
        {
            _cmbChoices = new ComboBox();
            _cmbSchemas = new UnsettableComboBox();

            _btnEditChoices = new Button();
            _btnClose = new Button();
            _btnHelp = new Button();
            
            _lblChoices.Location = new System.Drawing.Point(0, 0);
            _lblChoices.Size = new System.Drawing.Size(276, 16);
            _lblChoices.TabStop = false;

            _cmbChoices.Location = new System.Drawing.Point(0, 16);
            _cmbChoices.Size = new System.Drawing.Size(195, 21);
            _cmbChoices.TabStop = true;
            _cmbChoices.Enabled = false;
            _cmbChoices.Sorted = true;
            _cmbChoices.DropDownStyle = ComboBoxStyle.DropDownList;
            _cmbChoices.SelectedIndexChanged += new EventHandler(this.OnSelectedIndexChangedChoicesComboBox);

            _btnEditChoices.Location = new System.Drawing.Point(201, 15);
            _btnEditChoices.Size = new System.Drawing.Size(75, 23);
            _btnEditChoices.TabStop = true;
            _btnEditChoices.Click += new EventHandler(this.OnClickEditChoicesButton);

            _lblSchemas.Location = new System.Drawing.Point(0, 48);
            _lblSchemas.Size = new System.Drawing.Size(276, 16);
            _lblSchemas.TabStop = false;

            _cmbSchemas.Location = new System.Drawing.Point(0, 64);
            _cmbSchemas.Size = new System.Drawing.Size(276, 21);
            _cmbSchemas.TabStop = true;
            _cmbSchemas.Sorted = true;
            _cmbSchemas.DropDownStyle = ComboBoxStyle.DropDown;
            _cmbSchemas.LostFocus += new EventHandler(this.OnLostFocusSchemasComboBox);

            _btnClose.Location = new System.Drawing.Point(120, 104);
            _btnClose.Size = new System.Drawing.Size(75, 23);
            _btnClose.TabStop = true;
            _btnClose.Click += new EventHandler(this.OnClickCloseButton);

            _btnHelp.Location = new System.Drawing.Point(201, 104);
            _btnHelp.Size = new System.Drawing.Size(75, 23);
            _btnHelp.TabStop = true;
            _btnHelp.Click += new EventHandler(this.OnClickHelpButton);

            this.HelpRequested += new HelpEventHandler(this.OnHelpRequested);
            
            this._pnlMain.Controls.AddRange(new System.Windows.Forms.Control[] {
                this._btnClose,
                this._btnHelp,
                this._cmbSchemas,
                this._lblSchemas,
                this._btnEditChoices,
                this._lblChoices,
                this._cmbChoices
            });
            this._pnlMain.Location = new System.Drawing.Point(6, 5);
            this._pnlMain.Size = new System.Drawing.Size(276, 128);
            this._pnlMain.TabIndex = 0;
            this._pnlMain.Anchor = (System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left);

            this.ClientSize = new Size(285, 139);
            this.AcceptButton = _btnClose;
            this.CancelButton = _btnClose;
            this.Controls.Add(_pnlMain);
        }

        private void FillChoicesComboBox()
        {
            Debug.Assert(_dsd != null);

            _cmbChoices.Items.Clear();

            if (null != _ds || null != _dsd.UnderlyingObject)
            {
                _cmbChoices.Items.Add(SR.GetString(SR.DeviceFilter_NoChoice));
            }

            if (null == _ds)
            {
                if (_cmbChoices.Items.Count > 0)
                {
                    _cmbChoices.SelectedIndex = 0;
                }
            }
            else
            {
                bool addedDefault = false;
                foreach (DeviceSpecificChoice choice in _ds.Choices)
                {
                    if (String.Empty == choice.Filter)
                    {
                        if (!addedDefault)
                        {
                            _cmbChoices.Items.Add(SR.GetString(SR.DeviceFilter_DefaultChoice));
                            addedDefault = true;
                        }
                    }
                    else
                    {
                        if (!choice.Filter.Equals(SR.GetString(SR.DeviceFilter_NoChoice)))
                        {
                            _cmbChoices.Items.Add(DesignerUtility.ChoiceToUniqueIdentifier(choice));
                        }
                    }
                }
                if (null != _designer.CurrentChoice && _designer.CurrentDeviceSpecific == _ds)
                {
                    if (String.Empty == _designer.CurrentChoice.Filter)
                    {
                        _cmbChoices.SelectedItem = SR.GetString(SR.DeviceFilter_DefaultChoice);
                    }
                    else
                    {
                        _cmbChoices.SelectedItem = DesignerUtility.ChoiceToUniqueIdentifier(_designer.CurrentChoice);
                    }
                }
                else 
                {
                    Debug.Assert(_cmbChoices.Items.Count > 0);
                    _cmbChoices.SelectedItem = SR.GetString(SR.DeviceFilter_NoChoice);
                }
            }
        }

        private void FillSchemasComboBox()
        {
            String friendlySchema;

            _cmbSchemas.Items.Clear();
            _cmbSchemas.Text = String.Empty;

            if (null != _ds)
            {
                // Add the standard HTML 3.2 and cHTML1.0 schemas
                for (int i = 0; i < _standardSchemaNumber; i++)
                {
                    _cmbSchemas.AddItem(_schemasFriendly[i]);
                }

                // Add the Xmlns entries existing in the applied device filters of the page
                IContainer container = (IContainer) _site.GetService(typeof(IContainer));
                Debug.Assert(null != container, "container is null");
                ComponentCollection allComponents = container.Components;
                _strCollSchemas.Clear();

                foreach (IComponent component in allComponents)
                {
                    ExtractDeviceFilterSchemas(component as System.Web.UI.Control);
                }

                foreach (String strSchema in _strCollSchemas)
                {
                    friendlySchema = UrlToFriendlySchema(strSchema);
                    if (!CaseSensitiveComboSearch(_cmbSchemas, friendlySchema))
                    {
                        _cmbSchemas.AddItem(friendlySchema);
                    }
                }

                // Add the Xmlns entries existing in the currently selected device filter
                foreach (DeviceSpecificChoice choice in _ds.Choices)
                {
                    friendlySchema = UrlToFriendlySchema(choice.Xmlns);
                    if (friendlySchema != null && friendlySchema.Length > 0 &&
                        !CaseSensitiveComboSearch(_cmbSchemas, friendlySchema))
                    {
                        _cmbSchemas.AddItem(friendlySchema);
                    }
                }
            }
        }

        private String FriendlyToUrlSchema(String friendlySchema)
        {
            for (int i = 0; i < _standardSchemaNumber; i++)
            {
                if (0 == String.Compare(_schemasFriendly[i], friendlySchema, true, CultureInfo.InvariantCulture))
                {
                    return _schemasUrl[i];
                }
            }
            return friendlySchema;
        }

        private String UrlToFriendlySchema(String urlSchema)
        {
            for (int i = 0; i < _standardSchemaNumber; i++)
            {
                if (0 == String.Compare(_schemasUrl[i], urlSchema, false, CultureInfo.InvariantCulture))
                {
                    return _schemasFriendly[i];
                }
            }
            return urlSchema;
        }

        private void SetSchemaValue()
        {
            if (_ds != null &&
                _cmbChoices.SelectedIndex >= 0)
            {
                String currentChoiceIdentifier = _cmbChoices.SelectedItem as String;
                if (currentChoiceIdentifier != null && !currentChoiceIdentifier.Equals(SR.GetString(SR.DeviceFilter_NoChoice)))
                {
                    DeviceSpecificChoice dsc = GetChoiceFromIdentifier((String) currentChoiceIdentifier, _ds);
                    _cmbSchemas.Text = UrlToFriendlySchema(dsc.Xmlns);
                }
            }
        }

        private void ExtractDeviceFilterSchemas(System.Web.UI.Control control)
        {
            if (null == control)
            {
                return;
            }

            MobileControl mobileControl = control as MobileControl;
            if (null != mobileControl)
            {
                DeviceSpecific deviceSpecific;
                DeviceSpecificChoiceCollection choices;
                if (mobileControl is StyleSheet)
                {
                    StyleSheet styleSheet = (StyleSheet) mobileControl;
                    ICollection styleKeys = styleSheet.Styles;
                    foreach (String key in styleKeys)
                    {
                        Style style = styleSheet[key];
                        deviceSpecific = style.DeviceSpecific;
                        if (null != deviceSpecific && _ds != deviceSpecific)
                        {
                            choices = deviceSpecific.Choices;

                            foreach (DeviceSpecificChoice choice in choices)
                            {
                                if (choice.Xmlns != null && choice.Xmlns.Length > 0 &&
                                    !_strCollSchemas.Contains(choice.Xmlns))
                                {
                                    _strCollSchemas.Add(choice.Xmlns);
                                }
                            }
                        }
                    }
                }
                else
                {
                    deviceSpecific = mobileControl.DeviceSpecific;
                    if (null != deviceSpecific && _ds != deviceSpecific)
                    {
                        choices = deviceSpecific.Choices;

                        foreach (DeviceSpecificChoice choice in choices)
                        {
                            if (choice.Xmlns != null && choice.Xmlns.Length > 0 &&
                                !_strCollSchemas.Contains(choice.Xmlns))
                            {
                                _strCollSchemas.Add(choice.Xmlns);
                            }
                        }
                    }
                }
            }

            if (control.HasControls())
            {
                foreach (System.Web.UI.Control child in control.Controls)
                {
                    ExtractDeviceFilterSchemas(child);
                }
            }
        }

        private bool CaseSensitiveComboSearch(ComboBox cmb, String str)
        {
            foreach (Object obj in cmb.Items)
            {
                if (String.Compare(str, (String) obj, false, CultureInfo.InvariantCulture) == 0)
                {
                    return true;
                }
            }
            return false;
        }

        private void UpdateControlEnabling()
        {
            _btnEditChoices.Enabled = (_dsd.UnderlyingObject != null);
            _cmbChoices.Enabled = (_cmbChoices.Items.Count > 0);
            _cmbSchemas.Enabled = (_cmbChoices.Items.Count > 1) &&
                                  (!((String)_cmbChoices.SelectedItem).Equals(SR.GetString(SR.DeviceFilter_NoChoice)));
        }

        private DeviceSpecificChoice GetChoiceFromIdentifier(String choiceIdentifier, DeviceSpecific ds)
        {
            if (null == ds)
            {
                return null;
            }

            Debug.Assert(ds.Choices != null);

            foreach (DeviceSpecificChoice choice in ds.Choices)
            {
                if (DesignerUtility.ChoiceToUniqueIdentifier(choice).Equals(choiceIdentifier) ||
                    (String.Empty == choice.Filter && 
                     choiceIdentifier.Equals(SR.GetString(SR.DeviceFilter_DefaultChoice))))
                {
                    return choice;
                }
            }

            return null;
        }

        bool IRefreshableDeviceSpecificEditor.RequestRefresh()
        {
            return true;
        }
        
        void IRefreshableDeviceSpecificEditor.Refresh(String deviceSpecificID, DeviceSpecific ds)
        {
            _ds = ds;
            FillChoicesComboBox();
            FillSchemasComboBox();
            SetSchemaValue();
            UpdateControlEnabling();
        }

        void IRefreshableDeviceSpecificEditor.UnderlyingObjectsChanged()
        {
        }

        void IRefreshableDeviceSpecificEditor.BeginExternalDeviceSpecificEdit() {}
        void IRefreshableDeviceSpecificEditor.EndExternalDeviceSpecificEdit(
            bool commitChanges) {}
        void IRefreshableDeviceSpecificEditor.DeviceSpecificRenamed(
            String oldDeviceSpecificID, String newDeviceSpecificID) {}
        void IRefreshableDeviceSpecificEditor.DeviceSpecificDeleted(
            String deviceSpecificID) {}
        
        private void ShowHelpTopic()
        {
            Debug.Assert(_site != null);
            IHelpService helpService = (IHelpService)_site.GetService(typeof(IHelpService));
            if (helpService != null) 
            {
                helpService.ShowHelpFromKeyword("net.Mobile.TemplatingOptionsDialog");
            }
        }

        private void OnClickCloseButton(Object sender, EventArgs e)
        {
            _dsd.UseCurrentDeviceSpecificID();

            if (0 <= _cmbChoices.SelectedIndex &&
                !_cmbChoices.Text.Equals(SR.GetString(SR.DeviceFilter_NoChoice)))
            {
                _designer.CurrentChoice = GetChoiceFromIdentifier((String) _cmbChoices.SelectedItem, _ds);
            }
            else
            {
                _designer.CurrentChoice = null;
            }

            Close();
            DialogResult = DialogResult.OK;
        }

        private void OnClickHelpButton(Object sender, EventArgs e)
        {
            ShowHelpTopic();
        }

        private void OnHelpRequested(Object Control, HelpEventArgs hevent)
        {
            ShowHelpTopic();
            hevent.Handled = true;
        }


        private void OnSelectedIndexChangedChoicesComboBox(Object sender, EventArgs e) 
        {
            if (_cmbChoices.Text.Equals(SR.GetString(SR.DeviceFilter_NoChoice)))
            {
                _cmbSchemas.Enabled = false;
                _cmbSchemas.Text = String.Empty;
            }
            else
            {
                _cmbSchemas.Enabled = true;
                SetSchemaValue();
            }

            _designer.SetTemplateVerbsDirty();
        }

        private void OnLostFocusSchemasComboBox(Object sender, EventArgs e) 
        {
            Debug.Assert(_ds != null);
            Debug.Assert(_cmbChoices.SelectedIndex >= 0);
            DeviceSpecificChoice choice = GetChoiceFromIdentifier((String) _cmbChoices.SelectedItem, _ds);
            String urlSchema = FriendlyToUrlSchema(_cmbSchemas.Text);
            if (0 != String.Compare(choice.Xmlns, urlSchema, false, CultureInfo.InvariantCulture))
            {
                String previousUrlSchema = choice.Xmlns;
                if (!_strCollSchemas.Contains(previousUrlSchema))
                {
                    int previousSchemaOccurrences = 0;
                    foreach (DeviceSpecificChoice choiceTmp in _ds.Choices)
                    {
                        if (0 == String.Compare(choiceTmp.Xmlns, previousUrlSchema, false, CultureInfo.InvariantCulture))
                        {
                            previousSchemaOccurrences++;
                        }
                    }
                    Debug.Assert(previousSchemaOccurrences > 0);
                    if (previousSchemaOccurrences == 1)
                    {
                        bool standardSchema = false;
                        for (int i = 0; i < _standardSchemaNumber; i++)
                        {
                            if (0 == String.Compare(_schemasUrl[i], previousUrlSchema, false, CultureInfo.InvariantCulture))
                            {
                                standardSchema = true;
                                break;
                            }
                        }
                        if (!standardSchema)
                        {
                            _cmbSchemas.Items.Remove(UrlToFriendlySchema(previousUrlSchema));
                        }
                    }
                }
                choice.Xmlns = urlSchema;
                String friendlySchema = UrlToFriendlySchema(urlSchema);
                if (friendlySchema != String.Empty &&
                    !CaseSensitiveComboSearch(_cmbSchemas, friendlySchema))
                {
                    _cmbSchemas.AddItem(friendlySchema);
                }
            }
        }

        private void OnClickEditChoicesButton(Object source, EventArgs e)
        {
            AppliedDeviceFiltersDialog dialog = new AppliedDeviceFiltersDialog(this, _mergingContext);
            if (dialog.ShowDialog() == DialogResult.OK)
            {
                _designer.UpdateRendering();
                FillChoicesComboBox();
                FillSchemasComboBox();
                SetSchemaValue();
                UpdateControlEnabling();
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //  Begin IDeviceSpecificDesigner Implementation
        ////////////////////////////////////////////////////////////////////////

        void IDeviceSpecificDesigner.SetDeviceSpecificEditor
            (IRefreshableDeviceSpecificEditor editor)
        {
        }

        String IDeviceSpecificDesigner.CurrentDeviceSpecificID
        {
            get
            {
                return _dsd.CurrentDeviceSpecificID;
            }
        }

        System.Windows.Forms.Control IDeviceSpecificDesigner.Header
        {
            get
            {
                return _header;
            }
        }

        System.Web.UI.Control IDeviceSpecificDesigner.UnderlyingControl
        {
            get
            {
                return _dsd.UnderlyingControl;
            }
        }

        Object IDeviceSpecificDesigner.UnderlyingObject
        {
            get
            {
                return _dsd.UnderlyingObject;
            }
        }

        bool IDeviceSpecificDesigner.GetDeviceSpecific(String deviceSpecificParentID, out DeviceSpecific ds)
        {
            return _dsd.GetDeviceSpecific(deviceSpecificParentID, out ds);
        }

        void IDeviceSpecificDesigner.SetDeviceSpecific(String deviceSpecificParentID, DeviceSpecific ds)
        {
            _ds = ds;
            _dsd.SetDeviceSpecific(deviceSpecificParentID, ds);
        }

        void IDeviceSpecificDesigner.InitHeader(int mergingContext)
        {
            HeaderPanel panel = new HeaderPanel();
            HeaderLabel lblDescription = new HeaderLabel();

            lblDescription.TabIndex = 0;
            lblDescription.Text = SR.GetString(SR.MobileControl_SettingGenericChoiceDescription);
            
            panel.Height = lblDescription.Height;
            panel.Width = lblDescription.Width;
            panel.Controls.Add(lblDescription);
            _header = panel;
        }

        void IDeviceSpecificDesigner.RefreshHeader(int mergingContext)
        {
        }

        void IDeviceSpecificDesigner.UseCurrentDeviceSpecificID()
        {
        }

        /////////////////////////////////////////////////////////////////////////
        //  End IDeviceSpecificDesigner Implementation
        /////////////////////////////////////////////////////////////////////////
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\styleseditordialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="StylesEditorDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Reflection;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Web.UI;
    using System.Web.UI.MobileControls;
    using System.Web.UI.Design.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Util;

    using AttributeCollection = System.ComponentModel.AttributeCollection;
    using Control   = System.Windows.Forms.Control;

    using Button    = System.Windows.Forms.Button;
    using Label     = System.Windows.Forms.Label;
    using TextBox   = System.Windows.Forms.TextBox;
    using ListView  = System.Windows.Forms.ListView;
    using ListBox   = System.Windows.Forms.ListBox;

    using FontSize  = System.Web.UI.MobileControls.FontSize;
    using Style     = System.Web.UI.MobileControls.Style;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class StylesEditorDialog : System.Windows.Forms.Form
    {
        private StyleSheet         _styleSheet;
        private StyleSheet         _tempStyleSheet;
        private StyleSheetDesigner _styleSheetDesigner;
        private Style              _previewStyle;
        private Type               _currentNewStyleType;
        private bool               _firstActivate = true;

        private Button             _btnOK;
        private Button             _btnCancel;
        private Button             _btnHelp;
        private Button             _btnUp;
        private Button             _btnDown;
        private Button             _btnAdd;
        private Button             _btnRemove;
        private TextBox            _txtType;
        private TreeView           _tvDefinedStyles;
        private ListView           _lvAvailableStyles;
        private PropertyGrid       _propertyBrowser;
        private MSHTMLHost         _samplePreview;
        private ContextMenu        _cntxtMenu;
        private MenuItem           _cntxtMenuItem;
        private TreeNode           _editCandidateNode = null;

        private StyleNode SelectedStyle
        {
            get 
            {
                Debug.Assert(_tvDefinedStyles != null);
                return _tvDefinedStyles.SelectedNode as StyleNode;
            }
            set
            {
                Debug.Assert(_tvDefinedStyles != null);
                _tvDefinedStyles.SelectedNode = value;
            }
        }

        /// <summary>
        ///    Create a new StylesEditorDialog instance
        /// </summary>
        /// <internalonly/>
        internal StylesEditorDialog(StyleSheet stylesheet, 
            StyleSheetDesigner styleSheetDesigner,
            String initialStyleName)
        {
            if(stylesheet.DuplicateStyles.Count > 0)
            {
                GenericUI.ShowErrorMessage(
                    SR.GetString(SR.StylesEditorDialog_Title),
                    SR.GetString(SR.StylesEditorDialog_DuplicateStyleNames)
                );
                throw new ArgumentException(
                    SR.GetString(SR.StylesEditorDialog_DuplicateStyleException)
                );
            }
        
            _tempStyleSheet = new StyleSheet();
            _previewStyle   = new Style();

            _styleSheet         = stylesheet;
            _styleSheetDesigner = styleSheetDesigner;

            _tempStyleSheet.Site = _styleSheet.Site;

            InitializeComponent();

            InitAvailableStyles();
            LoadStyleItems();

            if (_tvDefinedStyles.Nodes.Count > 0)
            {
                int initialIndex = 0;
                if (initialStyleName != null)
                {
                    initialIndex = StyleIndex(initialStyleName);
                }
                SelectedStyle = (StyleNode)_tvDefinedStyles.Nodes[initialIndex];
                _tvDefinedStyles.Enabled = true;
                UpdateTypeText();
                UpdatePropertyGrid();
            }

            UpdateButtonsEnabling();
            UpdateFieldsEnabling();
        }

        protected override void Dispose(bool disposing)
        {
            if(disposing)
            {
                if (_tvDefinedStyles != null)
                {
                    foreach (StyleNode item in _tvDefinedStyles.Nodes)
                    {
                        item.Dispose();
                    }
                    _tvDefinedStyles = null;
                }
            }
            base.Dispose(disposing);
        }

        private void InitializeComponent()
        {
            _btnOK             = new Button();
            _btnCancel         = new Button();
            _btnHelp           = new Button();
            _btnUp             = new Button();
            _btnDown           = new Button();
            _btnAdd            = new Button();
            _btnRemove         = new Button();

            _txtType           = new TextBox();
            _tvDefinedStyles   = new TreeView();
            _lvAvailableStyles = new ListView();
            _samplePreview     = new MSHTMLHost();
            _propertyBrowser   = new PropertyGrid();
            _cntxtMenuItem     = new MenuItem();
            _cntxtMenu         = new ContextMenu();

            GroupLabel grplblStyleList = new GroupLabel();
            grplblStyleList.SetBounds(6, 5, 432, 16);
            grplblStyleList.Text = SR.GetString(SR.StylesEditorDialog_StyleListGroupLabel);
            grplblStyleList.TabStop = false;
            grplblStyleList.TabIndex = 0;

            Label lblAvailableStyles = new Label();
            lblAvailableStyles.SetBounds(14, 25, 180, 16);
            lblAvailableStyles.Text = SR.GetString(SR.StylesEditorDialog_AvailableStylesCaption);
            lblAvailableStyles.TabStop = false;
            lblAvailableStyles.TabIndex = 1;

            ColumnHeader chStyleType = new System.Windows.Forms.ColumnHeader();
            ColumnHeader chStyleNamespace = new System.Windows.Forms.ColumnHeader();

            chStyleType.Width = 16;
            chStyleType.TextAlign = System.Windows.Forms.HorizontalAlignment.Left;
            chStyleNamespace.Width = 16;
            chStyleNamespace.TextAlign = System.Windows.Forms.HorizontalAlignment.Left;

            _lvAvailableStyles.SetBounds(14, 41, 180, 95);
            _lvAvailableStyles.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
            _lvAvailableStyles.MultiSelect = false;
            _lvAvailableStyles.HideSelection = false;
            _lvAvailableStyles.FullRowSelect = true;
            _lvAvailableStyles.View = System.Windows.Forms.View.Details;
            _lvAvailableStyles.Columns.AddRange(new System.Windows.Forms.ColumnHeader[2] {chStyleType, chStyleNamespace});
            _lvAvailableStyles.SelectedIndexChanged += new EventHandler(this.OnNewStyleTypeChanged);
            _lvAvailableStyles.DoubleClick += new EventHandler(this.OnDoubleClick);
            _lvAvailableStyles.Sorting = SortOrder.Ascending;
            _lvAvailableStyles.TabIndex = 2;
            _lvAvailableStyles.TabStop = true;

            _btnAdd.SetBounds(198, 77, 32, 25);
            _btnAdd.Text = SR.GetString(SR.StylesEditorDialog_AddBtnCation);
            _btnAdd.Click += new EventHandler(this.OnClickAddButton);
            _btnAdd.TabIndex = 3;
            _btnAdd.TabStop = true;

            Label lblDefinedStyles = new Label();
            lblDefinedStyles.SetBounds(234, 25, 166, 16);
            lblDefinedStyles.Text = SR.GetString(SR.StylesEditorDialog_DefinedStylesCaption);
            lblDefinedStyles.TabStop = false;
            lblDefinedStyles.TabIndex = 4;;

            _tvDefinedStyles.SetBounds(234, 41, 166, 95);
            _tvDefinedStyles.AfterSelect += new TreeViewEventHandler(OnStylesSelected);
            _tvDefinedStyles.AfterLabelEdit += new NodeLabelEditEventHandler(OnAfterLabelEdit);
            _tvDefinedStyles.LabelEdit = true;
            _tvDefinedStyles.ShowPlusMinus = false;
            _tvDefinedStyles.HideSelection = false;
            _tvDefinedStyles.Indent = 15;
            _tvDefinedStyles.ShowRootLines = false;
            _tvDefinedStyles.ShowLines = false;
            _tvDefinedStyles.ContextMenu = _cntxtMenu;
            _tvDefinedStyles.TabIndex = 5;
            _tvDefinedStyles.TabStop = true;
            _tvDefinedStyles.KeyDown += new KeyEventHandler(OnKeyDown);
            _tvDefinedStyles.MouseUp += new MouseEventHandler(OnListMouseUp);
            _tvDefinedStyles.MouseDown += new MouseEventHandler(OnListMouseDown);

            _btnUp.SetBounds(404, 41, 28, 27);
            _btnUp.Click += new EventHandler(this.OnClickUpButton);
            _btnUp.Image = GenericUI.SortUpIcon; 
            _btnUp.TabIndex = 6;
            _btnUp.TabStop = true;

            _btnDown.SetBounds(404, 72, 28, 27);
            _btnDown.Click += new EventHandler(this.OnClickDownButton);
            _btnDown.Image = GenericUI.SortDownIcon;
            _btnDown.TabIndex = 7;
            _btnDown.TabStop = true;

            _btnRemove.SetBounds(404, 109, 28, 27);
            _btnRemove.Click += new EventHandler(this.OnClickRemoveButton);
            _btnRemove.Image = GenericUI.DeleteIcon;
            _btnRemove.TabIndex = 8;
            _btnRemove.TabStop = true;

            GroupLabel grplblStyleProperties = new GroupLabel();
            grplblStyleProperties.SetBounds(6, 145, 432, 16);
            grplblStyleProperties.Text = SR.GetString(SR.StylesEditorDialog_StylePropertiesGroupLabel);
            grplblStyleProperties.TabStop = false;
            grplblStyleProperties.TabIndex = 9;

            Label lblType = new Label();
            lblType.SetBounds(14, 165, 180, 16);
            lblType.Text = SR.GetString(SR.StylesEditorDialog_TypeCaption);
            lblType.TabIndex = 10;
            lblType.TabStop = false;

            _txtType.SetBounds(14, 181, 180, 16);
            _txtType.ReadOnly = true;
            _txtType.TabIndex = 11;
            _txtType.TabStop = true;

            Label lblSample = new Label();
            lblSample.SetBounds(14, 213, 180, 16);
            lblSample.Text = SR.GetString(SR.StylesEditorDialog_SampleCaption);
            lblSample.TabStop = false;
            lblSample.TabIndex = 12;

            _samplePreview.SetBounds(14, 229, 180, 76);
            _samplePreview.TabStop = false;
            _samplePreview.TabIndex = 13;

            Label lblProperties = new Label();
            lblProperties.SetBounds(234, 165, 198, 16);
            lblProperties.Text = SR.GetString(SR.StylesEditorDialog_PropertiesCaption);
            lblProperties.TabIndex = 14;
            lblProperties.TabStop = false;

            _propertyBrowser.SetBounds(234, 181, 198, 178);
            _propertyBrowser.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Bottom | AnchorStyles.Right;
            _propertyBrowser.ToolbarVisible = false;
            _propertyBrowser.HelpVisible = false;
            _propertyBrowser.TabIndex = 15;
            _propertyBrowser.TabStop = true;
            _propertyBrowser.PropertySort = PropertySort.Alphabetical;
            _propertyBrowser.PropertyValueChanged += new PropertyValueChangedEventHandler(this.OnPropertyValueChanged);

            _btnOK.DialogResult = DialogResult.OK;
            _btnOK.Location = new System.Drawing.Point(201, 370);
            _btnOK.Size = new System.Drawing.Size(75, 23);
            _btnOK.TabIndex = 16;
            _btnOK.Text = SR.GetString(SR.GenericDialog_OKBtnCaption);
            _btnOK.Click += new EventHandler(this.OnClickOKButton);

            _btnCancel.DialogResult = DialogResult.Cancel;
            _btnCancel.Location = new System.Drawing.Point(282, 370);
            _btnCancel.Size = new System.Drawing.Size(75, 23);
            _btnCancel.TabIndex = 17;
            _btnCancel.Text = SR.GetString(SR.GenericDialog_CancelBtnCaption);

            _btnHelp.Click += new EventHandler(this.OnClickHelpButton);
            _btnHelp.Location = new System.Drawing.Point(363, 370);
            _btnHelp.Size = new System.Drawing.Size(75, 23);
            _btnHelp.TabIndex = 18;
            _btnHelp.Text = SR.GetString(SR.GenericDialog_HelpBtnCaption);

            _cntxtMenuItem.Text = SR.GetString(SR.EditableTreeList_Rename);
            _cntxtMenu.MenuItems.Add(_cntxtMenuItem);
            _cntxtMenu.Popup += new EventHandler(OnPopup);
            _cntxtMenuItem.Click += new EventHandler(OnContextMenuItemClick);

            GenericUI.InitDialog(this, _styleSheet.Site);

            this.Text = _styleSheet.ID + " - " + SR.GetString(SR.StylesEditorDialog_Title);
            this.ClientSize = new Size(444, 401);
            this.AcceptButton = _btnOK;
            this.CancelButton = _btnCancel;
            this.Activated += new System.EventHandler(StylesEditorDialog_Activated);
            this.HelpRequested += new HelpEventHandler(this.OnHelpRequested);
            this.Controls.AddRange(new Control[]
                           {
                               grplblStyleList,
                               lblAvailableStyles,
                               _lvAvailableStyles,
                               _btnAdd,
                               lblDefinedStyles,
                               _tvDefinedStyles,
                               _btnUp,
                               _btnDown,
                               _btnRemove,
                               grplblStyleProperties,
                               lblType,
                               _txtType,
                               lblSample,
                               _samplePreview,
                               lblProperties,
                               _propertyBrowser,
                               _btnOK,
                               _btnCancel,
                               _btnHelp
                           });
        }

        private void InitAvailableStyles() 
        {
            //int[] colMaxWidth = { _lvAvailableStyles.Columns[0].Width, _lvAvailableStyles.Columns[1].Width };
            int[] colMaxWidth = { 68, 202 };
            int[] colReqWidth = { 0, 0 };

            // NOTE: Currently no way for third party extenders to add their
            // own styles.  They'll need to specify complete name with tagprefix included.
            StringCollection mobileStyles = new StringCollection();
            mobileStyles.AddRange(
                new String[2]{"System.Web.UI.MobileControls.PagerStyle",
                                 "System.Web.UI.MobileControls.Style"});

            foreach (String mobileStyle in mobileStyles)
            {
                Type type = Type.GetType(mobileStyle, true);
                String[] subItems = {type.Name, type.Namespace};
                ListViewItem item = new ListViewItem(subItems);
                _lvAvailableStyles.Items.Add(item);
            }

            ICollection styles = _styleSheet.Styles;
            foreach (String key in styles)
            {
                Style style = (Style) _styleSheet[key];
                Type type = style.GetType();
                if (!mobileStyles.Contains(type.FullName))
                {
                    String[] subItems = {type.Name, type.Namespace};
                    ListViewItem item = new ListViewItem(subItems);
                    _lvAvailableStyles.Items.Add(item);

                    // Rectangle rcLvi = lvi.GetBounds((int) ItemBoundsPortion.Label);
                    // use a method like GetExtendPoint32
                    colReqWidth[0] = 68;
                    if (colReqWidth[0] > colMaxWidth[0])
                    {
                        colMaxWidth[0] = colReqWidth[0];
                    }
                    // use a method like GetExtendPoint32
                    colReqWidth[1] = 202;
                    if (colReqWidth[1] > colMaxWidth[1])
                    {
                        colMaxWidth[1] = colReqWidth[1];
                    }
                }
            }
            _lvAvailableStyles.Columns[0].Width = colMaxWidth[0] + 4;
            _lvAvailableStyles.Columns[1].Width = colMaxWidth[1] + 4;

            Debug.Assert(_lvAvailableStyles.Items.Count > 0);
            _lvAvailableStyles.Sort();
            _lvAvailableStyles.Items[0].Selected = true;
            _currentNewStyleType = Type.GetType((String) _lvAvailableStyles.Items[0].SubItems[1].Text + "." + 
                _lvAvailableStyles.Items[0].Text, true);
        }

        private void SaveComponent()
        {
            // Clear old styles
            _styleSheet.Clear();

            foreach (StyleNode styleNode in _tvDefinedStyles.Nodes)
            {
                _styleSheet[styleNode.RuntimeStyle.Name] = styleNode.RuntimeStyle;
                styleNode.RuntimeStyle.SetControl(_styleSheet);
            }

            // Delete CurrentStyle if it does not exist any more.
            if (_styleSheetDesigner.CurrentStyle != null && 
                null == _styleSheet[_styleSheetDesigner.CurrentStyle.Name])
            {
                _styleSheetDesigner.CurrentStyle = null;
                _styleSheetDesigner.CurrentChoice = null;
            }

            _styleSheetDesigner.OnStylesChanged();
        }

        private void LoadStyleItems() 
        {
            ICollection styles = _styleSheet.Styles;

            foreach (String key in styles)
            {
                Style style = (Style) _styleSheet[key];
                Style newStyle = (Style) Activator.CreateInstance(style.GetType());
                
                PropertyDescriptorCollection propDescs = TypeDescriptor.GetProperties(style);

                for (int i = 0; i < propDescs.Count; i++) 
                {
                    if (propDescs[i].Name.Equals("Font"))
                    {
                        foreach (PropertyDescriptor desc in TypeDescriptor.GetProperties(style.Font))
                        {
                            desc.SetValue(newStyle.Font, desc.GetValue(style.Font));
                        }
                    }
                    else if (!propDescs[i].IsReadOnly)
                    {
                        propDescs[i].SetValue(newStyle, propDescs[i].GetValue(style));
                    }
                }

                _tempStyleSheet[newStyle.Name] = newStyle;
                newStyle.SetControl(_tempStyleSheet);

                StyleNode newStyleItem = new StyleNode(newStyle);
                _tvDefinedStyles.Nodes.Add(newStyleItem);
            }
        }

        private void UpdateButtonsEnabling()
        {
            if (SelectedStyle == null)
            {
                _btnUp.Enabled = false;
                _btnDown.Enabled = false;
            }
            else
            {
                _btnUp.Enabled = (SelectedStyle.Index > 0);
                _btnDown.Enabled = (SelectedStyle.Index < _tvDefinedStyles.Nodes.Count - 1);
            }

            _btnRemove.Enabled = (SelectedStyle != null);
        }

        private void UpdateFieldsEnabling()
        {
            _propertyBrowser.Enabled = 
                _tvDefinedStyles.Enabled = (SelectedStyle != null);
        }

        private String AutoIDStyle()
        {
            String newStyleID = _currentNewStyleType.Name;

            int i = 1;
            while (StyleIndex(newStyleID + i.ToString()) >= 0)
            {
                i++;
            }
            return newStyleID + i.ToString();
        }

        private int StyleIndex(String name)
        {
            int index = 0;
            foreach (StyleNode styleNode in _tvDefinedStyles.Nodes)
            {
                if (String.Compare(name, styleNode.RuntimeStyle.Name, true, CultureInfo.InvariantCulture) == 0)
                {
                    return index;
                }
                index++;
            }
            return -1;
        }

        private void UpdatePropertyGrid()
        {
            _propertyBrowser.SelectedObject = (SelectedStyle == null) ? 
                null : ((StyleNode)SelectedStyle).RuntimeStyle;
        }

        private void UpdateTypeText()
        {
            if (SelectedStyle == null)
            {
                _txtType.Text = String.Empty;
            }
            else
            {
                _txtType.Text = ((StyleNode)SelectedStyle).FullName;
            }
        }

        /// <summary>
        ///    Update scheme preview
        /// </summary>
        /// <internalonly/>
        private void UpdateSamplePreview()
        {
            if (_firstActivate)
            {
                return;
            }

            NativeMethods.IHTMLDocument2 tridentDocument = _samplePreview.GetDocument();
            NativeMethods.IHTMLElement documentElement = tridentDocument.GetBody();
            NativeMethods.IHTMLBodyElement bodyElement;

            bodyElement = (NativeMethods.IHTMLBodyElement) documentElement;
            bodyElement.SetScroll("no");

            if (SelectedStyle == null)
            {
                documentElement.SetInnerHTML(String.Empty);
                tridentDocument.SetBgColor("buttonface");
                return;
            }
            else
            {
                tridentDocument.SetBgColor(String.Empty);
            }

            bool cycle = ReferencesContainCycle(SelectedStyle);
            if (cycle)
            {
                documentElement.SetInnerHTML(String.Empty);
                return;
            }

            // apply the current Style to label
            ApplyStyle();

            DesignerTextWriter tw = new DesignerTextWriter();

            //ToolTip
            tw.AddAttribute("title", ((StyleNode)SelectedStyle).RuntimeStyle.Name);

            // ForeColor
            Color c = _previewStyle.ForeColor;
            if (!c.Equals(Color.Empty))
            {
                tw.AddStyleAttribute("color", ColorTranslator.ToHtml(c));
            }

            // BackColor
            c = _previewStyle.BackColor;
            if (!c.Equals(Color.Empty))
            {
                tw.AddStyleAttribute("background-color", ColorTranslator.ToHtml(c));
            }

            // Font Name
            String name = _previewStyle.Font.Name;
            if (!name.Equals(String.Empty))
            {
                tw.AddStyleAttribute("font-family", name);
            }

            // Font Size
            switch (_previewStyle.Font.Size)
            {
                case FontSize.Large :
                    tw.AddStyleAttribute("font-size", "Medium");
                    break;
                case FontSize.Small :
                    tw.AddStyleAttribute("font-size", "X-Small");
                    break;
                default:
                    tw.AddStyleAttribute("font-size", "Small");
                    break;
            }

            // Font Style
            if (_previewStyle.Font.Bold == BooleanOption.True)
            {
                tw.AddStyleAttribute("font-weight", "bold");
            }
            if (_previewStyle.Font.Italic == BooleanOption.True)
            {
                tw.AddStyleAttribute("font-style", "italic");
            }

            tw.RenderBeginTag("span");
            tw.Write(SR.GetString(SR.StylesEditorDialog_PreviewText));
            tw.RenderEndTag();

            // and show it!
            String finalHTML = "<div align='center'><table width='100%' height='100%'><tr><td><p align='center'>" +
                tw.ToString() + "</p></td></tr></table></div>";
            documentElement.SetInnerHTML(finalHTML);
        }

        private void ShowHelpTopic()
        {
            ISite componentSite = _styleSheet.Site;
            Debug.Assert(componentSite != null, "Expected the stylesheet to be sited.");
 
            IHelpService helpService = (IHelpService)componentSite.GetService(typeof(IHelpService));
            if (helpService != null) 
            {
                helpService.ShowHelpFromKeyword("net.Mobile.StylesEditorDialog");
            }
        }

        /*
         *  BEGIN EVENT HANDLING
         */
        Timer _delayTimer;
        private void StylesEditorDialog_Activated(Object sender, System.EventArgs e)
        {
            if (!_firstActivate)
            {
                return;
            }
            _firstActivate = false;

            _samplePreview.CreateTrident();
            _samplePreview.ActivateTrident();

            UpdateSamplePreview();

            _delayTimer = new Timer();
            _delayTimer.Interval = 100;
            _delayTimer.Tick += new EventHandler(this.OnActivateDefinedStyles);
            _delayTimer.Start();
        }

        private void OnActivateDefinedStyles(Object sender, System.EventArgs e)
        {
            _delayTimer.Stop();
            _delayTimer.Tick -= new EventHandler(this.OnActivateDefinedStyles);
            
            _lvAvailableStyles.Focus();
        }

        internal delegate void StyleRenamedEventHandler(
            Object source, StyleRenamedEventArgs e);
        
        internal event StyleRenamedEventHandler StyleRenamed;

        private void OnStyleRenamed(StyleRenamedEventArgs e)
        {
            if(StyleRenamed != null)
            {
                StyleRenamed(this, e);
            }
        }

        private void OnAfterLabelEdit(Object source, NodeLabelEditEventArgs e)
        {
            Debug.Assert(null != e);
            Debug.Assert(e.CancelEdit == false);

            // this happens when the label is unchanged after entering and exiting
            // label editing mode - bizarre behavior. this may be a bug in treeview
            if (null == e.Label)
            {
                return;
            }

            String oldValue = e.Node.Text;
            String newValue = e.Label;

            String messageTitle = SR.GetString(SR.Style_ErrorMessageTitle);

            // can't accept a style name that already exists
            if (String.Compare(oldValue, newValue , true, CultureInfo.InvariantCulture) != 0 && StyleIndex(newValue) >= 0)
            {
                MessageBox.Show(
                    SR.GetString(SR.Style_DuplicateName),
                    messageTitle,
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Exclamation);
                e.CancelEdit = true;
                return;
            }

            // can't accept an empty style name
            if (newValue == String.Empty)
            {
                MessageBox.Show(
                    SR.GetString(SR.StylesEditorDialog_EmptyName), 
                    messageTitle,
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Exclamation);
                e.CancelEdit = true;
                return;
            }

            /* Removed for DCR 4240
            // can't accept an illegal style name
            if (!DesignerUtility.IsValidName(newValue))
            {
                MessageBox.Show(
                    SR.GetString(SR.Style_InvalidName, newValue),
                    messageTitle, 
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Exclamation);
                e.CancelEdit = true;
                return;
            }
            */

            SelectedStyle.RuntimeStyle.Name = newValue;
            _tempStyleSheet.Remove(oldValue);
            _tempStyleSheet[newValue] = SelectedStyle.RuntimeStyle;

            if (ReferencesContainCycle(SelectedStyle))
            {
                // Restore original settings
                SelectedStyle.RuntimeStyle.Name = oldValue;
                _tempStyleSheet.Remove(newValue);
                _tempStyleSheet[oldValue] = SelectedStyle.RuntimeStyle;

                MessageBox.Show(
                    SR.GetString(SR.Style_NameChangeCauseCircularLoop),
                    messageTitle, 
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Exclamation);

                e.CancelEdit = true;
                return;
            }

            // Raise StyleRenamed event for any styles which vere
            // renamed.
            OnStyleRenamed(
                new StyleRenamedEventArgs(
                    oldValue,
                    newValue
                )
            );
        }

        private void OnCreateNewStyle()
        {
            String newStyleAutoID = AutoIDStyle();

            Style newStyle = (Style)Activator.CreateInstance(_currentNewStyleType);
            Debug.Assert(newStyle != null);
            newStyle.Name = newStyleAutoID;

            // Add this style to StyleSheet
            _tempStyleSheet[newStyle.Name] = newStyle;
            newStyle.SetControl(_tempStyleSheet);

            StyleNode newStyleItem = new StyleNode(newStyle);

            _tvDefinedStyles.Enabled = true;
            _propertyBrowser.Enabled = true;
            _tvDefinedStyles.Nodes.Add(newStyleItem);
            SelectedStyle = newStyleItem;

            UpdateSamplePreview();
            UpdateButtonsEnabling();
        }

        private void OnClickOKButton(Object sender, EventArgs e)
        {
            SaveComponent();
            Close();
            DialogResult = DialogResult.OK;
        }

        private void OnClickHelpButton(Object sender, EventArgs e)
        {
            ShowHelpTopic();
        }

        private void OnHelpRequested(Object Control, HelpEventArgs hevent)
        {
            ShowHelpTopic();
            hevent.Handled = true;
        }

        private void OnStylesSelected(Object sender, TreeViewEventArgs e)
        {
            UpdateTypeText();
            UpdatePropertyGrid();
            UpdateSamplePreview();
            UpdateButtonsEnabling();
            UpdateFieldsEnabling();
        }

        private void OnNewStyleTypeChanged(Object sender, EventArgs e)
        {
            if (_lvAvailableStyles.SelectedItems.Count != 0)
            {
                _currentNewStyleType = Type.GetType((String) _lvAvailableStyles.SelectedItems[0].SubItems[1].Text + "." + 
                                                _lvAvailableStyles.SelectedItems[0].Text, true);
                //Debug.Assert(typeof(Style).IsAssignableFrom(_currentNewStyleType), "Non style object passed in.");
            }
        }

        private void MoveSelectedNode(int direction)
        {
            Debug.Assert(direction == 1 || direction == -1);
            
            StyleNode node = SelectedStyle;
            Debug.Assert(node != null);

            int index = node.Index;
            _tvDefinedStyles.Nodes.RemoveAt(index);
            _tvDefinedStyles.Nodes.Insert(index + direction, node);
            SelectedStyle = node;
        }

        private void OnClickUpButton(Object source, EventArgs e)
        {
            MoveSelectedNode(-1);
            UpdateButtonsEnabling();
        }

        private void OnClickDownButton(Object source, EventArgs e)
        {
            MoveSelectedNode(1);
            UpdateButtonsEnabling();
         }

        private void OnClickAddButton(Object sender, EventArgs e)
        {
            OnCreateNewStyle();
        }

        internal delegate void StyleDeletedEventHandler(
            Object source, StyleDeletedEventArgs e);
        
        internal event StyleDeletedEventHandler StyleDeleted;

        private void OnStyleDeleted(StyleDeletedEventArgs e)
        {
            if(StyleDeleted != null)
            {
                StyleDeleted(this, e);
            }
        }

        private void OnClickRemoveButton(Object source, EventArgs e)
        {
            Debug.Assert(SelectedStyle != null);

            String message = SR.GetString(SR.StylesEditorDialog_DeleteStyleMessage);
            String caption = SR.GetString(SR.StylesEditorDialog_DeleteStyleCaption);

            if (System.Windows.Forms.MessageBox.Show(message,
                caption, MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.No)
            {
                return;
            }

            String deletedStyle = ((StyleNode)SelectedStyle).RuntimeStyle.Name;

            // Remove this style from temporary StyleSheet
            _tempStyleSheet.Remove(deletedStyle);
            ((StyleNode)SelectedStyle).Dispose();

            int selectedIndex = SelectedStyle.Index;
            int stylesCount = _tvDefinedStyles.Nodes.Count;

            _tvDefinedStyles.Nodes.RemoveAt(selectedIndex);
            OnStyleDeleted(new StyleDeletedEventArgs(deletedStyle));

            if (selectedIndex < stylesCount-1)
            {
                SelectedStyle = (StyleNode) _tvDefinedStyles.Nodes[selectedIndex];
            }
            else if (selectedIndex >= 1)
            {
                SelectedStyle = (StyleNode) _tvDefinedStyles.Nodes[selectedIndex-1];
            }
            else if (stylesCount == 1)
            {
                SelectedStyle = null;
                UpdateTypeText();
                UpdatePropertyGrid();
                UpdateSamplePreview();
                UpdateButtonsEnabling();
                UpdateFieldsEnabling();
            }        
        }

        private void OnDoubleClick(Object sender, EventArgs e)
        {
            OnCreateNewStyle();
        }

        private void OnKeyDown(Object sender, KeyEventArgs e)
        {
            switch(e.KeyData)
            {
                case Keys.F2:
                {
                    if(SelectedStyle != null)
                    {
                        SelectedStyle.BeginEdit();
                    }
                    break;
                }
                case (Keys.Control | Keys.Home):
                {
                    if(_tvDefinedStyles.Nodes.Count > 0)
                    {
                        SelectedStyle = (StyleNode)_tvDefinedStyles.Nodes[0];
                    }
                    break;
                }
                case (Keys.Control | Keys.End):
                {
                    int numNodes = _tvDefinedStyles.Nodes.Count;
                    if(numNodes > 0)
                    {
                        SelectedStyle = (StyleNode)_tvDefinedStyles.Nodes[numNodes - 1];
                    }
                    break;
                }
            }
        }

        private void OnListMouseUp(Object sender, MouseEventArgs e)
        {
            _editCandidateNode= null;
            if (e.Button == MouseButtons.Right)
            {
                _editCandidateNode = (TreeNode)_tvDefinedStyles.GetNodeAt (e.X, e.Y);
            }
        }

        private void OnListMouseDown(Object sender, MouseEventArgs e)
        {
            _editCandidateNode = null;
            if (e.Button == MouseButtons.Right)
            {
                _editCandidateNode = (TreeNode)_tvDefinedStyles.GetNodeAt (e.X, e.Y);
            }
        }
        
        private void OnPopup(Object sender, EventArgs e)
        {
            _cntxtMenuItem.Enabled = (_editCandidateNode != null ||
                                                    _tvDefinedStyles.SelectedNode != null);
        }

        private void OnContextMenuItemClick(Object sender, EventArgs e)
        {
            if(_editCandidateNode == null)
            {
                // context menu key pressed
                if (_tvDefinedStyles.SelectedNode != null)
                {
                    _tvDefinedStyles.SelectedNode.BeginEdit();
                }
            }
            else
            {
                // right mouseclick
                _editCandidateNode.BeginEdit();
            }
            _editCandidateNode = null;
        }

        private void OnPropertyValueChanged(Object sender, PropertyValueChangedEventArgs e)
        {
            if (SelectedStyle == null)
            {
                return;
            }

            UpdateSamplePreview();
        }

        /*
         *  END EVENT HANDLING
         */

        private bool ReferencesContainCycle(StyleNode startingStyleItem)
        {
            StyleNode currentStyleItem = startingStyleItem;
            Style currentStyle = currentStyleItem.RuntimeStyle;
            String reference = currentStyle.StyleReference;
            bool found = true;
            bool cycle = false;

            // Clear referenced boolean
            foreach (StyleNode styleNode in _tvDefinedStyles.Nodes)
            {
                styleNode.Referenced = false;
            }

            // Set current style as referenced.
            currentStyleItem.Referenced = true;

            while ((reference != null && reference.Length > 0) && found && !cycle)
            {
                found = false;
                foreach (StyleNode styleNode in _tvDefinedStyles.Nodes)
                {
                    Style style = styleNode.RuntimeStyle;
                    if (0 == String.Compare(style.Name, reference, true, CultureInfo.InvariantCulture))
                    {
                        reference = style.StyleReference;
                        found = true;
                        if (styleNode.Referenced)
                        {
                            cycle = true;
                        }
                        else
                        {
                            styleNode.Referenced = true;
                        }
                        break;
                    }
                }

                // keep on looking. 
                // It depends on whether a style defined in web.config can have a reference or not.

/*              if we do need to keep on looking we need to store the Referenced flag
                // for those styles as well.
                // If not found, check default styles
                if (!found)
                {
                    if (null != StyleSheet.Default[reference])
                    {
                        Style style = StyleSheet.Default[reference];
                        reference = style.Reference;
                        found = true;
                        // get styleNode from other list
                        if (styleNode.Referenced)
                        {
                            cycle = true;
                        }
                        else
                        {
                            styleNode.Referenced = true;
                        }
                        break;
                    }
                }
*/
            }

            return cycle;
        }

        /// <summary>
        ///   Apply the currently selected style to the preview label.
        ///   This function should only be called after making sure that there is no
        ///   cycle that starts with _tvDefinedStyles.SelectedItem
        /// </summary>
        private void ApplyStyle()
        {
            StyleNode     currentStyleItem = (StyleNode)SelectedStyle;
            Style         currentStyle     = currentStyleItem.RuntimeStyle;

            Color         foreColor        = currentStyle.ForeColor;
            Color         backColor        = currentStyle.BackColor;
            BooleanOption fontBold         = currentStyle.Font.Bold;
            BooleanOption fontItalic       = currentStyle.Font.Italic;
            FontSize      fontSize         = currentStyle.Font.Size;
            String        fontName         = currentStyle.Font.Name;
            String        reference        = currentStyle.StyleReference;

            bool found = true;

            while ((reference != null && reference.Length > 0) && found)
            {
                found = false;
                foreach (StyleNode styleNode in _tvDefinedStyles.Nodes)
                {
                    Style style = styleNode.RuntimeStyle;
                    if (0 == String.Compare(style.Name, reference, true, CultureInfo.InvariantCulture))
                    {
                        if (foreColor == Color.Empty)
                        {
                            foreColor = style.ForeColor;
                        }
                        if (backColor == Color.Empty)
                        {
                            backColor = style.BackColor;
                        }
                        if (fontBold == BooleanOption.NotSet)
                        {
                            fontBold = style.Font.Bold;
                        }
                        if (fontItalic == BooleanOption.NotSet)
                        {
                            fontItalic = style.Font.Italic;
                        }
                        if (fontSize == FontSize.NotSet)
                        {
                            fontSize = style.Font.Size;
                        }
                        if (fontName == String.Empty)
                        {
                            fontName = style.Font.Name;
                        }
                        reference = style.StyleReference;
                        found = true;
                        break;
                    }
                }

                // If not found, check default styles
                if (!found)
                {
                    if (null != StyleSheet.Default[reference])
                    {
                        Style style = StyleSheet.Default[reference];
                        if (foreColor == Color.Empty)
                        {
                            foreColor = style.ForeColor;
                        }
                        if (backColor == Color.Empty)
                        {
                            backColor = style.BackColor;
                        }
                        if (fontBold == BooleanOption.NotSet)
                        {
                            fontBold = style.Font.Bold;
                        }
                        if (fontItalic == BooleanOption.NotSet)
                        {
                            fontItalic = style.Font.Italic;
                        }
                        if (fontSize == FontSize.NotSet)
                        {
                            fontSize = style.Font.Size;
                        }
                        if (fontName == String.Empty)
                        {
                            fontName = style.Font.Name;
                        }
                        reference = null;
                        found = true;
                        break;
                    }
                }
            }

            _previewStyle.ForeColor = foreColor;
            _previewStyle.BackColor = backColor;
            _previewStyle.Font.Name  = fontName;
            _previewStyle.Font.Size  = fontSize;
            _previewStyle.Font.Bold = fontBold;
            _previewStyle.Font.Italic = fontItalic;
        }

        /*
         *   BEGIN INTERNAL CLASS
         */

        [
            System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        private class StyleNode : TreeNode
        {
            private String          _fullName;
            private bool            _referenced;
            private Style           _runtimeStyle;
            private EventHandler    _styleReferenceChanged;
            private String          _styleReference;
   
            internal StyleNode(Style style)
            {
                _runtimeStyle = style;
                _fullName = style.GetType().FullName;
                _styleReference = RuntimeStyle.StyleReference;
                _styleReferenceChanged = new EventHandler(this.OnStyleReferenceChanged);
                base.Text = RuntimeStyle.Name;


                PropertyDescriptor property;
                property = TypeDescriptor.GetProperties(typeof(Style))["StyleReference"];
                Debug.Assert(property != null);
                property.AddValueChanged(RuntimeStyle, _styleReferenceChanged);
            }

            internal Style RuntimeStyle
            {
                get
                {
                    return _runtimeStyle;
                }
            }

            internal bool Referenced
            {
                get
                {
                    return _referenced;
                }

                set
                {
                    _referenced = value;
                }
            }

            internal String FullName
            {
                get
                {
                    return _fullName;
                }
            }

            internal void Dispose()
            {
                PropertyDescriptor property;
                property = TypeDescriptor.GetProperties(typeof(Style))["StyleReference"];
                Debug.Assert(property != null);
                property.RemoveValueChanged(RuntimeStyle, _styleReferenceChanged);
            }

            // Note that it return false if any of the referenced styles are already in a loop
            // ie. it returns true if and only if current style is in a loop now.
            private bool InCircularLoop()
            {
                StyleSheet styleSheet = (StyleSheet)RuntimeStyle.Control;
                Debug.Assert(styleSheet != null);

                String reference = RuntimeStyle.StyleReference;
                int count = styleSheet.Styles.Count + 1;

                while ((reference != null && reference.Length > 0) && count > 0)
                {
                    if (0 == String.Compare(RuntimeStyle.Name, reference, true, CultureInfo.InvariantCulture))
                    {
                        return true;
                    }
                    else
                    {
                        Style style = styleSheet[reference];
                        if (null != style)
                        {
                            reference = style.StyleReference;
                            count --;
                        }
                        else
                        {
                            reference = null;
                        }
                    }
                }

                return false;
            }

            private void OnStyleReferenceChanged(Object sender, EventArgs e)
            {
                if (InCircularLoop())
                {
                    RestoreStyleReference();
                    // new style reference creates a cycle
                    throw new Exception(SR.GetString(SR.Style_ReferenceCauseCircularLoop));
                }

                CacheStyleReference();
            }

            private void RestoreStyleReference()
            {
                RuntimeStyle.StyleReference = _styleReference;
            }

            private void CacheStyleReference()
            {
                _styleReference = RuntimeStyle.StyleReference;
            }
        }
    }

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class StyleRenamedEventArgs : EventArgs
    {
        private String _oldName;
        private String _newName;
        
        internal StyleRenamedEventArgs(
            String oldName,
            String newName)
        {
            _oldName = oldName;
            _newName = newName;
        }

        internal String OldName
        {
            get
            {
                return _oldName;
            }
        }

        internal String NewName
        {
            get
            {
                return _newName;
            }
        }

    }

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class StyleDeletedEventArgs : EventArgs
    {
        private String _name;
        
        internal StyleDeletedEventArgs(String name)
        {
            _name = name;
        }

        internal String Name
        {
            get
            {
                return _name;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\designeradapterutil.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerAdapterUtil.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Diagnostics;
using System.Web.UI.Design;
using System.Web.UI.Design.MobileControls;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class DesignerAdapterUtil
    {
        // margin width is 10px on right (10px on left taken care of by parentChildOffset)
        private const int _marginWidth = 10;
        // default Panel or Form width
        private const int _defaultContainerWidth = 300;
        // 11px on the left and the right for padding and margin between levels
        private const int _marginPerLevel = 22;
        // offset of control within a template is 10px on the left + 11px on the right + 1
        private const int _templateParentChildOffset = 22;
        // offset of control outside of a template is 11px
        private const int _regularParentChildOffset = 11;

        // default width for controls in templates. The value doesn't matter as long as it is 
        // equal or larger than parent width, since the parent control designer will still 
        // truncate to 100%
        internal const int CONTROL_MAX_WIDTH_IN_TEMPLATE = 300;
        internal const byte CONTROL_IN_TEMPLATE_NONEDIT = 0x01;
        internal const byte CONTROL_IN_TEMPLATE_EDIT    = 0x02;
 
        internal static IDesigner ControlDesigner(IComponent component)
        {
            Debug.Assert(null != component);
            ISite compSite = component.Site;

            if (compSite != null)
            {
                return ((IDesignerHost) compSite.GetService(typeof(IDesignerHost))).GetDesigner(component);
            }
            return null;
        }

        internal static ContainmentStatus GetContainmentStatus(Control control)
        {
            ContainmentStatus containmentStatus = ContainmentStatus.Unknown;
            Control parent = control.Parent;

            if (control == null || parent == null)
            {
                return containmentStatus;
            }

            if (parent is Form)
            {
                containmentStatus = ContainmentStatus.InForm;
            }
            else if (parent is Panel)
            {
                containmentStatus = ContainmentStatus.InPanel;
            }
            else if (parent is Page || parent is UserControl)
            {
                containmentStatus = ContainmentStatus.AtTopLevel;
            }
            else if (InTemplateFrame(control))
            {
                containmentStatus = ContainmentStatus.InTemplateFrame;
            }

            return containmentStatus;
        }

        internal static IComponent GetRootComponent(IComponent component)
        {
            Debug.Assert(null != component);
            ISite compSite = component.Site;

            if (compSite != null)
            {
                IDesignerHost host = (IDesignerHost)compSite.GetService(typeof(IDesignerHost));
                if (host != null)
                {
                    return host.RootComponent;
                }
            }

            return null;
        }

        internal static String GetWidth(Control control)
        {
            if (DesignerAdapterUtil.GetContainmentStatus(control) == ContainmentStatus.AtTopLevel)
            {
                return Constants.ControlSizeAtToplevelInNonErrorMode;
            }
            return Constants.ControlSizeInContainer;
        }

        internal static bool InMobilePage(Control control)
        {
            return (control != null && control.Page is MobilePage);
        }

        internal static bool InUserControl(IComponent component)
        {
            return GetRootComponent(component) is UserControl;
        }

        internal static bool InMobileUserControl(IComponent component)
        {
            return GetRootComponent(component) is MobileUserControl;
        }

        // Returns true if the closest templateable ancestor is in template editing mode.
        internal static  bool InTemplateFrame(Control control)
        {
            if (control.Parent == null)
            {
                return false;
            }

            TemplatedControlDesigner designer = 
                ControlDesigner(control.Parent) as TemplatedControlDesigner;

            if (designer == null)
            {
                return InTemplateFrame(control.Parent);
            }

            if (designer.InTemplateMode)
            {
                return true;
            }

            return false;
        }

        internal static  void AddAttributesToProperty(
            Type designerType,
            IDictionary properties,
            String propertyName,
            Attribute[] attributeArray)
        {
            Debug.Assert (propertyName != null && 
                propertyName.Length != 0);

            PropertyDescriptor prop = (PropertyDescriptor)properties[propertyName];
            Debug.Assert(prop != null);

            prop = TypeDescriptor.CreateProperty (
                designerType,
                prop,
                attributeArray);

            properties[propertyName] = prop;
        }

        internal static  void AddAttributesToPropertiesOfDifferentType(
            Type designerType,
            Type newType,
            IDictionary properties,
            String propertyName,
            Attribute newAttribute)
        {
            Debug.Assert (propertyName != null && 
                propertyName.Length != 0);

            PropertyDescriptor prop = (PropertyDescriptor)properties[propertyName];
            Debug.Assert(prop != null);

            // we can't create the designer DataSource property based on the runtime property since their
            // types do not match. Therefore, we have to copy over all the attributes from the runtime
            // and use them that way.
            System.ComponentModel.AttributeCollection runtimeAttributes = prop.Attributes;
            Attribute[] attrs = new Attribute[runtimeAttributes.Count + 1];
            runtimeAttributes.CopyTo(attrs, 0);

            attrs[runtimeAttributes.Count] = newAttribute;
            prop = TypeDescriptor.CreateProperty (
                designerType,
                propertyName,
                newType,
                attrs);

            properties[propertyName] = prop;
        }

        internal static  int NestingLevel(Control control, 
                                       out bool inTemplate, 
                                       out int defaultControlWidthInTemplate)
        {
            int level = -1;
            defaultControlWidthInTemplate = 0;
            inTemplate = false;
            if (control != null)
            {
                Control parent = control.Parent;
                while (parent != null)
                {
                    level++;
                    IDesigner designer = ControlDesigner(parent);
                    if (designer is MobileTemplatedControlDesigner)
                    {
                        defaultControlWidthInTemplate = 
                            ((MobileTemplatedControlDesigner) designer).TemplateWidth - 
                            _templateParentChildOffset;
                        inTemplate = true;
                        return level;
                    }
                    parent = parent.Parent;
                }
            }
            return level;
        }

        internal static  void SetStandardStyleAttributes(IHtmlControlDesignerBehavior behavior, 
                                                      ContainmentStatus containmentStatus)
        {
            bool controlAtTopLevel = (containmentStatus == ContainmentStatus.AtTopLevel);

            Color cw = SystemColors.Window;
            Color ct = SystemColors.WindowText;
            Color c = Color.FromArgb((Int16)(ct.R * 0.1 + cw.R * 0.9),
                (Int16)(ct.G * 0.1 + cw.G * 0.9),
                (Int16)(ct.B * 0.1 + cw.B * 0.9));
            behavior.SetStyleAttribute("borderColor", true, ColorTranslator.ToHtml(c), true);
            behavior.SetStyleAttribute("borderStyle", true, "solid", true);
                        
            behavior.SetStyleAttribute("borderWidth", true, "1px", true);
            behavior.SetStyleAttribute("marginLeft", true, "5px", true);
            behavior.SetStyleAttribute("marginRight", true, controlAtTopLevel ? "30%" : "5px", true);
            behavior.SetStyleAttribute("marginTop", true, controlAtTopLevel ? "5px" : "2px", true);
            behavior.SetStyleAttribute("marginBottom", true, controlAtTopLevel ? "5px" : "2px", true);
        }

        internal static  String GetDesignTimeErrorHtml(
            String errorMessage, 
            bool infoMode,
            Control control,
            IHtmlControlDesignerBehavior behavior,
            ContainmentStatus containmentStatus)
        {
            String id = String.Empty;
            Debug.Assert(control != null, "control is null");

            if (control.Site != null)
            {
                id = control.Site.Name;
            }
            behavior.SetStyleAttribute("borderWidth", true, "0px", true);

            return String.Format(MobileControlDesigner.defaultErrorDesignTimeHTML, 
                new Object[]
                {
                    control.GetType().Name,
                    id,
                    errorMessage,
                    infoMode? MobileControlDesigner.infoIcon : MobileControlDesigner.errorIcon,
                    ((containmentStatus == ContainmentStatus.AtTopLevel) ? 
                    Constants.ControlSizeAtToplevelInErrormode : 
                    Constants.ControlSizeInContainer)
                });
        }

        internal static  int GetMaxWidthToFit(MobileControl control, out byte templateStatus)
        {
            IDesigner parentDesigner = ControlDesigner(control.Parent);
            IDesigner controlDesigner = ControlDesigner(control);
            int defaultControlWidthInTemplate;

            NativeMethods.IHTMLElement2 htmlElement2Parent = null;
            
            if (controlDesigner == null)
            {
                templateStatus = CONTROL_IN_TEMPLATE_NONEDIT;
                return 0;
            }
            Debug.Assert(controlDesigner is MobileControlDesigner ||
                         controlDesigner is MobileTemplatedControlDesigner, 
                         "controlDesigner is not MobileControlDesigner or MobileTemplatedControlDesigner");

            templateStatus = 0x00;
            if (parentDesigner is MobileTemplatedControlDesigner)
            {
                htmlElement2Parent =
                    (NativeMethods.IHTMLElement2) 
                    ((MobileTemplatedControlDesigner) parentDesigner).DesignTimeElement;
            }
            else if (parentDesigner is MobileContainerDesigner)
            {
                htmlElement2Parent =
                    (NativeMethods.IHTMLElement2) 
                    ((MobileContainerDesigner) parentDesigner).DesignTimeElement;
            }

            bool inTemplate;
            int nestingLevel = DesignerAdapterUtil.NestingLevel(control, out inTemplate, out defaultControlWidthInTemplate);
            if (inTemplate)
            {
                templateStatus = CONTROL_IN_TEMPLATE_EDIT;
            }

            if (htmlElement2Parent != null)
            {
                int maxWidth;
                if (!inTemplate)
                {
                    Debug.Assert(control.Parent is MobileControl);
                    Style parentStyle = ((MobileControl) control.Parent).Style;
                    Alignment alignment = (Alignment) parentStyle[Style.AlignmentKey, true];
                    int parentChildOffset;

                    // AUI 2786
                    if (alignment != Alignment.NotSet && alignment != Alignment.Left)
                    {
                        parentChildOffset = _regularParentChildOffset;
                    }
                    else
                    {
                        NativeMethods.IHTMLRectCollection rectColl;
                        NativeMethods.IHTMLRect rect;
                        int index = 0;
                        Object obj = index;

                        NativeMethods.IHTMLElement2 htmlElement2;
                        
                        if (controlDesigner is MobileControlDesigner)
                        { 
                            htmlElement2 = (NativeMethods.IHTMLElement2) ((MobileControlDesigner) controlDesigner).DesignTimeElement;
                        }
                        else
                        {
                            htmlElement2 = (NativeMethods.IHTMLElement2) ((MobileTemplatedControlDesigner) controlDesigner).DesignTimeElement;
                        }

                        if (null == htmlElement2)
                        {
                            return 0;
                        }

                        try
                        {
                            rectColl = htmlElement2.GetClientRects();
                        }
                        catch (Exception)
                        {
                            // this happens when switching from Design view to HTML view
                            return 0;
                        }
                        Debug.Assert(rectColl.GetLength() == 1, "rectColl.GetLength() != 1");

                        rect = (NativeMethods.IHTMLRect) rectColl.Item(ref obj);
                        parentChildOffset = rect.GetLeft();

                        rectColl = htmlElement2Parent.GetClientRects();
                        Debug.Assert(rectColl.GetLength() == 1);
                        rect = (NativeMethods.IHTMLRect) rectColl.Item(ref obj);
                        parentChildOffset -= rect.GetLeft();
                    }

                    maxWidth = htmlElement2Parent.GetClientWidth() - _marginWidth - parentChildOffset;
                    if (maxWidth > 0 && maxWidth > _defaultContainerWidth - nestingLevel * _marginPerLevel)
                    {
                        maxWidth = _defaultContainerWidth - nestingLevel * _marginPerLevel;
                    }
                }
                else
                {
                    int parentWidth = htmlElement2Parent.GetClientWidth();
                    if (parentWidth == 0)
                    {
                        // AUI 4525
                        maxWidth = defaultControlWidthInTemplate;
                    }
                    else
                    {
                        maxWidth = parentWidth - _templateParentChildOffset;
                    }

                    if (maxWidth > 0 && maxWidth > defaultControlWidthInTemplate - nestingLevel * _marginPerLevel)
                    {
                        maxWidth = defaultControlWidthInTemplate - nestingLevel * _marginPerLevel;
                    }
                }
                return maxWidth;
            }
            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\validationsummarydesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValidationSummaryDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.IO;
    using System.Web.UI;
    using System.Web.UI.Design;
    using System.Web.UI.MobileControls;
    using System.Web.UI.Design.MobileControls.Adapters;

    /// <summary>
    ///    <para>
    ///       Provides a designer for the <see cref='System.Web.UI.MobileControls.ValidationSummary'/>
    ///       control.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.Web.UI.MobileControls.ValidationSummary'/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class ValidationSummaryDesigner : MobileControlDesigner
    {
        private System.Web.UI.MobileControls.ValidationSummary _validationSummary;

        /// <summary>
        ///    <para>
        ///       Initializes the designer.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element being designed.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component being
        ///       designed.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.ValidationSummary,
                         "ValidationSummaryDesigner.Initialize - Invalid ValidationSummary Control");
            _validationSummary = (System.Web.UI.MobileControls.ValidationSummary) component;
            base.Initialize(component);
        }

        /// <summary>
        ///    <para>
        ///       Gets the HTML to be used for the design time representation of the control runtime.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The design time HTML.
        ///    </para>
        /// </returns>
        protected override String GetDesignTimeNormalHtml()
        {
            DesignerTextWriter tw = new DesignerTextWriter();
            _validationSummary.Adapter.Render(tw);

            return tw.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\designeradrotatoradapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerAdRotatorAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.Web.Mobile;
using System.Web.UI.Design.MobileControls;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerAdRotatorAdapter : HtmlControlAdapter
    {
        public override MobileCapabilities Device
        {
            get
            {
                return DesignerCapabilities.Instance;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            Alignment alignment = (Alignment)Style[Style.AlignmentKey, true];
            String width = DesignerAdapterUtil.GetWidth(Control);

            byte templateStatus;
            int maxWidth = DesignerAdapterUtil.GetMaxWidthToFit(Control, out templateStatus);

            if (templateStatus == DesignerAdapterUtil.CONTROL_IN_TEMPLATE_EDIT)
            {
                width = maxWidth.ToString() + "px";
            }

            writer.WriteBeginTag("div");
            if (alignment == Alignment.Center)
            {
                writer.WriteAttribute("align", "center");
            }
            writer.WriteAttribute("style", "padding=2px;overflow-x:hidden;width:" + width);
            writer.Write(">");

            ((DesignerTextWriter)writer).EnterZeroFontSizeTag();

            writer.WriteBeginTag("img");
            writer.WriteAttribute("alt", Control.ID);
            ((DesignerTextWriter)writer).WriteStyleAttribute(Style);

            // center alignment not part of HTML for images.
            if (alignment == Alignment.Right ||
                alignment == Alignment.Left)
            {
                writer.WriteAttribute("align", Enum.GetName(typeof(Alignment), alignment));
            }

            writer.WriteAttribute("height", "40");
            writer.WriteAttribute("width", "250");
            writer.WriteAttribute("border", "0");
            writer.Write(">");

            ((DesignerTextWriter)writer).ExitZeroFontSizeTag();
            writer.WriteEndTag("div");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\stylesheetdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="StyleSheetDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing.Design;
    using System.Globalization;
    using System.Text;
    using System.Web.UI;
    using System.Web.UI.Design;
    using System.Web.UI.Design.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Converters;
    using System.Web.UI.Design.MobileControls.Util;
    using System.Web.UI.MobileControls;
    using System.Windows.Forms;

    using Control = System.Web.UI.Control;
    using DataBindingCollectionEditor = System.Web.UI.Design.DataBindingCollectionEditor;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class StyleSheetDesigner : MobileTemplatedControlDesigner, IDeviceSpecificDesigner
    {
        internal static BooleanSwitch StyleSheetDesignerSwitch =
            new BooleanSwitch("StyleSheetDesigner", "Enable StyleSheet designer general purpose traces.");

        private IWebFormsDocumentService _iWebFormsDocumentService;
        private IRefreshableDeviceSpecificEditor _deviceSpecificEditor;
        private DesignerVerbCollection _designerVerbs;
        private System.Web.UI.MobileControls.StyleSheet _styleSheet;
        private Style _currentStyle, _tmpCurrentStyle;
        private bool _isDuplicate;
        private MergedUI _mergedUI = null;
        private ArrayList _cycledStyles = null;
        private const int _templateWidth = 300;
        private static bool _requiresDesignTimeChanges = false;
        private bool _shouldRepersistStyles = false;
        private EventHandler _loadComplete = null;

        private const String _templatesStylePropName = "TemplateStyle";
        private const String _persistedStylesPropName = "PersistedStyles";

        private const String _designTimeHTML =
            @"
                <table cellpadding=4 cellspacing=0 width='300px' style='font-family:tahoma;font-size:8pt;color:buttontext;background-color:buttonface;border: solid 1px;border-top-color:buttonhighlight;border-left-color:buttonhighlight;border-bottom-color:buttonshadow;border-right-color:buttonshadow'>
                  <tr><td colspan=2><span style='font-weight:bold'>StyleSheet</span> - {0}</td></tr>
                  <tr><td style='padding-top:0;padding-bottom:0;width:55%;padding-left:10px;font-weight:bold'>Template Style:</td><td style='padding-top:0;padding-bottom:0'>{1}</td></tr>
                  <tr><td style='padding-top:0;padding-bottom:0;width:55%;padding-left:10px;font-weight:bold'>Template Device Filter:</td><td style='padding-top:0;padding-bottom:0'>{2}</td></tr>
                  <tr><td colspan=2 style='padding-top:4px'>{3}</td></tr>
                </table>
             ";

        private const String _specialCaseDesignTimeHTML =
            @"
                <table cellpadding=4 cellspacing=0 width='300px' style='font-family:tahoma;font-size:8pt;color:buttontext;background-color:buttonface;border: solid 1px;border-top-color:buttonhighlight;border-left-color:buttonhighlight;border-bottom-color:buttonshadow;border-right-color:buttonshadow'>
                  <tr><td colspan=2><span style='font-weight:bold'>StyleSheet</span> - {0}</td></tr>
                  <tr><td style='padding-top:0;padding-bottom:0;width:55%;padding-left:10px;font-weight:bold'>Template Style:</td><td style='padding-top:0;padding-bottom:0'>{1}</td></tr>
                  <tr><td style='padding-top:0;padding-bottom:0;width:55%;padding-left:10px;font-weight:bold'>Template Device Filter:</td><td style='padding-top:0;padding-bottom:0'>{2}</td></tr>
                  <tr><td colspan=2 style='padding-top:4px'>{3}</td></tr>
                  <tr><td colspan=2>
                    <table style='font-size:8pt;color:window;background-color:ButtonShadow'>
                      <tr><td valign='top'><img src='{4}'/></td><td>{5}</td></tr>
                    </table>
                  </td></tr>
                </table>
             ";

        private const int _headerFooterTemplates            = 0;
        private const int _itemTemplates                    = 1;
        private const int _separatorTemplate                = 2;
        private const int _contentTemplate                  = 3;
        private const int _numberOfTemplateFrames           = 4;

        private static readonly String[][] _templateFrameNames =
            new String[][] {
                               new String [] { Constants.HeaderTemplateTag, Constants.FooterTemplateTag },
                               new String [] { Constants.ItemTemplateTag, Constants.AlternatingItemTemplateTag, Constants.ItemDetailsTemplateTag },
                               new String [] { Constants.SeparatorTemplateTag },
                               new String [] { Constants.ContentTemplateTag }
                           };

        private const String _templateStyle = "__TemplateStyle__";

        // used by DesignerAdapterUtil.GetMaxWidthToFit
        // and needs to be exposed in object model because
        // custom controls may need to access the value just like
        // DesignerAdapterUtil.GetMaxWidthToFit does.
        public override int TemplateWidth
        {
            get
            {
                return _templateWidth;
            }
        }

        private MobilePage MobilePage
        {
            get
            {
                IComponent component = DesignerAdapterUtil.GetRootComponent(Component);
                if (component is MobileUserControl)
                {
                    return ((Control)component).Page as MobilePage;
                }
                return component as MobilePage;
            }
        }

        private Control RootControl
        {
            get
            {
                IComponent component = DesignerAdapterUtil.GetRootComponent(Component);
                return component as Control;
            }
        }

        /// <summary>
        ///    <para>
        ///       Initializes the designer.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element being designed.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component being
        ///       designed.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.StyleSheet,
                         "StyleSheetDesigner.Initialize - Invalid StyleSheet Control");
            base.Initialize(component);

            _isDuplicate = false;
            _styleSheet = (System.Web.UI.MobileControls.StyleSheet) component;
            if(_requiresDesignTimeChanges)
            {
                _shouldRepersistStyles = true;
            }
            _loadComplete = new EventHandler(this.OnLoadComplete);
            IWebFormsDocumentService.LoadComplete += _loadComplete;

            if (IMobileWebFormServices != null)
            {
                TemplateStyle = (String) IMobileWebFormServices.GetCache(_styleSheet.ID, _templateStyle);
                TemplateDeviceFilter = 
                    (String) IMobileWebFormServices.GetCache(
                    _styleSheet.ID,
                    MobileTemplatedControlDesigner.DefaultTemplateDeviceFilter);
            }
        }

        private void OnLoadComplete(Object source, EventArgs e) 
        {
            if(_shouldRepersistStyles)
            {
                IsDirty = true;
                OnInternalChange();
            }
            _requiresDesignTimeChanges = false;
            _shouldRepersistStyles = false;
        }
        
        internal static void SetRequiresDesignTimeChanges()
        {
            _requiresDesignTimeChanges = true;
        }

        private IWebFormsDocumentService IWebFormsDocumentService
        {
            get
            {
                if (_iWebFormsDocumentService == null)
                {
                    _iWebFormsDocumentService =
                        (IWebFormsDocumentService)GetService(typeof(IWebFormsDocumentService));

                    Debug.Assert(_iWebFormsDocumentService != null);
                }

                return _iWebFormsDocumentService;
            }
        }
        
        protected override ITemplateEditingFrame CreateTemplateEditingFrame(TemplateEditingVerb verb)
        {
            ITemplateEditingService teService = 
                (ITemplateEditingService)GetService(typeof(ITemplateEditingService));
            Debug.Assert(teService != null,
                "How did we get this far without an ITemplateEditingService");

            String[] templateNames = GetTemplateFrameNames(verb.Index);
            ITemplateEditingFrame editingFrame = teService.CreateFrame(
                this, 
                TemplateDeviceFilter + " (" + TemplateStyle + ")",
                templateNames,
                WebCtrlStyle,
                null /* we don't have template styles */);

            editingFrame.InitialWidth = _templateWidth;
            return editingFrame;
        }

        protected override void Dispose(bool disposing) 
        {
            if (disposing) 
            {
                UpdateActiveStyleSheet();
                
                if (_loadComplete != null)
                {
                    IWebFormsDocumentService.LoadComplete -= _loadComplete;
                    _loadComplete = null;
                }

                if (IMobileWebFormServices != null)
                {
                    // If the page is in loading mode, it means the remove is trigged by webformdesigner.
                    if (!LoadComplete)
                    {
                        IMobileWebFormServices.SetCache(_styleSheet.ID, (Object) _templateStyle, (Object) this.TemplateStyle);
                    }
                    else
                    {
                        // setting to null will remove the entry.
                        IMobileWebFormServices.SetCache(_styleSheet.ID, (Object) _templateStyle, null);
                    }
                }
            }

            base.Dispose(disposing);
        }

        private void UpdateActiveStyleSheet()
        {
            if (MobilePage != null && MobilePage.StyleSheet == _styleSheet)
            {
                IDesigner designer = null;

                // currently active stylesheet is deleted
                MobilePage.StyleSheet = StyleSheet.Default;
                StyleSheet _newStyleSheet = null;

                Debug.Assert(RootControl != null);
                foreach (Control control in RootControl.Controls)
                {
                    // Find new stylesheet
                    if (control is StyleSheet && _newStyleSheet == null && control != _styleSheet)
                    {
                        designer = Host.GetDesigner((IComponent) control);
                        // AUI 7285
                        if (designer != null)
                        {
                            _newStyleSheet = (StyleSheet) control;
                        }
                    }
                }

                MobilePage.StyleSheet = _newStyleSheet;
                if (null != _newStyleSheet)
                {
                    Debug.Assert(designer != null);
                    StyleSheetDesigner ssd = designer as StyleSheetDesigner;
                    Debug.Assert(ssd != null, "ssd is null in StyleSheetDesigner");
                    ssd.TreatAsDuplicate(false);
                }
                RefreshPageView();
            }
        }
        
        protected override String[] GetTemplateFrameNames(int index)
        {
            Debug.Assert(index >= 0 & index <= _templateFrameNames.Length);
            return _templateFrameNames[index];
        }

        protected override TemplateEditingVerb[] GetTemplateVerbs()
        {
            TemplateEditingVerb[] templateVerbs = new TemplateEditingVerb[_numberOfTemplateFrames];

            templateVerbs[_headerFooterTemplates] = new TemplateEditingVerb(
                SR.GetString(SR.TemplateFrame_HeaderFooterTemplates),
                _headerFooterTemplates,
                this);
            templateVerbs[_itemTemplates] = new TemplateEditingVerb(
                SR.GetString(SR.TemplateFrame_ItemTemplates),
                _itemTemplates,
                this);
            templateVerbs[_separatorTemplate] = new TemplateEditingVerb(
                SR.GetString(SR.TemplateFrame_SeparatorTemplate),
                _separatorTemplate,
                this);
            templateVerbs[_contentTemplate] = new TemplateEditingVerb(
                SR.GetString(SR.TemplateFrame_ContentTemplate),
                _contentTemplate,
                this);

            return templateVerbs;
        }

        /// <summary>
        ///    <para>
        ///       Delegate to handle component changed event.
        ///    </para>
        /// </summary>
        /// <param name='sender'>
        ///    The object sending the event.
        /// </param>
        /// <param name='ce'>
        ///    The event object used when firing a component changed notification.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called after a property has been changed. It allows the implementor
        ///       to do any post-processing that may be needed after a property change.
        ///    </para>
        /// </remarks>
        public override void OnComponentChanged(Object sender, ComponentChangedEventArgs ce) 
        {
            // Delegate to the base class implementation first!
            base.OnComponentChanged(sender, ce);

            MemberDescriptor member = ce.Member;
            if (member != null && 
                member.GetType().FullName.Equals(Constants.ReflectPropertyDescriptorTypeFullName))
            {
                PropertyDescriptor propDesc = (PropertyDescriptor)member;
                
                if (propDesc.Name.Equals("ID"))
                {
                    // Update the dictionary of device filters stored in the page designer
                    // setting to null will remove the entry.
                    IMobileWebFormServices.SetCache(ce.OldValue.ToString(), (Object) _templateStyle, null);
                }
            }
        }

        internal void OnStylesChanged()
        {
            // If this is not a new stylesheet and it is the current stylesheet
            if (MobilePage != null && MobilePage.StyleSheet == _styleSheet)
            {
                // Refresh the whole page assuming styles have been changed.
                RefreshPageView();
                ClearCycledStyles();
            }
        }

        private void RefreshPageView()
        {
            if (IMobileWebFormServices != null)
            {
                IMobileWebFormServices.RefreshPageView();
            }
        }

        public override void OnSetParent() 
        {
            base.OnSetParent();

            // This is not a MobilePage or the styleSheet is already the active styleSheet.
            // The latter happens when the active StyleSheet is drag/drop to another location
            // which forces its parent to be changed.
            if (MobilePage == null)
            {
                return;
            }

            if (MobilePage.StyleSheet == _styleSheet)
            {
                if (!(_styleSheet.Parent is MobilePage
                    || _styleSheet.Parent is MobileUserControl))
                {
                    UpdateActiveStyleSheet();
                }
                return;
            }

            if (MobilePage.StyleSheet != StyleSheet.Default) 
            {
                // can't accept more than 1 stylesheet
                TreatAsDuplicate(true);

                // the current valid StyleSheet is intentionaly refreshed because
                // if this stylesheet instance is recreated via a Undo operation
                // the current valid StyleSheet appears as a duplicate if not refreshed.
                IDesigner designer = Host.GetDesigner((IComponent) MobilePage.StyleSheet);
                Debug.Assert(designer != null, "designer is null in StyleSheetDesigner");
                StyleSheetDesigner ssd = (StyleSheetDesigner) designer;
                ssd.UpdateRendering();
            }
            else if (_styleSheet.Parent is MobilePage ||
                     _styleSheet.Parent is MobileUserControl)
            {
                // the active stylesheet is changed
                MobilePage.StyleSheet = _styleSheet;
                _isDuplicate = false;
            }
            RefreshPageView();
        }

        protected override void OnTemplateModeChanged() 
        {
            base.OnTemplateModeChanged();

            // Refresh all mobilecontrols after exit template editing mode.
            if (!InTemplateMode)
            {
                RefreshPageView();
            }        
        }

        public void TreatAsDuplicate(bool isDuplicate)
        {
            if (isDuplicate != _isDuplicate)
            {
                _isDuplicate = isDuplicate;
                SetTemplateVerbsDirty();
                UpdateDesignTimeHtml();
            }
        }

        protected override bool ErrorMode
        {
            get
            {
                return base.ErrorMode
                    || _isDuplicate
                    || _styleSheet.DuplicateStyles.Count > 0;
            }
        }

        private StringCollection GetDuplicateStyleNames()
        {
            StringCollection duplicateNamesList = new StringCollection();

            // Filter out repeated duplicate names using case insensitive
            // hash table
            HybridDictionary duplicateNamesHash = new HybridDictionary(
                true /* Names not case sensitive */ );
            foreach(Style style in _styleSheet.DuplicateStyles)
            {
                duplicateNamesHash[style.Name] = true;
            }

            // Copy remaining names into a string list
            foreach(DictionaryEntry entry in duplicateNamesHash)
            {
                duplicateNamesList.Add((String)entry.Key);
            }
            return duplicateNamesList;
        }

        protected override String GetDesignTimeNormalHtml()
        {
            String curStyle, message;
            ArrayList lstStylesInCycle = null;

            if (null == CurrentStyle)
            {
                curStyle = SR.GetString(SR.StyleSheet_PropNotSet);
            }
            else
            {
                curStyle = HttpUtility.HtmlEncode(CurrentStyle.Name);
            }

            String curChoice;

            if (null == CurrentChoice)
            {
                curChoice = SR.GetString(SR.StyleSheet_PropNotSet);
            }
            else
            {
                if (String.Empty == CurrentChoice.Filter)
                {
                    curChoice = SR.GetString(SR.DeviceFilter_DefaultChoice);
                }
                else
                {
                    curChoice = HttpUtility.HtmlEncode(DesignerUtility.ChoiceToUniqueIdentifier(CurrentChoice));
                }
            }

            message = SR.GetString(SR.StyleSheet_DefaultMessage);

            bool renderErrorMsg = false;
            String errorMsg = null;
            String errorIconUrl = null;

            if(_isDuplicate)
            {
                renderErrorMsg = true;
                errorMsg = SR.GetString(SR.StyleSheet_DuplicateWarningMessage);
                errorIconUrl = MobileControlDesigner.errorIcon;
            }
            else if(_styleSheet.DuplicateStyles.Count > 0)
            {
                renderErrorMsg = true;
                errorMsg = SR.GetString(
                    SR.StyleSheet_DuplicateStyleNamesMessage,
                    GenericUI.BuildCommaDelimitedList(
                        GetDuplicateStyleNames()
                    )
                );
                errorIconUrl = MobileControlDesigner.errorIcon;
            }
            else if (null != CurrentStyle && null != CurrentChoice)
            {
                if (IsHTMLSchema(CurrentChoice))
                {
                    message = SR.GetString(SR.StyleSheet_TemplateEditingMessage);
                }
                else
                {
                    // User has selected non-html schema
                    renderErrorMsg = true;
                    errorMsg = SR.GetString(SR.StyleSheet_NonHTMLSchemaMessage);
                    errorIconUrl = MobileControlDesigner.infoIcon;
                }
            }

            if (renderErrorMsg)
            {
                Debug.Assert(errorMsg != null && errorIconUrl != null);
                return String.Format(_specialCaseDesignTimeHTML, 
                    new Object[]
                                     {
                                         _styleSheet.Site.Name,
                                         curStyle,
                                         curChoice,
                                         message,
                                         errorIconUrl,
                                         errorMsg
                                     });
            }
            else
            {
                lstStylesInCycle = DetectCycles();

                // REVIEW: This should really be merged with the above logic to
                //         choose the error rending.
                if (lstStylesInCycle != null && lstStylesInCycle.Count > 0)
                {
                    String cycledStyles = String.Empty;
                    // REVIEW: New methed GenericUI.BuildCommaDelimitedList could
                    //         be used here as well.
                    foreach (Object obj in lstStylesInCycle)
                    {
                        Style cycledStyle = (Style) obj;
                        if (cycledStyles != String.Empty)
                        {
                            cycledStyles += ", ";  
                        }
                        cycledStyles += cycledStyle.Name;
                    }
                    return String.Format(_specialCaseDesignTimeHTML, 
                        new Object[]
                                         {
                                             _styleSheet.Site.Name,
                                             curStyle,
                                             curChoice,
                                             message,
                                             MobileControlDesigner.errorIcon,
                                             String.Format(SR.GetString(SR.StyleSheet_RefCycleErrorMessage), cycledStyles)
                                         });
                }
                else
                {
                    return String.Format(_designTimeHTML, 
                        new Object[]
                                         {
                                             _styleSheet.Site.Name,
                                             curStyle,
                                             curChoice,
                                             message
                                         });
                }
            }
        }

        private void ClearCycledStyles()
        {
            _cycledStyles = null;
        }

/* O(n) algorithm for loop detection
        private HybridDictionary DetectCycles()
        {
            if (_cycledStyles == null)
            {
                _cycledStyles = new HybridDictionary();
                ICollection styles = _styleSheet.Styles;

                // Initialize the set
                Hashtable styleSet = new Hashtable(styles.Count);
                foreach (String key in styles)
                {
                    styleSet.Add(key, true);
                }

                while (styleSet.Count > 0)
                {
                    Style style = null;
                    foreach (String key in styleSet.Keys)
                    {
                        style = (Style)_styleSheet[key];
                        Debug.Assert(style != null);
                        break;
                    }

                    int count = 0;
                    Traverse(styleSet, style, count);
                }
            }
            return _cycledStyles;
        }
        
        private bool Traverse(Hashtable styleSet, Style style)
        {
            String reference = style.StyleReference;
            Style nextStyle = null;
            bool result = false;

            styleSet.Remove(style.Name.ToLower(CultureInfo.InvariantCulture));

            if (reference == null || reference.Length == 0 || 
                ((nextStyle = (Style)_styleSheet[reference]) == null) ||
                (!styleSet.Contains(nextStyle)))
            {
                result = false;
            }
            else if (_cycledStyles.Contains(nextStyle) || 
                Traverse(styleSet, nextStyle, ++count))
            {
                Debug.Assert(_cycledStyles != null);
                if (!_cycledStyles.Contains(style))
                {
                    _cycledStyles.Add(style, "");
                }
                result = true;
            }
            
            return result;
        }
*/
        private ArrayList DetectCycles()
        {
            if (_cycledStyles == null)
            {
                _cycledStyles = new ArrayList();
                ICollection styles = _styleSheet.Styles;

                foreach (String key in styles)
                {
                    Style style = (Style) _styleSheet[key];
                    Style styleTmp;
                    Debug.Assert(style != null);

                    bool cycle = false;
                    String reference = style.StyleReference;
                    String name = style.Name;

                    int count = styles.Count + 1;

                    while ((reference != null && reference.Length > 0) && count > 0)
                    {
                        if (0 == String.Compare(name, reference, true, CultureInfo.InvariantCulture))
                        {
                            cycle = true;
                            break;
                        }
                        else
                        {
                            styleTmp = _styleSheet[reference];
                            if (null != styleTmp)
                            {
                                reference = styleTmp.StyleReference;
                                count --;
                            }
                            else
                            {
                                reference = null;
                            }
                        }
                    }

                    if (cycle)
                    {
                        _cycledStyles.Add(style);
                    }
                }
            }

            return _cycledStyles;
        }

        ////////////////////////////////////////////////////////////////////////
        //  Begin IDeviceSpecificDesigner Implementation
        ////////////////////////////////////////////////////////////////////////

        void IDeviceSpecificDesigner.SetDeviceSpecificEditor
            (IRefreshableDeviceSpecificEditor editor)
        {
            _deviceSpecificEditor = editor;
        }

        String IDeviceSpecificDesigner.CurrentDeviceSpecificID
        {
            get
            {
                if (_tmpCurrentStyle == null)
                {
                    return null;
                }

                if (_styleSheet[_tmpCurrentStyle.Name] == null)
                {
                    _tmpCurrentStyle = null;
                }
                return (_tmpCurrentStyle != null) ? _tmpCurrentStyle.Name.ToLower(CultureInfo.InvariantCulture) : null;
            }
        }

        System.Windows.Forms.Control IDeviceSpecificDesigner.Header
        {
            get
            {
                return _mergedUI;
            }
        }

        System.Web.UI.Control IDeviceSpecificDesigner.UnderlyingControl
        {
            get
            {
                return _styleSheet;
            }
        }

        Object IDeviceSpecificDesigner.UnderlyingObject
        {
            get
            {
                if (null != _mergedUI.CbStyles.SelectedItem)
                {
                    String styleName = (String) _mergedUI.CbStyles.SelectedItem;
                    return _styleSheet[styleName];
                }
                else
                {
                    return null;
                }
            }
        }

        bool IDeviceSpecificDesigner.GetDeviceSpecific(String deviceSpecificParentID, out DeviceSpecific ds)
        {
            Style style = (Style) _styleSheet[deviceSpecificParentID];
            if (null == style)
            {
                ds = null;
                return false;
            }
            else
            {
                ds = style.DeviceSpecific;
                return true;
            }
        }

        void IDeviceSpecificDesigner.SetDeviceSpecific(String deviceSpecificParentID, DeviceSpecific ds)
        {
            Style style = (Style) _styleSheet[deviceSpecificParentID];
            Debug.Assert(null != style, "style is null in IDeviceSpecificDesigner.SetDeviceSpecific");
            if (null != ds)
            {
                ds.SetOwner((MobileControl) _styleSheet);
            }
            style.DeviceSpecific = ds;

            if (CurrentChoice != null && 0 == String.Compare(CurrentStyle.Name, deviceSpecificParentID, true, CultureInfo.InvariantCulture))
            {
                if (ds == null)
                {
                    CurrentChoice = null;
                }
                else
                {
                    // This makes sure that the CurrentChoice value is set to null is
                    // it was deleted during the deviceSpecific object editing
                    if (String.Empty == CurrentChoice.Filter)
                    {
                        TemplateDeviceFilter = SR.GetString(SR.DeviceFilter_DefaultChoice);
                    }
                    else
                    {
                        TemplateDeviceFilter = DesignerUtility.ChoiceToUniqueIdentifier(CurrentChoice);
                    }
                }
            }
        }

        void IDeviceSpecificDesigner.InitHeader(int mergingContext)
        {
            _mergedUI = new MergedUI();
            _mergedUI.LblStyles.Text = SR.GetString(SR.StyleSheet_StylesCaption);
            _mergedUI.LblStyles.TabIndex = 1;

            _mergedUI.CbStyles.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            _mergedUI.CbStyles.SelectedIndexChanged += new EventHandler(this.OnSelectedIndexChangedStylesComboBox);
            _mergedUI.CbStyles.TabIndex = 2;
            _mergedUI.CbStyles.Sorted = true;

            _mergedUI.BtnEdit.Text = SR.GetString(SR.Stylesheet_EditBtnCaption);
            _mergedUI.BtnEdit.Click += new EventHandler(this.OnClickEditStylesButton);
            _mergedUI.BtnEdit.TabIndex = 3;

            switch (mergingContext)
            {
                case MobileControlDesigner.MergingContextTemplates:
                {
                    _mergedUI.LblHeader.Text = SR.GetString(SR.StyleSheet_SettingTemplatingStyleChoiceDescription);

                    // AUI 2730
                    _mergedUI.CbStyles.Width = 195;
                    _mergedUI.BtnEdit.Location = new System.Drawing.Point(201, 39);
                    break;
                }

                default:
                {
                    _mergedUI.LblHeader.Text = SR.GetString(SR.StyleSheet_SettingGenericStyleChoiceDescription);

                    // AUI 2730
                    _mergedUI.CbStyles.Width = 195;
                    _mergedUI.BtnEdit.Location = new System.Drawing.Point(201, 39);
                    break;
                }
            }
        }

        void IDeviceSpecificDesigner.RefreshHeader(int mergingContext)
        {
            _mergedUI.CbStyles.Items.Clear();
            ICollection styles = _styleSheet.Styles;
            foreach (String key in styles)
            {
                Style style = (Style) _styleSheet[key];
                Debug.Assert(style != null);

                _mergedUI.CbStyles.Items.Add(style.Name);
            }

            if (_mergedUI.CbStyles.Items.Count > 0)
            {
                Debug.Assert(null != CurrentStyle);
                _mergedUI.CbStyles.SelectedItem = CurrentStyle.Name;
                _oldSelectedIndex = _mergedUI.CbStyles.SelectedIndex;
            }

            _mergedUI.CbStyles.Enabled = (_mergedUI.CbStyles.Items.Count > 0);
        }

        void IDeviceSpecificDesigner.UseCurrentDeviceSpecificID()
        {
            if (CurrentStyle != _tmpCurrentStyle)
            {
                CurrentChoice = null;
                CurrentStyle = _tmpCurrentStyle;
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  End IDeviceSpecificDesigner Implementation
        /////////////////////////////////////////////////////////////////////////

        private int _oldSelectedIndex;
        
        private void OnSelectedIndexChangedStylesComboBox(Object source, EventArgs e) 
        {
            if (_mergedUI.CbStyles.SelectedIndex != _oldSelectedIndex
                && !_deviceSpecificEditor.RequestRefresh())
            {
                // User needs to correct error before editing a new style.
                _mergedUI.CbStyles.SelectedIndex = _oldSelectedIndex;
                return;
            }
            
            if (_mergedUI.CbStyles.SelectedIndex >= 0)
            {
                _tmpCurrentStyle = (Style) _styleSheet[((String) _mergedUI.CbStyles.SelectedItem).ToLower(CultureInfo.InvariantCulture)];
                _deviceSpecificEditor.Refresh((String) _mergedUI.CbStyles.SelectedItem, _tmpCurrentStyle.DeviceSpecific);
            }
            _oldSelectedIndex = _mergedUI.CbStyles.SelectedIndex;
        }

        private void OnStyleRenamedInEditor(Object source, StyleRenamedEventArgs e)
        {
            _deviceSpecificEditor.DeviceSpecificRenamed(e.OldName, e.NewName);
        }

        private void OnStyleDeletedInEditor(Object source, StyleDeletedEventArgs e)
        {
            _deviceSpecificEditor.DeviceSpecificDeleted(e.Name);
        }

        private void OnClickEditStylesButton(Object source, EventArgs e)
        {

            StylesEditorDialog dialog;
            
            try
            {
                dialog = new StylesEditorDialog(
                    _styleSheet,
                    this,
                    (null != _tmpCurrentStyle) ? _tmpCurrentStyle.Name : null
                );
            }
            catch(ArgumentException ex)
            {
                Debug.Fail(ex.ToString());
                // Block user from entering StylesEditorDialog until they fix
                // duplicate style declarations.
                return;
            }
            
            StylesEditorDialog.StyleRenamedEventHandler renameHandler =
                new StylesEditorDialog.StyleRenamedEventHandler(OnStyleRenamedInEditor);
            StylesEditorDialog.StyleDeletedEventHandler deleteHandler =
                new StylesEditorDialog.StyleDeletedEventHandler(OnStyleDeletedInEditor);
            dialog.StyleRenamed += renameHandler;
            dialog.StyleDeleted += deleteHandler;
            try
            {
                _deviceSpecificEditor.BeginExternalDeviceSpecificEdit();
                if (dialog.ShowDialog() == DialogResult.OK)
                {
                    _deviceSpecificEditor.EndExternalDeviceSpecificEdit(
                        true /* commit changes */ );
                    OnInternalChange();

                    ((IDeviceSpecificDesigner) this).RefreshHeader(0);
                    // using mergingContext 0 because this implementation does not use the param.
                    if (_mergedUI.CbStyles.Items.Count == 0)
                    {
                        _deviceSpecificEditor.Refresh(null, null); // force the clean up and 
                        // disabling of the filter controls.
                        _tmpCurrentStyle = null;
                    }

                    _deviceSpecificEditor.UnderlyingObjectsChanged();
                }
                else
                {
                    _deviceSpecificEditor.EndExternalDeviceSpecificEdit(
                        false /* do not commit changes */ );
                }
            }
            finally
            {
               dialog.StyleRenamed -= renameHandler;
               dialog.StyleDeleted -= deleteHandler;
            }
        }

        public Style CurrentStyle
        {
           get
           {
               if (null == _currentStyle)
               {
                   // Since this property is registered to property window (from TemplateStyle),
                   // it will be accessed even before Initialize is called. In that case, 
                   // _styleSheet will be null;
                   if (_styleSheet != null && _styleSheet.Styles.Count > 0)
                   {
                       // how else can you get an entry in the Styles hashtable?
                       // this needs to be fixed once we use an ordered list of styles.
                       ICollection styles = _styleSheet.Styles;
                       foreach (String key in styles)
                       {
                           _currentStyle = (Style) _styleSheet[key];
                           Debug.Assert (_currentStyle != null);
                           break;
                       }
                   }
               }
               return _currentStyle;
           }
           set
           {
               _currentStyle = value;
           }
        }

        public override DeviceSpecific CurrentDeviceSpecific
        {
            get
            {
                if (null == CurrentStyle)
                {
                    return null;
                }

                return CurrentStyle.DeviceSpecific;
            }
        }

        public String TemplateStyle
        {
            get
            {
                if (null == CurrentStyle)
                {
                    return SR.GetString(SR.StyleSheet_PropNotSet);
                }
                return CurrentStyle.Name;
            }
            set
            {
                // Clear DeviceSpecificChoice of previously selected Style
                CurrentChoice = null;
                CurrentStyle = null;
                if (null != value &&
                    !value.Equals(String.Empty) &&
                    !value.Equals(SR.GetString(SR.StyleSheet_PropNotSet)))
                {
                    ICollection styles = _styleSheet.Styles;
                    foreach (String key in styles)
                    {
                        Style style = (Style) _styleSheet[key];
                        if (style.Name.Equals(value))
                        {
                            CurrentStyle = style;
                            break;
                        }
                    }
                }
                // Clear DeviceSpecificChoice of currently selected Style
                CurrentChoice = null;

                // Invalidate the type descriptor so that the TemplateDeviceFilter gets updated
                TypeDescriptor.Refresh(Component);
            }
        }

        protected override void SetStyleAttributes()
        {
            Debug.Assert(Behavior != null, "Behavior is null");

            String marginTop = null, marginBottom = null, marginRight = null;

            if (ContainmentStatus == ContainmentStatus.AtTopLevel)
            {
                marginTop = "5px";
                marginBottom = "5px";
                marginRight = "30%";
            }
            else
            {
                marginTop = "3px";
                marginBottom = "3px";
                marginRight = "5px";
            }

            Behavior.SetStyleAttribute("marginTop", true, marginTop, true);
            Behavior.SetStyleAttribute("marginBottom", true, marginBottom, true);
            Behavior.SetStyleAttribute("marginRight", true, marginRight, true);
            Behavior.SetStyleAttribute("marginLeft", true, "5px", true);
        }

        protected override void PreFilterProperties(IDictionary properties) 
        {
            base.PreFilterProperties(properties);

            // DesignTime Property only, we will use this to select the current style.
            PropertyDescriptor designerTemplateStyleProp;

            designerTemplateStyleProp =
                TypeDescriptor.CreateProperty(this.GetType(), _templatesStylePropName, typeof(String),
                                     DesignerSerializationVisibilityAttribute.Hidden,
                                     MobileCategoryAttribute.Design,
                                     InTemplateMode ? ReadOnlyAttribute.Yes : ReadOnlyAttribute.No,
                                     InTemplateMode ? BrowsableAttribute.No : BrowsableAttribute.Yes,
                                     new DefaultValueAttribute(SR.GetString(SR.StyleSheet_PropNotSet)),
                                     new TypeConverterAttribute(typeof(StyleConverter)),
                                     new DescriptionAttribute(SR.GetString(SR.StyleSheet_TemplateStyleDescription)));
            properties[_templatesStylePropName] = designerTemplateStyleProp;

            PropertyDescriptor designerPersistedStyles;

            designerPersistedStyles =
                TypeDescriptor.CreateProperty(this.GetType(), _persistedStylesPropName, typeof(ICollection),
                                     //PersistenceTypeAttribute.InnerChild,
                                     PersistenceModeAttribute.InnerDefaultProperty,
                                     BrowsableAttribute.No);
            properties[_persistedStylesPropName] = designerPersistedStyles;
        }

        public ICollection PersistedStyles
        {
            get
            {
                Debug.Assert(null != _styleSheet, "_styleSheet is null");
                ICollection styleKeys = _styleSheet.Styles;
                ArrayList persistedStyles = new ArrayList();
                foreach (String key in styleKeys)
                {
                    Style style = _styleSheet[key];
                    persistedStyles.Add(style);
                }
                foreach (Style style in _styleSheet.DuplicateStyles)
                {
                    persistedStyles.Add(style);
                }
                return persistedStyles;
            }
        }

        /// <summary>
        ///    <para>
        ///       The designer's collection of verbs.
        ///    </para>
        /// </summary>
        /// <value>
        ///    <para>
        ///       An array of type <see cref='DesignerVerb'/> containing the verbs available to the
        ///       designer.
        ///    </para>
        /// </value>
        public override DesignerVerbCollection Verbs 
        {
            get 
            {
                if (_designerVerbs == null) 
                {
                    _designerVerbs = base.Verbs;
                    _designerVerbs.Add(new DesignerVerb(SR.GetString(SR.StyleSheet_StylesEditorVerb),
                                                        new EventHandler(this.OnShowStylesEditor)));
                }
                Debug.Assert(_designerVerbs.Count == 2);

                _designerVerbs[0].Enabled = !this.InTemplateMode;
                _designerVerbs[1].Enabled = !this.InTemplateMode;
                return _designerVerbs;
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  BEGIN STYLE DESIGNER EVENTHANDLERS
        /////////////////////////////////////////////////////////////////////////

        protected void OnShowStylesEditor(Object sender, EventArgs e)
        {
            IComponentChangeService changeService = null;

            changeService = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            if (changeService != null) 
            {
                try 
                {
                    changeService.OnComponentChanging(_styleSheet, null);
                }
                catch (CheckoutException ex) 
                {
                    if (ex == CheckoutException.Canceled)
                    {
                        return;
                    }
                    throw;
                }
            }

            DialogResult result = DialogResult.Cancel;
            try 
            {
                StylesEditorDialog dialog = new StylesEditorDialog(_styleSheet, this, null);
                result = dialog.ShowDialog();
            }
            catch(ArgumentException ex)
            {
                Debug.Fail(ex.ToString());
                // Block user from entering StylesEditorDialog until they fix
                // duplicate style declarations.
            }
            finally
            {
                if (changeService != null)
                {
                    changeService.OnComponentChanged(_styleSheet, null, null, null);

                    if (IMobileWebFormServices != null)
                    {
                        IMobileWebFormServices.ClearUndoStack();
                    }
                }
            }
        }

        protected override void OnCurrentChoiceChange()
        {
            SetCurrentChoice();
            RefreshPageView();
        }

        private void SetCurrentChoice()
        {
            if (CurrentStyle != null && CurrentStyle.DeviceSpecific != null)
            {
                this.CurrentStyle.DeviceSpecific.SetDesignerChoice(CurrentChoice);
            }
        }

        private bool ValidContainment
        {
            get
            {
                return (ContainmentStatus == ContainmentStatus.AtTopLevel);
            }
        }

        protected override String GetErrorMessage(out bool infoMode)
        {
            infoMode = false;

            if (!DesignerAdapterUtil.InMobileUserControl(_styleSheet))
            {
                if (DesignerAdapterUtil.InUserControl(_styleSheet))
                {
                    infoMode = true;
                    return MobileControlDesigner._userControlWarningMessage;
                }

                if (!DesignerAdapterUtil.InMobilePage(_styleSheet))
                {
                    return MobileControlDesigner._mobilePageErrorMessage;
                }
            }
            
            if (!ValidContainment)
            {
                return MobileControlDesigner._topPageContainmentErrorMessage;
            }

            // No error condition, return null;
            return null;
        }

        /////////////////////////////////////////////////////////////////////////
        //  END STYLE DESIGNER EVENTHANDLERS
        /////////////////////////////////////////////////////////////////////////

        [
            System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        private class MergedUI : HeaderPanel
        {
            internal System.Windows.Forms.Label LblStyles;
            internal System.Windows.Forms.ComboBox CbStyles;
            internal System.Windows.Forms.Button BtnEdit;
            internal HeaderLabel LblHeader;

            internal MergedUI()
            {
                this.LblStyles = new System.Windows.Forms.Label();
                this.CbStyles = new System.Windows.Forms.ComboBox();
                this.BtnEdit = new System.Windows.Forms.Button();
                this.LblHeader = new HeaderLabel();
//                this.LblStyles.Anchor = ((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)
//                    | System.Windows.Forms.AnchorStyles.Right);
                this.LblStyles.Location = new System.Drawing.Point(0, 24);
                this.LblStyles.Size = new System.Drawing.Size(160, 16);
//                this.CbStyles.Anchor = ((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
//                    | System.Windows.Forms.AnchorStyles.Right);
                this.CbStyles.DropDownWidth = 124;
                this.CbStyles.Location = new System.Drawing.Point(0, 40);
                this.CbStyles.Size = new System.Drawing.Size(160, 21);
//                this.BtnEdit.Anchor = (System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right);
                this.BtnEdit.Location = new System.Drawing.Point(164, 39);
                this.BtnEdit.Size = new System.Drawing.Size(75, 23);
                this.LblHeader.Location = new System.Drawing.Point(0, 0);
                this.LblHeader.Size = new System.Drawing.Size(240, 16);
                this.Controls.AddRange(new System.Windows.Forms.Control[] {this.CbStyles,
                                                                           this.LblStyles,
                                                                           this.BtnEdit,
                                                                           this.LblHeader});
                this.Size = new System.Drawing.Size(240, 70);
                this.Location = new System.Drawing.Point(5,6);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\textviewdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextViewDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.UI.MobileControls;
    using System.Web.UI.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Adapters;

    /// <summary>
    ///    <para>
    ///       Provides a designer for the <see cref='System.Web.UI.MobileControls.TextView'/>
    ///       control.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.Web.UI.MobileControls.TextView'/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class TextViewDesigner : MobileControlDesigner
    {
        private System.Web.UI.MobileControls.TextView _textView;

        /// <summary>
        ///    <para>
        ///       Initializes the designer with the component for design.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element for design.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component for
        ///       design.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.TextView,
                         "TextViewDesigner.Initialize - Invalid TextView Control");
            _textView = (System.Web.UI.MobileControls.TextView) component;
            base.Initialize(component);
        }

        private bool ValidContainment
        {
            get
            {
                return (
                    ContainmentStatus == ContainmentStatus.InForm ||
                    ContainmentStatus == ContainmentStatus.InPanel ||
                    ContainmentStatus == ContainmentStatus.InTemplateFrame);
            }
        }

        /// <summary>
        ///    <para>
        ///       Returns the design-time HTML of the <see cref='System.Web.UI.MobileControls.TextBox'/>
        ///       mobile control
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The HTML of the control.
        ///    </para>
        /// </returns>
        /// <seealso cref='System.Web.UI.MobileControls.TextBox'/>
        protected override String GetDesignTimeNormalHtml()
        {
            Debug.Assert (_textView.Text != null);

            DesignerTextWriter tw;
            Control[] children = null;

            String originalText = _textView.Text;
            bool blankText = (originalText.Trim().Length == 0);
            bool hasControls =  _textView.HasControls();

            if (blankText)
            {
                if (hasControls) 
                {
                    children = new Control[_textView.Controls.Count];
                    _textView.Controls.CopyTo(children, 0);
                }
                _textView.Text = "[" + _textView.ID + "]";
            }
            try
            {
                tw = new DesignerTextWriter();
                _textView.Adapter.Render(tw);
            }
            finally
            {
                if (blankText)
                {
                    _textView.Text = originalText;
                    if (hasControls) 
                    {
                        foreach (Control c in children) 
                        {
                            _textView.Controls.Add(c);
                        }
                    }
                }
            }

            return tw.ToString();
        }

        protected override String GetErrorMessage(out bool infoMode)
        {
            infoMode = false;

            if (DesignerAdapterUtil.InMobileUserControl(_textView))
            {
                return null;
            }

            if (DesignerAdapterUtil.InUserControl(_textView))
            {
                infoMode = true;
                return MobileControlDesigner._userControlWarningMessage;
            }

            if (!DesignerAdapterUtil.InMobilePage(_textView))
            {
                return MobileControlDesigner._mobilePageErrorMessage;
            }

            if (!ValidContainment)
            {
                return MobileControlDesigner._formPanelContainmentErrorMessage;
            }

            // Containment is valid, return null;
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\designercalendaradapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerCalendarAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.Drawing;
using System.Web.Mobile;
using System.Web.UI.Design.MobileControls;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerCalendarAdapter : HtmlCalendarAdapter
    {
        public override MobileCapabilities Device
        {
            get
            {
                return DesignerCapabilities.Instance;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            writer.WriteBeginTag("div");
            String width = DesignerAdapterUtil.GetWidth(Control);

            writer.WriteAttribute("style", "cellpadding=2px;width:" + width);

            Alignment alignment = (Alignment)Style[Style.AlignmentKey, true];
            if (alignment != Alignment.NotSet)
            {
                writer.WriteAttribute("align", Enum.GetName(typeof(Alignment), alignment));
            }
            writer.Write("/>");

            ((DesignerTextWriter)writer).EnterZeroFontSizeTag();

            //Note: Although this is an internal method of runtime, but it is still
            //      pretty easy to achieve the same goal without using this method.
            Style.ApplyTo(Control.WebCalendar);
            base.Render(writer);

            ((DesignerTextWriter)writer).ExitZeroFontSizeTag();
            writer.WriteEndTag("div");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\designercommandadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerCommandAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.IO;
using System.Web.Mobile;
using System.Web.UI.Design.MobileControls;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerCommandAdapter : HtmlCommandAdapter
    {
        // required width may differ a little bit from actual exact pixel value
        private const int SAFETY_MARGIN = 8;

        public override MobileCapabilities Device
        {
            get
            {
                return DesignerCapabilities.Instance;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            // Invalid text writers are not supported in this Adapter.
            if (!(writer is DesignerTextWriter))
            {
                return;
            }

            Alignment alignment = (Alignment)Style[Style.AlignmentKey, true];
            byte templateStatus;
            int maxWidth = DesignerAdapterUtil.GetMaxWidthToFit(Control, out templateStatus);
            String width = DesignerAdapterUtil.GetWidth(Control);

            if (Control.ImageUrl.Length == 0)
            {
                if (Control.Format == CommandFormat.Button)
                {
                    if (maxWidth == 0 && templateStatus == DesignerAdapterUtil.CONTROL_IN_TEMPLATE_NONEDIT)
                    {
                        maxWidth = DesignerAdapterUtil.CONTROL_MAX_WIDTH_IN_TEMPLATE;
                    }

                    if (maxWidth == 0 && DesignerAdapterUtil.InMobileUserControl(Control))
                    {
                        maxWidth = Constants.ControlMaxsizeAtToplevel;
                    }

                    if (maxWidth == 0)
                    {
                        // Render will be called a second time for which maxWidth != 0
                        return;
                    }

                    String additionalStyle = null;
                    String controlText = Control.Text;
                    String commandCaption;
                    int requiredWidth = 0;

                    DesignerTextWriter twTmp;
                    twTmp = new DesignerTextWriter();
                    twTmp.WriteBeginTag("input");
                    twTmp.WriteStyleAttribute(Style, null);
                    twTmp.WriteAttribute("type", "submit");
                    twTmp.Write(" value=\"");
                    twTmp.WriteText(controlText, true);
                    twTmp.Write("\"/>");
                    String htmlFragment = twTmp.ToString();

                    MSHTMLHostUtil.ApplyStyle(String.Empty, String.Empty, null);
                    requiredWidth = MSHTMLHostUtil.GetHtmlFragmentWidth(htmlFragment);

                    ((DesignerTextWriter)writer).EnterZeroFontSizeTag();
                    writer.WriteBeginTag("div");
                    if (requiredWidth + SAFETY_MARGIN > maxWidth)
                    {
                        if (templateStatus == DesignerAdapterUtil.CONTROL_IN_TEMPLATE_EDIT)
                        {
                            int tmpRequiredWidth, allowedLength;
                            int captionLength = controlText.Length;
                            twTmp = new DesignerTextWriter();
                            twTmp.WriteBeginTag("input");
                            twTmp.WriteStyleAttribute(Style, null);
                            twTmp.WriteAttribute("type", "submit");
                            twTmp.WriteAttribute("value", "{0}");
                            twTmp.Write("/>");
                            htmlFragment = twTmp.ToString();
                            // At least 10 characters can fit into the caption of the command
                            for (allowedLength = (captionLength < 10 ? captionLength : 10); allowedLength <= captionLength; allowedLength++)
                            {
                                tmpRequiredWidth = MSHTMLHostUtil.GetHtmlFragmentWidth(String.Format(htmlFragment, HttpUtility.HtmlEncode(controlText.Substring(0, allowedLength))));
                                if (tmpRequiredWidth + SAFETY_MARGIN > maxWidth)
                                {
                                    break;
                                }
                            }
                            commandCaption = controlText.Substring(0, allowedLength - 1);
                        }
                        else
                        {
                            commandCaption = controlText;
                        }
                    }
                    else
                    {
                        writer.WriteAttribute("style", "width:" + width);
                        commandCaption = controlText;
                    }

                    if (alignment != Alignment.NotSet)
                    {
                        writer.WriteAttribute("align", Enum.GetName(typeof(Alignment), alignment));
                    }
                    writer.Write(">");

                    writer.EnterLayout(Style);

                    writer.WriteBeginTag("input");
                    if (requiredWidth + SAFETY_MARGIN > maxWidth)
                    {
                        additionalStyle = String.Format("width:{0};", width);
                    }
                    ((DesignerTextWriter)writer).WriteStyleAttribute(Style, additionalStyle);
                    writer.WriteAttribute("type", "submit");

                    writer.Write(" value=\"");
                    writer.WriteText(commandCaption, true);
                    writer.Write("\"/>");

                    writer.ExitLayout(Style);
                }
                else
                {
                    Wrapping wrapping = (Wrapping) Style[Style.WrappingKey, true];
                    bool wrap = (wrapping == Wrapping.Wrap || wrapping == Wrapping.NotSet);

                    ((DesignerTextWriter)writer).EnterZeroFontSizeTag();
                    writer.WriteBeginTag("div");

                    if (!wrap)
                    {
                        if (templateStatus == DesignerAdapterUtil.CONTROL_IN_TEMPLATE_EDIT)
                        {
                            width = maxWidth.ToString() + "px";
                        }
                        writer.WriteAttribute("style", "overflow-x:hidden;width:" + width);
                    }
                    else
                    {
                        writer.WriteAttribute("style", "word-wrap:break-word;width:" + width);
                    }

                    if (alignment != Alignment.NotSet)
                    {
                        writer.WriteAttribute("align", Enum.GetName(typeof(Alignment), alignment));
                    }
                    writer.Write(">");

                    writer.WriteBeginTag("a");
                    writer.WriteAttribute("href", "NavigationUrl");
                    writer.Write(">");
                    ((DesignerTextWriter)writer).WriteCssStyleText(Style, null, Control.Text, true);
                    writer.WriteEndTag("a");
                }
                writer.WriteEndTag("div");
                ((DesignerTextWriter)writer).ExitZeroFontSizeTag();
            }
            else
            {
                if (templateStatus == DesignerAdapterUtil.CONTROL_IN_TEMPLATE_EDIT)
                {
                    width = maxWidth.ToString() + "px";
                }

                writer.WriteBeginTag("div");
                if (alignment == Alignment.Center)
                {
                    writer.WriteAttribute("align", "center");
                }
                writer.WriteAttribute("style", "overflow-x:hidden;width:" + width);
                writer.Write(">");

                writer.WriteBeginTag("img");
                ((DesignerTextWriter)writer).WriteStyleAttribute(Style);
                writer.WriteAttribute("src", Control.ImageUrl, true);

                // center alignment not part of HTML for images.
                if (alignment == Alignment.Right ||
                    alignment == Alignment.Left)
                {
                    writer.WriteAttribute("align", Enum.GetName(typeof(Alignment), alignment));
                }

                writer.WriteAttribute("border", "0");
                writer.Write(">");
                writer.WriteEndTag("div");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\designerimageadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerImageAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.Web.Mobile;
using System.Web.UI.Design.MobileControls;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;
using System.ComponentModel.Design;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerImageAdapter : HtmlImageAdapter 
    {
        public override MobileCapabilities Device
        {
            get
            {
                return DesignerCapabilities.Instance;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            Alignment alignment = (Alignment)Style[Style.AlignmentKey, true];

            byte templateStatus;
            int maxWidth = DesignerAdapterUtil.GetMaxWidthToFit(Control, out templateStatus);
            String width = DesignerAdapterUtil.GetWidth(Control);

            if (templateStatus == DesignerAdapterUtil.CONTROL_IN_TEMPLATE_EDIT)
            {
                width = maxWidth.ToString() + "px";
            }

            writer.WriteBeginTag("div");
            if (alignment == Alignment.Center)
            {
                writer.WriteAttribute("align", "center");
            }
            writer.WriteAttribute("style", "overflow-x:hidden;width:" + width);
            writer.Write(">");

            String source = Control.ImageUrl;

            writer.WriteBeginTag("img");
            ((DesignerTextWriter)writer).WriteStyleAttribute(Style);
            if (source != "")
            {
                writer.WriteAttribute("src", source, true);
            }
            if (Control.AlternateText != "")
            {
                writer.Write(" alt=\"");
                writer.WriteText(Control.AlternateText, true);
                writer.Write("\"");
            }

            // center alignment not part of HTML for images.
            if (alignment == Alignment.Right ||
                alignment == Alignment.Left)
            {
                writer.WriteAttribute("align", Enum.GetName(typeof(Alignment), alignment));
            }

            writer.WriteAttribute("border", "0");
            writer.Write(">");
            writer.WriteEndTag("div");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\designerlabeladapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerLableAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.Web.Mobile;
using System.Web.UI.Design.MobileControls;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerLabelAdapter : HtmlLabelAdapter
    {
        public override MobileCapabilities Device
        {
            get
            {
                return DesignerCapabilities.Instance;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            // Style.SetControl(Control);
            Alignment alignment = (Alignment)Style[Style.AlignmentKey, true];
            Wrapping wrapping = (Wrapping) Style[Style.WrappingKey, true];
            bool wrap = (wrapping == Wrapping.Wrap || wrapping == Wrapping.NotSet);

            ((DesignerTextWriter)writer).EnterZeroFontSizeTag();
            writer.WriteBeginTag("div");

            String width = DesignerAdapterUtil.GetWidth(Control);
            if (!wrap)
            {
                byte templateStatus;
                int maxWidth = DesignerAdapterUtil.GetMaxWidthToFit(Control, out templateStatus);
                if (templateStatus == DesignerAdapterUtil.CONTROL_IN_TEMPLATE_EDIT)
                {
                    width = maxWidth.ToString() + "px";
                }
                writer.WriteAttribute("style", "overflow-x:hidden;width:" + width);
            }
            else
            {
                writer.WriteAttribute("style", "word-wrap:break-word;width:" + width);
            }
            

            if (alignment != Alignment.NotSet)
            {
                writer.WriteAttribute("align", Enum.GetName(typeof(Alignment), alignment));
            }
            writer.Write(">");

            ((DesignerTextWriter)writer).WriteCssStyleText(Style, null, Control.Text, true);
            writer.WriteEndTag("div");
            ((DesignerTextWriter)writer).ExitZeroFontSizeTag();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\designerselectionlistadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerSelectionListAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.Drawing;
using System.Web.Mobile;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerSelectionListAdapter : HtmlSelectionListAdapter
    {
        public override MobileCapabilities Device
        {
            get
            {
                return DesignerCapabilities.Instance;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            writer.WriteBeginTag("div");
            ((DesignerTextWriter)writer).WriteDesignerStyleAttributes(Control, Style);
            writer.Write("\">");

            base.Render(writer);

            writer.WriteEndTag("div");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\designerobjectlistadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerObjectListAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.Drawing;
using System.Web.Mobile;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerObjectListAdapter : HtmlObjectListAdapter
    {
        public override MobileCapabilities Device
        {
            get
            {
                return DesignerCapabilities.Instance;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            writer.WriteBeginTag("div");
            ((DesignerTextWriter)writer).WriteDesignerStyleAttributes(Control, Style);
            writer.Write("\">");    

            base.Render(writer);

            writer.WriteEndTag("div");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\designerlinkadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerLinkAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Web.Mobile;
using System.Web.UI.Design.MobileControls;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerLinkAdapter : HtmlLinkAdapter 
    {
        public override MobileCapabilities Device
        {
            get
            {
                return DesignerCapabilities.Instance;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            Alignment alignment = (Alignment)Style[Style.AlignmentKey, true];
            Wrapping wrapping = (Wrapping) Style[Style.WrappingKey, true];
            bool wrap = (wrapping == Wrapping.Wrap || wrapping == Wrapping.NotSet);

            ((DesignerTextWriter)writer).EnterZeroFontSizeTag();
            writer.WriteBeginTag("div");
            String width = DesignerAdapterUtil.GetWidth(Control);

            if (!wrap)
            {
                byte templateStatus;
                int maxWidth = DesignerAdapterUtil.GetMaxWidthToFit(Control, out templateStatus);
                if (templateStatus == DesignerAdapterUtil.CONTROL_IN_TEMPLATE_EDIT)
                {
                    width = maxWidth.ToString() + "px";
                }
                writer.WriteAttribute("style", "overflow-x:hidden;width:" + width);
            }
            else
            {
                writer.WriteAttribute("style", "word-wrap:break-word;width:" + width);
            }

            if (alignment != Alignment.NotSet)
            {
                writer.WriteAttribute("align", Enum.GetName(typeof(Alignment), alignment));
            }
            writer.Write(">");

            writer.WriteBeginTag("a");
            writer.WriteAttribute("href", "NavigationUrl");
            writer.Write(">");
            ((DesignerTextWriter)writer).WriteCssStyleText(Style, null, Control.Text, true);
            writer.WriteEndTag("a");

            writer.WriteEndTag("div");
            ((DesignerTextWriter)writer).ExitZeroFontSizeTag();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\designertextviewadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerTextViewAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Globalization;
using System.Text;
using System.Web.Mobile;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerTextViewAdapter : HtmlControlAdapter 
    {
        protected new TextView Control
        {
            get
            {
                return (TextView)base.Control;
            }
        }

        public override MobileCapabilities Device
        {
            get
            {
                return DesignerCapabilities.Instance;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            Alignment alignment = (Alignment) Style[Style.AlignmentKey, true];
            Wrapping wrapping = (Wrapping) Style[Style.WrappingKey, true];
            bool wrap = (wrapping == Wrapping.Wrap || wrapping == Wrapping.NotSet);
            String width = DesignerAdapterUtil.GetWidth(Control);

            ((DesignerTextWriter)writer).EnterZeroFontSizeTag();
            writer.WriteBeginTag("div");
            if (!wrap)
            {
                byte templateStatus;
                int maxWidth = DesignerAdapterUtil.GetMaxWidthToFit(Control, out templateStatus);
                if (templateStatus == DesignerAdapterUtil.CONTROL_IN_TEMPLATE_EDIT)
                {
                    width = maxWidth.ToString() + "px";
                }
                writer.WriteAttribute("style", "overflow-x:hidden;width:" + width);
            }
            else
            {
                writer.WriteAttribute("style", "word-wrap:break-word;width:" + width);
            }

            if (alignment != Alignment.NotSet)
            {
                writer.WriteAttribute("align", Enum.GetName(typeof(Alignment), alignment));
            }
            writer.Write(">");

            MSHTMLHostUtil.ApplyStyle(null, null, null);
            String filteredText = FilterTags(Control.Text.Trim());
            int uniqueLineHeight = MSHTMLHostUtil.GetHtmlFragmentHeight("a");
            int requiredHeight = MSHTMLHostUtil.GetHtmlFragmentHeight(filteredText);
            int requiredWidth = MSHTMLHostUtil.GetHtmlFragmentWidth(filteredText);

            ((DesignerTextWriter)writer).WriteCssStyleText(Style, null, (requiredHeight > uniqueLineHeight || requiredWidth > 1) ? filteredText : "&nbsp;", false);
            writer.WriteEndTag("div");
            ((DesignerTextWriter)writer).ExitZeroFontSizeTag();
        }

        private enum CursorStatus
        {
            OutsideTag,
            InsideTagName,
            InsideAttributeName,
            InsideAttributeValue,
            ExpectingAttributeValue
        }

        private String FilterTags(String text)
        {
            StringBuilder filteredText = new StringBuilder();
            // StringBuilder hrefValue = null;
            int len = text.Length, i;
            int tagBegin = 0; //, attribBegin = 0;
            bool doubleQuotedAttributeValue = false;
            // bool cacheHRefValue = false;
            CursorStatus cs = CursorStatus.OutsideTag;
            String tagName = String.Empty;

            for (i = 0; i < len; i++)
            {
                switch (text[i])
                {
                    case '<':
                    {
                        switch (cs)
                        {
                            case CursorStatus.OutsideTag:
                            {
                                cs = CursorStatus.InsideTagName;
                                tagBegin = i;
                                break;
                            }
                        }
                        break;
                    }
                    case '=':
                    {
                        switch (cs)
                        {
                            case CursorStatus.InsideAttributeName:
                            {
                                // cacheHRefValue = text.Substring(attribBegin, i-attribBegin).Trim().ToUpper() == "HREF";
                                // hrefValue = null;
                                cs = CursorStatus.ExpectingAttributeValue;
                                break;
                            }
                            case CursorStatus.OutsideTag:
                            {
                                filteredText.Append(text[i]);
                                break;
                            }
                        }
                        break;
                    }
                    case '"':
                    {
                        switch (cs)
                        {
                            case CursorStatus.ExpectingAttributeValue:
                            {
                                cs = CursorStatus.InsideAttributeValue;
                                doubleQuotedAttributeValue = true;
                                //if (cacheHRefValue)
                                //{
                                //    hrefValue = new StringBuilder("\"");
                                //}
                                break;
                            }
                            case CursorStatus.InsideAttributeValue:
                            {
                                //if (cacheHRefValue)
                                //{
                                //    hrefValue.Append('"');
                                //}
                                if (text[i-1] != '\\' && doubleQuotedAttributeValue)
                                {
                                    // leaving attribute value
                                    cs = CursorStatus.InsideAttributeName;
                                    // attribBegin = i;
                                    break;
                                }
                                break;
                            }
                            case CursorStatus.OutsideTag:
                            {
                                filteredText.Append(text[i]);
                                break;
                            }
                        }
                        break;
                    }
                    case '\'':
                    {
                        switch (cs)
                        {
                            case CursorStatus.ExpectingAttributeValue:
                            {
                                cs = CursorStatus.InsideAttributeValue;
                                //if (cacheHRefValue)
                                //{
                                //    hrefValue = new StringBuilder("'");
                                //}
                                doubleQuotedAttributeValue = false;
                                break;
                            }
                            case CursorStatus.InsideAttributeValue:
                            {
                                //if (cacheHRefValue)
                                //{
                                //    hrefValue.Append('\'');
                                //}
                                if (text[i-1] != '\\' && !doubleQuotedAttributeValue)
                                {
                                    // leaving attribute value
                                    cs = CursorStatus.InsideAttributeName;
                                    // attribBegin = i;
                                    break;
                                }
                                break;
                            }
                            case CursorStatus.OutsideTag:
                            {
                                filteredText.Append(text[i]);
                                break;
                            }
                        }
                        break;
                    }
                    case '/':
                    {
                        switch (cs)
                        {
                            case CursorStatus.InsideTagName:
                            {
                                tagName = text.Substring(tagBegin+1, i-tagBegin-1).Trim().ToUpper(CultureInfo.InvariantCulture);

                                if (tagName.Trim().Length > 0)
                                {
                                    cs = CursorStatus.InsideAttributeName;
                                    // attribBegin = i;
                                }
                                break;
                            }
                            case CursorStatus.OutsideTag:
                            {
                                filteredText.Append(text[i]);
                                break;
                            }
                        }
                        break;
                    }
                    case '>':
                    {
                        switch (cs)
                        {
                            case CursorStatus.InsideTagName:
                            case CursorStatus.InsideAttributeName:
                            case CursorStatus.ExpectingAttributeValue:
                            {
                                // leaving tag
                                if (cs == CursorStatus.InsideTagName)
                                {
                                    tagName = text.Substring(tagBegin+1, i-tagBegin-1).Trim().ToUpper(CultureInfo.InvariantCulture);
                                }
                                cs = CursorStatus.OutsideTag;
                                switch (tagName)
                                {
                                    case "A":
                                    {
                                        //filteredText.Append(String.Format("<A HREF={0}>", 
                                        //    hrefValue == null ? String.Empty : hrefValue.ToString()));
                                        filteredText.Append("<A HREF=\"\">");
                                        break;
                                    }

                                    case "/A":
                                    case "B":
                                    case "/B":
                                    case "BR":
                                    case "/BR":
                                    case "I":
                                    case "/I":
                                    case "P":
                                    case "/P":
                                    {
                                        filteredText.Append("<" + tagName + ">");
                                        break;
                                    }
                                }
                                tagName = String.Empty;
                                break;
                            }
                            case CursorStatus.OutsideTag:
                            {
                                filteredText.Append(text[i]);
                                break;
                            }
                        }
                        break;
                    }
                    default:
                    {
                        if (Char.IsWhiteSpace(text[i]))
                        {
                            switch (cs)
                            {
                                case CursorStatus.OutsideTag:
                                {
                                    filteredText.Append(text[i]);
                                    break;
                                }
                                case CursorStatus.InsideTagName:
                                {
                                    cs = CursorStatus.InsideAttributeName;
                                    // attribBegin = i;
                                    tagName = text.Substring(tagBegin+1, i-tagBegin-1).Trim().ToUpper(CultureInfo.InvariantCulture);
                                    break;
                                }
                            }
                        }
                        else
                        {
                            switch (cs)
                            {
                                case CursorStatus.OutsideTag:
                                {
                                    filteredText.Append(text[i]);
                                    break;
                                }
                            }
                        }
                        break;
                    }
                }
            }

            return filteredText.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\designertextboxadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerTextBoxAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.IO;
using System.Web.Mobile;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerTextBoxAdapter : HtmlTextBoxAdapter 
    {
        // required width may differ a little bit from actual exact pixel value
        private const int SAFETY_MARGIN = 12;
        // size after which we simply assume the control is too large to fit
        // into its container.
        private const int LARGESIZE_THRESHOLD = 100;

        public override MobileCapabilities Device
        {
            get
            {
                return DesignerCapabilities.Instance;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            // Invalid text writers are not supported in this Adapter.
            if (!(writer is DesignerTextWriter))
            {
                return;
            }

            byte templateStatus;
            bool pwd = Control.Password;
            int size = Control.Size;
            int fittingSize;

            int maxWidth = DesignerAdapterUtil.GetMaxWidthToFit(Control, out templateStatus);

            if (maxWidth == 0)
            {
                if (templateStatus == DesignerAdapterUtil.CONTROL_IN_TEMPLATE_NONEDIT)
                {
                    maxWidth = DesignerAdapterUtil.CONTROL_MAX_WIDTH_IN_TEMPLATE;
                }
                else if (DesignerAdapterUtil.InMobileUserControl(Control))
                {
                    maxWidth = Constants.ControlMaxsizeAtToplevel;
                }
            }

            if (maxWidth == 0)
            {
                return;
            }

            bool restoreEmptyFontName = false;
            if ((String) Style[Style.FontNameKey, true] == String.Empty)
            {
                // MSHTMLHostUtil is using another font by default.
                // Setting the font name to the one that is actually
                // used by default for the desig-time rendering
                // assures that the requiredWidth returned by
                // MSHTMLHostUtil.GetHtmlFragmentWidth is accurate.
                Style[Style.FontNameKey] = "Arial";
                restoreEmptyFontName = true;
            }

            int requiredWidth = 0;
            DesignerTextWriter tw;
            tw = new DesignerTextWriter(false);
            tw.EnterLayout(Style);
            String enterLayout = tw.ToString();

            tw = new DesignerTextWriter(false);
            tw.ExitLayout(Style);
            String exitLayout = tw.ToString();

            tw = new DesignerTextWriter(false);
            tw.WriteBeginTag("input");
            tw.WriteStyleAttribute(Style, null);
            if (size > 0)
            {
                tw.WriteAttribute("size", "{0}");
            }
            tw.Write("/>");
            String htmlFragment = tw.ToString();

            MSHTMLHostUtil.ApplyStyle(enterLayout, exitLayout, null);

            if (size < LARGESIZE_THRESHOLD)
            {
                requiredWidth = MSHTMLHostUtil.GetHtmlFragmentWidth(size > 0 ? String.Format(htmlFragment, size.ToString()) : htmlFragment);
            }

            if (requiredWidth + SAFETY_MARGIN > maxWidth || size >= LARGESIZE_THRESHOLD)
            {
                if (size == 0)
                {
                    tw = new DesignerTextWriter(false);
                    tw.WriteBeginTag("input");
                    tw.WriteStyleAttribute(Style, null);
                    tw.WriteAttribute("size", "{0}");
                    tw.Write("/>");
                    htmlFragment = tw.ToString();
                }
                fittingSize = 0;
                do
                {
                    fittingSize++;
                    requiredWidth = MSHTMLHostUtil.GetHtmlFragmentWidth(String.Format(htmlFragment, fittingSize.ToString()));
                }
                while (requiredWidth + SAFETY_MARGIN <= maxWidth);

                if (fittingSize > 1)
                {
                    fittingSize--;
                }
            }
            else
            {
                fittingSize = size;
            }

            if (restoreEmptyFontName)
            {
                Style[Style.FontNameKey] = String.Empty;
            }

            Alignment alignment = (Alignment) Style[Style.AlignmentKey, true];
            String width = DesignerAdapterUtil.GetWidth(Control);

            writer.Write("<div style='width:" + width);
            if (alignment != Alignment.NotSet)
            {
                writer.Write(";text-align:" + Enum.GetName(typeof(Alignment), alignment));
            }
            writer.Write("'>");

            ((DesignerTextWriter)writer).EnterZeroFontSizeTag();
            writer.EnterLayout(Style);

            writer.WriteBeginTag("input");
            ((DesignerTextWriter)writer).WriteStyleAttribute(Style, null);
            if (Control.Text != String.Empty)
            {
                writer.Write(" value=\"");
                writer.WriteText(Control.Text, true);
                writer.Write("\" ");
            }
            if (fittingSize > 0)
            {
                writer.WriteAttribute("size", fittingSize.ToString());
            }
            if (pwd)
            {
                writer.WriteAttribute("type", "password");
            }
            writer.Write("/>");

            writer.ExitLayout(Style);
            ((DesignerTextWriter)writer).ExitZeroFontSizeTag();
            writer.Write("</div>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\designerlistadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerListAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.Drawing;
using System.Web.Mobile;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerListAdapter : HtmlListAdapter
    {
        public override MobileCapabilities Device
        {
            get
            {
                return DesignerCapabilities.Instance;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            writer.WriteBeginTag("div");
            ((DesignerTextWriter)writer).WriteDesignerStyleAttributes(Control, Style);
            writer.Write("\">");

            base.Render(writer);

            writer.WriteEndTag("div");
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\designervalidationsummaryadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerValidationSummaryAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Web.Mobile;
using System.Web.UI.Design.MobileControls;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;
using System.Diagnostics;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerValidationSummaryAdapter : HtmlValidationSummaryAdapter
    {
        public override MobileCapabilities Device
        {
            get
            {
                return DesignerCapabilities.Instance;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            String additionalStyle;

            Alignment alignment = (Alignment) Style[Style.AlignmentKey, true];
            Wrapping wrapping = (Wrapping) Style[Style.WrappingKey, true];
            bool wrap = (wrapping == Wrapping.Wrap || wrapping == Wrapping.NotSet);
            String width = DesignerAdapterUtil.GetWidth(Control);

            ((DesignerTextWriter)writer).EnterZeroFontSizeTag();
            writer.EnterLayout(Style);
            writer.WriteBeginTag("div");
            if (!wrap)
            {
                byte templateStatus;
                int maxWidth = DesignerAdapterUtil.GetMaxWidthToFit(Control, out templateStatus);
                if (templateStatus == DesignerAdapterUtil.CONTROL_IN_TEMPLATE_EDIT)
                {
                    width = maxWidth.ToString() + "px";
                }
                additionalStyle = "overflow-x:hidden;width:" + width + ";";
            }
            else
            {
                additionalStyle = "word-wrap:break-word;width:" + width + ";";
            }

            ((DesignerTextWriter)writer).WriteStyleAttribute(Style, additionalStyle);
            if (alignment != Alignment.NotSet)
            {
                writer.WriteAttribute("align", Enum.GetName(typeof(Alignment), alignment));
            }
            writer.Write(">");

            writer.WriteText(Control.HeaderText, true);
            
            writer.WriteFullBeginTag("ul");
            for (int i = 1; i <= 2; i++)
            {
                writer.WriteFullBeginTag("li");
                writer.Write(SR.GetString(SR.ValidationSummary_ErrorMessage, i.ToString()));
                writer.WriteEndTag("li");
            }
            writer.WriteEndTag("ul");

            writer.WriteBeginTag("a");
            writer.WriteAttribute("href", "NavigationUrl");
            writer.Write(">");
            writer.WriteText(Control.BackLabel == String.Empty? GetDefaultLabel(BackLabel) : Control.BackLabel, true);
            writer.WriteEndTag("a");

            writer.WriteEndTag("div");
            writer.ExitLayout(Style);
            ((DesignerTextWriter)writer).ExitZeroFontSizeTag();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\designertextwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerTextWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Drawing;
using System.IO;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;
using System.Web.UI.Design.MobileControls;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerTextWriter : HtmlMobileTextWriter
    {
        private readonly WriterStyle _defaultWriterStyle;
        
        internal DesignerTextWriter() : this(false)
        {
        }

        internal DesignerTextWriter(bool maintainState) : 
            base(new StringWriter(), DesignerCapabilities.Instance)
        {
            MaintainState = maintainState;
            _defaultWriterStyle = new WriterStyle();
        }

        internal void EnterZeroFontSizeTag()
        {
            WriteBeginTag("font");
            WriteAttribute("size", "+0");
            Write("/>");
            WriteBeginTag("div");
            WriteAttribute("style", "font-weight:normal;font-style:normal");
            Write(">");
        }

        internal void ExitZeroFontSizeTag()
        {
            WriteEndTag("div");
            WriteEndTag("font");
        }

        public override String ToString()
        {
            return InnerWriter.ToString();
        }

        internal void WriteDesignerStyleAttributes(MobileControl control, 
            Style style)
        {
            Alignment alignment = (Alignment) style[Style.AlignmentKey, true];
            Wrapping wrapping = (Wrapping) style[Style.WrappingKey, true];
            Color backColor = (Color) style[Style.BackColorKey, true];

            bool align  = (alignment != Alignment.NotSet);
            bool wrap = (wrapping == Wrapping.Wrap || wrapping == Wrapping.NotSet);

            String width = DesignerAdapterUtil.GetWidth(control);

            byte templateStatus;
            int maxWidth = DesignerAdapterUtil.GetMaxWidthToFit(control, out templateStatus);
            if (templateStatus == DesignerAdapterUtil.CONTROL_IN_TEMPLATE_EDIT)
            {
                width = maxWidth.ToString() + "px";
            }

            if (!wrap)
            {
                Write(" style=\"overflow-x:hidden;width:" + width);
            }
            else
            {
                Write(" style=\"word-wrap:break-word;overflow-x:hidden;width:" + width);
            }

            if (backColor != Color.Empty)
            {
                Write(";background-color:" + ColorTranslator.ToHtml(backColor));
            }

            if (align)
            {
                Write(";text-align:" + Enum.GetName(typeof(Alignment), alignment));
            }
        }

        internal void WriteStyleAttribute(Style style)
        {
            WriteStyleAttribute(style, null);
        }

        internal void WriteStyleAttribute(Style style, String additionalStyle)
        {
            // Style attributes not written for device without CSS support
            if (!Device.SupportsCss)
            {
                return;
            }

            bool bold = (BooleanOption)style[Style.BoldKey, true] == BooleanOption.True;
            bool italic = (BooleanOption)style[Style.ItalicKey, true] == BooleanOption.True;
            FontSize  fontSize  = (FontSize) style[Style.FontSizeKey , true];
            String    fontName  = (String)   style[Style.FontNameKey , true];
            Color     foreColor = (Color)    style[Style.ForeColorKey, true];
            Color     backColor = (Color)    style[Style.BackColorKey, true];

            Write(" style=\"");

            if (null != additionalStyle)
            {
                Write(additionalStyle);
            }

            if (bold)
            {
                Write("font-weight:bold;");
            }

            if (italic)
            {
                Write("font-style:italic;");
            }

            if (fontSize == FontSize.Large)
            {
                Write("font-size:larger;");
            }
            else if (fontSize == FontSize.Small)
            {
                Write("font-size:smaller;");
            }

            if (fontName != String.Empty)
            {
                Write("font-family:");
                Write(fontName);
                Write(';');
            }

            if (foreColor != Color.Empty)
            {
                Write("color:");
                Write(ColorTranslator.ToHtml(foreColor));
                Write(';');
            }

            if (backColor != Color.Empty)
            {
                Write("background-color:");
                Write(ColorTranslator.ToHtml(backColor));
                Write(';');
                Write("border-color:");
                Write(ColorTranslator.ToHtml(backColor));
                Write(';');
            }

            Write("\"");
        }

        internal void WriteCssStyleText(Style style,
                                      String additionalStyle,
                                      String text,
                                      bool encodeText)
        {
            EnterLayout(style);
            WriteBeginTag("div");
            WriteStyleAttribute(style, additionalStyle);
            Write(">");
            WriteText(text, encodeText);
            WriteEndTag("div");
            ExitLayout(style);
        }

        public override void EnterLayout(Style style)
        {
            if(MaintainState)
            {
                base.EnterLayout(style);
                return;
            }
            //we are not maintaining state, so begin a new context
            BeginStyleContext();
            //create a WriterStyle and turn off formatting output
            WriterStyle newStyle = new WriterStyle(style);
            newStyle.Format = false;
            //transition to the new style, capturing output
            _currentState.Transition(newStyle);
            //Clear stack so we do not interfere with Write*()
            _currentState.Transition(_defaultWriterStyle, false);
            //restore the context
            EndStyleContext();
        }

        public override void ExitLayout(Style style, bool breakAfter)
        {
            if(MaintainState)
            {
                base.ExitLayout(style, breakAfter);
                return;
            }
            //we are not maintaining state, so begin a new context
            BeginStyleContext();
            //create a WriterStyle and turn off formatting output
            WriterStyle newStyle = new WriterStyle(style);
            newStyle.Format = false;
            //Setup stack like it would be after base.EnterLayout()
            _currentState.Transition(newStyle, false);
            //transition to default state and capture output
            _currentState.Transition(_defaultWriterStyle);
            //close the context, to flush all pending tags
            EndStyleContext();
        }

        public override void ExitLayout(Style style)
        {
            ExitLayout(style, false);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\designervalidatoradapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerValidatorAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Web.Mobile;
using System.Web.UI.Design.MobileControls;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;
using System.Diagnostics;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerValidatorAdapter : HtmlValidatorAdapter
    {
        public override MobileCapabilities Device
        {
            get
            {
                return DesignerCapabilities.Instance;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            Alignment alignment = (Alignment) Style[Style.AlignmentKey, true];
            Wrapping wrapping = (Wrapping) Style[Style.WrappingKey, true];
            bool wrap = (wrapping == Wrapping.Wrap || wrapping == Wrapping.NotSet);
            String width = DesignerAdapterUtil.GetWidth(Control);

            ((DesignerTextWriter)writer).EnterZeroFontSizeTag();
            writer.WriteBeginTag("div");

            if (!wrap)
            {
                byte templateStatus;
                int maxWidth = DesignerAdapterUtil.GetMaxWidthToFit(Control, out templateStatus);

                if (templateStatus == DesignerAdapterUtil.CONTROL_IN_TEMPLATE_EDIT)
                {
                    width = maxWidth.ToString() + "px";
                }
                writer.WriteAttribute("style", "overflow-x:hidden;width:" + width);
            }
            else
            {
                writer.WriteAttribute("style", "word-wrap:break-word;width:" + width);
            }

            if (alignment != Alignment.NotSet)
            {
                writer.WriteAttribute("align", Enum.GetName(typeof(Alignment), alignment));
            }
            writer.Write(">");

            if (Control.Text.Trim().Length > 0)
            {
                ((DesignerTextWriter)writer).WriteCssStyleText(Style, null, Control.Text, true);
            }
            else
            {
                ((DesignerTextWriter)writer).WriteCssStyleText(Style, null, Control.ErrorMessage, true);
            }

            writer.WriteEndTag("div");
            ((DesignerTextWriter)writer).ExitZeroFontSizeTag();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adapters\mshtmlhostutil.cs ===
//------------------------------------------------------------------------------
// <copyright file="MSHTMLHostUtil.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Drawing;
using System.Web.UI.Design.MobileControls.Util;

namespace System.Web.UI.Design.MobileControls.Adapters
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class MSHTMLHostUtil
    {
        private const int CONTROL_WIDTH = 64;
        private const int CONTROL_HEIGHT = 4096;

        private static MSHTMLHost _tridentControl;
        private static NativeMethods.IHTMLElement _htmlBody;
        private static NativeMethods.IHTMLElement _htmlDivOuter;
        private static NativeMethods.IHTMLElement _htmlDivInner;

        private static void CreateControl()
        {
            if (null != _tridentControl && null != _htmlBody)
            {
                return;
            }

            _tridentControl = new MSHTMLHost();

            _tridentControl.Size = new Size(CONTROL_WIDTH, CONTROL_HEIGHT);

            _tridentControl.CreateTrident();
            _tridentControl.ActivateTrident();

            NativeMethods.IHTMLDocument2 htmlDoc2 = _tridentControl.GetDocument();
            _htmlBody = htmlDoc2.GetBody();
        }

        internal static void ApplyStyle(String enterStyle, String exitStyle, String cssStyle)
        {
            MSHTMLHostUtil.CreateControl();

            String bodyInnerHTML = "<div id=__divOuter nowrap style='width:1px; height:10px'>" +
                                   enterStyle +
                                   "<div id=__divInner" + cssStyle + "></div>" +
                                   exitStyle +
                                   "</div>";

            // MessageBox.Show("Body HTML for empty content: " + bodyInnerHTML);
            _htmlBody.SetInnerHTML(bodyInnerHTML);

            NativeMethods.IHTMLDocument3 htmlDoc3 = (NativeMethods.IHTMLDocument3) _tridentControl.GetDocument();
            Debug.Assert(null != htmlDoc3);

            _htmlDivInner = htmlDoc3.GetElementById("__divInner");
            _htmlDivOuter = htmlDoc3.GetElementById("__divOuter");
            Debug.Assert(null != _htmlDivOuter && null != _htmlDivInner);
        }

        internal static int GetTextWidth(String text)
        {
            Debug.Assert(null != _htmlDivOuter && null != _htmlDivInner);

            _htmlDivInner.SetInnerText(text);
            NativeMethods.IHTMLElement2 htmlElement2 = (NativeMethods.IHTMLElement2) _htmlDivOuter;
            Debug.Assert(null != htmlElement2);
            return htmlElement2.GetClientWidth();
        }

        internal static int GetHtmlFragmentWidth(String htmlFragment)
        {
            Debug.Assert(null != _htmlDivOuter && null != _htmlDivInner);
            _htmlDivInner.SetInnerHTML(htmlFragment);
            NativeMethods.IHTMLElement2 htmlElement2 = (NativeMethods.IHTMLElement2) _htmlDivOuter;
            Debug.Assert(null != htmlElement2);
            return htmlElement2.GetClientWidth();
        }

        internal static int GetHtmlFragmentHeight(String htmlFragment)
        {
            Debug.Assert(null != _htmlDivOuter && null != _htmlDivInner);
            _htmlDivInner.SetInnerHTML(htmlFragment);
            NativeMethods.IHTMLElement2 htmlElement2 = (NativeMethods.IHTMLElement2) _htmlDivOuter;
            Debug.Assert(null != htmlElement2);
            return htmlElement2.GetClientHeight();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\ienumoleundounits.cs ===
//------------------------------------------------------------------------------
// <copyright file="IEnumOleUndoUnits.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IEnumOleUndoUnits.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VSDesigner.Interop {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport(),System.Runtime.InteropServices.Guid("B3E7C340-EF97-11CE-9BC9-00AA00608E01"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IEnumOleUndoUnits {

        
         void Next(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)] 
             int cElt,
            [System.Runtime.InteropServices.In, System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
               Microsoft.VSDesigner.Interop.IOleUndoUnit[] rgElt,
            [System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
              int[] pcEltFetched);

        
         void Skip(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)] 
             int cElt);

        
         void Reset();

        
         void Clone(
            [System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
               Microsoft.VSDesigner.Interop.IEnumOleUndoUnits[] ppEnum);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\iolecommandtarget.cs ===
//------------------------------------------------------------------------------
// <copyright file="IOleCommandTarget.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IOleCommandTarget.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VSDesigner.Interop {
    using System;
    using System.Runtime.InteropServices;

    [System.Runtime.InteropServices.ComVisible(true), 
    ComImport,
    Guid("B722BCCB-4E68-101B-A2BC-00AA00404770"),
    System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliantAttribute(false)
    ]
    internal interface IOleCommandTarget {

        //C#r: UNDONE (Field in interface) public static readonly    Guid iid;
        [return: MarshalAs(UnmanagedType.I4)]
        [System.Runtime.InteropServices.PreserveSig]
        int QueryStatus(
                       ref Guid pguidCmdGroup,
                       int cCmds,
                       [In, Out] 
                       Microsoft.VSDesigner.Interop._tagOLECMD prgCmds,
                       [In, Out] 
                       int pCmdText);

        [return: MarshalAs(UnmanagedType.I4)]
        [System.Runtime.InteropServices.PreserveSig]
        int Exec(
                ref Guid pguidCmdGroup,
                int nCmdID,
                int nCmdexecopt,
                // we need to have this an array because callers need to be able to specify NULL or VT_NULL
                [In, MarshalAs(UnmanagedType.LPArray)]
                Object[] pvaIn,
                int pvaOut);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\fontconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter"]/*' />
    /// <devdoc>
    ///      FontConverter is a class that can be used to convert
    ///      fonts from one data type to another.  Access this
    ///      class through the TypeDescriptor.
    /// </devdoc>
    public class FontConverter : TypeConverter {

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {

            if (value is string) {

                string text = ((string)value).Trim();

                if (text.Length == 0) {
                    return null;
                }
                else {
                    // Parse an array of values.
                    //
                    if (culture == null) {
                        culture = CultureInfo.CurrentCulture;
                    }                                        
                    char sep = culture.TextInfo.ListSeparator[0];
                    string[] tokens = text.Split(new char[] {sep});

                    string name;
                    float size = 8;
                    FontStyle style = FontStyle.Regular;
                    GraphicsUnit units =  GraphicsUnit.Point;

                    if (tokens.Length < 1) {
                        throw new ArgumentException(SR.GetString(SR.TextParseFailedFormat,
                                                                  text,
                                                                  "name, size[units[, style]]"));
                    }

                    name = tokens[0];

                    if (tokens.Length > 1) {
                        string[] unitTokens = ParseSizeTokens(tokens[1]);

                        if (unitTokens[0] != null) {
                            size = (float)TypeDescriptor.GetConverter(typeof(float)).ConvertFromString(context, culture, unitTokens[0]); 
                        }

                        if (unitTokens[1] != null) {
                            units = ParseGraphicsUnits(unitTokens[1]);
                        }
                    }

                    if (tokens.Length > 2) {
                        string styleText = string.Join(",", tokens, 2, tokens.Length - 2);
                        styleText = styleText.Trim();
                        if (!styleText.StartsWith("style") || styleText.IndexOf('=') == -1)
                            throw new ArgumentException(SR.GetString(SR.TextParseFailedFormat,
                                                                      text,
                                                                      "name, size[units[, style]]"));
                        styleText = styleText.Substring(styleText.IndexOf('=') + 1);
                        styleText = styleText.Trim();
                        style = (FontStyle)Enum.Parse(typeof(FontStyle), styleText, true);
                        
                        // Enum.IsDefined doesn't do what we want on flags enums...
                        FontStyle validBits = FontStyle.Regular | FontStyle.Bold | FontStyle.Italic | FontStyle.Underline | FontStyle.Strikeout;
                        if ((style | validBits) != validBits)
                            throw new InvalidEnumArgumentException("style", (int)style, typeof(FontStyle));
                    }
                    
                    // should get cached version from TypeDescriptor                                                                                                
                    name = (string)(new FontNameConverter().ConvertFrom(context, culture, name));
                    
                    return new Font(name, size, style, units);
                }
            }

            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                Font font = (Font)value;

                if (font == null) {
                    return SR.GetString(SR.toStringNone);
                }
                else {
                    if (culture == null) {
                        culture = CultureInfo.CurrentCulture;
                    }                                        
                    string sep = culture.TextInfo.ListSeparator + " ";
                    
                    int argCount = 2;
                    if (font.Style != FontStyle.Regular)
                        argCount++;
                    string[] args = new string[argCount];
                    int nArg = 0;

                    // should go through type converters here -- we already need
                    // converts for Name, Size and Units.
                    //
                    args[nArg++] = font.Name;
                    args[nArg++] = TypeDescriptor.GetConverter(font.Size).ConvertToString(context, culture, font.Size) + GetGraphicsUnitText(font.Unit);
                    if (font.Style != FontStyle.Regular)
                        args[nArg++] = "style=" + font.Style.ToString("G");

                    return string.Join(sep, args);
                }
            }
            if (destinationType == typeof(InstanceDescriptor) && value is Font) {
                
                Font font = (Font)value;
                
                // Custom font, not derived from any stock font
                //
                int argCount = 2;

                if (font.GdiVerticalFont) {
                    argCount = 6;
                }
                else if (font.GdiCharSet != Font.DEFAULT_CHARSET) {
                    argCount = 5;
                }
                else if (font.Unit != GraphicsUnit.Point) {
                    argCount = 4;
                }
                else if (font.Style != FontStyle.Regular) {
                    argCount++;
                }

                object[] args = new object[argCount];
                Type[] types = new Type[argCount];

                // Always specifying the eight parameter constructor is nastily confusing.
                // Use as simple a constructor as possible.
                //
                args[0] = font.Name; types[0] = typeof(string);
                args[1] = font.Size; types[1] = typeof(float);
                
                if (argCount > 2) {
                    args[2] = font.Style; types[2] = typeof(FontStyle);
                }

                if (argCount > 3) {
                    args[3] = font.Unit; types[3] = typeof(GraphicsUnit);
                }
                
                if (argCount > 4) {
                    args[4] = font.GdiCharSet; types[4] = typeof(byte);
                }
                
                if (argCount > 5) {
                    args[5] = font.GdiVerticalFont; types[5] = typeof(bool);
                }
                
                MemberInfo ctor = typeof(Font).GetConstructor(types);
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, args);
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.CreateInstance"]/*' />
        /// <devdoc>
        ///      Creates an instance of this type given a set of property values
        ///      for the object.  This is useful for objects that are immutable, but still
        ///      want to provide changable properties.
        /// </devdoc>
        public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues) {
            object name       = propertyValues["Name"];
            object size       = propertyValues["Size"];
            object units      = propertyValues["Unit"];
            object bold       = propertyValues["Bold"];
            object italic     = propertyValues["Italic"];
            object strikeout  = propertyValues["Strikeout"];
            object underline  = propertyValues["Underline"];
            object gdiCharSet = propertyValues["GdiCharSet"];
            object gdiVerticalFont = propertyValues["GdiVerticalFont"];

            // If any of these properties are null, it may indicate a change in font that
            // was not propgated to FontConverter.
            //
            Debug.Assert(name != null && size != null && units != null && 
                         bold != null && italic != null && strikeout != null && gdiCharSet != null && 
                         underline != null, "Missing font properties.  Did Font change without FontConverter getting updated?");

            if (name == null)       name = "Tahoma";
            if (size == null)       size = 8.0f;
            if (units == null)      units = GraphicsUnit.Point;
            if (gdiCharSet == null) gdiCharSet = 0;
            if (gdiVerticalFont == null) gdiVerticalFont = false;

            FontStyle style = 0;
            if (bold != null && ((bool)bold)) style |= FontStyle.Bold;
            if (italic != null && ((bool)italic)) style |= FontStyle.Italic;
            if (strikeout != null && ((bool)strikeout)) style |= FontStyle.Strikeout;
            if (underline != null && ((bool)underline)) style |= FontStyle.Underline;

            return new Font((string)name,
                            (float)size,
                            style,
                            (GraphicsUnit)units,
                            (byte)gdiCharSet,
                            (bool)gdiVerticalFont);
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.GetCreateInstanceSupported"]/*' />
        /// <devdoc>
        ///      Determines if changing a value on this object should require a call to
        ///      CreateInstance to create a new value.
        /// </devdoc>
        public override bool GetCreateInstanceSupported(ITypeDescriptorContext context) {
            return true;
        }
        
        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.GetGraphicsUnitText"]/*' />
        /// <devdoc>
        ///     Returns a text description for the font units
        /// </devdoc>
        private string GetGraphicsUnitText(GraphicsUnit units) {
            string unitStr = "";

            for (int i = 0; i < UnitName.names.Length; i++) {
                if (UnitName.names[i].unit == units) {
                    unitStr = UnitName.names[i].name;
                    break;
                }
            }
            return unitStr;
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.GetProperties"]/*' />
        /// <devdoc>
        ///      Retrieves the set of properties for this type.  By default, a type has
        ///      does not return any properties.  An easy implementation of this method
        ///      can just call TypeDescriptor.GetProperties for the correct data type.
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
            PropertyDescriptorCollection props = TypeDescriptor.GetProperties(typeof(Font), attributes);
            return props.Sort(new string[] {"Name", "Size", "Unit", "Weight"});
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.GetPropertiesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports properties.  By default, this
        ///      is false.
        /// </devdoc>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.ParseSizeTokens"]/*' />
        /// <devdoc>
        ///      Takes a string of the format ####.##CC and parses it into two 
        ///      strings.
        /// </devdoc>
        private string[] ParseSizeTokens(string text) {
            text = text.Trim();
            int length = text.Length;
            int splitPoint;


            for (splitPoint = 0; splitPoint < length; splitPoint++) {
                if (Char.IsLetter(text[splitPoint])) {
                    break;
                }
            }

            string size = null;
            string units = null;

            if (length > 0 && splitPoint > 0) {
                size = text.Substring(0, splitPoint);
            }

            if (splitPoint < length) {
                units = text.Substring(splitPoint);
            }

            return new string[] {size, units};
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.ParseGraphicsUnits"]/*' />
        /// <devdoc>
        ///     Parses the font units from the given text.
        /// </devdoc>
        private GraphicsUnit ParseGraphicsUnits(string units) {
            UnitName unitName = null;

            for (int i = 0; i < UnitName.names.Length; i++) {
                if (String.Compare(UnitName.names[i].name, units, true) == 0) {
                    unitName = UnitName.names[i];
                    break;
                }
            }

            if (unitName == null) {
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "units", units));
            }
            return unitName.unit;
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.UnitName"]/*' />
        /// <devdoc>
        ///     Simple private class to associate a font size unit with a text name.
        /// </devdoc>
        internal class UnitName {

            internal string name; 

            internal GraphicsUnit unit;

            internal static readonly UnitName[] names = new UnitName[] {
                    new UnitName("world", GraphicsUnit.World), // made up
                    new UnitName("display", GraphicsUnit.Display), // made up
                    new UnitName("px", GraphicsUnit.Pixel),
                    new UnitName("pt", GraphicsUnit.Point),
                    new UnitName("in", GraphicsUnit.Inch),
                    new UnitName("doc", GraphicsUnit.Document), // made up
                    new UnitName("mm", GraphicsUnit.Millimeter),
                };


            internal UnitName(string name, GraphicsUnit unit) {
                this.name = name;
                this.unit = unit;
            }
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter"]/*' />
        /// <devdoc>
        ///      FontNameConverter is a type converter that is used to convert
        ///      a font name to and from various other representations.
        /// </devdoc>
        /// <internalonly/>
        public sealed class FontNameConverter : TypeConverter {

            private StandardValuesCollection values;

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.FontNameConverter"]/*' />
            /// <devdoc>
            ///      Creates a new font name converter.
            /// </devdoc>
            public FontNameConverter() {

                // Sink an event to let us know when the installed
                // set of fonts changes.
                //
                SystemEvents.InstalledFontsChanged += new EventHandler(this.OnInstalledFontsChanged);
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.CanConvertFrom"]/*' />
            /// <devdoc>
            ///      Determines if this converter can convert an object in the given source
            ///      type to the native type of the converter.
            /// </devdoc>
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
                if (sourceType == typeof(string)) {
                    return true;
                }
                return base.CanConvertFrom(context, sourceType);
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.ConvertFrom"]/*' />
            /// <devdoc>
            ///      Converts the given object to the converter's native type.
            /// </devdoc>
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
                if (value is string) {
                    return MatchFontName((string)value, context);
                }
                return base.ConvertFrom(context, culture, value);
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.Finalize"]/*' />
            /// <devdoc>
            ///      We need to know when we're finalized.
            /// </devdoc>
            ~FontNameConverter() {
                SystemEvents.InstalledFontsChanged -= new EventHandler(this.OnInstalledFontsChanged);
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.GetStandardValues"]/*' />
            /// <devdoc>
            ///      Retrieves a collection containing a set of standard values
            ///      for the data type this validator is designed for.  This
            ///      will return null if the data type does not support a
            ///      standard set of values.
            /// </devdoc>
            public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
                if (values == null) {
                    FontFamily[] fonts =  FontFamily.Families;

                    Hashtable hash = new Hashtable();
                    for (int i = 0; i < fonts.Length; i++) {
                            string name = fonts[i].Name;
                            hash[name.ToLower()] = name;
                    }

                    object[] array = new object[hash.Values.Count];
                    hash.Values.CopyTo(array, 0);
                    Array.Sort(array);
                    values = new StandardValuesCollection(array);
                }

                return values;
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.GetStandardValuesExclusive"]/*' />
            /// <devdoc>
            ///      Determines if the list of standard values returned from
            ///      GetStandardValues is an exclusive list.  If the list
            ///      is exclusive, then no other values are valid, such as
            ///      in an enum data type.  If the list is not exclusive,
            ///      then there are other valid values besides the list of
            ///      standard values GetStandardValues provides.
            /// </devdoc>
            public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
                return false;
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.GetStandardValuesSupported"]/*' />
            /// <devdoc>
            ///      Determines if this object supports a standard set of values
            ///      that can be picked from a list.
            /// </devdoc>
            public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
                return true;
            }
            
            private string MatchFontName(string name, ITypeDescriptorContext context) {
                Debug.Assert(name != null, "Expected an actual font name to match in FontNameConverter::MatchFontName.");
                
                // Try a partial match
                //
                string bestMatch = null;
                name = name.ToLower();
                IEnumerator e = GetStandardValues(context).GetEnumerator();
                while (e.MoveNext()) {
                    string fontName = e.Current.ToString().ToLower();
                    if (fontName.Equals(name)) {
                        // For an exact match, return immediately
                        //
                        return e.Current.ToString();
                    }
                    else if (fontName.StartsWith(name)) {
                        if (bestMatch == null || fontName.Length <= bestMatch.Length) {
                            bestMatch = e.Current.ToString();
                        }
                    }
                }
                
                if (bestMatch == null) {
                    // no match... fall back on whatever was provided
                    bestMatch = name;
                }
                return bestMatch;
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.OnInstalledFontsChanged"]/*' />
            /// <devdoc>
            ///      Called by system events when someone adds or removes a font.  Here
            ///      we invalidate our font name collection.
            /// </devdoc>
            private void OnInstalledFontsChanged(object sender, EventArgs e) {
                values = null;
            }
        }    

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontUnitConverter"]/*' />
        /// <devdoc>
        ///      FontUnitConverter strips out the members of GraphicsUnit that are invalid for fonts.
        /// </devdoc>
        /// <internalonly/>
        public class FontUnitConverter : EnumConverter {
            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontUnitConverter.FontUnitConverter"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public FontUnitConverter() : base(typeof(GraphicsUnit)) {
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontUnitConverter.GetStandardValues"]/*' />
            /// <internalonly/>
            public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
                if (Values == null) {
                    base.GetStandardValues(context); // sets "values"
                    ArrayList filteredValues = new ArrayList(Values);
                    filteredValues.Remove(GraphicsUnit.Display);
                    Values = new StandardValuesCollection(filteredValues);
                }
                return Values;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\datafieldconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataFieldConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Globalization;

    /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides design-time support for a component's data field properties.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DataFieldConverter : TypeConverter {

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.DataFieldConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.DataFieldConverter'/>.
        ///    </para>
        /// </devdoc>
        public DataFieldConverter() {
        }

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this converter can
        ///       convert an object in the given source type to the native type of the converter
        ///       using the context.
        ///    </para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return false;
        }

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the given object to the converter's native type.
        ///    </para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value == null) {
                return String.Empty;
            }
            else if (value.GetType() == typeof(string)) {
                return (string)value;
            }
            throw GetConvertFromException(value);
        }

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the fields present within the selected data source if information about them is available.
        ///    </para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            object[] names = null;
            
            if (context != null) {
                ArrayList list = new ArrayList();

                PropertyDescriptorCollection props = null;

                // REVIEW: We should try and support the multi-select scenario - Get the data source
                //         from each selected component. If they are the same, we can proceed,
                //         otherwise return an empty collection.

                // This converter shouldn't be used in a multi-select scenario. If it is, it simply
                // returns no standard values.

                IComponent component = context.Instance as IComponent;
                if (component != null) {
                    ISite componentSite = component.Site;
                    if (componentSite != null) {
                        IDesignerHost designerHost = (IDesignerHost)componentSite.GetService(typeof(IDesignerHost));
                        if (designerHost != null) {
                            IDesigner designer = designerHost.GetDesigner(component);

                            if (designer is IDataSourceProvider) {
                                IEnumerable dataSource = ((IDataSourceProvider)designer).GetResolvedSelectedDataSource();

                                if (dataSource != null) {
                                    props = DesignTimeData.GetDataFields(dataSource);
                                }
                            }
                        }
                    }
                }
                
                if (props != null) {
                    foreach (PropertyDescriptor propDesc in props) {
                        list.Add(propDesc.Name);
                    }
                }

                names = list.ToArray();
                Array.Sort(names);
            }
            return new StandardValuesCollection(names);
        }

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the collection of standard values returned from
        ///    <see cref='System.ComponentModel.TypeConverter.GetStandardValues'/> is an exclusive 
        ///       list of possible values, using the specified context.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return false;
        }

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this object supports a standard set of values
        ///       that can be picked from a list.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            if (context.Instance is IComponent) {
                // We only support the dropdown in single-select mode.
                return true;
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\datamemberconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataMemberConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Globalization;
    using System.Runtime.InteropServices;

    /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides design-time support for a component's DataMember properties.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class DataMemberConverter : TypeConverter {

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.DataMemberConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.DataFieldConverter'/>.
        ///    </para>
        /// </devdoc>
        public DataMemberConverter() {
        }

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this converter can
        ///       convert an object in the given source type to the native type of the converter
        ///       using the context.
        ///    </para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return false;
        }

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the given object to the converter's native type.
        ///    </para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value == null) {
                return String.Empty;
            }
            else if (value.GetType() == typeof(string)) {
                return (string)value;
            }
            throw GetConvertFromException(value);
        }

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the fields present within the selected data source if information about them is available.
        ///    </para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            string[] names = null;
            
            if (context != null) {
                // REVIEW: We should try and support the multi-select scenario - Get the data source
                //         from each selected component. If they are the same, we can proceed,
                //         otherwise return an empty collection.

                // This converter shouldn't be used in a multi-select scenario. If it is, it simply
                // returns no standard values.
                IComponent component = context.Instance as IComponent;

                if (component != null) {
                    ISite componentSite = component.Site;
                    if (componentSite != null) {
                        IDesignerHost designerHost = (IDesignerHost)componentSite.GetService(typeof(IDesignerHost));
                        if (designerHost != null) {
                            IDesigner designer = designerHost.GetDesigner(component);

                            if (designer is IDataSourceProvider) {
                                object dataSource = ((IDataSourceProvider)designer).GetSelectedDataSource();

                                if (dataSource != null) {
                                    names = DesignTimeData.GetDataMembers(dataSource);
                                }
                            }
                        }
                    }
                }
                
                if (names == null) {
                    names = new string[0];
                }
                Array.Sort(names);
            }
            return new StandardValuesCollection(names);
        }

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the collection of standard values returned from
        ///    <see cref='System.ComponentModel.TypeConverter.GetStandardValues'/> is an exclusive 
        ///       list of possible values, using the specified context.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return false;
        }

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this object supports a standard set of values
        ///       that can be picked from a list.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            if (context.Instance is IComponent) {
                // We only support the dropdown in single-select mode.
                return true;
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\ioleparentundounit.cs ===
//------------------------------------------------------------------------------
// <copyright file="IOleParentUndoUnit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IOleParentUndoUnit.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VSDesigner.Interop {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport, System.Runtime.InteropServices.ComVisible(true),System.Runtime.InteropServices.Guid("A1FAF330-EF97-11CE-9BC9-00AA00608E01"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IOleParentUndoUnit {

        [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
         [PreserveSig]
         int Do(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
              Microsoft.VSDesigner.Interop.IOleUndoManager pUndoManager);

        [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)]
          string GetDescription();

        [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
         [PreserveSig]
         int GetUnitType(
              ref Guid pClsid,
            [System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
              int[] plID);

        
         void OnNextAdd();

        
         void Open(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
              Microsoft.VSDesigner.Interop.IOleParentUndoUnit pPUU);

        [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
         [PreserveSig]
         int Close(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
              Microsoft.VSDesigner.Interop.IOleParentUndoUnit pPUU,
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Bool)] 
             bool fCommit);

        
         void Add(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
              Microsoft.VSDesigner.Interop.IOleUndoUnit pUU);

        [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
         [PreserveSig]
         int FindUnit(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
              Microsoft.VSDesigner.Interop.IOleUndoUnit pUU);

        
         void GetParentState(
            [System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
              int[] pdwState);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\ioleundounit.cs ===
//------------------------------------------------------------------------------
// <copyright file="IOleUndoUnit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IOleUndoUnit.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VSDesigner.Interop {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport, System.Runtime.InteropServices.ComVisible(true),System.Runtime.InteropServices.Guid("894AD3B0-EF97-11CE-9BC9-00AA00608E01"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IOleUndoUnit {

        [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
         [PreserveSig]
         int Do(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
              Microsoft.VSDesigner.Interop.IOleUndoManager pUndoManager);

        [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)]
          string GetDescription();

        [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
         [PreserveSig]
         int GetUnitType(
              ref System.Guid pClsid,
            [System.Runtime.InteropServices.Out,System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPArray)] 
              int[] plID);

        
         void OnNextAdd();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\ipersiststreaminit.cs ===
//------------------------------------------------------------------------------
// <copyright file="IPersistStreamInit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IPersistStreamInit.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VSDesigner.Interop {
    using System;
    using System.Runtime.InteropServices;

    [
        System.Runtime.InteropServices.ComVisible(true), 
        ComImport,
        Guid("7FD52380-4E07-101B-AE2D-08002B2EC713"),
        System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown),
        CLSCompliantAttribute(false)
    ]
    internal interface IPersistStreamInit {

        void GetClassID(
                       [In, Out] 
                       ref Guid pClassID);

        [return: MarshalAs(UnmanagedType.I4)]
        [PreserveSig]
        int IsDirty();

        
        void Load(
                 [In, MarshalAs(UnmanagedType.Interface)] 
                 IStream pstm);

        
        void Save(
                 [In, MarshalAs(UnmanagedType.Interface)] 
                 IStream pstm,
                 [In, MarshalAs(UnmanagedType.Bool)] 
                 bool fClearDirty);

        
        void GetSizeMax(
                       [Out, MarshalAs(UnmanagedType.LPArray)] 
                       long pcbSize);

        
        void InitNew();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\externdll.cs ===
//------------------------------------------------------------------------------
// <copyright file="ExternDll.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System {
    internal class ExternDll {

        public const string Gdiplus = "gdiplus.dll";
        public const string User32 = "user32.dll";
        public const string Shfolder = "shfolder.dll";
        public const string Imm32 = "imm32.dll";
        public const string Advapi32 = "advapi32.dll";
        public const string Shell32 = "shell32.dll";
        public const string Kernel32 = "kernel32.dll";
        public const string Comctl32 = "comctl32.dll";
        public const string Oleaut32 = "oleaut32.dll";
        public const string Olepro32 = "olepro32.dll";
        public const string Ole32 = "ole32.dll";
        public const string Gdi32 = "gdi32.dll";
        public const string Comdlg32 = "comdlg32.dll";
        public const string Uxtheme = "uxtheme.dll";
        public const string Oleacc = "oleacc.dll";
        public const string Hhctrl = "hhctrl.ocx";
        public const string Winspool = "winspool.drv";
        public const string Psapi = "psapi.dll";
        public const string Ntdll = "ntdll.dll";
        public const string Version = "version.dll";
        public const string Vsassert = "vsassert.dll";
        public const string Mscoree = "mscoree.dll";
        public const string Msi = "msi.dll";
        public const string Mqrt = "mqrt.dll";
        public const string Activeds = "activeds.dll";
        public const string Loadperf = "Loadperf.dll";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\ivsusercontext.cs ===
//------------------------------------------------------------------------------
// <copyright file="IVsUserContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsUserContext.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VSDesigner.Interop {
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport, System.Runtime.InteropServices.ComVisible(true), Guid("761081DF-D45F-4683-9B9E-1B7241E56F5C"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsUserContext {

        
         void AddAttribute(
             tagVsUserContextAttributeUsage usage,
             [System.Runtime.InteropServices.In, MarshalAs(UnmanagedType.LPWStr)] 
             string szName,
             [System.Runtime.InteropServices.In, MarshalAs(UnmanagedType.LPWStr)] 
             string szValue);

        [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.I4)]
         [PreserveSig]
         int RemoveAttribute(
             [System.Runtime.InteropServices.In, MarshalAs(UnmanagedType.LPWStr)] 
             string szName,
             [System.Runtime.InteropServices.In, MarshalAs(UnmanagedType.LPWStr)] 
             string szValue);

        [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)]
         int AddSubcontext(
             Microsoft.VSDesigner.Interop.IVsUserContext pSubCtx,
             int priority);

        
         void RemoveSubcontext(
             [System.Runtime.InteropServices.In, MarshalAs(UnmanagedType.U4)] 
             int cookie);

        
         int CountAttributes(
             [System.Runtime.InteropServices.In, MarshalAs(UnmanagedType.BStr)] 
             string pszName,
             int fIncludeChildren);

        [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)]
          string GetAttribute(
             int iAttribute,
             [System.Runtime.InteropServices.In, MarshalAs(UnmanagedType.LPWStr)] 
             string pszName,
             int fIncludeChildren,
             out string pbstrName);

        
         int CountSubcontexts();

        
          Microsoft.VSDesigner.Interop.IVsUserContext GetSubcontext(
             int i);

        
        bool IsDirty();

        
         void SetDirty(
             bool fDirty);

        
         void Update();

        [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)]
         int AdviseUpdate(
              Microsoft.VSDesigner.Interop.IVsUserContextUpdate pUpdate);

        
         void UnadviseUpdate(
            [System.Runtime.InteropServices.In, MarshalAs(UnmanagedType.U4)] 
             int dwCookie);

        
         tagVsUserContextAttributeUsage GetAttrUsage(
             int index,
             bool fIncludeChildren);
        
         
          void RemoveAllSubcontext();
        
         
          int GetPriority();
        
         
          void RemoveAttributeIncludeChildren(
                      [System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPWStr)]
                      string szName,
                      [System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPWStr)]
                      string szValue);
        
         [return: System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)]
          string GetAttributePri(
                      int iAttribute,
                      [System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPWStr)]
                      string pszName,
                      bool fIncludeChildren,
                      out int piPriority,
                      [System.Runtime.InteropServices.MarshalAs(UnmanagedType.BStr)]
                      out string pbstrName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\istream.cs ===
//------------------------------------------------------------------------------
// <copyright file="IStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IStream.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VSDesigner.Interop {
    using System;
    using System.Runtime.InteropServices;

    [System.Runtime.InteropServices.ComVisible(true), Guid("0000000C-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    [System.Runtime.InteropServices.ComImport]
    internal interface IStream {

        //C#r: UNDONE (Field in interface) public static readonly    Guid iid;
        //C#r: UNDONE (Field in interface) public const   int LOCK_WRITE = 0x1;
        //C#r: UNDONE (Field in interface) public const   int LOCK_EXCLUSIVE = 0x2;
        //C#r: UNDONE (Field in interface) public const   int LOCK_ONLYONCE = 0x4;
        //C#r: UNDONE (Field in interface) public const   int STATFLAG_DEFAULT = 0x0;
        //C#r: UNDONE (Field in interface) public const   int STATFLAG_NONAME = 0x1;
        //C#r: UNDONE (Field in interface) public const   int STATFLAG_NOOPEN = 0x2;
        //C#r: UNDONE (Field in interface) public const   int STGC_DEFAULT = 0x0;
        //C#r: UNDONE (Field in interface) public const   int STGC_OVERWRITE = 0x1;
        //C#r: UNDONE (Field in interface) public const   int STGC_ONLYIFCURRENT = 0x2;
        //C#r: UNDONE (Field in interface) public const   int STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 0x4;
        //C#r: UNDONE (Field in interface) public const   int STREAM_SEEK_SET = 0x0;
        //C#r: UNDONE (Field in interface) public const   int STREAM_SEEK_CUR = 0x1;
        //C#r: UNDONE (Field in interface) public const   int STREAM_SEEK_END = 0x2;
        [return: MarshalAs(UnmanagedType.I4)]
         int Read(
            [In] 
             IntPtr buf,
            [In, MarshalAs(UnmanagedType.I4)] 
             int len);

        [return: MarshalAs(UnmanagedType.I4)]
         int Write(
            [In] 
             IntPtr buf,
            [In] 
             int len);

        [return: MarshalAs(UnmanagedType.I8)]
         long Seek(
            [In, MarshalAs(UnmanagedType.I8)] 
             long dlibMove,
            [In, MarshalAs(UnmanagedType.I4)] 
             int dwOrigin);

        
         void SetSize(
            [In, MarshalAs(UnmanagedType.I8)] 
             long libNewSize);

        [return: MarshalAs(UnmanagedType.I8)]
         long CopyTo(
            [In, MarshalAs(UnmanagedType.Interface)] 
              Microsoft.VSDesigner.Interop.IStream pstm,
            [In, MarshalAs(UnmanagedType.I8)] 
             long cb,
            [Out, MarshalAs(UnmanagedType.LPArray)] 
              long[] pcbRead);

        
         void Commit(
            [In, MarshalAs(UnmanagedType.I4)] 
             int grfCommitFlags);

        
         void Revert();

        
         void LockRegion(
            [In, MarshalAs(UnmanagedType.I8)] 
             long libOffset,
            [In, MarshalAs(UnmanagedType.I8)] 
             long cb,
            [In, MarshalAs(UnmanagedType.I4)] 
             int dwLockType);

        
         void UnlockRegion(
            [In, MarshalAs(UnmanagedType.I8)] 
             long libOffset,
            [In, MarshalAs(UnmanagedType.I8)] 
             long cb,
            [In, MarshalAs(UnmanagedType.I4)] 
             int dwLockType);

        
         void Stat(
            [In, MarshalAs(UnmanagedType.I4)] 
              int pStatstg,
            [In, MarshalAs(UnmanagedType.I4)] 
             int grfStatFlag);

        [return: MarshalAs(UnmanagedType.Interface)]
          Microsoft.VSDesigner.Interop.IStream Clone();


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\ivsusercontextupdate.cs ===
//------------------------------------------------------------------------------
// <copyright file="IVsUserContextUpdate.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// IVsUserContextUpdate.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VSDesigner.Interop {
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport(),System.Runtime.InteropServices.Guid("F5ED7D1C-61B6-428A-8129-E13B36D9E9A7"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IVsUserContextUpdate {

        
         void UpdateUserContext(
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.Interface)] 
              Microsoft.VSDesigner.Interop.IVsUserContext pCtx,
            [System.Runtime.InteropServices.In,System.Runtime.InteropServices.MarshalAs(UnmanagedType.U4)] 
             int dwCookie);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\mshtmleditcommands.cs ===
//------------------------------------------------------------------------------
// <copyright file="MshtmlEditCommands.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VSDesigner.Interop.Trident {

    using System;
    
    /// <summary>
    ///     
    /// </summary>
    internal class MshtmlEditCommands {
        public static readonly Guid guidMSHTMLCmdSet = new Guid("DE4BA900-59CA-11CF-9592-444553540000");

        public static readonly int icmdMultipleSelection = 2393;

        public static readonly int icmdLiveResize = 2398;

        public static readonly int icmd2DPosition = 2394;

        public static readonly int icmdPeristDefaultValues = 7100;

        public static readonly int icmdShowZeroBorderAtDesignTime = 2328;

        public static readonly int icmdSetDirty = 2342;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\nativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Design {
    using System.Runtime.InteropServices;
    using System;
    using System.Drawing;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [System.Runtime.InteropServices.ComVisible(false)]
    internal class NativeMethods {
        public const int WM_USER = 0x0400,
        WM_GETDLGCODE = 0x0087,
        WM_MOUSEMOVE = 0x0200,
        WM_NOTIFY = 0x004E,
        DLGC_WANTALLKEYS = 0x0004,
        NM_CLICK = ((0-0)-2),
        WM_REFLECT          = WM_USER + 0x1C00,
        BM_SETIMAGE = 0x00F7,
        IMAGE_ICON = 1,
        BS_ICON = 0x00000040;

        public const int    VK_PROCESSKEY = 0xE5;

        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int MultiByteToWideChar(int CodePage, int dwFlags,
                                                     byte[] lpMultiByteStr, int cchMultiByte, char[] lpWideCharStr, int cchWideChar);
        
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class NMHEADER {
            public int hwndFrom; 
            public int idFrom; 
            public int code; 
            public int iItem;
            public int iButton;
            public int pItem;  // HDITEM*
        }
        [StructLayout(LayoutKind.Sequential)]
        public class POINT {
            public int x;
            public int y;

            public POINT() {
            }

            public POINT(int x, int y) {
                this.x = x;
                this.y = y;
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct WINDOWPOS {
            public IntPtr hwnd;
            public IntPtr hwndInsertAfter;
            public int x;
            public int y;
            public int cx;
            public int cy;
            public int flags;
        }
        
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto, Pack=1)]
        public class TV_ITEM {
            public int	mask;
            public int	hItem;
            public int	state;
            public int	stateMask;
            public int /* LPTSTR */	pszText;
            public int	cchTextMax;
            public int	iImage;
            public int	iSelectedImage;
            public int	cChildren;
            public int	lParam;
        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class NMHDR
        {
            public int hwndFrom;
            public int idFrom;
            public int code;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class NMTREEVIEW
        {
            public NMHDR    nmhdr;
            public int      action;
            public TV_ITEM  itemOld;
            public TV_ITEM  itemNew;
            public POINT    ptDrag;
        }


        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class TCHITTESTINFO {
            public Point pt;
            public TabControlHitTest flags;
        }

        public const int TCM_HITTEST = 4877;

        [Flags]
        public enum TabControlHitTest {
            TCHT_NOWHERE         =   0x0001,
            TCHT_ONITEMICON      =   0x0002,
            TCHT_ONITEMLABEL     =   0x0004
        }

        [System.Runtime.InteropServices.ComVisible(false)]
        public enum StructFormat {
            Ansi = 1,
            Unicode = 2,
            Auto = 3,
        }


        public static IntPtr InvalidIntPtr = ((IntPtr)((int)(-1)));

        public const int S_OK =      0x00000000;
        public const int S_FALSE =   0x00000001;
        public const int E_NOTIMPL = unchecked((int)0x80004001);
        public const int E_NOINTERFACE = unchecked((int)0x80004002);
        public const int E_INVALIDARG = unchecked((int)0x80070057);
        public const int E_FAIL = unchecked((int)0x80004005);

        public const int WS_EX_STATICEDGE = 0x00020000;

        public const int
        OLEIVERB_PRIMARY = 0,
        OLEIVERB_SHOW = -1,
        OLEIVERB_OPEN = -2,
        OLEIVERB_HIDE = -3,
        OLEIVERB_UIACTIVATE = -4,
        OLEIVERB_INPLACEACTIVATE = -5,
        OLEIVERB_DISCARDUNDOSTATE = -6,
        OLEIVERB_PROPERTIES = -7;

        public const int
        OLECLOSE_SAVEIFDIRTY = 0,
        OLECLOSE_NOSAVE = 1,
        OLECLOSE_PROMPTSAVE = 2;

        public const int
        PM_NOREMOVE = 0x0000,
        PM_REMOVE = 0x0001;

        public const int
        WM_CHAR = 0x0102;

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetClientRect(IntPtr hWnd, [In, Out] ref RECT rect);

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetClientRect(IntPtr hWnd, [In, Out] COMRECT rect);

        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool PeekMessage([In, Out] ref MSG msg, IntPtr hwnd, int msgMin, int msgMax, int remove);

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
        public static extern bool PeekMessageA([In, Out] ref MSG msg, IntPtr hwnd, int msgMin, int msgMax, int remove);

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern bool PeekMessageW([In, Out] ref MSG msg, IntPtr hwnd, int msgMin, int msgMax, int remove);

        [StructLayout(LayoutKind.Sequential)]
        public struct MSG {
            public IntPtr hwnd;
            public int  message;
            public IntPtr wParam;
            public IntPtr lParam;
            public int  time;
            // pt was a by-value POINT structure
            public int  pt_x;
            public int  pt_y;
        }

        [StructLayout(LayoutKind.Sequential)]
        public class COMRECT {
            public int left;
            public int top;
            public int right;
            public int bottom;

            public COMRECT() {
            }

            public COMRECT(int left, int top, int right, int bottom) {
                this.left = left;
                this.top = top;
                this.right = right;
                this.bottom = bottom;
            }

            public static COMRECT FromXYWH(int x, int y, int width, int height) {
                return new COMRECT(x,
                                   y,
                                   x + width,
                                   y + height);
            }
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public sealed class FORMATETC {
            [MarshalAs(UnmanagedType.I4)]
            public   int cfFormat;
            [MarshalAs(UnmanagedType.I4)]
            public   IntPtr ptd;
            [MarshalAs(UnmanagedType.I4)]
            public   int dwAspect;
            [MarshalAs(UnmanagedType.I4)]
            public   int lindex;
            [MarshalAs(UnmanagedType.I4)]
            public   int tymed;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class STGMEDIUM {
            [MarshalAs(UnmanagedType.I4)]
            public   int tymed;
            public   IntPtr unionmember;
            public   IntPtr pUnkForRelease;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct RECT {
            public int left;
            public int top;
            public int right;
            public int bottom;

            public RECT(int left, int top, int right, int bottom) {
                this.left = left;
                this.top = top;
                this.right = right;
                this.bottom = bottom;
            }

            public static RECT FromXYWH(int x, int y, int width, int height) {
                return new RECT(x,
                                y,
                                x + width,
                                y + height);
            }
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public sealed class OLECMD {
            [MarshalAs(UnmanagedType.U4)]
            public   int cmdID;
            [MarshalAs(UnmanagedType.U4)]
            public   int cmdf;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public sealed class tagOIFI {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U4)]
            public int cb;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)]
            public int fMDIApp;
            public IntPtr hwndFrame;
            public IntPtr hAccel;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U4)]
            public int cAccelEntries;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public sealed class tagSIZE {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)]
            public int cx;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)]
            public int cy;
        }

        [System.Runtime.InteropServices.ComVisible(true), StructLayout(LayoutKind.Sequential)]
        public sealed class tagSIZEL {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)]
            public int cx;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)]
            public int cy;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public sealed class tagLOGPALETTE {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U2)]
            public short palVersion;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U2)]
            public short palNumEntries;

            // UNMAPPABLE: palPalEntry: Cannot be used as a structure field.
            //  /* @com.structmap(UNMAPPABLE palPalEntry) */
            //  public UNMAPPABLE palPalEntry;
        }

        public class DOCHOSTUIDBLCLICK {
            public const int DEFAULT = 0x0;
            public const int SHOWPROPERTIES = 0x1;
            public const int SHOWCODE = 0x2;
        }

        public class DOCHOSTUIFLAG {
            public const int DIALOG = 0x1;
            public const int DISABLE_HELP_MENU = 0x2;
            public const int NO3DBORDER = 0x4;
            public const int SCROLL_NO = 0x8;
            public const int DISABLE_SCRIPT_INACTIVE = 0x10;
            public const int OPENNEWWIN = 0x20;
            public const int DISABLE_OFFSCREEN = 0x40;
            public const int FLAT_SCROLLBAR = 0x80;
            public const int DIV_BLOCKDEFAULT = 0x100;
            public const int ACTIVATE_CLIENTHIT_ONLY = 0x200;
            public const int DISABLE_COOKIE = 0x400;
        }

        [System.Runtime.InteropServices.ComVisible(true), StructLayout(LayoutKind.Sequential)]
        public class DOCHOSTUIINFO {
            [MarshalAs(UnmanagedType.U4)]
            public int cbSize;
            [MarshalAs(UnmanagedType.I4)]
            public int dwFlags;
            [MarshalAs(UnmanagedType.I4)]
            public int dwDoubleClick;
            [MarshalAs(UnmanagedType.I4)]
            public int dwReserved1;
            [MarshalAs(UnmanagedType.I4)]
            public int dwReserved2;
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("BD3F23C0-D43E-11CF-893B-00AA00BDCE1A"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IDocHostUIHandler {

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int ShowContextMenu(
                               [In, MarshalAs(UnmanagedType.U4)]
                               int dwID,
                               [In]
                               POINT pt,
                               [In, MarshalAs(UnmanagedType.Interface)]
                               object pcmdtReserved,
                               [In, MarshalAs(UnmanagedType.Interface)]
                               object pdispReserved);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int GetHostInfo(
                           [In, Out]
                           DOCHOSTUIINFO info);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int ShowUI(
                      [In, MarshalAs(UnmanagedType.I4)]
                      int dwID,
                      [In]
                      IOleInPlaceActiveObject activeObject,
                      [In]
                      IOleCommandTarget commandTarget,
                      [In]
                      IOleInPlaceFrame frame,
                      [In]
                      IOleInPlaceUIWindow doc);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int HideUI();

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int UpdateUI();

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int EnableModeless(
                              [In, MarshalAs(UnmanagedType.Bool)]
                              bool fEnable);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OnDocWindowActivate(
                                   [In, MarshalAs(UnmanagedType.Bool)]
                                   bool fActivate);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OnFrameWindowActivate(
                                     [In, MarshalAs(UnmanagedType.Bool)]
                                     bool fActivate);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int ResizeBorder(
                            [In]
                            COMRECT rect,
                            [In]
                            IOleInPlaceUIWindow doc,
                            bool fFrameWindow);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int TranslateAccelerator(
                                    [In]
                                    ref MSG msg,
                                    [In]
                                    ref Guid group,
                                    [In, MarshalAs(UnmanagedType.I4)]
                                    int nCmdID);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int GetOptionKeyPath(
                                [Out, MarshalAs(UnmanagedType.LPArray)]
                                String[] pbstrKey,
                                [In, MarshalAs(UnmanagedType.U4)]
                                int dw);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int GetDropTarget(
                             [In, MarshalAs(UnmanagedType.Interface)]
                             IOleDropTarget pDropTarget,
                             [Out, MarshalAs(UnmanagedType.Interface)]
                             out IOleDropTarget ppDropTarget);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int GetExternal(
                           [Out, MarshalAs(UnmanagedType.Interface)]
                           out object ppDispatch);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int TranslateUrl(
                            [In, MarshalAs(UnmanagedType.U4)]
                            int dwTranslate,
                            [In, MarshalAs(UnmanagedType.LPWStr)]
                            string strURLIn,
                            [Out, MarshalAs(UnmanagedType.LPWStr)]
                            out string pstrURLOut);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int FilterDataObject(
                                [In, MarshalAs(UnmanagedType.Interface)]
                                IOleDataObject pDO,
                                [Out, MarshalAs(UnmanagedType.Interface)]
                                out IOleDataObject ppDORet);


        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("0000010E-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleDataObject {

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleGetData(
                          FORMATETC pFormatetc,
                          [Out] 
                          STGMEDIUM pMedium);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleGetDataHere(
                              FORMATETC pFormatetc,
                              [In, Out] 
                              STGMEDIUM pMedium);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleQueryGetData(
                               FORMATETC pFormatetc);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleGetCanonicalFormatEtc(
                                        FORMATETC pformatectIn,
                                        [Out] 
                                        FORMATETC pformatetcOut);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleSetData(
                          FORMATETC pFormatectIn,
                          STGMEDIUM pmedium,
                          [In, MarshalAs(UnmanagedType.I4)] 
                          int fRelease);

            [return: MarshalAs(UnmanagedType.Interface)]
            object OleEnumFormatEtc(
                                   [In, MarshalAs(UnmanagedType.U4)] 
                                   int dwDirection);

            [PreserveSig]
            int OleDAdvise(
                          FORMATETC pFormatetc,
                          [In, MarshalAs(UnmanagedType.U4)] 
                          int advf,
                          [In, MarshalAs(UnmanagedType.Interface)] 
                          object pAdvSink,
                          [Out, MarshalAs(UnmanagedType.LPArray)] 
                          int[] pdwConnection);

            [PreserveSig]
            int OleDUnadvise(
                            [In, MarshalAs(UnmanagedType.U4)] 
                            int dwConnection);

            [PreserveSig]
            int OleEnumDAdvise(
                              [Out, MarshalAs(UnmanagedType.LPArray)] 
                              Object[] ppenumAdvise);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000122-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleDropTarget {

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleDragEnter(
                            [In, MarshalAs(UnmanagedType.Interface)]
                            IOleDataObject pDataObj,
                            [In, MarshalAs(UnmanagedType.U4)]
                            int grfKeyState,
                            [In, MarshalAs(UnmanagedType.U8)]
                            long pt,
                            [In, Out, MarshalAs(UnmanagedType.I4)]
                            ref int pdwEffect);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleDragOver(
                           [In, MarshalAs(UnmanagedType.U4)]
                           int grfKeyState,
                           [In, MarshalAs(UnmanagedType.U8)]
                           long pt,
                           [In, Out, MarshalAs(UnmanagedType.I4)]
                           ref int pdwEffect);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleDragLeave();

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleDrop(
                       [In, MarshalAs(UnmanagedType.Interface)]
                       IOleDataObject pDataObj,
                       [In, MarshalAs(UnmanagedType.U4)]
                       int grfKeyState,
                       [In, MarshalAs(UnmanagedType.U8)]
                       long pt,
                       [In, Out, MarshalAs(UnmanagedType.I4)]
                       ref int pdwEffect);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("B722BCCB-4E68-101B-A2BC-00AA00404770"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleCommandTarget {

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int QueryStatus(
                           ref Guid pguidCmdGroup,
                           int cCmds,
                           [In, Out] 
                           OLECMD prgCmds,
                           [In, Out] 
                           string pCmdText);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int Exec(
                    ref Guid pguidCmdGroup,
                    int nCmdID,
                    int nCmdexecopt,
                    // we need to have this an array because callers need to be able to specify NULL or VT_NULL
                    [In, MarshalAs(UnmanagedType.LPArray)]
                    Object[] pvaIn,
                    IntPtr pvaOut);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000116-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceFrame {

            
            IntPtr GetWindow();

            
            void ContextSensitiveHelp(
                                     [In, MarshalAs(UnmanagedType.I4)]
                                     int fEnterMode);

            
            void GetBorder(
                          [Out]
                          COMRECT lprectBorder);

            
            void RequestBorderSpace(
                                   [In]
                                   COMRECT pborderwidths);

            
            void SetBorderSpace(
                               [In]
                               COMRECT pborderwidths);

            
            void SetActiveObject(
                                [In, MarshalAs(UnmanagedType.Interface)]
                                IOleInPlaceActiveObject pActiveObject,
                                [In, MarshalAs(UnmanagedType.LPWStr)]
                                string pszObjName);

            
            void InsertMenus(
                            [In]
                            IntPtr hmenuShared,
                            [In, Out]
                            object lpMenuWidths);

            
            void SetMenu(
                        [In]
                        IntPtr hmenuShared,
                        [In]
                        IntPtr holemenu,
                        [In]
                        IntPtr hwndActiveObject);

            
            void RemoveMenus(
                            [In]
                            IntPtr hmenuShared);

            
            void SetStatusText(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string pszStatusText);

            
            void EnableModeless(
                               [In, MarshalAs(UnmanagedType.I4)]
                               int fEnable);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int TranslateAccelerator(
                                    [In]
                                    ref MSG lpmsg,
                                    [In, MarshalAs(UnmanagedType.U2)]
                                    short wID);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000115-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceUIWindow {

            
            IntPtr GetWindow();

            
            void ContextSensitiveHelp(
                                     [In, MarshalAs(UnmanagedType.I4)] 
                                     int fEnterMode);

            
            void GetBorder(
                          [Out] 
                          COMRECT lprectBorder);

            
            void RequestBorderSpace(
                                   [In] 
                                   COMRECT pborderwidths);

            
            void SetBorderSpace(
                               [In] 
                               COMRECT pborderwidths);

            
            void SetActiveObject(
                                [In, MarshalAs(UnmanagedType.Interface)] 
                                IOleInPlaceActiveObject pActiveObject,
                                [In, MarshalAs(UnmanagedType.LPWStr)] 
                                string pszObjName);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000117-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceActiveObject {

            int GetWindow(out IntPtr hwnd);

            
            void ContextSensitiveHelp(
                                     [In, MarshalAs(UnmanagedType.I4)]
                                     int fEnterMode);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int TranslateAccelerator(
                                    [In]
                                    ref MSG lpmsg);

            
            void OnFrameWindowActivate(
                                      [In, MarshalAs(UnmanagedType.I4)]
                                      int fActivate);

            
            void OnDocWindowActivate(
                                    [In, MarshalAs(UnmanagedType.I4)]
                                    int fActivate);

            
            void ResizeBorder(
                             [In]
                             COMRECT prcBorder,
                             [In]
                             IOleInPlaceUIWindow pUIWindow,
                             [In, MarshalAs(UnmanagedType.I4)]
                             int fFrameWindow);

            
            void EnableModeless(
                               [In, MarshalAs(UnmanagedType.I4)]
                               int fEnable);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("0000011B-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleContainer {

            
            void ParseDisplayName(
                                 [In, MarshalAs(UnmanagedType.Interface)] 
                                 object pbc,
                                 [In, MarshalAs(UnmanagedType.BStr)] 
                                 string pszDisplayName,
                                 [Out, MarshalAs(UnmanagedType.LPArray)] 
                                 int[] pchEaten,
                                 [Out, MarshalAs(UnmanagedType.LPArray)] 
                                 Object[] ppmkOut);

            
            void EnumObjects(
                            [In, MarshalAs(UnmanagedType.U4)] 
                            int grfFlags,
                            [Out, MarshalAs(UnmanagedType.Interface)] 
                            out object ppenum);

            
            void LockContainer(
                              [In, MarshalAs(UnmanagedType.I4)] 
                              int fLock);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000118-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleClientSite {

            
            void SaveObject();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetMoniker(
                             [In, MarshalAs(UnmanagedType.U4)] 
                             int dwAssign,
                             [In, MarshalAs(UnmanagedType.U4)] 
                             int dwWhichMoniker);

            [PreserveSig]
            int GetContainer(
                    [System.Runtime.InteropServices.Out]
                    out IOleContainer ppContainer);

            
            void ShowObject();

            
            void OnShowWindow(
                             [In, MarshalAs(UnmanagedType.I4)] 
                             int fShow);

            
            void RequestNewObjectLayout();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("B722BCC7-4E68-101B-A2BC-00AA00404770"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleDocumentSite {

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int ActivateMe(
                          [In, MarshalAs(UnmanagedType.Interface)] 
                          IOleDocumentView pViewToActivate);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("B722BCC6-4E68-101B-A2BC-00AA00404770"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleDocumentView {

            
            void SetInPlaceSite(
                               [In, MarshalAs(UnmanagedType.Interface)] 
                               IOleInPlaceSite pIPSite);

            [return: MarshalAs(UnmanagedType.Interface)]
            IOleInPlaceSite GetInPlaceSite();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetDocument();

            
            void SetRect(
                        [In] 
                        COMRECT prcView);

            
            void GetRect(
                        [Out] 
                        COMRECT prcView);

            
            void SetRectComplex(
                               [In] 
                               COMRECT prcView,
                               [In] 
                               COMRECT prcHScroll,
                               [In] 
                               COMRECT prcVScroll,
                               [In] 
                               COMRECT prcSizeBox);

            
            void Show(
                     [In, MarshalAs(UnmanagedType.I4)] 
                     int fShow);

            
            void UIActivate(
                           [In, MarshalAs(UnmanagedType.I4)] 
                           int fUIActivate);

            
            void Open();

            
            void CloseView(
                          [In, MarshalAs(UnmanagedType.U4)] 
                          int dwReserved);

            
            void SaveViewState(
                              [In, MarshalAs(UnmanagedType.Interface)] 
                              IStream pstm);

            
            void ApplyViewState(
                               [In, MarshalAs(UnmanagedType.Interface)] 
                               IStream pstm);

            
            void Clone(
                      [In, MarshalAs(UnmanagedType.Interface)] 
                      IOleInPlaceSite pIPSiteNew,
                      [Out, MarshalAs(UnmanagedType.LPArray)] 
                      IOleDocumentView[] ppViewNew);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000119-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceSite {

            
            IntPtr GetWindow();

            
            void ContextSensitiveHelp(
                                     [In, MarshalAs(UnmanagedType.I4)] 
                                     int fEnterMode);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int CanInPlaceActivate();

            
            void OnInPlaceActivate();

            
            void OnUIActivate();

            
            void GetWindowContext(
                                 [Out]
                                 out IOleInPlaceFrame ppFrame,
                                 [Out]
                                 out IOleInPlaceUIWindow ppDoc,
                                 [Out] 
                                 COMRECT lprcPosRect,
                                 [Out] 
                                 COMRECT lprcClipRect,
                                 [In, Out] 
                                 tagOIFI lpFrameInfo);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int Scroll(
                      [In, MarshalAs(UnmanagedType.U4)] 
                      tagSIZE scrollExtant);

            
            void OnUIDeactivate(
                               [In, MarshalAs(UnmanagedType.I4)] 
                               int fUndoable);

            
            void OnInPlaceDeactivate();

            
            void DiscardUndoState();

            
            void DeactivateAndUndo();

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OnPosRectChange(
                               [In] 
                               COMRECT lprcPosRect);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("0000000C-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IStream {

            [return: MarshalAs(UnmanagedType.I4)]
            int Read(
                    [In] 
                    IntPtr buf,
                    [In, MarshalAs(UnmanagedType.I4)] 
                    int len);

            [return: MarshalAs(UnmanagedType.I4)]
            int Write(
                     [In] 
                     IntPtr buf,
                     [In, MarshalAs(UnmanagedType.I4)] 
                     int len);

            [return: MarshalAs(UnmanagedType.I8)]
            long Seek(
                     [In, MarshalAs(UnmanagedType.I8)] 
                     long dlibMove,
                     [In, MarshalAs(UnmanagedType.I4)] 
                     int dwOrigin);

            
            void SetSize(
                        [In, MarshalAs(UnmanagedType.I8)] 
                        long libNewSize);

            [return: MarshalAs(UnmanagedType.I8)]
            long CopyTo(
                       [In, MarshalAs(UnmanagedType.Interface)] 
                       IStream pstm,
                       [In, MarshalAs(UnmanagedType.I8)] 
                       long cb,
                       [Out, MarshalAs(UnmanagedType.LPArray)] 
                       long[] pcbRead);

            
            void Commit(
                       [In, MarshalAs(UnmanagedType.I4)] 
                       int grfCommitFlags);

            
            void Revert();

            
            void LockRegion(
                           [In, MarshalAs(UnmanagedType.I8)] 
                           long libOffset,
                           [In, MarshalAs(UnmanagedType.I8)] 
                           long cb,
                           [In, MarshalAs(UnmanagedType.I4)] 
                           int dwLockType);

            
            void UnlockRegion(
                             [In, MarshalAs(UnmanagedType.I8)] 
                             long libOffset,
                             [In, MarshalAs(UnmanagedType.I8)] 
                             long cb,
                             [In, MarshalAs(UnmanagedType.I4)] 
                             int dwLockType);

            
            void Stat(
                     [In] 
                     IntPtr pStatstg,
                     [In, MarshalAs(UnmanagedType.I4)] 
                     int grfStatFlag);

            [return: MarshalAs(UnmanagedType.Interface)]
            IStream Clone();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000112-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleObject {

            [PreserveSig]
            int SetClientSite(
                             [In, MarshalAs(UnmanagedType.Interface)]
                             IOleClientSite pClientSite);

            [PreserveSig]
            int GetClientSite(out IOleClientSite site);

            [PreserveSig]
            int SetHostNames(
                            [In, MarshalAs(UnmanagedType.LPWStr)]
                            string szContainerApp,
                            [In, MarshalAs(UnmanagedType.LPWStr)]
                            string szContainerObj);

            [PreserveSig]
            int Close(
                     [In, MarshalAs(UnmanagedType.I4)]
                     int dwSaveOption);

            [PreserveSig]
            int SetMoniker(
                          [In, MarshalAs(UnmanagedType.U4)]
                          int dwWhichMoniker,
                          [In, MarshalAs(UnmanagedType.Interface)]
                          object pmk);

            [PreserveSig]
            int GetMoniker(
                          [In, MarshalAs(UnmanagedType.U4)]
                          int dwAssign,
                          [In, MarshalAs(UnmanagedType.U4)]
                          int dwWhichMoniker,
                          out object moniker);

            [PreserveSig]
            int InitFromData(
                            [In, MarshalAs(UnmanagedType.Interface)]
                            IOleDataObject pDataObject,
                            [In, MarshalAs(UnmanagedType.I4)]
                            int fCreation,
                            [In, MarshalAs(UnmanagedType.U4)]
                            int dwReserved);

            [PreserveSig]
            int GetClipboardData(
                                [In, MarshalAs(UnmanagedType.U4)]
                                int dwReserved,
                                out IOleDataObject data);

            [PreserveSig]
            int DoVerb(
                      [In, MarshalAs(UnmanagedType.I4)]
                      int iVerb,
                      [In]
                      IntPtr lpmsg,
                      [In, MarshalAs(UnmanagedType.Interface)]
                      IOleClientSite pActiveSite,
                      [In, MarshalAs(UnmanagedType.I4)]
                      int lindex,
                      [In]
                      IntPtr hwndParent,
                      [In]
                      COMRECT lprcPosRect);

            [PreserveSig]
            int EnumVerbs(out NativeMethods.IEnumOLEVERB e);

            [PreserveSig]
            int OleUpdate();

            [PreserveSig]
            int IsUpToDate();

            [PreserveSig]
            int GetUserClassID(
                              [In, Out]
                              ref Guid pClsid);

            [PreserveSig]
            int GetUserType(
                           [In, MarshalAs(UnmanagedType.U4)]
                           int dwFormOfType,
                           [Out, MarshalAs(UnmanagedType.LPWStr)]
                           out string userType);

            [PreserveSig]
            int SetExtent(
                         [In, MarshalAs(UnmanagedType.U4)]
                         int dwDrawAspect,
                         [In]
                         tagSIZEL pSizel);

            [PreserveSig]
            int GetExtent(
                         [In, MarshalAs(UnmanagedType.U4)]
                         int dwDrawAspect,
                         [Out]
                         tagSIZEL pSizel);

            [PreserveSig]
            int Advise(
                      [In, MarshalAs(UnmanagedType.Interface)]
                      IAdviseSink pAdvSink,
                      out int cookie);

            [PreserveSig]
            int Unadvise(
                        [In, MarshalAs(UnmanagedType.U4)]
                        int dwConnection);

            [PreserveSig]
            int EnumAdvise(out object e);

            [PreserveSig]
            int GetMiscStatus(
                             [In, MarshalAs(UnmanagedType.U4)]
                             int dwAspect,
                             out int misc);

            [PreserveSig]
            int SetColorScheme(
                              [In]
                              tagLOGPALETTE pLogpal);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("0000010F-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IAdviseSink {

            
            void OnDataChange(
                             [In]
                             FORMATETC pFormatetc,
                             [In]
                             STGMEDIUM pStgmed);

            
            void OnViewChange(
                             [In, MarshalAs(UnmanagedType.U4)]
                             int dwAspect,
                             [In, MarshalAs(UnmanagedType.I4)]
                             int lindex);

            
            void OnRename(
                         [In, MarshalAs(UnmanagedType.Interface)]
                         object pmk);

            
            void OnSave();

            
            void OnClose();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("7FD52380-4E07-101B-AE2D-08002B2EC713"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IPersistStreamInit {

            
            void GetClassID(
                           [In, Out] 
                           ref Guid pClassID);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int IsDirty();

            
            void Load(
                     [In, MarshalAs(UnmanagedType.Interface)] 
                     IStream pstm);

            
            void Save(
                     [In, MarshalAs(UnmanagedType.Interface)] 
                     IStream pstm,
                     [In, MarshalAs(UnmanagedType.Bool)] 
                     bool fClearDirty);

            
            void GetSizeMax(
                           [Out, MarshalAs(UnmanagedType.LPArray)] 
                           long pcbSize);

            
            void InitNew();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("25336920-03F9-11CF-8FD0-00AA00686F13")]
        public class HTMLDocument {
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("626FC520-A41E-11CF-A731-00A0C9082637"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLDocument {

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetScript();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("332C4425-26CB-11D0-B483-00C04FD90119"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLDocument2 {

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetScript();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetAll();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement GetBody();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement GetActiveElement();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetImages();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetApplets();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetLinks();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetForms();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetAnchors();

            
            void SetTitle(
                         [In, MarshalAs(UnmanagedType.BStr)]
                         string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTitle();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetScripts();

            
            void SetDesignMode(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDesignMode();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetSelection();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetReadyState();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetFrames();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetEmbeds();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetPlugins();

            
            void SetAlinkColor(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            object GetAlinkColor();

            
            void SetBgColor(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            object GetBgColor();

            
            void SetFgColor(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            object GetFgColor();

            
            void SetLinkColor(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            object GetLinkColor();

            
            void SetVlinkColor(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetVlinkColor();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetReferrer();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetLocation();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetLastModified();

            
            void SetURL(
                       [In, MarshalAs(UnmanagedType.BStr)]
                       string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetURL();

            
            void SetDomain(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDomain();

            
            void SetCookie(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetCookie();

            
            void SetExpando(
                           [In, MarshalAs(UnmanagedType.Bool)]
                           bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetExpando();

            
            void SetCharset(
                           [In, MarshalAs(UnmanagedType.BStr)]
                           string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetCharset();

            
            void SetDefaultCharset(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDefaultCharset();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetMimeType();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFileSize();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFileCreatedDate();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFileModifiedDate();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFileUpdatedDate();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetSecurity();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetProtocol();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetNameProp();

            
            void DummyWrite(
                           [In, MarshalAs(UnmanagedType.I4)]
                           int psarray);

            
            void DummyWriteln(
                             [In, MarshalAs(UnmanagedType.I4)]
                             int psarray);

            [return: MarshalAs(UnmanagedType.Interface)]
            object Open(
                       [In, MarshalAs(UnmanagedType.BStr)]
                       string URL,
                       [In, MarshalAs(UnmanagedType.Struct)]
                       Object name,
                       [In, MarshalAs(UnmanagedType.Struct)]
                       Object features,
                       [In, MarshalAs(UnmanagedType.Struct)]
                       Object replace);

            
            void Close();

            
            void Clear();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool QueryCommandSupported(
                                      [In, MarshalAs(UnmanagedType.BStr)]
                                      string cmdID);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool QueryCommandEnabled(
                                    [In, MarshalAs(UnmanagedType.BStr)]
                                    string cmdID);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool QueryCommandState(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string cmdID);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool QueryCommandIndeterm(
                                     [In, MarshalAs(UnmanagedType.BStr)]
                                     string cmdID);

            [return: MarshalAs(UnmanagedType.BStr)]
            string QueryCommandText(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string cmdID);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object QueryCommandValue(
                                    [In, MarshalAs(UnmanagedType.BStr)]
                                    string cmdID);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool ExecCommand(
                            [In, MarshalAs(UnmanagedType.BStr)]
                            string cmdID,
                            [In, MarshalAs(UnmanagedType.Bool)]
                            bool showUI,
                            [In, MarshalAs(UnmanagedType.Struct)]
                            Object value);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool ExecCommandShowHelp(
                                    [In, MarshalAs(UnmanagedType.BStr)]
                                    string cmdID);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement CreateElement(
                                      [In, MarshalAs(UnmanagedType.BStr)]
                                      string eTag);

            
            void SetOnhelp(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnhelp();

            
            void SetOnclick(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnclick();

            
            void SetOndblclick(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndblclick();

            
            void SetOnkeyup(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnkeyup();

            
            void SetOnkeydown(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnkeydown();

            
            void SetOnkeypress(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnkeypress();

            
            void SetOnmouseup(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmouseup();

            
            void SetOnmousedown(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmousedown();

            
            void SetOnmousemove(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmousemove();

            
            void SetOnmouseout(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmouseout();

            
            void SetOnmouseover(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmouseover();

            
            void SetOnreadystatechange(
                                      [In, MarshalAs(UnmanagedType.Struct)]
                                      Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnreadystatechange();

            
            void SetOnafterupdate(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnafterupdate();

            
            void SetOnrowexit(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnrowexit();

            
            void SetOnrowenter(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnrowenter();

            
            void SetOndragstart(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragstart();

            
            void SetOnselectstart(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnselectstart();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement ElementFromPoint(
                                         [In, MarshalAs(UnmanagedType.I4)]
                                         int x,
                                         [In, MarshalAs(UnmanagedType.I4)]
                                         int y);

            [return: MarshalAs(UnmanagedType.Interface)]
            /*IHTMLWindow2*/ object GetParentWindow();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetStyleSheets();

            
            void SetOnbeforeupdate(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforeupdate();

            
            void SetOnerrorupdate(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnerrorupdate();

            [return: MarshalAs(UnmanagedType.BStr)]
            string toString();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLStyleSheet CreateStyleSheet(
                                            [In, MarshalAs(UnmanagedType.BStr)]
                                            string bstrHref,
                                            [In, MarshalAs(UnmanagedType.I4)]
                                            int lIndex);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F1FF-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLElement {

            
            void SetAttribute(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string strAttributeName,
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object AttributeValue,
                             [In, MarshalAs(UnmanagedType.I4)]
                             int lFlags);

            
            void GetAttribute(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string strAttributeName,
                             [In, MarshalAs(UnmanagedType.I4)]
                             int lFlags,
                             [Out, MarshalAs(UnmanagedType.LPArray)]
                             Object[] pvars);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool RemoveAttribute(
                                [In, MarshalAs(UnmanagedType.BStr)]
                                string strAttributeName,
                                [In, MarshalAs(UnmanagedType.I4)]
                                int lFlags);

            
            void SetClassName(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetClassName();

            
            void SetId(
                      [In, MarshalAs(UnmanagedType.BStr)]
                      string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetId();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTagName();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement GetParentElement();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLStyle GetStyle();

            
            void SetOnhelp(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnhelp();

            
            void SetOnclick(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnclick();

            
            void SetOndblclick(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndblclick();

            
            void SetOnkeydown(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnkeydown();

            
            void SetOnkeyup(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnkeyup();

            
            void SetOnkeypress(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnkeypress();

            
            void SetOnmouseout(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmouseout();

            
            void SetOnmouseover(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmouseover();

            
            void SetOnmousemove(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmousemove();

            
            void SetOnmousedown(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmousedown();

            
            void SetOnmouseup(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmouseup();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDocument2 GetDocument();

            
            void SetTitle(
                         [In, MarshalAs(UnmanagedType.BStr)]
                         string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTitle();

            
            void SetLanguage(
                            [In, MarshalAs(UnmanagedType.BStr)]
                            string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetLanguage();

            
            void SetOnselectstart(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnselectstart();

            
            void ScrollIntoView(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object varargStart);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool Contains(
                         [In, MarshalAs(UnmanagedType.Interface)]
                         IHTMLElement pChild);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetSourceIndex();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetRecordNumber();

            
            void SetLang(
                        [In, MarshalAs(UnmanagedType.BStr)]
                        string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetLang();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetOffsetLeft();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetOffsetTop();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetOffsetWidth();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetOffsetHeight();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement GetOffsetParent();

            
            void SetInnerHTML(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetInnerHTML();

            
            void SetInnerText(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetInnerText();

            
            void SetOuterHTML(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetOuterHTML();

            
            void SetOuterText(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetOuterText();

            
            void InsertAdjacentHTML(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string where,
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string html);

            
            void InsertAdjacentText(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string where,
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string text);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement GetParentTextEdit();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetIsTextEdit();

            
            void Click();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetFilters();

            
            void SetOndragstart(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragstart();

            [return: MarshalAs(UnmanagedType.BStr)]
            string toString();

            
            void SetOnbeforeupdate(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforeupdate();

            
            void SetOnafterupdate(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnafterupdate();

            
            void SetOnerrorupdate(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnerrorupdate();

            
            void SetOnrowexit(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnrowexit();

            
            void SetOnrowenter(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnrowenter();

            
            void SetOndatasetchanged(
                                    [In, MarshalAs(UnmanagedType.Struct)]
                                    Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndatasetchanged();

            
            void SetOndataavailable(
                                   [In, MarshalAs(UnmanagedType.Struct)]
                                   Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndataavailable();

            
            void SetOndatasetcomplete(
                                     [In, MarshalAs(UnmanagedType.Struct)]
                                     Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndatasetcomplete();

            
            void SetOnfilterchange(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnfilterchange();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetChildren();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetAll();
        }

        [System.Runtime.InteropServices.ComVisible(false), System.Runtime.InteropServices.ComImport(), Guid("3050F434-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLElement2 {

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetScopeName();

            
            void SetCapture(
                           [In, MarshalAs(UnmanagedType.Bool)]
                           bool containerCapture);

            
            void ReleaseCapture();

            
            void SetOnlosecapture(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnlosecapture();

            [return: MarshalAs(UnmanagedType.BStr)]
            string ComponentFromPoint(
                                     [In, MarshalAs(UnmanagedType.I4)]
                                     int x,
                                     [In, MarshalAs(UnmanagedType.I4)]
                                     int y);

            
            void DoScroll(
                         [In, MarshalAs(UnmanagedType.Struct)]
                         Object component);

            
            void SetOnscroll(
                            [In, MarshalAs(UnmanagedType.Struct)]
                            Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnscroll();

            
            void SetOndrag(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndrag();

            
            void SetOndragend(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragend();

            
            void SetOndragenter(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragenter();

            
            void SetOndragover(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragover();

            
            void SetOndragleave(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragleave();

            
            void SetOndrop(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndrop();

            
            void SetOnbeforecut(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforecut();

            
            void SetOncut(
                         [In, MarshalAs(UnmanagedType.Struct)]
                         Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOncut();

            
            void SetOnbeforecopy(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforecopy();

            
            void SetOncopy(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOncopy();

            
            void SetOnbeforepaste(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforepaste();

            
            void SetOnpaste(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnpaste();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLCurrentStyle GetCurrentStyle();

            
            void SetOnpropertychange(
                                    [In, MarshalAs(UnmanagedType.Struct)]
                                    Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnpropertychange();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLRectCollection GetClientRects();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLRect GetBoundingClientRect();

            
            void SetExpression(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string propname,
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string expression,
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string language);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetExpression(
                                [In, MarshalAs(UnmanagedType.BStr)]
                                Object propname);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool RemoveExpression(
                                 [In, MarshalAs(UnmanagedType.BStr)]
                                 string propname);

            
            void SetTabIndex(
                            [In, MarshalAs(UnmanagedType.I2)]
                            short p);

            [return: MarshalAs(UnmanagedType.I2)]
            short GetTabIndex();

            
            void Focus();

            
            void SetAccessKey(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetAccessKey();

            
            void SetOnblur(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnblur();

            
            void SetOnfocus(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnfocus();

            
            void SetOnresize(
                            [In, MarshalAs(UnmanagedType.Struct)]
                            Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnresize();

            
            void Blur();

            
            void AddFilter(
                          [In, MarshalAs(UnmanagedType.Interface)]
                          object pUnk);

            
            void RemoveFilter(
                             [In, MarshalAs(UnmanagedType.Interface)]
                             object pUnk);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetClientHeight();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetClientWidth();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetClientTop();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetClientLeft();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool AttachEvent(
                            [In, MarshalAs(UnmanagedType.BStr)]
                            string ev,
                            [In, MarshalAs(UnmanagedType.Interface)]
                            object pdisp);

            
            void DetachEvent(
                            [In, MarshalAs(UnmanagedType.BStr)]
                            string ev,
                            [In, MarshalAs(UnmanagedType.Interface)]
                            object pdisp);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetReadyState();

            
            void SetOnreadystatechange(
                                      [In, MarshalAs(UnmanagedType.Struct)]
                                      Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnreadystatechange();

            
            void SetOnrowsdelete(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnrowsdelete();

            
            void SetOnrowsinserted(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnrowsinserted();

            
            void SetOncellchange(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOncellchange();

            
            void SetDir(
                       [In, MarshalAs(UnmanagedType.BStr)]
                       string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDir();

            [return: MarshalAs(UnmanagedType.Interface)]
            object CreateControlRange();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetScrollHeight();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetScrollWidth();

            
            void SetScrollTop(
                             [In, MarshalAs(UnmanagedType.I4)]
                             int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetScrollTop();

            
            void SetScrollLeft(
                              [In, MarshalAs(UnmanagedType.I4)]
                              int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetScrollLeft();

            
            void ClearAttributes();

            
            void MergeAttributes(
                                [In, MarshalAs(UnmanagedType.Interface)]
                                IHTMLElement mergeThis);

            
            void SetOncontextmenu(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOncontextmenu();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement InsertAdjacentElement(
                                              [In, MarshalAs(UnmanagedType.BStr)]
                                              string where,
                                              [In, MarshalAs(UnmanagedType.Interface)]
                                              IHTMLElement insertedElement);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement ApplyElement(
                                     [In, MarshalAs(UnmanagedType.Interface)]
                                     IHTMLElement apply,
                                     [In, MarshalAs(UnmanagedType.BStr)]
                                     string where);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetAdjacentText(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string where);

            [return: MarshalAs(UnmanagedType.BStr)]
            string ReplaceAdjacentText(
                                      [In, MarshalAs(UnmanagedType.BStr)]
                                      string where,
                                      [In, MarshalAs(UnmanagedType.BStr)]
                                      string newText);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetCanHaveChildren();

            [return: MarshalAs(UnmanagedType.I4)]
            int AddBehavior(
                           [In, MarshalAs(UnmanagedType.BStr)]
                           string bstrUrl,
                           [In]
                           ref Object pvarFactory);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool RemoveBehavior(
                               [In, MarshalAs(UnmanagedType.I4)]
                               int cookie);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLStyle GetRuntimeStyle();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetBehaviorUrns();

            
            void SetTagUrn(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTagUrn();

            
            void SetOnbeforeeditfocus(
                                     [In, MarshalAs(UnmanagedType.Struct)]
                                     Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforeeditfocus();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetReadyStateValue();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetElementsByTagName(
                                                       [In, MarshalAs(UnmanagedType.BStr)]
                                                       string v);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLStyle GetBaseStyle();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLCurrentStyle GetBaseCurrentStyle();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLStyle GetBaseRuntimeStyle();

            
            void SetOnmousehover(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmousehover();

            
            void SetOnkeydownpreview(
                                    [In, MarshalAs(UnmanagedType.Struct)]
                                    Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnkeydownpreview();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetBehavior(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string bstrName,
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string bstrUrn);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F673-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLElement3 {

            
            void MergeAttributes(
                                [In, MarshalAs(UnmanagedType.Interface)]
                                IHTMLElement mergeThis,
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object pvarFlags);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetIsMultiLine();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetCanHaveHTML();

            
            void SetOnLayoutComplete(
                                    [In, MarshalAs(UnmanagedType.Struct)]
                                    Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnLayoutComplete();

            
            void SetOnPage(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnPage();

            
            void SetInflateBlock(
                                [In, MarshalAs(UnmanagedType.Bool)]
                                bool inflate);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetInflateBlock();

            
            void SetOnBeforeDeactivate(
                                      [In, MarshalAs(UnmanagedType.Struct)]
                                      Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnBeforeDeactivate();

            
            void SetActive();

            
            void SetContentEditable(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetContentEditable();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetIsContentEditable();

            
            void SetHideFocus(
                             [In, MarshalAs(UnmanagedType.Bool)]
                             bool v);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetHideFocus();

            
            void SetDisabled(
                            [In, MarshalAs(UnmanagedType.Bool)]
                            bool v);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetDisabled();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetIsDisabled();

            
            void SetOnMove(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnMove();

            
            void SetOnControlSelect(
                                   [In, MarshalAs(UnmanagedType.Struct)]
                                   Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnControlSelect();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool FireEvent(
                          [In, MarshalAs(UnmanagedType.BStr)] 
                          string eventName,
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object eventObject);

            
            void SetOnResizeStart(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnResizeStart();

            
            void SetOnResizeEnd(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnResizeEnd();

            
            void SetOnMoveStart(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnMoveStart();

            
            void SetOnMoveEnd(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnMoveEnd();

            
            void SetOnMouseEnter(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnMouseEnter();

            
            void SetOnMouseLeave(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnMouseLeave();

            
            void SetOnActivate(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnActivate();

            
            void SetOnDeactivate(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnDeactivate();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool DragDrop();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetGlyphMode();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F1D8-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLBodyElement {

            
            void SetBackground(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackground();

            
            void SetBgProperties(
                                [In, MarshalAs(UnmanagedType.BStr)]
                                string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBgProperties();

            
            void SetLeftMargin(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLeftMargin();

            
            void SetTopMargin(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetTopMargin();

            
            void SetRightMargin(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetRightMargin();

            
            void SetBottomMargin(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBottomMargin();

            
            void SetNoWrap(
                          [In, MarshalAs(UnmanagedType.Bool)]
                          bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetNoWrap();

            
            void SetBgColor(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBgColor();

            
            void SetText(
                        [In, MarshalAs(UnmanagedType.Struct)]
                        Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetText();

            
            void SetLink(
                        [In, MarshalAs(UnmanagedType.Struct)]
                        Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLink();

            
            void SetVLink(
                         [In, MarshalAs(UnmanagedType.Struct)]
                         Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetVLink();

            
            void SetALink(
                         [In, MarshalAs(UnmanagedType.Struct)]
                         Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetALink();

            
            void SetOnload(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnload();

            
            void SetOnunload(
                            [In, MarshalAs(UnmanagedType.Struct)]
                            Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnunload();

            
            void SetScroll(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetScroll();

            
            void SetOnselect(
                            [In, MarshalAs(UnmanagedType.Struct)]
                            Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnselect();

            
            void SetOnbeforeunload(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforeunload();

            [return: MarshalAs(UnmanagedType.Interface)]
            object CreateTextRange();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F2E3-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLStyleSheet {

            
            void SetTitle(
                         [In, MarshalAs(UnmanagedType.BStr)] 
                         string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTitle();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLStyleSheet GetParentStyleSheet();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement GetOwningElement();

            
            void SetDisabled(
                            [In, MarshalAs(UnmanagedType.Bool)] 
                            bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetDisabled();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetReadOnly();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetImports();

            
            void SetHref(
                        [In, MarshalAs(UnmanagedType.BStr)] 
                        string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetHref();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetStyleSheetType();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetId();

            [return: MarshalAs(UnmanagedType.I4)]
            int AddImport(
                         [In, MarshalAs(UnmanagedType.BStr)] 
                         string bstrURL,
                         [In, MarshalAs(UnmanagedType.I4)] 
                         int lIndex);

            [return: MarshalAs(UnmanagedType.I4)]
            int AddRule(
                       [In, MarshalAs(UnmanagedType.BStr)] 
                       string bstrSelector,
                       [In, MarshalAs(UnmanagedType.BStr)] 
                       string bstrStyle,
                       [In, MarshalAs(UnmanagedType.I4)] 
                       int lIndex);

            
            void RemoveImport(
                             [In, MarshalAs(UnmanagedType.I4)] 
                             int lIndex);

            
            void RemoveRule(
                           [In, MarshalAs(UnmanagedType.I4)] 
                           int lIndex);

            
            void SetMedia(
                         [In, MarshalAs(UnmanagedType.BStr)] 
                         string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetMedia();

            
            void SetCssText(
                           [In, MarshalAs(UnmanagedType.BStr)] 
                           string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetCssText();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetRules();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F25E-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLStyle {

            
            void SetFontFamily(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontFamily();

            
            void SetFontStyle(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontStyle();

            
            void SetFontObject(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontObject();

            
            void SetFontWeight(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontWeight();

            
            void SetFontSize(
                            [In, MarshalAs(UnmanagedType.Struct)]
                            Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetFontSize();

            
            void SetFont(
                        [In, MarshalAs(UnmanagedType.BStr)]
                        string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFont();

            
            void SetColor(
                         [In, MarshalAs(UnmanagedType.Struct)]
                         Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetColor();

            
            void SetBackground(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackground();

            
            void SetBackgroundColor(
                                   [In, MarshalAs(UnmanagedType.Struct)]
                                   Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundColor();

            
            void SetBackgroundImage(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundImage();

            
            void SetBackgroundRepeat(
                                    [In, MarshalAs(UnmanagedType.BStr)]
                                    string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundRepeat();

            
            void SetBackgroundAttachment(
                                        [In, MarshalAs(UnmanagedType.BStr)]
                                        string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundAttachment();

            
            void SetBackgroundPosition(
                                      [In, MarshalAs(UnmanagedType.BStr)]
                                      string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundPosition();

            
            void SetBackgroundPositionX(
                                       [In, MarshalAs(UnmanagedType.Struct)]
                                       Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundPositionX();

            
            void SetBackgroundPositionY(
                                       [In, MarshalAs(UnmanagedType.Struct)]
                                       Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundPositionY();

            
            void SetWordSpacing(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetWordSpacing();

            
            void SetLetterSpacing(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLetterSpacing();

            
            void SetTextDecoration(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextDecoration();

            
            void SetTextDecorationNone(
                                      [In, MarshalAs(UnmanagedType.Bool)]
                                      bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetTextDecorationNone();

            
            void SetTextDecorationUnderline(
                                           [In, MarshalAs(UnmanagedType.Bool)]
                                           bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetTextDecorationUnderline();

            
            void SetTextDecorationOverline(
                                          [In, MarshalAs(UnmanagedType.Bool)]
                                          bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetTextDecorationOverline();

            
            void SetTextDecorationLineThrough(
                                             [In, MarshalAs(UnmanagedType.Bool)]
                                             bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetTextDecorationLineThrough();

            
            void SetTextDecorationBlink(
                                       [In, MarshalAs(UnmanagedType.Bool)]
                                       bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetTextDecorationBlink();

            
            void SetVerticalAlign(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetVerticalAlign();

            
            void SetTextTransform(
                                 [In, MarshalAs(UnmanagedType.BStr)]
                                 string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextTransform();

            
            void SetTextAlign(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextAlign();

            
            void SetTextIndent(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetTextIndent();

            
            void SetLineHeight(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLineHeight();

            
            void SetMarginTop(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginTop();

            
            void SetMarginRight(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginRight();

            
            void SetMarginBottom(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginBottom();

            
            void SetMarginLeft(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginLeft();

            
            void SetMargin(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetMargin();

            
            void SetPaddingTop(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingTop();

            
            void SetPaddingRight(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingRight();

            
            void SetPaddingBottom(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingBottom();

            
            void SetPaddingLeft(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingLeft();

            
            void SetPadding(
                           [In, MarshalAs(UnmanagedType.BStr)]
                           string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPadding();

            
            void SetBorder(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorder();

            
            void SetBorderTop(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderTop();

            
            void SetBorderRight(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderRight();

            
            void SetBorderBottom(
                                [In, MarshalAs(UnmanagedType.BStr)]
                                string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderBottom();

            
            void SetBorderLeft(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderLeft();

            
            void SetBorderColor(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderColor();

            
            void SetBorderTopColor(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderTopColor();

            
            void SetBorderRightColor(
                                    [In, MarshalAs(UnmanagedType.Struct)]
                                    Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderRightColor();

            
            void SetBorderBottomColor(
                                     [In, MarshalAs(UnmanagedType.Struct)]
                                     Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderBottomColor();

            
            void SetBorderLeftColor(
                                   [In, MarshalAs(UnmanagedType.Struct)]
                                   Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderLeftColor();

            
            void SetBorderWidth(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderWidth();

            
            void SetBorderTopWidth(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderTopWidth();

            
            void SetBorderRightWidth(
                                    [In, MarshalAs(UnmanagedType.Struct)]
                                    Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderRightWidth();

            
            void SetBorderBottomWidth(
                                     [In, MarshalAs(UnmanagedType.Struct)]
                                     Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderBottomWidth();

            
            void SetBorderLeftWidth(
                                   [In, MarshalAs(UnmanagedType.Struct)]
                                   Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderLeftWidth();

            
            void SetBorderStyle(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderStyle();

            
            void SetBorderTopStyle(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderTopStyle();

            
            void SetBorderRightStyle(
                                    [In, MarshalAs(UnmanagedType.BStr)]
                                    string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderRightStyle();

            
            void SetBorderBottomStyle(
                                     [In, MarshalAs(UnmanagedType.BStr)]
                                     string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderBottomStyle();

            
            void SetBorderLeftStyle(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderLeftStyle();

            
            void SetWidth(
                         [In, MarshalAs(UnmanagedType.Struct)]
                         Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetWidth();

            
            void SetHeight(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetHeight();

            
            void SetStyleFloat(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetStyleFloat();

            
            void SetClear(
                         [In, MarshalAs(UnmanagedType.BStr)]
                         string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetClear();

            
            void SetDisplay(
                           [In, MarshalAs(UnmanagedType.BStr)]
                           string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDisplay();

            
            void SetVisibility(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetVisibility();

            
            void SetListStyleType(
                                 [In, MarshalAs(UnmanagedType.BStr)]
                                 string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleType();

            
            void SetListStylePosition(
                                     [In, MarshalAs(UnmanagedType.BStr)]
                                     string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStylePosition();

            
            void SetListStyleImage(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleImage();

            
            void SetListStyle(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyle();

            
            void SetWhiteSpace(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetWhiteSpace();

            
            void SetTop(
                       [In, MarshalAs(UnmanagedType.Struct)]
                       Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetTop();

            
            void SetLeft(
                        [In, MarshalAs(UnmanagedType.Struct)]
                        Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLeft();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPosition();

            
            void SetZIndex(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetZIndex();

            
            void SetOverflow(
                            [In, MarshalAs(UnmanagedType.BStr)]
                            string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetOverflow();

            
            void SetPageBreakBefore(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakBefore();

            
            void SetPageBreakAfter(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakAfter();

            
            void SetCssText(
                           [In, MarshalAs(UnmanagedType.BStr)]
                           string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetCssText();

            
            void SetPixelTop(
                            [In, MarshalAs(UnmanagedType.I4)]
                            int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetPixelTop();

            
            void SetPixelLeft(
                             [In, MarshalAs(UnmanagedType.I4)]
                             int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetPixelLeft();

            
            void SetPixelWidth(
                              [In, MarshalAs(UnmanagedType.I4)]
                              int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetPixelWidth();

            
            void SetPixelHeight(
                               [In, MarshalAs(UnmanagedType.I4)]
                               int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetPixelHeight();

            
            void SetPosTop(
                          [In, MarshalAs(UnmanagedType.R4)]
                          float p);

            [return: MarshalAs(UnmanagedType.R4)]
            float GetPosTop();

            
            void SetPosLeft(
                           [In, MarshalAs(UnmanagedType.R4)]
                           float p);

            [return: MarshalAs(UnmanagedType.R4)]
            float GetPosLeft();

            
            void SetPosWidth(
                            [In, MarshalAs(UnmanagedType.R4)]
                            float p);

            [return: MarshalAs(UnmanagedType.R4)]
            float GetPosWidth();

            
            void SetPosHeight(
                             [In, MarshalAs(UnmanagedType.R4)]
                             float p);

            [return: MarshalAs(UnmanagedType.R4)]
            float GetPosHeight();

            
            void SetCursor(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetCursor();

            
            void SetClip(
                        [In, MarshalAs(UnmanagedType.BStr)]
                        string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetClip();

            
            void SetFilter(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFilter();

            
            void SetAttribute(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string strAttributeName,
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object AttributeValue,
                             [In, MarshalAs(UnmanagedType.I4)]
                             int lFlags);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetAttribute(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string strAttributeName,
                               [In, MarshalAs(UnmanagedType.I4)]
                               int lFlags);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool RemoveAttribute(
                                [In, MarshalAs(UnmanagedType.BStr)]
                                string strAttributeName,
                                [In, MarshalAs(UnmanagedType.I4)]
                                int lFlags);

        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F3DB-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLCurrentStyle {

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPosition();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetStyleFloat();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetColor();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundColor();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontFamily();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontStyle();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontObject();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetFontWeight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetFontSize();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundImage();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundPositionX();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundPositionY();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundRepeat();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderLeftColor();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderTopColor();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderRightColor();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderBottomColor();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderTopStyle();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderRightStyle();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderBottomStyle();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderLeftStyle();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderTopWidth();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderRightWidth();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderBottomWidth();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderLeftWidth();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLeft();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetTop();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetWidth();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetHeight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingLeft();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingTop();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingRight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingBottom();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextAlign();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextDecoration();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDisplay();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetVisibility();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetZIndex();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLetterSpacing();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLineHeight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetTextIndent();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetVerticalAlign();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundAttachment();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginTop();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginRight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginBottom();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginLeft();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetClear();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleType();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStylePosition();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleImage();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetClipTop();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetClipRight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetClipBottom();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetClipLeft();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetOverflow();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakBefore();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakAfter();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetCursor();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTableLayout();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderCollapse();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDirection();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBehavior();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetAttribute(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string strAttributeName,
                               [In, MarshalAs(UnmanagedType.I4)]
                               int lFlags);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetUnicodeBidi();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetRight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBottom();

        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F21F-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLElementCollection {

            [return: MarshalAs(UnmanagedType.BStr)]
            string toString();

            
            void SetLength(
                          [In, MarshalAs(UnmanagedType.I4)] 
                          int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetLength();

            [return: MarshalAs(UnmanagedType.Interface)]
            object Get_newEnum();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement Item(
                       [In, MarshalAs(UnmanagedType.Struct)] 
                       Object name,
                       [In, MarshalAs(UnmanagedType.Struct)] 
                       Object index);

            [return: MarshalAs(UnmanagedType.Interface)]
            object Tags(
                       [In, MarshalAs(UnmanagedType.Struct)] 
                       Object tagName);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F4A3-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLRect {

            
            void SetLeft(
                        [In, MarshalAs(UnmanagedType.I4)] 
                        int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetLeft();

            
            void SetTop(
                       [In, MarshalAs(UnmanagedType.I4)] 
                       int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetTop();

            
            void SetRight(
                         [In, MarshalAs(UnmanagedType.I4)] 
                         int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetRight();

            
            void SetBottom(
                          [In, MarshalAs(UnmanagedType.I4)] 
                          int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetBottom();

        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F4A4-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLRectCollection {

            [return: MarshalAs(UnmanagedType.I4)]
            int GetLength();

            [return: MarshalAs(UnmanagedType.Interface)]
            object Get_newEnum();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object Item(
                       [In]
                       ref Object pvarIndex);

        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F5DA-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLDOMNode {

            [return: MarshalAs(UnmanagedType.I4)]
            int GetNodeType();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode GetParentNode();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool HasChildNodes();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetChildNodes();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetAttributes();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode InsertBefore(
                                     [In, MarshalAs(UnmanagedType.Interface)]
                                     IHTMLDOMNode newChild,
                                     [In, MarshalAs(UnmanagedType.Struct)]
                                     Object refChild);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode RemoveChild(
                                    [In, MarshalAs(UnmanagedType.Interface)]
                                    IHTMLDOMNode oldChild);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode ReplaceChild(
                                     [In, MarshalAs(UnmanagedType.Interface)]
                                     IHTMLDOMNode newChild,
                                     [In, MarshalAs(UnmanagedType.Interface)]
                                     IHTMLDOMNode oldChild);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode CloneNode(
                                  [In, MarshalAs(UnmanagedType.Bool)]
                                  bool fDeep);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode RemoveNode(
                                   [In, MarshalAs(UnmanagedType.Bool)]
                                   bool fDeep);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode SwapNode(
                                 [In, MarshalAs(UnmanagedType.Interface)]
                                 IHTMLDOMNode otherNode);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode ReplaceNode(
                                    [In, MarshalAs(UnmanagedType.Interface)]
                                    IHTMLDOMNode replacement);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode AppendChild(
                                    [In, MarshalAs(UnmanagedType.Interface)]
                                    IHTMLDOMNode newChild);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetNodeName();

            
            void SetNodeValue(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetNodeValue();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode GetFirstChild();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode GetLastChild();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode GetPreviousSibling();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode GetNextSibling();
        }

        public static readonly int WM_MOUSEENTER = Util.RegisterWindowMessage("WinFormsMouseEnter");
        public static readonly int HDN_ENDTRACK = Marshal.SystemDefaultCharSize == 1 ? NativeMethods.HDN_ENDTRACKA : NativeMethods.HDN_ENDTRACKW;

        public const int 
            WM_CAPTURECHANGED = 0x0215,
        WM_PARENTNOTIFY = 0x0210,
        WM_CREATE = 0x0001,
        WM_SETREDRAW = 0x000B,
        WM_NCACTIVATE = 0x0086,
        WM_HSCROLL = 0x0114,
        WM_VSCROLL = 0x0115,
        WM_WINDOWPOSCHANGED = 0x0047,
        WS_CLIPSIBLINGS = 0x04000000,
        WS_CLIPCHILDREN = 0x02000000,
        NOTSRCCOPY = 0x00330008,
        SRCCOPY = 0x00CC0020,
        LVM_SETCOLUMNWIDTH = (0x1000+30),
                             LVM_GETHEADER = (0x1000+31),
                                             LVM_CREATEDRAGIMAGE = (0x1000+33),
                                                                   LVM_GETVIEWRECT = (0x1000+34),
                                                                                     LVM_GETTEXTCOLOR = (0x1000+35),
                                                                                                        LVM_SETTEXTCOLOR = (0x1000+36),
                                                                                                                           LVM_GETTEXTBKCOLOR = (0x1000+37),
                                                                                                                                                LVM_SETTEXTBKCOLOR = (0x1000+38),
                                                                                                                                                                     LVM_GETTOPINDEX = (0x1000+39),
                                                                                                                                                                                       LVM_GETCOUNTPERPAGE = (0x1000+40),
                                                                                                                                                                                                             LVM_GETORIGIN = (0x1000+41),
                                                                                                                                                                                                                             LVM_UPDATE = (0x1000+42),
                                                                                                                                                                                                                                          LVM_SETITEMSTATE = (0x1000+43),
                                                                                                                                                                                                                                                             LVM_GETITEMSTATE = (0x1000+44),
                                                                                                                                                                                                                                                                                LVM_GETITEMTEXTA = (0x1000+45),
                                                                                                                                                                                                                                                                                                   LVM_GETITEMTEXTW = (0x1000+115),
                                                                                                                                                                                                                                                                                                                      LVM_SETITEMTEXTA = (0x1000+46),
                                                                                                                                                                                                                                                                                                                                         LVM_SETITEMTEXTW = (0x1000+116),
                                                                                                                                                                                                                                                                                                                                                            LVSICF_NOINVALIDATEALL = 0x00000001,
        LVSICF_NOSCROLL = 0x00000002,
        LVM_SETITEMCOUNT = (0x1000+47),
                           LVM_SORTITEMS = (0x1000+48),
                                           LVM_SETITEMPOSITION32 = (0x1000+49),
                                                                   LVM_GETSELECTEDCOUNT = (0x1000+50),
                                                                                          LVM_GETITEMSPACING = (0x1000+51),
                                                                                                               LVM_GETISEARCHSTRINGA = (0x1000+52),
                                                                                                                                       LVM_GETISEARCHSTRINGW = (0x1000+117),
                                                                                                                                                               LVM_SETICONSPACING = (0x1000+53),
                                                                                                                                                                                    LVM_SETEXTENDEDLISTVIEWSTYLE = (0x1000+54),
                                                                                                                                                                                                                   LVM_GETEXTENDEDLISTVIEWSTYLE = (0x1000+55),
                                                                                                                                                                                                                                                  LVS_EX_GRIDLINES = 0x00000001,
        HDM_HITTEST = (0x1200+6),
                      HDM_GETITEMRECT = (0x1200+7),
                                        HDM_SETIMAGELIST = (0x1200+8),
                                                           HDM_GETIMAGELIST = (0x1200+9),
                                                                              HDM_ORDERTOINDEX = (0x1200+15),
                                                                                                 HDM_CREATEDRAGIMAGE = (0x1200+16),
                                                                                                                       HDM_GETORDERARRAY = (0x1200+17),
                                                                                                                                           HDM_SETORDERARRAY = (0x1200+18),
                                                                                                                                                               HDM_SETHOTDIVIDER = (0x1200+19),
                                                                                                                                                                                   HDN_ITEMCHANGINGA = ((0-300)-0),
                                                                                                                                                                                                       HDN_ITEMCHANGINGW = ((0-300)-20),
                                                                                                                                                                                                                           HDN_ITEMCHANGEDA = ((0-300)-1),
                                                                                                                                                                                                                                              HDN_ITEMCHANGEDW = ((0-300)-21),
                                                                                                                                                                                                                                                                 HDN_ITEMCLICKA = ((0-300)-2),
                                                                                                                                                                                                                                                                                  HDN_ITEMCLICKW = ((0-300)-22),
                                                                                                                                                                                                                                                                                                   HDN_ITEMDBLCLICKA = ((0-300)-3),
                                                                                                                                                                                                                                                                                                                       HDN_ITEMDBLCLICKW = ((0-300)-23),
                                                                                                                                                                                                                                                                                                                                           HDN_DIVIDERDBLCLICKA = ((0-300)-5),
                                                                                                                                                                                                                                                                                                                                                                  HDN_DIVIDERDBLCLICKW = ((0-300)-25),
                                                                                                                                                                                                                                                                                                                                                                                         HDN_BEGINTRACKA = ((0-300)-6),
                                                                                                                                                                                                                                                                                                                                                                                                           HDN_BEGINTRACKW = ((0-300)-26),
                                                                                                                                                                                                                                                                                                                                                                                                                             HDN_ENDTRACKA = ((0-300)-7),
                                                                                                                                                                                                                                                                                                                                                                                                                                             HDN_ENDTRACKW = ((0-300)-27),
                                                                                                                                                                                                                                                                                                                                                                                                                                                             HDN_TRACKA = ((0-300)-8),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          HDN_TRACKW = ((0-300)-28),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       HDN_GETDISPINFOA = ((0-300)-9),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          HDN_GETDISPINFOW = ((0-300)-29),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             HDN_BEGINDRAG = ((0-300)-10),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             HDN_ENDDRAG = ((0-300)-11),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           HIST_BACK = 0,
        HHT_ONHEADER = 0x0002,
        HHT_ONDIVIDER = 0x0004,
        HHT_ONDIVOPEN = 0x0008,
        HHT_ABOVE = 0x0100,
        HHT_BELOW = 0x0200,
        HHT_TORIGHT = 0x0400,
        HHT_TOLEFT = 0x0800,
        HWND_TOP = 0,
        HWND_BOTTOM = 1,
        HWND_TOPMOST = -1,
        HWND_NOTOPMOST = -2,
        CWP_SKIPINVISIBLE = 0x0001,
        RDW_FRAME = 0x0400,
        WM_KILLFOCUS = 0x0008,
        WM_STYLECHANGED = 0x007D,
        TVM_GETITEMRECT = (0x1100+4),
                          TVM_GETCOUNT = (0x1100+5),
                                         TVM_GETINDENT = (0x1100+6),
                                                         TVM_SETINDENT = (0x1100+7),
                                                                         TVM_GETIMAGELIST = (0x1100+8),
                                                                                            TVSIL_NORMAL = 0,
        TVSIL_STATE = 2,
        TVM_SETIMAGELIST = (0x1100+9),
                           TVM_GETNEXTITEM = (0x1100+10),
                                             TVGN_ROOT = 0x0000,
        TVHT_ONITEMICON = 0x0002,
        TVHT_ONITEMLABEL = 0x0004,
        TVHT_ONITEMINDENT = 0x0008,
        TVHT_ONITEMBUTTON = 0x0010,
        TVHT_ONITEMRIGHT = 0x0020,
        TVHT_ONITEMSTATEICON = 0x0040,
        TVHT_ABOVE = 0x0100,
        TVHT_BELOW = 0x0200,
        TVHT_TORIGHT = 0x0400,
        TVHT_TOLEFT = 0x0800,
        GW_HWNDFIRST = 0,
        GW_HWNDLAST = 1,
        GW_HWNDNEXT = 2,
        GW_HWNDPREV = 3,
        GW_OWNER = 4,
        GW_CHILD = 5,
        GW_MAX = 5,
        SB_HORZ = 0,
        SB_VERT = 1,
        SB_CTL = 2,
        SB_BOTH = 3,
        SB_LINEUP = 0,
        SB_LINELEFT = 0,
        SB_LINEDOWN = 1,
        SB_LINERIGHT = 1,
        SB_PAGEUP = 2,
        SB_PAGELEFT = 2,
        SB_PAGEDOWN = 3,
        SB_PAGERIGHT = 3,
        SB_THUMBPOSITION = 4,
        SB_THUMBTRACK = 5,
        SB_TOP = 6,
        SB_LEFT = 6,
        SB_BOTTOM = 7,
        SB_RIGHT = 7,
        SB_ENDSCROLL = 8,
        MK_LBUTTON = 0x0001,
        TVM_HITTEST = (0x1100+17),
                      MK_RBUTTON = 0x0002,
        MK_SHIFT = 0x0004,
        MK_CONTROL = 0x0008,
        MK_MBUTTON = 0x0010,
        LB_ADDSTRING = 0x0180,
        LB_INSERTSTRING = 0x0181,
        LB_DELETESTRING = 0x0182,
        LB_SELITEMRANGEEX = 0x0183,
        LB_RESETCONTENT = 0x0184,
        LB_SETSEL = 0x0185,
        LB_SETCURSEL = 0x0186,
        LB_GETSEL = 0x0187,
        LB_GETCURSEL = 0x0188,
        LB_GETTEXT = 0x0189,
        LB_GETTEXTLEN = 0x018A,
        LB_GETCOUNT = 0x018B,
        LB_SELECTSTRING = 0x018C,
        LB_DIR = 0x018D,
        LB_GETTOPINDEX = 0x018E,
        LB_FINDSTRING = 0x018F,
        LB_GETSELCOUNT = 0x0190,
        LB_GETSELITEMS = 0x0191,
        LB_SETTABSTOPS = 0x0192,
        LB_GETHORIZONTALEXTENT = 0x0193,
        LB_SETHORIZONTALEXTENT = 0x0194,
        LB_SETCOLUMNWIDTH = 0x0195,
        LB_ADDFILE = 0x0196,
        LB_SETTOPINDEX = 0x0197,
        LB_GETITEMRECT = 0x0198,
        LB_GETITEMDATA = 0x0199,
        LB_SETITEMDATA = 0x019A,
        LB_SELITEMRANGE = 0x019B,
        LB_SETANCHORINDEX = 0x019C,
        LB_GETANCHORINDEX = 0x019D,
        LB_SETCARETINDEX = 0x019E,
        LB_GETCARETINDEX = 0x019F,
        LB_SETITEMHEIGHT = 0x01A0,
        LB_GETITEMHEIGHT = 0x01A1,
        LB_FINDSTRINGEXACT = 0x01A2,
        LB_SETLOCALE = 0x01A5,
        LB_GETLOCALE = 0x01A6,
        LB_SETCOUNT = 0x01A7,
        LB_INITSTORAGE = 0x01A8,
        LB_ITEMFROMPOINT = 0x01A9,
        LB_MSGMAX = 0x01B0,
        HTHSCROLL = 6,
        HTVSCROLL = 7,
        HTERROR = (-2),
                  HTTRANSPARENT = (-1),
                                  HTNOWHERE = 0,
        HTCLIENT = 1,
        HTCAPTION = 2,
        HTSYSMENU = 3,
        HTGROWBOX = 4,
        HTSIZE = 4,
        SWP_NOSIZE = 0x0001,
        SWP_NOMOVE = 0x0002,
        SWP_NOZORDER = 0x0004,
        SWP_NOREDRAW = 0x0008,
        SWP_NOACTIVATE = 0x0010,
        SWP_FRAMECHANGED = 0x0020,
        SWP_SHOWWINDOW = 0x0040,
        SWP_HIDEWINDOW = 0x0080,
        SWP_NOCOPYBITS = 0x0100,
        SWP_NOOWNERZORDER = 0x0200,
        SWP_NOSENDCHANGING = 0x0400,
        SWP_DRAWFRAME = 0x0020,
        SWP_NOREPOSITION = 0x0200,
        SWP_DEFERERASE = 0x2000,
        SWP_ASYNCWINDOWPOS = 0x4000,
        WM_IME_ENDCOMPOSITION = 0x10E,
        WM_NCMOUSEMOVE = 0x00A0,
        WM_NCLBUTTONDOWN = 0x00A1,
        WM_NCLBUTTONUP = 0x00A2,
        WM_NCLBUTTONDBLCLK = 0x00A3,
        WM_NCRBUTTONDOWN = 0x00A4,
        WM_NCRBUTTONUP = 0x00A5,
        WM_NCRBUTTONDBLCLK = 0x00A6,
        WM_NCMBUTTONDOWN = 0x00A7,
        WM_NCMBUTTONUP = 0x00A8,
        WM_NCMBUTTONDBLCLK = 0x00A9,
        WM_MOUSEHOVER = 0x02A1,
        WM_MOUSELEAVE = 0x02A3,
        WM_MOUSEFIRST = 0x0200,
        WM_LBUTTONDOWN = 0x0201,
        WM_LBUTTONUP = 0x0202,
        WM_LBUTTONDBLCLK = 0x0203,
        WM_RBUTTONDOWN = 0x0204,
        WM_RBUTTONUP = 0x0205,
        WM_RBUTTONDBLCLK = 0x0206,
        WM_MBUTTONDOWN = 0x0207,
        WM_MBUTTONUP = 0x0208,
        WM_MBUTTONDBLCLK = 0x0209,
        WM_NCMOUSEHOVER = 0x02A0,
        WM_NCMOUSELEAVE = 0x02A2,
        WM_MOUSEWHEEL = 0x020A,
        WM_MOUSELAST = 0x020A,
        WM_NCHITTEST = 0x0084,
        WM_SETCURSOR = 0x0020,
        WM_GETOBJECT = 0x003D,
        WM_CANCELMODE = 0x001F,
        WM_SETFOCUS = 0x0007,
        WM_KEYFIRST = 0x0100,
        WM_KEYDOWN = 0x0100,
        WM_KEYUP = 0x0101,
        WM_DEADCHAR = 0x0103,
        WM_SYSKEYDOWN = 0x0104,
        WM_SYSKEYUP = 0x0105,
        WM_SYSCHAR = 0x0106,
        WM_SYSDEADCHAR = 0x0107,
        WM_KEYLAST = 0x0108,
        WM_CONTEXTMENU = 0x007B,
        WM_PAINT = 0x000F,
        WM_SIZE = 0x0005,
        WM_TIMER = 0x0113;

        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr PostMessage(IntPtr hWnd, int msg, int wParam, int lParam);
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetCursorPos([In, Out] POINT pt);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr WindowFromPoint(int x, int y);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SendMessage(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, [In, Out] ref RECT lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, [In, Out] HDHITTESTINFO lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SendMessage(IntPtr hWnd, int msg, int wParam, int lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SendMessage(IntPtr hWnd, int msg, int wParam, string lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]        
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, int wParam, [In, Out] TV_HITTESTINFO lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, ref short wParam, ref short lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, [In, Out, MarshalAs(UnmanagedType.Bool)] bool wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, ListViewCompareCallback pfnCompare);
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="SendMessageW", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern IntPtr SendMessageW(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="SendMessageA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
        public static extern IntPtr SendMessageA(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr DefWindowProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GetWindow(IntPtr hWnd, int uCmd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern short GetKeyState(int keyCode);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int MapWindowPoints(IntPtr hWndFrom, IntPtr hWndTo, [In, Out] ref RECT rect, int cPoints);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int MapWindowPoints(IntPtr hWndFrom, IntPtr hWndTo, [In, Out] POINT pt, int cPoints);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool ValidateRect(IntPtr hwnd, ref RECT rect);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool ValidateRect(IntPtr hwnd, IntPtr prect);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool ValidateRgn(IntPtr hwnd, IntPtr hrgn);

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateRectRgn", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr IntCreateRectRgn(int x1, int y1, int x2, int y2);
        public static IntPtr CreateRectRgn(int x1, int y1, int x2, int y2) {
            return HandleCollector.Add(IntCreateRectRgn(x1, y1, x2, y2), CommonHandles.GDI);
        }
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetUpdateRect(IntPtr hwnd, [In, Out] ref RECT rc, bool fErase);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetUpdateRgn(IntPtr hwnd, IntPtr hrgn, bool fErase);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="DeleteObject", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern bool IntDeleteObject(IntPtr hObject);
        public static bool DeleteObject(IntPtr hObject) {
            HandleCollector.Remove(hObject, CommonHandles.GDI);
            return IntDeleteObject(hObject);
        }
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SetParent(IntPtr hWnd, IntPtr hWndParent);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool TranslateMessage([In, Out] ref MSG msg);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int DispatchMessage([In] ref MSG msg);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
        public static extern int DispatchMessageA([In] ref MSG msg);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int DispatchMessageW([In] ref MSG msg);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SetTimer(IntPtr hWnd, int nIDEvent, int uElapse, TimerProc lpTimerFunc);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetWindowRect(IntPtr hWnd, [In, Out] ref RECT rect);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool KillTimer(IntPtr hwnd, int idEvent);
        [DllImport(ExternDll.Ole32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int RevokeDragDrop(IntPtr hwnd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr ChildWindowFromPointEx(IntPtr hwndParent, int x, int y, int uFlags);

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool IsWindowVisible(IntPtr hWnd);

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GetFocus();  
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class HDHITTESTINFO {
            public int pt_x;
            public int pt_y;
            public int flags;
            public int iItem;
        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
        public sealed class tagOLEVERB {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)/*leftover(offset=0, lVerb)*/]
            public int lVerb;

            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPWStr)/*leftover(offset=4, customMarshal="UniStringMarshaller", lpszVerbName)*/]
            public String lpszVerbName;

            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U4)/*leftover(offset=8, fuFlags)*/]
            public int fuFlags;

            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U4)/*leftover(offset=12, grfAttribs)*/]
            public int grfAttribs;

        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto, Pack=1)]
        public class TV_HITTESTINFO {
            public int  pt_x;
            public int  pt_y;
            public int  flags;
            public int  hItem;
        }

        public delegate int ListViewCompareCallback(IntPtr lParam1, IntPtr lParam2, IntPtr lParamSort);

        public delegate void TimerProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);

        internal class Util {
            public static int MAKELONG(int low, int high) {
                return(high << 16) | (low & 0xffff);
            }

            public static int MAKELPARAM(int low, int high) {
                return(high << 16) | (low & 0xffff);
            }

            public static int HIWORD(int n) {
                return(n >> 16) & 0xffff;
            }

            public static int LOWORD(int n) {
                return n & 0xffff;
            }

            public static int SignedHIWORD(int n) {
                int i = (int)(short)((n >> 16) & 0xffff);

                i = i << 16;
                i = i >> 16;

                return i;
            }

            public static int SignedLOWORD(int n) {
                int i = (int)(short)(n & 0xFFFF);

                i = i << 16;
                i = i >> 16;

                return i;
            }
            [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
            private static extern int lstrlen(String s);

            [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
            internal static extern int RegisterWindowMessage(String msg);
        }
        public sealed class CommonHandles {
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Accelerator"]/*' />
            /// <devdoc>
            ///     Handle type for accelerator tables.
            /// </devdoc>
            public static readonly int Accelerator  = HandleCollector.RegisterType("Accelerator", 80, 50);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Cursor"]/*' />
            /// <devdoc>
            ///     handle type for cursors.
            /// </devdoc>
            public static readonly int Cursor       = HandleCollector.RegisterType("Cursor", 20, 500);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.EMF"]/*' />
            /// <devdoc>
            ///     Handle type for enhanced metafiles.
            /// </devdoc>
            public static readonly int EMF          = HandleCollector.RegisterType("EnhancedMetaFile", 20, 500);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Find"]/*' />
            /// <devdoc>
            ///     Handle type for file find handles.
            /// </devdoc>
            public static readonly int Find         = HandleCollector.RegisterType("Find", 0, 1000);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.GDI"]/*' />
            /// <devdoc>
            ///     Handle type for GDI objects.
            /// </devdoc>
            public static readonly int GDI          = HandleCollector.RegisterType("GDI", 90, 50);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.HDC"]/*' />
            /// <devdoc>
            ///     Handle type for HDC's that count against the Win98 limit of five DC's.  HDC's
            ///     which are not scarce, such as HDC's for bitmaps, are counted as GDIHANDLE's.
            /// </devdoc>
            public static readonly int HDC          = HandleCollector.RegisterType("HDC", 100, 2); // wait for 2 dc's before collecting

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Icon"]/*' />
            /// <devdoc>
            ///     Handle type for icons.
            /// </devdoc>
            public static readonly int Icon         = HandleCollector.RegisterType("Icon", 20, 500);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Kernel"]/*' />
            /// <devdoc>
            ///     Handle type for kernel objects.
            /// </devdoc>
            public static readonly int Kernel       = HandleCollector.RegisterType("Kernel", 0, 1000);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Menu"]/*' />
            /// <devdoc>
            ///     Handle type for files.
            /// </devdoc>
            public static readonly int Menu         = HandleCollector.RegisterType("Menu", 30, 1000);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Window"]/*' />
            /// <devdoc>
            ///     Handle type for windows.
            /// </devdoc>
            public static readonly int Window       = HandleCollector.RegisterType("Window", 5, 1000);
        }
        [System.Runtime.InteropServices.ComVisible(false)]
        public sealed class HandleCollector {
            private static HandleType[]             handleTypes = null;
            private static int                      handleTypeCount = 0;
            private static HandleChangeEventHandler handleAdd = null;
            private static HandleChangeEventHandler handleRemove = null;

#if MULTI_THREAD_COLLECT
            private static Daemon collectorDaemon = null;
#endif

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Add"]/*' />
            /// <devdoc>
            ///     Adds the given handle to the handle collector.  This keeps the
            ///     handle on a "hot list" of objects that may need to be garbage
            ///     collected.
            /// </devdoc>
            public static IntPtr Add(IntPtr handle, int type) {
                handleTypes[type - 1].Add(handle);

#if MULTI_THREAD_COLLECT
                if (collectorDaemon == null) {
                    lock (typeof(HandleCollector)) {
                        if (collectorDaemon == null) {
                            collectorDaemon = new Daemon();
                        }
                    }
                }
#endif

                return handle;
            }


            public static event HandleChangeEventHandler HandleAdded {
                add {
                    handleAdd += value;
                }
                remove {
                    handleAdd -= value;
                }
            }


            public static event HandleChangeEventHandler HandleRemoved {
                add {
                    handleRemove += value;
                }
                remove {
                    handleRemove -= value;
                }
            }

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.RegisterType"]/*' />
            /// <devdoc>
            ///     Registers a new type of handle with the handle collector.
            /// </devdoc>
            public static int RegisterType(string typeName, int expense, int initialThreshold) {
                lock(typeof(HandleCollector)) {
                    if (handleTypeCount == 0 || handleTypeCount == handleTypes.Length) {
                        HandleType[] newTypes = new HandleType[handleTypeCount + 10];
                        if (handleTypes != null) {
                            Array.Copy(handleTypes, 0, newTypes, 0, handleTypeCount);
                        }
                        handleTypes = newTypes;
                    }

                    handleTypes[handleTypeCount++] = new HandleType(typeName, expense, initialThreshold);
                    return handleTypeCount;
                }
            }

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Remove"]/*' />
            /// <devdoc>
            ///     Removes the given handle from the handle collector.  Removing a
            ///     handle removes it from our "hot list" of objects that should be
            ///     frequently garbage collected.
            /// </devdoc>
            public static IntPtr Remove(IntPtr handle, int type) {
                return handleTypes[type - 1].Remove(handle);
            }

#if MULTI_THREAD_COLLECT
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Daemon"]/*' />
            /// <devdoc>
            ///     Private inner class that runs a deamon thread to monitor
            ///     handle usage.
            /// </devdoc>
            private class Daemon {
                private Thread thread;

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Daemon.Daemon"]/*' />
                /// <devdoc>
                ///     Creates a new Daemon thread monitor.
                /// </devdoc>
                public Daemon() {
                    thread = new Thread(new ThreadStart(this.ThreadProc));
                    thread.Priority = Thread.PriorityLowest;
                    thread.IsBackground = true;
                    thread.Start();
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Daemon.Collect"]/*' />
                /// <devdoc>
                ///     Forces a GC if needed.
                /// </devdoc>
                public void Collect() {
                    // See if we need to collect.
                    //
                    bool collect = false;
                    HandleType[] collectedTypes = null;

                    lock (typeof(HandleCollector)) {
                        for (int i = 0; i < HandleCollector.handleTypeCount; i++) {
                            if (HandleCollector.handleTypes[i].NeedCollection()) {
                                if (collectedTypes == null) {
                                    collectedTypes = new HandleType[HandleCollector.handleTypeCount];
                                }
                                collectedTypes[i] = HandleCollector.handleTypes[i];
                                collect = true;
                            }
                        }
                    }

                    if (collect) {
                        GC.Collect();
                        for (int i = 0; i < collectedTypes.Length; i++) {
                            if (collectedTypes[i] != null) {
                                collectedTypes[i].Collected();
                            }
                        }
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Daemon.Dispose"]/*' />
                /// <devdoc>
                ///     Disposes this daemon object by destroying the thread.
                /// </devdoc>
                public void Dispose() {
                    lock(this) {
                        if (thread != null) {
                            thread.Stop();
                            thread = null;
                        }
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Daemon.ThreadProc"]/*' />
                /// <devdoc>
                ///     Thread proc.  This runs in it's own thread in the background, looking
                ///     for opportune times to force GC.
                /// </devdoc>
                private void ThreadProc() {
                    while (true) {
                        Collect();
                        try {
                            Thread.Sleep(500);
                        }
                        catch (ThreadInterruptedException e1) {
                        }
                    }
                }
            }
#endif

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType"]/*' />
            /// <devdoc>
            ///     Represents a specific type of handle.
            /// </devdoc>
            private class HandleType {
                public readonly String name;

                private int threshHold;
                private int handleCount;
                private readonly int deltaPercent;

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.HandleType"]/*' />
                /// <devdoc>
                ///     Creates a new handle type.
                /// </devdoc>
                public HandleType(String name, int expense, int initialThreshold) {
                    this.name = name;
                    this.threshHold = initialThreshold;
                    this.handleCount = 0;
                    this.deltaPercent = 100 - expense;
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.Add"]/*' />
                /// <devdoc>
                ///     Adds a handle to this handle type for monitoring.
                /// </devdoc>
                public void Add(IntPtr handle) {
                    lock(this) {
                        handleCount++;
#if !MULTI_THREAD_COLLECT
                        if (NeedCollection()) {
#if DEBUG_HANDLECOLLECTOR
                            Debug.WriteLine("HC> Forcing GC");
                            Debug.WriteLine("HC>     name        :" + name);
                            Debug.WriteLine("HC>     threshHold  :" + (threshHold).ToString());
                            Debug.WriteLine("HC>     handleCount :" + (handleCount).ToString());
                            Debug.WriteLine("HC>     deltaPercent:" + (deltaPercent).ToString());
#endif
                            GC.Collect();
                            Collected();
                        }
#endif

                        if (HandleCollector.handleAdd != null) {
                            HandleCollector.handleAdd(name, handle, GetHandleCount());
                        }
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.Collected"]/*' />
                /// <devdoc>
                ///     Called after the collector has finished it's work.  Here,
                ///     we look at the number of objects currently outstanding
                ///     and establish a new cleanup threshhold.
                /// </devdoc>
                public void Collected() {
                    lock(this) {
                        threshHold = handleCount + ((handleCount * deltaPercent) / 100);
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.GetHandleCount"]/*' />
                /// <devdoc>
                ///     Retrieves the outstanding handle count for this
                ///     handle type.
                /// </devdoc>
                public int GetHandleCount() {
                    lock(this) {
                        return handleCount;
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.NeedCollection"]/*' />
                /// <devdoc>
                ///     Determines if this handle type needs a GC pass.
                /// </devdoc>
                public  bool NeedCollection() {
                    lock(this) {
                        return handleCount > threshHold;
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.Remove"]/*' />
                /// <devdoc>
                ///     Removes the given handle from our monitor list.
                /// </devdoc>
                public IntPtr Remove(IntPtr handle) {
                    lock(this) {
                        handleCount--;
                        if (HandleCollector.handleRemove != null) {
                            HandleCollector.handleRemove(name, handle, GetHandleCount());
                        }
                        return handle;
                    }
                }
            }
        }
        public delegate void HandleChangeEventHandler(string handleType, IntPtr handleValue, int currentHandleCount);

        [System.Runtime.InteropServices.ComVisible(false)]
        internal class ActiveX {

            public const   int OCM__BASE = 0x2000;
            public const   int DISPID_VALUE = unchecked((int)0x0);
            public const   int DISPID_UNKNOWN = unchecked((int)0xFFFFFFFF);
            public const   int DISPID_AUTOSIZE = unchecked((int)0xFFFFFE0C);
            public const   int DISPID_BACKCOLOR = unchecked((int)0xFFFFFE0B);
            public const   int DISPID_BACKSTYLE = unchecked((int)0xFFFFFE0A);
            public const   int DISPID_BORDERCOLOR = unchecked((int)0xFFFFFE09);
            public const   int DISPID_BORDERSTYLE = unchecked((int)0xFFFFFE08);
            public const   int DISPID_BORDERWIDTH = unchecked((int)0xFFFFFE07);
            public const   int DISPID_DRAWMODE = unchecked((int)0xFFFFFE05);
            public const   int DISPID_DRAWSTYLE = unchecked((int)0xFFFFFE04);
            public const   int DISPID_DRAWWIDTH = unchecked((int)0xFFFFFE03);
            public const   int DISPID_FILLCOLOR = unchecked((int)0xFFFFFE02);
            public const   int DISPID_FILLSTYLE = unchecked((int)0xFFFFFE01);
            public const   int DISPID_FONT = unchecked((int)0xFFFFFE00);
            public const   int DISPID_FORECOLOR = unchecked((int)0xFFFFFDFF);
            public const   int DISPID_ENABLED = unchecked((int)0xFFFFFDFE);
            public const   int DISPID_HWND = unchecked((int)0xFFFFFDFD);
            public const   int DISPID_TABSTOP = unchecked((int)0xFFFFFDFC);
            public const   int DISPID_TEXT = unchecked((int)0xFFFFFDFB);
            public const   int DISPID_CAPTION = unchecked((int)0xFFFFFDFA);
            public const   int DISPID_BORDERVISIBLE = unchecked((int)0xFFFFFDF9);
            public const   int DISPID_APPEARANCE = unchecked((int)0xFFFFFDF8);
            public const   int DISPID_MOUSEPOINTER = unchecked((int)0xFFFFFDF7);
            public const   int DISPID_MOUSEICON = unchecked((int)0xFFFFFDF6);
            public const   int DISPID_PICTURE = unchecked((int)0xFFFFFDF5);
            public const   int DISPID_VALID = unchecked((int)0xFFFFFDF4);
            public const   int DISPID_READYSTATE = unchecked((int)0xFFFFFDF3);
            public const   int DISPID_REFRESH = unchecked((int)0xFFFFFDDA);
            public const   int DISPID_DOCLICK = unchecked((int)0xFFFFFDD9);
            public const   int DISPID_ABOUTBOX = unchecked((int)0xFFFFFDD8);
            public const   int DISPID_CLICK = unchecked((int)0xFFFFFDA8);
            public const   int DISPID_DBLCLICK = unchecked((int)0xFFFFFDA7);
            public const   int DISPID_KEYDOWN = unchecked((int)0xFFFFFDA6);
            public const   int DISPID_KEYPRESS = unchecked((int)0xFFFFFDA5);
            public const   int DISPID_KEYUP = unchecked((int)0xFFFFFDA4);
            public const   int DISPID_MOUSEDOWN = unchecked((int)0xFFFFFDA3);
            public const   int DISPID_MOUSEMOVE = unchecked((int)0xFFFFFDA2);
            public const   int DISPID_MOUSEUP = unchecked((int)0xFFFFFDA1);
            public const   int DISPID_ERROREVENT = unchecked((int)0xFFFFFDA0);
            public const   int DISPID_RIGHTTOLEFT = unchecked((int)0xFFFFFD9D);
            public const   int DISPID_READYSTATECHANGE = unchecked((int)0xFFFFFD9F);
            public const   int DISPID_AMBIENT_BACKCOLOR = unchecked((int)0xFFFFFD43);
            public const   int DISPID_AMBIENT_DISPLAYNAME = unchecked((int)0xFFFFFD42);
            public const   int DISPID_AMBIENT_FONT = unchecked((int)0xFFFFFD41);
            public const   int DISPID_AMBIENT_FORECOLOR = unchecked((int)0xFFFFFD40);
            public const   int DISPID_AMBIENT_LOCALEID = unchecked((int)0xFFFFFD3F);
            public const   int DISPID_AMBIENT_MESSAGEREFLECT = unchecked((int)0xFFFFFD3E);
            public const   int DISPID_AMBIENT_SCALEUNITS = unchecked((int)0xFFFFFD3D);
            public const   int DISPID_AMBIENT_TEXTALIGN = unchecked((int)0xFFFFFD3C);
            public const   int DISPID_AMBIENT_USERMODE = unchecked((int)0xFFFFFD3B);
            public const   int DISPID_AMBIENT_UIDEAD = unchecked((int)0xFFFFFD3A);
            public const   int DISPID_AMBIENT_SHOWGRABHANDLES = unchecked((int)0xFFFFFD39);
            public const   int DISPID_AMBIENT_SHOWHATCHING = unchecked((int)0xFFFFFD38);
            public const   int DISPID_AMBIENT_DISPLAYASDEFAULT = unchecked((int)0xFFFFFD37);
            public const   int DISPID_AMBIENT_SUPPORTSMNEMONICS = unchecked((int)0xFFFFFD36);
            public const   int DISPID_AMBIENT_AUTOCLIP = unchecked((int)0xFFFFFD35);
            public const   int DISPID_AMBIENT_APPEARANCE = unchecked((int)0xFFFFFD34);
            public const   int DISPID_AMBIENT_PALETTE = unchecked((int)0xFFFFFD2A);
            public const   int DISPID_AMBIENT_TRANSFERPRIORITY = unchecked((int)0xFFFFFD28);
            public const   int DISPID_Name = unchecked((int)0xFFFFFCE0);
            public const   int DISPID_Delete = unchecked((int)0xFFFFFCDF);
            public const   int DISPID_Object = unchecked((int)0xFFFFFCDE);
            public const   int DISPID_Parent = unchecked((int)0xFFFFFCDD);
            public const   int DVASPECT_CONTENT = 0x1;
            public const   int DVASPECT_THUMBNAIL = 0x2;
            public const   int DVASPECT_ICON = 0x4;
            public const   int DVASPECT_DOCPRINT = 0x8;
            public const   int OLEMISC_RECOMPOSEONRESIZE = 0x1;
            public const   int OLEMISC_ONLYICONIC = 0x2;
            public const   int OLEMISC_INSERTNOTREPLACE = 0x4;
            public const   int OLEMISC_STATIC = 0x8;
            public const   int OLEMISC_CANTLINKINSIDE = 0x10;
            public const   int OLEMISC_CANLINKBYOLE1 = 0x20;
            public const   int OLEMISC_ISLINKOBJECT = 0x40;
            public const   int OLEMISC_INSIDEOUT = 0x80;
            public const   int OLEMISC_ACTIVATEWHENVISIBLE = 0x100;
            public const   int OLEMISC_RENDERINGISDEVICEINDEPENDENT = 0x200;
            public const   int OLEMISC_INVISIBLEATRUNTIME = 0x400;
            public const   int OLEMISC_ALWAYSRUN = 0x800;
            public const   int OLEMISC_ACTSLIKEBUTTON = 0x1000;
            public const   int OLEMISC_ACTSLIKELABEL = 0x2000;
            public const   int OLEMISC_NOUIACTIVATE = 0x4000;
            public const   int OLEMISC_ALIGNABLE = 0x8000;
            public const   int OLEMISC_SIMPLEFRAME = 0x10000;
            public const   int OLEMISC_SETCLIENTSITEFIRST = 0x20000;
            public const   int OLEMISC_IMEMODE = 0x40000;
            public const   int OLEMISC_IGNOREACTIVATEWHENVISIBLE = 0x80000;
            public const   int OLEMISC_WANTSTOMENUMERGE = 0x100000;
            public const   int OLEMISC_SUPPORTSMULTILEVELUNDO = 0x200000;
            public const   int QACONTAINER_SHOWHATCHING = 0x1;
            public const   int QACONTAINER_SHOWGRABHANDLES = 0x2;
            public const   int QACONTAINER_USERMODE = 0x4;
            public const   int QACONTAINER_DISPLAYASDEFAULT = 0x8;
            public const   int QACONTAINER_UIDEAD = 0x10;
            public const   int QACONTAINER_AUTOCLIP = 0x20;
            public const   int QACONTAINER_MESSAGEREFLECT = 0x40;
            public const   int QACONTAINER_SUPPORTSMNEMONICS = 0x80;
            public const   int XFORMCOORDS_POSITION = 0x1;
            public const   int XFORMCOORDS_SIZE = 0x2;
            public const   int XFORMCOORDS_HIMETRICTOCONTAINER = 0x4;
            public const   int XFORMCOORDS_CONTAINERTOHIMETRIC = 0x8;
            public const   int PROPCAT_Nil = unchecked((int)0xFFFFFFFF);
            public const   int PROPCAT_Misc = unchecked((int)0xFFFFFFFE);
            public const   int PROPCAT_Font = unchecked((int)0xFFFFFFFD);
            public const   int PROPCAT_Position = unchecked((int)0xFFFFFFFC);
            public const   int PROPCAT_Appearance = unchecked((int)0xFFFFFFFB);
            public const   int PROPCAT_Behavior = unchecked((int)0xFFFFFFFA);
            public const   int PROPCAT_Data = unchecked((int)0xFFFFFFF9);
            public const   int PROPCAT_List = unchecked((int)0xFFFFFFF8);
            public const   int PROPCAT_Text = unchecked((int)0xFFFFFFF7);
            public const   int PROPCAT_Scale = unchecked((int)0xFFFFFFF6);
            public const   int PROPCAT_DDE = unchecked((int)0xFFFFFFF5);
            public const   int GC_WCH_SIBLING = 0x1;
            public const   int GC_WCH_CONTAINER = 0x2;
            public const   int GC_WCH_CONTAINED = 0x3;
            public const   int GC_WCH_ALL = 0x4;
            public const   int GC_WCH_FREVERSEDIR = 0x8000000;
            public const   int GC_WCH_FONLYNEXT = 0x10000000;
            public const   int GC_WCH_FONLYPREV = 0x20000000;
            public const   int GC_WCH_FSELECTED = 0x40000000;
            public const   int OLECONTF_EMBEDDINGS = 0x1;
            public const   int OLECONTF_LINKS = 0x2;
            public const   int OLECONTF_OTHERS = 0x4;
            public const   int OLECONTF_ONLYUSER = 0x8;
            public const   int OLECONTF_ONLYIFRUNNING = 0x10;
            public const   int ALIGN_MIN = 0x0;
            public const   int ALIGN_NO_CHANGE = 0x0;
            public const   int ALIGN_TOP = 0x1;
            public const   int ALIGN_BOTTOM = 0x2;
            public const   int ALIGN_LEFT = 0x3;
            public const   int ALIGN_RIGHT = 0x4;
            public const   int ALIGN_MAX = 0x4;
            public const   int OLEVERBATTRIB_NEVERDIRTIES = 0x1;
            public const   int OLEVERBATTRIB_ONCONTAINERMENU = 0x2;

            public static Guid IID_IUnknown = new Guid("{00000000-0000-0000-C000-000000000046}");
        }
        public static bool Succeeded(int hr) {
            return(hr >= 0);
        }

        public static bool Failed(int hr) {
            return(hr < 0);
        }
        [ComImport(), Guid("00000104-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IEnumOLEVERB {


            [PreserveSig]
            int Next(
                    [MarshalAs(UnmanagedType.U4)] 
                    int celt,
                    [Out]
                    NativeMethods.tagOLEVERB rgelt,
                    [Out, MarshalAs(UnmanagedType.LPArray)]
                    int[] pceltFetched);

            [PreserveSig]
            int Skip(
                    [In, MarshalAs(UnmanagedType.U4)] 
                    int celt);


            void Reset();


            void Clone(
                      out NativeMethods.IEnumOLEVERB ppenum);


        }

        [ComImport(), Guid("00000105-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IEnumSTATDATA {


            void Next(
                     [In, MarshalAs(UnmanagedType.U4)] 
                     int celt,
                     [Out] 
                     NativeMethods.STATDATA rgelt,
                     [Out, MarshalAs(UnmanagedType.LPArray)] 
                     int[] pceltFetched);


            void Skip(
                     [In, MarshalAs(UnmanagedType.U4)] 
                     int celt);


            void Reset();


            void Clone(
                      [Out, MarshalAs(UnmanagedType.LPArray)] 
                      NativeMethods.IEnumSTATDATA[] ppenum);


        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public sealed class STATDATA {

            [MarshalAs(UnmanagedType.U4)]
            public   int advf;
            [MarshalAs(UnmanagedType.U4)]
            public   int dwConnection;
        }

    
        [ComImport(), Guid("00000103-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IEnumFORMATETC {


            [PreserveSig]
            int Next(
                    [In, MarshalAs(UnmanagedType.U4)] 
                    int celt,
                    [Out] 
                    NativeMethods.FORMATETC rgelt,
                    [In, Out, MarshalAs(UnmanagedType.LPArray)] 
                    int[] pceltFetched);


            [PreserveSig]
            int Skip(
                    [In, MarshalAs(UnmanagedType.U4)] 
                    int celt);


            [PreserveSig]
            int Reset();


            [PreserveSig]
            int Clone(
                     [Out, MarshalAs(UnmanagedType.LPArray)] 
                     NativeMethods.IEnumFORMATETC[] ppenum);


        }
        
        public const int CHILDID_SELF = 0;
        public const int OBJID_WINDOW = 0x00000000;
        public const int OBJID_CLIENT = unchecked(unchecked((int)0xFFFFFFFC));
        public const string uuid_IAccessible  = "{618736E0-3C3D-11CF-810C-00AA00389B71}";
        public const string uuid_IEnumVariant = "{00020404-0000-0000-C000-000000000046}";

        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public static extern UCOMITypeLib LoadRegTypeLib(ref Guid clsid, short majorVersion, short minorVersion, int lcid);

        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public extern static UCOMITypeLib LoadTypeLib([In, MarshalAs(UnmanagedType.LPWStr)]
                                                 string typelib);

        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public extern static UCOMITypeLib LoadTypeLibFromResource([In, MarshalAs(UnmanagedType.LPWStr)]
                                                             string typelib);

        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        [return: MarshalAs(UnmanagedType.BStr)]
        public extern static string QueryPathOfRegTypeLib(ref Guid guid, short majorVersion, short minorVersion, int lcid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\mshtmlhost.cs ===
//------------------------------------------------------------------------------
// <copyright file="MSHTMLHost.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// MSHTMLHost.cs
//
// 12/17/98: Created: NikhilKo
//

namespace System.Web.UI.Design.Util {
    using System.Runtime.Serialization.Formatters;
    
    using System.Runtime.InteropServices;
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using System.Design;
    
    using Microsoft.Win32;    
    using System.Windows.Forms;

    /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="MSHTMLHost"]/*' />
    /// <devdoc>
    ///    Control that hosts a Trident DocObject.
    /// </devdoc>
    /// <internalonly/>
    // TODO: Change the interface wrappers to return an HRESULT instead of throwing
    //    exceptions for E_NOTIMPL
    //
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class MSHTMLHost : Control {
        private TridentSite tridentSite;

        public MSHTMLHost() : base() {
        }

        public NativeMethods.IHTMLDocument2 GetDocument() {
            Debug.Assert(tridentSite != null,
                         "Cannot call getDocument before calling createTrident");

            return tridentSite.GetDocument();
        }

        protected override CreateParams CreateParams {
             get {
                CreateParams cp = base.CreateParams;

                cp.ExStyle |= NativeMethods.WS_EX_STATICEDGE;
                return cp;
            }
        }

        public bool CreateTrident() {
            Debug.Assert(Handle != IntPtr.Zero,
                         "MSHTMLHost must first be created before createTrident is called");

            try {
                tridentSite = new TridentSite(this);
            }
            catch (Exception e) {
                Debug.WriteLine("Exception caught in MSHTMLHost::CreateTrident\n\t" + e.ToString());
                return false;
            }
            return true;
        }

        public void CloseTrident() {
            if (tridentSite != null) {
                tridentSite.Close();
                tridentSite = null;
            }
        }

        public void ActivateTrident() {
            Debug.Assert(tridentSite != null,
                         "cannot call activateTrident before calling createTrident");

            tridentSite.Activate();
        }
    }


    /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite"]/*' />
    /// <devdoc>
    ///    Implements the client site for Trident DocObject
    /// </devdoc>
    [ClassInterface(ClassInterfaceType.None)]
    internal class TridentSite : NativeMethods.IOleClientSite, NativeMethods.IOleDocumentSite, NativeMethods.IOleInPlaceSite, NativeMethods.IOleInPlaceFrame, NativeMethods.IDocHostUIHandler {

        protected Control parentControl;
        protected NativeMethods.IOleDocumentView tridentView;
        protected NativeMethods.IOleObject tridentOleObject;
        protected NativeMethods.IHTMLDocument2 tridentDocument;

        protected EventHandler resizeHandler;

        public TridentSite(Control parent) {
            Debug.Assert((parent != null) && (parent.Handle != IntPtr.Zero),
                         "Invalid control passed in as parent of Trident window");

            parentControl = parent;
            resizeHandler = new EventHandler(this.OnParentResize);
            parentControl.Resize += resizeHandler;

            CreateDocument();
        }

        public void Close() {
            parentControl.Resize -= resizeHandler;
            CloseDocument();
        }

        public NativeMethods.IHTMLDocument2 GetDocument() {
            return tridentDocument;
        }

        public void Activate() {
            ActivateDocument();
        }

        protected virtual void OnParentResize(object src, EventArgs e) {
            if (tridentView != null) {
                NativeMethods.COMRECT r = new NativeMethods.COMRECT();

                NativeMethods.GetClientRect(parentControl.Handle, r);
                tridentView.SetRect(r);
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleClientSite Implementation

        public virtual void SaveObject() {
        }

        public virtual object GetMoniker(int dwAssign, int dwWhichMoniker) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual int GetContainer(out NativeMethods.IOleContainer ppContainer) {
            ppContainer = null;
            return NativeMethods.E_NOINTERFACE;
        }

        public virtual void ShowObject() {
        }

        public virtual void OnShowWindow(int fShow) {
        }

        public virtual void RequestNewObjectLayout() {
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleDocumentSite Implementation

        public virtual int ActivateMe(NativeMethods.IOleDocumentView pViewToActivate) {
            Debug.Assert(pViewToActivate != null,
                         "Expected the view to be non-null");
            if (pViewToActivate == null)
                return NativeMethods.E_INVALIDARG;

            NativeMethods.COMRECT r = new NativeMethods.COMRECT();

            NativeMethods.GetClientRect(parentControl.Handle, r);

            tridentView = pViewToActivate;
            tridentView.SetInPlaceSite((NativeMethods.IOleInPlaceSite)this);
            tridentView.UIActivate(1);
            tridentView.SetRect(r);
            tridentView.Show(1);

            return NativeMethods.S_OK;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleInPlaceSite Implementation

        public virtual IntPtr GetWindow() {
            return parentControl.Handle;
        }

        public virtual void ContextSensitiveHelp(int fEnterMode) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual int CanInPlaceActivate() {
            return NativeMethods.S_OK;
        }

        public virtual void OnInPlaceActivate() {
        }

        public virtual void OnUIActivate() {
        }

        public virtual void GetWindowContext(out NativeMethods.IOleInPlaceFrame ppFrame, out NativeMethods.IOleInPlaceUIWindow ppDoc, NativeMethods.COMRECT lprcPosRect, NativeMethods.COMRECT lprcClipRect, NativeMethods.tagOIFI lpFrameInfo) {

            ppFrame = (NativeMethods.IOleInPlaceFrame)this;
            ppDoc = null;

            NativeMethods.GetClientRect(parentControl.Handle, lprcPosRect);
            NativeMethods.GetClientRect(parentControl.Handle, lprcClipRect);

            lpFrameInfo.cb = System.Runtime.InteropServices.Marshal.SizeOf(typeof(NativeMethods.tagOIFI));
            lpFrameInfo.fMDIApp = 0;
            lpFrameInfo.hwndFrame = parentControl.Handle;
            lpFrameInfo.hAccel = IntPtr.Zero;
            lpFrameInfo.cAccelEntries = 0;
        }

        public virtual int Scroll(NativeMethods.tagSIZE scrollExtant) {
            return(NativeMethods.E_NOTIMPL);
        }

        public virtual void OnUIDeactivate(int fUndoable) {
            // NOTE, nikhilko, 7/99: Don't return E_NOTIMPL. Somehow doing nothing and returning S_OK
            //    fixes trident hosting in Win2000.
        }

        public virtual void OnInPlaceDeactivate() {
        }

        public virtual void DiscardUndoState() {
            throw new COMException("Not implemented", NativeMethods.E_NOTIMPL);
        }

        public virtual void DeactivateAndUndo() {
        }

        public virtual int OnPosRectChange(NativeMethods.COMRECT lprcPosRect) {
            return NativeMethods.S_OK;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleInPlaceFrame Implementation

        public virtual void GetBorder(NativeMethods.COMRECT lprectBorder) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void RequestBorderSpace(NativeMethods.COMRECT pborderwidths) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetBorderSpace(NativeMethods.COMRECT pborderwidths) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetActiveObject(NativeMethods.IOleInPlaceActiveObject pActiveObject, string pszObjName) {
            // NOTE, nikhilko, 7/99: Don't return E_NOTIMPL. Somehow doing nothing and returning S_OK
            //    fixes trident hosting in Win2000.
            // throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void InsertMenus(IntPtr hmenuShared, object lpMenuWidths) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetMenu(IntPtr hmenuShared, IntPtr holemenu, IntPtr hwndActiveObject) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void RemoveMenus(IntPtr hmenuShared) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetStatusText(string pszStatusText) {
        }

        public virtual void EnableModeless(int fEnable) {
        }

        public virtual int TranslateAccelerator(ref NativeMethods.MSG lpmsg, short wID) {
            return NativeMethods.S_FALSE;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IDocHostUIHandler Implementation

        public virtual int ShowContextMenu(int dwID, NativeMethods.POINT pt, object pcmdtReserved, object pdispReserved) {
            return NativeMethods.S_OK;
        }

        public virtual int GetHostInfo(NativeMethods.DOCHOSTUIINFO info) {
            info.dwDoubleClick = NativeMethods.DOCHOSTUIDBLCLICK.DEFAULT;
            info.dwFlags = NativeMethods.DOCHOSTUIFLAG.FLAT_SCROLLBAR |
                           NativeMethods.DOCHOSTUIFLAG.NO3DBORDER |
                           NativeMethods.DOCHOSTUIFLAG.DIALOG |
                           NativeMethods.DOCHOSTUIFLAG.DISABLE_SCRIPT_INACTIVE;

            return NativeMethods.S_OK;
        }

        public virtual int EnableModeless(bool fEnable) {
            return NativeMethods.S_OK;
        }

        public virtual int ShowUI(int dwID, NativeMethods.IOleInPlaceActiveObject activeObject, NativeMethods.IOleCommandTarget commandTarget, NativeMethods.IOleInPlaceFrame frame, NativeMethods.IOleInPlaceUIWindow doc) {
            return NativeMethods.S_OK;
        }

        public virtual int HideUI() {
            return NativeMethods.S_OK;
        }

        public virtual int UpdateUI() {
            return NativeMethods.S_OK;
        }

        public virtual int OnDocWindowActivate(bool fActivate) {
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int OnFrameWindowActivate(bool fActivate) {
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int ResizeBorder(NativeMethods.COMRECT rect, NativeMethods.IOleInPlaceUIWindow doc, bool fFrameWindow) {
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int GetOptionKeyPath(string[] pbstrKey, int dw) {
            pbstrKey[0] = null;
            return NativeMethods.S_OK;
        }

        public virtual int GetDropTarget(NativeMethods.IOleDropTarget pDropTarget, out NativeMethods.IOleDropTarget ppDropTarget) {
            ppDropTarget = null;
            return NativeMethods.S_FALSE;
        }

        public virtual int GetExternal(out object ppDispatch) {
            ppDispatch = null;
            return NativeMethods.S_OK;
        }

        public virtual int TranslateAccelerator(ref NativeMethods.MSG msg, ref Guid group, int nCmdID) {
            return NativeMethods.S_OK;
        }

        public virtual int TranslateUrl(int dwTranslate, string strUrlIn, out string pstrUrlOut) {
            pstrUrlOut = null;
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int FilterDataObject(NativeMethods.IOleDataObject pDO, out NativeMethods.IOleDataObject ppDORet) {
            ppDORet = null;
            return NativeMethods.S_OK;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Implementation

        /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite.CreateDocument"]/*' />
        /// <devdoc>
        ///     Creates a new instance of mshtml and initializes it as a new document
        ///     using its IPersistStreamInit.
        /// </devdoc>
        protected void CreateDocument() {

            try {
                // Create an instance of Trident
                tridentDocument = (NativeMethods.IHTMLDocument2)new NativeMethods.HTMLDocument();
                tridentOleObject = (NativeMethods.IOleObject)tridentDocument;

                // Initialize its client site
                tridentOleObject.SetClientSite((NativeMethods.IOleClientSite)this);

                // Initialize it
                NativeMethods.IPersistStreamInit psi = (NativeMethods.IPersistStreamInit)tridentDocument;
                psi.InitNew();
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
                throw e;
            }
        }

        /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite.CloseDocument"]/*' />
        /// <devdoc>
        ///     Closes the mshtml instance by deactivating and releasing it.
        /// </devdoc>
        protected void CloseDocument() {
            try {
                if (tridentDocument != null) {
                    tridentView = null;
                    tridentDocument = null;

                    tridentOleObject.Close(NativeMethods.OLECLOSE_NOSAVE);
                    tridentOleObject.SetClientSite(null);
                    tridentOleObject = null;
                }
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
            }
        }

        /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite.ActivateDocument"]/*' />
        /// <devdoc>
        ///     Activates the mshtml instance
        /// </devdoc>
        protected void ActivateDocument() {
            Debug.Assert(tridentOleObject != null,
                         "How'd we get here when trident is null!");

            try {
                NativeMethods.COMRECT r = new NativeMethods.COMRECT();

                NativeMethods.GetClientRect(parentControl.Handle, r);
                tridentOleObject.DoVerb(NativeMethods.OLEIVERB_UIACTIVATE, IntPtr.Zero, (NativeMethods.IOleClientSite)this, 0, parentControl.Handle, r);
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\tagvsusercontextattributeusage.cs ===
//------------------------------------------------------------------------------
// <copyright file="tagVsUserContextAttributeUsage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// tagVsUserContextAttributeUsage.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VSDesigner.Interop {
    

    using System.Diagnostics;
    using System;
    
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    public enum tagVsUserContextAttributeUsage {

        VSUC_Usage_Filter = 0x00, 
        VSUC_Usage_Lookup = 0x1,
        VSUC_Usage_LookupF1 = 0x2

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\util.cs ===
//------------------------------------------------------------------------------
// <copyright file="Util.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VSDesigner.Interop {

    using System;
    using System.Runtime.InteropServices;
    /// <summary>
    ///     @security(checkClassLinking=on)
    /// </summary>
    [ComVisible(false), 
        System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class Util {
        public static int MAKELONG(int low, int high) {
            return (high << 16) | (low & 0xffff);
        }

        public static int MAKELPARAM(int low, int high) {
            return (high << 16) | (low & 0xffff);
        }

        public static int HIWORD(int n) {
            return (n >> 16) & 0xffff;
        }

        public static int LOWORD(int n) {
            return n & 0xffff;
        }

        public static int SignedHIWORD(int n) {
            int i = (int)(short)((n >> 16) & 0xffff);

            i = i << 16;
            i = i >> 16;

            return i;
        }

        public static int SignedLOWORD(int n) {
            int i = (int)(short)(n & 0xFFFF);

            i = i << 16;
            i = i >> 16;

            return i;
        }

        /// <summary>
        ///     Computes the string size that should be passed to a typical Win32 call.
        ///     This will be the character count under NT, and the ubyte count for Win95.
        /// </summary>
        /// <param name='s'>
        ///     The string to get the size of.
        /// </param>
        /// <returns>
        ///     the count of characters or bytes, depending on what the jdirect
        ///     call wants
        /// </returns>
        public static int GetJDirectStringLength(String s) {
            if (s == null) {
                return 0;
            }

            if (System.Runtime.InteropServices.Marshal.SystemDefaultCharSize == 2) {
                return s.Length;
            }
            else {
                if (s.Length == 0) {
                    return 0;
                }
                if (s.IndexOf('\0') > -1) {
                    return GetEmbededNullStringLengthAnsi(s);
                }
                else {
                    return lstrlen(s);
                }
            }
        }

        private static int GetEmbededNullStringLengthAnsi(String s) {
            int n = s.IndexOf('\0');
            if (n > -1) {
                String left = s.Substring(0, n);
                String right = s.Substring(n+1);
                return GetJDirectStringLength(left) + GetEmbededNullStringLengthAnsi(right) + 1;
            }
            else {
                return GetJDirectStringLength(s);
            }
        }

        [DllImport("kernel32", CharSet=CharSet.Auto)]
        private static extern int lstrlen(String s);

        [DllImport("user32", CharSet=CharSet.Auto)]
        internal static extern int RegisterWindowMessage(String msg);

        /// <summary>
        ///     Computes the string size that should be passed to a typical Win32 call.
        ///     This will be the character count under NT, and the ubyte count for Win95.
        /// </summary>
        /// <param name='s'>
        ///     The string to get the size of.
        /// </param>
        /// <returns>
        ///     the count of characters or bytes, depending on what the pinvoke
        ///     call wants
        /// </returns>
        public static int GetPInvokeStringLength(String s) {
            if (s == null) {
                return 0;
            }

            if (System.Runtime.InteropServices.Marshal.SystemDefaultCharSize == 2) {
                return s.Length;
            }
            else {
                if (s.Length == 0) {
                    return 0;
                }
                if (s.IndexOf('\0') > -1) {
                    return GetEmbededNullStringLengthAnsi(s);
                }
                else {
                    return lstrlen(s);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\_tagolecmd.cs ===
//------------------------------------------------------------------------------
// <copyright file="_tagOLECMD.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// _tagOLECMD.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace Microsoft.VSDesigner.Interop {
    using System;
    using System.Runtime.InteropServices;

    // C#r: noAutoOffset
    [
    System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential),
    CLSCompliantAttribute(false)
    ]
    internal sealed class  _tagOLECMD {

        [MarshalAs(UnmanagedType.U4)]
        public   int cmdID;
        [MarshalAs(UnmanagedType.U4)]
        public   int cmdf;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\converters\defaultcommandconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DefaultCommandConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Converters
{
    using System.Diagnostics;
    using System.Collections;
    using System.ComponentModel;
    using System.Web.UI.MobileControls;

    /// <summary>
    ///    <para>
    ///       Can filter and retrieve several types of values from controls.
    ///    </para>
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DefaultCommandConverter: StringConverter
    {
        private Object[] GetCommands(ObjectList objectList)
        {
            ObjectListCommandCollection commands = objectList.Commands;
            if (commands.Count == 0)
            {
                return null;
            }

            ArrayList commandList = new ArrayList(commands.Count);
            foreach(ObjectListCommand command in commands)
            {
                commandList.Add(command.Name);
            }

            commandList.Sort();
            return commandList.ToArray();
        }

        /// <summary>
        ///    <para>
        ///       Returns a collection of standard values retrieved from the context specified
        ///       by the specified type descriptor.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that specifies the location of the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///       A StandardValuesCollection that represents the standard values collected from
        ///       the specified context.
        ///    </para>
        /// </returns>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
        {
            if (context == null || context.Instance == null)
            {
                return null;
            }

            ObjectList objectList = null;
            if (context.Instance is IDeviceSpecificChoiceDesigner)
            {
                objectList = ((IDeviceSpecificChoiceDesigner)context.Instance).UnderlyingObject as ObjectList;
            }
            else if (context.Instance is ObjectList)
            {
                objectList = (ObjectList)context.Instance;
            }
            else
            {
                return null;
            }
            
            Debug.Assert(objectList != null);

            Object [] objValues = GetCommands(objectList);
            if (objValues != null)
            {
                return new StandardValuesCollection(objValues);
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        ///    <para>
        ///       Gets whether
        ///       or not the context specified contains exclusive standard values.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that indicates the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///    <see langword='true'/> if the specified context contains exclusive standard 
        ///       values, otherwise <see langword='false'/>.
        ///    </para>
        /// </returns>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)
        {
            return false;
        }

        /// <summary>
        ///    <para>
        ///       Gets whether or not the specified context contains supported standard
        ///       values.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that indicates the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///    <see langword='true'/> if the specified context conatins supported standard 
        ///       values, otherwise <see langword='false'/>.
        ///    </para>
        /// </returns>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
        {
            if (context.Instance is IComponent) 
            {
                // We only support the dropdown in single-select mode.
                return true;
            }
            return false;
        }        
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\converters\choiceconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ChoiceConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Converters
{
    using System.Diagnostics;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Globalization;
    using System.Reflection;
    using System.Web.UI.Design.MobileControls.Util;
    using System.Web.UI.MobileControls;
    using System.Windows.Forms;

    /// <summary>
    ///    <para>
    ///       Can filter and retrieve several types of values from controls.
    ///    </para>
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class ChoiceConverter: StringConverter
    {
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) 
        {
            if (context != null && context.Instance is Array)
            {
                return value;
            }

            if (value is String) 
            {
                return MatchFilterName((string)value, context);
            }

            return base.ConvertFrom(context, culture, value);
        }

        /// <summary>
        /// </summary>
        protected virtual Object [] GetChoices(Object instance)
        {
            bool defaultAdded = false;
            DeviceSpecific deviceSpecific;

            if (instance is System.Web.UI.MobileControls.StyleSheet)
            {
                StyleSheet ss = (StyleSheet) instance;
                ISite componentSite = ss.Site;
                Debug.Assert(componentSite != null, "Expected the component to be sited.");
                IDesignerHost designerHost = (IDesignerHost) componentSite.GetService(typeof(IDesignerHost));
                Debug.Assert(designerHost != null, "Expected a designer host.");
                Object designer = designerHost.GetDesigner(ss);
                Debug.Assert(designer != null, "Expected a designer for the stylesheet.");
                Debug.Assert(designer is StyleSheetDesigner, "Expected a StyleSheet designer.");
                StyleSheetDesigner ssd = (StyleSheetDesigner) designer;
                Style style = (Style) ssd.CurrentStyle;
                if (null != style)
                {
                    deviceSpecific = style.DeviceSpecific;
                }
                else
                {
                    deviceSpecific = null;
                }
            }
            else if (instance is System.Web.UI.MobileControls.DeviceSpecific)
            {
                deviceSpecific = (DeviceSpecific) instance;
            }
            else if (instance is MobileControl)
            {
                MobileControl mc = (MobileControl) instance;
                deviceSpecific = mc.DeviceSpecific;
            }
            else
            {
                // Simply return null if the instance is not recognizable.
                return null;
            }

            ArrayList returnArray = new ArrayList();

            // entry that corresponds to null CurrentChoice.
            returnArray.Add(SR.GetString(SR.DeviceFilter_NoChoice));

            if (null == deviceSpecific)
            {
                return returnArray.ToArray();
            }

            Debug.Assert(deviceSpecific.Choices != null);
            foreach(DeviceSpecificChoice choice in deviceSpecific.Choices)
            {
                // Choice must have a Name
                if (choice.Filter == String.Empty)
                {
                    if (!defaultAdded)
                    {
                        returnArray.Add(SR.GetString(SR.DeviceFilter_DefaultChoice));
                        defaultAdded = true;
                    }
                }
                else
                {
                    if (!choice.Filter.Equals(SR.GetString(SR.DeviceFilter_NoChoice)))
                    {
                        returnArray.Add(DesignerUtility.ChoiceToUniqueIdentifier(choice));
                    }
                }
            }
            returnArray.Sort();
            return returnArray.ToArray();
        }

        /// <summary>
        ///    <para>
        ///       Returns a collection of standard values retrieved from the context specified
        ///       by the specified type descriptor.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that specifies the location of the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///       A StandardValuesCollection that represents the standard values collected from
        ///       the specified context.
        ///    </para>
        /// </returns>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
        {
            if (context == null || context.Instance == null)
            {
                return null;
            }

            Object [] objValues = GetChoices(context.Instance);
            if (objValues != null)
            {
                return new StandardValuesCollection(objValues);
            }
            else
            {
                return null;
            }            
        }

        /// <summary>
        ///    <para>
        ///       Gets whether
        ///       or not the context specified contains exclusive standard values.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that indicates the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///    <see langword='true'/> if the specified context contains exclusive standard 
        ///       values, otherwise <see langword='false'/>.
        ///    </para>
        /// </returns>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)
        {
            return false;
        }

        /// <summary>
        ///    <para>
        ///       Gets whether or not the specified context contains supported standard
        ///       values.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that indicates the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///    <see langword='true'/> if the specified context conatins supported standard 
        ///       values, otherwise <see langword='false'/>.
        ///    </para>
        /// </returns>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
        {
            return true;
        }

        private String MatchFilterName(String name, ITypeDescriptorContext context) 
        {
            Debug.Assert(name != null, "Expected an actual device filter name to match.");

            // Try a partial match
            //
            String bestMatch = null;
            name = name.ToLower(CultureInfo.InvariantCulture);

            StandardValuesCollection standardValues = GetStandardValues(context);
            if (standardValues == null)
            {
                return null;
            }

            IEnumerator e = standardValues.GetEnumerator();
            while (e.MoveNext()) 
            {
                String filterName = e.Current.ToString().ToLower(CultureInfo.InvariantCulture);
                if (filterName.Equals(name)) 
                {
                    // For an exact match, return immediately
                    //
                    return e.Current.ToString();
                }
                else if (filterName.StartsWith(name)) 
                {
                    if (bestMatch == null || filterName.Length <= bestMatch.Length) 
                    {
                        bestMatch = e.Current.ToString();
                    }
                }
            }
                
            if (bestMatch == null) 
            {
                // no match... use NoChoice
                bestMatch = SR.GetString(SR.DeviceFilter_NoChoice);
            }
            return bestMatch;
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\webcontrolpersister.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebControlPersister.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Web;
    using System.Web.UI;
    using System.Web.UI.HtmlControls;
    using System.Web.UI.WebControls;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Text;
    using AttributeCollection = System.Web.UI.AttributeCollection;

    /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides helper functions used in persisting Controls.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public sealed class ControlPersister {

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.ControlPersister"]/*' />
        /// <devdoc>
        ///    We don't want instances of this class to be created, so mark
        ///    the constructor as private.
        /// </devdoc>
        private ControlPersister() {
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.GetDeclarativeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the delarative type for the
        ///       specified type.
        ///    </para>
        /// </devdoc>
        private static string GetDeclarativeType(Type type, IDesignerHost host) {
            Debug.Assert(host != null, "Need an IDesignerHost to create declarative type names");
            string declarativeType = null;

            if (host != null) {
                IWebFormReferenceManager refMgr =
                    (IWebFormReferenceManager)host.GetService(typeof(IWebFormReferenceManager));
                Debug.Assert(refMgr != null, "Did not get back IWebFormReferenceManager service from host.");

                if (refMgr != null) {
                    string tagPrefix = refMgr.GetTagPrefix(type);
                    if ((tagPrefix != null) && (tagPrefix.Length != 0)) {
                        declarativeType = tagPrefix + ":" + type.Name;
                    }
                }
            }

            if (declarativeType == null) {
                declarativeType = type.FullName;
            }

            return declarativeType;
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistCollectionProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists a collection property.
        ///    </para>
        /// </devdoc>
        private static void PersistCollectionProperty(TextWriter sw, object component, PropertyDescriptor propDesc, PersistenceMode persistMode, IDesignerHost host) {
            Debug.Assert(typeof(ICollection).IsAssignableFrom(propDesc.PropertyType),
                "Invalid collection property : " + propDesc.Name);

            ICollection propValue = (ICollection)propDesc.GetValue(component);
            if ((propValue == null) || (propValue.Count == 0))
                return;

            sw.WriteLine();
            if (persistMode == PersistenceMode.InnerProperty) {
                sw.Write('<');
                sw.Write(propDesc.Name);
                sw.WriteLine('>');
            }

            IEnumerator e = propValue.GetEnumerator();
            while (e.MoveNext()) {
                object collItem = e.Current;
                string itemTypeName = GetDeclarativeType(collItem.GetType(), host);
                
                sw.Write("<");
                sw.Write(itemTypeName);
                PersistAttributes(sw, collItem, String.Empty, null);
                sw.Write(">");
                
                if (collItem is Control) {
                    PersistChildrenAttribute pca =
                        (PersistChildrenAttribute)TypeDescriptor.GetAttributes(collItem.GetType())[typeof(PersistChildrenAttribute)];

                    if (pca.Persist == true) {
                        // asurt 106696: ensure the parent control's visibility is set to true.
                        Control parentControl = (Control)collItem;
                        if (parentControl.HasControls()) {
                            bool oldVisible = parentControl.Visible;
                            try {
                                parentControl.Visible = true;
                                PersistChildControls(sw, parentControl.Controls, host);
                            }
                            finally {
                                parentControl.Visible = oldVisible;
                            }
                        }
                    }
                    else {
                        PersistInnerProperties(sw, collItem, host);
                    }
                }
                else {
                    PersistInnerProperties(sw, collItem, host);
                }
                
                sw.Write("</");
                sw.Write(itemTypeName);
                sw.WriteLine(">");
            }

            if (persistMode == PersistenceMode.InnerProperty) {
                sw.Write("</");
                sw.Write(propDesc.Name);
                sw.WriteLine('>');
            }
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistComplexProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists a complex property.
        ///    </para>
        /// </devdoc>
        private static void PersistComplexProperty(TextWriter sw, object component, PropertyDescriptor propDesc, IDesignerHost host) {
            object propValue = propDesc.GetValue(component);

            if (propValue == null) {
                return;
            }

            StringWriter tagProps = new StringWriter();
            StringWriter innerProps = new StringWriter();

            PersistAttributes(tagProps, propValue, String.Empty, null);
            PersistInnerProperties(innerProps, propValue, host);

            // the rule here is that if a complex property has all its subproperties
            // in the default state, then it itself is in the default state.
            // When this is the case, there shouldn't be any tag properties or inner properties
            if ((tagProps.GetStringBuilder().Length != 0) ||
                (innerProps.GetStringBuilder().Length != 0)) {

                sw.WriteLine();
                sw.Write('<');
                sw.Write(propDesc.Name);
                sw.Write(tagProps.ToString());
                sw.WriteLine(">");

                string innerPropsString = innerProps.ToString();
                sw.Write(innerPropsString);
                if (innerPropsString.Length != 0) {
                    sw.WriteLine();
                }

                sw.Write("</");
                sw.Write(propDesc.Name);
                sw.WriteLine('>');
            }
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistDataBindings"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists the data bindings of the specified control using the specified
        ///       string writer.
        ///    </para>
        /// </devdoc>
        private static void PersistDataBindings(TextWriter sw, Control control) {
            DataBindingCollection bindings = ((IDataBindingsAccessor)control).DataBindings;
            IEnumerator bindingEnum = bindings.GetEnumerator();

            while (bindingEnum.MoveNext()) {
                DataBinding db = (DataBinding)bindingEnum.Current;
                string persistPropName = db.PropertyName.Replace('.', '-');

                sw.Write(" ");
                sw.Write(persistPropName);
                sw.Write("='<%# ");
                sw.Write(HttpUtility.HtmlEncode(db.Expression));
                sw.Write(" %>'");
            }
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistInnerProperties"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a string that can persist the inner properties of a control.
        ///    </para>
        /// </devdoc>
        public static string PersistInnerProperties(object component, IDesignerHost host) {
            StringWriter sw = new StringWriter();

            PersistInnerProperties(sw, component, host);
            return sw.ToString();
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistInnerProperties1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists the inner properties of the control.
        ///    </para>
        /// </devdoc>
        public static void PersistInnerProperties(TextWriter sw, object component, IDesignerHost host) {
            PropertyDescriptorCollection propDescs = TypeDescriptor.GetProperties(component);

            for (int i = 0; i < propDescs.Count; i++) {
                // Only deal with inner attributes that need to be persisted
                if (propDescs[i].SerializationVisibility == DesignerSerializationVisibility.Hidden)
                    continue;

                PersistenceModeAttribute persistenceMode = (PersistenceModeAttribute)propDescs[i].Attributes[typeof(PersistenceModeAttribute)];
                if (persistenceMode.Mode == PersistenceMode.Attribute) {
                    continue;
                }
                    
                if (propDescs[i].PropertyType == typeof(string)) {
                    // String based property...
                    
                    DataBindingCollection dataBindings = null;
                    if (component is IDataBindingsAccessor) {
                        dataBindings = ((IDataBindingsAccessor)component).DataBindings;
                    }
                    if (dataBindings == null || dataBindings[propDescs[i].Name] == null) {
                        PersistenceMode mode = persistenceMode.Mode;
                        if ((mode == PersistenceMode.InnerDefaultProperty) ||
                            (mode == PersistenceMode.EncodedInnerDefaultProperty)) {
                            PersistStringProperty(sw, component, propDescs[i], mode);
                        }
                        else {
                            Debug.Fail("Cannot persist inner string property marked with PersistenceMode.InnerProperty");
                        }
                    }
                }
                else if (typeof(ICollection).IsAssignableFrom(propDescs[i].PropertyType)) {
                    // Collection based property...
                    if ((persistenceMode.Mode == PersistenceMode.InnerProperty) ||
                        (persistenceMode.Mode == PersistenceMode.InnerDefaultProperty)) {
                        PersistCollectionProperty(sw, component, propDescs[i], persistenceMode.Mode, host);
                    }
                    else {
                        Debug.Fail("Cannot persist collection property " + propDescs[i].Name + " not marked with PersistenceMode.InnerProperty or PersistenceMode.InnerDefaultProperty");
                    }
                }
                else if (typeof(ITemplate).IsAssignableFrom(propDescs[i].PropertyType)) {
                    // Template based property...
                    if (persistenceMode.Mode == PersistenceMode.InnerProperty) {
                        PersistTemplateProperty(sw, component, propDescs[i]);
                    }
                    else {
                        Debug.Fail("Cannot persist template property " + propDescs[i].Name + " not marked with PersistenceMode.InnerProperty");
                    }
                }
                else {
                    // Other complex property...
                    if (persistenceMode.Mode == PersistenceMode.InnerProperty) {
                        PersistComplexProperty(sw, component, propDescs[i], host);
                    }
                    else {
                        Debug.Fail("Cannot persist complex property " + propDescs[i].Name + " not marked with PersistenceMode.InnerProperty");
                    }
                }
            }
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistStringProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists the properties of a
        ///       string.
        ///    </para>
        /// </devdoc>
        private static void PersistStringProperty(TextWriter sw, object component, PropertyDescriptor propDesc, PersistenceMode mode) {
            Debug.Assert(propDesc.PropertyType == typeof(string),
                "Invalid string property : " + propDesc.Name);
            Debug.Assert((mode == PersistenceMode.InnerDefaultProperty) || (mode == PersistenceMode.EncodedInnerDefaultProperty),
                         "Inner string properties must be marked as either InnerDefaultProperty or EncodedInnerDefaultProperty");

            object propValue = propDesc.GetValue(component);
            if (propValue == null) {
                return;
            }

            if (mode == PersistenceMode.InnerDefaultProperty) {
                sw.Write((string)propValue);
            }
            else {
                HttpUtility.HtmlEncode((string)propValue, sw);
            }
        }
        
        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists the properties of a tag.
        ///    </para>
        /// </devdoc>
        private static void PersistAttributes(TextWriter sw, object component, string prefix, PropertyDescriptor propDesc) {
            PropertyDescriptorCollection properties;
            string persistPrefix = String.Empty;
            object value = component;

            if (propDesc != null) {
                value = propDesc.GetValue(component);
                properties = TypeDescriptor.GetProperties(propDesc.PropertyType,
                                                               new Attribute[] {
                                                                   PersistenceModeAttribute.Attribute
                                                               });
            }
            else {
                properties = TypeDescriptor.GetProperties(component,
                                                               new Attribute[] {
                                                                   PersistenceModeAttribute.Attribute
                                                               });
            }

            if (value == null)
                return;

            if (prefix.Length != 0)
                persistPrefix = prefix + "-";

            DataBindingCollection dataBindings = null;
            bool isControl = (component is Control);
            if ((component is IDataBindingsAccessor))
                dataBindings = ((IDataBindingsAccessor)component).DataBindings;

            for (int i = 0; i < properties.Count; i++) {
            
                // Skip properties that are hidden to the serializer
                if (properties[i].SerializationVisibility == DesignerSerializationVisibility.Hidden) {
                    continue;
                }

                // Skip design-time only properties such as DefaultModifiers and Name
                DesignOnlyAttribute doAttr = (DesignOnlyAttribute)properties[i].Attributes[typeof(DesignOnlyAttribute)];
                if ((doAttr != null) && doAttr.IsDesignOnly) {
                    continue;
                }
                
                string propName = properties[i].Name;
                Type propType = properties[i].PropertyType;
                
                object obj = properties[i].GetValue(value);
                if (obj == null)
                    continue;

                DefaultValueAttribute defValAttr =
                    (DefaultValueAttribute)properties[i].Attributes[typeof(DefaultValueAttribute)];
                if ((defValAttr != null) && (obj.Equals(defValAttr.Value)))
                    continue;

                string persistName = propName;
                if (prefix.Length != 0)
                    persistName = persistPrefix + persistName;

                PropertyDescriptorCollection subProps = null;
                if (properties[i].SerializationVisibility == DesignerSerializationVisibility.Content) {
                    subProps = TypeDescriptor.GetProperties(propType);
                }
                if ((subProps == null) || (subProps.Count == 0)) {
                    string persistValue = null;

                    // TODO: Use consts or have DataBinding store both OM name and persist name
                    DataBinding db = null;
                    if (dataBindings != null)
                        db = dataBindings[persistName.Replace('.', '-')];
                    
                    if (db == null) {
                        if (propType.IsEnum) {
                            persistValue = Enum.Format(propType, obj, "G");
                        }
                        else if (propType == typeof(string)) {
                            persistValue = HttpUtility.HtmlEncode(obj.ToString());
                        }
                        else {
                            TypeConverter converter = properties[i].Converter;
                            if (converter != null) {
                                persistValue = converter.ConvertToInvariantString(null, obj);
                            }
                            else {
                                persistValue = obj.ToString();
                            }
                            persistValue = HttpUtility.HtmlEncode(persistValue);
                        }

                        if ((persistValue == null) ||
                            (persistValue.Equals("NotSet")) ||
                            (propType.IsArray && (persistValue.Length == 0)))
                            continue;

                        sw.Write(" ");
                        sw.Write(persistName);
                        sw.Write("=\"");

                        sw.Write(persistValue);
                        sw.Write("\"");
                    }
                }
                else {
                    // there are sub properties, don't persist this object, but
                    // recursively persist the subproperties.
                    PersistAttributes(sw, obj, persistName, null);
                }
            }

            // Persist all the databindings on this control
            if (isControl) {
                PersistDataBindings(sw, (Control)component);

                AttributeCollection expandos = null;
                if (component is WebControl) {
                    expandos = ((WebControl)component).Attributes;
                }
                else if (component is HtmlControl) {
                    expandos = ((HtmlControl)component).Attributes;
                }
                else if (component is UserControl) {
                    expandos = ((UserControl)component).Attributes;
                }

                if (expandos != null) {
                    foreach (string key in expandos.Keys) {
                        sw.Write(" ");
                        sw.Write(key);
                        sw.Write("=\"");
                        sw.Write(expandos[key]);
                        sw.Write("\"");
                    }
                }
            }
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistTemplateProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists a template property including the specified persistance mode,
        ///       string writer and property descriptor.
        ///    </para>
        /// </devdoc>
        private static void PersistTemplateProperty(TextWriter sw, object component, PropertyDescriptor propDesc) {
            Debug.Assert(typeof(ITemplate).IsAssignableFrom(propDesc.PropertyType),
                         "Invalid template property : " + propDesc.Name);

            ITemplate template = (ITemplate)propDesc.GetValue(component);
            if (template == null) {
                return;
            }

            string templateContent;
            
            Debug.Assert(template is TemplateBuilder, "Unexpected ITemplate implementation.");
            if (template is TemplateBuilder) {
                templateContent = ((TemplateBuilder)template).Text;
            }
            else {
                templateContent = String.Empty;
            }

            sw.WriteLine();
            sw.Write('<');
            sw.Write(propDesc.Name);
            sw.Write('>');
            if (!templateContent.StartsWith("\r\n")) {
                sw.WriteLine();
            }
            
            sw.Write(templateContent);

            if (!templateContent.EndsWith("\r\n")) {
                sw.WriteLine();
            }
            sw.Write("</");
            sw.Write(propDesc.Name);
            sw.WriteLine('>');
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistControl"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a string that can
        ///       persist a control.
        ///    </para>
        /// </devdoc>
        public static string PersistControl(Control control) {
            StringWriter sw = new StringWriter();

            PersistControl(sw, control);
            return sw.ToString();
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistControl1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a string that can
        ///       persist a control.
        ///    </para>
        /// </devdoc>
        public static string PersistControl(Control control, IDesignerHost host) {
            StringWriter sw = new StringWriter();

            PersistControl(sw, control, host);
            return sw.ToString();
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistControl2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists a control using the
        ///       specified string writer.
        ///    </para>
        /// </devdoc>
        public static void PersistControl(TextWriter sw, Control control) {
            if (control is LiteralControl) {
                PersistLiteralControl(sw, (LiteralControl)control);
                return;
            }
            if (control is DesignerDataBoundLiteralControl) {
                PersistDataBoundLiteralControl(sw, (DesignerDataBoundLiteralControl)control);
                return;
            }

            ISite site = control.Site;
            if (site == null) {
                IComponent baseComponent = (IComponent)control.Page;
                Debug.Assert(baseComponent != null, "Control does not have its Page set!");
                if (baseComponent != null) {
                    site = baseComponent.Site;
                }
            }

            IDesignerHost host = null;
            if (site != null) {
                host = (IDesignerHost)site.GetService(typeof(IDesignerHost));
            }

            Debug.Assert(host != null, "Did not get a valid IDesignerHost reference. Expect persistence problems!");

            PersistControl(sw, control, host);
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistControl3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists a control using the
        ///       specified string writer.
        ///    </para>
        /// </devdoc>
        public static void PersistControl(TextWriter sw, Control control, IDesignerHost host) {
            // Literals and DataBoundLiterals must be handled specially, since they
            // don't have a tag around them
            if (control is LiteralControl) {
                PersistLiteralControl(sw, (LiteralControl)control);
                return;
            }
            if (control is DesignerDataBoundLiteralControl) {
                PersistDataBoundLiteralControl(sw, (DesignerDataBoundLiteralControl)control);
                return;
            }

            Debug.Assert(host != null, "Did not get a valid IDesignerHost reference. Expect persistence problems!");

            string tagName = null;
            bool isUserControl = false;

            if (control is HtmlControl) {
                tagName = ((HtmlControl)control).TagName;
            }
            else if (control is UserControl) {
                tagName = ((IUserControlDesignerAccessor)control).TagName;
                Debug.Assert((tagName != null) && (tagName.Length != 0));
                
                if (tagName.Length == 0) {
                    // not enough information to go any further... no options, other than to throw this control out
                    return;
                }
                
                isUserControl = true;
            }
            else {
                tagName = GetDeclarativeType(control.GetType(), host);
            }

            sw.Write('<');
            sw.Write(tagName);
            sw.Write(" runat=\"server\"");
            PersistAttributes(sw, control, String.Empty, null);
            sw.Write('>');

            if (isUserControl == false) {
                PersistChildrenAttribute pca =
                    (PersistChildrenAttribute)TypeDescriptor.GetAttributes(control.GetType())[typeof(PersistChildrenAttribute)];

                if (pca.Persist == true) {
                    if (control.HasControls()) {
                        // asurt 106696: Ensure parent control's visibility is true.
                        bool oldVisible = control.Visible;
                        try {
                            control.Visible = true;
                            PersistChildControls(sw, control.Controls, host);
                        }
                        finally {
                            control.Visible = oldVisible;
                        }
                    }
                }
                else {
                    // controls marked with LiteralContent == true shouldn't have
                    // children in their persisted form. They only build children
                    // collections at runtime.

                    PersistInnerProperties(sw, control, host);
                }
            }
            else {
                string innerText = ((IUserControlDesignerAccessor)control).InnerText;
                if ((innerText != null) && (innerText.Length != 0)) {
                    sw.Write(innerText);
                }
            }

            sw.Write("</");
            sw.Write(tagName);
            sw.WriteLine('>');
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistChildControls"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists the child controls of
        ///       the control using the specified string writer.
        ///    </para>
        /// </devdoc>
        private static void PersistChildControls(TextWriter sw, ControlCollection controls, IDesignerHost host) {
            int children = controls.Count;
  
            for (int i = 0; i < children; i++) {
                PersistControl(sw, controls[i], host);
            }
        }

        private static void PersistDataBoundLiteralControl(TextWriter sw, DesignerDataBoundLiteralControl control) {
            Debug.Assert(((IDataBindingsAccessor)control).HasDataBindings == true);

            DataBindingCollection bindings = ((IDataBindingsAccessor)control).DataBindings;
            DataBinding textBinding = bindings["Text"];
            Debug.Assert(textBinding != null, "Did not get a Text databinding from DesignerDataBoundLiteralControl");
            
            if (textBinding != null) {
                sw.Write("<%# ");
                sw.Write(textBinding.Expression);
                sw.Write(" %>");
            }
        }

        private static void PersistLiteralControl(TextWriter sw, LiteralControl control) {
            Debug.Assert(control.Text != null);
            sw.Write(control.Text);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\converters\datamemberconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataMemberConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Converters
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Web.UI.Design;
    using System.Security.Permissions;

    /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides design-time support for a component's DataMember properties.
    ///    </para>
    /// </devdoc>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DataMemberConverter : TypeConverter 
    {

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.DataMemberConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.DataFieldConverter'/>.
        ///    </para>
        /// </devdoc>
        public DataMemberConverter() 
        {
        }

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this converter can
        ///       convert an object in the given source type to the native type of the converter
        ///       using the context.
        ///    </para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) 
        {
            if (sourceType == typeof(string)) 
            {
                return true;
            }
            return false;
        }

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the given object to the converter's native type.
        ///    </para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) 
        {
            if (value == null) 
            {
                return String.Empty;
            }
            else if (value.GetType() == typeof(string)) 
            {
                return (string)value;
            }
            throw GetConvertFromException(value);
        }

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the fields present within the selected data source if information about them is available.
        ///    </para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) 
        {
            string[] names = null;
            
            if (context != null) 
            {
                IComponent component = context.Instance as IComponent;
                if (component is IDeviceSpecificChoiceDesigner)
                {
                    component = ((IDeviceSpecificChoiceDesigner)component).UnderlyingControl;
                }

                if (component != null) 
                {
                    ISite componentSite = component.Site;
                    if (componentSite != null) 
                    {
                        IDesignerHost designerHost = (IDesignerHost)componentSite.GetService(typeof(IDesignerHost));
                        if (designerHost != null) 
                        {
                            IDesigner designer = designerHost.GetDesigner(component);

                            if (designer is IDataSourceProvider) 
                            {
                                object dataSource = ((IDataSourceProvider)designer).GetSelectedDataSource();

                                if (dataSource != null) 
                                {
                                    names = DesignTimeData.GetDataMembers(dataSource);
                                }
                            }
                        }
                    }
                }
                
                if (names == null) 
                {
                    names = new string[0];
                }
                Array.Sort(names);
            }
            return new StandardValuesCollection(names);
        }

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the collection of standard values returned from
        ///    <see cref='System.ComponentModel.TypeConverter.GetStandardValues'/> is an exclusive 
        ///       list of possible values, using the specified context.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) 
        {
            return false;
        }

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this object supports a standard set of values
        ///       that can be picked from a list.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) 
        {
            if (context.Instance is IComponent) 
            {
                // We only support the dropdown in single-select mode.
                return true;
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\converters\datafieldconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataFieldConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Converters
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Globalization;
    using System.Web.UI.Design;
    using System.Web.UI.MobileControls;
    using System.Security.Permissions;

    /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides design-time support for a component's data field properties.
    ///    </para>
    /// </devdoc>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DataFieldConverter : TypeConverter 
    {
        private const String _dataMemberPropertyName = "DataMember";
        private const String _dataSourcePropertyName = "DataSource";

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.DataFieldConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.DataFieldConverter'/>.
        ///    </para>
        /// </devdoc>
        public DataFieldConverter() 
        {
        }

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this converter can
        ///       convert an object in the given source type to the native type of the converter
        ///       using the context.
        ///    </para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) 
        {
            if (sourceType == typeof(string)) 
            {
                return true;
            }
            return false;
        }

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the given object to the converter's native type.
        ///    </para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) 
        {
            if (value == null) 
            {
                return String.Empty;
            }
            else if (value.GetType() == typeof(string)) 
            {
                return (string)value;
            }
            throw GetConvertFromException(value);
        }

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the fields present within the selected data source if information about them is available.
        ///    </para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) 
        {
            object[] names = null;
            String dataMember = null;
            bool autoGenerateFields = false;
            bool autoGenerateFieldsSet = false;
            ObjectList objectList = null;
            
            if (context != null) 
            {
                ArrayList list = new ArrayList();

                PropertyDescriptorCollection props = null;

                IComponent component = context.Instance as IComponent;
                if (component is IDeviceSpecificChoiceDesigner)
                {
                    Object owner = ((ChoicePropertyFilter)component).Owner;
                    PropertyDescriptor pd = 
                        ((ICustomTypeDescriptor)component).GetProperties()[_dataMemberPropertyName];
                    Debug.Assert(pd != null, "Cannot get DataMember");

                    if (owner is ObjectList)
                    {
                        autoGenerateFields = ((ObjectList)owner).AutoGenerateFields;
                        autoGenerateFieldsSet = true;
                    }

                    component = ((IDeviceSpecificChoiceDesigner)component).UnderlyingControl;

                    // See if owner already has a DataMember
                    dataMember = (String)pd.GetValue(owner);
                    Debug.Assert(dataMember != null);
                    if (dataMember == String.Empty)
                    {
                        // Get it from underlying object.
                        dataMember = (String)pd.GetValue(component);
                        Debug.Assert(dataMember != null);
                    }
                }

                if (component != null) 
                {
                    objectList = component as ObjectList;

                    if (objectList != null)
                    {
                        foreach(ObjectListField field in objectList.Fields)
                        {
                            list.Add(field.Name);
                        }

                        if (!autoGenerateFieldsSet)
                        {
                            autoGenerateFields = objectList.AutoGenerateFields;
                        }
                    }

                    if (objectList == null || autoGenerateFields)
                    {
                        ISite componentSite = component.Site;
                        if (componentSite != null) 
                        {
                            IDesignerHost designerHost = (IDesignerHost)componentSite.GetService(typeof(IDesignerHost));
                            if (designerHost != null) 
                            {
                                IDesigner designer = designerHost.GetDesigner(component);

                                if (designer is IDataSourceProvider) 
                                {
                                    IEnumerable dataSource = null;
                                    if (dataMember != null && dataMember != String.Empty)
                                    {
                                        DataBindingCollection dataBindings = 
                                            ((HtmlControlDesigner)designer).DataBindings;
                                        DataBinding binding = dataBindings[_dataSourcePropertyName];
                                        if (binding != null)
                                        {
                                            dataSource = 
                                                DesignTimeData.GetSelectedDataSource(
                                                component,
                                                binding.Expression,
                                                dataMember);
                                        }
                                    }
                                    else
                                    {
                                        dataSource = 
                                            ((IDataSourceProvider)designer).GetResolvedSelectedDataSource();
                                    }

                                    if (dataSource != null) 
                                    {
                                        props = DesignTimeData.GetDataFields(dataSource);
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (props != null) 
                {
                    foreach (PropertyDescriptor propDesc in props) 
                    {
                        list.Add(propDesc.Name);
                    }
                }

                names = list.ToArray();
                Array.Sort(names);
            }
            return new StandardValuesCollection(names);
        }

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the collection of standard values returned from
        ///    <see cref='System.ComponentModel.TypeConverter.GetStandardValues'/> is an exclusive 
        ///       list of possible values, using the specified context.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) 
        {
            return false;
        }

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this object supports a standard set of values
        ///       that can be picked from a list.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) 
        {
            if (context.Instance is IComponent) 
            {
                // We only support the dropdown in single-select mode.
                return true;
            }
            return false;
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\converters\stylereferenceconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="StyleReferenceConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Converters
{
    using System.Diagnostics;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel;
    using System.Web.UI.MobileControls;
    using System.Web.UI.Design.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Util;

    /// <summary>
    ///    <para>
    ///       Can filter and retrieve several types of values from controls.
    ///    </para>
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class StyleReferenceConverter: StringConverter
    {
        protected virtual Object [] GetStyles(Object instance)
        {
            StyleSheet styleSheet = null;
            Style instanceStyle = null;

            // Remember, ChoicePropertyFilter is a MobileControl, so we must
            // check for ChoicePropertyFilter first...
            if (instance is IDeviceSpecificChoiceDesigner)
            {
                instance = ((IDeviceSpecificChoiceDesigner)instance).UnderlyingObject;
            }
            
            if (instance is System.Web.UI.MobileControls.Style)
            {
                instanceStyle = (Style) instance;
                if (instanceStyle.Control is StyleSheet)
                {
                    styleSheet = (StyleSheet) instanceStyle.Control;
                }
                else if ((instanceStyle.Control is Form && instanceStyle is PagerStyle) ||
                    (instanceStyle.Control is ObjectList))
                {
                    if (instanceStyle.Control.MobilePage != null)
                    {
                        styleSheet = instanceStyle.Control.MobilePage.StyleSheet;
                    }
                    else
                    {
                        return null;
                    }
                }
                else
                {
                    Debug.Fail("Unsupported objects passed in");
                }
            }
            else if (instance is System.Web.UI.MobileControls.MobileControl)
            {
                MobileControl control = (MobileControl)instance;
                if (control.MobilePage == null)
                {
                    return null;
                }
                styleSheet = control.MobilePage.StyleSheet;
            }
            else if (instance is Array)
            {
                Array array = (Array)instance;
                Debug.Assert(array.Length > 0);

                return GetStyles(array.GetValue(0));
            }
            else
            {
                Debug.Fail("Unsupported type passed in");
                return null;
            }
            Debug.Assert(null != styleSheet);

            ICollection styles = styleSheet.Styles;
            ArrayList styleArray = new ArrayList();
            foreach (String key in styles)
            {
                System.Web.UI.MobileControls.Style style = styleSheet[key];
                if (style.Name != null && style.Name.Length > 0)
                {
                    if (null == instanceStyle || 0 != String.Compare(instanceStyle.Name, style.Name, false, CultureInfo.InvariantCulture))
                    {
                        styleArray.Add(style.Name);
                    }
                }
            }

            if (styleSheet == StyleSheet.Default)
            {
                styleArray.Sort();
                return styleArray.ToArray();
            }

            styles = StyleSheet.Default.Styles;
            foreach (String key in styles)
            {
                System.Web.UI.MobileControls.Style style = StyleSheet.Default[key];
                if (style.Name != null && style.Name.Length > 0)
                {
                    if (null == instanceStyle || 0 != String.Compare(instanceStyle.Name, style.Name, false, CultureInfo.InvariantCulture))
                    {
                        styleArray.Add(style.Name);
                    }
                }
            }

            if (styleArray.Count <= 1)
            {
                return styleArray.ToArray();
            }

            styleArray.Sort();
            String preID = ((String)styleArray[0]).ToLower(CultureInfo.InvariantCulture);

            int i = 1;
            while (i < styleArray.Count)
            {
                if (((String)styleArray[i]).ToLower(CultureInfo.InvariantCulture).Equals(preID))
                {
                    styleArray.RemoveAt(i);
                }
                else
                {
                    preID = ((String)styleArray[i]).ToLower(CultureInfo.InvariantCulture);
                    i++;
                }
            }

            return styleArray.ToArray();
        }

        /// <summary>
        ///    <para>
        ///       Returns a collection of standard values retrieved from the context specified
        ///       by the specified type descriptor.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that specifies the location of the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///       A StandardValuesCollection that represents the standard values collected from
        ///       the specified context.
        ///    </para>
        /// </returns>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
        {
            if (context == null || context.Instance == null)
            {
                return null;
            }

            Object [] objValues = GetStyles(context.Instance);
            if (objValues != null)
            {
                return new StandardValuesCollection(objValues);
            }
            else
            {
                return null;
            }            
        }

        /// <summary>
        ///    <para>
        ///       Gets whether
        ///       or not the context specified contains exclusive standard values.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that indicates the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///    <see langword='true'/> if the specified context contains exclusive standard 
        ///       values, otherwise <see langword='false'/>.
        ///    </para>
        /// </returns>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)
        {
            return false;
        }

        /// <summary>
        ///    <para>
        ///       Gets whether or not the specified context contains supported standard
        ///       values.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that indicates the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///    <see langword='true'/> if the specified context conatins supported standard 
        ///       values, otherwise <see langword='false'/>.
        ///    </para>
        /// </returns>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
        {
            return true;
        }        
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\converters\navigateurlconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="NavigateUrlConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Converters
{
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Collections;
    using System.Globalization;
    using System.Web.UI.MobileControls;

    /// <summary>
    ///     Subclass of FormConverter to handle the special case where we want
    ///     to select a form OR a valid URL to navigate to.
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class NavigateUrlConverter : FormConverter
    {
        protected override ArrayList GetControls(ITypeDescriptorContext context)
        {
            ArrayList formList = base.GetControls(context);

            // We disable the "Select Url..." option in multi-selected case
            if (formList != null && !(context.Instance is Array))
            {
                formList.Insert(0, SR.GetString(SR.NavigateUrlConverter_SelectURITarget));
            }

            return formList;
        }
        
        protected override String ProcessControlId(String id)
        {
            return "#" + id;
        }
        
        /// <summary>
        ///     url = new value in OnPropertyChanged, we check to see if we need to
        ///           browse for the url.  If not, we just return this value.
        ///     oldUrl = old value of URL, used to initialize URL builder and returned
        ///              if the user cancels.
        /// </summary>
        internal static String GetUrl(IComponent component, String url, String oldUrl)
        {
            if(url == SR.GetString(SR.NavigateUrlConverter_SelectURITarget))
            {
                url = UrlBuilder.BuildUrl(
                    component, 
                    null,
                    oldUrl,
                    SR.GetString(SR.UrlPicker_DefaultCaption),
                    SR.GetString(SR.UrlPicker_DefaultFilter)
                );
                if (url == null)
                {
                    url = oldUrl;
                }
            }
            return url;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\converters\formconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="FormConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Converters
{
    using System.Diagnostics;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Web.UI;
    using System.Web.UI.MobileControls;
    using System.Web.UI.Design.MobileControls.Adapters;

    /// <summary>
    ///    <para>
    ///       Can filter and retrieve several types of values from Style controls.
    ///    </para>
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class FormConverter : StringConverter
    {
        private Form GetContainingForm(MobileControl mc)
        {
            return FindContainer(mc, typeof(Form)) as Form;
        }

        private StyleSheet GetContainingStyleSheet(MobileControl mc)
        {
            return FindContainer(mc, typeof(StyleSheet)) as StyleSheet;
        }

        private Control FindContainer(MobileControl mc, Type containerType)
        {
            for (Control control = mc; control != null; control = control.Parent)
            {
                if (containerType.IsAssignableFrom(control.GetType()))
                {
                    return control;
                }
            }
            return null;
        }

        protected virtual ArrayList GetControls(ITypeDescriptorContext context)
        {
            ArrayList       controlList = new ArrayList();
            MobileControl   control = null;
            IContainer      container = context.Container;

            if (context.Instance is Array)
            {
                Array list = (Array)context.Instance;
                Debug.Assert(list.Length > 0);

                foreach(Object obj in list)
                {
                    Debug.Assert(obj is MobileControl);
                    Form form = GetContainingForm((MobileControl)obj);

                    // If the control is not within a Form control or a StyleSheet control,
                    // simply return the empty combobox.
                    // If the control is placed at UserControl top level, the ID of the 
                    // containing Form is null.
                    if ((form == null || form.ID == null) && 
                        GetContainingStyleSheet((MobileControl)obj) == null)
                    {
                        return null;
                    }
                }
                control = list.GetValue(0) as MobileControl;
            }
            else
            {
                if (context.Instance is MobileControl)
                {
                    control = (MobileControl) context.Instance;
                }
                else if (context.Instance is ChoicePropertyFilter)
                {
                    ChoicePropertyFilter filter = (ChoicePropertyFilter)context.Instance;
                    IDeviceSpecificDesigner designer = filter.Designer;
                    control = designer.UnderlyingObject as MobileControl;
                    Debug.Assert(control != null, "Not a control");
                }
                else
                {
                    Debug.Fail("Unrecognized object passed in");
                    return null;
                }

                Form form = GetContainingForm(control);

                // All controls must be contained within Forms or StyleSheets
                // Show empty combobox for the invalid control.
                if (form == null)
                {
                    if (GetContainingStyleSheet(control) == null)
                    {
                        return null;
                    }
                }
                // MobileUserControl has a default Form with null ID
                else if (form.ID == null && (GetContainingStyleSheet(control) == null))
                {
                    Debug.Assert(container is IDesignerHost &&
                        ((IDesignerHost)container).RootComponent is MobileUserControl);

                    // Just return an empty array list, so that url picker still works.
                    return controlList;
                }
            }

            // If container is null, try to get one from control's IContainer
            if (container == null)
            {
                ISite site = control.Site;
                Debug.Assert(site != null);

                container = (IContainer)site.GetService(typeof(IContainer));
            }

            // Is this possible?
            if (container == null)
            {
                Debug.Fail("container is null");
                return null;
            }

            foreach(IComponent component in container.Components)
            {
                Form candidate = component as Form;
                if (candidate != null &&
                    candidate.ID != null &&
                    candidate.ID.Length != 0)
                {
                    controlList.Add(ProcessControlId(candidate.ID));
                }
            }

            controlList.Sort();
            return controlList;
        }

        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
        {
            if (context == null)
            {
                return null;
            }

            ArrayList objValues = GetControls(context);
            return (objValues != null? new StandardValuesCollection(objValues) : null);
        }

        /// <summary>
        ///    <para>
        ///       Gets whether
        ///       or not the context specified contains exclusive standard values.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that indicates the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///    <see langword='true'/> if the specified context contains exclusive standard 
        ///       values, otherwise <see langword='false'/>.
        ///    </para>
        /// </returns>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)
        {
            return false;
        }

        /// <summary>
        ///    <para>
        ///       Gets whether or not the specified context contains supported standard
        ///       values.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that indicates the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///    <see langword='true'/> if the specified context conatins supported standard 
        ///       values, otherwise <see langword='false'/>.
        ///    </para>
        /// </returns>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
        {
            return true;
        }

        /// <summary>
        ///     Override to manipulate the control id as it is added to the list.
        ///     Do not return the original string, make sure a copy is made.
        ///     See NavigateUrlConverter.cs for an example.
        /// </summary>
        protected virtual String ProcessControlId(String id)
        {
            return id;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\converters\validatedmobilecontrolconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValidatedMobileControlConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Converters
{
    using System.Diagnostics;
    using System.Collections;
    using System.ComponentModel;
    using System.Web.UI;
    using System.Web.UI.Design.MobileControls.Adapters;
    using System.Web.UI.MobileControls;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class ValidatedMobileControlConverter: StringConverter
    {
        private Form GetContainingForm(MobileControl mc)
        {
            return FindContainer(mc, typeof(Form)) as Form;
        }

        private StyleSheet GetContainingStyleSheet(MobileControl mc)
        {
            return FindContainer(mc, typeof(StyleSheet)) as StyleSheet;
        }

        private Control FindContainer(MobileControl mc, Type containerType)
        {
            for (Control control = mc; control != null; control = control.Parent)
            {
                if (containerType.IsAssignableFrom(control.GetType()))
                {
                    return control;
                }
            }
            return null;
        }

        protected virtual Object [] GetValidatableControls(Object instance)
        {
            System.Web.UI.MobileControls.BaseValidator thisValidator = null;

            if (instance is Array)
            {
                Array controlList = (Array)instance;
                Debug.Assert(controlList.Length > 0);

                thisValidator = (BaseValidator) controlList.GetValue(0);
                Form firstForm = GetContainingForm(thisValidator);

                for (int i = 1; i < controlList.Length; i++)
                {
                    BaseValidator validator = (BaseValidator)controlList.GetValue(i);
                    if (GetContainingForm(validator) != firstForm)
                    {
                        return null;
                    }
                }
            }

            if (instance is System.Web.UI.MobileControls.BaseValidator)
            {
                thisValidator = (System.Web.UI.MobileControls.BaseValidator) instance;
            }
            else if (instance is ChoicePropertyFilter)
            {
                IDeviceSpecificDesigner designer = 
                    ((ChoicePropertyFilter)instance).Designer;

                thisValidator = designer.UnderlyingObject 
                    as System.Web.UI.MobileControls.BaseValidator;
            }

            if (thisValidator == null)
            {
                Debug.Fail("Unsupported object passed in");
                return null;
            }

            ArrayList controlArray = new ArrayList();

            if (GetContainingStyleSheet(thisValidator) != null)
            {
                ISite site = thisValidator.Site;
                IContainer container = null;

                if (site != null)
                {
                    container = (IContainer)site.GetService(typeof(IContainer));
                    Debug.Assert(container != null);

                    foreach(IComponent component in container.Components)
                    {
                        Control control = component as Control;
                        if (control != null && CanBeValidated(control))
                        {
                            controlArray.Add(control.ID);
                        }
                    }
                }
            }
            else
            {
                Form parentForm = GetContainingForm(thisValidator);

                if (parentForm != null)
                {
                    ExtractValidatableControls(parentForm, controlArray);
                }
                else
                {
                    return null;
                }
            }

            controlArray.Sort();
            return controlArray.ToArray();
        }

        private void ExtractValidatableControls(Control parent, ArrayList controlArray)
        {
            foreach (Control control in parent.Controls)
            {
                if (CanBeValidated(control))
                {
                    controlArray.Add(control.ID);
                }
                if (!(control is Form))
                {
                    ExtractValidatableControls(control, controlArray);
                }
            }
        }

        private bool CanBeValidated(Control control)
        {
            // Control must have an ID
            if (control.ID == null || control.ID.Length == 0)
            {
                return false;
            }

            // Control must have a ValidationProperty attribute
            ValidationPropertyAttribute valProp = 
                (ValidationPropertyAttribute) 
                TypeDescriptor.GetAttributes(control)[typeof(ValidationPropertyAttribute)];

            if (null != valProp && null != valProp.Name)
            {
                return true;    
            }

            return false;
        }

        /// <summary>
        ///    <para>
        ///       Returns a collection of standard values retrieved from the context specified
        ///       by the specified type descriptor.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that specifies the location of the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///       A StandardValuesCollection that represents the standard values collected from
        ///       the specified context.
        ///    </para>
        /// </returns>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
        {
            if (context == null || context.Instance == null)
            {
                return null;
            }

            Object [] objValues = GetValidatableControls(context.Instance);
            if (objValues != null)
            {
                return new StandardValuesCollection(objValues);
            }
            else
            {
                return null;
            }            
        }

        /// <summary>
        ///    <para>
        ///       Gets whether
        ///       or not the context specified contains exclusive standard values.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that indicates the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///    <see langword='true'/> if the specified context contains exclusive standard 
        ///       values, otherwise <see langword='false'/>.
        ///    </para>
        /// </returns>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)
        {
            return false;
        }

        /// <summary>
        ///    <para>
        ///       Gets whether or not the specified context contains supported standard
        ///       values.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that indicates the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///    <see langword='true'/> if the specified context conatins supported standard 
        ///       values, otherwise <see langword='false'/>.
        ///    </para>
        /// </returns>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
        {
            return true;
        }        
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\converters\fontnameconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontNameConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Converters
{
    using Microsoft.Win32;

    using System.Collections;
    using System.ComponentModel;
    using System.Drawing;
    using System.Diagnostics;
    using System.Globalization;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class FontNameConverter : TypeConverter 
    {
        private StandardValuesCollection values;

        /// <devdoc>
        ///      Creates a new font name converter.
        /// </devdoc>
        public FontNameConverter() 
        {
            // Sink an event to let us know when the installed
            // set of fonts changes.
            //
            SystemEvents.InstalledFontsChanged += new EventHandler(this.OnInstalledFontsChanged);
        }

        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) 
        {
            if (sourceType == typeof(string)) 
            {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) 
        {
            if (value is string) 
            {
                return MatchFontName((string)value, context);
            }
            return base.ConvertFrom(context, culture, value);
        }

        /// <devdoc>
        ///      We need to know when we're finalized.
        /// </devdoc>
        ~FontNameConverter() 
        {
            SystemEvents.InstalledFontsChanged -= new EventHandler(this.OnInstalledFontsChanged);
        }

        /// <devdoc>
        ///      Retrieves a collection containing a set of standard values
        ///      for the data type this validator is designed for.  This
        ///      will return null if the data type does not support a
        ///      standard set of values.
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) 
        {
            if (values == null) 
            {
                FontFamily[] fonts =  FontFamily.Families;

                Hashtable hash = new Hashtable();
                for (int i = 0; i < fonts.Length; i++) 
                {
                    string name = fonts[i].Name;
                    hash[name.ToLower(CultureInfo.InvariantCulture)] = name;
                }

                object[] array = new object[hash.Values.Count];
                hash.Values.CopyTo(array, 0);
                Array.Sort(array);
                values = new StandardValuesCollection(array);
            }

            return values;
        }

        /// <devdoc>
        ///      Determines if the list of standard values returned from
        ///      GetStandardValues is an exclusive list.  If the list
        ///      is exclusive, then no other values are valid, such as
        ///      in an enum data type.  If the list is not exclusive,
        ///      then there are other valid values besides the list of
        ///      standard values GetStandardValues provides.
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) 
        {
            return false;
        }

        /// <devdoc>
        ///      Determines if this object supports a standard set of values
        ///      that can be picked from a list.
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) 
        {
            return true;
        }

        private string MatchFontName(string name, ITypeDescriptorContext context) 
        {
            Debug.Assert(name != null, "Expected an actual font name to match in FontNameConverter::MatchFontName.");

            // AUI 2300
            if (name.Trim().Equals(String.Empty))
            {
                return String.Empty;
            }
                
            // Try a partial match
            //
            string bestMatch = null;
            name = name.ToLower(CultureInfo.InvariantCulture);
            IEnumerator e = GetStandardValues(context).GetEnumerator();
            while (e.MoveNext()) 
            {
                string fontName = e.Current.ToString().ToLower(CultureInfo.InvariantCulture);
                if (fontName.Equals(name)) 
                {
                    // For an exact match, return immediately
                    //
                    return e.Current.ToString();
                }
                else if (fontName.StartsWith(name)) 
                {
                    if (bestMatch == null || fontName.Length <= bestMatch.Length) 
                    {
                        bestMatch = e.Current.ToString();
                    }
                }
            }
                
            if (bestMatch == null) 
            {
                // no match... fall back on whatever was provided
                bestMatch = name;
            }
            return bestMatch;
        }

        /// <devdoc>
        ///      Called by system events when someone adds or removes a font.  Here
        ///      we invalidate our font name collection.
        /// </devdoc>
        private void OnInstalledFontsChanged(object sender, EventArgs e) 
        {
            values = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\defaultdialogbuttons.cs ===
//------------------------------------------------------------------------------
// <copyright file="DefaultDialogButtons.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// File created with Beta1 Windes.  (Build 1.0.2204.21)
// Made to compile under new URT by 'sed "s/Windows.Forms/Windows.Forms/g"'
// Any manual modifications marked by HUMAN comments.

// Size of panel should be 237,23.

namespace System.Web.UI.Design.MobileControls.Util
{    
    using System;
    using System.Drawing;
    using System.ComponentModel;
    using System.Windows.Forms;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DefaultDialogButtons : Panel
    {
        private System.ComponentModel.Container components;
        internal System.Windows.Forms.Button CmdCancel;
        internal System.Windows.Forms.Button CmdHelp;
        internal System.Windows.Forms.Button CmdOK;
        
        ////////////////////////////////////////////////////////////////////////
        //  Begin WinDes Generated
        ////////////////////////////////////////////////////////////////////////

        /// <summary> 
        ///    Required by the Win Forms designer 
        /// </summary>
        internal DefaultDialogButtons()
        {
            // Required for Win Form Designer support
            InitializeComponent();
            
            CmdOK.Text = SR.GetString(SR.GenericDialog_OKBtnCaption);
            CmdCancel.Text = SR.GetString(SR.GenericDialog_CancelBtnCaption);
            CmdHelp.Text = SR.GetString(SR.GenericDialog_HelpBtnCaption);
        }

        protected override void Dispose(bool disposing)
        {
            if(disposing)
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.CmdHelp = new System.Windows.Forms.Button();
            this.CmdOK = new System.Windows.Forms.Button();
            this.CmdCancel = new System.Windows.Forms.Button();
            
            CmdOK.Size = new System.Drawing.Size(75, 23);
            
            CmdCancel.Location = new System.Drawing.Point(81, 0);
            CmdCancel.Size = new System.Drawing.Size(75, 23);

            CmdHelp.Location = new System.Drawing.Point(162, 0);
            CmdHelp.Size = new System.Drawing.Size(75, 23);

            this.Controls.Add(CmdOK);
            this.Controls.Add(CmdCancel);
            this.Controls.Add(CmdHelp);
        }
        
        ////////////////////////////////////////////////////////////////////////
        //  End WinDes Generated 
        ////////////////////////////////////////////////////////////////////////
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\converters\styleconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="StyleConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Converters
{
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.UI.MobileControls;

    /// <summary>
    ///    <para>
    ///       Can filter and retrieve several types of values from controls.
    ///    </para>
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class StyleConverter: StringConverter
    {
        protected virtual Object [] GetStyles(Object instance)
        {
            // We do not support anything other than a single styleSheet
            if (!(instance is System.Web.UI.MobileControls.StyleSheet))
            {
                return null;
            }

            StyleSheet _styleSheet = (StyleSheet)instance;
            ICollection styles = _styleSheet.Styles;

            ArrayList _styleArray = new ArrayList();

            foreach (String key in styles)
            {
                System.Web.UI.MobileControls.Style style = (System.Web.UI.MobileControls.Style) _styleSheet[key];
                if (style.Name != null && style.Name.Length > 0)
                {
                    _styleArray.Add(style.Name);
                }
            }

            if (0 == _styleArray.Count)
            {
                // add (None) entry for CurrentStyle == null
                _styleArray.Add(SR.GetString(SR.StyleSheet_PropNotSet));
            }

            _styleArray.Sort();
            return _styleArray.ToArray();
        }

        /// <summary>
        ///    <para>
        ///       Returns a collection of standard values retrieved from the context specified
        ///       by the specified type descriptor.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that specifies the location of the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///       A StandardValuesCollection that represents the standard values collected from
        ///       the specified context.
        ///    </para>
        /// </returns>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
        {
            if (context == null || context.Instance == null)
            {
                return null;
            }

            Object [] objValues = GetStyles(context.Instance);
            if (objValues != null)
            {
                return new StandardValuesCollection(objValues);
            }
            else
            {
                return null;
            }            
        }

        /// <summary>
        ///    <para>
        ///       Gets whether
        ///       or not the context specified contains exclusive standard values.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that indicates the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///    <see langword='true'/> if the specified context contains exclusive standard 
        ///       values, otherwise <see langword='false'/>.
        ///    </para>
        /// </returns>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)
        {
            return false;
        }

        /// <summary>
        ///    <para>
        ///       Gets whether or not the specified context contains supported standard
        ///       values.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A type descriptor that indicates the context to convert from.
        /// </param>
        /// <returns>
        ///    <para>
        ///    <see langword='true'/> if the specified context conatins supported standard 
        ///       values, otherwise <see langword='false'/>.
        ///    </para>
        /// </returns>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
        {
            return true;
        }        
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\filereader.cs ===
//------------------------------------------------------------------------------
// <copyright file="FileReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Util
{
    using System;
    using System.Diagnostics;
    using System.Net;
    using System.IO;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class FileReader
    {
        /// <summary>
        ///    This method reads a file specified by a uri and returns it
        ///    as a byte array.  If the file is located on the local file
        ///    system, a FileStream is used instead of a WebRequest.
        /// </summary>
        internal static Byte[] Read(Uri uri)
        {
            int length;
            Stream stream;

            Byte[] buffer = null;
            try
            {
                WebRequest request = WebRequest.Create(uri);
                WebResponse response = request.GetResponse();
                length = (int) response.ContentLength;
                stream = response.GetResponseStream();
                buffer = new Byte[length];
                stream.Read(buffer, 0, length);
                stream.Close();
            }
            catch(Exception e)
            {
                Debug.Fail("FileReader - Unable to read url '"
                    + uri.ToString() + ":\r\n" + e.ToString());
                return null;
            }
            return buffer;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\genericui.cs ===
//------------------------------------------------------------------------------
// <copyright file="GenericUI.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Util
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Drawing;
    using System.Diagnostics;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Text;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class GenericUI
    {
        internal static readonly Bitmap SortDownIcon =
            new Icon(typeof(MobileControlDesigner), "SortDown.ico").ToBitmap();

        internal static readonly Bitmap SortUpIcon =
            new Icon(typeof(MobileControlDesigner), "SortUp.ico").ToBitmap();
        
        internal static readonly Bitmap DeleteIcon =
            new Icon(typeof(MobileControlDesigner), "Delete.ico").ToBitmap();
        
        internal static readonly Bitmap ErrorIcon = 
            new Icon(typeof(MobileContainerDesigner), "Error.ico").ToBitmap();

        internal static readonly Bitmap InfoIcon = 
            new Icon(typeof(MobileContainerDesigner), "Info.ico").ToBitmap();

        internal static void InitDialog(
            Form dialog,
            ISite site
        ) {
            dialog.FormBorderStyle = FormBorderStyle.FixedDialog;
            dialog.Icon = null;
            dialog.MaximizeBox = false;
            dialog.MinimizeBox = false;
            dialog.ShowInTaskbar = false;
            dialog.StartPosition = FormStartPosition.CenterParent;
            dialog.AutoScaleBaseSize = new Size(5, 14);
            dialog.Font = GetVS7Font(site);
        }

        internal static Font GetVS7Font(ISite site)
        {
            System.Drawing.Font vsfont = Control.DefaultFont;
            if (site != null)
            {
                IUIService uiService = (IUIService) site.GetService(
                    typeof(IUIService)
                    );
                if (uiService != null)
                {
                    vsfont = (Font) uiService.Styles["DialogFont"];
                }
            }
            return vsfont;
        }    
        
        // This version of InitDialog() handles merged UIs
        internal static int InitDialog(
            Form dialog,
            IDeviceSpecificDesigner designer,
            int mergingContext
        ) {
            InitDialog(dialog, designer.UnderlyingControl.Site);
            int tabOffset = 0;
            designer.InitHeader(mergingContext);
            Control header = designer.Header;
            if (header != null)
            {
                // (6, 5) = Windows standard positioning
                header.Location = new Point(6, 5);
                dialog.Controls.Add(header);
                // +6 = 6px space between header and first control
                dialog.Height += header.Height + 6;
                tabOffset = GenericUI.GetMaxContainedTabIndex(header);
                // Changing the header width is going to magically
                // cause everything to be repositioned vertically
                // -10 = 5px padding on each side of the client area
                header.Width = dialog.ClientSize.Width - 10;
            }
            return tabOffset;
        }

        internal static int GetMaxContainedTabIndex(Control control)
        {
            int maxTabIndex = control.TabIndex;
            
            foreach(Control child in control.Controls)
            {
                int maxChildTabIndex = GetMaxContainedTabIndex(child);
                if(maxChildTabIndex > maxTabIndex)
                {
                    maxTabIndex = maxChildTabIndex;
                }
            }
            return maxTabIndex;
        }

        internal static void ShowErrorMessage(String title, String message)
        {
            MessageBox.Show(
                null,
                message,
                title,
                MessageBoxButtons.OK,
                MessageBoxIcon.Error
            );
        }

        internal static String BuildCommaDelimitedList(ICollection stringList)
        {
            StringBuilder delimitedString = new StringBuilder();

            foreach (String str in stringList)
            {
                if(delimitedString.Length > 0)
                {
                    delimitedString.Append(", ");
                }
                delimitedString.Append(str);
            }
            return delimitedString.ToString();
        }

        internal static void ShowWarningMessage(String title, String message)
        {
            MessageBox.Show(
                null,
                message,
                title,
                MessageBoxButtons.OK,
                MessageBoxIcon.Exclamation
            );
        }
        
        internal static bool ConfirmYesNo(String title, String message)
        {
            DialogResult result = MessageBox.Show(
                null,
                message,
                title,
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Exclamation
            );
            return result == DialogResult.Yes;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\grouplabel.cs ===
//------------------------------------------------------------------------------
// <copyright file="GroupLabel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Util
{
    using System;
    using System.Diagnostics;
    using System.Drawing;
    using System.Runtime.Serialization.Formatters;
    using System.Windows.Forms;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class GroupLabel : Label 
    {
        /// <summary>
        ///    Creates a new GroupLabel
        /// </summary>
        internal GroupLabel() : base() 
        {
            SetStyle(ControlStyles.UserPaint, true);
        }

        /// <summary>
        ///    Custom UI is painted here
        /// </summary>
        protected override void OnPaint(PaintEventArgs e) 
        {
            Graphics g = e.Graphics;
            Rectangle r = ClientRectangle;
            string text = Text;

            Brush foreBrush = new SolidBrush(ForeColor);
            g.DrawString(text, Font, foreBrush, 0, 0);
            foreBrush.Dispose();

            int etchLeft = r.X;
            if (text.Length != 0) 
            {
                Size sz = Size.Ceiling(g.MeasureString(text, Font));
                etchLeft += 6 + sz.Width;
            }
            int etchTop = r.Height / 2;

            g.DrawLine(SystemPens.ControlDark, etchLeft, etchTop, r.Width, etchTop);

            etchTop++;
            g.DrawLine(SystemPens.ControlLightLight, etchLeft, etchTop, r.Width, etchTop);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\designerutility.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerUtility.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Util
{
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Reflection;
    using System.Web.UI.MobileControls;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerUtility
    {
        /* Removed for DCR 4240
        internal static bool IsValidName(String name)
        {
            if (name == null || name.Length == 0)
            {
                return false;
            }

            for (int pos = 0; pos < name.Length; pos++)
            {
                Char ch = name[pos];
                if (Char.IsWhiteSpace(ch) || ch.Equals('"') || ch.Equals('<') || 
                    ch.Equals('>') || ch.Equals('\'') || ch.Equals('&'))
                {
                    return false;
                }
            }
            return true;
        }
        */

        internal static bool TopLevelControl(MobileControl control)
        {
            if (control is Form || control is StyleSheet)
            {
                return true;
            }
            return false;
        }

        internal static String ChoiceToUniqueIdentifier(DeviceSpecificChoice choice)
        {
            Debug.Assert(choice != null);
            return  ChoiceToUniqueIdentifier(choice.Filter, choice.Argument);
        }

        internal static String ChoiceToUniqueIdentifier(String filter, String argument)
        {
            if (filter == null || filter == "")
            {
                filter = SR.GetString(SR.DeviceFilter_DefaultChoice);
            }
            if (argument == null)
            {
                argument = "";
            }
            return String.Format("{0} (\"{1}\")", filter, argument);
        }
        
        // NOTE: Throws CheckoutException.Canceled if user cancels checkout.
        internal static void EnsureFileCheckedOut(ISite site, String fileName)
        {
            Type serviceType = Type.GetType("Microsoft.VisualStudio.Shell.VsCheckoutService, Microsoft.VisualStudio, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
            Object serviceInstance = System.Activator.CreateInstance(
                serviceType, new Object[] { site });
            
            try
            {
                Object[] args = new Object[] { fileName };
                bool fileNeedsCheckout = (bool) serviceType.InvokeMember(
                    "DoesFileNeedCheckout",
                    BindingFlags.Default | BindingFlags.InvokeMethod,
                    null,
                    serviceInstance,
                    args
                );
                if(fileNeedsCheckout)
                {
                    serviceType.InvokeMember(
                        "CheckoutFile",
                        BindingFlags.Default | BindingFlags.InvokeMethod,
                        null,
                        serviceInstance,
                        args
                    );                
                }
            }
            finally
            {
                serviceType.InvokeMember(
                    "Dispose",
                    BindingFlags.Default | BindingFlags.InvokeMethod,
                    null,
                    serviceInstance,
                    new Object[] {}
                );                
                serviceInstance = null;
            }
        }

        // Ideally we would refactor the rest of the common code in the ADF/PO/DFE
        // dialogs into a separate manager object.
        internal static StringCollection GetDuplicateChoiceTreeNodes(ICollection treeNodes)
        {
            HybridDictionary visitedChoices = new HybridDictionary();
            StringCollection duplicateChoices = new StringCollection();
            
            foreach(ChoiceTreeNode node in treeNodes)
            {
                String key = ChoiceToUniqueIdentifier(node.Name, node.Argument);
                if(visitedChoices[key] == null)
                {
                    visitedChoices[key] = 1;
                }
                else
                {
                    if((int)visitedChoices[key] == 1)
                    {
                        duplicateChoices.Add(key);

                    }
                    visitedChoices[key] = ((int)visitedChoices[key]) + 1;
                }
            }
            return duplicateChoices;
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\editabletreelist.cs ===
//------------------------------------------------------------------------------
// <copyright file="EditableTreeList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Util
{
    using System;
    using System.Diagnostics;
    using System.Drawing;
    using System.ComponentModel;
    using System.Globalization;
    using System.Windows.Forms;
    using System.Web.UI.Design.MobileControls;

    [
        ToolboxItem(false),
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class EditableTreeList : Panel
    {
        
        private const String _assertMsgNullNodeSelected =
            "Caller is responsible for ensuring a TreeNode is selected. "
            + "Modified TreeViewNode without calling UpdateButtonsEnabling()?";

        private const String _assertMsgOutOfBounds =
            "Caller is responsible for ensuring this action does not move the "
            + "selected TreeViewNode out of bounds. "
            + "Modified TvList without calling UpdateButtonsEnabling()?";

        internal TreeNode LastNodeChanged = null;
        internal TreeNode EditCandidateNode = null;
        internal EventHandler RemoveHandler;
        private bool _caseSensitive;

        internal System.Windows.Forms.Button BtnAdd;
        internal System.Windows.Forms.Button BtnRemove;
        internal System.Windows.Forms.Button BtnDown;
        internal System.Windows.Forms.Button BtnUp;
        internal System.Windows.Forms.TreeView TvList;
        internal System.Windows.Forms.Label LblTitle;
        internal System.Windows.Forms.ContextMenu CntxtMenu;
        internal System.Windows.Forms.MenuItem CntxtMenuItem;

        internal EditableTreeList() : this(true, true, 16)
        {
        }
        
        internal EditableTreeList(bool showAddButton, bool caseSensitive, int Y)
        {
            this.TvList = new System.Windows.Forms.TreeView();
            this.BtnAdd = new System.Windows.Forms.Button();
            this.BtnDown = new System.Windows.Forms.Button();
            this.LblTitle = new System.Windows.Forms.Label();
            this.BtnUp = new System.Windows.Forms.Button();
            this.BtnRemove = new System.Windows.Forms.Button();
            this.CntxtMenuItem = new System.Windows.Forms.MenuItem();
            this.CntxtMenu = new System.Windows.Forms.ContextMenu();
            
            LblTitle.Size = new System.Drawing.Size(210, 16);
            LblTitle.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;;

            TvList.Location = new System.Drawing.Point(0, 16);
            TvList.Size = new System.Drawing.Size(178, 148);
            TvList.ForeColor = System.Drawing.SystemColors.WindowText;
            TvList.Anchor = AnchorStyles.Top
                | AnchorStyles.Bottom
                | AnchorStyles.Left
                | AnchorStyles.Right;
            TvList.LabelEdit = true;
            TvList.ShowPlusMinus = false;
            TvList.HideSelection = false;
            TvList.Indent = 15;
            TvList.ShowRootLines = false;
            TvList.ShowLines = false;
            TvList.ContextMenu = CntxtMenu;
            
            BtnUp.Location = new System.Drawing.Point(182, 16);
            BtnUp.Size = new System.Drawing.Size(28, 27);
            BtnUp.Anchor = AnchorStyles.Top | AnchorStyles.Right;;
            
            BtnDown.Location = new System.Drawing.Point(182, 48);
            BtnDown.Size = new System.Drawing.Size(28, 27);
            BtnDown.Anchor = AnchorStyles.Top | AnchorStyles.Right;
            
            BtnRemove.Location = new System.Drawing.Point(182, 136);
            BtnRemove.Size = new System.Drawing.Size(28, 27);
            BtnRemove.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;

            BtnAdd.Location = new System.Drawing.Point(0, 168);
            BtnAdd.Size = new System.Drawing.Size(178, 25);
            BtnAdd.Anchor = AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;

            CntxtMenuItem.Text = SR.GetString(SR.EditableTreeList_Rename);
            CntxtMenu.MenuItems.Add(CntxtMenuItem);

            this.Location = new System.Drawing.Point(8, Y);
            this.Size = new System.Drawing.Size(210, 196);
            
            this.Controls.Add(LblTitle);
            this.Controls.Add(TvList);
            this.Controls.Add(BtnUp);
            this.Controls.Add(BtnDown);
            this.Controls.Add(BtnRemove);
            this.Controls.Add(BtnAdd);

            BtnDown.Image = GenericUI.SortDownIcon;
            BtnUp.Image = GenericUI.SortUpIcon;
            BtnRemove.Image = GenericUI.DeleteIcon;

            BtnUp.Click += new EventHandler(MoveSelectedItemUp);
            BtnDown.Click += new EventHandler(MoveSelectedItemDown);
            RemoveHandler = new EventHandler(OnRemove);
            BtnRemove.Click += RemoveHandler;
            TvList.AfterSelect += new TreeViewEventHandler(OnListSelect);
            TvList.KeyDown += new KeyEventHandler(OnKeyDown);
            TvList.MouseUp += new MouseEventHandler(OnListMouseUp);
            TvList.MouseDown += new MouseEventHandler(OnListMouseDown);
            CntxtMenu.Popup += new EventHandler(OnPopup);
            CntxtMenuItem.Click += new EventHandler(OnContextMenuItemClick);
            
            UpdateButtonsEnabling();

            if(!showAddButton)
            {
                // stretch UI to occupy space where add button was.
                BtnAdd.Visible = false;
                int offset = 4 + BtnAdd.Height;
                TvList.Height += offset;
                BtnRemove.Top += offset;
            }
            _caseSensitive = caseSensitive;
        }

        ////////////////////////////////////////////////////////////////////////
        //  End Windes Generated
        ////////////////////////////////////////////////////////////////////////

        internal int SelectedIndex
        {
            get
            {
                TreeNode selectedNode = TvList.SelectedNode;
                if(selectedNode != null)
                {
                    return selectedNode.Index;
                }
                else
                {
                    return -1;
                }
            }
        }

        internal TreeNode SelectedNode
        {
            get
            {
                return TvList.SelectedNode;
            }

            set
            {
                TvList.SelectedNode = value;
            }
        }

        private TreeNode SelectedNodeChecked
        {
            get
            {
                TreeNode node = TvList.SelectedNode;
                Debug.Assert(
                    node != null,
                    _assertMsgNullNodeSelected
                );
                return node;
            }
        }

        private void MoveSelectedNode(int direction)
        {
            Debug.Assert(direction == 1 || direction == -1);
            LastNodeChanged = TvList.SelectedNode;
            Debug.Assert(
                LastNodeChanged != null,
                _assertMsgNullNodeSelected
            );
            int index = LastNodeChanged.Index;
            Debug.Assert(
                (index + direction >= 0)
                && ((index + direction) < TvList.Nodes.Count),
                _assertMsgOutOfBounds
            );
            TvList.Nodes.RemoveAt(index);
            TvList.Nodes.Insert(index + direction, LastNodeChanged);
            TvList.SelectedNode = LastNodeChanged;
        }
        
        internal void MoveSelectedItemUp(Object sender, EventArgs e)
        {
            MoveSelectedNode(-1);
            UpdateButtonsEnabling();
        }

        internal void MoveSelectedItemDown(Object sender, EventArgs e)
        {
            MoveSelectedNode(1);
            UpdateButtonsEnabling();
        }

        internal void RemoveSelectedItem()
        {
            LastNodeChanged = SelectedNodeChecked;
            TvList.Nodes.Remove(LastNodeChanged);
            UpdateButtonsEnabling();
        }

        private void OnKeyDown(Object sender, KeyEventArgs e)
        {
            switch(e.KeyData)
            {
                case Keys.F2:
                {
                    TreeNode selectedNode = TvList.SelectedNode;
                    if(selectedNode != null)
                    {
                        selectedNode.BeginEdit();
                    }
                    break;
                }
                case (Keys.Control | Keys.Home):
                {
                    if(TvList.Nodes.Count > 0)
                    {
                        TvList.SelectedNode = TvList.Nodes[0];
                    }
                    break;
                }
                case (Keys.Control | Keys.End):
                {
                    int numNodes = TvList.Nodes.Count;
                    if(numNodes > 0)
                    {
                        TvList.SelectedNode = TvList.Nodes[numNodes - 1];
                    }
                    break;
                }
            }
        }

        private void OnRemove(Object sender, EventArgs e)
        {
            RemoveSelectedItem();
        }

        private void OnListSelect(Object sender, TreeViewEventArgs e)
        {
            UpdateButtonsEnabling();
        }

        private void OnListMouseUp(Object sender, MouseEventArgs e)
        {
            EditCandidateNode= null;
            if (e.Button == MouseButtons.Right)
            {
                EditCandidateNode = (TreeNode)TvList.GetNodeAt (e.X, e.Y);
            }
        }

        private void OnListMouseDown(Object sender, MouseEventArgs e)
        {
            EditCandidateNode = null;
            if (e.Button == MouseButtons.Right)
            {
                EditCandidateNode = (TreeNode)TvList.GetNodeAt (e.X, e.Y);
            }
        }
        
        private void OnPopup(Object sender, EventArgs e)
        {
            CntxtMenuItem.Enabled = (EditCandidateNode != null || 
                                                    TvList.SelectedNode != null);
        }

        private void OnContextMenuItemClick(Object sender, EventArgs e)
        {
            if(EditCandidateNode == null)
            {
               // context menu key pressed
               if (TvList.SelectedNode!=null)
               {
                    TvList.SelectedNode.BeginEdit();
               }
            }
            else
            {
                // right mouse-click
                EditCandidateNode.BeginEdit();
            }
            EditCandidateNode = null;
        }
        
        internal String GetUniqueLabel(String label)
        {
            int index = 1;
            String uniqueLabel = label + index;
            while(LabelExists(uniqueLabel))
            {
                uniqueLabel = label + (++index);
            }
            return uniqueLabel;
        }

        internal bool LabelExists(String label)
        {
            foreach(TreeNode node in TvList.Nodes)
            {
                if(String.Compare(node.Text, label, !_caseSensitive, CultureInfo.InvariantCulture) == 0)
                {
                    return true;
                }
            }
            return false;
        }

        internal void UpdateButtonsEnabling()
        {
            int selectedIndex = SelectedIndex;
            bool anItemIsSelected = (selectedIndex >= 0);

            BtnRemove.Enabled = anItemIsSelected;
            if (anItemIsSelected)
            {
                BtnUp.Enabled = (selectedIndex > 0);
                BtnDown.Enabled = (selectedIndex < TvList.Nodes.Count - 1);
            }
            else
            {
                BtnUp.Enabled = false;
                BtnDown.Enabled = false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\headerpanel.cs ===
//------------------------------------------------------------------------------
// <copyright file="HeaderPanel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Util
{
    using System;
    using System.Diagnostics;
    using System.Drawing;
    using System.Windows.Forms;
    
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class HeaderPanel : Panel
    {
        private int _recursionCount = 0;
        
        internal void RequestNewHeight(HeaderLabel header, int height)
        {
            int offset = height - header.Height;
 
            try
            {
                // This is a workaround for a RTB issue that causes their
                // algorithm to blow up if OnContentsResize recurses.  (Now
                // that HeaderLabel does not resize the text untill after
                // autoscaling, we do not seem to hit this, but just in case).
                // 
                // On the first call the RTB guesses its best dimensions
                // for the given text.  We correct the Width which may cause
                // a second recursive call to adjust the height.

                if(_recursionCount < 2)
                {
                    _recursionCount++;
                    header.Height = height;
                    
                    // BUGBUG: Horrid hack to temporarily avoid using anchors
                    foreach(Control child in Controls)
                    {
                        if(child.Top > header.Top)
                        {
                            child.Top += offset;
                        }
                    }

                    for(
                        Control controlIterator = this;
                        controlIterator != null;
                        controlIterator = controlIterator.Parent
                    ) {
                        controlIterator.Height += offset;
                    }
                }
                else
                {
                    Debug.Assert(offset == 0,
                        "On 3rd recursive call offset is not yet stabalized."
                    );
                }
            }
            finally
            {
                _recursionCount = 0;
            }
        }

        protected override void OnSizeChanged(EventArgs e)
        {
            foreach(Control child in Controls)
            {
                if(child is HeaderLabel)
                {
                    child.Width = Width;
                }
            }
            base.OnSizeChanged(e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\headerlabel.cs ===
//------------------------------------------------------------------------------
// <copyright file="HeaderLabel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Util
{
    using System;
    using System.Diagnostics;
    using System.Drawing;
    using System.Windows.Forms;
    
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class HeaderLabel : RichTextBox
    {
        private String _text;
        
        internal HeaderLabel()
        {
            BackColor = SystemColors.Control;
            BorderStyle = BorderStyle.None;
            WordWrap = true;
            ReadOnly = true;
            TabStop = false;
            ScrollBars = RichTextBoxScrollBars.None;
            VisibleChanged += new EventHandler(OnVisibleChanged);
        }

        protected override void OnContentsResized(ContentsResizedEventArgs e)
        {
            HeaderPanel headerPanel = Parent as HeaderPanel;
            
            Debug.Assert(headerPanel != null,
                "HeaderLabel should be placed inside of a HeaderPanel.");
            headerPanel.RequestNewHeight(this, e.NewRectangle.Height);
            base.OnContentsResized(e);
        }

        public override String Text
        {
            get
            {
                return _text;
            }

            set
            {
                _text = value;
            }
        }

        private void OnVisibleChanged(Object sender, EventArgs e)
        {
            if(Visible && _text != base.Text)
            {
                base.Text = _text;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\interchangeablelists.cs ===
//------------------------------------------------------------------------------
// <copyright file="InterchangeableLists.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Util
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Data;
    using System.Drawing;
    using System.Diagnostics;
    using System.Web.UI.Design.MobileControls;
    using System.Windows.Forms;

    [
        ToolboxItem(false),
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class InterchangeableLists : System.Windows.Forms.Panel
    {
        private System.Windows.Forms.Button _removeButton;
        private System.Windows.Forms.Button _addButton;
        private System.Windows.Forms.Button _upButton;
        private System.Windows.Forms.TreeView _availableList;
        private System.Windows.Forms.Label _availableFieldLabel;
        private System.Windows.Forms.TreeView _selectedList;
        private System.Windows.Forms.Button _downButton;
        private System.Windows.Forms.Label _selectedFieldLabel;

        private Hashtable _eventTable;

        /// <summary>
        ///    Required designer variable.
        /// </summary>
        private static readonly Object _componentChangedEvent = new Object();

        internal InterchangeableLists()
        {
            // This call is required by the Windows.Forms Form Designer.
            InitializeComponent();

            // TODO: Add any initialization after the InitForm call
            _downButton.Image = GenericUI.SortDownIcon;
            _upButton.Image = GenericUI.SortUpIcon;
            UpdateButtonEnabling();

            this._eventTable = new Hashtable();
        }

        internal void SetTitles(
            String availableListTitle,
            String selectedListTitle)
        {
            this._selectedFieldLabel.Text = selectedListTitle;
            this._availableFieldLabel.Text = availableListTitle;
        }

        internal void AddToAvailableList(Object obj)
        {
            AddItem(_availableList, new TreeNode(obj.ToString()));
        }

        internal void AddToSelectedList(Object obj)
        {
            AddItem(_selectedList, new TreeNode(obj.ToString()));
        }

        internal void Initialize()
        {
            if (_availableList.Nodes.Count > 0)
            {
                _availableList.SelectedNode = _availableList.Nodes[0];
            }
            if (_selectedList.Nodes.Count > 0)
            {
                _selectedList.SelectedNode = _selectedList.Nodes[0];
            }
        }

        internal EventHandler OnComponentChanged
        {
            get 
            {
                return (EventHandler)_eventTable[_componentChangedEvent];
            }
            set 
            {
                _eventTable[_componentChangedEvent] = value;
            }
        }

        private void NotifyChangeEvent()
        {
            EventHandler handler = (EventHandler)_eventTable[_componentChangedEvent];
            if (handler != null)
            {
                handler.Invoke(this, EventArgs.Empty);
            }
        }

        internal void Clear()
        {
            _availableList.Nodes.Clear();
            _selectedList.Nodes.Clear();
        }

        internal ICollection GetSelectedItems()
        {
            ArrayList list = new ArrayList();

            foreach (TreeNode node in _selectedList.Nodes)
            {
                list.Add(node.Text);
            }
            return list;
        }

        /// <summary>
        ///    Required method for Designer support - do not modify 
        ///    the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this._removeButton = new System.Windows.Forms.Button();
            this._selectedFieldLabel = new System.Windows.Forms.Label();
            this._addButton = new System.Windows.Forms.Button();
            this._selectedList = new System.Windows.Forms.TreeView();
            this._availableList = new System.Windows.Forms.TreeView();
            this._availableFieldLabel = new System.Windows.Forms.Label();
            this._upButton = new System.Windows.Forms.Button();
            this._downButton = new System.Windows.Forms.Button();
            this._removeButton.Location = new System.Drawing.Point(166, 69);
            this._removeButton.Size = new System.Drawing.Size(32, 25);
            this._removeButton.TabIndex = 4;
            this._removeButton.Text = "<";
            this._removeButton.Click += new System.EventHandler(this.RemoveNode);
            this._selectedFieldLabel.Location = new System.Drawing.Point(202, 8);
            this._selectedFieldLabel.Size = new System.Drawing.Size(164, 16);
            this._selectedFieldLabel.TabIndex = 5;
            this._addButton.Location = new System.Drawing.Point(166, 40);
            this._addButton.Size = new System.Drawing.Size(32, 25);
            this._addButton.TabIndex = 3;
            this._addButton.Text = ">";
            this._addButton.Click += new System.EventHandler(this.AddNode);
            this._selectedList.HideSelection = false;
            this._selectedList.Indent = 15;
            this._selectedList.Location = new System.Drawing.Point(202, 24);
            this._selectedList.ShowLines = false;
            this._selectedList.ShowPlusMinus = false;
            this._selectedList.ShowRootLines = false;
            this._selectedList.Size = new System.Drawing.Size(154, 89);
            this._selectedList.TabIndex = 6;
            this._selectedList.DoubleClick += new System.EventHandler(this.RemoveNode);
            this._selectedList.AfterSelect += new System.Windows.Forms.TreeViewEventHandler(this.SelectedList_AfterSelect);
            this._availableList.HideSelection = false;
            this._availableList.Indent = 15;
            this._availableList.Location = new System.Drawing.Point(8, 24);
            this._availableList.ShowLines = false;
            this._availableList.ShowPlusMinus = false;
            this._availableList.ShowRootLines = false;
            this._availableList.Size = new System.Drawing.Size(154, 89);
            this._availableList.TabIndex = 2;
            this._availableList.DoubleClick += new System.EventHandler(this.AddNode);
            this._availableList.AfterSelect += new System.Windows.Forms.TreeViewEventHandler(this.AvailableList_AfterSelect);
            this._availableFieldLabel.Location = new System.Drawing.Point(8, 8);
            this._availableFieldLabel.Size = new System.Drawing.Size(164, 16);
            this._availableFieldLabel.TabIndex = 1;
            this._upButton.Location = new System.Drawing.Point(360, 24);
            this._upButton.Size = new System.Drawing.Size(28, 27);
            this._upButton.TabIndex = 7;
            this._upButton.Click += new System.EventHandler(this.Up_Click);
            this._downButton.Location = new System.Drawing.Point(360, 55);
            this._downButton.Size = new System.Drawing.Size(28, 27);
            this._downButton.TabIndex = 8;
            this._downButton.Click += new System.EventHandler(this.Down_Click);
            this.Controls.AddRange(new System.Windows.Forms.Control[] {this._availableFieldLabel,
                                                                          this._selectedFieldLabel,
                                                                          this._upButton,
                                                                          this._downButton,
                                                                          this._removeButton,
                                                                          this._selectedList,
                                                                          this._addButton,
                                                                          this._availableList});
            this.Size = new System.Drawing.Size(396, 119);

        }

        private void UpdateButtonEnabling()
        {
            bool anAvailableItemIsSelected = 
                (_availableList.SelectedNode != null);

            bool anSelectedItemIsSelected = 
                (_selectedList.SelectedNode != null);

            _addButton.Enabled = anAvailableItemIsSelected;
            _removeButton.Enabled = anSelectedItemIsSelected;

            if (anSelectedItemIsSelected)
            {
                int selectedIndex = _selectedList.SelectedNode.Index;
                _upButton.Enabled = (selectedIndex > 0);
                _downButton.Enabled = 
                    (selectedIndex < _selectedList.Nodes.Count - 1);
            }
            else
            {
                _downButton.Enabled = false;
                _upButton.Enabled = false;
            }
        }

        private void AddNode(object sender, System.EventArgs e)
        {
            TreeNode selectedNode = _availableList.SelectedNode;
            if (selectedNode != null)
            {
                RemoveItem(_availableList, selectedNode);
                AddItem(_selectedList, selectedNode);

                UpdateButtonEnabling();
                NotifyChangeEvent();
            }
        }

        private void RemoveItem(TreeView list, TreeNode node)
        {
            Debug.Assert (list.Nodes.Contains(node));

            int itemCount = list.Nodes.Count;
            int selectedIndex = list.SelectedNode.Index;

            list.Nodes.Remove(node);

            if (selectedIndex < itemCount - 1)
            {
                list.SelectedNode = list.Nodes[selectedIndex];
            }
            else if (selectedIndex >= 1)
            {
                list.SelectedNode = list.Nodes[selectedIndex-1];
            }
            else
            {
                Debug.Assert(itemCount == 1);
                list.SelectedNode = null;
            }
        }

        private void AddItem(TreeView list, TreeNode node)
        {
            Debug.Assert(node != null);

            list.Nodes.Add(node);
            list.SelectedNode = node;
            //_selectedList.Select();
        }

        private void RemoveNode(object sender, System.EventArgs e)
        {
            TreeNode selectedNode = _selectedList.SelectedNode;
            if (selectedNode != null)
            {
                RemoveItem(_selectedList, selectedNode);
                AddItem(_availableList, selectedNode);

                UpdateButtonEnabling();
            }

            //_availableList.Select();
            NotifyChangeEvent();
        }

        private void MoveItem(
            int direction /* 1 is up, -1 is down */)
        {
            Debug.Assert(direction == -1 || direction == 1);
            
            int selectedIndex = _selectedList.SelectedNode.Index;
            int newIndex = selectedIndex + direction;

            TreeNode node = _selectedList.SelectedNode;
            _selectedList.Nodes.RemoveAt(selectedIndex);
            _selectedList.Nodes.Insert(newIndex, node);
            _selectedList.SelectedNode = node;
        }

        private void Up_Click(object sender, System.EventArgs e)
        {
            MoveItem(-1);

            UpdateButtonEnabling();
            //_selectedList.Select();
            NotifyChangeEvent();
        }

        private void Down_Click(object sender, System.EventArgs e)
        {
            MoveItem(+1);

            UpdateButtonEnabling();
            //_selectedList.Select();
            NotifyChangeEvent();
        }

        private void AvailableList_AfterSelect(object sender, System.Windows.Forms.TreeViewEventArgs e)
        {
            UpdateButtonEnabling();
        }

        private void SelectedList_AfterSelect(object sender, System.Windows.Forms.TreeViewEventArgs e)
        {
            UpdateButtonEnabling();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\imagecreator.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageCreator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Util
{
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.IO;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class ImageCreator
    {
        const String _fontFamily = "Tahoma"; // default font used for the 
                                             // title and error message

        private static int GetHeight(
            String text,
            Font font,
            int width
        ) {
            // THISSUCKS: I need a bitmap to get a graphics object to measure
            // the string, but I can not create the bitmap I intend to return
            // until I know how big it needs to be...

            using(Bitmap bmp = new Bitmap(1,1))
            {
            using(Graphics g = Graphics.FromImage(bmp))
            {
                SizeF size = new SizeF(width, 0);
                size = g.MeasureString(text, font, size);
                return (int) (size.Height + 1);
            }} // using bmp, g
        }
        
        internal static void CreateBackgroundImage(
            ref TemporaryBitmapFile bmpFile,
            String controlID,
            String title,
            String message,
            bool infoMode,
            int controlWidth
        ) {
            // Really, anything this small is not practically going to
            // show readable text.  Truncate instead of trying to display
            // the string vertically.
            if(controlWidth < 75)
            {
                controlWidth = 75;
            }

            Bitmap errorIcon = infoMode? GenericUI.InfoIcon : GenericUI.ErrorIcon;
            
            bool showMessage = message != null && message.Length != 0;
            bool showTitle = (title != null && title.Length != 0)
                || (controlID != null && controlID.Length != 0);

            Debug.Assert(showMessage || showTitle);

            // REVIEW: Technically this breaks our indentation rules, but I
            //         argue it is more readable than indenting for each
            //         using statement.
            using(
                Font normalFont = new Font(_fontFamily, 8, FontStyle.Regular),
                boldFont = new Font(normalFont.FontFamily, 8, FontStyle.Bold)
            ) {
            using(
                Brush controlTextBrush = new SolidBrush(SystemColors.ControlText),
                controlDarkBrush = new SolidBrush(SystemColors.ControlDark),
                controlBrush = new SolidBrush(SystemColors.Control),
                windowBrush = new SolidBrush(SystemColors.Window)
            ) {
            using(
                Pen controlDarkPen = new Pen(SystemColors.ControlDark),
                windowPen = new Pen(SystemColors.Window)
            ) {
                int barHeight = 0;
                if(showTitle)
                {
                    // We do not measure the height of the real title because
                    // we inted to truncate rather than wrap.
                    barHeight = GetHeight(
                        "'",
                        normalFont,
                        (controlWidth - 30)
                    ) + 6;
                }
                int messageHeight = 0;
                if(showMessage)
                {
                    int textHeight = GetHeight(
                        message,
                        normalFont,
                        (controlWidth - 30)
                    );
                    messageHeight = (textHeight < (errorIcon.Height + 6)) ?
                        (errorIcon.Height + 6) : textHeight + 3;
                }

                int width = 500; // normally only 300px visible.
                int height = barHeight + messageHeight;

                Bitmap bitmap = new Bitmap(width, height);
                using(Graphics g = Graphics.FromImage(bitmap))
                {
                    if (showTitle)
                    {
                        // The rectangle area
                        g.FillRectangle(controlBrush, 0, 0, width, barHeight);
                        // The gray line below the controlID
                        g.DrawLine(controlDarkPen, 0, barHeight - 1, width, barHeight - 1);
                        // Draw the text "controlTypeName - controlID"
                        g.DrawString(controlID, boldFont, controlTextBrush, 2, 2);
                        if(title != null && title.Length > 0)
                        {
                            int strPelLen = (int) g.MeasureString(controlID, boldFont).Width;
                            g.DrawString(" - " + title, normalFont, controlTextBrush, 4 + strPelLen, 2);
                        }
                    }

                    if (showMessage)
                    {
                        // The transparent line between controlID and errormessage.
                        g.DrawLine(windowPen, 0, barHeight, width, barHeight);
                        // The message rectangle area
                        g.FillRectangle(controlDarkBrush, 0, barHeight + 1, width, messageHeight - 1);
                        // Draw the message text
                        g.DrawString(message, normalFont, windowBrush,
                            new RectangleF(20, barHeight + 1, controlWidth - 30, messageHeight - 1));
                        // Draw the icon
                        g.DrawImage(errorIcon, 2, barHeight + 3);
                    }

                    if(bmpFile == null)
                    {
                        bmpFile = new TemporaryBitmapFile(bitmap);
                    }
                    else
                    {
                        bmpFile.UnderlyingBitmap = bitmap;
                    }
                } // using g
            }}} // using Fonts, Brushes, and Pens
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\wbmpconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WbmpConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Util
{
    using System;
    using System.Drawing;
    using System.Diagnostics;
    
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class WbmpConverter
    {
        private static int ExtractMultiByte(Byte[] buffer, ref int cursor)
        {
            int sum = 0;
            do
            {
                sum <<= 7;
                sum += buffer[cursor] & 0x7F;
            }
            while((buffer[cursor++] & 0x80) != 0);
            return sum;
        }
        
        internal static Bitmap Convert(Byte[] buffer)
        {
            try
            {
                int cursor = 0;
                int type = buffer[cursor++];

                if(type != 0)
                {
                    Debug.Fail("Wbmp is not type 0. (Unsupported)");
                    return null;
                }
                
                int header = buffer[cursor++];
                int width = ExtractMultiByte(buffer, ref cursor);
                int height = ExtractMultiByte(buffer, ref cursor);

                Bitmap bitmap = new Bitmap(width, height);
                Byte mask = 0x80;

                for(int y = 0; y < height; y++)
                {
                    for(int x = 0; x < width; x++)
                    {
                        if((buffer[cursor] & mask) == 0)
                        {
                            bitmap.SetPixel(x, y, Color.Black);
                        }
                        else
                        {
                            bitmap.SetPixel(x, y, Color.White);
                        }
                        mask >>= 1;
                        if(mask == 0)
                        {
                           mask = 0x80;
                           cursor++;
                        }
                    }
                    // each row starts at the beginning of an octet
                    if(mask != 0x80)
                    {
                        mask = 0x80;
                        cursor++;
                    }
                }
                return bitmap;
            }
            catch
            {
                Debug.Fail("Wbmp file appears to be corrupt.");
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\unsettablecombobox.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsettableComboBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Util
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Windows.Forms;

    //   Standard combobox with a "Not Set" item as the first item in its dropdown.
    //   It also automatically blanks out the "Not Set" item on losing focus.
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class UnsettableComboBox : ComboBox 
    {
        private String notSetText;
        private String notSetCompactText;

        internal UnsettableComboBox() 
        {
            notSetText = SR.GetString(SR.UnsettableComboBox_NotSetText);
            notSetCompactText = SR.GetString(SR.UnsettableComboBox_NotSetCompactText);
        }

        internal String NotSetText 
        {
            get 
            {
                return notSetText;
            }
            set 
            {
                notSetText = value;
            }
        }

        internal String NotSetCompactText 
        {
            get 
            {
                return notSetCompactText;
            }
            set 
            {
                notSetCompactText = value;
            }
        }

        public override String Text 
        {
            get 
            {
                // handle DropDown styles in Templating Options dialog
                // if (this.SelectedIndex == 0) || (this.SelectedIndex == -1))
                if (this.SelectedIndex == 0)
                {
                    return String.Empty;
                }
                else
                {
                    return base.Text;
                }
            }

            set 
            {
                if (value == notSetCompactText)
                {
                    base.Text = String.Empty;
                }
                else
                {
                    base.Text = value;
                }
            }
        }

        internal void AddItem(Object item) 
        {
            EnsureNotSetItem();
            Items.Add(item);
        }

        internal void EnsureNotSetItem() 
        {
            if (Items.Count == 0) 
            {
                Items.Add(notSetText);
            }
        }

        internal bool IsSet() 
        {
            return SelectedIndex > 0;
        }

        protected override void OnLostFocus(EventArgs e) 
        {
            base.OnLostFocus(e);

            if (SelectedIndex == 0)
            {
                SelectedIndex = -1;
            }
        }

        protected override void SetItemsCore(IList values)
        {
            Items.Clear();
            
            if (!DesignMode) 
            {
                Items.Add(notSetText);
            }
            
            // Unfortunately. the interfaces between SetItemsCore and
            // AddItemsCore are mismatched as of 3106.
            ArrayList items = new ArrayList();
            foreach(Object item in values)
            {
                items.Add(item);
            }
            
            base.AddItemsCore(items.ToArray());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\resources\system\net\_networkingperfcounters.h ===
//------------------------------------------------------------------------------
// <copyright file="_NetworkingPerfCounters.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   _NetworkingPerfCounters.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#define OBJECT_1 0;
#define DEVICE_COUNTER_1 2;
#define DEVICE_COUNTER_2 4;
#define DEVICE_COUNTER_3 6;
#define DEVICE_COUNTER_4 8;
#define DEVICE_COUNTER_5 10;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\mshtmlhost.cs ===
//------------------------------------------------------------------------------
// <copyright file="MSHTMLHost.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// MSHTMLHost.cs
//
// 12/17/98: Created: NikhilKo
//

namespace System.Web.UI.Design.MobileControls.Util {
    using System.Runtime.Serialization.Formatters;
    
    using System.Runtime.InteropServices;
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using System.Design;
    
    using Microsoft.Win32;    
    using System.Windows.Forms;

    /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="MSHTMLHost"]/*' />
    /// <devdoc>
    ///    Control that hosts a Trident DocObject.
    /// </devdoc>
    /// <internalonly/>
    // TODO: Change the interface wrappers to return an HRESULT instead of throwing
    //    exceptions for E_NOTIMPL
    //
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class MSHTMLHost : Control 
    {
        private TridentSite tridentSite;

        internal MSHTMLHost() : base() {
        }

        public NativeMethods.IHTMLDocument2 GetDocument() {
            Debug.Assert(tridentSite != null,
                         "Cannot call getDocument before calling createTrident");

            return tridentSite.GetDocument();
        }

        protected override CreateParams CreateParams {
             get {
                CreateParams cp = base.CreateParams;

                cp.ExStyle |= NativeMethods.WS_EX_STATICEDGE;
                return cp;
            }
        }

        internal bool CreateTrident() {
            Debug.Assert(Handle != IntPtr.Zero,
                         "MSHTMLHost must first be created before createTrident is called");

            try {
                tridentSite = new TridentSite(this);
            }
            catch (Exception e) {
                Debug.WriteLine("Exception caught in MSHTMLHost::CreateTrident\n\t" + e.ToString());
                return false;
            }
            return true;
        }

        internal void CloseTrident() {
            if (tridentSite != null) {
                tridentSite.Close();
                tridentSite = null;
            }
        }

        internal void ActivateTrident() {
            Debug.Assert(tridentSite != null,
                         "cannot call activateTrident before calling createTrident");

            tridentSite.Activate();
        }
    }


    /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite"]/*' />
    /// <devdoc>
    ///    Implements the client site for Trident DocObject
    /// </devdoc>
    [ClassInterface(ClassInterfaceType.None)]
    internal class TridentSite : NativeMethods.IOleClientSite, NativeMethods.IOleDocumentSite, NativeMethods.IOleInPlaceSite, NativeMethods.IOleInPlaceFrame, NativeMethods.IDocHostUIHandler {

        protected Control parentControl;
        protected NativeMethods.IOleDocumentView tridentView;
        protected NativeMethods.IOleObject tridentOleObject;
        protected NativeMethods.IHTMLDocument2 tridentDocument;

        protected EventHandler resizeHandler;

        internal TridentSite(Control parent) {
            Debug.Assert((parent != null) && (parent.Handle != IntPtr.Zero),
                         "Invalid control passed in as parent of Trident window");

            parentControl = parent;
            resizeHandler = new EventHandler(this.OnParentResize);
            parentControl.Resize += resizeHandler;

            CreateDocument();
        }

        internal void Close() {
            parentControl.Resize -= resizeHandler;
            CloseDocument();
        }

        public NativeMethods.IHTMLDocument2 GetDocument() {
            return tridentDocument;
        }

        internal void Activate() {
            ActivateDocument();
        }

        protected virtual void OnParentResize(object src, EventArgs e) {
            if (tridentView != null) {
                NativeMethods.COMRECT r = new NativeMethods.COMRECT();

                NativeMethods.GetClientRect(parentControl.Handle, r);
                tridentView.SetRect(r);
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleClientSite Implementation

        public virtual void SaveObject() {
        }

        public virtual object GetMoniker(int dwAssign, int dwWhichMoniker) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual int GetContainer(out NativeMethods.IOleContainer ppContainer) {
            ppContainer = null;
            return NativeMethods.E_NOINTERFACE;
        }

        public virtual void ShowObject() {
        }

        public virtual void OnShowWindow(int fShow) {
        }

        public virtual void RequestNewObjectLayout() {
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleDocumentSite Implementation

        public virtual int ActivateMe(NativeMethods.IOleDocumentView pViewToActivate) {
            Debug.Assert(pViewToActivate != null,
                         "Expected the view to be non-null");
            if (pViewToActivate == null)
                return NativeMethods.E_INVALIDARG;

            NativeMethods.COMRECT r = new NativeMethods.COMRECT();

            NativeMethods.GetClientRect(parentControl.Handle, r);

            tridentView = pViewToActivate;
            tridentView.SetInPlaceSite((NativeMethods.IOleInPlaceSite)this);
            tridentView.UIActivate(1);
            tridentView.SetRect(r);
            tridentView.Show(1);

            return NativeMethods.S_OK;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleInPlaceSite Implementation

        public virtual IntPtr GetWindow() {
            return parentControl.Handle;
        }

        public virtual void ContextSensitiveHelp(int fEnterMode) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual int CanInPlaceActivate() {
            return NativeMethods.S_OK;
        }

        public virtual void OnInPlaceActivate() {
        }

        public virtual void OnUIActivate() {
        }

        public virtual void GetWindowContext(out NativeMethods.IOleInPlaceFrame ppFrame, out NativeMethods.IOleInPlaceUIWindow ppDoc, NativeMethods.COMRECT lprcPosRect, NativeMethods.COMRECT lprcClipRect, NativeMethods.tagOIFI lpFrameInfo) {

            ppFrame = (NativeMethods.IOleInPlaceFrame)this;
            ppDoc = null;

            NativeMethods.GetClientRect(parentControl.Handle, lprcPosRect);
            NativeMethods.GetClientRect(parentControl.Handle, lprcClipRect);

            lpFrameInfo.cb = System.Runtime.InteropServices.Marshal.SizeOf(typeof(NativeMethods.tagOIFI));
            lpFrameInfo.fMDIApp = 0;
            lpFrameInfo.hwndFrame = parentControl.Handle;
            lpFrameInfo.hAccel = IntPtr.Zero;
            lpFrameInfo.cAccelEntries = 0;
        }

        public virtual int Scroll(NativeMethods.tagSIZE scrollExtant) {
            return(NativeMethods.E_NOTIMPL);
        }

        public virtual void OnUIDeactivate(int fUndoable) {
            // NOTE, nikhilko, 7/99: Don't return E_NOTIMPL. Somehow doing nothing and returning S_OK
            //    fixes trident hosting in Win2000.
        }

        public virtual void OnInPlaceDeactivate() {
        }

        public virtual void DiscardUndoState() {
            throw new COMException("Not implemented", NativeMethods.E_NOTIMPL);
        }

        public virtual void DeactivateAndUndo() {
        }

        public virtual int OnPosRectChange(NativeMethods.COMRECT lprcPosRect) {
            return NativeMethods.S_OK;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleInPlaceFrame Implementation

        public virtual void GetBorder(NativeMethods.COMRECT lprectBorder) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void RequestBorderSpace(NativeMethods.COMRECT pborderwidths) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetBorderSpace(NativeMethods.COMRECT pborderwidths) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetActiveObject(NativeMethods.IOleInPlaceActiveObject pActiveObject, string pszObjName) {
            // NOTE, nikhilko, 7/99: Don't return E_NOTIMPL. Somehow doing nothing and returning S_OK
            //    fixes trident hosting in Win2000.
            // throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void InsertMenus(IntPtr hmenuShared, object lpMenuWidths) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetMenu(IntPtr hmenuShared, IntPtr holemenu, IntPtr hwndActiveObject) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void RemoveMenus(IntPtr hmenuShared) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetStatusText(string pszStatusText) {
        }

        public virtual void EnableModeless(int fEnable) {
        }

        public virtual int TranslateAccelerator(ref NativeMethods.MSG lpmsg, short wID) {
            return NativeMethods.S_FALSE;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IDocHostUIHandler Implementation

        public virtual int ShowContextMenu(int dwID, NativeMethods.POINT pt, object pcmdtReserved, object pdispReserved) {
            return NativeMethods.S_OK;
        }

        public virtual int GetHostInfo(NativeMethods.DOCHOSTUIINFO info) {
            info.dwDoubleClick = NativeMethods.DOCHOSTUIDBLCLICK.DEFAULT;
            info.dwFlags = NativeMethods.DOCHOSTUIFLAG.FLAT_SCROLLBAR |
                           NativeMethods.DOCHOSTUIFLAG.NO3DBORDER |
                           NativeMethods.DOCHOSTUIFLAG.DIALOG |
                           NativeMethods.DOCHOSTUIFLAG.DISABLE_SCRIPT_INACTIVE;

            return NativeMethods.S_OK;
        }

        public virtual int EnableModeless(bool fEnable) {
            return NativeMethods.S_OK;
        }

        public virtual int ShowUI(int dwID, NativeMethods.IOleInPlaceActiveObject activeObject, NativeMethods.IOleCommandTarget commandTarget, NativeMethods.IOleInPlaceFrame frame, NativeMethods.IOleInPlaceUIWindow doc) {
            return NativeMethods.S_OK;
        }

        public virtual int HideUI() {
            return NativeMethods.S_OK;
        }

        public virtual int UpdateUI() {
            return NativeMethods.S_OK;
        }

        public virtual int OnDocWindowActivate(bool fActivate) {
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int OnFrameWindowActivate(bool fActivate) {
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int ResizeBorder(NativeMethods.COMRECT rect, NativeMethods.IOleInPlaceUIWindow doc, bool fFrameWindow) {
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int GetOptionKeyPath(string[] pbstrKey, int dw) {
            pbstrKey[0] = null;
            return NativeMethods.S_OK;
        }

        public virtual int GetDropTarget(NativeMethods.IOleDropTarget pDropTarget, out NativeMethods.IOleDropTarget ppDropTarget) {
            ppDropTarget = null;
            return NativeMethods.S_FALSE;
        }

        public virtual int GetExternal(out object ppDispatch) {
            ppDispatch = null;
            return NativeMethods.S_OK;
        }

        public virtual int TranslateAccelerator(ref NativeMethods.MSG msg, ref Guid group, int nCmdID) {
            return NativeMethods.S_OK;
        }

        public virtual int TranslateUrl(int dwTranslate, string strUrlIn, out string pstrUrlOut) {
            pstrUrlOut = null;
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int FilterDataObject(NativeMethods.IOleDataObject pDO, out NativeMethods.IOleDataObject ppDORet) {
            ppDORet = null;
            return NativeMethods.S_OK;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Implementation

        /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite.CreateDocument"]/*' />
        /// <devdoc>
        ///     Creates a new instance of mshtml and initializes it as a new document
        ///     using its IPersistStreamInit.
        /// </devdoc>
        protected void CreateDocument() {

            try {
                // Create an instance of Trident
                tridentDocument = (NativeMethods.IHTMLDocument2)new NativeMethods.HTMLDocument();
                tridentOleObject = (NativeMethods.IOleObject)tridentDocument;

                // Initialize its client site
                tridentOleObject.SetClientSite((NativeMethods.IOleClientSite)this);

                // Initialize it
                NativeMethods.IPersistStreamInit psi = (NativeMethods.IPersistStreamInit)tridentDocument;
                psi.InitNew();
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
                throw e;
            }
        }

        /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite.CloseDocument"]/*' />
        /// <devdoc>
        ///     Closes the mshtml instance by deactivating and releasing it.
        /// </devdoc>
        protected void CloseDocument() {
            try {
                if (tridentDocument != null) {
                    tridentView = null;
                    tridentDocument = null;

                    tridentOleObject.Close(NativeMethods.OLECLOSE_NOSAVE);
                    tridentOleObject.SetClientSite(null);
                    tridentOleObject = null;
                }
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
            }
        }

        /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite.ActivateDocument"]/*' />
        /// <devdoc>
        ///     Activates the mshtml instance
        /// </devdoc>
        protected void ActivateDocument() {
            Debug.Assert(tridentOleObject != null,
                         "How'd we get here when trident is null!");

            try {
                NativeMethods.COMRECT r = new NativeMethods.COMRECT();

                NativeMethods.GetClientRect(parentControl.Handle, r);
                tridentOleObject.DoVerb(NativeMethods.OLEIVERB_UIACTIVATE, IntPtr.Zero, (NativeMethods.IOleClientSite)this, 0, parentControl.Handle, r);
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\temporarybitmapfile.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemporaryBitmapFile.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Util
{
    using System;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Imaging;
    using System.IO;

    /// <summary>
    ///    This class encapsulates a bitmap and a file that represents
    ///    the bitmap on disk.  It would have been cleaner to subclass
    ///    bitmap, but the bitmap class is sealed.
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class TemporaryBitmapFile : IDisposable
    {
        private String _path;
        private Bitmap _bitmap;

        internal TemporaryBitmapFile(Bitmap bitmap)
        {
            Debug.Assert(bitmap != null,
                "You must provide a valid bitmap object."
            );
            _bitmap = bitmap;
            _path = Path.GetTempPath() + Guid.NewGuid().ToString() + ".bmp";
            Sync();
        }

        public void Dispose()
        {
            if(_bitmap != null)
            {
                _bitmap.Dispose();
                _bitmap = null;
            }
            if(_path != null)
            {
                FileAttributes fa = File.GetAttributes(_path);
                File.SetAttributes(_path, fa & ~FileAttributes.ReadOnly);
                File.Delete(_path);
                _path = null;
            }
        }

        private void Sync()
        {
            FileAttributes fa;

            if(File.Exists(_path))
            {
                fa = File.GetAttributes(_path);
                File.SetAttributes(_path, fa & ~FileAttributes.ReadOnly);
            }

            _bitmap.Save(_path, ImageFormat.Bmp);

            // If the file did not exist previously, fa will not be valid.
            fa = File.GetAttributes(_path);
            File.SetAttributes(_path,  fa | FileAttributes.ReadOnly);
        }

        internal String Url
        {
            get
            {
                return "file:///" + _path;
            }
        }

        internal Bitmap UnderlyingBitmap
        {
            get
            {
                return _bitmap;
            }
            set
            {
                Debug.Assert(value != null,
                    "Do not set UnderlyingBitmap to null.  Instead, "+
                    "dispose of this object and create a new one later if " +
                    "neccessary.  (A zero sized bmp can not be written to disk)"
                );
                if(_bitmap != null)
                {
                    _bitmap.Dispose();
                }
                _bitmap = value;
                Sync();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\simpleparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="SimpleParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Collections;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using System.Web.RegularExpressions;
using System.Web.Util;
using System.Web.UI.MobileControls;

namespace System.Web.UI.Design.MobileControls.Util
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class SimpleParser : BaseParser
    {
        private const int _stackInitialSize = 100;
        private static Regex _unclosedTagRegex = null;

        private const RegexOptions _options = 
            RegexOptions.Singleline | RegexOptions.Multiline;

        private const String _pattern = 
            "\\G<(?<tagname>[\\w:\\.]+)" +
            "(" +
            "\\s+(?<attrname>[-\\w]+)(" +           // Attribute name
            "\\s*=\\s*\"(?<attrval>[^\"]*)\"|" +    // ="bar" attribute value
            "\\s*=\\s*'(?<attrval>[^']*)'|" +       // ='bar' attribute value
            "\\s*=\\s*(?<attrval><%#.*?%>)|" +      // =<%#expr%> attribute value
            "\\s*=\\s*(?<attrval>[^\\s=/>]*)|" +    // =bar attribute value
            "(?<attrval>\\s*?)" +                   // no attrib value (with no '=')
            ")" +
            ")*" +
            "\\s*(?<empty>)?>";
        //"\\s*(?<empty>/)?>";

        private static ElementTable _endTagOptionalElement = null;

        private readonly static Regex _tagRegex = new TagRegex();
        private readonly static Regex _directiveRegex = new DirectiveRegex();
        private readonly static Regex _endtagRegex = new EndTagRegex();
        private readonly static Regex _aspCodeRegex = new AspCodeRegex();
        private readonly static Regex _aspExprRegex = new AspExprRegex();
        private readonly static Regex _databindExprRegex = new DatabindExprRegex();
        private readonly static Regex _commentRegex = new CommentRegex();
        private readonly static Regex _includeRegex = new IncludeRegex();
        private readonly static Regex _textRegex = new TextRegex();

        // Regexes used in DetectSpecialServerTagError
        private readonly static Regex _gtRegex = new GTRegex();
        private readonly static Regex _ltRegex = new LTRegex();
        private readonly static Regex _serverTagsRegex = new ServerTagsRegex();
        private readonly static Regex _runatServerRegex = new RunatServerRegex();

/* Regex patterns
        AspCodeRegex : \G<%(?!@)(?<code>.*?)%>
        AspExprRegex : \G<%\s*?=(?<code>.*?)?%>
        CommentRegex : \G<%--(([^-]*)-)*?-%>
        DataBindExprRegex : \G<%#(?<code>.*?)?%>
        DirectiveRegex : \G<%\s*@(\s*(?<attrname>\w+(?=\W))(\s*(?<equal>=)\s*"(?<attrval>[^"]*)"|\s*(?<equal>=)\s*'(?<attrval>[^']*)'|\s*(?<equal>=)\s*(?<attrval>[^\s%>]*)|(?<equal>)(?<attrval>\s*?)))*\s*?%>
        EndTagRegex : \G</(?<tagname>[\w:\.]+)\s*>
        GTRegex : [^%]>
        IncludeRegex : \G<!--\s*#(?i:include)\s*(?<pathtype>[\w]+)\s*=\s*["']?(?<filename>[^\"']*?)["']?\s*-->
        LTRegex : <
        RunATServerRegex : runat\W*server
        ServerTagsRegex : <%(?!#)(([^%]*)%)*?>
        TagRegex : \G<(?<tagname>[\w:\.]+)(\s+(?<attrname>[-\w]+)(\s*=\s*"(?<attrval>[^"]*)"|\s*=\s*'(?<attrval>[^']*)'|\s*=\s*(?<attrval><%#.*?%>)|\s*=\s*(?<attrval>[^\s=/>]*)|(?<attrval>\s*?)))*\s*(?<empty>/)?>
        TextRegex : \G[^<]+
                    
        //SimpleDirectiveRegex simpleDirectiveRegex = new SimpleDirectiveRegex();
*/
        static SimpleParser()
        {
            _unclosedTagRegex = new Regex(_pattern, _options);
            _endTagOptionalElement = new ElementTable();

            /* following defnitions from MSDN Online WorkShop
                http://msdn.microsoft.com/workshop/c-frame.htm#/workshop/author/default.asp
            */
            _endTagOptionalElement.AddRange(
                new String[] {
                                 "area", "base", "basefront", "bgsound", "br",
                                 "col", "colgroup", "dd", "dt", "embed", "frame",
                                 "hr", "img", "input", "isindex", "li", "link",
                                 "meta", "option", "p", "param", "rt"
                             });
                             
        }

        /// <summary>
        ///     Simple parsing to check if input fragment is well-formed,
        ///     HTML elements that do not required end tags (i.e. <BR>)
        ///     will be ignored by this parser.
        /// </summary>
        /// <param name="text">
        ///     text being parsed
        /// </param>
        internal static bool IsWellFormed(String text)
        {
            int textPos = 0;
            TagStack stack = new TagStack();
            StringBuilder builder = new StringBuilder();

            for (;;) 
            {
                Match match = null;

                // 1: scan for text up to the next tag.
                if ((match = _textRegex.Match(text, textPos)).Success)
                {
                    textPos = match.Index + match.Length;
                }

                // we might be done now
                if (textPos == text.Length)
                {
                    while (!stack.IsEmpty())
                    {
                        if (!IsEndTagOptional(stack.Pop()))
                        {
                            return false;
                        }
                    }
                    return true;
                }

                // First check if it's a unclosed tag (i.e. <mobile:Form >)
                if ((match = _unclosedTagRegex.Match(text, textPos)).Success)
                {
                    String startTag = match.Groups["tagname"].Value;
                    stack.Push(startTag);
                }

                // Check to see if it's a tag
                else if ((match = _tagRegex.Match(text, textPos)).Success)
                {
                    // skip
                }

                // Check to see if it's an end tag
                else if ((match = _endtagRegex.Match(text, textPos)).Success)
                {
                    String endTag = match.Groups["tagname"].Value;
                    bool matched = false;

                    while (!stack.IsEmpty())
                    {
                        String startTag = stack.Pop();

                        if (String.Compare(endTag, startTag, true /*ignoreCase*/, CultureInfo.InvariantCulture) != 0)
                        {
                            if (IsEndTagOptional(startTag))
                            {
                                continue;
                            }

                            // no match against start tag that requires an end tag
                            return false;
                        }

                        // we found a match here.
                        matched = true;
                        break;
                    }

                    if (!matched && stack.IsEmpty())
                    {
                        return false;
                    }
                }

                // Check to see if it's a directive (i.e. <%@ %> block)
                else if ((match = _directiveRegex.Match(text, textPos)).Success)
                {
                    // skip
                }

                // Check to see if it's a server side include
                // e.g. <!-- #include file="foo.inc" -->
                else if ((match = _includeRegex.Match(text, textPos)).Success)
                {
                    // skip it
                }

                // Check to see if it's a comment (<%-- --%> block
                // e.g. <!-- Blah! -->
                else if ((match = _commentRegex.Match(text, textPos)).Success)
                {
                    // skip
                }

                // Check to see if it's an asp expression block (i.e. <%= %> block)
                else if ((match = _aspExprRegex.Match(text, textPos)).Success)
                {
                    // skip
                }

                // Check to see if it's a databinding expression block (i.e. <%# %> block)
                // This does not include <%# %> blocks used as values for
                // attributes of server tags.
                else if ((match = _databindExprRegex.Match(text, textPos)).Success)
                {
                    // skip
                }

                // Check to see if it's an asp code block
                else if ((match = _aspCodeRegex.Match(text, textPos)).Success)
                {
                    // skip
                }

                // Did we process the block that started with a '<'?
                if (match == null || !match.Success) 
                {
                    // Skip the '<'
                    textPos++;
                }
                else 
                {
                    textPos = match.Index + match.Length;
                }

                // we might be done now
                if (textPos == text.Length)
                {
                    while (!stack.IsEmpty())
                    {
                        if (!IsEndTagOptional(stack.Pop()))
                        {
                            return false;
                        }
                    }
                    return true;
                }
            }
        }

        private static bool IsEndTagOptional(String element)
        {
            return (_endTagOptionalElement.Contains(element));
        }
    
        /// <summary>
        ///     Private class used to store lowercase tags in a stack
        ///     return String.Empty if stack is empty 
        /// </summary>
        [
            System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        private class TagStack
        {
            private Stack _tagStack = null;

            internal TagStack() : this(_stackInitialSize) 
            {
            }

            internal TagStack(int initialCapacity)
            {
                _tagStack = new Stack(initialCapacity);
            }

            internal void Push(String tagName)
            {
                _tagStack.Push(tagName.ToLower(CultureInfo.InvariantCulture));
            }

            internal String Pop()
            {
                if (IsEmpty())
                {
                    return String.Empty;
                }
                return (String)_tagStack.Pop();
            }

            internal bool IsEmpty()
            {
                return (_tagStack.Count == 0);
            }
        }

        /// <summary>
        ///     Private class used to store recognizable lowercase elements
        ///     return true if element is in the list, otherwise false 
        /// </summary>
        [
            System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
            Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        private class ElementTable
        {
            private Hashtable _table = null;

            internal ElementTable() : this(_stackInitialSize) 
            {}

            internal ElementTable(int initialCapacity)
            {
                _table = new Hashtable(initialCapacity);
            }

            internal void Add(String key)
            {
                _table.Add(key.ToLower(CultureInfo.InvariantCulture), true);
            }

            internal bool Contains(String key)
            {
                return (_table.Contains(key.ToLower(CultureInfo.InvariantCulture)));
            }

            internal void AddRange(String[] keysCollection)
            {
                foreach (String key in keysCollection)
                {
                    this.Add(key);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\uribuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="uribuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System {

    using System.Text;
    using System.Globalization;

    /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class UriBuilder {

    // fields

        private bool m_changed = true;
        private string m_fragment = String.Empty;
        private string m_host = "loopback";
        private string m_password = String.Empty;
        private string m_path = "/";
        private int m_port = -1;
        private string m_query = String.Empty;
        private string m_scheme = "http";
        private string m_schemeDelimiter = "://";
        private Uri m_uri;
        private string m_username = String.Empty;

    // constructors

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.UriBuilder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public UriBuilder() {
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.UriBuilder1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public UriBuilder(string uri) {

            bool supplyHttpDefault = false;
            int  schemeEnd = uri.IndexOf(':');

            if (schemeEnd == -1) {   //no scheme
                supplyHttpDefault = true;
            }
            else if (schemeEnd > 0) {
                string scheme = uri.Substring(0,schemeEnd);
                if (Uri.SchemeHasSlashes(scheme)) { //exclude mailto/news
                    schemeEnd = uri.IndexOf(Uri.SchemeDelimiter);
                    if (schemeEnd == -1) {
                        supplyHttpDefault = true;
                    }
                }
            }

            if (supplyHttpDefault) {
                uri = Uri.UriSchemeHttp + Uri.SchemeDelimiter + uri;
            }

            Init(new Uri(uri));
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.UriBuilder2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public UriBuilder(Uri uri) {
            Init(uri);
        }

        private void Init(Uri uri) {
            m_fragment = uri.Fragment;
            m_query = uri.Query;
            m_host = uri.Host;
            m_path = uri.AbsolutePath;
            m_port = uri.Port;
            m_scheme = uri.Scheme;
            m_schemeDelimiter = Uri.SchemeHasSlashes(m_scheme) ? "://" : ":";
            //m_uri = (Uri)uri.MemberwiseClone();

            string userInfo = uri.UserInfo;

            if (userInfo != String.Empty) {

                int index = userInfo.IndexOf(':');

                if (index != -1) {
                    m_password = userInfo.Substring(index + 1);
                    m_username = userInfo.Substring(0, index);
                }
                else {
                    m_username = userInfo;
                }
            }
            SetFieldsFromUri(uri);
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.UriBuilder3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public UriBuilder(string schemeName, string hostName) {
            Scheme = schemeName;
            Host = hostName;
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.UriBuilder4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public UriBuilder(string scheme, string host, int portNumber) : this(scheme, host) {
            try {
                Port = portNumber;
            }
            catch {
                throw new ArgumentOutOfRangeException("portNumber");
            }
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.UriBuilder5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public UriBuilder(string scheme,
                          string host,
                          int port,
                          string pathValue
                          ) : this(scheme, host, port)
        {
            bool escaped;
            Path = Uri.EscapeString(ConvertSlashes(pathValue), false, out escaped);
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.UriBuilder6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public UriBuilder(string scheme,
                          string host,
                          int port,
                          string path,
                          string extraValue
                          ) : this(scheme, host, port, path)
        {
            try {
                Extra = extraValue;
            }
            catch {
                throw new ArgumentException("extraValue");
            }
        }

    // properties

        private string Extra {
            set {
                if (value == null) {
                    value = String.Empty;
                }
                if (value.Length > 0) {
                    if (value[0] == '#') {
                        Fragment = value.Substring(1);
                    }
                    else if (value[0] == '?') {
                        int end = value.IndexOf('#');
                        if (end == -1) {
                            end = value.Length;
                        }
                        else {
                            Fragment = value.Substring(end+1);
                        }
                        Query = value.Substring(1, end-1);
                    } else {
                        throw new ArgumentException("value");
                    }
                }
                else {
                    Fragment = String.Empty;
                    Query = String.Empty;
                }
            }
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.Fragment"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Fragment {
            get {
                return m_fragment;
            }
            set {
                if (value == null) {
                    value = String.Empty;
                }
                if (value.Length > 0) {
                    value = '#' + value;
                }
                m_fragment = value;
                m_query = String.Empty;
                m_changed = true;
            }
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.Host"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Host {
            get {
                return m_host;
            }
            set {
                if (value == null) {
                    value = String.Empty;
                }
                m_host = value;

                //probable ipv6 address
                if (m_host.IndexOf(':') >= 0) {
                    //set brackets
                    if (m_host[0] != '[')
                        m_host = "[" + m_host + "]";
                }

                m_changed = true;
            }
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.Password"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Password {
            get {
                return m_password;
            }
            set {
                if (value == null) {
                    value = String.Empty;
                }
                m_password = value;
            }
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.Path"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Path {
            get {
                return m_path;
            }
            set {
                if ((value == null) || (value.Length == 0)) {
                    value = "/";
                }
                //if ((value[0] != '/') && (value[0] != '\\')) {
                //    value = '/' + value;
                //}
                bool escaped;
                m_path = Uri.EscapeString(ConvertSlashes(value), false, out escaped);
                m_changed = true;
            }
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.Port"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Port {
            get {
                return m_port;
            }
            set {
                if (value < 0) {
                    throw new ArgumentOutOfRangeException("value");
                }
                m_port = value;
                m_changed = true;
            }
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.Query"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Query {
            get {
                return m_query;
            }
            set {
                if (value == null) {
                    value = String.Empty;
                }
                if (value.Length > 0) {
                    value = '?' + value;
                }
                m_query = value;
                m_fragment = String.Empty;
                m_changed = true;
            }
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.Scheme"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Scheme {
            get {
                return m_scheme;
            }
            set {
                if (value == null) {
                    value = String.Empty;
                }

                int index = value.IndexOf(':');

                if (index != -1) {
                    value = value.Substring(0, index);
                }
                m_scheme = value.ToLower(CultureInfo.InvariantCulture);
                m_schemeDelimiter = Uri.SchemeHasSlashes(value) ? "://" : ":";
                m_changed = true;
            }
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.Uri"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Uri Uri {
            get {
                if (m_changed) {
                    m_uri = new Uri(ToString());
                    SetFieldsFromUri(m_uri);
                    m_changed = false;
                }
                return m_uri;
            }
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.UserName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string UserName {
            get {
                return m_username;
            }
            set {
                if (value == null) {
                    value = String.Empty;
                }
                m_username = value;
            }
        }

    // methods

        private string ConvertSlashes(string path) {

            StringBuilder sb = new StringBuilder(path.Length);
            char ch;

            for (int i = 0; i < path.Length; ++i) {
                ch = path[i];
                if (ch == '\\') {
                    ch = '/';
                }
                sb.Append(ch);
            }
            return sb.ToString();
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(object rparam) {
            if (rparam == null) {
                return false;
            }
            return Uri.Equals(rparam.ToString());
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return Uri.GetHashCode();
        }

        private void SetFieldsFromUri(Uri uri) {
            m_fragment = uri.Fragment;
            m_query = uri.Query;
            m_host = uri.Host;
            m_path = uri.AbsolutePath;
            m_port = uri.Port;
            m_scheme = uri.Scheme;
            m_schemeDelimiter = Uri.SchemeHasSlashes(m_scheme) ? "://" : ":";
            //m_uri = (Uri)uri.MemberwiseClone();

            string userInfo = uri.UserInfo;

            if (userInfo.Length > 0) {

                int index = userInfo.IndexOf(':');

                if (index != -1) {
                    m_password = userInfo.Substring(index + 1);
                    m_username = userInfo.Substring(0, index);
                }
                else {
                    m_username = userInfo;
                }
            }
        }

        /// <include file='doc\uribuilder.uex' path='docs/doc[@for="UriBuilder.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string ToString() {

            if (m_username.Length == 0 && m_password.Length > 0) {
                throw new UriFormatException(SR.GetString(SR.net_uri_BadUserPassword));
            }

            return m_scheme
                    + m_schemeDelimiter
                    + m_username
                    + ((m_password.Length > 0) ? (":" + m_password) : String.Empty)
                    + ((m_username.Length > 0) ? "@" : String.Empty)
                    + m_host
                    + (((m_port != -1) && (m_host.Length > 0)) ? (":" + m_port) : String.Empty)
                    + (((m_host.Length > 0) && (m_path.Length != 0) && (m_path[0] != '/')) ? "/" : String.Empty) + m_path
                    + m_fragment
                    + m_query;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\uriformatexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="URIFormatException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System {
    using System.Runtime.Serialization;
    /// <include file='doc\URIFormatException.uex' path='docs/doc[@for="UriFormatException"]/*' />
    /// <devdoc>
    ///    <para>
    ///       An exception class used when an invalid Uniform Resource Identifier is detected.
    ///    </para>
    /// </devdoc>
    [Serializable]
    public class UriFormatException : FormatException, ISerializable {

        // constructors

        /// <include file='doc\URIFormatException.uex' path='docs/doc[@for="UriFormatException.UriFormatException"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public UriFormatException() : base() {
        }

        /// <include file='doc\URIFormatException.uex' path='docs/doc[@for="UriFormatException.UriFormatException1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public UriFormatException(string textString) : base(textString) {
        }

        /// <include file='doc\URIFormatException.uex' path='docs/doc[@for="UriFormatException.UriFormatException2"]/*' />
        protected UriFormatException(SerializationInfo serializationInfo, StreamingContext streamingContext)
            : base(serializationInfo, streamingContext) {
        }

        /// <include file='doc\URIFormatException.uex' path='docs/doc[@for="UriFormatException.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            base.GetObjectData(serializationInfo, streamingContext);
        }

        // accessors

        // methods

        // data

    }; // class UriFormatException


} // namespace System
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\tools\gensr.cs ===
//------------------------------------------------------------------------------
// <copyright from='2000' to='2001' company='Microsoft Corporation'>
//    Copyright (c) Microsoft Corporation. All Rights Reserved.
//    Information Contained Herein is Proprietary and Confidential.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.IO;

// Generate SR namespace given a resource file

public class SRGenerator
{
    static String _infile, _outfile, _resfile, _namespace, _class, _protectLevel;

    // Template _headerFormat and _footerFormat are at the bottom.

    
    public static int Main(String[] args)
    {
        if (args.Length != 5)
        {
            System.Console.WriteLine("Usage: GenSr <infile> <outfile> <namespace> <resourcename> <protectLevel>");
            System.Console.WriteLine("  only " + args.Length + " provided.");
            return -1;
        }
    
        _infile = args[0];
        _outfile = args[1];
        _namespace = args[2];
        _resfile = args[3];
        _protectLevel = args[4];
        _class = "SR";

        String header = String.Format(_headerFormat,
                                      _namespace,
                                      _class,
                                      _protectLevel);

        String footer = String.Format(_footerFormat,
                                      _resfile,
                                      _class);


        Stream inputFile = new FileStream(_infile,
                                          FileMode.Open,
                                          FileAccess.Read); 
        StreamReader reader = new StreamReader(inputFile);
        
        Stream outputFile = new FileStream(_outfile,
                                           FileMode.Create,
                                           FileAccess.Write); 
        StreamWriter writer = new StreamWriter(outputFile);
        writer.Write(header);

        // Read through each entry in the input file
        String inputLine;
        while ((inputLine = reader.ReadLine()) != null)
        {
            // Find stuff to the left of the = sign.  If none, skip the line.
            int equalsIdx = inputLine.IndexOf('=');
            if (equalsIdx > 0)
            {
                String name = inputLine.Substring(0, equalsIdx);
                writer.Write(String.Format(_defnFormat,
                                           name,
                                           _protectLevel));
            }
        }

        writer.Write(footer);
        writer.Flush();
        outputFile.Flush();

        writer.Close();


        reader.Close();
        inputFile.Close();
        
        outputFile.Close();
        
        return 0;
    }

////////////////////////////  Embedded String  ////////////////////////
    static String _defnFormat = @"
        {1} const String {0} = ""{0}"";";
////////////////////////////  End Embedded String  ////////////////////////
    
    // {0} = resource file
    // {1} = class
    // {2} = protection level
////////////////////////////  Embedded String  ////////////////////////
    static String _headerFormat = @"
//------------------------------------------------------------------------------
// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
//    Copyright (c) Microsoft Corporation. All Rights Reserved.                
//    Information Contained Herein is Proprietary and Confidential.            
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace {0} {{
    using System;
    using System.Reflection;
    using System.Globalization;
    using System.Resources;
    using System.Text;
    using System.Threading;

    /// <summary>
    ///    AutoGenerated resource class. Usage:
    ///
    ///        String s = {1}.GetString({1}.MyIdenfitier);
    /// </summary>
    {2} class {1} {{
";

////////////////////////////  End Embedded String  ////////////////////////

    // {0} = resource file
    // {1} = class
////////////////////////////  Embedded String  ////////////////////////
    static String _footerFormat = @"

        static bool loading = false;
        static {1} loader = null;
        ResourceManager resources;
        
        protected {1}() {{
            resources = new System.Resources.ResourceManager(""{0}"", this.GetType().Module.Assembly);
        }}
        
        private static {1} GetLoader() {{
            if (loader == null && !loading) {{
                lock(typeof({1})) {{
                   // loading is used to avoid recursing.
                   if (loader == null && !loading) {{
                       loading = true;
                       try {{
                           loader = new {1}();
                       }}
                       finally {{
                           loading = false;
                       }}
                   }}
               }}
            }}
            
            return loader;
        }}

        public static string GetString(string name, params object[] args) {{
            return GetString(null, name, args);
        }}
        public static string GetString(CultureInfo culture, string name, params object[] args) {{
            {1} sys = GetLoader();
            if (sys == null)
                return null;
            string res = sys.resources.GetString(name, culture);
            
            if (args != null && args.Length > 0) {{
                return String.Format(res, args);
            }}
            else {{
                return res;
            }}
        }}

        public static string GetString(string name) {{
            return GetString(null, name);
        }}
        public static string GetString(CultureInfo culture, string name) {{
            {1} sys = GetLoader();
            if (sys == null)
                return null;
            return sys.resources.GetString(name, culture);
        }}
        public static bool GetBoolean(string name) {{
            return GetBoolean(name);
        }}
        public static bool GetBoolean(CultureInfo culture, string name) {{
            bool val = false;;

            {1} sys = GetLoader();
            if (sys != null) {{
                object res = sys.resources.GetObject(name, culture);
                if (res is bool) {{
                    val = (bool)res;
                }}
            }}
            return val;
        }}
        public static char GetChar(string name) {{
            return GetChar(null, name);
        }}
        public static char GetChar(CultureInfo culture, string name) {{
            char val = (char)0;

            {1} sys = GetLoader();
            if (sys != null) {{
                object res = sys.resources.GetObject(name, culture);
                if (res is char) {{
                    val = (char)res;
                }}
            }}
            return val;
        }}
        public static byte GetByte(string name) {{
            return GetByte(null, name);
        }}
        public static byte GetByte(CultureInfo culture, string name) {{
            byte val = (byte)0;

            {1} sys = GetLoader();
            if (sys != null) {{
                object res = sys.resources.GetObject(name, culture);
                if (res is byte) {{
                    val = (byte)res;
                }}
            }}
            return val;
        }}
        public static short GetShort(string name) {{
            return GetShort(null, name);
        }}
        public static short GetShort(CultureInfo culture, string name) {{
            short val = (short)0;

            {1} sys = GetLoader();
            if (sys != null) {{
                object res = sys.resources.GetObject(name, culture);
                if (res is short) {{
                    val = (short)res;
                }}
            }}
            return val;
        }}
        public static int GetInt(string name) {{
            return GetInt(null, name);
        }}
        public static int GetInt(CultureInfo culture, string name) {{
            int val = 0;

            {1} sys = GetLoader();
            if (sys != null) {{
                object res = sys.resources.GetObject(name, culture);
                if (res is int) {{
                    val = (int)res;
                }}
            }}
            return val;
        }}
        public static long GetLong(string name) {{
            return GetLong(null, name);
        }}
        public static long GetLong(CultureInfo culture, string name) {{
            long val = 0L;

            {1} sys = GetLoader();
            if (sys != null) {{
                object res = sys.resources.GetObject(name, culture);
                if (res is long) {{
                    val = (long)res;
                }}
            }}
            return val;
        }}
        public static float GetFloat(string name) {{
            return GetFloat(null, name);
        }}
        public static float GetFloat(CultureInfo culture, string name) {{
            float val = 0.0F;

            {1} sys = GetLoader();
            if (sys == null) {{
                object res = sys.resources.GetObject(name, culture);
                if (res is float) {{
                    val = (float)res;
                }}
            }}
            return val;
        }}
        public static double GetDouble(string name) {{
            return GetDouble(null, name);
        }}
        public static double GetDouble(CultureInfo culture, string name) {{
            double val = 0.0;

            {1} sys = GetLoader();
            if (sys == null) {{
                object res = sys.resources.GetObject(name, culture);
                if (res is double) {{
                    val = (double)res;
                }}
            }}
            return val;
        }}
        public static object GetObject(string name) {{
            return GetObject(null, name);
        }}
        public static object GetObject(CultureInfo culture, string name) {{
            {1} sys = GetLoader();
            if (sys == null)
                return null;
            return sys.resources.GetObject(name, culture);
        }}
    }}
}}

";
    
}

////////////////////////////  End Embedded String  ////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\uri.cs ===
//------------------------------------------------------------------------------
// <copyright file="URI.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System {

    using System.Net;
    using System.Text;
    using System.Runtime.Serialization;
    using System.Globalization;

    /// <include file='doc\URI.uex' path='docs/doc[@for="Uri"]/*' />
    /// <devdoc>
    ///    <para>Provides
    ///       an object representation of a Uniform Resource Identifier (URI) and easy
    ///       access to the parts of the URI.</para>
    /// </devdoc>
    [Serializable]
    public class Uri : MarshalByRefObject, ISerializable {

        private const int Max16BitUtf8SequenceLength = 4;

// fields

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.UriSchemeFile"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the URI identifies a file resource. Read-only.
        ///    </para>
        /// </devdoc>
        public static readonly string UriSchemeFile = "file";
        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.UriSchemeFtp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the URI is accessed by the File Transfer Protocol (FTP).
        ///       Read-only.
        ///    </para>
        /// </devdoc>
        public static readonly string UriSchemeFtp = "ftp";
        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.UriSchemeGopher"]/*' />
        /// <devdoc>
        ///    Specifies that the URI is accessed via the
        ///    Gopher protocol. Read-only.
        /// </devdoc>
        public static readonly string UriSchemeGopher = "gopher";
        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.UriSchemeHttp"]/*' />
        /// <devdoc>
        ///    Specifies that the URI is accessed by the
        ///    Hypertext Transfer Protocol (HTTP). Read-only.
        /// </devdoc>
        public static readonly string UriSchemeHttp = "http";
        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.UriSchemeHttps"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the URI is accessed by the Secure Hypertext Transfer Protocol
        ///       (HTTPS). Read-only.
        ///    </para>
        /// </devdoc>
        public static readonly string UriSchemeHttps = "https";
        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.UriSchemeMailto"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the URI is an email address and is accessed by the Simple
        ///       Network Mail Protocol (SNMP). Read-only.
        ///    </para>
        /// </devdoc>
        public static readonly string UriSchemeMailto = "mailto";
        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.UriSchemeNews"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifes that the URI is an Internet news group and is accessed by the
        ///       Network News Transport Protocol (NNTP). Read-only.
        ///    </para>
        /// </devdoc>
        public static readonly string UriSchemeNews = "news";

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.UriSchemeNntp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly string UriSchemeNntp = "nntp";

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.SchemeDelimiter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifes the characters that separate the communication protocol scheme from
        ///       the address portion of the URI. Read-only.
        ///    </para>
        /// </devdoc>
        public static readonly string SchemeDelimiter = "://";

        //
        // hash code table lifted directly from Wininet
        //

        static readonly byte [] CaseInsensitiveHashCodeTable = {
              1,  14, 110,  25,  97, 174, 132, 119,
            138, 170, 125, 118,  27, 233, 140,  51,
             87, 197, 177, 107, 234, 169,  56,  68,
             30,   7, 173,  73, 188,  40,  36,  65,
             49, 213, 104, 190,  57, 211, 148, 223,
             48, 115,  15,   2,  67, 186, 210,  28,
             12, 181, 103,  70,  22,  58,  75,  78,
            183, 167, 238, 157, 124, 147, 172, 144,
            102, 218, 255, 240,  82, 106, 158, 201, // a..h
             61,   3,  89,   9,  42, 155, 159,  93, // i..p
            166,  80,  50,  34, 175, 195, 100,  99, // q..x
             26, 150,  95, 116, 252, 192,  54, 221, // yz..
            102, 218, 255, 240,  82, 106, 158, 201, // a..h
             61,   3,  89,   9,  42, 155, 159,  93, // i..p
            166,  80,  50,  34, 175, 195, 100,  99, // q..x
             26, 150,  16, 145,   4,  33,   8, 189, // yz..
            121,  64,  77,  72, 208, 245, 130, 122,
            143,  55, 105, 134,  29, 164, 185, 194,
            193, 239, 101, 242,   5, 171, 126,  11,
             74,  59, 137, 228, 108, 191, 232, 139,
              6,  24,  81,  20, 127,  17,  91,  92,
            251, 151, 225, 207,  21,  98, 113, 112,
             84, 226,  18, 214, 199, 187,  13,  32,
             94, 220, 224, 212, 247, 204, 196,  43,
            249, 236,  45, 244, 111, 182, 153, 136,
            129,  90, 217, 202,  19, 165, 231,  71,
            230, 142,  96, 227,  62, 179, 246, 114,
            162,  53, 160, 215, 205, 180,  47, 109,
             44,  38,  31, 149, 135,   0, 216,  52,
             63,  23,  37,  69,  39, 117, 146, 184,
            163, 200, 222, 235, 248, 243, 219,  10,
            152, 131, 123, 229, 203,  76, 120, 209
        };

        private string m_AbsoluteUri;               // machine sensible version
        private bool m_AlreadyEscaped;              // Original value of dontEscape.
        private string m_Fragment = String.Empty;
        private bool m_FragmentEscaped;
        private int m_Hash;
        private bool m_HasScheme;                   // true if e.g. file://c:/; false if e.g. c:\
        private bool m_HasSlashes;                  // true if e.g. http://; false if e.g. mailto:
        private HostNameType m_Host;
        private bool m_IsDefaultPort;
        private bool m_IsFile;                      // path is file:
        private bool m_IsFileReally;                // path is a file but the scheme is not file:
        private int m_IsSchemeKnownToHaveSlashes = -1;
        private bool m_IsUnc;                       // file path is UNC (\\server\share\...)
        private string m_Path = String.Empty;       // canonicalized but unescaped absolute path
        private bool m_PathEscaped;
        private int m_Port = -1;                    // -1 = not-present value
        private string m_Query = String.Empty;
        private bool m_QueryEscaped;
        private string m_Scheme = String.Empty;
        private int m_SegmentCount = -1;            // number of path segments
        private string [] m_Segments;
        private string m_UserInfo = String.Empty;
        private string m_String = null;

// constructors

        //
        // Uri(string)
        //
        //  Constructs Uri from input URI string. Performs parsing, canonicalization
        //  and escaping of supplied string argument.
        //
        //  We expect to create a Uri from a display name - e.g. that was typed by
        //  a user, or that was copied & pasted from a document. That is, we do not
        //  expect already encoded URI to be supplied. But we will also allow URI
        //  that are already encoded, and attempt to handle them correctly
        //
        // Inputs:
        //  <argument>  uriString
        //      String from which to create Uri object
        //
        // Outputs:
        //  <Uri> member fields
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  Nothing
        //
        // Throws:
        //  ArgumentException
        //  UriFormatException
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Uri"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the Uri
        ///       class with the supplied Uniform Resource Identifier
        ///       (URI).
        ///    </para>
        /// </devdoc>
        public Uri(string uriString) : this(uriString, false) {
        }

        //
        // Uri(string, bool)
        //
        //  Uri constructor. Do not perform character escaping if <alreadyEscaped>
        //  is true
        //
        // Inputs:
        //  <argument>  uriString
        //      String from which to construct Uri
        //
        //  <argument>  alreadyEscaped
        //      True if caller is passing already escaped string
        //
        // Outputs:
        //  <Uri>
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  Nothing
        //
        // Throws:
        //  ArgumentException
        //      If null or empty string provided as <uriString>
        //
        //  UriFormatException
        //      If we can't create the Uri because we cannot parse <uriString>
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Uri1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Uri'/> class from the specified URI, with control of character
        ///       escaping.
        ///    </para>
        /// </devdoc>
        public Uri(string uriString, bool dontEscape) {
            if (uriString == null) {
                throw new ArgumentNullException("uriString");
            }
            m_Path = uriString.Trim();
            if (m_Path.Length == 0) {
                throw new UriFormatException(SR.GetString(SR.net_uri_EmptyUri));
            }
            m_AlreadyEscaped = dontEscape;
            Parse();
            Canonicalize();
            if (!dontEscape) {
                Escape();
            }
            m_AbsoluteUri = NonPathPart +
                            m_Path +
                            m_Query +
                            m_Fragment;
            m_Hash = CalculateCaseInsensitiveHashCode(Unescape(m_AbsoluteUri));
        }

        //
        // ISerializable constructor
        //
        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Uri2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected Uri(SerializationInfo serializationInfo, StreamingContext streamingContext)
        : this(serializationInfo.GetString("AbsoluteUri"), true) {
            return;
        }

        //
        // ISerializable method
        //
        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            //
            // for now disregard streamingContext.
            // just serialize AbsoluteUri.
            //
            serializationInfo.AddValue("AbsoluteUri", AbsoluteUri);
            return;
        }

        //
        // Uri(Uri, string)
        //
        //  Construct a new Uri from a base and relative URI. The relative URI may
        //  also be an absolute URI, in which case the resultant URI is constructed
        //  entirely from it
        //
        // Inputs:
        //  <argument>  baseUri
        //      Uri object to treat as base for combination
        //
        //  <argument>  relativeUri
        //      String relative, or absolute, URI to combine with baseUri to create
        //      resulting new URI
        //
        // Outputs:
        //  <Uri>
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  Nothing
        //
        // Throws:
        //  ArgumentException
        //  UriFormatException
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Uri3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Uri'/> class constructed
        ///       from the specified
        ///       base and releative URIs.
        ///    </para>
        /// </devdoc>
        public Uri(Uri baseUri, string relativeUri) : this(baseUri, relativeUri, false) {
        }

        //
        // Uri(Uri, string, bool)
        //
        //  Uri combinatorial constructor. Do not perform character escaping if
        //  DontEscape is true
        //
        // Inputs:
        //  <argument>  baseUri
        //      Uri object to treat as base for combination
        //
        //  <argument>  relativeUri
        //      String relative, or absolute, URI to combine with baseUri to create
        //      resulting new Uri
        //
        //  <argument>  dontEscape
        //      True if caller is passing already escaped string
        //
        // Outputs:
        //  <Uri>
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  Nothing
        //
        // Throws:
        //  ArgumentException
        //  UriFormatException
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Uri4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Uri'/> class constructed from the specified base and releative Uris, with
        ///       control of character escaping.
        ///    </para>
        /// </devdoc>
        public Uri(Uri baseUri, string relativeUri, bool dontEscape) :
            this(CombineUri(baseUri, relativeUri), dontEscape) {
        }

// properties

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.AbsolutePath"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the absolute path.
        ///    </para>
        /// </devdoc>
        public string AbsolutePath {
            get {
                return m_Path;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.AbsoluteUri"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the absolute
        ///       Uniform Resource Identifier (URI).
        ///    </para>
        /// </devdoc>
        /// <devdoc>
        ///    <para>
        ///       Gets the absolute
        ///       Uniform Resource Identifier (URI).
        ///    </para>
        /// </devdoc>
        public string AbsoluteUri {
            get {
                return m_AbsoluteUri;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Authority"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the Domain Name System (DNS) host name.
        ///    </para>
        /// </devdoc>
        public string Authority {
            get {
                return Host + (!m_IsDefaultPort ? (":" + m_Port) : String.Empty);
            }
        }

        private string BasePath {
            get {

                string path = m_Path;
                int first = 0;
                int last = path.LastIndexOf('/');

                if (m_IsUnc && (path.Length > 1)) {
                    first = path.IndexOf('/', 1);
                    if (first < 0) {
                        first = 0;
                    }
                }
                return path.Substring(first, (last - first) + 1);;
            }
        }

        private string CurrentDocument {
            get {

                string path = m_Path;

                if (path.Length > 0) {

                    int index = path.LastIndexOf('/') + 1;

                    if (index < path.Length) {
                        return path.Substring(index);
                    }
                }
                return String.Empty;
            }
        }

        private string DisplayFragment {
            get {
                return m_FragmentEscaped ? Unescape(m_Fragment) : m_Fragment;
            }
        }

        private string DisplayNameNoExtra {
            get {
                return NonPathPart + DisplayPath;
            }
        }

        private string DisplayPath {
            get {
                return m_PathEscaped ? UnescapePath(m_Path, true) : m_Path;
            }
        }

        private string DisplayPathLocal {
            get {
                return m_PathEscaped ? UnescapePath(m_Path, false) : m_Path;
            }
        }

        private string DisplayQuery {
            get {
                return m_QueryEscaped ? Unescape(m_Query) : m_Query;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Fragment"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the escaped fragment.
        ///    </para>
        /// </devdoc>
        public string Fragment {
            get {
                return m_Fragment;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Host"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the Domain Name System (DNS) host name.
        ///    </para>
        /// </devdoc>
        public string Host {
            get {
                if (m_Host != null) {
                    if (m_Host is IPv6Address) {
                        return '[' + m_Host.Name + ']';
                    }
                    return m_Host.Name;
                }
                return String.Empty;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.HostNameType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the type of this host name
        ///    </para>
        /// </devdoc>
        public UriHostNameType HostNameType {
            get {
                return (m_Host == null)
                        ? UriHostNameType.Unknown
                        : ((m_Host is DomainName)
                           ? UriHostNameType.Dns
                           : ((m_Host is BasicHostName)
                              ? UriHostNameType.Basic
                              : ((m_Host is IPv4Address)
                                 ? UriHostNameType.IPv4
                                 : ((m_Host is IPv6Address)
                                    ? UriHostNameType.IPv6
                                    : UriHostNameType.Unknown))));
            }
        }

        internal HostNameType HostType {
            get {
                return m_Host;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.IsDefaultPort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns true if the port value is the default for this scheme
        ///    </para>
        /// </devdoc>
        public bool IsDefaultPort {
            get {
                return m_IsDefaultPort;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.IsFile"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsFile {
            get {
                return m_IsFile;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.IsLoopback"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsLoopback {
            get {
                return m_Host.IsLoopback;
            }
        }

        internal bool IsSchemeKnownToHaveSlashes {
            get {
                if (m_IsSchemeKnownToHaveSlashes == -1) {
                    m_IsSchemeKnownToHaveSlashes = ((m_Scheme == UriSchemeHttp)
                                                    || (m_Scheme == UriSchemeHttps)
                                                    || (m_Scheme == UriSchemeFtp)
                                                    || (m_Scheme == UriSchemeGopher)
                                                    || (m_Scheme == UriSchemeFile)) ? 1 : 0;
                }
                return m_IsSchemeKnownToHaveSlashes == 1;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.IsUnc"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsUnc {
            get {
                return m_IsUnc;
            }
        }

        //
        // LocalPath
        //
        //  Returns a 'local' version of the path. This is mainly for file: URI
        //  such that DOS and UNC paths are returned with '/' converted back to
        //  '\', and any escape sequences converted
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.LocalPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string LocalPath {
            get {
                if (m_IsFileReally || m_IsUnc) {

                    StringBuilder path = new StringBuilder((m_IsUnc
                                                                ? ("\\\\" + Host)
                                                                : String.Empty
                                                           ) + DisplayPathLocal
                                                          );

                    for (int i = m_IsUnc ? 2 : 0; i < path.Length; ++i) {
                        if (path[i] == '/') {
                            path[i] = '\\';
                        }
                    }
                    return path.ToString();
                } else {
                    return AbsolutePath;
                }
            }
        }

        private string NonPathPart {
            get {
                return m_Scheme + ":"
                        + (m_HasSlashes ? "//" : "")
                        + UserInfo + ((UserInfo.Length > 0) ? "@" : String.Empty)
                        + Authority

                        //
                        // note: use m_IsFile here not m_IsFileReally because
                        // we don't want to return e.g. vsmacros:///c:/foo
                        // but vsmacros://c:/foo if vsmacros://c:/foo was the
                        // original string
                        //

                        + ((m_IsFile && !m_IsUnc) ? "/" : "");
            }
        }

        private string NonPathPartUnc {
            get {
                if (!m_IsUnc) {
                    return NonPathPart;
                }

                string shareName = String.Empty;

                if (Segments.Length > 1) {
                    shareName += Segments[1];
                }
                return NonPathPart + "/" + shareName;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.PathAndQuery"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the escaped <see cref='System.Uri.AbsolutePath'/> and <see cref='System.Uri.Query'/>
        ///       properties separated by a "?" character.
        ///    </para>
        /// </devdoc>
        public string PathAndQuery {
            get {
                return m_Path + m_Query;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Port"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the port number.
        ///    </para>
        /// </devdoc>
        public int Port {
            get {
                return m_Port;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Query"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the escaped query.
        ///    </para>
        /// </devdoc>
        public string Query {
            get {
                return m_Query;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Scheme"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the scheme name.
        ///    </para>
        /// </devdoc>
        public string Scheme {
            get {
                return m_Scheme;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Segments"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an array of the segments that make up a URI.
        ///    </para>
        /// </devdoc>
        public string[] Segments {
            get {
                if (m_Segments == null) {

                    string path = AbsolutePath;

                    if (path.Length == 0) {
                        m_SegmentCount = 0;
                        m_Segments = new string[0];
                    }
                    else {

                        int i;
                        bool isLocalPath = m_IsFileReally && !m_IsUnc;

                        if (m_SegmentCount == -1) {
                            if (path.Length > 0) {

                                //
                                // if the path doesn't start with a slash then
                                // its a rooted Windows path (c:/foo/bar) so we
                                // start n off at 1 for the "c:" part
                                //

                                int n = isLocalPath ? 2 : 1;

                                for (i = 0; i < path.Length; ++i) {
                                    if (path[i] == '/') {
                                        ++n;
                                    }
                                }
                                if (path[i - 1] == '/') {
                                    --n;
                                }
                                m_SegmentCount = n;
                            }
                            else {
                                m_SegmentCount = 0;
                            }
                        }

                        string[] pathSegments = new string[m_SegmentCount];
                        int current = 1;

                        i = 0;
                        if (isLocalPath) {
                            pathSegments[0] = path.Substring(0, 2);
                            ++i;
                            current = 3;
                        }
                        if (m_HasSlashes) {
                            pathSegments[i] = "/";
                        } else {
                            i = -1;
                            current = 0;
                        }

                        while (current < path.Length) {

                            int next = path.IndexOf('/', current);

                            if (next == -1) {
                                next = path.Length - 1;
                            }
                            ++i;
                            pathSegments[i] = path.Substring(current, (next - current) + 1);
                            current = next + 1;
                        }
                        m_Segments = pathSegments;
                    }
                }
                return m_Segments;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.UserEscaped"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns <see langword='true '/>if the <paramref name="dontEscape
        ///       "/>parameter was set to <see langword='true '/>when the <see cref='System.Uri'/>
        ///       instance was created.
        ///    </para>
        /// </devdoc>
        public bool UserEscaped {
            get {
                return m_AlreadyEscaped;
            }
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.UserInfo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the user name, password, and other user specific information associated
        ///       with the Uniform Resource Identifier (URI).
        ///    </para>
        /// </devdoc>
        public string UserInfo {
            get {
                return m_UserInfo;
            }
        }

// methods

        //
        // CalculateCaseInsensitiveHashCode
        //
        //  Calculates the hash code for a string without regard to case. Uses
        //  Pearson's method
        //
        // Inputs:
        //  <argument>  text
        //      The string to generate the hash code for
        //
        //  <argument>  ignoreCase
        //      True if we are to treat the characters in the string without
        //      regard to case
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  The string contains only ANSI characters (7-bit (actually 8-bit))
        //
        // Returns:
        //  generated hash code as an integer
        //
        // Throws:
        //  Nothing
        //

        internal static int CalculateCaseInsensitiveHashCode(string text) {

            byte [] hashTable = CaseInsensitiveHashCodeTable;
            byte b1, b2, b3, b4;
            uint hash;

            //
            // seed the hash
            //
            b1 = hashTable[(text[0]    ) & 0xff];
            b2 = hashTable[(text[0] + 1) & 0xff];
            b3 = hashTable[(text[0] + 2) & 0xff];
            b4 = hashTable[(text[0] + 3) & 0xff];
            hash = (((uint)b4 << 24)
                    | ((uint)b3 << 16)
                    | ((uint)b2 << 8)
                    | (uint)b1);

            //
            // calculate the hash
            //

            for (int i = 0; i < text.Length; ++i) {

                //
                // fragment not included in calculation
                //

                if (text[i] == '#') {
                    break;
                }
                b1 = hashTable[b1 ^ (byte)text[i]];
                b2 = hashTable[b2 ^ (byte)text[i]];
                b3 = hashTable[b3 ^ (byte)text[i]];
                b4 = hashTable[b4 ^ (byte)text[i]];
                hash = hash ^ (((uint)b4 << 24)
                               | ((uint)b3 << 16)
                               | ((uint)b2 << 8)
                               | (uint)b1);
            }
            return (int)hash;
        }

        //
        // Canonicalize
        //
        //  Convert the URI to a canonical form:
        //
        //      - convert any '\' characters to '/'
        //      - compress any path meta sequences ("/." and "/..")
        //      - compress multiple insignificant '/' in path component to single
        //
        // Inputs:
        //  <member>    m_Path
        //      Contains uncanonicalized path parsed from URI
        //
        // Outputs:
        //  <member>    m_Path
        //      Absolute path in canonic form
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  Nothing
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Canonicalize"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected virtual void Canonicalize() {
            if ((m_Path.Length > 0) && (m_Path != "/")) {

                StringBuilder sb = new StringBuilder(m_Path.Length);
                int i = 0;
                int k = 0;

                sb.Length = m_Path.Length;

                //
                // if URI is using 'non-proprietary' disk drive designation,
                // convert to MS-style
                //

                if ((m_Path.Length > 1) && (m_Path[1] == '|')) {
                    sb[k++] = m_Path[0];
                    sb[k++] = ':';
                    i = 2;
                }
                for (; i < m_Path.Length; ++i) {

                    char ch = m_Path[i];

                    if (ch == '\\') {
                        ch = '/';
                    }

                    //
                    // compress multiple '/' for file URI
                    //

                    if ((ch == '/') && m_IsFileReally && (k > 0) && (sb[k - 1] == '/')) {
                        continue;
                    }
                    sb[k++] = ch;
                }
                sb.Length = k;
                m_Path = CompressPath(sb.ToString());
            }
        }

        //
        // CheckHostName
        //
        //  Determines whether a host name authority is a valid Host name according
        //  to DNS naming rules
        //
        // Inputs:
        //  <argument>  name
        //      Name to check for validity
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  true if <name> is valid else false
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.CheckHostName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if a host name is valid.
        ///    </para>
        /// </devdoc>
        public static UriHostNameType CheckHostName(string name) {
            if ((name == null) || (name.Length == 0)) {
                return UriHostNameType.Unknown;
            }
            if ((name[0] == '[') && (name[name.Length - 1] == ']')) {
                if (IPv6Address.IsValid(name.Substring(1, name.Length - 2))) {
                    return UriHostNameType.IPv6;
                }
            }
            if (IPv4Address.IsValid(name)) {
                return UriHostNameType.IPv4;
            }
            if (DomainName.IsValid(name)) {
                return UriHostNameType.Dns;
            }
            if (IPv6Address.IsValid(name)) {
                return UriHostNameType.IPv6;
            }
            return UriHostNameType.Unknown;
        }

        //
        // CheckSchemeName
        //
        //  Determines whether a string is a valid scheme name according to RFC 2396.
        //  Syntax is:
        //
        //      scheme = alpha *(alpha | digit | '+' | '-' | '.')
        //
        // Inputs:
        //  <argument>  schemeName
        //      Name of scheme to test
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  true if <schemeName> is good else false
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.CheckSchemeName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if a scheme name is valid.
        ///    </para>
        /// </devdoc>
        public static bool CheckSchemeName(string schemeName) {
            if ((schemeName == null)
                || (schemeName.Length == 0)
                || !Char.IsLetter(schemeName[0])) {
                return false;
            }
            for (int i = schemeName.Length - 1; i > 0; --i) {
                if (!(Char.IsLetterOrDigit(schemeName[i])
                      || (schemeName[i] == '+')
                      || (schemeName[i] == '-')
                      || (schemeName[i] == '.'))) {
                    return false;
                }
            }
            return true;
        }

        //
        // CheckSecurity
        //
        //  Check for any invalid or problematic character sequences
        //
        // Inputs:
        //  Nothing
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  Nothing
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.CheckSecurity"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected virtual void CheckSecurity() {
            if (m_Scheme == "telnet") {

                //
                // remove everything after ';' for telnet
                //

            }
        }

        //
        // Combine
        //
        //  Combines a base URI string and a relative URI string into a resultant
        //  URI string
        //
        // Inputs:
        //  <argument>  basePart
        //      String representation of an absolute base URI
        //
        //  <argument>  relativePart
        //      String which is a relative path
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  string which is combination of <basePart> and <relativePart>
        //
        // Throws:
        //  UriFormatException
        //

        internal static string Combine(string basePart, string relativePart, bool dontEscape) {

            Uri u = new Uri(basePart, dontEscape);
            Uri uc = new Uri(u, relativePart, dontEscape);

            return uc.ToString();
        }

        //
        // CombineUri
        //
        //  Given 2 URI strings, combine them into a single resultant URI string
        //
        // Inputs:
        //  <argument>  basePart
        //      Base URI to combine with
        //
        //  <argument>  relativePart
        //      String expected to be relative URI
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  <basePart> is in canonic form
        //
        // Returns:
        //  Resulting combined URI string
        //
        // Throws:
        //  UriFormatException
        //

        private static string CombineUri(Uri basePart, string relativePart) {

            int index;

            for (index = 0; index < relativePart.Length; ++index) {
                if (!Char.IsWhiteSpace(relativePart[index])) {
                    break;
                }
            }
            if (index != 0) {
                relativePart = relativePart.Substring(index);
            }
            if (relativePart.Length == 0) {
                return basePart.AbsoluteUri;
            }
            index = relativePart.IndexOf(':');

            int offset = 0;

            if ((relativePart.Length > 2)
                && ((relativePart[0] == '\\') || (relativePart[0] == '/'))
                && ((relativePart[1] == '\\') || (relativePart[1] == '/'))) {
                offset = 2;
            }

            int hindex = relativePart.IndexOf('#');
            int qindex = relativePart.IndexOf('?');

            int end = Math.Min(hindex, qindex);

            if (end == -1) {
                end = relativePart.Length;
            }

            //
            // convert any non-significant backslashes to forward-slash
            //

            StringBuilder sb = null;
            int previous = 0;

            do {
                offset = relativePart.IndexOf('\\', offset);
                if ((offset >= 0) && (offset < end)) {
                    if (sb == null) {
                        sb = new StringBuilder(relativePart.Length);
                    }
                    sb.Append(relativePart.Substring(previous, offset - previous) + '/');
                    ++offset;
                    previous = offset;
                } else {
                    relativePart = ((sb == null) ? String.Empty : sb.ToString()) + relativePart.Substring(previous);
                    break;
                }
            } while (true);

            int sindex = relativePart.IndexOf('/');

            //
            // if there is a colon we assume its a scheme name separator unless
            // it is preceeded by a '/', '#' or '?'
            //

            if (((sindex != -1) && (sindex < index))
                || ((hindex != -1) && (hindex < index))
                || ((qindex != -1) && (qindex < index))) {
                index = -1;
            }

            string scheme = (index != -1)
                                ? relativePart.Substring(0, index).ToLower(CultureInfo.InvariantCulture)
                                : String.Empty;

            if ((scheme.Length > 0) && (scheme != basePart.Scheme)) {
                return relativePart;
            }
            if ((scheme == basePart.Scheme)
                && (relativePart.Length - index > 2)
                && (relativePart[index + 1] == '/')
                && (relativePart[index + 2] == '/')) {
                return relativePart;
            }
            if ((scheme.Length == 0)
                && (relativePart.Length > 2)
                && (relativePart[0] == '\\')
                && (relativePart[1] == '\\')) {
                return relativePart;
            }
            relativePart = relativePart.Substring(index + 1);
            if (relativePart[0] == '/') {
                if ((relativePart.Length > 2) && (relativePart[1] == '/')) {
                    return basePart.Scheme + ":" + relativePart;
                }
                return basePart.NonPathPartUnc + relativePart;
            }

            string extra = String.Empty;

            qindex = relativePart.IndexOf('?');
            hindex = relativePart.IndexOf('#');
            index = (qindex == -1)
                        ? hindex
                        : ((hindex == -1)
                            ? qindex
                            : ((qindex < hindex)
                                ? qindex
                                : hindex));

            if (index != -1) {
                if ((index != 0) || (qindex == 0)) {
                    extra = relativePart.Substring(index);
                    relativePart = relativePart.Substring(0, index);
                }
                else {
                    extra = relativePart;
                    relativePart = basePart.CurrentDocument;
                }
            }

            //
            // ensure that if we're combining a UNC path, we don't remove the
            // share name. I.e., \\server\share + path\file doesn't become
            // \\server\path\file, but \\server\share\path\file
            //

            return basePart.NonPathPartUnc + CompressPath(basePart.BasePath + relativePart) + extra;
        }

        //
        // CompessPath
        //
        //  Handle "/." and "/.." meta sequences in a combined path string
        //
        // Inputs:
        //  <argument>  path
        //      String containing path components to process
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  <path> starts with '/'
        //
        // Returns:
        //  Compressed path
        //
        // Throws:
        //  Nothing
        //

        private static string CompressPath(string path) {

            //
            // PERF: probably a better algorithm is to create an array of segment
            // offset & length, then recreate the path, possibly as a StringBuilder
            // then convert to string
            //

            int ls = -1;        // last slash character position
            int pls = -1;       // previous last slash character position
            int dot = -2;       // needs to be -2 in case path[0] is /
            int dotdot = -2;    // ditto
            int i;

            for (i = 0; i < path.Length; ++i) {
                if (path[i] == '/') {
                    if (dot == i - 1) {
                        path = path.Substring(0, ls + 1) + path.Substring(i + 1);
                        dot = -2;
                        i -= 2; // allow for ++i in for()
                    }
                    else if ((dotdot == i - 1)
                             && (pls >= 0)
                             && (ls - pls > 1)
                             && !((path[pls + 1] == '.') && (path[pls + 2] == '.'))) {
                        path = path.Substring(0, pls + 1) + path.Substring(i + 1);
                        ls = pls;
                        for (pls = ls - 1; pls >= 0 && path[pls] != '/'; --pls);
                        dot = -2;
                        dotdot = -2;
                        i = ls;
                    }
                    else {
                        pls = ls;
                        ls = i;
                    }
                }
                else if (path[i] == '.') {
                    if (ls == i - 1) {
                        dot = i;
                    }
                    else if (dot == i - 1) {
                        dotdot = i;
                    }
                }
            }

            //
            // handle trailing dots - "/a/." and "/a/.."
            //

            if (dot == i - 1) {

                //
                // it is always OK to convert "/." to "/"
                //

                path = path.Substring(0, dot);
            }
            else if ((dotdot == i - 1)
                     && (pls >= 0)
                     && (ls - pls > 1)
                     && !((path[pls + 1] == '.') && (path[pls + 2] == '.'))) {

                //
                // it is only OK to convert "/.." if there is a preceding non-slash-dot-dot
                // sequence. I.e., "/a/.." is OK to convert to "/" but "/.." isn't
                // because it is the only element left in the path (e.g. we may have
                // converted "/a/../.." to "/.." so we can't run another, final
                // conversion
                //

                path = path.Substring(0, pls + 1);
            }
            return path;
        }

        //
        // CreateHost
        //
        //  Returns a new HostNameType based on <name> or returns a null reference
        //  if the name type can't be determined
        //
        // Inputs:
        //  <argument>  name
        //      to create a HostNameType object for
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  HostNameType
        //
        // Throws:
        //  Nothing
        //

        private HostNameType CreateHost(string name) {
            if ((name[0] == '[') && (name[name.Length - 1] == ']')) {
                name = name.Substring(1, name.Length - 2);
                if (IPv6Address.IsValid(name)) {
                    return new IPv6Address(name);
                }
            }
            else {
                if (Char.IsDigit(name[0]) && IPv4Address.IsValid(name)) {
                    return new IPv4Address(name);
                }
                else if (DomainName.IsValid(name)) {
                    return new DomainName(name);
                } else if (UncName.IsValid(name)) {
                    return new UncName(name);
                }
            }
            return null;
        }

        //
        // DefaultPortForScheme
        //
        //  Return the default port value for the schemes we know about
        //
        // Inputs:
        //  <argument>  schemeName
        //      Name of scheme to return port for
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Default port values are unchanging
        //
        // Returns:
        //  Port number for scheme name or -1 if unknown
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.DefaultPortForScheme"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal virtual int DefaultPortForScheme(string schemeName) {
            if (schemeName == UriSchemeHttp) {
                return 80;
            }
            if ((schemeName == UriSchemeMailto) || (schemeName == "mail")) {
                return 25;
            }
            if (schemeName == UriSchemeHttps) {
                return 443;
            }
            if (schemeName == UriSchemeFtp) {
                return 21;
            }
            if ((schemeName == UriSchemeNews) || (schemeName == UriSchemeNntp)) {
                return 119;
            }
            if (schemeName == UriSchemeGopher) {
                return 70;
            }
            return -1;
        }

        //
        // Equals
        //
        //  Overrides default function (in Object class)
        //
        // Inputs:
        //  <argument>  comparand
        //      other Uri object to compare with
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  <comparand> is an object of class Uri
        //
        // Returns:
        //  true if objects have the same value, else false
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compares two <see cref='System.Uri'/> instances for equality.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object comparand) {
            if (comparand == null) {
                return false;
            }

            //
            // we allow comparisons of Uri and String objects only. If a string
            // is passed, convert to Uri. This is inefficient, but allows us to
            // canonicalize the comparand, making comparison possible
            //

            if (comparand is string) {

                string s = (string)comparand;

                if (s.Length == 0) {
                    return false;
                }
                comparand = (object)new Uri(s);
            }
            if (!(comparand is Uri)) {
                return false;
            }

            Uri obj = (Uri)comparand;

            return (Scheme == obj.Scheme)
                    && HostType.Equals(obj.HostType)
                    && (Port == obj.Port)

                    //
                    // if m_IsFileReally is true then we ignore case in the path comparison
                    // Unescape the AbsolutePaths so that e.g. 'A' and "%41" compare
                    //

                    && (String.Compare(Unescape(AbsolutePath), Unescape(obj.AbsolutePath), m_IsFileReally, CultureInfo.InvariantCulture) == 0);
        }

        //
        // Escape
        //
        //  Convert any unsafe or reserved characters in the path component to hex
        //  sequences
        //
        // Inputs:
        //  <member>    m_Path
        //
        // Outputs:
        //  <member>    m_Path
        //
        // Assumes:
        //  <m_Path> is not already escaped
        //
        // Returns:
        //  Nothing
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Escape"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected virtual void Escape() {
            m_Path = EscapeString(m_Path, !m_HasScheme, out m_PathEscaped);
        }

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.EscapeString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected static string EscapeString(string str) {
            bool escaped;
            return EscapeString(str, false, out escaped);
        }

        //
        // EscapeString
        //
        //  Convert any unsafe or reserved characters in a string to hex
        //  sequences
        //
        // Inputs:
        //  <argument>  rawString
        //      String to be escaped
        //
        //  <argument>  reEncode
        //      True if %XX sequences are to be re-encoded as %25XX or False to
        //      leave as-is
        //
        // Outputs:
        //  <argument>  escaped
        //      Set to true if we escaped <rawString>
        //
        // Assumes:
        //  rawString is not already escapced.
        //
        // Returns:
        //  Escaped string
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.EscapeString1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        internal static string EscapeString(string rawString, bool reEncode, out bool escaped) {
            escaped = false;
            if (rawString == null) {
                return String.Empty;
            }

            StringBuilder result = new StringBuilder();
            string sub = null;
            byte [] bytes = new byte[Max16BitUtf8SequenceLength * 2];
            char [] chars = rawString.ToCharArray();
            int index = 0;
            int runLength = 0;

            for (int i = 0; i < rawString.Length; ) {
                while (i < rawString.Length) {
                    if (rawString[i] > '\x7f') {

                        bool isSurrogate = Char.IsSurrogate(chars[i]);
                        int numberOfBytes = Encoding.UTF8.GetBytes(chars,
                                                                   i,
                                                                   isSurrogate
                                                                    ? Math.Min(2, rawString.Length - i)
                                                                    : 1,
                                                                   bytes,
                                                                   0
                                                                   );

                        if (numberOfBytes == 0) {
                            throw new UriFormatException(SR.GetString(SR.net_uri_BadString));
                        }
                        for (int j = 0; j < numberOfBytes; ++j) {
                            sub += HexEscape_NoCheck((char)bytes[j]);
                        }
                        escaped = true;
                        if (isSurrogate) {
                            ++i;
                        }
                        break;
                    }
                    else if (!reEncode && ((rawString[i] == '%') && IsHexEncoding(rawString, i))) {
                        runLength += 3;
                        i += 2;

                        //
                        // although we are not escaping the string, we are saying
                        // that it contains escape sequences. This is significant
                        // for DisplayPath and LocalPath
                        //

                        escaped = true;
                    }
                    else if (IsExcludedCharacter(rawString[i])) {
                        sub = HexEscape_NoCheck(rawString[i]);
                        escaped = true;
                        break;
                    }
                    else {
                        ++runLength;
                    }
                    ++i;
                }
                if (runLength != 0) {
                    if (runLength == rawString.Length) {

                        //
                        // rawString consists entirely of characters that don't
                        // need escaping in any way
                        //

                        return rawString;
                    }
                    result.Append(rawString.Substring(index, runLength));
                    runLength = 0;
                }
                if (sub != null) {
                    result.Append(sub);
                    sub = null;
                    ++i;
                    index = i;
                }
            }
            return result.ToString();
        }

        //
        // FromHex
        //
        //  Returns the number corresponding to a hexadecimal character
        //
        // Inputs:
        //  <argument>  digit
        //      Character representation of hexadecimal digit
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  Number in the range 0..15
        //
        // Throws:
        //  ArgumentException
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.FromHex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the decimal value of a hexadecimal digit.
        ///    </para>
        /// </devdoc>
        public static int FromHex(char digit) {
            if (((digit >= '0') && (digit <= '9'))
                || ((digit >= 'A') && (digit <= 'F'))
                || ((digit >= 'a') && (digit <= 'f'))) {
                return FromHex_NoCheck(digit);
            }
            throw new ArgumentException("digit");
        }

        //
        // FromHex_NoCheck
        //
        //  Performs FromHex() without range checking the <digit> parameter
        //
        // Inputs:
        //  <argument>  digit
        //      Character to convert
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  <digit> is in the range 0..9A..Za..z
        //
        // Returns:
        //  Integer value of <digit>
        //
        // Throws:
        //  Nothing
        //

        private static int FromHex_NoCheck(char digit) {
            return  (digit <= '9')
                        ? ((int)digit - (int)'0')
                        : (((digit <= 'F')
                            ? ((int)digit - (int)'A')
                            : ((int)digit - (int)'a'))
                           + 10);
        }

        //
        // GetHashCode
        //
        //  Overrides default function (in Object class)
        //
        // Inputs:
        //  Nothing
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  Hash value previously calculated for this object
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hash code for the Uri.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return m_Hash;
        }

        //
        // GetLeftPart
        //
        //  Returns part of the URI based on the parameters:
        //
        // Inputs:
        //  <argument>  part
        //      Which part of the URI to return
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  The requested substring
        //
        // Throws:
        //  UriFormatException if URI type doesn't have host-port or authority parts
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.GetLeftPart"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string GetLeftPart(UriPartial part) {
            switch (part) {
                case UriPartial.Scheme:

                    string result = m_Scheme + (m_HasSlashes ? SchemeDelimiter : ":");

                    if (m_IsFileReally && !m_IsUnc) {
                        result += "/";
                    }
                    return result;

                case UriPartial.Authority:
                    if (!m_HasSlashes || (m_IsFileReally && !m_IsUnc)) {

                        //
                        // anything that didn't have "//" after the scheme name
                        // (mailto: and news: e.g.) doesn't have an authority
                        //

                        return String.Empty;
                    }
                    return NonPathPart;

                case UriPartial.Path:
                    return NonPathPart + m_Path;
            }
            throw new ArgumentException("part");
        }

        //
        // HexEscape
        //
        //  Converts an 8-bit character to hex representation
        //
        // Inputs:
        //  <argument>  character
        //      Character to convert
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  3 character string hex encoded version of input character
        //
        // Throws:
        //  ArgumentOutOfRangeException
        //

        internal static readonly char[] HexUpperChars = {
            '0', '1', '2', '3', '4', '5', '6', '7',
            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
        };

        internal static readonly char[] HexLowerChars = {
            '0', '1', '2', '3', '4', '5', '6', '7',
            '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
        };

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.HexEscape"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Transforms a character into its hexadecimal representation.
        ///    </para>
        /// </devdoc>
        public static string HexEscape(char character) {
            if (character > '\xff') {
                throw new ArgumentOutOfRangeException("character");
            }
            return HexEscape_NoCheck(character);
        }

        //
        // HexEscape_NoCheck
        //
        //  Internal version of HexEscape() which does not perform parameter
        //  validation
        //
        // Inputs:
        //  see HexEscape()
        //
        // Outputs:
        //  see HexEscape()
        //
        // Assumes:
        //  see HexEscape()
        //
        // Returns:
        //  see HexEscape()
        //
        // Throws:
        //  Nothing
        //

        internal static string HexEscape_NoCheck(char character) {

            StringBuilder sb = new StringBuilder(3);

            sb.Length = 3;
            sb[0] = '%';
            sb[1] = HexUpperChars[(character & 0xf0) >> 4];
            sb[2] = HexUpperChars[character & 0xf];
            return sb.ToString();
        }

        //
        // HexUnescape
        //
        //  Converts a substring of the form "%XX" to the single character represented
        //  by the hexadecimal value XX. If the substring s[Index] does not conform to
        //  the hex encoding format then the character at s[Index] is returned
        //
        // Inputs:
        //  <argument>  pattern
        //      String from which to read the hexadecimal encoded substring
        //
        //  <argument>  index
        //      Offset within <pattern> from which to start reading the hexadecimal
        //      encoded substring
        //
        // Outputs:
        //  <argument>  index
        //      Incremented to the next character position within the string. This
        //      may be EOS if this was the last character/encoding within <pattern>
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  Either the converted character if <pattern>[<index>] was hex encoded, or
        //  the character at <pattern>[<index>]
        //
        // Throws:
        //  ArgumentOutOfRangeException
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.HexUnescape"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Transforms a hexadecimal representation of a character to the character.
        ///    </para>
        /// </devdoc>
        public static char HexUnescape(string pattern, ref int index) {
            if ((index < 0) || (index >= pattern.Length)) {
                throw new ArgumentOutOfRangeException("index");
            }
            if ((pattern[index] == '%')
                && (pattern.Length - index >= 3)
                && IsHexDigit(pattern[index + 1]) && IsHexDigit(pattern[index + 2])) {
                ++index;
                return Convert.ToChar(FromHex_NoCheck(pattern[index++]) * 16
                                      + FromHex_NoCheck(pattern[index++]));
            }
            return pattern[index++];
        }

        //
        // HexUnescape_NoCheck
        //
        //  Performs HexUnescape without parameter validation
        //
        // Inputs:
        //  <argument>  pattern
        //      String from which to read the hexadecimal encoded substring
        //
        //  <argument>  index
        //      Offset within <pattern> from which to start reading the hexadecimal
        //      encoded substring
        //
        // Outputs:
        //  <argument>  index
        //      Incremented to the next character position within the string. This
        //      may be EOS if this was the last character/encoding within <pattern>
        //
        // Assumes:
        //  0 < <index> < <pattern>.Length
        //
        // Returns:
        //  Either the converted character if <pattern>[<index>] was hex encoded, or
        //  the character at <pattern>[<index>]
        //
        // Throws:
        //  Nothing
        //

        internal static char HexUnescape_NoCheck(string pattern, ref int index) {
            if ((pattern[index] == '%')
                && (pattern.Length - index >= 3)
                && IsHexDigit(pattern[index + 1]) && IsHexDigit(pattern[index + 2])) {
                ++index;
                return Convert.ToChar(FromHex_NoCheck(pattern[index++]) * 16
                                      + FromHex_NoCheck(pattern[index++]));
            }
            return pattern[index++];
        }

        //
        // IsBadFileSystemCharacter
        //
        //  Determine whether a character would be an invalid character if used in
        //  a file system name. Note, this is really based on NTFS rules
        //
        // Inputs:
        //  <argument>  character
        //      Character to test
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  ASCII comparisons legal
        //
        // Returns:
        //  true if <character> would be a treated as a bad file system character
        //  else false
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.IsBadFileSystemCharacter"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected virtual bool IsBadFileSystemCharacter(char character) {
            return (character < 0x20)
                    || (character == ';')
                    || (character == '/')
                    || (character == '?')
                    || (character == ':')
                    || (character == '&')
                    || (character == '=')
                    || (character == ',')
                    || (character == '*')
                    || (character == '<')
                    || (character == '>')
                    || (character == '"')
                    || (character == '|')
                    || (character == '\\')
                    || (character == '^')
                    ;
        }

        //
        // IsExcludedCharacter
        //
        //  Determine if a character should be exluded from a URI and therefore be
        //  escaped
        //
        // Inputs:
        //  <argument>  character
        //      Character to test
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  ASCII comparisons legal
        //
        // Returns:
        //  true if <character> should be escaped else false
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.IsExcludedCharacter"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected static bool IsExcludedCharacter(char character) {

            //
            // the excluded characters...
            //

            return (character <= 0x20)
                    || (character >= 0x7f)
                    || (character == '<')
                    || (character == '>')
                    || (character == '#')
                    || (character == '%')
                    || (character == '"')

            //
            // the 'unwise' characters...
            //

                    || (character == '{')
                    || (character == '}')
                    || (character == '|')
                    || (character == '\\')
                    || (character == '^')
                    || (character == '[')
                    || (character == ']')
                    || (character == '`')
                    ;
        }

        //
        // IsHexDigit
        //
        //  Determines whether a character is a valid hexadecimal digit in the range
        //  [0..9] | [A..F] | [a..f]
        //
        // Inputs:
        //  <argument>  character
        //      Character to test
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  true if <character> is a hexadecimal digit character
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.IsHexDigit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if a character is a valid hexadecimal digit.
        ///    </para>
        /// </devdoc>
        public static bool IsHexDigit(char character) {
            return ((character >= '0') && (character <= '9'))
                    || ((character >= 'A') && (character <= 'F'))
                    || ((character >= 'a') && (character <= 'f'));
        }

        //
        // IsHexEncoding
        //
        //  Determines whether a substring has the URI hex encoding format of '%'
        //  followed by 2 hexadecimal characters
        //
        // Inputs:
        //  <argument>  pattern
        //      String to check
        //
        //  <argument>  index
        //      Offset in <pattern> at which to check substring for hex encoding
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  0 <= <index> < <pattern>.Length
        //
        // Returns:
        //  true if <pattern>[<index>] is hex encoded, else false
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.IsHexEncoding"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if a string is hex
        ///       encoded.
        ///    </para>
        /// </devdoc>
        public static bool IsHexEncoding(string pattern, int index) {
            if ((pattern.Length - index) < 3) {
                return false;
            }
            return IsHexEncoding_NoCheck(pattern, index);
        }

        //
        // IsHexEncoding_NoCheck
        //
        //  Performs the same function as IsHexEncoding without the string length
        //  check
        //
        // Inputs:
        //  see IsHexEncoding()
        //
        // Outputs:
        //  see IsHexEncoding()
        //
        // Assumes:
        //  see IsHexEncoding()
        //
        // Returns:
        //  see IsHexEncoding()
        //
        // Throws:
        //  see IsHexEncoding()
        //

        internal static bool IsHexEncoding_NoCheck(string pattern, int index) {
            return (pattern[index] == '%')
                    && IsHexDigit(pattern[index + 1])
                    && IsHexDigit(pattern[index + 2]);
        }

        //
        // IsPrefix
        //
        //  Determines whether <prefix> is a prefix of this URI. A prefix match
        //  is defined as:
        //
        //      scheme match
        //      + host match
        //      + port match, if any
        //      + <prefix> path is a prefix of <URI> path, if any
        //
        // Inputs:
        //  <argument>  prefix
        //      Possible prefix string
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  True if <prefix> is a prefix of this URI
        //
        // Throws:
        //  UriFormatException
        //

        internal bool IsPrefix(string prefix) {

            Uri prefixUri;

            try {
                prefixUri = new Uri(prefix);
            } catch (UriFormatException) {
                return false;
            }
            return IsPrefix(prefixUri);
        }

        //
        // IsPrefix
        //
        //  Determines whether <prefixUri> is a prefix of this URI. A prefix
        //  match is defined as:
        //
        //      scheme match
        //      + host match
        //      + port match, if any
        //      + <prefix> path is a prefix of <URI> path, if any
        //
        // Inputs:
        //  <argument>  prefixUri
        //      Possible prefix URI
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  True if <prefixUri> is a prefix of this URI
        //
        // Throws:
        //  Nothing
        //

        internal bool IsPrefix(Uri prefixUri) {
            return (prefixUri.Scheme == Scheme)
                    && (prefixUri.Host == Host)
                    && (prefixUri.Port == Port)
                    && AbsolutePath.Substring(0, AbsolutePath.LastIndexOf('/')).StartsWith(
                        prefixUri.AbsolutePath.Substring(0, prefixUri.AbsolutePath.LastIndexOf('/')));
        }

        //
        // IsPrefix
        //
        //  Determines whether <prefix> is a prefix of <uri>. A prefix match is
        //  defined as:
        //
        //      scheme match
        //      + host match
        //      + port match, if any
        //      + <prefix> path is a prefix of <uri> path, if any
        //
        // Inputs:
        //  <argument>  prefix
        //      Possible prefix string
        //
        //  <argument>  uri
        //      URI string to test for possible prefix match with <prefix>
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  True if <prefix> is a prefix of <uri>
        //
        // Throws:
        //  UriFormatException
        //

        internal static bool IsPrefix(string prefix, string uri) {

            Uri u = new Uri(uri);

            return u.IsPrefix(prefix);
        }

        //
        // IsReservedCharacter
        //
        //  Determine whether a character is part of the reserved set
        //
        // Inputs:
        //  <argument>  character
        //      Character to test
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  ASCII comparisons legal
        //
        // Returns:
        //  true if <character> is reserved else false
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.IsReservedCharacter"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected virtual bool IsReservedCharacter(char character) {
            return (character == ';')
                    || (character == '/')
                    || (character == ':')
                    || (character == '@')   // OK FS char
                    || (character == '&')
                    || (character == '=')
                    || (character == '+')   // OK FS char
                    || (character == '$')   // OK FS char
                    || (character == ',')
                    ;
        }

        //
        // MakeRelative
        //
        //  Return a relative path which when applied to this Uri would create the
        //  resulting Uri <toUri>
        //
        // Inputs:
        //  <argument>  toUri
        //      Uri to which we calculate the transformation from this Uri
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  If the 2 Uri are common except for a relative path difference, then that
        //  difference, else the display name of this Uri
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.MakeRelative"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the difference between two <see cref='System.Uri'/> instances.
        ///    </para>
        /// </devdoc>
        public string MakeRelative(Uri toUri) {
            if ((Scheme == toUri.Scheme)
                && (Authority == toUri.Authority)
                && (m_Port == toUri.Port)) {
                return PathDifference(AbsolutePath,
                                      toUri.AbsolutePath,

                                      //
                                      // if this is a file Uri then we ignore
                                      // case in the path characters
                                      //

                                      !m_IsFileReally
                                      );
            }
            return toUri.ToString();
        }

        //
        // MakeRelative
        //
        //  Return a relative path which when applied to <path1> with a Combine()
        //  results in <path2>
        //
        // Inputs:
        //  <argument>  path1
        //  <argument>  path2
        //      Paths for which we calculate the relative difference
        //
        //  <argument>  compareCase
        //      False if we should consider characters that differ only in case
        //      to be equal
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  the relative path difference which when applied to <path1> using
        //  Combine(), results in <path2>
        //
        // Throws:
        //  Nothing
        //

        internal static string MakeRelative(string path1, string path2, bool compareCase) {

            Uri u1 = new Uri(path1);
            Uri u2 = new Uri(path2);

            //return PathDifference(path1, path2, compareCase);
            return u1.MakeRelative(u2);
        }

        //
        // Parse
        //
        //  Parse the URI into its constituent components. We accept the
        //  following forms:
        //
        //      <scheme>://<server>/<path>
        //      c:\path
        //      c|\path
        //      \\server\share\path
        //      file:c:\path
        //      file:/c:\path
        //      file://c:\path
        //      file:///c:\path
        //      file:////c:\path (or more leading slashes)
        //      file://server/path
        //      file://server/path
        //      file:///server/path
        //      file:\\server\path
        //      file:///path
        //
        // Inputs:
        //  <member>    m_Path
        //      Holds string containing URI to parse
        //
        // Outputs:
        //  <member>    m_HasSlashes
        //      Set if the scheme was followed by a net name designator (//)
        //
        //  <member>    m_UserInfo
        //      Set to any username:password found in the URI
        //
        //  <member>    m_Host
        //      Set to the host name
        //
        //  <member>    m_Port
        //      Set to the port value if found, else -1 (== no port supplied)
        //
        //  <member>    m_Path
        //      Set to the uncanonicalized path part, ready for Canonicalize()
        //
        //  <member>    m_Fragment
        //      Set if there was a '#' at the end of the path part
        //
        //  <member>    m_Query
        //      Set if there was a '?' at the end of the path part
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  Nothing
        //
        // Throws:
        //  UriFormatException
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Parse"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected virtual void Parse() {

            string uriString = m_Path;
            int index = uriString.IndexOf(':');
            bool isMailto = false;

            if (index > 1) {
                m_HasScheme = true;
                m_Scheme = uriString.Substring(0, index++).ToLower(CultureInfo.InvariantCulture);
                if (!CheckSchemeName(m_Scheme)) {
                    throw new UriFormatException(SR.GetString(SR.net_uri_BadScheme));
                }
                if (m_Scheme == UriSchemeFile) {
                    m_IsFile = true;
                    m_IsFileReally = true;
                    m_HasSlashes = true;
                }
                else {
                    m_Port = DefaultPortForScheme(m_Scheme);
                    isMailto = m_Scheme == UriSchemeMailto;
                }
            }
            else {

                //
                // assume file - either UNC or local (Windows) path
                //

                m_Scheme = UriSchemeFile;
                m_HasSlashes = true;
                m_IsFile = true;
                index = 0;
            }

            int nSlashes = 0;

            while ((index < uriString.Length)
                   && ((uriString[index] == '/') || (uriString[index] == '\\'))) {
                ++index;
                ++nSlashes;
            }
            if (!m_IsFile && (nSlashes > 2)) {
                throw new UriFormatException(SR.GetString(SR.net_uri_BadFormat));
            }

            //
            // if we think the path is a non-UNC file path but it doesn't begin
            // with <letter> (':' | '|') ('/' | '\\') then this is an error.
            // Legal file paths must be rooted local drive (Windows) paths.
            // Relative paths will be thrown out
            //

            bool looksLikeADriveLetter = (uriString.Length - index >= 3)
                                          && Char.IsLetter(uriString[index])
                                          && ((uriString[index + 1] == ':') || (uriString[index + 1] == '|'))
                                          && ((uriString[index + 2] == '/') || (uriString[index + 2] == '\\'));

            if (m_IsFile && !looksLikeADriveLetter) {
                if (nSlashes >= 2) {
                    m_IsUnc = true;
                    m_IsFileReally = true;
                }
                else {
                    throw new UriFormatException(SR.GetString(SR.net_uri_BadFormat));
                }
            } else {
                if ((nSlashes >= 2) || IsSchemeKnownToHaveSlashes) {
                    m_HasSlashes = true;
                }
                if (looksLikeADriveLetter) {
                    m_IsFileReally = true;
                    m_HasSlashes = true;
                }
            }

            //
            // find the various interesting component delimiters
            //

            int ai = -1; // at ('@') index
            int bi = -1; // blank (space) index
            int ci = -1; // colon index
            int fi = -1; // fragment ('#') index
            int pi = -1; // percent-sign index
            int qi = -1; // query ('?') index
            int si = -1; // slash index
            int bsi = -1;   // backslash index
            int lbi = -1;   // left bracket index (for IPv6 address)
            int rbi = -1;   // right bracket index (for IPv6 address)
            int terminator = uriString.Length;

            for (int i = index; i < uriString.Length; ++i) {
                switch (uriString[i]) {
                    case ' ':
                        if ((si != -1) && (bi == -1)) {

                            //
                            // there's a space in the path. So even if we have what looks
                            // like embedded hex sequences, we'll still recommend the
                            // path be escaped
                            //

                            bi = i;
                        }
                        continue;

                    case '@':

                        //
                        // only interested in '@' if we haven't found any path
                        // components yet
                        //

                        if (ai == -1 && si == -1 && bsi == -1) {

                            //
                            // if we already found a colon, then ignore it. Its the
                            // password delimiter, which we don't care about
                            //

                            if (ci != -1) {
                                ci = -1;
                            }
                            ai = i;
                        }
                        continue;

                    case ':':

                        //
                        // similarly, only note colon position if before the path
                        // component AND if colon is not encountered after '['
                        // which denotes an IPv6 address. We only care about the
                        // left bracket because we're looking for the colon
                        // separating name and password, and that's only legal
                        // before the host name, including an IPv6 address
                        //

                        if ((ci == -1) && (si == -1) && ((lbi == -1) ? true : (rbi != -1))) {
                            ci = i;
                        }
                        continue;

                    case '/':

                        //
                        // '/' can also be used as a prefix separator in an IPv6
                        // address. IPv6 addresses are contained within [..], so
                        // this is a path separator index if we don't have an
                        // IPv6 address, or if we're already past it
                        //

                        if ((si == -1) && ((lbi != -1) ? (rbi != -1) : true)) {
                            si = i;
                        }
                        continue;

                    case '\\':
                        if (bsi == -1) {
                            bsi = i;
                        }
                        continue;

                    case '%':
                        //make sure we're not in an ipv6 address
                        if (lbi != -1 && rbi == -1)
                        {
                            continue;
                        }

                        if (si != -1) {
                            if (pi == -1) {
                                pi = i;
                            }

                            //
                            // if the string is already escaped but contains a
                            // %XX sequence then note that the various URI parts
                            // are escaped so that we unescape them before
                            // returning them to the application in a display
                            // name, e.g.
                            //

                            if (IsHexEncoding(uriString, i) && m_AlreadyEscaped) {
                                m_PathEscaped = true;
                            }
                        }
                        continue;

                    case '#':
                        fi = i;
                        if (m_HasScheme) {
                            terminator = i;
                            goto done;
                        }
                        continue;

                    case '?':
                        qi = i;
                        if (m_HasScheme) {
                            terminator = i;
                            goto done;
                        }
                        continue;

                    case '[':
                        if (lbi == -1) {
                            lbi = i;
                        }
                        continue;

                    case ']':
                        if (rbi == -1) {
                            rbi = i;
                        }
                        continue;
                }
            }

        done:

            if (!m_IsFileReally && (m_HasSlashes || isMailto)) {

                //
                // 1. parse user info. Ignore <empty string>@
                //

                if (ai != -1) {
                    if ((ai - index) >= 1) {
                        m_UserInfo = uriString.Substring(index, ai - index);
                    }
                    index = ai + 1;

                    //
                    // at least determine that user info conforms to the spec. If
                    // the userinfo is just ":" then ignore it
                    //

                    if (m_UserInfo.Length > 0) {

                        int passwordIndex = m_UserInfo.IndexOf(':');

                        if (passwordIndex == 0) {
                            if (m_UserInfo.Length > 1) {

                                //
                                // <empty>:<password> - exception
                                //

                                throw new UriFormatException(SR.GetString(SR.net_uri_BadUserPassword));
                            }
                            else {

                                //
                                // <empty>:<empty> - ignore
                                //

                                m_UserInfo = String.Empty;
                            }
                        }
                        else {

                            int i;

                            for (i = 0; i < passwordIndex; ++i) {
                                if ((m_UserInfo[i] == ';')
                                    || (m_UserInfo[i] == ':')
                                    || (m_UserInfo[i] == '?')
                                    || (m_UserInfo[i] == '/')) {
                                    throw new UriFormatException(SR.GetString(SR.net_uri_BadUserPassword));
                                }
                            }
                            for (i = passwordIndex + 1; i < m_UserInfo.Length; ++i) {
                                if ((m_UserInfo[i] == ';')
                                    || (m_UserInfo[i] == ':')
                                    || (m_UserInfo[i] == '?')
                                    || (m_UserInfo[i] == '/')) {
                                    throw new UriFormatException(SR.GetString(SR.net_uri_BadUserPassword));
                                }
                            }
                        }
                    }
                }

                //
                // 2. parse host and port (authority)
                //

                int authTerminator = (si != -1) ? si : terminator;
                int hostTerminator = (ci != -1) ? ci : authTerminator;
                string name = uriString.Substring(index, hostTerminator - index);

                //
                // ensure host name is valid
                //

                if (name.Length > 0) {
                    if ((name == "*") && (m_Scheme == UriSchemeNews)) {
                        m_Host = new BasicHostName("*");
                    }
                    else {
                        m_Host = CreateHost(name);
                    }
                }
                if (m_Host == null) {
                    throw new UriFormatException(SR.GetString(SR.net_uri_BadHostName));
                }

                //
                // ci cannot be == 0. Allow for not-present port numbers. Anything else
                // is an error
                //

                m_IsDefaultPort = true;
                if ((ci > 0) && (authTerminator - ci > 1)) {

                    int port = 0;

                    while (++ci < authTerminator) {

                        int n = (int)uriString[ci] - (int)'0';

                        if ((n >= 0) && (n <= 9)) {
                            port = port * 10 + n;
                        }
                        else {
                            break;
                        }
                    }
                    if (ci != authTerminator) {
                        throw new UriFormatException(SR.GetString(SR.net_uri_BadHostName));
                    }
                    if (m_Port != port) {
                        m_IsDefaultPort = false;
                    }
                    m_Port = port;
                }
            }
            else {
                m_IsDefaultPort = true; // don't add port when recreating path
                if (m_IsUnc) {

                    int hi = (bsi != -1)
                             ? ((si != -1) ? ((bsi < si) ? bsi : si) : bsi)
                             : ((si != -1) ? si : uriString.Length);

                    m_Host = CreateHost(uriString.Substring(index, hi - index));
                    if (m_Host == null) {
                        throw new UriFormatException(SR.GetString(SR.net_uri_BadHostName));
                    }
                    index = hi;
                }
                else {
                    m_Host = new BasicHostName(String.Empty);
                }
                si = index;
            }

            //
            // 3. parse path
            //

            m_Path = (si == -1)
                        ? (m_HasSlashes ? "/" : String.Empty)
                        : uriString.Substring(si, terminator - si);

            //
            // 4. parse fragment or query if URI did have a scheme (it is NOT a DOS or UNC path)
            //

            if (m_HasScheme) {
                if (qi != -1) {
                    ++qi;

                    string s = "";
                    if (qi < uriString.Length) {
                        int end = qi;
                        while(end < uriString.Length) {
                            if (uriString[end] == '#') {
                                fi = end;
                                break;
                            }
                            ++end;
                        }

                        s = uriString.Substring(qi, end-qi);
                        if (!m_AlreadyEscaped) {
                            s = EscapeString(s, false, out m_QueryEscaped);
                        }
                        else {
                            // ToString will always run Unescape on Query
                            m_QueryEscaped = true;
                        }
                    }
                    m_Query = '?' + s;
                }

                if (fi != -1) {
                    ++fi;

                    int len = uriString.Length - fi;
                    string s = "";

                    if (len > 0) {
                        s = uriString.Substring(fi, len);
                        if (!m_AlreadyEscaped) {
                            s = EscapeString(s, false, out m_FragmentEscaped);
                        }
                        else {
                            // ToString will always run Unescape on Fragment
                            m_FragmentEscaped = true;
                        }
                    }
                    m_Fragment = '#' + s;
                }
            }
        }

        //
        // PathDifference
        //
        //  Performs the relative path calculation for MakeRelative()
        //
        // Inputs:
        //  <argument>  path1
        //  <argument>  path2
        //      Paths for which we calculate the difference
        //
        //  <argument>  compareCase
        //      False if we consider characters that differ only in case to be
        //      equal
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  A string which is the relative path difference between <path1> and
        //  <path2> such that if <path1> and the calculated difference are used
        //  as arguments to Combine(), <path2> is returned
        //
        // Throws:
        //  Nothing
        //

        private static string PathDifference(string path1, string path2, bool compareCase) {

            int i;
            int si = -1;

            for (i = 0; (i < path1.Length) && (i < path2.Length); ++i) {
                if ((path1[i] != path2[i])
                    && (compareCase
                        ? true
                        : (Char.ToLower(path1[i], CultureInfo.InvariantCulture) != Char.ToLower(path2[i], CultureInfo.InvariantCulture)))) {
                        break;
                } else if (path1[i] == '/') {
                    si = i;
                }
            }
            if (i == 0) {
                return path2;
            }
            if ((i == path1.Length) && (i == path2.Length)) {
                return String.Empty;
            }

            StringBuilder relPath = new StringBuilder();

            for (; i < path1.Length; ++i) {
                if (path1[i] == '/') {
                    relPath.Append("../");
                }
            }
            return relPath.ToString() + path2.Substring(si + 1);
        }

        internal static bool SchemeHasSlashes(string scheme) {
            return !((scheme == UriSchemeMailto) || (scheme == UriSchemeNews));
        }

        //
        // ToString
        //
        //  Return the default string value for this object - i.e. the display name.
        //  That is typically the most useful value to return
        //
        // Inputs:
        //  Nothing
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  String that is display name for this Uri
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the display string for this <see cref='System.Uri'/> instance.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            if (m_String == null) {
                m_String = DisplayNameNoExtra +
                           DisplayQuery +
                           DisplayFragment;
            }
            return m_String;
        }

        //
        // Unescape
        //
        //  Convert any escape sequences in <path>. Escape sequences can be
        //  hex encoded reserved characters (e.g. %40 == '@') or hex encoded
        //  UTF-8 sequences (e.g. %C4%D2 == 'Latin capital Ligature Ij')
        //
        // Inputs:
        //  <argument>  path
        //      Parsed and canonicalized path; may contain escape sequences
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  Unescaped version of <path>
        //
        // Throws:
        //  Nothing
        //

        /// <include file='doc\URI.uex' path='docs/doc[@for="Uri.Unescape"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected virtual string Unescape(string path) {
            return UnescapePath(path, false);
        }

        //
        // UnescapePath
        //
        //  Convert any escape sequences in <path>. Escape sequences can be
        //  hex encoded reserved characters (e.g. %40 == '@') or hex encoded
        //  UTF-8 sequences (e.g. %C4%D2 == 'Latin capital Ligature Ij').
        //  Will not convert "%23" to '#' or "%3F" to '?' if <noSpecialChars>
        //  is true
        //
        // Inputs:
        //  <argument>  path
        //      Parsed and canonicalized path; may contain escape sequences
        //
        //  <argument>  noSpecialChars
        //      If true, will not convert "%23" to '#' or "%3F" to '?'. These
        //      are special characters and shouldn't appear in an unescaped
        //      path or they may be mistaken for fragment and query parts if
        //      the path is re-parsed, e.g. in CombineUri()
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  Unescaped version of <path>
        //
        // Throws:
        //  Nothing
        //

        private static string UnescapePath(string path, bool noSpecialChars) {
            if ((path == null) || (path.Length == 0)) {
                return String.Empty;
            }

            StringBuilder sb = new StringBuilder(path.Length);
            int current = 0;
            int next;

            sb.Length = 0;
            do {

                int index = path.IndexOf('%', current);

                if (path.Length - index < 3) {
                    index = -1;
                }
                next = (index == -1) ? path.Length : index;
                sb.Append(path.Substring(current, next - current));
                if (index != -1) {

                    byte [] bytes = new byte[path.Length - index];
                    char [] chars = new char[path.Length - index];
                    int byteCount = 0;
                    char ch;

                    do {

                        //
                        // this could cause an exception if we're at a '%' but
                        // there are < 3 chars left in the string. However, if
                        // that were true then this wouldn't be an escaped
                        // string, and we know that's not the case (otherwise
                        // we wouldn't be here)
                        //

                        ch = HexUnescape_NoCheck(path, ref next);
                        if (ch < '\x80') {

                            //
                            // character is not part of a UTF-8 sequence
                            //

                            break;
                        }
                        bytes[byteCount++] = (byte)ch;
                    } while (next < path.Length);
                    if (byteCount != 0) {

                        int charCount = Encoding.UTF8.GetCharCount(bytes, 0, byteCount);

                        if (charCount != 0) {
                            Encoding.UTF8.GetChars(bytes, 0, byteCount, chars, 0);
                            sb.Append(chars, 0, charCount);
                        } else {

                            //
                            // the encoded, high-ANSI characters are not UTF-8 encoded
                            //

                            for (int i = 0; i < byteCount; ++i) {
                                sb.Append((char)bytes[i]);
                            }
                        }
                    }
                    if (ch < '\x80') {

                        //
                        // if noSpecialChars is true and the character read from
                        // the string is '#' or '?' then maintain the %XX encoding
                        // of the character
                        //

                        if (noSpecialChars && ((ch == '#') || (ch == '?'))) {
                            sb.Append(path.Substring(next - 3, 3));
                        } else {
                            sb.Append(ch);
                        }
                    }
                }
                current = next;
            } while (next < path.Length);
            return sb.ToString();
        }
    } // class Uri
} // namespace System
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\urihostnametype.cs ===
//------------------------------------------------------------------------------
// <copyright file="UriHostNameType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System {
    /// <include file='doc\UriHostNameType.uex' path='docs/doc[@for="UriHostNameType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum UriHostNameType {
        /// <include file='doc\UriHostNameType.uex' path='docs/doc[@for="UriHostNameType.Unknown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Unknown,
        /// <include file='doc\UriHostNameType.uex' path='docs/doc[@for="UriHostNameType.Basic"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Basic,
        /// <include file='doc\UriHostNameType.uex' path='docs/doc[@for="UriHostNameType.Dns"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Dns,
        /// <include file='doc\UriHostNameType.uex' path='docs/doc[@for="UriHostNameType.IPv4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        IPv4,
        /// <include file='doc\UriHostNameType.uex' path='docs/doc[@for="UriHostNameType.IPv6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        IPv6
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\util\webconfigmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebConfigManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls.Util
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Reflection;
    using System.IO;
    using System.Windows.Forms;
    using System.Web.UI.MobileControls;
    using System.Web.UI.Design.MobileControls;
    using System.Xml;
    using SR = System.Web.UI.Design.MobileControls.SR;    

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class WebConfigManager
    {
        private readonly String _path = null;
        private ISite _site = null;
        private XmlDocument _document = null;

        private WebConfigManager()
        {
        }

        internal WebConfigManager(ISite site)
        {
            Debug.Assert(site != null);
            _site = site;

            // the following inspired by:
            // \VSDesigner\Designer\Microsoft\VisualStudio\Designer\Serialization\BaseDesignerLoader.cs

            Type projectItemType = Type.GetType("EnvDTE.ProjectItem, " + AssemblyRef.EnvDTE);
            if (projectItemType != null)
            {
                Object currentProjItem = _site.GetService(projectItemType);
                PropertyInfo containingProjectProp = projectItemType.GetProperty("ContainingProject");
                Object dteProject = containingProjectProp.GetValue(currentProjItem, new Object[0]);
                Type projectType = Type.GetType("EnvDTE.Project, " + AssemblyRef.EnvDTE);
                PropertyInfo fullNameProperty = projectType.GetProperty("FullName");
                String projectPath = (String)fullNameProperty.GetValue(dteProject, new Object[0]);

                _path = Path.GetDirectoryName(projectPath) + "\\web.config";
            }
        }

        internal XmlDocument Document
        {
            get
            {
                if (_document == null)
                {
                    _document = new XmlDocument();
                }

                return _document;
            }
        }

        private void LoadDocument()
        {
            try
            {
                Document.Load(_path);
            }
            catch (Exception ex)
            {
                Debug.Fail(ex.ToString());
                throw new Exception(SR.GetString(SR.WebConfig_FileLoadException));
            }
        }

        internal void EnsureWebConfigCheckedOut()
        {
            DesignerUtility.EnsureFileCheckedOut(_site, _path);
        }

        internal void EnsureWebConfigIsPresent()
        {
            if(!File.Exists(_path))
            {
                // We throw our own exception type so we can easily tell
                // between a corrupt web.config and a missing one.
                throw new FileNotFoundException(
                    SR.GetString(SR.WebConfig_FileNotFoundException)
                );
            }
        }

        internal ArrayList ReadDeviceFilters()
        {
            EnsureWebConfigIsPresent();

            // Reload the document everytime we read filters
            LoadDocument();

            XmlNode filters = Document.SelectSingleNode("configuration/system.web/deviceFilters");
            ArrayList DeviceFilterList = new ArrayList();

            if (filters != null)
            {
                Hashtable filterTable = new Hashtable();

                foreach(XmlNode childNode in filters.ChildNodes)
                {
                    if (childNode.Name != null && childNode.Name.Equals("filter"))
                    {
                        // Ignore the empty filter.
                        if (childNode.Attributes["name"] == null ||
                            childNode.Attributes["name"].Value == null ||
                            childNode.Attributes["name"].Value.Length == 0)
                        {
                            continue;
                        }

                        String filterName = childNode.Attributes["name"].Value;
                        if (filterTable[filterName] != null)
                        {
                            throw new Exception(SR.GetString(SR.DeviceFilterEditorDialog_DuplicateNames));
                        }

                        DeviceFilterNode node = new DeviceFilterNode(this, childNode);
                        DeviceFilterList.Add(node);
                        filterTable[filterName] = true;
                    }
                }
            }

            return DeviceFilterList;
        }

        private bool IsSystemWebSectionPresent()
        {
            EnsureWebConfigIsPresent();

            XmlNode filters = Document.SelectSingleNode("configuration/system.web/deviceFilters");

            return filters != null;
        }

        internal void EnsureSystemWebSectionIsPresent()
        {
            if(!IsSystemWebSectionPresent())
            {
                Debug.Assert(Document != null);

                XmlNode configSection = Document.SelectSingleNode("configuration");
                if (configSection == null)
                {
                    throw new Exception(SR.GetString(SR.WebConfig_FileLoadException));
                }

                if (configSection.SelectSingleNode("system.web") == null)
                {
                    XmlElement newWebSection = Document.CreateElement("system.web");
                    configSection.AppendChild(newWebSection);
                }

                XmlNode webSection = Document.SelectSingleNode("configuration/system.web");
                if (webSection.SelectSingleNode("deviceFilters") == null)
                {
                    XmlElement newFilters = Document.CreateElement("deviceFilters");
                    webSection.AppendChild(newFilters);
                }
            }
        }

        internal void Save()
        {
            Document.Save(_path);
        }
    }

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DeviceFilterNode : ICloneable
    {
        internal enum DeviceFilterMode
        {
            Compare,
            Delegate
        };

        private WebConfigManager _webConfig = null;
        private XmlNode _xmlNode = null;
        internal DeviceFilterMode Mode;

        private String _name;
        private String _type;
        private String _method;
        private String _compare;
        private String _argument;

        internal DeviceFilterNode(WebConfigManager webConfig) : base()
        {
            _webConfig = webConfig;
            _xmlNode = webConfig.Document.CreateElement("filter");

            Name = SR.GetString(SR.DeviceFilterNode_DefaultFilterName);
            Mode = DeviceFilterMode.Compare;
        }

        internal DeviceFilterNode(
            WebConfigManager webConfig,
            XmlNode xmlNode
        ) {
            _webConfig = webConfig;
            _xmlNode = xmlNode;

            Debug.Assert(_xmlNode.Attributes != null);

            if (_xmlNode.Attributes["type"] != null)
            {
                Mode = DeviceFilterMode.Delegate;
                Debug.Assert(
                    _xmlNode.Attributes["argument"] == null && _xmlNode.Attributes["compare"] == null,
                    "Managementobject contains both Compare and Delegate mode properties."
                );
            }
            else
            {
                Mode = DeviceFilterMode.Compare;
                // we already know type is null, but it nevers hurts...
                Debug.Assert(
                    _xmlNode.Attributes["type"] == null && _xmlNode.Attributes["method"] == null,
                    "Managementobject contains both Compare and Delegate mode properties."
                );
            }

            _name = _xmlNode.Attributes["name"] == null? 
                null : _xmlNode.Attributes["name"].Value;

            _compare = _xmlNode.Attributes["compare"] == null?
                null : _xmlNode.Attributes["compare"].Value;

            _argument = _xmlNode.Attributes["argument"] == null?
                null : _xmlNode.Attributes["argument"].Value;

            _type = _xmlNode.Attributes["type"] == null?
                null : _xmlNode.Attributes["type"].Value;

            _method = _xmlNode.Attributes["method"] == null?
                null : _xmlNode.Attributes["method"].Value;
        }

        internal void Delete()
        {
            Debug.Assert(_xmlNode != null);

            if (_xmlNode.ParentNode != null)
            {
                _xmlNode.ParentNode.RemoveChild(_xmlNode);
            }
        }

        internal void Save()
        {
            Debug.Assert(_xmlNode != null);

            if (_xmlNode.Attributes["name"] == null)
            {
                _xmlNode.Attributes.Append(_webConfig.Document.CreateAttribute("name"));
            }
            _xmlNode.Attributes["name"].Value = Name;

            if(Mode == DeviceFilterMode.Compare)
            {
                Type = null;
                Method = null;
                _xmlNode.Attributes.RemoveNamedItem("type");
                _xmlNode.Attributes.RemoveNamedItem("method");

                if (_xmlNode.Attributes["compare"] == null)
                {
                    _xmlNode.Attributes.Append(_webConfig.Document.CreateAttribute("compare"));
                }
                _xmlNode.Attributes["compare"].Value = Compare;

                if (_xmlNode.Attributes["argument"] == null)
                {
                    _xmlNode.Attributes.Append(_webConfig.Document.CreateAttribute("argument"));
                }
                _xmlNode.Attributes["argument"].Value = Argument;

            }
            else
            {
                Compare = null;
                Argument = null;
                _xmlNode.Attributes.RemoveNamedItem("compare");
                _xmlNode.Attributes.RemoveNamedItem("argument");

                if (_xmlNode.Attributes["type"] == null)
                {
                    _xmlNode.Attributes.Append(_webConfig.Document.CreateAttribute("type"));
                }
                _xmlNode.Attributes["type"].Value = Type;

                if (_xmlNode.Attributes["method"] == null)
                {
                    _xmlNode.Attributes.Append(_webConfig.Document.CreateAttribute("method"));
                }
                _xmlNode.Attributes["method"].Value = Method;
            }

            _webConfig.EnsureSystemWebSectionIsPresent();

            XmlNode filters = 
                _webConfig.Document.SelectSingleNode("configuration/system.web/deviceFilters");
            filters.AppendChild(_xmlNode);
        }

        // Cause the DeviceFilterNode to display correctly when inserted
        // in a combo box.
        public override String ToString()
        {
            if(Name == null || Name.Length == 0)
            {
                return SR.GetString(SR.DeviceFilter_DefaultChoice);
            }
            return Name;
        }

        internal String Name
        {
            get { return _name; }
            set { _name = value; }
        }

        internal String Type
        {
            get { return _type; }
            set { _type = value; }
        }

        internal String Method
        {
            get { return _method; }
            set { _method = value; }
        }

        internal String Compare
        {
            get { return _compare; }
            set { _compare = value; }
        }

        internal String Argument
        {
            get { return _argument; }
            set { _argument = value; }
        }
        
        // <summary>
        //    Returns a copy of this node's encapsulated data.  Does not
        //    copy TreeNode fields.
        // </summary>
        public Object Clone()
        {
            DeviceFilterNode newNode = new DeviceFilterNode(
                _webConfig
            );
            newNode.Name = this.Name;
            newNode.Mode = this.Mode;
            if(this.Mode == DeviceFilterMode.Compare)
            {
                newNode.Compare = this.Compare;
                newNode.Argument = this.Argument;
            }
            else
            {
                newNode.Type = this.Type;
                newNode.Method = this.Method;
            }
            return (Object) newNode;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\_domainname.cs ===
//------------------------------------------------------------------------------
// <copyright file="_DomainName.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System.Globalization;

namespace System {
    internal class DomainName : HostNameType {

    // fields

        private static int m_LoopbackHash = Uri.CalculateCaseInsensitiveHashCode("loopback");
        private static int m_LocalHostHash = Uri.CalculateCaseInsensitiveHashCode("localhost");

    // constructors

        internal DomainName(string name) : base(name.ToLower(CultureInfo.InvariantCulture)) {
            m_IsLoopback = (m_HashCode == m_LoopbackHash) || (m_HashCode == m_LocalHostHash);
            if (m_IsLoopback) {
                // this.Name is already in lowercase.
                if (String.Compare(Name, "loopback", false, CultureInfo.InvariantCulture) != 0 && 
                    String.Compare(Name, "localhost", false, CultureInfo.InvariantCulture) != 0 ) {
                    m_IsLoopback = false;
                }
            }
        }

    // properties

    // methods

        //
        // IsValid
        //
        //  Determines whether a string is a valid domain name
        //
        //      subdomain -> <label> | <label> "." <subdomain>
        //
        // Inputs:
        //  <argument>  name
        //      Name to test
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  bool
        //
        // Throws:
        //  Nothing
        //

        internal static bool IsValid(string name) {
            if ((name == null) || (name.Length == 0)) {
                return false;
            }

            int offset = 0;
            int length = name.Length;
            int subLength;

            do {
                subLength = name.IndexOf('.', offset) - offset;
                if (subLength < 0) {
                    subLength = length;
                }
                if (!IsValidLabel(name, offset, subLength)) {
                    return false;
                }
                length -= subLength + 1;
                offset += subLength + 1;
            } while (length > 0);
            return true;
        }

        //
        // IsLetter
        //
        //  Determines whether a character is a valid letter according to
        //  RFC 1035. Note: we don't use Char.IsLetter() because it assumes
        //  some non-ANSI characters out of the range A..Za..z are also
        //  valid letters
        //
        // Inputs:
        //  <argument>  character
        //      character to test
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Only A..Z and a..z are letters
        //
        // Returns:
        //  bool
        //
        // Throws:
        //  Nothing
        //

        private static bool IsLetter(char character) {
            return ((character >= 'A') && (character <= 'Z'))
                    || ((character >= 'a') && (character <= 'z'));
        }

        //
        // IsLetterOrDigit
        //
        //  Determines whether a character is a letter or digit according to the
        //  DNS specification [RFC 1035]. We use our own variant of IsLetterOrDigit
        //  because the base version returns false positives for non-ANSI characters
        //
        // Inputs:
        //  <argument>  character
        //      character to test
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  bool
        //
        // Throws:
        //  Nothing
        //

        private static bool IsLetterOrDigit(char character) {
            return IsLetter(character) || Char.IsDigit(character);
        }

        //
        // IsValidCharacter
        //
        //  Variant of DomainName.IsLetter which takes into account the
        //  additional legal domain name character, '-'
        //
        // Inputs:
        //  <argument>  character
        //      character to test
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  bool
        //
        // Throws:
        //  Nothing
        //

        private static bool IsValidCharacter(char character) {

            //
            // RAID#9445
            // we are not allowing NetBIOS names containing embedded
            // underscore. Underscore is not a valid DNS character. May need to
            // revisit this post-M10 and determine between DNS and NetBIOS names
            // and perhaps apply different naming criteria
            //

            return IsLetterOrDigit(character) || (character == '-') || (character == '_');
        }

        //
        // IsValidLabel
        //
        //  Determines whether a string is a valid domain name label. In keeping
        //  with RFC 1123, section 2.1, the requirement that the first character
        //  of a label be alphabetic is dropped. Therefore, Domain names are
        //  formed as:
        //
        //      <label> -> <alphanum> [<alphanum> | <hyphen> | <underscore>] * 62
        //
        // Inputs:
        //  <argument>  label
        //      string to check
        //
        //  <argument>  offset
        //      offset in <label> at which to start check
        //
        //  <argument>  length
        //      length of substring to check
        //
        // Assumes:
        //  Label already checked for NULL or zero length
        //
        // Returns:
        //  bool
        //
        // Throws:
        //  Nothing
        //

        private static bool IsValidLabel(string label, int offset, int length) {
            if (!IsLetterOrDigit(label[offset]) || (length < 1) || (length > 63)) {
                return false;
            }
            for (int i = offset + 1; i < offset + length; ++i) {
                if (!IsValidCharacter(label[i])) {
                    return false;
                }
            }
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\uripartial.cs ===
//------------------------------------------------------------------------------
// <copyright file="URIPartial.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System {
    /// <include file='doc\URIPartial.uex' path='docs/doc[@for="UriPartial"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum UriPartial {
        /// <include file='doc\URIPartial.uex' path='docs/doc[@for="UriPartial.Scheme"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Scheme,
        /// <include file='doc\URIPartial.uex' path='docs/doc[@for="UriPartial.Authority"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Authority,
        /// <include file='doc\URIPartial.uex' path='docs/doc[@for="UriPartial.Path"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Path
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\_basichostname.cs ===
//------------------------------------------------------------------------------
// <copyright file="_BasicHostName.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.Globalization;

namespace System {
    internal class BasicHostName : HostNameType {

        internal BasicHostName(string name) : base(name) {
        }

        public override bool Equals(object comparand) {
            Debug.Assert(comparand != null);
            return String.Compare(Name, comparand.ToString(), true, CultureInfo.InvariantCulture) == 0;
        }

        public override int GetHashCode() {
            // 11/15/00 - avoid compiler warning
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\_ipv4address.cs ===
//------------------------------------------------------------------------------
// <copyright file="_IPv4Address.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System {
    internal class IPv4Address : HostNameType {

    // fields

        private const int NumberOfLabels = 4;

        private byte [] m_Numbers = new byte[NumberOfLabels];

    // constructors

        internal IPv4Address(string name) : base(name) {
            Parse();
            Name = CanonicalName;
            m_IsLoopback = ((m_Numbers[0] == 127)
                            && (m_Numbers[1] == 0)
                            && (m_Numbers[2] == 0)
                            && (m_Numbers[3] == 1));
        }

    // properties

        internal override string CanonicalName {
            get {
                return m_Numbers[0] + "." + m_Numbers[1] + "."
                        + m_Numbers[2] + "." + m_Numbers[3];
            }
        }

        internal byte this[int index] {
            get {
                return m_Numbers[index];
            }
        }

    // methods

        //
        // IsValid
        //
        //  Determines whether a name is a valid IPv4 4-part dotted-decimal address
        //
        // Inputs:
        //  <argument>  name
        //      String containing possible IPv4 address to check
        //
        // Assumes:
        //  <name> has already been checked for null/empty
        //
        // Returns:
        //  true if <name> contains a valid IPv4 address
        //
        // Throws:
        //  Nothing
        //

        internal static bool IsValid(string name) {

            int length = name.Length - 1;

            return IsValid(name, 0, ref length);
        }

        //
        // IsValid
        //
        //  Performs IsValid on a substring. Updates the index to where we
        //  believe the IPv4 address ends
        //
        // Inputs:
        //  <argument>  name
        //      string containing possible IPv4 address
        //
        //  <argument>  start
        //      offset in <name> to start checking for IPv4 address
        //
        //  <argument>  end
        //      offset in <name> of the last character we can touch in the check
        //
        // Outputs:
        //  <argument>  end
        //      index of last character in <name> we checked
        //
        // Assumes:
        //  <start> >= 0
        //  <start> <= <end>
        //  <name>.Length >= 0
        //
        // Returns:
        //  bool
        //
        // Throws:
        //  Nothing
        //

        internal static bool IsValid(string name, int start, ref int end) {

            int dots = 0;
            int number = 0;
            bool haveNumber = false;

            while (start <= end) {
                if (Char.IsDigit(name[start])) {
                    haveNumber = true;
                    number = number * 10 + (name[start] - '0');
                    if (number > 255) {
                        return false;
                    }
                } else if (name[start] == '.') {
                    if (!haveNumber) {
                        return false;
                    }
                    ++dots;
                    haveNumber = false;
                    number = 0;
                } else {
                    return false;
                }
                ++start;
            }
            end = start;
            return (dots == 3) && haveNumber;
        }

        //
        // Parse
        //
        //  Convert this IPv4 address into a sequence of 4 8-bit numbers
        //
        // Inputs:
        //  <member>    Name
        //      The validated IPv4 address
        //
        // Outputs:
        //  <member>    m_Numbers
        //      Array filled in with the numbers in the IPv4 labels
        //
        // Assumes:
        //  <Name> has been validated and contains only decimal digits in groups
        //  of 8-bit numbers and the characters '.'
        //
        // Returns:
        //  Nothing
        //
        // Throws:
        //  Nothing
        //

        internal void Parse() {
            for (int i = 0, j = 0; i < NumberOfLabels; ++i) {

                byte b = 0;

                for (; (j < Name.Length) && (Name[j] != '.'); ++j) {
                    b = (byte)(b * 10 + (byte)(Name[j] - '0'));
                }
                m_Numbers[i] = b;
                ++j;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\_hostnametype.cs ===
//------------------------------------------------------------------------------
// <copyright file="_HostNameType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System {

    using System.Net;
    using System.Globalization;
    using System.Diagnostics;

    internal abstract class HostNameType {

    // fields

        private string m_HostIdentifier = String.Empty;
        internal int m_HashCode = 0;
        internal bool m_IsLoopback = false;

    // constructors

        internal HostNameType(string hostName) {
            Name = hostName;
        }

    // properties

        internal virtual string CanonicalName {
            get {
                return Name;
            }
        }

        internal bool IsLoopback {
            get {
                return m_IsLoopback;
            }
        }

        internal string Name {
            get {
                return m_HostIdentifier;
            }
            set {
                m_HostIdentifier = value;
                CalculateHashCode();
            }
        }

    // methods

        private void CalculateHashCode() {

            //
            // default is case-sensitive hash-code generation because for DNS
            // names, IPv6 and IPv4 addresses, we have already canonicalized
            // the string, including converting to a standard case
            //

            if (Name.Length > 0) {
                m_HashCode = Uri.CalculateCaseInsensitiveHashCode(Name);
            }
        }

        public override bool Equals(object comparand) {
            Debug.Assert(comparand != null);

            //
            // if this && comparand are same types then compare hash codes
            //

            if (GetType() == comparand.GetType() && GetHashCode() == comparand.GetHashCode()) {
                return ToString() == comparand.ToString();
            } else { 
                return false;
            }
        }

        public override int GetHashCode() {
            return m_HashCode;
        }

        public override string ToString() {
            return CanonicalName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\_uncname.cs ===
//------------------------------------------------------------------------------
// <copyright file="_UncName.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------
using System.Globalization;

namespace System {
    internal class UncName : HostNameType {

    // fields

        private const int MaximumUncNameLength = 15;
        private const string BadUncChars = "\"*+,/:;<=>?[\\]|";

    // constructors

        internal UncName(string name) : base(name) {
        }

    // properties

    // methods

        public override bool Equals(object comparand) {
            return (String.Compare(Name, comparand.ToString(), true, CultureInfo.InvariantCulture) == 0);
        }

        public override int GetHashCode() {
            // 11/15/00 - avoid compiler warning
            return base.GetHashCode();
        }

        //
        // IsValid
        //
        //  Determine whether <name> is a valid UNC server name. A valid UNC
        //  name can consist of 15 characters and may not include the following
        //  invalid characters:
        //
        //      Invalid UNC server name chars:
        //
        //          "    34 0x22
        //          *    42 0x2A
        //          +    43 0x2B
        //          ,    44 0x2C
        //          /    47 0x2F
        //          :    58 0x3A
        //          ;    59 0x3B
        //          <    60 0x3C
        //          =    61 0x3D
        //          >    62 0x3E
        //          ?    63 0x3F
        //          [    91 0x5B
        //          \    92 0x5C
        //          ]    93 0x5D
        //          |   124 0x7C
        //          <leading space>
        //          <trailing space>
        //
        //  but may include the following valid characters:
        //
        //      Valid UNC server name chars:
        //
        //          !    33 0x21
        //          #    35 0x23
        //          $    36 0x24
        //          %    37 0x25
        //          &    38 0x26
        //          '    39 0x27
        //          (    40 0x28
        //          )    41 0x29
        //          -    45 0x2D
        //          .    46 0x2E    = this server?
        //          ;    59 0x3B
        //          @    64 0x40
        //          ^    94 0x5E
        //          _    95 0x5F
        //          `    96 0x60
        //          {   123 0x7B
        //          }   125 0x7D
        //          ~   126 0x7E
        //              127 0x7F
        //          <embedded space>
        //
        // Inputs:
        //  <argument>  name
        //      To determine for validity as UNC name
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  bool
        //
        // Throws:
        //  Nothing
        //

        internal static bool IsValid(string name) {
            if (name.Length > MaximumUncNameLength) {
                return false;
            }

            bool leading = true;
            int trailing = 0;

            for (int i = 0; i < name.Length; ++i) {
                if (name[i] == ' ') {
                    if (leading) {
                        return false;
                    } else {
                        leading = false;
                        ++trailing;
                    }
                } else {
                    if ((name[i] < ' ') || BadUncChars.IndexOf(name[i]) != -1) {
                        return false;
                    }
                    trailing = 0;
                }
            }
            return (trailing == 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\_ipv6address.cs ===
//------------------------------------------------------------------------------
// <copyright file="_IPv6Address.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System {

    using System.Diagnostics;

    internal class IPv6Address : HostNameType {

    // fields

        private const int NumberOfLabels = 8;
        private const string CanonicalNumberFormat = "{0:X4}";

        private ushort [] m_Numbers = new ushort[NumberOfLabels];
        private string m_ScopeId = null;
        internal int PrefixLength = 0;

    // constructors

        internal IPv6Address(string name) : base(name) {
            Parse();
            Name = CanonicalName;
        }

    // properties
     
        internal override string CanonicalName {
            get {
                return String.Format(CanonicalNumberFormat, m_Numbers[0]) + ":"
                        + String.Format(CanonicalNumberFormat, m_Numbers[1]) + ":"
                        + String.Format(CanonicalNumberFormat, m_Numbers[2]) + ":"
                        + String.Format(CanonicalNumberFormat, m_Numbers[3]) + ":"
                        + String.Format(CanonicalNumberFormat, m_Numbers[4]) + ":"
                        + String.Format(CanonicalNumberFormat, m_Numbers[5]) + ":"
                        + String.Format(CanonicalNumberFormat, m_Numbers[6]) + ":"
                        + String.Format(CanonicalNumberFormat, m_Numbers[7]) + 
                        ((m_ScopeId != null && m_ScopeId.Length > 0)?("%"+m_ScopeId):String.Empty);
            }
        }
       
        internal ushort this[int index] {
            get {
                return m_Numbers[index];
            }
        }

    // nethods

        //
        // IsValid
        //
        //  Determine whether a name is a valid IPv6 address. Rules are:
        //
        //   *  8 groups of 16-bit hex numbers, separated by ':'
        //   *  a *single* run of zeros can be compressed using the symbol '::'
        //   *  an optional 1 or 2 character prefix length field delimited by '/'
        //   *  the last 32 bits in an address can be represented as an IPv4 address
        //
        // Inputs:
        //  <argument>  name
        //      Domain name field of a URI to check for pattern match with
        //      IPv6 address
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  true if <name> has IPv6 format, else false
        //
        // Throws:
        //  Nothing
        //

        internal static bool IsValid(string name) {

            int sequenceCount = 0;
            int sequenceLength = 0;
            bool haveCompressor = false;
            bool haveIPv4Address = false;
            bool havePrefix = false;
            bool haveScopeId = false;
            bool expectingNumber = true;
            int lastSequence = 1;

            for (int i = 0; i < name.Length; ++i) {
                if (havePrefix ? Char.IsDigit(name[i]) : Uri.IsHexDigit(name[i])) {
                    ++sequenceLength;
                    expectingNumber = false;
                } else {
                    if (sequenceLength > 4) {
                        return false;
                    }
                    if (sequenceLength != 0) {
                        ++sequenceCount;
                        lastSequence = i - sequenceLength;
                    }
                    sequenceLength = 0;
                    switch (name[i]) {
                        case ':':
                            if ((i > 0) && (name[i - 1] == ':')) {
                                if (haveCompressor) {

                                    //
                                    // can only have one per IPv6 address
                                    //

                                    return false;
                                }
                                haveCompressor = true;
                                expectingNumber = false;
                            } else {
                                expectingNumber = true;
                            }
                            break;
                        
                        case '%':
                            if ((sequenceCount == 0) || haveScopeId) {
                                return false;
                            }
                            expectingNumber = true;       
                            haveScopeId = true;
                            break;

                        case '/':
                            if ((sequenceCount == 0) || havePrefix) {
                                return false;
                            }
                            havePrefix = true;
                            expectingNumber = true;
                            break;

                        case '.':
                            if (haveIPv4Address) {
                                return false;
                            }

                            int slashIndex = name.IndexOfAny(new char[] {'%','/'}, i);
                            int length = name.Length;

                            if (slashIndex != -1) {
                                length = Math.Min(slashIndex, length);
                            }
							
                            --length;
                            if (!IPv4Address.IsValid(name, lastSequence, ref length)) {
                                return false;
                            }
                            haveIPv4Address = true;

                            //
                            // we have to say there is a sequence here in case
                            // the next token is the prefix separator. This will
                            // cause the sequenceCount to be incremented. Bit
                            // hacky
                            //

                            sequenceLength = 4;
                            i = length - 1;
                            break;

                        default:
                            return false;
                    }
                }
            }

            //
            // if the last token was a prefix, check number of digits
            //

            if (havePrefix && ((sequenceLength < 1) || (sequenceLength > 2))) {
                return false;
            }

            //
            // these sequence counts are -1 because it is implied in end-of-sequence
            //

            int expectedSequenceCount = 7 + ((sequenceLength == 0) ? 1 : 0) + (havePrefix ? 1 : 0) + (haveScopeId ? 1 : 0);

            return !expectingNumber
                && (sequenceLength <= 4)
                && (haveCompressor
                    ? (sequenceCount < expectedSequenceCount)
                    : (sequenceCount == expectedSequenceCount)
                );
        }

        //
        // Parse
        //
        //  Convert this IPv6 address into a sequence of 8 16-bit numbers
        //
        // Inputs:
        //  <member>    Name
        //      The validated IPv6 address
        //
        // Outputs:
        //  <member>    m_Numbers
        //      Array filled in with the numbers in the IPv6 groups
        //
        //  <member>    PrefixLength
        //      Set to the number after the prefix separator (/) if found
        //
        // Assumes:
        //  <Name> has been validated and contains only hex digits in groups of
        //  16-bit numbers, the characters ':' and '/', and a possible IPv4
        //  address
        //
        // Returns:
        //  Nothing
        //
        // Throws:
        //  Nothing
        //

        internal void Parse() {

            //
            // get the address and add a sentinel character for eof string
            //

            string address = Name + '!';
            int number = 0;
            int index = 0;
            int compressorIndex = -1;
            bool numberIsValid = true;

            for (int i = 0; address[i] != '!'; ) {
                switch (address[i]) {
                    
                    case ':':
                        m_Numbers[index++] = (ushort)number;
                        number = 0;
                        ++i;
                        if (address[i] == ':') {
                            compressorIndex = index;
                            ++i;
                        } else if ((compressorIndex < 0) && (index < 6)) {

                            //
                            // no point checking for IPv4 address if we don't
                            // have a compressor or we haven't seen 6 16-bit
                            // numbers yet
                            //

                            break;
                        }

                        //
                        // check to see if the upcoming number is really an IPv4
                        // address. If it is, convert it to 2 ushort numbers
                        //

                        for (int j = i; (address[j] != '!') && (address[j] != ':') && (j < i + 4); ++j) {
                            if (address[j] == '.') {

                                //
                                // we have an IPv4 address. Find the end of it:
                                // we know that since we have a valid IPv6
                                // address, the only things that will terminate
                                // the IPv4 address are the prefix delimiter '/'
                                // or the end-of-string (which we conveniently
                                // delimited with '!')
                                //

                                while ((address[j] != '!') && (address[j] != '/')&& (address[j] != '%')) {
                                    ++j;
                                }

                                IPv4Address ip4addr = new IPv4Address(address.Substring(i, j - i));

                                number = ((int)ip4addr[0] * 256) + (int)ip4addr[1];
                                m_Numbers[index++] = (ushort)number;
                                number = ((int)ip4addr[2] * 256) + (int)ip4addr[3];
                                m_Numbers[index++] = (ushort)number;
                                i = j;

                                //
                                // set this to avoid adding another number to
                                // the array if there's a prefix
                                //

                                number = 0;
                                numberIsValid = false;
                                break;
                            }
                        }
                        break;

                    case '%':
                        ++i;
                        int begin = i;
                        while (Char.IsDigit(address[i]) || Uri.IsHexDigit(address[i])) {
                            ++i;
                        }
                        if (i>begin)  //we had digits
                            m_ScopeId = address.Substring(begin,i-begin);
                        break;    
                
                    case '/':
                        if (numberIsValid) {
                            m_Numbers[index++] = (ushort)number;
                            numberIsValid = false;
                        }

                        //
                        // since we have a valid IPv6 address string, the prefix
                        // length is the last token in the string
                        //

                        for (++i; address[i] != '!'; ++i) {
                            PrefixLength = PrefixLength * 10 + (address[i] - '0');
                        }
                        break;

                    default:
                        number = number * 16 + Uri.FromHex(address[i++]);
                        break;
                }
            }

            //
            // add number to the array if its not the prefix length or part of
            // an IPv4 address that's already been handled
            //

            if (numberIsValid) {
                m_Numbers[index++] = (ushort)number;
            }

            //
            // if we had a compressor sequence ("::") then we need to expand the
            // m_Numbers array
            //

            if (compressorIndex > 0) {

                int toIndex = NumberOfLabels - 1;
                int fromIndex = index - 1;

                for (int i = index - compressorIndex; i > 0 ; --i) {
                    m_Numbers[toIndex--] = m_Numbers[fromIndex];
                    m_Numbers[fromIndex--] = 0;
                }
            }

            //
            // is the address loopback? Loopback is defined as one of:
            //
            //  0:0:0:0:0:0:0:1
            //  0:0:0:0:0:0:127.0.0.1       == 0:0:0:0:0:0:7F00:0001
            //  0:0:0:0:0:FFFF:127.0.0.1    == 0:0:0:0:0:FFFF:7F00:0001
            //

            m_IsLoopback = ((m_Numbers[0] == 0)
                            && (m_Numbers[1] == 0)
                            && (m_Numbers[2] == 0)
                            && (m_Numbers[3] == 0)
                            && (m_Numbers[4] == 0))
                           && (((m_Numbers[5] == 0)
                                && (m_Numbers[6] == 0)
                                && (m_Numbers[7] == 1))
                               || (((m_Numbers[6] == 0x7F00)
                                    && (m_Numbers[7] == 0x0001))
                                   && ((m_Numbers[5] == 0)
                                       || (m_Numbers[5] == 0xFFFF))));

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\authorization.cs ===
//------------------------------------------------------------------------------
// <copyright file="Authorization.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net {
    /// <include file='doc\Authorization.uex' path='docs/doc[@for="Authorization"]/*' />
    /// <devdoc>
    ///    <para>Used for handling and completing a custom authorization.</para>
    /// </devdoc>
    public class Authorization {

        private string                  m_Message;
        private bool                    m_Complete;
        private string[]                m_ProtectionRealm;
        private string                  m_ConnectionGroupId;
        private IAuthenticationModule   m_Module;

        /// <include file='doc\Authorization.uex' path='docs/doc[@for="Authorization.Authorization"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.Authorization'/> class with the specified
        ///       authorization token.
        ///    </para>
        /// </devdoc>
        public Authorization(string token) {
            m_Message = ValidationHelper.MakeStringNull(token);
            m_Complete = true;
        }

        /// <include file='doc\Authorization.uex' path='docs/doc[@for="Authorization.Authorization1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.Authorization'/> class with the specified
        ///       authorization token and completion status.
        ///    </para>
        /// </devdoc>
        public Authorization(string token, bool finished) {
            m_Message = ValidationHelper.MakeStringNull(token);
            m_Complete = finished;
        }

        /// <include file='doc\Authorization.uex' path='docs/doc[@for="Authorization.Authorization2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.Authorization'/> class with the specified
        ///       authorization token, completion status, and connection m_ConnectionGroupId identifier. 
        ///    </para>
        /// </devdoc>
        public Authorization(string token, bool finished, string connectionGroupId) {
            m_Message = ValidationHelper.MakeStringNull(token);
            m_ConnectionGroupId = ValidationHelper.MakeStringNull(connectionGroupId);
            m_Complete = finished;
        }

        /// <include file='doc\Authorization.uex' path='docs/doc[@for="Authorization.Message"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       the response returned to the server in response to an authentication
        ///       challenge.</para>
        /// </devdoc>
        public string Message {
            get { return m_Message;}
        }

        // used to specify if this Authorization needs a special private server connection,
        //  identified by this string
        /// <include file='doc\Authorization.uex' path='docs/doc[@for="Authorization.ConnectionGroupId"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ConnectionGroupId {
            get { return m_ConnectionGroupId; }
        }

        /// <include file='doc\Authorization.uex' path='docs/doc[@for="Authorization.Complete"]/*' />
        /// <devdoc>
        ///    <para>Gets the completion status of the authorization.</para>
        /// </devdoc>
        public bool Complete {
            get { return m_Complete;}
        }
        internal void SetComplete(bool complete) {
            m_Complete = complete;
        }

        /// <include file='doc\Authorization.uex' path='docs/doc[@for="Authorization.ProtectionRealm"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the prefix for Uris that can be authenticated with the <see cref='System.Net.Authorization.Message'/> property.</para>
        /// </devdoc>
        public string[] ProtectionRealm {
            get { return m_ProtectionRealm;}
            set { 
                string[] newValue = ValidationHelper.MakeEmptyArrayNull(value);
                m_ProtectionRealm = newValue;
            }
        }

        //
        // RAID#86753
        // may be removed after we have Update() public
        //
        internal IAuthenticationModule Module {
            get {
                return m_Module;
            }
            set {
                m_Module = value;
            }
        }


    }; // class Authorization


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\connectionmodes.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConnectionModes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Configuration;
using System.Configuration.Assemblies;

using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Reflection.Emit;
using System.Resources;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Permissions;
using System.Security.Util;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;



namespace System.Net {


// Used to indicate the mode of how we use a transport
// Not sure whether this is the right way to define an enum
/// <include file='doc\ConnectionModes.uex' path='docs/doc[@for="ConnectionModes"]/*' />
/// <devdoc>
///    <para>
///       Specifies the mode used to establish a connection with a server.
///    </para>
/// </devdoc>
    internal enum ConnectionModes {
        /// <include file='doc\ConnectionModes.uex' path='docs/doc[@for="ConnectionModes.Single"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Non-persistent, one request per connection.
        ///    </para>
        /// </devdoc>
        Single      ,       // Non-Persistent, one request per connection
        /// <include file='doc\ConnectionModes.uex' path='docs/doc[@for="ConnectionModes.Persistent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persistent connection, one request/response at a time.
        ///    </para>
        /// </devdoc>
        Persistent,         // Persistant, one request/response at a time
        /// <include file='doc\ConnectionModes.uex' path='docs/doc[@for="ConnectionModes.Pipeline"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persistent connection, many requests/responses in order.
        ///    </para>
        /// </devdoc>
        Pipeline ,          // Persistant, many requests/responses in order
        /// <include file='doc\ConnectionModes.uex' path='docs/doc[@for="ConnectionModes.Mux"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persistent connection, many requests/responses out of order.
        ///    </para>
        /// </devdoc>
        Mux                 // Persistant, many requests/responses out of order



    } // enum ConnectionModes


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\cookie.cs ===
//------------------------------------------------------------------------------
// <copyright file="cookie.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Collections;
    using System.Globalization;
    
    internal enum CookieVariant {
        Unknown,
        Plain,
        Rfc2109,
        Rfc2965,
        Default = Rfc2109
    }

    //
    // Cookie class
    //
    //  Adheres to RFC 2965
    //
    //  Currently, only client-side cookies. The cookie classes know how to
    //  parse a set-cookie format string, but not a cookie format string
    //  (e.g. "Cookie: $Version=1; name=value; $Path=/foo; $Secure")
    //

    /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Serializable]
    public sealed class Cookie {

        internal const int    MaxSupportedVersion = 1;
        internal const string CommentAttributeName = "Comment";
        internal const string CommentUrlAttributeName = "CommentURL";
        internal const string DiscardAttributeName = "Discard";
        internal const string DomainAttributeName = "Domain";
        internal const string ExpiresAttributeName = "Expires";
        internal const string MaxAgeAttributeName = "Max-Age";
        internal const string PathAttributeName = "Path";
        internal const string PortAttributeName = "Port";
        internal const string SecureAttributeName = "Secure";
        internal const string VersionAttributeName = "Version";

        internal const string SeparatorLiteral = "; ";
        internal const string EqualsLiteral = "=";
        internal const string SpecialAttributeLiteral = "$";
        
        internal static readonly char[] PortSplitDelimiters =  new char[] {' ', ',', '\"'};
        internal static readonly char[] Reserved2Name =  new char[] {' ', '\t', '\r', '\n', '=', ';', ',' };
        internal static readonly char[] Reserved2Value =  new char[] {';', ',' };
        private  static Comparer staticComparer = new Comparer();

    // fields

        string  m_comment = string.Empty;
        Uri     m_commentUri = null;
        CookieVariant m_cookieVariant = CookieVariant.Plain;
        bool    m_discard = false;
        string  m_domain = string.Empty;
        bool    m_domain_implicit = true;
        DateTime m_expires = DateTime.MinValue;
        string  m_name = string.Empty;
        string  m_path = string.Empty;
        bool    m_path_implicit = true;
        string  m_port = string.Empty;
        bool    m_port_implicit = true;
        int[]   m_port_list = null;
        bool    m_secure = false;
        DateTime m_timeStamp = DateTime.Now;
        string  m_value = string.Empty;
        int     m_version = 0;
        
        string  m_domainKey = string.Empty;
        internal bool IsQuotedVersion = false;
        internal bool IsQuotedDomain = false;


    // constructors

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Cookie"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Cookie() {
        }


        //public Cookie(string cookie) {
        //    if ((cookie == null) || (cookie == String.Empty)) {
        //        throw new ArgumentException("cookie");
        //    }
        //    Parse(cookie.Trim());
        //    Validate();
        //}

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Cookie1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Cookie(string name, string value) {
            Name = name;
            m_value = value;
        }

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Cookie2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Cookie(string name, string value, string path)
            : this(name, value) {
            Path = path;
        }

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Cookie3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Cookie(string name, string value, string path, string domain)
            : this(name, value, path) {
            Domain = domain;
        }

    // properties

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Comment"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Comment {
            get {
                return m_comment;
            }
            set {
                if (value == null) {
                    value = string.Empty;
                }
                m_comment = value;
            }
        }

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.CommentUri"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Uri CommentUri {
            get {
                return m_commentUri;
            }
            set {
                m_commentUri = value;
            }
        }

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Discard"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Discard {
            get {
                return m_discard;
            }
            set {
                m_discard = value;
            }
        }

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Domain"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Domain {
            get {
                return m_domain;
            }
            set {
                m_domain = (value == null? String.Empty : value);
                m_domain_implicit = false;
                m_domainKey = string.Empty; //this will get it value when adding into the Container.
            }
        }

        private string _Domain {
            get {
                return (Plain || m_domain_implicit || (m_domain.Length == 0))
                    ? string.Empty
                    : (SpecialAttributeLiteral
                       + DomainAttributeName
                       + EqualsLiteral + (IsQuotedDomain? "\"": string.Empty)
                       + m_domain + (IsQuotedDomain? "\"": string.Empty)
                       );
            }
        }

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Expired"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Expired {
            get {
                return (m_expires <= DateTime.Now) && (m_expires != DateTime.MinValue);
            }
            set {
                if (value == true) {
                    m_expires = DateTime.Now;
                }
            }
        }

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Expires"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DateTime Expires {
            get {
                return m_expires;
            }
            set {
                m_expires = value;
            }
        }

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Name {
            get {
                return m_name;
            }
            set {
                if (value == null || value == string.Empty || !InternalSetName(value)) {
                    throw new CookieException(SR.GetString(SR.net_cookie_attribute, "Name", value == null? "<null>": value));
                }
            }
        }

        internal bool InternalSetName(string value) {
            if (value == null || value == string.Empty || value[0] == '$' || value.IndexOfAny(Reserved2Name) != -1) {
                m_name = string.Empty;
                return false;
            }
            m_name = value;
            return true;
        }

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Path"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Path {
            get {
                return m_path;
            }
            set {
                m_path = (value == null? String.Empty : value);
                m_path_implicit = false;
            }
        }

        private string _Path {
            get {
                return (Plain || m_path_implicit || (m_path.Length == 0))
                    ? string.Empty
                    : (SpecialAttributeLiteral
                       + PathAttributeName
                       + EqualsLiteral
                       + m_path
                       );
            }
        }

        internal bool Plain {
            get {
                return Variant == CookieVariant.Plain;
            }
        }


        //
        // According to spec we must assume default values for attributes but still 
        // keep in mind that we must not include them into the requests.
        // We also check the validiy of all attributes based on the version and variant (read RFC)
        //
        // To work properly this function must be called after cookie construction with
        // default (response) URI AND set_default == true
        //
        // Afterwards, the function can be called many times with other URIs and 
        // set_default == false to check whether this cookie matches given uri
        //

        internal bool VerifySetDefaults(CookieVariant variant, Uri uri, bool isLocalDomain, string localDomain, bool set_default, bool isThrow) {
           
            string host = uri.Host;
            int    port = uri.Port;
            string path = uri.AbsolutePath;
            bool   valid= true;

            if (set_default) {
                // Set Variant. If version is zero => reset cookie to Version0 style
                if (Version == 0) {
                    variant = CookieVariant.Plain;
                }
                else if (Version == 1 && variant == CookieVariant.Unknown) {
                     //since we don't expose Variant to an app, set it to Default
                     variant = CookieVariant.Default;
                }
                m_cookieVariant = variant;
            }

            //Check the name
            if (m_name == null || m_name.Length == 0 || m_name[0] == '$' || m_name.IndexOfAny(Reserved2Name) != -1) {
                if (isThrow) {
                    throw new CookieException(SR.GetString(SR.net_cookie_attribute, "Name", m_name == null? "<null>": m_name));
                }
                return false;
            }

            //Check the value
            if (m_value == null || 
                (!(m_value.Length > 2 && m_value[0] == '\"' && m_value[m_value.Length-1] == '\"') && m_value.IndexOfAny(Reserved2Value) != -1)) {
                if (isThrow) {
                    throw new CookieException(SR.GetString(SR.net_cookie_attribute, "Value", m_value == null? "<null>": m_value));
                }
                return false;
            }

            //Check Comment syntax
            if (Comment != null && !(Comment.Length > 2 && Comment[0] == '\"' && Comment[Comment.Length-1] == '\"') 
                && (Comment.IndexOfAny(Reserved2Value) != -1)) {
                if (isThrow) 
                   throw new CookieException(SR.GetString(SR.net_cookie_attribute, CommentAttributeName, Comment));
                return false;
            }

            //Check Path syntax
            if (Path != null  && !(Path.Length > 2 && Path[0] == '\"' && Path[Path.Length-1] == '\"') 
                && (Path.IndexOfAny(Reserved2Value) != -1)) {
                if (isThrow) {
                    throw new CookieException(SR.GetString(SR.net_cookie_attribute, PathAttributeName, Path));
                }
                return false;
            }

            //Check/set domain
            // if domain is implicit => assume a) uri is valid, b) just set domain to uri hostname
            if (set_default && m_domain_implicit == true) {
                m_domain = host;
            }
            else {
                if (!m_domain_implicit) {
                    // Forwarding note: If Uri.Host is of IP address form then the only supported case
                    // is for IMPLICIT domain property of a cookie.
                    // The below code (explicit cookie.Domain value) will try to parse Uri.Host IP string   
                    // as a fqdn and reject the cookie
                    
                    //aliasing since we might need the KeyValue (but not the original one)
                    string domain = m_domain;

                    //Syntax check for Domain charset plus empty string
                    if (!DomainCharsTest(domain)) {
                        if (isThrow) {
                            throw new CookieException(SR.GetString(SR.net_cookie_attribute, DomainAttributeName, domain == null? "<null>": domain));
                        }
                        return false;
                    }

                    //domain must start with '.' if set explicitly
                    if(domain[0] != '.' ) {
                        if (!(variant == CookieVariant.Rfc2965 || variant == CookieVariant.Plain)) {
                            if (isThrow) {
                                throw new CookieException(SR.GetString(SR.net_cookie_attribute, DomainAttributeName, m_domain));
                            }
                            return false;
                        }
                        domain = '.' + domain;
                    }

                    int  host_dot = host.IndexOf('.');
                    bool   is_local = false;

                    // First quick check is for pushing a cookie into the local domain
                    if (isLocalDomain && (string.Compare(localDomain, domain, true, CultureInfo.InvariantCulture) == 0)) {
                        valid = true;
                    }
                    else if (domain.Length < 4 || (!(is_local = (string.Compare(domain, ".local", true, CultureInfo.InvariantCulture)) == 0) && domain.IndexOf('.', 1, domain.Length-2) == -1)) {
                        // explicit domains must contain 'inside' dots or be ".local"
                        valid = false;
                    }
                    else if (is_local && isLocalDomain) {
                        // valid ".local" found for the local domain Uri
                        valid = true;
                    }
                    else if (is_local && !isLocalDomain) {
                        // ".local" cannot happen on non-local domain
                        valid = false;
                    }
                    else if (variant == CookieVariant.Plain) {
                        // We distiguish between Version0 cookie and other versions on domain issue
                        // According to Version0 spec a domain must be just a substring of the hostname
                        if (host.Length <= domain.Length ||
                            string.Compare(host, host.Length-domain.Length, domain, 0, domain.Length, true, CultureInfo.InvariantCulture) != 0) {
                            valid = false;
                        }
                    }
                    else if ( !is_local && 
                             (host_dot == -1 || 
                             domain.Length != host.Length-host_dot || 
                             string.Compare(host, host_dot, domain, 0, domain.Length, true, CultureInfo.InvariantCulture) != 0)) {
                        //starting the first dot, the host must match the domain
                        valid = false;
                    }

                    if (valid) {
                        if(is_local) {
                            m_domainKey = localDomain.ToLower(CultureInfo.InvariantCulture);
                        }
                        else {
                            m_domainKey = domain.ToLower(CultureInfo.InvariantCulture);
                        }
                    }
                    
                }
                else {
                    // for implicitly set domain AND at the set_default==false time 
                    // we simply got to match uri.Host against m_domain
                    if (string.Compare(host, m_domain, true, CultureInfo.InvariantCulture) != 0) {
                        valid = false;
                    }

                }
                if(!valid) {
                    if (isThrow) {
                        throw new CookieException(SR.GetString(SR.net_cookie_attribute, DomainAttributeName, m_domain));
                    }
                    return false;
                }
            }


            //Check/Set Path

            if (set_default && m_path_implicit == true) {
                //assuming that uri path is always valid and contains at least one '/'
                switch (m_cookieVariant) {
                case CookieVariant.Plain:                   
                                        m_path = path;
                                        break;
                case CookieVariant.Rfc2109:                   
                                        m_path = path.Substring(0, path.LastIndexOf('/')); //may be empty
                                        break;

                case CookieVariant.Rfc2965:
                default:                //hope future versions will have same 'Path' semantic?
                                        m_path = path.Substring(0, path.LastIndexOf('/')+1);
                                        break;

                }
            }
            else {
                //check current path (implicit/explicit) against given uri
                if (!path.StartsWith(CookieParser.CheckQuoted(m_path))) {
                    if (isThrow) {
                        throw new CookieException(SR.GetString(SR.net_cookie_attribute, PathAttributeName, m_path));
                    }
                    return false;
                }
            }
            
            // set the default port if Port attribute was present but had no value
            if (set_default && (m_port_implicit == false && m_port.Length == 0)) {
                m_port_list = new int[1] {port};
            }

            if(m_port_implicit == false) {
                // Port must match agaist the one from the uri
                valid = false;
                foreach (int p in m_port_list) {
                    if (p == port) {
                        valid = true;
                        break;
                    }
                }
                if (!valid) {
                    if (isThrow) {
                        throw new CookieException(SR.GetString(SR.net_cookie_attribute, PortAttributeName, m_port));
                    }
                    return false;
                }
            }
            return true;
        }

        //Very primitive test to make sure that the name does not have illegal characters
        // As pe RFC 952 (relaxed on first char could be a digit and string can have '_')
        private static bool DomainCharsTest(string name) {
            if (name == null || name.Length == 0) {
                return false;
            }
            for(int i=0; i < name.Length; ++i) {
                char ch = name[i];
                if (!(
                      (ch >= '0' && ch <= '9') ||
                      (ch == '.' || ch == '-') ||
                      (ch >= 'a' && ch <= 'z') ||
                      (ch >= 'A' && ch <= 'Z') ||
                      (ch == '_')
                    ))
                    return false;
            }
            return true;
        }

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Port"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Port {
            get {
                return m_port;
            }
            set {
                m_port_implicit = false;
                if ((value == null || value.Length == 0)) {
                    //"Port" is present but has no value.
                    m_port = string.Empty;
                }
                else {
                    m_port = value;
                    // Parse port list
                    if (value[0] != '\"' || value[value.Length-1] != '\"') {
                        throw new CookieException(SR.GetString(SR.net_cookie_attribute, PortAttributeName, m_port));
                    }
                    string[] ports = value.Split(PortSplitDelimiters);
                    m_port_list = new int[ports.Length];
                    for (int i = 0; i < ports.Length; ++i) {
                        m_port_list[i] = -1;        
                        if(ports[i].Length == 0) {
                            //ignore spaces this way, and leave port=-1 in the slot
                            continue;
                        }
                        try {
                            m_port_list[i] = Int32.Parse(ports[i]);
                        }
                        catch (Exception e) {
                            throw new CookieException(SR.GetString(SR.net_cookie_attribute, PortAttributeName, m_port),e);
                        }
                    }
                }
            }
        }


        internal int[] PortList {
            get {
                //It must be null if Port Attribute was ommitted in the response
                return m_port_list;
            }
        }

        private string _Port {
            get {
                return m_port_implicit ? string.Empty :
                      (SpecialAttributeLiteral
                       + PortAttributeName
                       + ((m_port.Length == 0) ? string.Empty : (EqualsLiteral + m_port))
                       );
            }
        }

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Secure"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Secure {
            get {
                return m_secure;
            }
            set {
                m_secure = value;
            }
        }

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.TimeStamp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DateTime TimeStamp {
            get {
                return m_timeStamp;
            }
        }

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Value"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Value {
            get {
                return m_value;
            }
            set {
                m_value = (value == null? String.Empty : value);
            }
        }

        internal CookieVariant Variant {
            get {
                return m_cookieVariant;
            }
        }

        // m_domainKey member is set internally in VerifySetDefaults()
        // If it is not set then verification function was not called
        // and this shoul dnever happen
        internal string DomainKey {
            get {
                return m_domain_implicit ? Domain : m_domainKey;
            }
        }


        //public Version Version {
        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Version"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Version {
            get {
                return m_version;
            }
            set {
                m_version = value;
            }
        }

        private string _Version {
            get {
                  return (Version == 0) ? string.Empty :
                                         ( SpecialAttributeLiteral
                                         + VersionAttributeName
                                         + EqualsLiteral + (IsQuotedVersion? "\"": string.Empty) 
                                         + m_version.ToString() + (IsQuotedVersion? "\"": string.Empty));
            }
        }

    // methods


        internal static IComparer GetComparer() {
            //the class don't have any members, it's safe reuse the instance
            return staticComparer;
        }


        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(object comparand) {
            if (!(comparand is Cookie)) {
                return false;
            }

            Cookie other = (Cookie)comparand;

            return (string.Compare(Name, other.Name, true, CultureInfo.InvariantCulture) == 0)
                    && (string.Compare(Value, other.Value, false, CultureInfo.InvariantCulture) == 0)
                    && (string.Compare(Path, other.Path, false, CultureInfo.InvariantCulture) == 0)
                    && (string.Compare(Domain, other.Domain, true, CultureInfo.InvariantCulture) == 0)
                    && (Version == other.Version)
                    ;
        }

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            //
            //string hashString = Name + "=" + Value + ";" + Path + "; " + Domain + "; " + Version;
            //int hash = 0;
            //
            //foreach (char ch in hashString) {
            //    hash = unchecked(hash << 1 ^ (int)ch);
            //}
            //return hash;
            return (Name + "=" + Value + ";" + Path + "; " + Domain + "; " + Version).GetHashCode();
        }

        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string ToString() {

            string domain = _Domain;
            string path = _Path;
            string port = _Port;
            string version = _Version;

            string result = 
                    ((version.Length == 0)? string.Empty : (version + SeparatorLiteral))
                    + Name + EqualsLiteral + Value
                    + ((path.Length == 0)   ? string.Empty : (SeparatorLiteral + path))
                    + ((domain.Length == 0) ? string.Empty : (SeparatorLiteral + domain))
                    + ((port.Length == 0)   ? string.Empty : (SeparatorLiteral + port))
                    ;
            if (result == "=") {
                return string.Empty;
            }
            return result;
        }

        //private void Validate() {
        //    if ((m_name == String.Empty) && (m_value == String.Empty)) {
        //        throw new CookieException();
        //    }
        //    if ((m_name != String.Empty) && (m_name[0] == '$')) {
        //        throw new CookieException();
        //    }
        //}

#if DEBUG
        /// <include file='doc\cookie.uex' path='docs/doc[@for="Cookie.Dump"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Dump() {
            Console.WriteLine("Cookie: " + ToString() + "->\n"
                            + "\tComment    = " + Comment + "\n"
                            + "\tCommentUri = " + CommentUri + "\n"
                            + "\tDiscard    = " + Discard + "\n"
                            + "\tDomain     = " + Domain + "\n"
                            + "\tExpired    = " + Expired + "\n"
                            + "\tExpires    = " + Expires + "\n"
                            + "\tName       = " + Name + "\n"
                            + "\tPath       = " + Path + "\n"
                            + "\tPort       = " + Port + "\n"
                            + "\tSecure     = " + Secure + "\n"
                            + "\tTimeStamp  = " + TimeStamp + "\n"
                            + "\tValue      = " + Value + "\n"
                            + "\tVariant    = " + Variant + "\n"
                            + "\tVersion    = " + Version + "\n"
                            );
        }
#endif
    }

    internal enum CookieToken {

    // state types

        Nothing,
        NameValuePair,  // X=Y
        Attribute,      // X
        EndToken,       // ';'
        EndCookie,      // ','
        End,            // EOLN
        Equals,

    // value types

        Comment,
        CommentUrl,
        CookieName,
        Discard,
        Domain,
        Expires,
        MaxAge,
        Path,
        Port,
        Secure,
        Unknown,
        Version
    }

    //
    // CookieTokenizer
    //
    //  Used to split a single or multi-cookie (header) string into individual
    //  tokens
    //

    internal class CookieTokenizer {

    // fields

        bool m_eofCookie;
        int m_index;
        int m_length;
        string m_name;
        bool m_quoted;
        int m_start;
        CookieToken m_token;
        int m_tokenLength;
        string m_tokenStream;
        string m_value;

    // constructors

        internal CookieTokenizer(string tokenStream) {
            m_length = tokenStream.Length;
            m_tokenStream = tokenStream;
        }

    // properties

        internal bool EndOfCookie {
            get {
                return m_eofCookie;
            }
            set {
                m_eofCookie = value;
            }
        }

        internal bool Eof {
            get {
                return m_index >= m_length;
            }
        }

        internal string Name {
            get {
                return m_name;
            }
            set {
                m_name = value;
            }
        }

        internal bool Quoted {
            get {
                return m_quoted;
            }
            set {
                m_quoted = value;
            }
        }

        internal CookieToken Token {
            get {
                return m_token;
            }
            set {
                m_token = value;
            }
        }

        internal string Value {
            get {
                return m_value;
            }
            set {
                m_value = value;
            }
        }

    // methods

        //
        // Extract
        //
        //  extract the current token
        //

        internal string Extract() {

            string tokenString = string.Empty;

            if (m_tokenLength != 0) {
                tokenString = m_tokenStream.Substring(m_start, m_tokenLength);
                if (!Quoted) {
                    tokenString = tokenString.Trim();
                }
            }
            return tokenString;
        }

        //
        // FindNext
        //
        //  Find the start and length of the next token. The token is terminated
        //  by one of:
        //
        //      - end-of-line
        //      - end-of-cookie: unquoted comma separates multiple cookies
        //      - end-of-token: unquoted semi-colon
        //      - end-of-name: unquoted equals
        //
        // Inputs:
        //  <argument>  ignoreComma
        //      true if parsing doesn't stop at a comma. This is only true when
        //      we know we're parsing an original cookie that has an expires=
        //      attribute, because the format of the time/date used in expires
        //      is:
        //          Wdy, dd-mmm-yyyy HH:MM:SS GMT
        //
        //  <argument>  ignoreEquals
        //      true if parsing doesn't stop at an equals sign. The LHS of the
        //      first equals sign is an attribute name. The next token may
        //      include one or more equals signs. E.g.,
        //
        //          SESSIONID=ID=MSNx45&q=33
        //
        // Outputs:
        //  <member>    m_index
        //      incremented to the last position in m_tokenStream contained by
        //      the current token
        //
        //  <member>    m_start
        //      incremented to the start of the current token
        //
        //  <member>    m_tokenLength
        //      set to the length of the current token
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  type of CookieToken found:
        //
        //      End         - end of the cookie string
        //      EndCookie   - end of current cookie in (potentially) a
        //                    multi-cookie string
        //      EndToken    - end of name=value pair, or end of an attribute
        //      Equals      - end of name=
        //
        // Throws:
        //  Nothing
        //

        internal CookieToken FindNext(bool ignoreComma, bool ignoreEquals) {
            m_tokenLength = 0;
            m_start = m_index;
            while ((m_index < m_length) && Char.IsWhiteSpace(m_tokenStream[m_index])) {
                ++m_index;
                ++m_start;
            }

            CookieToken token = CookieToken.End;
            int increment = 1;

            if (!Eof) {
                if (m_tokenStream[m_index] == '"') {
                    Quoted = true;
                    ++m_index;
                    while ((m_index < m_length)
                           && !((m_tokenStream[m_index] == '"') && (m_tokenStream[m_index - 1] != '\\'))) {
                        ++m_index;
                    }
                    if (m_index < m_length) {
                        ++m_index;
                    }
                    m_tokenLength = m_index - m_start;
                    increment = 0;
                    // if we are here, reset ignoreComma 
                    // In effect, we ignore everything after quoted string till next delimiter
                    ignoreComma = false;
                }
                while ((m_index < m_length)
                       && (m_tokenStream[m_index] != ';')
                       && (ignoreEquals ? true : (m_tokenStream[m_index] != '='))
                       && (ignoreComma ? true :  (m_tokenStream[m_index] != ','))) {
                    
                    // Fixing 2 things:
                    // 1) ignore day of week in cookie string
                    // 2) revert ignoreComma once meet it, so won't miss the next cookie)
                    if (m_tokenStream[m_index] == ',') {
                        m_start = m_index+1;
                        m_tokenLength = -1;
                        ignoreComma = false;
                    }
                    ++m_index;
                    m_tokenLength += increment;

                }
                if (!Eof) {
                    switch (m_tokenStream[m_index]) {
                        case ';':
                            token = CookieToken.EndToken;
                            break;

                        case '=':
                            token = CookieToken.Equals;
                            break;

                        default:
                            token = CookieToken.EndCookie;
                            break;
                    }
                    ++m_index;
                }
            }
            return token;
        }

        //
        // Next
        //
        //  Get the next cookie name/value or attribute
        //
        //  Cookies come in the following formats:
        //
        //      1. Version0
        //          Set-Cookie: [<name>][=][<value>]
        //                      [; expires=<date>]
        //                      [; path=<path>]
        //                      [; domain=<domain>]
        //                      [; secure]
        //          Cookie: <name>=<value>
        //
        //          Notes: <name> and/or <value> may be blank
        //                 <date> is the RFC 822/1123 date format that
        //                 incorporates commas, e.g.
        //                 "Wednesday, 09-Nov-99 23:12:40 GMT"
        //
        //      2. RFC 2109
        //          Set-Cookie: 1#{
        //                          <name>=<value>
        //                          [; comment=<comment>]
        //                          [; domain=<domain>]
        //                          [; max-age=<seconds>]
        //                          [; path=<path>]
        //                          [; secure]
        //                          ; Version=<version>
        //                      }
        //          Cookie: $Version=<version>
        //                  1#{
        //                      ; <name>=<value>
        //                      [; path=<path>]
        //                      [; domain=<domain>]
        //                  }
        //
        //      3. RFC 2965
        //          Set-Cookie2: 1#{
        //                          <name>=<value>
        //                          [; comment=<comment>]
        //                          [; commentURL=<comment>]
        //                          [; discard]
        //                          [; domain=<domain>]
        //                          [; max-age=<seconds>]
        //                          [; path=<path>]
        //                          [; ports=<portlist>]
        //                          [; secure]
        //                          ; Version=<version>
        //                       }
        //          Cookie: $Version=<version>
        //                  1#{
        //                      ; <name>=<value>
        //                      [; path=<path>]
        //                      [; domain=<domain>]
        //                      [; port="<port>"]
        //                  }
        //          [Cookie2: $Version=<version>]
        //
        // Inputs:
        //  <argument>  first
        //      true if this is the first name/attribute that we have looked for
        //      in the cookie stream
        //
        // Outputs:
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  type of CookieToken found:
        //
        //      - Attribute
        //          - token was single-value. May be empty. Caller should check
        //            Eof or EndCookie to determine if any more action needs to
        //            be taken
        //
        //      - NameValuePair
        //          - Name and Value are meaningful. Either may be empty
        //
        // Throws:
        //  Nothing
        //

        internal CookieToken Next(bool first) {

            Reset();

            CookieToken terminator = FindNext(false, false);
            if (terminator == CookieToken.EndCookie) {
                EndOfCookie = true;
            }

            if ((terminator == CookieToken.End) || (terminator == CookieToken.EndCookie)) {
                if ((Name = Extract()).Length != 0) {
                    Token = TokenFromName();
                    return CookieToken.Attribute;
                }
                return terminator;
            }
            Name = Extract();
            if (first) {
                Token = CookieToken.CookieName;
            }
            else {
                Token = TokenFromName();
            }
            if (terminator == CookieToken.Equals) {
                terminator = FindNext(!first && (Token == CookieToken.Expires), true);
                if (terminator == CookieToken.EndCookie) {
                    EndOfCookie = true;
                }
                Value = Extract();
                return CookieToken.NameValuePair;
            }
            else {
                return CookieToken.Attribute;
            }
        }

        //
        // Reset
        //
        //  set up this tokenizer for finding the next name/value pair or
        //  attribute, or end-of-[token, cookie, or line]
        //

        internal void Reset() {
            m_eofCookie = false;
            m_name = string.Empty;
            m_quoted = false;
            m_start = m_index;
            m_token = CookieToken.Nothing;
            m_tokenLength = 0;
            m_value = string.Empty;
        }

        private struct RecognizedAttribute {

            string m_name;
            CookieToken m_token;

            internal RecognizedAttribute(string name, CookieToken token) {
                m_name = name;
                m_token = token;
            }

            internal CookieToken Token {
                get {
                    return m_token;
                }
            }

            internal bool Equals(string value) {
                return string.Compare(m_name, value, true, CultureInfo.InvariantCulture) == 0;
            }
        }

        //
        // recognized attributes in order of expected commonality
        //

        static RecognizedAttribute [] RecognizedAttributes = {
            new RecognizedAttribute(Cookie.PathAttributeName, CookieToken.Path),
            new RecognizedAttribute(Cookie.MaxAgeAttributeName, CookieToken.MaxAge),
            new RecognizedAttribute(Cookie.ExpiresAttributeName, CookieToken.Expires),
            new RecognizedAttribute(Cookie.VersionAttributeName, CookieToken.Version),
            new RecognizedAttribute(Cookie.DomainAttributeName, CookieToken.Domain),
            new RecognizedAttribute(Cookie.SecureAttributeName, CookieToken.Secure),
            new RecognizedAttribute(Cookie.DiscardAttributeName, CookieToken.Discard),
            new RecognizedAttribute(Cookie.PortAttributeName, CookieToken.Port),
            new RecognizedAttribute(Cookie.CommentAttributeName, CookieToken.Comment),
            new RecognizedAttribute(Cookie.CommentUrlAttributeName, CookieToken.CommentUrl)
        };

        internal CookieToken TokenFromName() {
            for (int i = 0; i < RecognizedAttributes.Length; ++i) {
                if (RecognizedAttributes[i].Equals(Name)) {
                    return RecognizedAttributes[i].Token;
                }
            }
            return CookieToken.Unknown;
        }
    }

    //
    // CookieParser
    //
    //  Takes a cookie header, makes cookies
    //

    internal class CookieParser {

    // fields

        CookieTokenizer m_tokenizer;

    // constructors

        internal CookieParser(string cookieString) {
            m_tokenizer = new CookieTokenizer(cookieString);
        }

    // properties

    // methods

        //
        // Get
        //
        //  Gets the next cookie
        //
        // Inputs:
        //  Nothing
        //
        // Outputs:
        //  Nothing
        //
        // Assumes:
        //  Nothing
        //
        // Returns:
        //  new cookie object, or null if there's no more
        //
        // Throws:
        //  Nothing
        //

        internal Cookie Get() {

            Cookie cookie = null;

            //only first ocurence of an attribute value must be counted
            bool   commentSet = false;
            bool   commentUriSet = false;
            bool   domainSet = false;
            bool   expiresSet = false;
            bool   pathSet = false;
            bool   portSet = false; //special case as it may have no value in header
            bool   versionSet = false;
            bool   secureSet = false;
            bool   discardSet = false;

            do {
                CookieToken token = m_tokenizer.Next(cookie == null);

                if (((token == CookieToken.NameValuePair) || (token == CookieToken.Attribute)) && (cookie == null)) {
                   cookie = new Cookie();
                   if (cookie.InternalSetName(m_tokenizer.Name) == false) {
                       cookie.InternalSetName(string.Empty);    //will be rejected
                   }
                   cookie.Value= m_tokenizer.Value;
                }
                else switch (token) {
                    case CookieToken.NameValuePair:

                        switch (m_tokenizer.Token) {
                            case CookieToken.Comment:
                                if (!commentSet) {
                                    commentSet = true;
                                    cookie.Comment = m_tokenizer.Value;
                                }
                                break;

                            case CookieToken.CommentUrl:
                                if (!commentUriSet) {
                                    commentUriSet = true;
                                    try {
                                        cookie.CommentUri = new Uri(CheckQuoted(m_tokenizer.Value));
                                    }
                                    catch {
                                            //ignore this kind of problem
                                    }
                                }
                                break;

                            case CookieToken.Domain:
                                if (!domainSet) {
                                    domainSet = true;
                                    cookie.Domain = CheckQuoted(m_tokenizer.Value);
                                    cookie.IsQuotedDomain = m_tokenizer.Quoted;
                                }
                                break;

                            case CookieToken.Expires:
                                if (!expiresSet) {
                                    expiresSet = true;
                                    // ParseCookieDate() does many formats for the date.
                                    // Also note that the parser will eat day of the week 
                                    // plus comma and leading spaces
                                    DateTime expires;
                                    if (HttpDateParse.ParseCookieDate(CheckQuoted(m_tokenizer.Value), out expires)) {
                                        cookie.Expires = expires;
                                    }
                                    else {
                                        cookie.InternalSetName(string.Empty); //this cookie will be rejected
                                    }
                                }
                                break;

                            case CookieToken.MaxAge:
                                if (!expiresSet) {
                                    expiresSet = true;
                                    try {
                                        cookie.Expires = DateTime.Now.AddSeconds((Double)(Int32.Parse(CheckQuoted(m_tokenizer.Value))));

                                    }
                                    catch {
                                        cookie.InternalSetName(string.Empty); //this cookie will be rejected
                                    }
                                }
                                break;

                            case CookieToken.Path:
                                if (!pathSet) {
                                    pathSet = true;
                                    cookie.Path = m_tokenizer.Value;
                                }
                                break;

                            case CookieToken.Port:
                                if (!portSet) {
                                    portSet = true;
                                    try {
                                        cookie.Port = m_tokenizer.Value;
                                    }
                                    catch {
                                        cookie.InternalSetName(string.Empty); //this cookie will be rejected
                                    }
                                }
                                break;

                            case CookieToken.Version:
                                if (!versionSet) {
                                    versionSet = true;
                                    try {
                                        cookie.Version = Int32.Parse(CheckQuoted(m_tokenizer.Value));
                                        cookie.IsQuotedVersion = m_tokenizer.Quoted;
                                    }
                                    catch {
                                        cookie.InternalSetName(string.Empty); //this cookie will be rejected
                                    }
                                }
                                break;
                        }
                        break;

                    case CookieToken.Attribute:
                        switch (m_tokenizer.Token) {
                            case CookieToken.Discard:
                                if (!discardSet) {
                                    discardSet = true;
                                    cookie.Discard = true;
                                }
                                break;

                            case CookieToken.Secure:
                                if (!secureSet) {
                                    secureSet = true;
                                    cookie.Secure = true;
                                }
                                break;

                            case CookieToken.Port:
                                if (!portSet) {
                                    portSet = true;
                                    cookie.Port  = string.Empty;
                                }
                                break;
                        }
                        break;
                }
            } while (!m_tokenizer.Eof && !m_tokenizer.EndOfCookie);
            return cookie;
        }

        internal static string CheckQuoted(string value) {
            if (value.Length < 2 || value[0] != '\"' || value[value.Length-1] != '\"')
                return value;
            
            return value.Length == 2? string.Empty: value.Substring(1, value.Length-2);
        }
    }


    internal class Comparer: IComparer {
            
            int IComparer.Compare(object ol, object or) {

                Cookie left  = (Cookie) ol;
                Cookie right = (Cookie) or;

                int result;

                if ((result = string.Compare(left.Name, right.Name, true, CultureInfo.InvariantCulture)) != 0) {
                    return result;
                }

                if ((result = string.Compare(left.Domain, right.Domain, true, CultureInfo.InvariantCulture)) != 0) {
                    return result;
                }

                //
                //NB: The only path is case sensitive as per spec. 
                //    However, on Win Platform that may break some lazy applications.
                //
                if ((result = string.Compare(left.Path, right.Path, false, CultureInfo.InvariantCulture)) != 0) {
                    return result;
                }
                // They are equal here even if variants are still different.
                return 0;
           }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\aspsource\win.cs ===
//------------------------------------------------------------------------------
// <copyright file="win.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VSDesigner.Interop {

    using System;
    using Microsoft.Win32;
    using Marshal = System.Runtime.InteropServices.Marshal;


    // Users can make their classes implement this interface to get access to all
    // the constants in the Win32 API easily.

    [
    System.Runtime.InteropServices.ComVisible(false),
    System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class win {
        public const int APPCMD_CLIENTONLY = 0x00000010,
        APPCMD_FILTERINITS = 0x00000020,
        APPCMD_MASK = 0x00000FF0,
        APPCLASS_STANDARD = 0x00000000,
        APPCLASS_MASK = 0x0000000F,
        APPCLASS_MONITOR = 0x00000001,
        ATTR_INPUT = 0x00,
        ATTR_TARGET_CONVERTED = 0x01,
        ATTR_CONVERTED = 0x02,
        ATTR_TARGET_NOTCONVERTED = 0x03,
        ATTR_INPUT_ERROR = 0x04,
        AUXCAPS_CDAUDIO = 1,
        AUXCAPS_AUXIN = 2,
        AUXCAPS_VOLUME = 0x0001,
        AUXCAPS_LRVOLUME = 0x0002,
        ASYNCH = unchecked((int)0x80),
        ASYNC_MODE_COMPATIBILITY = 0x00000001,
        ASYNC_MODE_DEFAULT = 0x00000000,
        ACTIVEOBJECT_STRONG = 0x0,
        ACTIVEOBJECT_WEAK = 0x1,
        ABM_NEW = 0x00000000,
        ABM_REMOVE = 0x00000001,
        ABM_QUERYPOS = 0x00000002,
        ABM_SETPOS = 0x00000003,
        ABM_GETSTATE = 0x00000004,
        ABM_GETTASKBARPOS = 0x00000005,
        ABM_ACTIVATE = 0x00000006,
        ABM_GETAUTOHIDEBAR = 0x00000007,
        ABM_SETAUTOHIDEBAR = 0x00000008,
        ABM_WINDOWPOSCHANGED = 0x0000009,
        ABN_STATECHANGE = 0x0000000,
        ABN_POSCHANGED = 0x0000001,
        ABN_FULLSCREENAPP = 0x0000002,
        ABN_WINDOWARRANGE = 0x0000003,
        ABS_AUTOHIDE = 0x0000001,
        ABS_ALWAYSONTOP = 0x0000002,
        ABE_LEFT = 0,
        ABE_TOP = 1,
        ABE_RIGHT = 2,
        ABE_BOTTOM = 3,
        AC_LINE_OFFLINE = 0x00,
        AC_LINE_ONLINE = 0x01,
        AC_LINE_BACKUP_POWER = 0x02,
        AC_LINE_UNKNOWN = 0xFF,
        ALG_CLASS_ANY = (0),
                        /* NT5 begin */
                        AC_SRC_OVER                 =0x00,
        AC_SRC_ALPHA                =0x01,
        /* NT5 end */

        ALG_CLASS_SIGNATURE = (1<<13),
                              ALG_CLASS_MSG_ENCRYPT = (2<<13),
                                                      ALG_CLASS_DATA_ENCRYPT = (3<<13),
                                                                               ALG_CLASS_HASH = (4<<13),
                                                                                                ALG_CLASS_KEY_EXCHANGE = (5<<13),
                                                                                                                         ALG_TYPE_ANY = (0),
                                                                                                                                        ALG_TYPE_DSS = (1<<9),
                                                                                                                                                       ALG_TYPE_RSA = (2<<9),
                                                                                                                                                                      ALG_TYPE_BLOCK = (3<<9),
                                                                                                                                                                                       ALG_TYPE_STREAM = (4<<9),
                                                                                                                                                                                                         ALG_SID_ANY = (0),
                                                                                                                                                                                                                       ALG_SID_RSA_ANY = 0,
        ALG_SID_RSA_PKCS = 1,
        ALG_SID_RSA_MSATWORK = 2,
        ALG_SID_RSA_ENTRUST = 3,
        ALG_SID_RSA_PGP = 4,
        ALG_SID_DSS_ANY = 0,
        ALG_SID_DSS_PKCS = 1,
        ALG_SID_DSS_DMS = 2,
        ALG_SID_DES = 1,
        ALG_SID_3DES = 3,
        ALG_SID_DESX = 4,
        ALG_SID_IDEA = 5,
        ALG_SID_CAST = 6,
        ALG_SID_SAFERSK64 = 7,
        ALD_SID_SAFERSK128 = 8,
        ALG_SID_RC2 = 2,
        ALG_SID_RC4 = 1,
        ALG_SID_SEAL = 2,
        ALG_SID_MD2 = 1,
        ALG_SID_MD4 = 2,
        ALG_SID_MD5 = 3,
        ALG_SID_SHA = 4,
        ALG_SID_MAC = 5,
        ALG_SID_RIPEMD = 6,
        ALG_SID_RIPEMD160 = 7,
        ALG_SID_SSL3SHAMD5 = 8,
        ALG_SID_EXAMPLE = 80,
        AT_KEYEXCHANGE = 1,
        AT_SIGNATURE = 2,
        ALTERNATE = 1,
        ASPECT_FILTERING = 0x0001,
        ABORTDOC = 2,
        ANTIALIASED_QUALITY = 4,
        ANSI_CHARSET = 0,
        ARABIC_CHARSET = 178,
        ABSOLUTE = 1,
        ANSI_FIXED_FONT = 11,
        ANSI_VAR_FONT = 12,
        AD_COUNTERCLOCKWISE = 1,
        AD_CLOCKWISE = 2,
        ASPECTX = 40,
        ASPECTY = 42,
        ASPECTXY = 44,
        ANYSIZE_ARRAY = 1,
        APPLICATION_ERROR_MASK = 0x20000000,
        ACCESS_SYSTEM_SECURITY = (0x01000000),
                                 ACL_REVISION = (2),
                                                ACL_REVISION1 = (1),
                                                                ACL_REVISION2 = (2),
                                                                                ACL_REVISION3 = (3),
                                                                                                ACCESS_ALLOWED_ACE_TYPE = (0x0),
                                                                                                                          ACCESS_DENIED_ACE_TYPE = (0x1),
                                                                                                                                                   ARW_BOTTOMLEFT = 0x0000,
        ARW_BOTTOMRIGHT = 0x0001,
        ARW_TOPLEFT = 0x0002,
        ARW_TOPRIGHT = 0x0003,
        ARW_STARTMASK = 0x0003,
        ARW_STARTRIGHT = 0x0001,
        ARW_STARTTOP = 0x0002,
        ARW_LEFT = 0x0000,
        ARW_RIGHT = 0x0000,
        ARW_UP = 0x0004,
        ARW_DOWN = 0x0004,
        ARW_HIDE = 0x0008,
        ARW_VALID = 0x000F,
        ATF_TIMEOUTON = 0x00000001,
        ATF_ONOFFFEEDBACK = 0x00000002,
        ACS_CENTER = 0x0001,
        ACS_TRANSPARENT = 0x0002,
        ACS_AUTOPLAY = 0x0004,
        ACS_TIMER = 0x0008,
        ACM_OPENA = (0x0400+100),
                    ACM_OPENW = (0x0400+103),
                                ACM_PLAY = (0x0400+101),
                                           ACM_STOP = (0x0400+102),
                                                      ACN_START = 1,
        ACN_STOP = 2,
        ADVF_NODATA = 1,
        ADVF_ONLYONCE = 2,
        ADVF_PRIMEFIRST = 4,
        ADVFCACHE_NOHANDLER = 8,
        ADVFCACHE_FORCEBUILTIN = 16,
        ADVFCACHE_ONSAVE = 32,
        ADVFCACHE_DATAONSTOP = 64,
        AW_HOR_POSITIVE = 0x00001,
        AW_HOR_NEGATIVE = 0x00002,
        AW_VER_POSITIVE = 0x00004,
        AW_VER_NEGATIVE = 0x00008,
        AW_CENTER       = 0x00010,
        AW_HIDE         = 0x10000,
        AW_ACTIVATE     = 0x20000,
        AW_SLIDE        = 0x40000,
        AW_BLEND        = 0x80000;

        public const int BOLD_FONTTYPE = 0x0100,
        BAUD_075 = (0x00000001),
                   BAUD_110 = (0x00000002),
                              BAUD_134_5 = (0x00000004),
                                           BAUD_150 = (0x00000008),
                                                      BAUD_300 = (0x00000010),
                                                                 BAUD_600 = (0x00000020),
                                                                            BAUD_1200 = (0x00000040),
                                                                                        BAUD_1800 = (0x00000080),
                                                                                                    BAUD_2400 = (0x00000100),
                                                                                                                BAUD_4800 = (0x00000200),
                                                                                                                            BAUD_7200 = (0x00000400),
                                                                                                                                        BAUD_9600 = (0x00000800),
                                                                                                                                                    BAUD_14400 = (0x00001000),
                                                                                                                                                                 BAUD_19200 = (0x00002000),
                                                                                                                                                                              BAUD_38400 = (0x00004000),
                                                                                                                                                                                           BAUD_56K = (0x00008000),
                                                                                                                                                                                                      BAUD_128K = (0x00010000),
                                                                                                                                                                                                                  BAUD_115200 = (0x00020000),
                                                                                                                                                                                                                                BAUD_57600 = (0x00040000),
                                                                                                                                                                                                                                             BAUD_USER = (0x10000000),
                                                                                                                                                                                                                                                         BACKUP_INVALID = 0x00000000,
        BACKUP_DATA = 0x00000001,
        BACKUP_EA_DATA = 0x00000002,
        BACKUP_SECURITY_DATA = 0x00000003,
        BACKUP_ALTERNATE_DATA = 0x00000004,
        BACKUP_LINK = 0x00000005,
        BACKUP_PROPERTY_DATA = 0x00000006,
        BATTERY_FLAG_HIGH = 0x01,
        BATTERY_FLAG_LOW = 0x02,
        BATTERY_FLAG_CRITICAL = 0x04,
        BATTERY_FLAG_CHARGING = 0x08,
        BATTERY_FLAG_NO_BATTERY = unchecked((int)0x80),
        BATTERY_FLAG_UNKNOWN = 0xFF,
        BATTERY_PERCENTAGE_UNKNOWN = 0xFF,
        BATTERY_LIFE_UNKNOWN = unchecked((int)0xFFFFFFFF),
        BACKGROUND_BLUE = 0x0010,
        BACKGROUND_GREEN = 0x0020,
        BACKGROUND_RED = 0x0040,
        BACKGROUND_INTENSITY = 0x0080,
        BLACKONWHITE = 1,
        BANDINFO = 24,
        BEGIN_PATH = 4096,
        BI_RGB = 0,
        BI_RLE8 = 1,
        BI_RLE4 = 2,
        BI_BITFIELDS = 3,
        BALTIC_CHARSET = 186,
        BKMODE_LAST = 2,
        BLACK_BRUSH = 4,
        BLACK_PEN = 7,
        BS_SOLID = 0,
        BS_NULL = 1,
        BS_HOLLOW = 1,
        BS_HATCHED = 2,
        BS_PATTERN = 3,
        BS_INDEXED = 4,
        BS_DIBPATTERN = 5,
        BS_DIBPATTERNPT = 6,
        BS_PATTERN8X8 = 7,
        BS_DIBPATTERN8X8 = 8,
        BS_MONOPATTERN = 9,
        BITSPIXEL = 12,
        BLTALIGNMENT = 119,
        BDR_RAISEDOUTER = 0x0001,
        BDR_SUNKENOUTER = 0x0002,
        BDR_RAISEDINNER = 0x0004,
        BDR_SUNKENINNER = 0x0008,
        BDR_OUTER = 0x0003,
        BDR_INNER = 0x000c,
        BDR_RAISED = 0x0005,
        BDR_SUNKEN = 0x000a,
        BF_LEFT = 0x0001,
        BF_TOP = 0x0002,
        BF_RIGHT = 0x0004,
        BF_BOTTOM = 0x0008,
        BF_TOPLEFT = (0x0002|0x0001),
                     BF_TOPRIGHT = (0x0002|0x0004),
                                   BF_BOTTOMLEFT = (0x0008|0x0001),
                                                   BF_BOTTOMRIGHT = (0x0008|0x0004),
                                                                    BF_RECT = (0x0001|0x0002|0x0004|0x0008),
                                                                              BF_DIAGONAL = 0x0010,
        BF_DIAGONAL_ENDTOPRIGHT = (0x0010|0x0002|0x0004),
                                  BF_DIAGONAL_ENDTOPLEFT = (0x0010|0x0002|0x0001),
                                                           BF_DIAGONAL_ENDBOTTOMLEFT = (0x0010|0x0008|0x0001),
                                                                                       BF_DIAGONAL_ENDBOTTOMRIGHT = (0x0010|0x0008|0x0004),
                                                                                                                    BF_MIDDLE = 0x0800,
        BF_SOFT = 0x1000,
        BF_ADJUST = 0x2000,
        BF_FLAT = 0x4000,
        BF_MONO = unchecked((int)0x8000),
        BSM_ALLCOMPONENTS = 0x00000000,
        BSM_VXDS = 0x00000001,
        BSM_NETDRIVER = 0x00000002,
        BSM_INSTALLABLEDRIVERS = 0x00000004,
        BSM_APPLICATIONS = 0x00000008,
        BSM_ALLDESKTOPS = 0x00000010,
        BSF_QUERY = 0x00000001,
        BSF_IGNORECURRENTTASK = 0x00000002,
        BSF_FLUSHDISK = 0x00000004,
        BSF_NOHANG = 0x00000008,
        BSF_POSTMESSAGE = 0x00000010,
        BSF_FORCEIFHUNG = 0x00000020,
        BSF_NOTIMEOUTIFNOTHUNG = 0x00000040,
        BROADCAST_QUERY_DENY = 0x424D5144,
        BS_PUSHBUTTON = 0x00000000,
        BS_DEFPUSHBUTTON = 0x00000001,
        BS_CHECKBOX = 0x00000002,
        BS_AUTOCHECKBOX = 0x00000003,
        BS_RADIOBUTTON = 0x00000004,
        BS_3STATE = 0x00000005,
        BS_AUTO3STATE = 0x00000006,
        BS_GROUPBOX = 0x00000007,
        BS_USERBUTTON = 0x00000008,
        BS_AUTORADIOBUTTON = 0x00000009,
        BS_OWNERDRAW = 0x0000000B,
        BS_LEFTTEXT = 0x00000020,
        BS_TEXT = 0x00000000,
        BS_ICON = 0x00000040,
        BS_BITMAP = 0x00000080,
        BS_LEFT = 0x00000100,
        BS_RIGHT = 0x00000200,
        BS_CENTER = 0x00000300,
        BS_TOP = 0x00000400,
        BS_BOTTOM = 0x00000800,
        BS_VCENTER = 0x00000C00,
        BS_PUSHLIKE = 0x00001000,
        BS_MULTILINE = 0x00002000,
        BS_NOTIFY = 0x00004000,
        BS_FLAT = 0x00008000,
        BS_RIGHTBUTTON = 0x00000020,
        BN_CLICKED = 0,
        BN_PAINT = 1,
        BN_HILITE = 2,
        BN_UNHILITE = 3,
        BN_DISABLE = 4,
        BN_DOUBLECLICKED = 5,
        BN_PUSHED = 2,
        BN_UNPUSHED = 3,
        BN_DBLCLK = 5,
        BN_SETFOCUS = 6,
        BN_KILLFOCUS = 7,
        BM_GETCHECK = 0x00F0,
        BM_SETCHECK = 0x00F1,
        BM_GETSTATE = 0x00F2,
        BM_SETSTATE = 0x00F3,
        BM_SETSTYLE = 0x00F4,
        BM_CLICK = 0x00F5,
        BM_GETIMAGE = 0x00F6,
        BM_SETIMAGE = 0x00F7,
        BST_UNCHECKED = 0x0000,
        BST_CHECKED = 0x0001,
        BST_INDETERMINATE = 0x0002,
        BST_PUSHED = 0x0004,
        BST_FOCUS = 0x0008,
        BLACKNESS = 0x00000042;


        public const int CDERR_DIALOGFAILURE = 0xFFFF,
        CDERR_GENERALCODES = 0x0000,
        CDERR_STRUCTSIZE = 0x0001,
        CDERR_INITIALIZATION = 0x0002,
        CDERR_NOTEMPLATE = 0x0003,
        CDERR_NOHINSTANCE = 0x0004,
        CDERR_LOADSTRFAILURE = 0x0005,
        CDERR_FINDRESFAILURE = 0x0006,
        CDERR_LOADRESFAILURE = 0x0007,
        CDERR_LOCKRESFAILURE = 0x0008,
        CDERR_MEMALLOCFAILURE = 0x0009,
        CDERR_MEMLOCKFAILURE = 0x000A,
        CDERR_NOHOOK = 0x000B,
        CDERR_REGISTERMSGFAIL = 0x000C,
        CFERR_CHOOSEFONTCODES = 0x2000,
        CFERR_NOFONTS = 0x2001,
        CFERR_MAXLESSTHANMIN = 0x2002,
        CCERR_CHOOSECOLORCODES = 0x5000,
        CDN_FIRST = (0-601),
                    CDN_LAST = (0-699),
                               CDN_INITDONE = ((0-601)-0x0000),
                                              CDN_SELCHANGE = ((0-601)-0x0001),
                                                              CDN_FOLDERCHANGE = ((0-601)-0x0002),
                                                                                 CDN_SHAREVIOLATION = ((0-601)-0x0003),
                                                                                                      CDN_HELP = ((0-601)-0x0004),
                                                                                                                 CDN_FILEOK = ((0-601)-0x0005),
                                                                                                                              CDN_TYPECHANGE = ((0-601)-0x0006),
                                                                                                                                               CC_RGBINIT = 0x00000001,
        CC_FULLOPEN = 0x00000002,
        CC_PREVENTFULLOPEN = 0x00000004,
        CC_SHOWHELP = 0x00000008,
        CC_ENABLEHOOK = 0x00000010,
        CC_ENABLETEMPLATE = 0x00000020,
        CC_ENABLETEMPLATEHANDLE = 0x00000040,
        CC_SOLIDCOLOR = 0x00000080,
        CC_ANYCOLOR = 0x00000100,
        CF_SCREENFONTS = 0x00000001,
        CF_PRINTERFONTS = 0x00000002,
        CF_BOTH = (0x00000001|0x00000002),
                  CF_SHOWHELP = 0x00000004,
        CF_ENABLEHOOK = 0x00000008,
        CF_ENABLETEMPLATE = 0x00000010,
        CF_ENABLETEMPLATEHANDLE = 0x00000020,
        CF_INITTOLOGFONTSTRUCT = 0x00000040,
        CF_USESTYLE = 0x00000080,
        CF_EFFECTS = 0x00000100,
        CF_APPLY = 0x00000200,
        CF_ANSIONLY = 0x00000400,
        CF_SCRIPTSONLY = 0x00000400,
        CF_NOVECTORFONTS = 0x00000800,
        CF_NOOEMFONTS = 0x00000800,
        CF_NOSIMULATIONS = 0x00001000,
        CF_LIMITSIZE = 0x00002000,
        CF_FIXEDPITCHONLY = 0x00004000,
        CF_WYSIWYG = 0x00008000,
        CF_FORCEFONTEXIST = 0x00010000,
        CF_SCALABLEONLY = 0x00020000,
        CF_TTONLY = 0x00040000,
        CF_NOFACESEL = 0x00080000,
        CF_NOSTYLESEL = 0x00100000,
        CF_NOSIZESEL = 0x00200000,
        CF_SELECTSCRIPT = 0x00400000,
        CF_NOSCRIPTSEL = 0x00800000,
        CF_NOVERTFONTS = 0x01000000,
        CD_LBSELNOITEMS = -1,
        CD_LBSELCHANGE = 0,
        CD_LBSELSUB = 1,
        CD_LBSELADD = 2,
        CADV_LATEACK = 0xFFFF,
        CP_WINANSI = 1004,
        CP_WINUNICODE = 1200;
        // CP_WINNEUTRAL = 1004;
        public const int CBF_FAIL_SELFCONNECTIONS = 0x00001000,
        CBF_FAIL_CONNECTIONS = 0x00002000,
        CBF_FAIL_ADVISES = 0x00004000,
        CBF_FAIL_EXECUTES = 0x00008000,
        CBF_FAIL_POKES = 0x00010000,
        CBF_FAIL_REQUESTS = 0x00020000,
        CBF_FAIL_ALLSVRXACTIONS = 0x0003f000,
        CBF_SKIP_CONNECT_CONFIRMS = 0x00040000,
        CBF_SKIP_REGISTRATIONS = 0x00080000,
        CBF_SKIP_UNREGISTRATIONS = 0x00100000,
        CBF_SKIP_DISCONNECTS = 0x00200000,
        CBF_SKIP_ALLNOTIFICATIONS = 0x003c0000,
        ctlFirst = 0x0400,
        ctlLast = 0x04ff,
        chx1 = 0x0410,
        chx2 = 0x0411,
        chx3 = 0x0412,
        chx4 = 0x0413,
        chx5 = 0x0414,
        chx6 = 0x0415,
        chx7 = 0x0416,
        chx8 = 0x0417,
        chx9 = 0x0418,
        chx10 = 0x0419,
        chx11 = 0x041a,
        chx12 = 0x041b,
        chx13 = 0x041c,
        chx14 = 0x041d,
        chx15 = 0x041e,
        chx16 = 0x041f,
        cmb1 = 0x0470,
        cmb2 = 0x0471,
        cmb3 = 0x0472,
        cmb4 = 0x0473,
        cmb5 = 0x0474,
        cmb6 = 0x0475,
        cmb7 = 0x0476,
        cmb8 = 0x0477,
        cmb9 = 0x0478,
        cmb10 = 0x0479,
        cmb11 = 0x047a,
        cmb12 = 0x047b,
        cmb13 = 0x047c,
        cmb14 = 0x047d,
        cmb15 = 0x047e,
        cmb16 = 0x047f,
        CPS_COMPLETE = 0x0001,
        CPS_CONVERT = 0x0002,
        CPS_REVERT = 0x0003,
        CPS_CANCEL = 0x0004,
        CS_INSERTCHAR = 0x2000,
        CS_NOMOVECARET = 0x4000,
        CFS_DEFAULT = 0x0000,
        CFS_RECT = 0x0001,
        CFS_POINT = 0x0002,
        CFS_FORCE_POSITION = 0x0020,
        CFS_CANDIDATEPOS = 0x0040,
        CFS_EXCLUDE = 0x0080,
        CALLBACK_TYPEMASK = 0x00070000,
        CALLBACK_NULL = 0x00000000,
        CALLBACK_WINDOW = 0x00010000,
        CALLBACK_TASK = 0x00020000,
        CALLBACK_FUNCTION = 0x00030000,
        CALLBACK_THREAD = (0x00020000),
                          CALLBACK_EVENT = 0x00050000;
        public const char CFSEPCHAR = '+';
        public const int CALL_PENDING = 0x02,
        CWCSTORAGENAME = 32,
        COM_RIGHTS_EXECUTE = 1,
        cbNDRContext = 20,
        CREATE_NEW = 1,
        CREATE_ALWAYS = 2,
        CALLBACK_CHUNK_FINISHED = 0x00000000,
        CALLBACK_STREAM_SWITCH = 0x00000001,
        COPY_FILE_FAIL_IF_EXISTS = 0x00000001,
        COPY_FILE_RESTARTABLE = 0x00000002,
        COMMPROP_INITIALIZED = (unchecked((int)0xE73CF52E)),
                               CREATE_SUSPENDED = 0x00000004,
        CREATE_NEW_CONSOLE = 0x00000010,
        CREATE_NEW_PROCESS_GROUP = 0x00000200,
        CREATE_UNICODE_ENVIRONMENT = 0x00000400,
        CREATE_SEPARATE_WOW_VDM = 0x00000800,
        CREATE_SHARED_WOW_VDM = 0x00001000,
        CREATE_FORCEDOS = 0x00002000,
        CREATE_DEFAULT_ERROR_MODE = 0x04000000,
        CREATE_NO_WINDOW = 0x08000000,
        CREATE_THREAD_DEBUG_EVENT = 2,
        CREATE_PROCESS_DEBUG_EVENT = 3,
        CBR_110 = 110,
        CBR_300 = 300,
        CBR_600 = 600,
        CBR_1200 = 1200,
        CBR_2400 = 2400,
        CBR_4800 = 4800,
        CBR_9600 = 9600,
        CBR_14400 = 14400,
        CBR_19200 = 19200,
        CBR_38400 = 38400,
        CBR_56000 = 56000,
        CBR_57600 = 57600,
        CBR_115200 = 115200,
        CBR_128000 = 128000,
        CBR_256000 = 256000,
        CE_RXOVER = 0x0001,
        CE_OVERRUN = 0x0002,
        CE_RXPARITY = 0x0004,
        CE_FRAME = 0x0008,
        CE_BREAK = 0x0010,
        CE_TXFULL = 0x0100,
        CE_PTO = 0x0200,
        CE_IOE = 0x0400,
        CE_DNS = 0x0800,
        CE_OOP = 0x1000,
        CE_MODE = unchecked((int)0x8000),
        CLRRTS = 4,
        CLRDTR = 6,
        CLRBREAK = 9,
        CAPSLOCK_ON = 0x0080,
        CTRL_C_EVENT = 0,
        CTRL_BREAK_EVENT = 1,
        CTRL_CLOSE_EVENT = 2,
        CTRL_LOGOFF_EVENT = 5,
        CTRL_SHUTDOWN_EVENT = 6,
        CONSOLE_TEXTMODE_BUFFER = 1,
        CRYPT_MODE_CBCI = 6,
        CRYPT_MODE_CFBP = 7,
        CRYPT_MODE_OFBP = 8,
        CRYPT_MODE_CBCOFM = 9,
        CRYPT_MODE_CBCOFMI = 10,
        CALG_MD2 = ((4<<13)|(0)|1),
                   CALG_MD4 = ((4<<13)|(0)|2),
                              CALG_MD5 = ((4<<13)|(0)|3),
                                         CALG_SHA = ((4<<13)|(0)|4),
                                                    CALG_MAC = ((4<<13)|(0)|5),
                                                               CALG_RSA_SIGN = ((1<<13)|(2<<9)|0),
                                                                               CALG_DSS_SIGN = ((1<<13)|(1<<9)|0),
                                                                                               CALG_RSA_KEYX = ((5<<13)|(2<<9)|0),
                                                                                                               CALG_DES = ((3<<13)|(3<<9)|1),
                                                                                                                          CALG_RC2 = ((3<<13)|(3<<9)|2),
                                                                                                                                     CALG_RC4 = ((3<<13)|(4<<9)|1),
                                                                                                                                                CALG_SEAL = ((3<<13)|(4<<9)|2),
                                                                                                                                                            CRYPT_VERIFYCONTEXT = unchecked((int)0xF0000000),
        CRYPT_NEWKEYSET = unchecked((int)0x8),
        CRYPT_DELETEKEYSET = 0x10,
        CRYPT_EXPORTABLE = 0x00000001,
        CRYPT_USER_PROTECTED = 0x00000002,
        CRYPT_CREATE_SALT = 0x00000004,
        CRYPT_UPDATE_KEY = 0x00000008,
        CRYPT_USERDATA = 1,
        CRYPT_MODE_CBC = 1,
        CRYPT_MODE_ECB = 2,
        CRYPT_MODE_OFB = 3,
        CRYPT_MODE_CFB = 4,
        CRYPT_MODE_CTS = 5,
        CRYPT_ENCRYPT = 0x0001,
        CRYPT_DECRYPT = 0x0002,
        CRYPT_READ = 0x0008,
        CRYPT_WRITE = 0x0010,
        CRYPT_MAC = 0x0020;
        public const bool CRYPT_FAILED = false,
        CRYPT_SUCCEED = true;
        public const int CRYPT_FIRST = 1,
        CRYPT_NEXT = 2,
        CRYPT_IMPL_HARDWARE = 1,
        CRYPT_IMPL_SOFTWARE = 2,
        CRYPT_IMPL_MIXED = 3,
        CRYPT_IMPL_UNKNOWN = 4,
        CUR_BLOB_VERSION = 2,
        CO_E_INIT_TLS = (int)unchecked((int)0x80004006),
        CO_E_INIT_SHARED_ALLOCATOR = (int)unchecked((int)0x80004007),
        CO_E_INIT_MEMORY_ALLOCATOR = (int)unchecked((int)0x80004008),
        CO_E_INIT_CLASS_CACHE = (int)unchecked((int)0x80004009),
        CO_E_INIT_RPC_CHANNEL = (int)unchecked((int)0x8000400A),
        CO_E_INIT_TLS_SET_CHANNEL_CONTROL = (int)unchecked((int)0x8000400B),
        CO_E_INIT_TLS_CHANNEL_CONTROL = (int)unchecked((int)0x8000400C),
        CO_E_INIT_UNACCEPTED_USER_ALLOCATOR = (int)unchecked((int)0x8000400D),
        CO_E_INIT_SCM_MUTEX_EXISTS = (int)unchecked((int)0x8000400E),
        CO_E_INIT_SCM_FILE_MAPPING_EXISTS = (int)unchecked((int)0x8000400F),
        CO_E_INIT_SCM_MAP_VIEW_OF_FILE = (int)unchecked((int)0x80004010),
        CO_E_INIT_SCM_EXEC_FAILURE = (int)unchecked((int)0x80004011),
        CO_E_INIT_ONLY_SINGLE_THREADED = (int)unchecked((int)0x80004012),
        CO_E_CANT_REMOTE = (int)unchecked((int)0x80004013),
        CO_E_BAD_SERVER_NAME = (int)unchecked((int)0x80004014),
        CO_E_WRONG_SERVER_IDENTITY = (int)unchecked((int)0x80004015),
        CO_E_OLE1DDE_DISABLED = (int)unchecked((int)0x80004016),
        CO_E_RUNAS_SYNTAX = (int)unchecked((int)0x80004017),
        CO_E_CREATEPROCESS_FAILURE = (int)unchecked((int)0x80004018),
        CO_E_RUNAS_CREATEPROCESS_FAILURE = (int)unchecked((int)0x80004019),
        CO_E_RUNAS_LOGON_FAILURE = (int)unchecked((int)0x8000401A),
        CO_E_LAUNCH_PERMSSION_DENIED = (int)unchecked((int)0x8000401B),
        CO_E_START_SERVICE_FAILURE = (int)unchecked((int)0x8000401C),
        CO_E_REMOTE_COMMUNICATION_FAILURE = (int)unchecked((int)0x8000401D),
        CO_E_SERVER_START_TIMEOUT = (int)unchecked((int)0x8000401E),
        CO_E_CLSREG_INCONSISTENT = (int)unchecked((int)0x8000401F),
        CO_E_IIDREG_INCONSISTENT = (int)unchecked((int)0x80004020),
        CO_E_NOT_SUPPORTED = (int)unchecked((int)0x80004021),
        CLASSFACTORY_E_FIRST = (int)unchecked((int)0x80040110),
        CLASSFACTORY_E_LAST = (int)unchecked((int)0x8004011F),
        CLASSFACTORY_S_FIRST = 0x00040110,
        CLASSFACTORY_S_LAST = 0x0004011F,
        CLASS_E_NOAGGREGATION = (int)unchecked((int)0x80040110),
        CLASS_E_CLASSNOTAVAILABLE = (int)unchecked((int)0x80040111),
        CACHE_E_FIRST = (int)unchecked((int)0x80040170),
        CACHE_E_LAST = (int)unchecked((int)0x8004017F),
        CACHE_S_FIRST = 0x00040170,
        CACHE_S_LAST = 0x0004017F,
        CACHE_E_NOCACHE_UPDATED = (int)unchecked((int)0x80040170),
        CLIENTSITE_E_FIRST = (int)unchecked((int)0x80040190),
        CLIENTSITE_E_LAST = (int)unchecked((int)0x8004019F),
        CLIENTSITE_S_FIRST = 0x00040190,
        CLIENTSITE_S_LAST = 0x0004019F,
        CONVERT10_E_FIRST = unchecked((int)0x800401C0),
        CONVERT10_E_LAST = unchecked((int)0x800401CF),
        CONVERT10_S_FIRST = 0x000401C0,
        CONVERT10_S_LAST = 0x000401CF,
        CONVERT10_E_OLESTREAM_GET = unchecked((int)0x800401C0),
        CONVERT10_E_OLESTREAM_PUT = unchecked((int)0x800401C1),
        CONVERT10_E_OLESTREAM_FMT = unchecked((int)0x800401C2),
        CONVERT10_E_OLESTREAM_BITMAP_TO_DIB = unchecked((int)0x800401C3),
        CONVERT10_E_STG_FMT = unchecked((int)0x800401C4),
        CONVERT10_E_STG_NO_STD_STREAM = unchecked((int)0x800401C5),
        CONVERT10_E_STG_DIB_TO_BITMAP = unchecked((int)0x800401C6),
        CLIPBRD_E_FIRST = unchecked((int)0x800401D0),
        CLIPBRD_E_LAST = unchecked((int)0x800401DF),
        CLIPBRD_S_FIRST = 0x000401D0,
        CLIPBRD_S_LAST = 0x000401DF,
        CLIPBRD_E_CANT_OPEN = unchecked((int)0x800401D0),
        CLIPBRD_E_CANT_EMPTY = unchecked((int)0x800401D1),
        CLIPBRD_E_CANT_SET = unchecked((int)0x800401D2),
        CLIPBRD_E_BAD_DATA = unchecked((int)0x800401D3),
        CLIPBRD_E_CANT_CLOSE = unchecked((int)0x800401D4),
        CO_E_FIRST = unchecked((int)0x800401F0),
        CO_E_LAST = unchecked((int)0x800401FF),
        CO_S_FIRST = 0x000401F0,
        CO_S_LAST = 0x000401FF,
        CO_E_NOTINITIALIZED = unchecked((int)0x800401F0),
        CO_E_ALREADYINITIALIZED = unchecked((int)0x800401F1),
        CO_E_CANTDETERMINECLASS = unchecked((int)0x800401F2),
        CO_E_CLASSSTRING = unchecked((int)0x800401F3),
        CO_E_IIDSTRING = unchecked((int)0x800401F4),
        CO_E_APPNOTFOUND = unchecked((int)0x800401F5),
        CO_E_APPSINGLEUSE = unchecked((int)0x800401F6),
        CO_E_ERRORINAPP = unchecked((int)0x800401F7),
        CO_E_DLLNOTFOUND = unchecked((int)0x800401F8),
        CO_E_ERRORINDLL = unchecked((int)0x800401F9),
        CO_E_WRONGOSFORAPP = unchecked((int)0x800401FA),
        CO_E_OBJNOTREG = unchecked((int)0x800401FB),
        CO_E_OBJISREG = unchecked((int)0x800401FC),
        CO_E_OBJNOTCONNECTED = unchecked((int)0x800401FD),
        CO_E_APPDIDNTREG = unchecked((int)0x800401FE),
        CO_E_RELEASED = unchecked((int)0x800401FF),
        CACHE_S_FORMATETC_NOTSUPPORTED = 0x00040170,
        CACHE_S_SAMECACHE = 0x00040171,
        CACHE_S_SOMECACHES_NOTUPDATED = 0x00040172,
        CONVERT10_S_NO_PRESENTATION = 0x000401C0,
        CO_E_CLASS_CREATE_FAILED = unchecked((int)0x80080001),
        CO_E_SCM_ERROR = unchecked((int)0x80080002),
        CO_E_SCM_RPC_FAILURE = unchecked((int)0x80080003),
        CO_E_BAD_PATH = unchecked((int)0x80080004),
        CO_E_SERVER_EXEC_FAILURE = unchecked((int)0x80080005),
        CO_E_OBJSRV_RPC_FAILURE = unchecked((int)0x80080006),
        CO_E_SERVER_STOPPING = unchecked((int)0x80080008),
        CO_S_NOTALLINTERFACES = 0x00080012,
        CERT_E_EXPIRED = unchecked((int)0x800B0101),
        CERT_E_VALIDIYPERIODNESTING = unchecked((int)0x800B0102),
        CERT_E_ROLE = unchecked((int)0x800B0103),
        CERT_E_CRITICAL = unchecked((int)0x800B0105),
        CERT_E_PURPOSE = unchecked((int)0x800B0106),
        CERT_E_ISSUERCHAINING = unchecked((int)0x800B0107),
        CERT_E_MALFORMED = unchecked((int)0x800B0108),
        CERT_E_UNTRUSTEDROOT = unchecked((int)0x800B0109),
        CERT_E_CHAINING = unchecked((int)0x800B010A),
        COMPLEXREGION = 3,
        COLORONCOLOR = 3,
        CLIP_TO_PATH = 4097,
        CLOSECHANNEL = 4112,
        CM_OUT_OF_GAMUT = 255,
        CM_IN_GAMUT = 0,
        CLIP_DEFAULT_PRECIS = 0,
        CLIP_CHARACTER_PRECIS = 1,
        CLIP_STROKE_PRECIS = 2,
        CLIP_MASK = 0xf,
        CLIP_LH_ANGLES = (1<<4),
                         CLIP_TT_ALWAYS = (2<<4),
                                          CLIP_EMBEDDED = (8<<4),
                                                          CHINESEBIG5_CHARSET = 136,
        CLR_INVALID = unchecked((int)0xFFFFFFFF),
        CURVECAPS = 28,
        CLIPCAPS = 36,
        COLORRES = 108,
        CC_NONE = 0,
        CC_CIRCLES = 1,
        CC_PIE = 2,
        CC_CHORD = 4,
        CC_ELLIPSES = 8,
        CC_WIDE = 16,
        CC_STYLED = 32,
        CC_WIDESTYLED = 64,
        CC_INTERIORS = 128,
        CC_ROUNDRECT = 256,
        CP_NONE = 0,
        CP_RECTANGLE = 1,
        CP_REGION = 2,
        CBM_INIT = 0x04,
        CCHDEVICENAME = 32,
        CCHFORMNAME = 32,
        CA_NEGATIVE = 0x0001,
        CA_LOG_FILTER = 0x0002,
        CONNECT_UPDATE_PROFILE = 0x00000001,
        CONNECT_UPDATE_RECENT = 0x00000002,
        CONNECT_TEMPORARY = 0x00000004,
        CONNECT_INTERACTIVE = 0x00000008,
        CONNECT_PROMPT = 0x00000010,
        CONNECT_NEED_DRIVE = 0x00000020,
        CONNECT_REFCOUNT = 0x00000040,
        CONNECT_REDIRECT = 0x00000080,
        CONNECT_LOCALDRIVE = 0x00000100,
        CONNECT_CURRENT_MEDIA = 0x00000200,
        CONNECT_DEFERRED = 0x00000400,
        CONNECT_RESERVED = unchecked((int)0xFF000000),
        CONNDLG_RO_PATH = 0x00000001,
        CONNDLG_CONN_POINT = 0x00000002,
        CONNDLG_USE_MRU = 0x00000004,
        CONNDLG_HIDE_BOX = 0x00000008,
        CONNDLG_PERSIST = 0x00000010,
        CONNDLG_NOT_PERSIST = 0x00000020,
        CT_CTYPE1 = 0x00000001,
        CT_CTYPE2 = 0x00000002,
        CT_CTYPE3 = 0x00000004,
        C1_UPPER = 0x0001,
        C1_LOWER = 0x0002,
        C1_DIGIT = 0x0004,
        C1_SPACE = 0x0008,
        C1_PUNCT = 0x0010,
        C1_CNTRL = 0x0020,
        C1_BLANK = 0x0040,
        C1_XDIGIT = 0x0080,
        C1_ALPHA = 0x0100,
        C2_LEFTTORIGHT = 0x0001,
        C2_RIGHTTOLEFT = 0x0002,
        C2_EUROPENUMBER = 0x0003,
        C2_EUROPESEPARATOR = 0x0004,
        C2_EUROPETERMINATOR = 0x0005,
        C2_ARABICNUMBER = 0x0006,
        C2_COMMONSEPARATOR = 0x0007,
        C2_BLOCKSEPARATOR = 0x0008,
        C2_SEGMENTSEPARATOR = 0x0009,
        C2_WHITESPACE = 0x000A,
        C2_OTHERNEUTRAL = 0x000B,
        C2_NOTAPPLICABLE = 0x0000,
        C3_NONSPACING = 0x0001,
        C3_DIACRITIC = 0x0002,
        C3_VOWELMARK = 0x0004,
        C3_SYMBOL = 0x0008,
        C3_KATAKANA = 0x0010,
        C3_HIRAGANA = 0x0020,
        C3_HALFWIDTH = 0x0040,
        C3_FULLWIDTH = 0x0080,
        C3_IDEOGRAPH = 0x0100,
        C3_KASHIDA = 0x0200,
        C3_LEXICAL = 0x0400,
        C3_ALPHA = unchecked((int)0x8000),
        C3_NOTAPPLICABLE = 0x0000,
        CP_INSTALLED = 0x00000001,
        CP_SUPPORTED = 0x00000002,
        CP_ACP = 0,
        CP_OEMCP = 1,
        CP_MACCP = 2,
        CP_UTF7 = 65000,
        CP_UTF8 = 65001,
        CTRY_DEFAULT = 0,
        CTRY_AUSTRALIA = 61,
        CTRY_AUSTRIA = 43,
        CTRY_BELGIUM = 32,
        CTRY_BRAZIL = 55,
        CTRY_BULGARIA = 359,
        CTRY_CANADA = 2,
        CTRY_CROATIA = 385,
        CTRY_CZECH = 42,
        CTRY_DENMARK = 45,
        CTRY_FINLAND = 358,
        CTRY_FRANCE = 33,
        CTRY_GERMANY = 49,
        CTRY_GREECE = 30,
        CTRY_HONG_KONG = 852,
        CTRY_HUNGARY = 36,
        CTRY_ICELAND = 354,
        CTRY_IRELAND = 353,
        CTRY_ITALY = 39,
        CTRY_JAPAN = 81,
        CTRY_MEXICO = 52,
        CTRY_NETHERLANDS = 31,
        CTRY_NEW_ZEALAND = 64,
        CTRY_NORWAY = 47,
        CTRY_POLAND = 48,
        CTRY_PORTUGAL = 351,
        CTRY_PRCHINA = 86,
        CTRY_ROMANIA = 40,
        CTRY_RUSSIA = 7,
        CTRY_SINGAPORE = 65,
        CTRY_SLOVAK = 42,
        CTRY_SLOVENIA = 386,
        CTRY_SOUTH_KOREA = 82,
        CTRY_SPAIN = 34,
        CTRY_SWEDEN = 46,
        CTRY_SWITZERLAND = 41,
        CTRY_TAIWAN = 886,
        CTRY_TURKEY = 90,
        CTRY_UNITED_KINGDOM = 44,
        CTRY_UNITED_STATES = 1,
        CAL_ICALINTVALUE = 0x00000001,
        CAL_SCALNAME = 0x00000002,
        CAL_IYEAROFFSETRANGE = 0x00000003,
        CAL_SERASTRING = 0x00000004,
        CAL_SSHORTDATE = 0x00000005,
        CAL_SLONGDATE = 0x00000006,
        CAL_SDAYNAME1 = 0x00000007,
        CAL_SDAYNAME2 = 0x00000008,
        CAL_SDAYNAME3 = 0x00000009,
        CAL_SDAYNAME4 = 0x0000000a,
        CAL_SDAYNAME5 = 0x0000000b,
        CAL_SDAYNAME6 = 0x0000000c,
        CAL_SDAYNAME7 = 0x0000000d,
        CAL_SABBREVDAYNAME1 = 0x0000000e,
        CAL_SABBREVDAYNAME2 = 0x0000000f,
        CAL_SABBREVDAYNAME3 = 0x00000010,
        CAL_SABBREVDAYNAME4 = 0x00000011,
        CAL_SABBREVDAYNAME5 = 0x00000012,
        CAL_SABBREVDAYNAME6 = 0x00000013,
        CAL_SABBREVDAYNAME7 = 0x00000014,
        CAL_SMONTHNAME1 = 0x00000015,
        CAL_SMONTHNAME2 = 0x00000016,
        CAL_SMONTHNAME3 = 0x00000017,
        CAL_SMONTHNAME4 = 0x00000018,
        CAL_SMONTHNAME5 = 0x00000019,
        CAL_SMONTHNAME6 = 0x0000001a,
        CAL_SMONTHNAME7 = 0x0000001b,
        CAL_SMONTHNAME8 = 0x0000001c,
        CAL_SMONTHNAME9 = 0x0000001d,
        CAL_SMONTHNAME10 = 0x0000001e,
        CAL_SMONTHNAME11 = 0x0000001f,
        CAL_SMONTHNAME12 = 0x00000020,
        CAL_SMONTHNAME13 = 0x00000021,
        CAL_SABBREVMONTHNAME1 = 0x00000022,
        CAL_SABBREVMONTHNAME2 = 0x00000023,
        CAL_SABBREVMONTHNAME3 = 0x00000024,
        CAL_SABBREVMONTHNAME4 = 0x00000025,
        CAL_SABBREVMONTHNAME5 = 0x00000026,
        CAL_SABBREVMONTHNAME6 = 0x00000027,
        CAL_SABBREVMONTHNAME7 = 0x00000028,
        CAL_SABBREVMONTHNAME8 = 0x00000029,
        CAL_SABBREVMONTHNAME9 = 0x0000002a,
        CAL_SABBREVMONTHNAME10 = 0x0000002b,
        CAL_SABBREVMONTHNAME11 = 0x0000002c,
        CAL_SABBREVMONTHNAME12 = 0x0000002d,
        CAL_SABBREVMONTHNAME13 = 0x0000002e,
        CAL_GREGORIAN = 1,
        CAL_GREGORIAN_US = 2,
        CAL_JAPAN = 3,
        CAL_TAIWAN = 4,
        CAL_KOREA = 5,
        CAL_HIJRI = 6,
        CAL_THAI = 7,
        CAL_HEBREW = 8;
        public const int CONTAINER_INHERIT_ACE = (0x2),
                                                 COMPRESSION_FORMAT_NONE = (0x0000),
                                                                           COMPRESSION_FORMAT_DEFAULT = (0x0001),
                                                                                                        COMPRESSION_FORMAT_LZNT1 = (0x0002),
                                                                                                                                   COMPRESSION_ENGINE_STANDARD = (0x0000),
                                                                                                                                                                 COMPRESSION_ENGINE_MAXIMUM = (0x0100),
                                                                                                                                                                                              CS_VREDRAW = 0x0001,
        CS_HREDRAW = 0x0002,
        CS_KEYCVTWINDOW = 0x0004,
        CS_DBLCLKS = 0x0008,
        CS_OWNDC = 0x0020,
        CS_CLASSDC = 0x0040,
        CS_PARENTDC = 0x0080,
        CS_NOKEYCVT = 0x0100,
        CS_NOCLOSE = 0x0200,
        CS_SAVEBITS = 0x0800,
        CS_BYTEALIGNCLIENT = 0x1000,
        CS_BYTEALIGNWINDOW = 0x2000,
        CS_GLOBALCLASS = 0x4000,
        CS_IME = 0x00010000,
        CF_TEXT = 1,
        CF_BITMAP = 2,
        CF_METAFILEPICT = 3,
        CF_SYLK = 4,
        CF_DIF = 5,
        CF_TIFF = 6,
        CF_OEMTEXT = 7,
        CF_DIB = 8,
        CF_PALETTE = 9,
        CF_PENDATA = 10,
        CF_RIFF = 11,
        CF_WAVE = 12,
        CF_UNICODETEXT = 13,
        CF_ENHMETAFILE = 14,
        CF_HDROP = 15,
        CF_LOCALE = 16,
        CF_MAX = 17,
        CF_OWNERDISPLAY = 0x0080,
        CF_DSPTEXT = 0x0081,
        CF_DSPBITMAP = 0x0082,
        CF_DSPMETAFILEPICT = 0x0083,
        CF_DSPENHMETAFILE = 0x008E,
        CF_PRIVATEFIRST = 0x0200,
        CF_PRIVATELAST = 0x02FF,
        CF_GDIOBJFIRST = 0x0300,
        CF_GDIOBJLAST = 0x03FF,
        CW_USEDEFAULT = (unchecked((int)0x80000000)),
                        CWP_ALL = 0x0000,
        CWP_SKIPINVISIBLE = 0x0001,
        CWP_SKIPDISABLED = 0x0002,
        CWP_SKIPTRANSPARENT = 0x0004,
        CTLCOLOR_MSGBOX = 0,
        CTLCOLOR_EDIT = 1,
        CTLCOLOR_LISTBOX = 2,
        CTLCOLOR_BTN = 3,
        CTLCOLOR_DLG = 4,
        CTLCOLOR_SCROLLBAR = 5,
        CTLCOLOR_STATIC = 6,
        CTLCOLOR_MAX = 7,
        COLOR_SCROLLBAR = 0,
        COLOR_BACKGROUND = 1,
        COLOR_ACTIVECAPTION = 2,
        COLOR_INACTIVECAPTION = 3,
        COLOR_MENU = 4,
        COLOR_WINDOW = 5,
        COLOR_WINDOWFRAME = 6,
        COLOR_MENUTEXT = 7,
        COLOR_WINDOWTEXT = 8,
        COLOR_CAPTIONTEXT = 9,
        COLOR_ACTIVEBORDER = 10,
        COLOR_INACTIVEBORDER = 11,
        COLOR_APPWORKSPACE = 12,
        COLOR_HIGHLIGHT = 13,
        COLOR_HIGHLIGHTTEXT = 14,
        COLOR_BTNFACE = 15,
        COLOR_BTNSHADOW = 16,
        COLOR_GRAYTEXT = 17,
        COLOR_BTNTEXT = 18,
        COLOR_INACTIVECAPTIONTEXT = 19,
        COLOR_BTNHIGHLIGHT = 20,
        COLOR_3DDKSHADOW = 21,
        COLOR_3DLIGHT = 22,
        COLOR_INFOTEXT = 23,
        COLOR_INFOBK = 24,
        COLOR_DESKTOP = 1,
        COLOR_3DFACE = 15,
        COLOR_3DSHADOW = 16,
        COLOR_3DHIGHLIGHT = 20,
        COLOR_3DHILIGHT = 20,
        COLOR_BTNHILIGHT = 20,
        CB_OKAY = 0,
        CB_ERR = (-1),
                 CB_ERRSPACE = (-2),
                               CBN_ERRSPACE = (-1),
                                              CBN_SELCHANGE = 1,
        CBN_DBLCLK = 2,
        CBN_SETFOCUS = 3,
        CBN_KILLFOCUS = 4,
        CBN_EDITCHANGE = 5,
        CBN_EDITUPDATE = 6,
        CBN_DROPDOWN = 7,
        CBN_CLOSEUP = 8,
        CBN_SELENDOK = 9,
        CBN_SELENDCANCEL = 10,
        CBS_SIMPLE = 0x0001,
        CBS_DROPDOWN = 0x0002,
        CBS_DROPDOWNLIST = 0x0003,
        CBS_OWNERDRAWFIXED = 0x0010,
        CBS_OWNERDRAWVARIABLE = 0x0020,
        CBS_AUTOHSCROLL = 0x0040,
        CBS_OEMCONVERT = 0x0080,
        CBS_SORT = 0x0100,
        CBS_HASSTRINGS = 0x0200,
        CBS_NOINTEGRALHEIGHT = 0x0400,
        CBS_DISABLENOSCROLL = 0x0800,
        CBS_UPPERCASE = 0x2000,
        CBS_LOWERCASE = 0x4000,
        CB_GETEDITSEL = 0x0140,
        CB_LIMITTEXT = 0x0141,
        CB_SETEDITSEL = 0x0142,
        CB_ADDSTRING = 0x0143,
        CB_DELETESTRING = 0x0144,
        CB_DIR = 0x0145,
        CB_GETCOUNT = 0x0146,
        CB_GETCURSEL = 0x0147,
        CB_GETLBTEXT = 0x0148,
        CB_GETLBTEXTLEN = 0x0149,
        CB_INSERTSTRING = 0x014A,
        CB_RESETCONTENT = 0x014B,
        CB_FINDSTRING = 0x014C,
        CB_SELECTSTRING = 0x014D,
        CB_SETCURSEL = 0x014E,
        CB_SHOWDROPDOWN = 0x014F,
        CB_GETITEMDATA = 0x0150,
        CB_SETITEMDATA = 0x0151,
        CB_GETDROPPEDCONTROLRECT = 0x0152,
        CB_SETITEMHEIGHT = 0x0153,
        CB_GETITEMHEIGHT = 0x0154,
        CB_SETEXTENDEDUI = 0x0155,
        CB_GETEXTENDEDUI = 0x0156,
        CB_GETDROPPEDSTATE = 0x0157,
        CB_FINDSTRINGEXACT = 0x0158,
        CB_SETLOCALE = 0x0159,
        CB_GETLOCALE = 0x015A,
        CB_GETTOPINDEX = 0x015b,
        CB_SETTOPINDEX = 0x015c,
        CB_GETHORIZONTALEXTENT = 0x015d,
        CB_SETHORIZONTALEXTENT = 0x015e,
        CB_GETDROPPEDWIDTH = 0x015f,
        CB_SETDROPPEDWIDTH = 0x0160,
        CB_INITSTORAGE = 0x0161,
        CB_MSGMAX = 0x0162;
        // CB_MSGMAX = 0x015B;
        public const int CDS_UPDATEREGISTRY = 0x00000001,
        CDS_TEST = 0x00000002,
        CDS_FULLSCREEN = 0x00000004,
        CDS_GLOBAL = 0x00000008,
        CDS_SET_PRIMARY = 0x00000010,
        CDS_RESET = 0x40000000,
        CDS_SETRECT = 0x20000000,
        CDS_NORESET = 0x10000000,
        CBEN_FIRST = (0-800),
                     CBEN_LAST = (0-830),
                                 CDRF_DODEFAULT = 0x00000000,
        CDRF_NEWFONT = 0x00000002,
        CDRF_SKIPDEFAULT = 0x00000004,
        CDRF_NOTIFYPOSTPAINT = 0x00000010,
        CDRF_NOTIFYITEMDRAW = 0x00000020,
        CDRF_NOTIFYSUBITEMDRAW = CDRF_NOTIFYITEMDRAW,
        CDRF_NOTIFYPOSTERASE = 0x00000040,
        CDRF_NOTIFYITEMERASE = 0x00000080,
        CDDS_PREPAINT = 0x00000001,
        CDDS_POSTPAINT = 0x00000002,
        CDDS_PREERASE = 0x00000003,
        CDDS_POSTERASE = 0x00000004,
        CDDS_ITEM = 0x00010000,
        CDDS_SUBITEM = 0x00020000,
        CDDS_ITEMPREPAINT = (0x00010000|0x00000001),
                            CDDS_ITEMPOSTPAINT = (0x00010000|0x00000002),
                                                 CDDS_ITEMPREERASE = (0x00010000|0x00000003),
                                                                     CDDS_ITEMPOSTERASE = (0x00010000|0x00000004),
                                                                                          CDIS_SELECTED = 0x0001,
        CDIS_GRAYED = 0x0002,
        CDIS_DISABLED = 0x0004,
        CDIS_CHECKED = 0x0008,
        CDIS_FOCUS = 0x0010,
        CDIS_DEFAULT = 0x0020,
        CDIS_HOT = 0x0040,
        CDIS_MARKED = 0x0080,
        CDIS_INDETERMINATE = 0x0100,
        CLR_NONE = unchecked((int)0xFFFFFFFF),
        CLR_DEFAULT = unchecked((int)0xFF000000),
        CLR_HILIGHT = unchecked((int)0xFF000000),
        CMB_MASKED = 0x02,
        CCS_TOP = 0x00000001,
        CCS_NOMOVEY = 0x00000002,
        CCS_BOTTOM = 0x00000003,
        CCS_NORESIZE = 0x00000004,
        CCS_NOPARENTALIGN = 0x00000008,
        CCS_ADJUSTABLE = 0x00000020,
        CCS_NODIVIDER = 0x00000040,
        CCS_VERT = 0x00000080,
        CCS_LEFT = (0x00000080|0x00000001),
                   CCS_RIGHT = (0x00000080|0x00000003),
                               CCS_NOMOVEX = (0x00000080|0x00000002),
                                             CBEIF_TEXT = 0x00000001,
        CBEIF_IMAGE = 0x00000002,
        CBEIF_SELECTEDIMAGE = 0x00000004,
        CBEIF_OVERLAY = 0x00000008,
        CBEIF_INDENT = 0x00000010,
        CBEIF_LPARAM = 0x00000020,
        CBEIF_DI_SETITEM = 0x10000000,
        CBEM_INSERTITEMA = (0x0400+1),
                           CBEM_SETIMAGELIST = (0x0400+2),
                                               CBEM_GETIMAGELIST = (0x0400+3),
                                                                   CBEM_GETITEMA = (0x0400+4),
                                                                                   CBEM_SETITEMA = (0x0400+5),
                                                                                                   CBEM_DELETEITEM = 0x0144,
        CBEM_GETCOMBOCONTROL = (0x0400+6),
                               CBEM_GETEDITCONTROL = (0x0400+7),
                                                     CBEM_SETEXSTYLE = (0x0400+8),
                                                                       CBEM_GETEXSTYLE = (0x0400+9),
                                                                                         CBEM_HASEDITCHANGED = (0x0400+10),
                                                                                                               CBEM_INSERTITEMW = (0x0400+11),
                                                                                                                                  CBEM_SETITEMW = (0x0400+12),
                                                                                                                                                  CBEM_GETITEMW = (0x0400+13),
                                                                                                                                                                  CBES_EX_NOEDITIMAGE = 0x00000001,
        CBES_EX_NOEDITIMAGEINDENT = 0x00000002,
        CBES_EX_PATHWORDBREAKPROC = 0x00000004,
        CBEN_GETDISPINFO = ((0-800)-0),
                           CBEN_INSERTITEM = ((0-800)-1),
                                             CBEN_DELETEITEM = ((0-800)-2),
                                                               CBEN_BEGINEDIT = ((0-800)-4),
                                                                                CBEN_ENDEDITA = ((0-800)-5),
                                                                                                CBEN_ENDEDITW = ((0-800)-6),
                                                                                                                CBENF_KILLFOCUS = 1,
        CBENF_RETURN = 2,
        CBENF_ESCAPE = 3,
        CBENF_DROPDOWN = 4,
        CBEMAXSTRLEN = 260,
        CDM_FIRST = (0x0400+100),
                    CDM_LAST = (0x0400+200),
                               CDM_GETSPEC = ((0x0400+100)+0x0000),
                                             CDM_GETFILEPATH = ((0x0400+100)+0x0001),
                                                               CDM_GETFOLDERPATH = ((0x0400+100)+0x0002),
                                                                                   CDM_GETFOLDERIDLIST = ((0x0400+100)+0x0003),
                                                                                                         CDM_SETCONTROLTEXT = ((0x0400+100)+0x0004),
                                                                                                                              CDM_HIDECONTROL = ((0x0400+100)+0x0005),
                                                                                                                                                CDM_SETDEFEXT = ((0x0400+100)+0x0006),
                                                                                                                                                                CONTROL_C_EXIT = (unchecked((int)0xC000013A)),
                                                                                                                                                                                 CCM_FIRST = 0x2000,
        CCM_SETBKCOLOR = (CCM_FIRST + 1),
                         CCM_SETCOLORSCHEME = (CCM_FIRST + 2),
                                              CCM_GETCOLORSCHEME = (CCM_FIRST + 3),
                                                                   CCM_GETDROPTARGET = (CCM_FIRST + 4),
                                                                                       CCM_SETUNICODEFORMAT = (CCM_FIRST + 5),
                                                                                                              CCM_GETUNICODEFORMAT = (CCM_FIRST + 6);

        public const int  CLSCTX_INPROC_SERVER  = 0x1,
        CLSCTX_INPROC_HANDLER   = 0x2,
        CLSCTX_LOCAL_SERVER = 0x4,
        CLSCTX_INPROC_SERVER16  = unchecked((int)0x8),
        CLSCTX_REMOTE_SERVER    = 0x10,
        CLSCTX_INPROC_HANDLER16 = 0x20,
        CLSCTX_INPROC_SERVERX86 = 0x40,
        CLSCTX_INPROC_HANDLERX86    = unchecked((int)0x80),
        CLSCTX_ESERVER_HANDLER  = 0x100,
        CLSCTX_RESERVED = 0x200,
        CLSCTX_NO_CODE_DOWNLOAD = 0x400;
        
        public const int CTRLINFO_EATS_RETURN    = 1,
        CTRLINFO_EATS_ESCAPE    = 2;

        public const int DN_DEFAULTPRN = 0x0001,
        DDE_FACK = unchecked((int)0x8000),
        DDE_FBUSY = 0x4000,
        DDE_FDEFERUPD = 0x4000,
        DDE_FACKREQ = unchecked((int)0x8000),
        DDE_FRELEASE = 0x2000,
        DDE_FREQUESTED = 0x1000,
        DDE_FAPPSTATUS = 0x00ff,
        DDE_FNOTPROCESSED = 0x0000,
        DDE_FACKRESERVED = (~(unchecked((int)0x8000)|0x4000|0x00ff)),
                           DDE_FADVRESERVED = (~(unchecked((int)0x8000)|0x4000)),
                                              DDE_FDATRESERVED = (~(unchecked((int)0x8000)|0x2000|0x1000)),
                                                                 DDE_FPOKRESERVED = (~(0x2000)),
                                                                                    DNS_REGISTER = 0x0001,
        DNS_UNREGISTER = 0x0002,
        DNS_FILTERON = 0x0004,
        DNS_FILTEROFF = 0x0008,
        DMLERR_NO_ERROR = 0,
        DMLERR_FIRST = 0x4000,
        DMLERR_ADVACKTIMEOUT = 0x4000,
        DMLERR_BUSY = 0x4001,
        DMLERR_DATAACKTIMEOUT = 0x4002,
        DMLERR_DLL_NOT_INITIALIZED = 0x4003,
        DMLERR_DLL_USAGE = 0x4004,
        DMLERR_EXECACKTIMEOUT = 0x4005,
        DMLERR_INVALIDPARAMETER = 0x4006,
        DMLERR_LOW_MEMORY = 0x4007,
        DMLERR_MEMORY_ERROR = 0x4008,
        DMLERR_NOTPROCESSED = 0x4009,
        DMLERR_NO_CONV_ESTABLISHED = 0x400a,
        DMLERR_POKEACKTIMEOUT = 0x400b,
        DMLERR_POSTMSG_FAILED = 0x400c,
        DMLERR_REENTRANCY = 0x400d,
        DMLERR_SERVER_DIED = 0x400e,
        DMLERR_SYS_ERROR = 0x400f,
        DMLERR_UNADVACKTIMEOUT = 0x4010,
        DMLERR_UNFOUND_QUEUE_ID = 0x4011,
        DMLERR_LAST = 0x4011,
        DIALOPTION_BILLING = 0x00000040,
        DIALOPTION_QUIET = 0x00000080,
        DIALOPTION_DIALTONE = 0x00000100,
        DRV_LOAD = 0x0001,
        DRV_ENABLE = 0x0002,
        DRV_OPEN = 0x0003,
        DRV_CLOSE = 0x0004,
        DRV_DISABLE = 0x0005,
        DRV_FREE = 0x0006,
        DRV_CONFIGURE = 0x0007,
        DRV_QUERYCONFIGURE = 0x0008,
        DRV_INSTALL = 0x0009,
        DRV_REMOVE = 0x000A,
        DRV_EXITSESSION = 0x000B,
        DRV_POWER = 0x000F,
        DRV_RESERVED = 0x0800,
        DRV_USER = 0x4000,
        DRVCNF_CANCEL = 0x0000,
        DRVCNF_OK = 0x0001,
        DRVCNF_RESTART = 0x0002,
        DRV_CANCEL = 0x0000,
        DRV_OK = 0x0001,
        DRV_RESTART = 0x0002,
        DRV_MCI_FIRST = 0x0800,
        DRV_MCI_LAST = (0x0800+0xFFF),
                       DEREGISTERED = 0x05,
        DUPLICATE = 0x06,
        DUPLICATE_DEREG = 0x07,
        DISPID_UNKNOWN = (-1),
                         DISPID_VALUE = (0),
                                        DISPID_PROPERTYPUT = (-3),
                                                             DISPID_NEWENUM = (-4),
                                                                              DISPID_EVALUATE = (-5),
                                                                                                DISPID_DESTRUCTOR = (-7),
                                                                                                                    DISPID_COLLECT = (-8),
                                                                                                                                     DISPATCH_METHOD = 0x1,
        DISPATCH_PROPERTYGET = 0x2,
        DISPATCH_PROPERTYPUT = 0x4,
        DISPATCH_PROPERTYPUTREF = unchecked((int)0x8),
        DROPEFFECT_NONE = (0),
                          DROPEFFECT_COPY = (1),
                                            DROPEFFECT_MOVE = (2),
                                                              DROPEFFECT_LINK = (4),
                                                                                DROPEFFECT_SCROLL = (unchecked((int)0x80000000)),
                                                                                                    DD_DEFSCROLLINSET = (11),
                                                                                                                        DD_DEFSCROLLDELAY = (50),
                                                                                                                                            DD_DEFSCROLLINTERVAL = (50),
                                                                                                                                                                   DD_DEFDRAGDELAY = (200),
                                                                                                                                                                                     DD_DEFDRAGMINDIST = (2),
                                                                                                                                                                                                         DCE_C_ERROR_STRING_LEN = 256,
        DATABITS_5 = (0x0001),
                     DATABITS_6 = (0x0002),
                                  DATABITS_7 = (0x0004),
                                               DATABITS_8 = (0x0008),
                                                            DATABITS_16 = (0x0010),
                                                                          DATABITS_16X = (0x0020),
                                                                                         DTR_CONTROL_DISABLE = 0x00,
        DTR_CONTROL_ENABLE = 0x01,
        DTR_CONTROL_HANDSHAKE = 0x02,
        DEBUG_PROCESS = 0x00000001,
        DEBUG_ONLY_THIS_PROCESS = 0x00000002,
        DETACHED_PROCESS = 0x00000008,
        DRIVE_UNKNOWN = 0,
        DRIVE_NO_ROOT_DIR = 1,
        DRIVE_REMOVABLE = 2,
        DRIVE_FIXED = 3,
        DRIVE_REMOTE = 4,
        DRIVE_CDROM = 5,
        DRIVE_RAMDISK = 6,
        DONT_RESOLVE_DLL_REFERENCES = 0x00000001,
        DDD_RAW_TARGET_PATH = 0x00000001,
        DDD_REMOVE_DEFINITION = 0x00000002,
        DDD_EXACT_MATCH_ON_REMOVE = 0x00000004,
        DDD_NO_BROADCAST_SYSTEM = 0x00000008,
        DOCKINFO_UNDOCKED = (0x1),
                            DOCKINFO_DOCKED = (0x2),
                                              DOCKINFO_USER_SUPPLIED = (0x4),
                                                                       DOCKINFO_USER_UNDOCKED = ((0x4)|(0x1)),
                                                                                                DOCKINFO_USER_DOCKED = ((0x4)|(0x2)),
                                                                                                                       DOUBLE_CLICK = 0x0002,
        DM_UPDATE = 1,
        DM_COPY = 2,
        DM_PROMPT = 4,
        DM_MODIFY = 8,
        DM_IN_BUFFER = 8,
        DM_IN_PROMPT = 4,
        DM_OUT_BUFFER = 2,
        DM_OUT_DEFAULT = 1,
        DC_FIELDS = 1,
        DC_PAPERS = 2,
        DC_PAPERSIZE = 3,
        DC_MINEXTENT = 4,
        DC_MAXEXTENT = 5,
        DC_BINS = 6,
        DC_DUPLEX = 7,
        DC_SIZE = 8,
        DC_EXTRA = 9,
        DC_VERSION = 10,
        DC_DRIVER = 11,
        DC_BINNAMES = 12,
        DC_ENUMRESOLUTIONS = 13,
        DC_FILEDEPENDENCIES = 14,
        DC_TRUETYPE = 15,
        DC_PAPERNAMES = 16,
        DC_ORIENTATION = 17,
        DC_COPIES = 18,
        DV_E_FORMATETC = unchecked((int)0x80040064),
        DV_E_DVTARGETDEVICE = unchecked((int)0x80040065),
        DV_E_STGMEDIUM = unchecked((int)0x80040066),
        DV_E_STATDATA = unchecked((int)0x80040067),
        DV_E_LINDEX = unchecked((int)0x80040068),
        DV_E_TYMED = unchecked((int)0x80040069),
        DV_E_CLIPFORMAT = unchecked((int)0x8004006A),
        DV_E_DVASPECT = unchecked((int)0x8004006B),
        DV_E_DVTARGETDEVICE_SIZE = unchecked((int)0x8004006C),
        DV_E_NOIVIEWOBJECT = unchecked((int)0x8004006D),
        DRAGDROP_E_FIRST = unchecked((int)0x80040100),
        DRAGDROP_E_LAST = unchecked((int)0x8004010F),
        DRAGDROP_S_FIRST = 0x00040100,
        DRAGDROP_S_LAST = 0x0004010F,
        DRAGDROP_E_NOTREGISTERED = unchecked((int)0x80040100),
        DRAGDROP_E_ALREADYREGISTERED = unchecked((int)0x80040101),
        DRAGDROP_E_INVALIDHWND = unchecked((int)0x80040102),
        DATA_E_FIRST = unchecked((int)0x80040130),
        DATA_E_LAST = unchecked((int)0x8004013F),
        DATA_S_FIRST = 0x00040130,
        DATA_S_LAST = 0x0004013F,
        DRAGDROP_S_DROP = 0x00040100,
        DRAGDROP_S_CANCEL = 0x00040101,
        DRAGDROP_S_USEDEFAULTCURSORS = 0x00040102,
        DATA_S_SAMEFORMATETC = 0x00040130,
        DISP_E_UNKNOWNINTERFACE = unchecked((int)0x80020001),
        DISP_E_MEMBERNOTFOUND = unchecked((int)0x80020003),
        DISP_E_PARAMNOTFOUND = unchecked((int)0x80020004),
        DISP_E_TYPEMISMATCH = unchecked((int)0x80020005),
        DISP_E_UNKNOWNNAME = unchecked((int)0x80020006),
        DISP_E_NONAMEDARGS = unchecked((int)0x80020007),
        DISP_E_BADVARTYPE = unchecked((int)0x80020008),
        DISP_E_EXCEPTION = unchecked((int)0x80020009),
        DISP_E_OVERFLOW = unchecked((int)0x8002000A),
        DISP_E_BADINDEX = unchecked((int)0x8002000B),
        DISP_E_UNKNOWNLCID = unchecked((int)0x8002000C),
        DISP_E_ARRAYISLOCKED = unchecked((int)0x8002000D),
        DISP_E_BADPARAMCOUNT = unchecked((int)0x8002000E),
        DISP_E_PARAMNOTOPTIONAL = unchecked((int)0x8002000F),
        DISP_E_BADCALLEE = unchecked((int)0x80020010),
        DISP_E_NOTACOLLECTION = unchecked((int)0x80020011),
        DIGSIG_E_ENCODE = unchecked((int)0x800B0005),
        DIGSIG_E_DECODE = unchecked((int)0x800B0006),
        DIGSIG_E_EXTENSIBILITY = unchecked((int)0x800B0007),
        DIGSIG_E_CRYPTO = unchecked((int)0x800B0008),
        DCB_RESET = 0x0001,
        DCB_ACCUMULATE = 0x0002,
        DCB_DIRTY = 0x0002,
        DCB_SET = (0x0001|0x0002),
                  DCB_ENABLE = 0x0004,
        DCB_DISABLE = 0x0008,
        DRAFTMODE = 7,
        DEVICEDATA = 19,
        DRAWPATTERNRECT = 25,
        DOWNLOADFACE = 514,
        DOWNLOADHEADER = 4111,
        DEFAULT_QUALITY = 0,
        DRAFT_QUALITY = 1,
        DEFAULT_PITCH = 0,
        DEFAULT_CHARSET = 1,
        DEVICE_FONTTYPE = 0x002,
        DKGRAY_BRUSH = 3,
        DEVICE_DEFAULT_FONT = 14,
        DEFAULT_PALETTE = 15,
        DEFAULT_GUI_FONT = 17,
        DRIVERVERSION = 0,
        DESKTOPVERTRES = 117,
        DESKTOPHORZRES = 118,
        DT_PLOTTER = 0,
        DT_RASDISPLAY = 1,
        DT_RASPRINTER = 2,
        DT_RASCAMERA = 3,
        DT_CHARSTREAM = 4,
        DT_METAFILE = 5,
        DT_DISPFILE = 6,
        DIB_RGB_COLORS = 0,
        DIB_PAL_COLORS = 1,
        DM_SPECVERSION = 0x0401,
        DM_ORIENTATION = 0x00000001,
        DM_PAPERSIZE = 0x00000002,
        DM_PAPERLENGTH = 0x00000004,
        DM_PAPERWIDTH = 0x00000008,
        DM_SCALE = 0x00000010,
        DM_COPIES = 0x00000100,
        DM_DEFAULTSOURCE = 0x00000200,
        DM_PRINTQUALITY = 0x00000400,
        DM_COLOR = 0x00000800,
        DM_DUPLEX = 0x00001000,
        DM_YRESOLUTION = 0x00002000,
        DM_TTOPTION = 0x00004000,
        DM_COLLATE = 0x00008000,
        DM_FORMNAME = 0x00010000,
        DM_LOGPIXELS = 0x00020000,
        DM_BITSPERPEL = 0x00040000,
        DM_PELSWIDTH = 0x00080000,
        DM_PELSHEIGHT = 0x00100000,
        DM_DISPLAYFLAGS = 0x00200000,
        DM_DISPLAYFREQUENCY = 0x00400000,
        DM_PANNINGWIDTH = 0x00800000,
        DM_PANNINGHEIGHT = 0x01000000,
        DM_ICMMETHOD = 0x02000000,
        DM_ICMINTENT = 0x04000000,
        DM_MEDIATYPE = 0x08000000,
        DM_DITHERTYPE = 0x10000000,
        DM_ICCMANUFACTURER = 0x20000000,
        DM_ICCMODEL = 0x40000000,
        DMORIENT_PORTRAIT = 1,
        DMORIENT_LANDSCAPE = 2,
        DMPAPER_LETTER = 1,
        DMPAPER_LETTERSMALL = 2,
        DMPAPER_TABLOID = 3,
        DMPAPER_LEDGER = 4,
        DMPAPER_LEGAL = 5,
        DMPAPER_STATEMENT = 6,
        DMPAPER_EXECUTIVE = 7,
        DMPAPER_A3 = 8,
        DMPAPER_A4 = 9,
        DMPAPER_A4SMALL = 10,
        DMPAPER_A5 = 11,
        DMPAPER_B4 = 12,
        DMPAPER_B5 = 13,
        DMPAPER_FOLIO = 14,
        DMPAPER_QUARTO = 15,
        DMPAPER_10X14 = 16,
        DMPAPER_11X17 = 17,
        DMPAPER_NOTE = 18,
        DMPAPER_ENV_9 = 19,
        DMPAPER_ENV_10 = 20,
        DMPAPER_ENV_11 = 21,
        DMPAPER_ENV_12 = 22,
        DMPAPER_ENV_14 = 23,
        DMPAPER_CSHEET = 24,
        DMPAPER_DSHEET = 25,
        DMPAPER_ESHEET = 26,
        DMPAPER_ENV_DL = 27,
        DMPAPER_ENV_C5 = 28,
        DMPAPER_ENV_C3 = 29,
        DMPAPER_ENV_C4 = 30,
        DMPAPER_ENV_C6 = 31,
        DMPAPER_ENV_C65 = 32,
        DMPAPER_ENV_B4 = 33,
        DMPAPER_ENV_B5 = 34,
        DMPAPER_ENV_B6 = 35,
        DMPAPER_ENV_ITALY = 36,
        DMPAPER_ENV_MONARCH = 37,
        DMPAPER_ENV_PERSONAL = 38,
        DMPAPER_FANFOLD_US = 39,
        DMPAPER_FANFOLD_STD_GERMAN = 40,
        DMPAPER_FANFOLD_LGL_GERMAN = 41,
        DMPAPER_ISO_B4 = 42,
        DMPAPER_JAPANESE_POSTCARD = 43,
        DMPAPER_9X11 = 44,
        DMPAPER_10X11 = 45,
        DMPAPER_15X11 = 46,
        DMPAPER_ENV_INVITE = 47,
        DMPAPER_RESERVED_48 = 48,
        DMPAPER_RESERVED_49 = 49,
        DMPAPER_LETTER_EXTRA = 50,
        DMPAPER_LEGAL_EXTRA = 51,
        DMPAPER_TABLOID_EXTRA = 52,
        DMPAPER_A4_EXTRA = 53,
        DMPAPER_LETTER_TRANSVERSE = 54,
        DMPAPER_A4_TRANSVERSE = 55,
        DMPAPER_LETTER_EXTRA_TRANSVERSE = 56,
        DMPAPER_A_PLUS = 57,
        DMPAPER_B_PLUS = 58,
        DMPAPER_LETTER_PLUS = 59,
        DMPAPER_A4_PLUS = 60,
        DMPAPER_A5_TRANSVERSE = 61,
        DMPAPER_B5_TRANSVERSE = 62,
        DMPAPER_A3_EXTRA = 63,
        DMPAPER_A5_EXTRA = 64,
        DMPAPER_B5_EXTRA = 65,
        DMPAPER_A2 = 66,
        DMPAPER_A3_TRANSVERSE = 67,
        DMPAPER_A3_EXTRA_TRANSVERSE = 68,

        // WINVER >= 0x0500
        DMPAPER_DBL_JAPANESE_POSTCARD = 69, /* Japanese Double Postcard 200 x 148 mm */
        DMPAPER_A6 =                  70,  /* A6 105 x 148 mm                 */
        DMPAPER_JENV_KAKU2 =          71,  /* Japanese Envelope Kaku #2       */
        DMPAPER_JENV_KAKU3 =          72,  /* Japanese Envelope Kaku #3       */
        DMPAPER_JENV_CHOU3 =          73,  /* Japanese Envelope Chou #3       */
        DMPAPER_JENV_CHOU4 =          74,  /* Japanese Envelope Chou #4       */
        DMPAPER_LETTER_ROTATED =      75,  /* Letter Rotated 11 x 8 1/2 11 in */
        DMPAPER_A3_ROTATED =          76,  /* A3 Rotated 420 x 297 mm         */
        DMPAPER_A4_ROTATED =          77,  /* A4 Rotated 297 x 210 mm         */
        DMPAPER_A5_ROTATED =          78,  /* A5 Rotated 210 x 148 mm         */
        DMPAPER_B4_JIS_ROTATED =      79,  /* B4 (JIS) Rotated 364 x 257 mm   */
        DMPAPER_B5_JIS_ROTATED =      80,  /* B5 (JIS) Rotated 257 x 182 mm   */
        DMPAPER_JAPANESE_POSTCARD_ROTATED = 81, /* Japanese Postcard Rotated 148 x 100 mm */
        DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82, /* Double Japanese Postcard Rotated 148 x 200 mm */
        DMPAPER_A6_ROTATED =          83,  /* A6 Rotated 148 x 105 mm         */
        DMPAPER_JENV_KAKU2_ROTATED =  84,  /* Japanese Envelope Kaku #2 Rotated */
        DMPAPER_JENV_KAKU3_ROTATED =  85,  /* Japanese Envelope Kaku #3 Rotated */
        DMPAPER_JENV_CHOU3_ROTATED =  86,  /* Japanese Envelope Chou #3 Rotated */
        DMPAPER_JENV_CHOU4_ROTATED =  87,  /* Japanese Envelope Chou #4 Rotated */
        DMPAPER_B6_JIS =              88,  /* B6 (JIS) 128 x 182 mm           */
        DMPAPER_B6_JIS_ROTATED =      89,  /* B6 (JIS) Rotated 182 x 128 mm   */
        DMPAPER_12X11 =               90,  /* 12 x 11 in                      */
        DMPAPER_JENV_YOU4 =           91,  /* Japanese Envelope You #4        */
        DMPAPER_JENV_YOU4_ROTATED =   92,  /* Japanese Envelope You #4 Rotated*/
        DMPAPER_P16K =                93,  /* PRC 16K 146 x 215 mm            */
        DMPAPER_P32K =                94,  /* PRC 32K 97 x 151 mm             */
        DMPAPER_P32KBIG =             95,  /* PRC 32K(Big) 97 x 151 mm        */
        DMPAPER_PENV_1 =              96,  /* PRC Envelope #1 102 x 165 mm    */
        DMPAPER_PENV_2 =              97,  /* PRC Envelope #2 102 x 176 mm    */
        DMPAPER_PENV_3 =              98,  /* PRC Envelope #3 125 x 176 mm    */
        DMPAPER_PENV_4 =              99,  /* PRC Envelope #4 110 x 208 mm    */
        DMPAPER_PENV_5 =              100, /* PRC Envelope #5 110 x 220 mm    */
        DMPAPER_PENV_6 =              101, /* PRC Envelope #6 120 x 230 mm    */
        DMPAPER_PENV_7 =              102, /* PRC Envelope #7 160 x 230 mm    */
        DMPAPER_PENV_8 =              103, /* PRC Envelope #8 120 x 309 mm    */
        DMPAPER_PENV_9 =              104, /* PRC Envelope #9 229 x 324 mm    */
        DMPAPER_PENV_10 =             105, /* PRC Envelope #10 324 x 458 mm   */
        DMPAPER_P16K_ROTATED =        106, /* PRC 16K Rotated                 */
        DMPAPER_P32K_ROTATED =        107, /* PRC 32K Rotated                 */
        DMPAPER_P32KBIG_ROTATED =     108, /* PRC 32K(Big) Rotated            */
        DMPAPER_PENV_1_ROTATED =      109, /* PRC Envelope #1 Rotated 165 x 102 mm */
        DMPAPER_PENV_2_ROTATED =      110, /* PRC Envelope #2 Rotated 176 x 102 mm */
        DMPAPER_PENV_3_ROTATED =      111, /* PRC Envelope #3 Rotated 176 x 125 mm */
        DMPAPER_PENV_4_ROTATED =      112, /* PRC Envelope #4 Rotated 208 x 110 mm */
        DMPAPER_PENV_5_ROTATED =      113, /* PRC Envelope #5 Rotated 220 x 110 mm */
        DMPAPER_PENV_6_ROTATED =      114, /* PRC Envelope #6 Rotated 230 x 120 mm */
        DMPAPER_PENV_7_ROTATED =      115, /* PRC Envelope #7 Rotated 230 x 160 mm */
        DMPAPER_PENV_8_ROTATED =      116, /* PRC Envelope #8 Rotated 309 x 120 mm */
        DMPAPER_PENV_9_ROTATED =      117, /* PRC Envelope #9 Rotated 324 x 229 mm */
        DMPAPER_PENV_10_ROTATED =     118, /* PRC Envelope #10 Rotated 458 x 324 mm */

        DMPAPER_LAST = DMPAPER_PENV_10_ROTATED,
        DMPAPER_USER = 256,

        DMBIN_UPPER = 1,
        DMBIN_ONLYONE = 1,
        DMBIN_LOWER = 2,
        DMBIN_MIDDLE = 3,
        DMBIN_MANUAL = 4,
        DMBIN_ENVELOPE = 5,
        DMBIN_ENVMANUAL = 6,
        DMBIN_AUTO = 7,
        DMBIN_TRACTOR = 8,
        DMBIN_SMALLFMT = 9,
        DMBIN_LARGEFMT = 10,
        DMBIN_LARGECAPACITY = 11,
        DMBIN_CASSETTE = 14,
        DMBIN_FORMSOURCE = 15,
        DMBIN_LAST = 15,
        DMBIN_USER = 256,
        DMRES_DRAFT = -1,
        DMRES_LOW = -2,
        DMRES_MEDIUM = -3,
        DMRES_HIGH = -4,
        DMCOLOR_MONOCHROME = 1,
        DMCOLOR_COLOR = 2,
        DMDUP_SIMPLEX = 1,
        DMDUP_VERTICAL = 2,
        DMDUP_HORIZONTAL = 3,
        DMTT_BITMAP = 1,
        DMTT_DOWNLOAD = 2,
        DMTT_SUBDEV = 3,
        DMTT_DOWNLOAD_OUTLINE = 4,
        DMCOLLATE_FALSE = 0,
        DMCOLLATE_TRUE = 1,
        DMDISPLAYFLAGS_TEXTMODE = 0x00000004,
        DMICMMETHOD_NONE = 1,
        DMICMMETHOD_SYSTEM = 2,
        DMICMMETHOD_DRIVER = 3,
        DMICMMETHOD_DEVICE = 4,
        DMICMMETHOD_USER = 256,
        DMICM_SATURATE = 1,
        DMICM_CONTRAST = 2,
        DMICM_COLORMETRIC = 3,
        DMICM_USER = 256,
        DMMEDIA_STANDARD = 1,
        DMMEDIA_TRANSPARENCY = 2,
        DMMEDIA_GLOSSY = 3,
        DMMEDIA_USER = 256,
        DMDITHER_NONE = 1,
        DMDITHER_COARSE = 2,
        DMDITHER_FINE = 3,
        DMDITHER_LINEART = 4,
        DMDITHER_GRAYSCALE = 5,
        DMDITHER_USER = 256,
        DC_BINADJUST = 19,
        DC_EMF_COMPLIANT = 20,
        DC_DATATYPE_PRODUCED = 21,
        DC_COLLATE = 22,
        DCTT_BITMAP = 0x0000001,
        DCTT_DOWNLOAD = 0x0000002,
        DCTT_SUBDEV = 0x0000004,
        DCTT_DOWNLOAD_OUTLINE = 0x0000008,
        DCBA_FACEUPNONE = 0x0000,
        DCBA_FACEUPCENTER = 0x0001,
        DCBA_FACEUPLEFT = 0x0002,
        DCBA_FACEUPRIGHT = 0x0003,
        DCBA_FACEDOWNNONE = 0x0100,
        DCBA_FACEDOWNCENTER = 0x0101,
        DCBA_FACEDOWNLEFT = 0x0102,
        DCBA_FACEDOWNRIGHT = 0x0103,
        DI_APPBANDING = 0x0001,
        DISC_UPDATE_PROFILE = 0x00000001,
        DISC_NO_FORCE = 0x00000040,
        DATE_SHORTDATE = 0x00000001,
        DATE_LONGDATE = 0x00000002,
        DATE_USE_ALT_CALENDAR = 0x00000004,
        DUPLICATE_CLOSE_SOURCE = 0x00000001,
        DUPLICATE_SAME_ACCESS = 0x00000002,
        DELETE = (0x00010000),
                 DOMAIN_USER_RID_ADMIN = (0x000001F4),
                                         DOMAIN_USER_RID_GUEST = (0x000001F5),
                                                                 DOMAIN_GROUP_RID_ADMINS = (0x00000200),
                                                                                           DOMAIN_GROUP_RID_USERS = (0x00000201),
                                                                                                                    DOMAIN_GROUP_RID_GUESTS = (0x00000202),
                                                                                                                                              DOMAIN_ALIAS_RID_ADMINS = (0x00000220),
                                                                                                                                                                        DOMAIN_ALIAS_RID_USERS = (0x00000221),
                                                                                                                                                                                                 DOMAIN_ALIAS_RID_GUESTS = (0x00000222),
                                                                                                                                                                                                                           DOMAIN_ALIAS_RID_POWER_USERS = (0x00000223),
                                                                                                                                                                                                                                                          DOMAIN_ALIAS_RID_ACCOUNT_OPS = (0x00000224),
                                                                                                                                                                                                                                                                                         DOMAIN_ALIAS_RID_SYSTEM_OPS = (0x00000225),
                                                                                                                                                                                                                                                                                                                       DOMAIN_ALIAS_RID_PRINT_OPS = (0x00000226),
                                                                                                                                                                                                                                                                                                                                                    DOMAIN_ALIAS_RID_BACKUP_OPS = (0x00000227),
                                                                                                                                                                                                                                                                                                                                                                                  DOMAIN_ALIAS_RID_REPLICATOR = (0x00000228),
                                                                                                                                                                                                                                                                                                                                                                                                                DACL_SECURITY_INFORMATION = (0X00000004),
                                                                                                                                                                                                                                                                                                                                                                                                                                            DLL_PROCESS_ATTACH = 1,
        DLL_THREAD_ATTACH = 2,
        DLL_THREAD_DETACH = 3,
        DLL_PROCESS_DETACH = 0,
        DBG_CONTINUE = (0x00010002),
                       DBG_TERMINATE_THREAD = (0x40010003),
                                              DBG_TERMINATE_PROCESS = (0x40010004),
                                                                      DBG_CONTROL_C = (0x40010005),
                                                                                      DBG_CONTROL_BREAK = (0x40010008),
                                                                                                          DBG_EXCEPTION_NOT_HANDLED = (unchecked((int)0x80010001)),
                                                                                                                                      DEF_PRIORITY = 1,
        DI_CHANNEL = 1,
        DI_READ_SPOOL_JOB = 3,
        DIFFERENCE = 11,
        DESKTOP_READOBJECTS = 0x0001,
        DESKTOP_CREATEWINDOW = 0x0002,
        DESKTOP_CREATEMENU = 0x0004,
        DESKTOP_HOOKCONTROL = 0x0008,
        DESKTOP_JOURNALRECORD = 0x0010,
        DESKTOP_JOURNALPLAYBACK = 0x0020,
        DESKTOP_ENUMERATE = 0x0040,
        DESKTOP_WRITEOBJECTS = 0x0080,
        DESKTOP_SWITCHDESKTOP = 0x0100,
        DF_ALLOWOTHERACCOUNTHOOK = 0x0001,
        DFC_CAPTION = 1,
        DFC_MENU = 2,
        DFC_SCROLL = 3,
        DFC_BUTTON = 4,
        DFCS_CAPTIONCLOSE = 0x0000,
        DFCS_CAPTIONMIN = 0x0001,
        DFCS_CAPTIONMAX = 0x0002,
        DFCS_CAPTIONRESTORE = 0x0003,
        DFCS_CAPTIONHELP = 0x0004,
        DFCS_MENUARROW = 0x0000,
        DFCS_MENUCHECK = 0x0001,
        DFCS_MENUBULLET = 0x0002,
        DFCS_MENUARROWRIGHT = 0x0004,
        DFCS_SCROLLUP = 0x0000,
        DFCS_SCROLLDOWN = 0x0001,
        DFCS_SCROLLLEFT = 0x0002,
        DFCS_SCROLLRIGHT = 0x0003,
        DFCS_SCROLLCOMBOBOX = 0x0005,
        DFCS_SCROLLSIZEGRIP = 0x0008,
        DFCS_SCROLLSIZEGRIPRIGHT = 0x0010,
        DFCS_BUTTONCHECK = 0x0000,
        DFCS_BUTTONRADIOIMAGE = 0x0001,
        DFCS_BUTTONRADIOMASK = 0x0002,
        DFCS_BUTTONRADIO = 0x0004,
        DFCS_BUTTON3STATE = 0x0008,
        DFCS_BUTTONPUSH = 0x0010,
        DFCS_INACTIVE = 0x0100,
        DFCS_PUSHED = 0x0200,
        DFCS_CHECKED = 0x0400,
        DFCS_ADJUSTRECT = 0x2000,
        DFCS_FLAT = 0x4000,
        DFCS_MONO = unchecked((int)0x8000),
        DC_ACTIVE = 0x0001,
        DC_SMALLCAP = 0x0002,
        DC_ICON = 0x0004,
        DC_TEXT = 0x0008,
        DC_INBUTTON = 0x0010,
        DLGWINDOWEXTRA = 30,
        DOF_EXECUTABLE = unchecked((int)0x8001),
        DOF_DOCUMENT = unchecked((int)0x8002),
        DOF_DIRECTORY = unchecked((int)0x8003),
        DOF_MULTIPLE = unchecked((int)0x8004),
        DOF_PROGMAN = 0x0001,
        DOF_SHELLDATA = 0x0002,
        DO_DROPFILE = 0x454C4946,
        DO_PRINTFILE = 0x544E5250,
        DT_TOP = 0x00000000,
        DT_LEFT = 0x00000000,
        DT_CENTER = 0x00000001,
        DT_RIGHT = 0x00000002,
        DT_VCENTER = 0x00000004,
        DT_BOTTOM = 0x00000008,
        DT_WORDBREAK = 0x00000010,
        DT_SINGLELINE = 0x00000020,
        DT_EXPANDTABS = 0x00000040,
        DT_TABSTOP = 0x00000080,
        DT_NOCLIP = 0x00000100,
        DT_CALCRECT = 0x00000400,
        DT_NOPREFIX = 0x00000800,
        DT_INTERNAL = 0x00001000,
        DT_EDITCONTROL = 0x00002000,
        DT_PATH_ELLIPSIS = 0x00004000,
        DT_END_ELLIPSIS = 0x00008000,
        DT_MODIFYSTRING = 0x00010000,
        DT_RTLREADING = 0x00020000,
        DT_WORD_ELLIPSIS = 0x00040000,
        DST_COMPLEX = 0x0000,
        DST_TEXT = 0x0001,
        DST_PREFIXTEXT = 0x0002,
        DST_ICON = 0x0003,
        DST_BITMAP = 0x0004,
        DSS_NORMAL = 0x0000,
        DSS_UNION = 0x0010,
        DSS_DISABLED = 0x0020,
        DSS_MONO = 0x0080,
        DSS_RIGHT = unchecked((int)0x8000),
        DCX_WINDOW = 0x00000001,
        DCX_CACHE = 0x00000002,
        DCX_NORESETATTRS = 0x00000004,
        DCX_CLIPCHILDREN = 0x00000008,
        DCX_CLIPSIBLINGS = 0x00000010,
        DCX_PARENTCLIP = 0x00000020,
        DCX_EXCLUDERGN = 0x00000040,
        DCX_INTERSECTRGN = 0x00000080,
        DCX_EXCLUDEUPDATE = 0x00000100,
        DCX_INTERSECTUPDATE = 0x00000200,
        DCX_LOCKWINDOWUPDATE = 0x00000400,
        DCX_VALIDATE = 0x00200000,
        DI_MASK = 0x0001,
        DI_IMAGE = 0x0002,
        DI_NORMAL = 0x0003,
        DI_COMPAT = 0x0004,
        DI_DEFAULTSIZE = 0x0008,
        DWL_MSGRESULT = 0,
        DWL_DLGPROC = 4,
        DWL_USER = 8,
        DDL_READWRITE = 0x0000,
        DDL_READONLY = 0x0001,
        DDL_HIDDEN = 0x0002,
        DDL_SYSTEM = 0x0004,
        DDL_DIRECTORY = 0x0010,
        DDL_ARCHIVE = 0x0020,
        DDL_POSTMSGS = 0x2000,
        DDL_DRIVES = 0x4000,
        DDL_EXCLUSIVE = unchecked((int)0x8000),
        DS_ABSALIGN = 0x01,
        DS_SYSMODAL = 0x02,
        DS_LOCALEDIT = 0x20,
        DS_SETFONT = 0x40,
        DS_MODALFRAME = unchecked((int)0x80),
        DS_NOIDLEMSG = 0x100,
        DS_SETFOREGROUND = 0x200,
        DS_3DLOOK = 0x0004,
        DS_FIXEDSYS = 0x0008,
        DS_NOFAILCREATE = 0x0010,
        DS_CONTROL = 0x0400,
        DS_CENTER = 0x0800,
        DS_CENTERMOUSE = 0x1000,
        DS_CONTEXTHELP = 0x2000,
        DM_GETDEFID = (0x0400+0),
                      DM_SETDEFID = (0x0400+1),
                                    DM_REPOSITION = (0x0400+2),
                                                    DC_HASDEFID = 0x534B,
        DLGC_WANTARROWS = 0x0001,
        DLGC_WANTTAB = 0x0002,
        DLGC_WANTALLKEYS = 0x0004,
        DLGC_WANTMESSAGE = 0x0004,
        DLGC_HASSETSEL = 0x0008,
        DLGC_DEFPUSHBUTTON = 0x0010,
        DLGC_UNDEFPUSHBUTTON = 0x0020,
        DLGC_RADIOBUTTON = 0x0040,
        DLGC_WANTCHARS = 0x0080,
        DLGC_STATIC = 0x0100,
        DLGC_BUTTON = 0x2000,
        DISP_CHANGE_SUCCESSFUL = 0,
        DISP_CHANGE_RESTART = 1,
        DISP_CHANGE_FAILED = -1,
        DISP_CHANGE_BADMODE = -2,
        DISP_CHANGE_NOTUPDATED = -3,
        DISP_CHANGE_BADFLAGS = -4,
        DISP_CHANGE_BADPARAM = -5,
        DECIMAL_NEG = (unchecked((int)0x80)),
                      DTN_FIRST = (0-760),
                                  DTN_LAST = (0-799),
                                             DL_BEGINDRAG = (0x0400+133),
                                                            DL_DRAGGING = (0x0400+134),
                                                                          DL_DROPPED = (0x0400+135),
                                                                                       DL_CANCELDRAG = (0x0400+136),
                                                                                                       DL_CURSORSET = 0,
        DL_STOPCURSOR = 1,
        DL_COPYCURSOR = 2,
        DL_MOVECURSOR = 3,
        DTM_FIRST = 0x1000,
        DTM_GETSYSTEMTIME = (0x1000+1),
                            DTM_SETSYSTEMTIME = (0x1000+2),
                                                DTM_GETRANGE = (0x1000+3),
                                                               DTM_SETRANGE = (0x1000+4),
                                                                              DTM_SETFORMATA = (0x1000+5),
                                                                                               DTM_SETFORMATW = (0x1000+50),
                                                                                                                DTM_SETMCCOLOR = (0x1000+6),
                                                                                                                                 DTM_GETMCCOLOR = (0x1000+7),
                                                                                                                                                  DTM_GETMONTHCAL = (0x1000+8),
                                                                                                                                                                    DTM_SETMCFONT = (0x1000+9),
                                                                                                                                                                                    DTM_GETMCFONT = (0x1000+10),
                                                                                                                                                                                                    DTS_UPDOWN = 0x0001,
        DTS_SHOWNONE = 0x0002,
        DTS_SHORTDATEFORMAT = 0x0000,
        DTS_LONGDATEFORMAT = 0x0004,
        DTS_TIMEFORMAT = 0x0009,
        DTS_APPCANPARSE = 0x0010,
        DTS_RIGHTALIGN = 0x0020,
        DTN_DATETIMECHANGE = ((0-760)+1),
                             DTN_USERSTRINGA = ((0-760)+2),
                                               DTN_USERSTRINGW = ((0-760)+15),
                                                                 DTN_WMKEYDOWNA = ((0-760)+3),
                                                                                  DTN_WMKEYDOWNW = ((0-760)+16),
                                                                                                   DTN_FORMATA = ((0-760)+4),
                                                                                                                 DTN_FORMATW = ((0-760)+17),
                                                                                                                               DTN_FORMATQUERYA = ((0-760)+5),
                                                                                                                                                  DTN_FORMATQUERYW = ((0-760)+18),
                                                                                                                                                                     DTN_DROPDOWN = ((0-760)+6),
                                                                                                                                                                                    DTN_CLOSEUP = ((0-760)+7),
                                                                                                                                                                                                  DATA_E_FORMATETC = unchecked((int)0x80040064),
        DMPAPER_FIRST = 1,
        DMBIN_FIRST = 1,
        DSTINVERT = 0x00550009;

        public const int DVASPECT_CONTENT   = 1;
        public const int DVASPECT_THUMBNAIL = 2;
        public const int DVASPECT_ICON      = 4;
        public const int DVASPECT_DOCPRINT  = 8;
        public const int DVASPECT_OPAQUE    = 16;
        public const int DVASPECT_TRANSPARENT = 32;

        public const int DATADIR_GET = 1,
        DATADIR_SET = 2;



        public const int EC_ENABLEALL = 0,
        EC_ENABLEONE = 0x0080,
        EC_DISABLE = 0x0008,
        EC_QUERYWAITING = 2,
        edt1 = 0x0480,
        edt2 = 0x0481,
        edt3 = 0x0482,
        edt4 = 0x0483,
        edt5 = 0x0484,
        edt6 = 0x0485,
        edt7 = 0x0486,
        edt8 = 0x0487,
        edt9 = 0x0488,
        edt10 = 0x0489,
        edt11 = 0x048a,
        edt12 = 0x048b,
        edt13 = 0x048c,
        edt14 = 0x048d,
        edt15 = 0x048e,
        edt16 = 0x048f,
        EXCEPTION_EXECUTE_HANDLER = 1,
        EXCEPTION_CONTINUE_SEARCH = 0,
        EXCEPTION_CONTINUE_EXECUTION = -1,
        EMBDHLP_INPROC_HANDLER = 0x0000,
        EMBDHLP_INPROC_SERVER = 0x0001,
        EMBDHLP_CREATENOW = 0x00000000,
        EMBDHLP_DELAYCREATE = 0x00010000,
        EXCEPTION_DEBUG_EVENT = 1,
        EXIT_THREAD_DEBUG_EVENT = 4,
        EXIT_PROCESS_DEBUG_EVENT = 5,
        EVENPARITY = 2,
        EV_RXCHAR = 0x0001,
        EV_RXFLAG = 0x0002,
        EV_TXEMPTY = 0x0004,
        EV_CTS = 0x0008,
        EV_DSR = 0x0010,
        EV_RLSD = 0x0020,
        EV_BREAK = 0x0040,
        EV_ERR = 0x0080,
        EV_RING = 0x0100,
        EV_PERR = 0x0200,
        EV_RX80FULL = 0x0400,
        EV_EVENT1 = 0x0800,
        EV_EVENT2 = 0x1000,
        ENHANCED_KEY = 0x0100,
        ENABLE_PROCESSED_INPUT = 0x0001,
        ENABLE_LINE_INPUT = 0x0002,
        ENABLE_ECHO_INPUT = 0x0004,
        ENABLE_WINDOW_INPUT = 0x0008,
        ENABLE_MOUSE_INPUT = 0x0010,
        ENABLE_PROCESSED_OUTPUT = 0x0001,
        ENABLE_WRAP_AT_EOL_OUTPUT = 0x0002,
        ERROR_SUCCESS = 0,
        ERROR_INVALID_FUNCTION = 1,
        ERROR_FILE_NOT_FOUND = 2,
        ERROR_PATH_NOT_FOUND = 3,
        ERROR_TOO_MANY_OPEN_FILES = 4,
        ERROR_ACCESS_DENIED = 5,
        ERROR_INVALID_HANDLE = 6,
        ERROR_ARENA_TRASHED = 7,
        ERROR_NOT_ENOUGH_MEMORY = 8,
        ERROR_INVALID_BLOCK = 9,
        ERROR_BAD_ENVIRONMENT = 10,
        ERROR_BAD_FORMAT = 11,
        ERROR_INVALID_ACCESS = 12,
        ERROR_INVALID_DATA = 13,
        ERROR_OUTOFMEMORY = 14,
        ERROR_INVALID_DRIVE = 15,
        ERROR_CURRENT_DIRECTORY = 16,
        ERROR_NOT_SAME_DEVICE = 17,
        ERROR_NO_MORE_FILES = 18,
        ERROR_WRITE_PROTECT = 19,
        ERROR_BAD_UNIT = 20,
        ERROR_NOT_READY = 21,
        ERROR_BAD_COMMAND = 22,
        ERROR_CRC = 23,
        ERROR_BAD_LENGTH = 24,
        ERROR_SEEK = 25,
        ERROR_NOT_DOS_DISK = 26,
        ERROR_SECTOR_NOT_FOUND = 27,
        ERROR_OUT_OF_PAPER = 28,
        ERROR_WRITE_FAULT = 29,
        ERROR_READ_FAULT = 30,
        ERROR_GEN_FAILURE = 31,
        ERROR_SHARING_VIOLATION = 32,
        ERROR_LOCK_VIOLATION = 33,
        ERROR_WRONG_DISK = 34,
        ERROR_SHARING_BUFFER_EXCEEDED = 36,
        ERROR_HANDLE_EOF = 38,
        ERROR_HANDLE_DISK_FULL = 39,
        ERROR_NOT_SUPPORTED = 50,
        ERROR_REM_NOT_LIST = 51,
        ERROR_DUP_NAME = 52,
        ERROR_BAD_NETPATH = 53,
        ERROR_NETWORK_BUSY = 54,
        ERROR_DEV_NOT_EXIST = 55,
        ERROR_TOO_MANY_CMDS = 56,
        ERROR_ADAP_HDW_ERR = 57,
        ERROR_BAD_NET_RESP = 58,
        ERROR_UNEXP_NET_ERR = 59,
        ERROR_BAD_REM_ADAP = 60,
        ERROR_PRINTQ_FULL = 61,
        ERROR_NO_SPOOL_SPACE = 62,
        ERROR_PRINT_CANCELLED = 63,
        ERROR_NETNAME_DELETED = 64,
        ERROR_NETWORK_ACCESS_DENIED = 65,
        ERROR_BAD_DEV_TYPE = 66,
        ERROR_BAD_NET_NAME = 67,
        ERROR_TOO_MANY_NAMES = 68,
        ERROR_TOO_MANY_SESS = 69,
        ERROR_SHARING_PAUSED = 70,
        ERROR_REQ_NOT_ACCEP = 71,
        ERROR_REDIR_PAUSED = 72,
        ERROR_FILE_EXISTS = 80,
        ERROR_CANNOT_MAKE = 82,
        ERROR_FAIL_I24 = 83,
        ERROR_OUT_OF_STRUCTURES = 84,
        ERROR_ALREADY_ASSIGNED = 85,
        ERROR_INVALID_PASSWORD = 86,
        ERROR_INVALID_PARAMETER = 87,
        ERROR_NET_WRITE_FAULT = 88,
        ERROR_NO_PROC_SLOTS = 89,
        ERROR_TOO_MANY_SEMAPHORES = 100,
        ERROR_EXCL_SEM_ALREADY_OWNED = 101,
        ERROR_SEM_IS_SET = 102,
        ERROR_TOO_MANY_SEM_REQUESTS = 103,
        ERROR_INVALID_AT_INTERRUPT_TIME = 104,
        ERROR_SEM_OWNER_DIED = 105,
        ERROR_SEM_USER_LIMIT = 106,
        ERROR_DISK_CHANGE = 107,
        ERROR_DRIVE_LOCKED = 108,
        ERROR_BROKEN_PIPE = 109,
        ERROR_OPEN_FAILED = 110,
        ERROR_BUFFER_OVERFLOW = 111,
        ERROR_DISK_FULL = 112,
        ERROR_NO_MORE_SEARCH_HANDLES = 113,
        ERROR_INVALID_TARGET_HANDLE = 114,
        ERROR_INVALID_CATEGORY = 117,
        ERROR_INVALID_VERIFY_SWITCH = 118,
        ERROR_BAD_DRIVER_LEVEL = 119,
        ERROR_CALL_NOT_IMPLEMENTED = 120,
        ERROR_SEM_TIMEOUT = 121,
        ERROR_INSUFFICIENT_BUFFER = 122,
        ERROR_INVALID_NAME = 123,
        ERROR_INVALID_LEVEL = 124,
        ERROR_NO_VOLUME_LABEL = 125,
        ERROR_MOD_NOT_FOUND = 126,
        ERROR_PROC_NOT_FOUND = 127,
        ERROR_WAIT_NO_CHILDREN = 128,
        ERROR_CHILD_NOT_COMPLETE = 129,
        ERROR_DIRECT_ACCESS_HANDLE = 130,
        ERROR_NEGATIVE_SEEK = 131,
        ERROR_SEEK_ON_DEVICE = 132,
        ERROR_IS_JOIN_TARGET = 133,
        ERROR_IS_JOINED = 134,
        ERROR_IS_SUBSTED = 135,
        ERROR_NOT_JOINED = 136,
        ERROR_NOT_SUBSTED = 137,
        ERROR_JOIN_TO_JOIN = 138,
        ERROR_SUBST_TO_SUBST = 139,
        ERROR_JOIN_TO_SUBST = 140,
        ERROR_SUBST_TO_JOIN = 141,
        ERROR_BUSY_DRIVE = 142,
        ERROR_SAME_DRIVE = 143,
        ERROR_DIR_NOT_ROOT = 144,
        ERROR_DIR_NOT_EMPTY = 145,
        ERROR_IS_SUBST_PATH = 146,
        ERROR_IS_JOIN_PATH = 147,
        ERROR_PATH_BUSY = 148,
        ERROR_IS_SUBST_TARGET = 149,
        ERROR_SYSTEM_TRACE = 150,
        ERROR_INVALID_EVENT_COUNT = 151,
        ERROR_TOO_MANY_MUXWAITERS = 152,
        ERROR_INVALID_LIST_FORMAT = 153,
        ERROR_LABEL_TOO_LONG = 154,
        ERROR_TOO_MANY_TCBS = 155,
        ERROR_SIGNAL_REFUSED = 156,
        ERROR_DISCARDED = 157,
        ERROR_NOT_LOCKED = 158,
        ERROR_BAD_THREADID_ADDR = 159,
        ERROR_BAD_ARGUMENTS = 160,
        ERROR_BAD_PATHNAME = 161,
        ERROR_SIGNAL_PENDING = 162,
        ERROR_MAX_THRDS_REACHED = 164,
        ERROR_LOCK_FAILED = 167,
        ERROR_BUSY = 170,
        ERROR_CANCEL_VIOLATION = 173,
        ERROR_ATOMIC_LOCKS_NOT_SUPPORTED = 174,
        ERROR_INVALID_SEGMENT_NUMBER = 180,
        ERROR_INVALID_ORDINAL = 182,
        ERROR_ALREADY_EXISTS = 183,
        ERROR_INVALID_FLAG_NUMBER = 186,
        ERROR_SEM_NOT_FOUND = 187,
        ERROR_INVALID_STARTING_CODESEG = 188,
        ERROR_INVALID_STACKSEG = 189,
        ERROR_INVALID_MODULETYPE = 190,
        ERROR_INVALID_EXE_SIGNATURE = 191,
        ERROR_EXE_MARKED_INVALID = 192,
        ERROR_BAD_EXE_FORMAT = 193,
        ERROR_ITERATED_DATA_EXCEEDS_64k = 194,
        ERROR_INVALID_MINALLOCSIZE = 195,
        ERROR_DYNLINK_FROM_INVALID_RING = 196,
        ERROR_IOPL_NOT_ENABLED = 197,
        ERROR_INVALID_SEGDPL = 198,
        ERROR_AUTODATASEG_EXCEEDS_64k = 199,
        ERROR_RING2SEG_MUST_BE_MOVABLE = 200,
        ERROR_RELOC_CHAIN_XEEDS_SEGLIM = 201,
        ERROR_INFLOOP_IN_RELOC_CHAIN = 202,
        ERROR_ENVVAR_NOT_FOUND = 203,
        ERROR_NO_SIGNAL_SENT = 205,
        ERROR_FILENAME_EXCED_RANGE = 206,
        ERROR_RING2_STACK_IN_USE = 207,
        ERROR_META_EXPANSION_TOO_LONG = 208,
        ERROR_INVALID_SIGNAL_NUMBER = 209,
        ERROR_THREAD_1_INACTIVE = 210,
        ERROR_LOCKED = 212,
        ERROR_TOO_MANY_MODULES = 214,
        ERROR_NESTING_NOT_ALLOWED = 215,
        ERROR_EXE_MACHINE_TYPE_MISMATCH = 216,
        ERROR_BAD_PIPE = 230,
        ERROR_PIPE_BUSY = 231,
        ERROR_NO_DATA = 232,
        ERROR_PIPE_NOT_CONNECTED = 233,
        ERROR_MORE_DATA = 234,
        ERROR_VC_DISCONNECTED = 240,
        ERROR_INVALID_EA_NAME = 254,
        ERROR_EA_LIST_INCONSISTENT = 255,
        ERROR_NO_MORE_ITEMS = 259,
        ERROR_CANNOT_COPY = 266,
        ERROR_DIRECTORY = 267,
        ERROR_EAS_DIDNT_FIT = 275,
        ERROR_EA_FILE_CORRUPT = 276,
        ERROR_EA_TABLE_FULL = 277,
        ERROR_INVALID_EA_HANDLE = 278,
        ERROR_EAS_NOT_SUPPORTED = 282,
        ERROR_NOT_OWNER = 288,
        ERROR_TOO_MANY_POSTS = 298,
        ERROR_PARTIAL_COPY = 299,
        ERROR_MR_MID_NOT_FOUND = 317,
        ERROR_INVALID_ADDRESS = 487,
        ERROR_ARITHMETIC_OVERFLOW = 534,
        ERROR_PIPE_CONNECTED = 535,
        ERROR_PIPE_LISTENING = 536,
        ERROR_EA_ACCESS_DENIED = 994,
        ERROR_OPERATION_ABORTED = 995,
        ERROR_IO_INCOMPLETE = 996,
        ERROR_IO_PENDING = 997,
        ERROR_NOACCESS = 998,
        ERROR_SWAPERROR = 999,
        ERROR_STACK_OVERFLOW = 1001,
        ERROR_INVALID_MESSAGE = 1002,
        ERROR_CAN_NOT_COMPLETE = 1003,
        ERROR_INVALID_FLAGS = 1004,
        ERROR_UNRECOGNIZED_VOLUME = 1005,
        ERROR_FILE_INVALID = 1006,
        ERROR_FULLSCREEN_MODE = 1007,
        ERROR_NO_TOKEN = 1008,
        ERROR_BADDB = 1009,
        ERROR_BADKEY = 1010,
        ERROR_CANTOPEN = 1011,
        ERROR_CANTREAD = 1012,
        ERROR_CANTWRITE = 1013,
        ERROR_REGISTRY_RECOVERED = 1014,
        ERROR_REGISTRY_CORRUPT = 1015,
        ERROR_REGISTRY_IO_FAILED = 1016,
        ERROR_NOT_REGISTRY_FILE = 1017,
        ERROR_KEY_DELETED = 1018,
        ERROR_NO_LOG_SPACE = 1019,
        ERROR_KEY_HAS_CHILDREN = 1020,
        ERROR_CHILD_MUST_BE_VOLATILE = 1021,
        ERROR_NOTIFY_ENUM_DIR = 1022,
        ERROR_DEPENDENT_SERVICES_RUNNING = 1051,
        ERROR_INVALID_SERVICE_CONTROL = 1052,
        ERROR_SERVICE_REQUEST_TIMEOUT = 1053,
        ERROR_SERVICE_NO_THREAD = 1054,
        ERROR_SERVICE_DATABASE_LOCKED = 1055,
        ERROR_SERVICE_ALREADY_RUNNING = 1056,
        ERROR_INVALID_SERVICE_ACCOUNT = 1057,
        ERROR_SERVICE_DISABLED = 1058,
        ERROR_CIRCULAR_DEPENDENCY = 1059,
        ERROR_SERVICE_DOES_NOT_EXIST = 1060,
        ERROR_SERVICE_CANNOT_ACCEPT_CTRL = 1061,
        ERROR_SERVICE_NOT_ACTIVE = 1062,
        ERROR_FAILED_SERVICE_CONTROLLER_CONNECT = 1063,
        ERROR_EXCEPTION_IN_SERVICE = 1064,
        ERROR_DATABASE_DOES_NOT_EXIST = 1065,
        ERROR_SERVICE_SPECIFIC_ERROR = 1066,
        ERROR_PROCESS_ABORTED = 1067,
        ERROR_SERVICE_DEPENDENCY_FAIL = 1068,
        ERROR_SERVICE_LOGON_FAILED = 1069,
        ERROR_SERVICE_START_HANG = 1070,
        ERROR_INVALID_SERVICE_LOCK = 1071,
        ERROR_SERVICE_MARKED_FOR_DELETE = 1072,
        ERROR_SERVICE_EXISTS = 1073,
        ERROR_ALREADY_RUNNING_LKG = 1074,
        ERROR_SERVICE_DEPENDENCY_DELETED = 1075,
        ERROR_BOOT_ALREADY_ACCEPTED = 1076,
        ERROR_SERVICE_NEVER_STARTED = 1077,
        ERROR_DUPLICATE_SERVICE_NAME = 1078,
        ERROR_DIFFERENT_SERVICE_ACCOUNT = 1079,
        ERROR_END_OF_MEDIA = 1100,
        ERROR_FILEMARK_DETECTED = 1101,
        ERROR_BEGINNING_OF_MEDIA = 1102,
        ERROR_SETMARK_DETECTED = 1103,
        ERROR_NO_DATA_DETECTED = 1104,
        ERROR_PARTITION_FAILURE = 1105,
        ERROR_INVALID_BLOCK_LENGTH = 1106,
        ERROR_DEVICE_NOT_PARTITIONED = 1107,
        ERROR_UNABLE_TO_LOCK_MEDIA = 1108,
        ERROR_UNABLE_TO_UNLOAD_MEDIA = 1109,
        ERROR_MEDIA_CHANGED = 1110,
        ERROR_BUS_RESET = 1111,
        ERROR_NO_MEDIA_IN_DRIVE = 1112,
        ERROR_NO_UNICODE_TRANSLATION = 1113,
        ERROR_DLL_INIT_FAILED = 1114,
        ERROR_SHUTDOWN_IN_PROGRESS = 1115,
        ERROR_NO_SHUTDOWN_IN_PROGRESS = 1116,
        ERROR_IO_DEVICE = 1117,
        ERROR_SERIAL_NO_DEVICE = 1118,
        ERROR_IRQ_BUSY = 1119,
        ERROR_MORE_WRITES = 1120,
        ERROR_COUNTER_TIMEOUT = 1121,
        ERROR_FLOPPY_ID_MARK_NOT_FOUND = 1122,
        ERROR_FLOPPY_WRONG_CYLINDER = 1123,
        ERROR_FLOPPY_UNKNOWN_ERROR = 1124,
        ERROR_FLOPPY_BAD_REGISTERS = 1125,
        ERROR_DISK_RECALIBRATE_FAILED = 1126,
        ERROR_DISK_OPERATION_FAILED = 1127,
        ERROR_DISK_RESET_FAILED = 1128,
        ERROR_EOM_OVERFLOW = 1129,
        ERROR_NOT_ENOUGH_SERVER_MEMORY = 1130,
        ERROR_POSSIBLE_DEADLOCK = 1131,
        ERROR_MAPPED_ALIGNMENT = 1132,
        ERROR_SET_POWER_STATE_VETOED = 1140,
        ERROR_SET_POWER_STATE_FAILED = 1141,
        ERROR_TOO_MANY_LINKS = 1142,
        ERROR_OLD_WIN_VERSION = 1150,
        ERROR_APP_WRONG_OS = 1151,
        ERROR_SINGLE_INSTANCE_APP = 1152,
        ERROR_RMODE_APP = 1153,
        ERROR_INVALID_DLL = 1154,
        ERROR_NO_ASSOCIATION = 1155,
        ERROR_DDE_FAIL = 1156,
        ERROR_DLL_NOT_FOUND = 1157,
        ERROR_BAD_USERNAME = 2202,
        ERROR_NOT_CONNECTED = 2250,
        ERROR_OPEN_FILES = 2401,
        ERROR_ACTIVE_CONNECTIONS = 2402,
        ERROR_DEVICE_IN_USE = 2404,
        ERROR_BAD_DEVICE = 1200,
        ERROR_CONNECTION_UNAVAIL = 1201,
        ERROR_DEVICE_ALREADY_REMEMBERED = 1202,
        ERROR_NO_NET_OR_BAD_PATH = 1203,
        ERROR_BAD_PROVIDER = 1204,
        ERROR_CANNOT_OPEN_PROFILE = 1205,
        ERROR_BAD_PROFILE = 1206,
        ERROR_NOT_CONTAINER = 1207,
        ERROR_EXTENDED_ERROR = 1208,
        ERROR_INVALID_GROUPNAME = 1209,
        ERROR_INVALID_COMPUTERNAME = 1210,
        ERROR_INVALID_EVENTNAME = 1211,
        ERROR_INVALID_DOMAINNAME = 1212,
        ERROR_INVALID_SERVICENAME = 1213,
        ERROR_INVALID_NETNAME = 1214,
        ERROR_INVALID_SHARENAME = 1215,
        ERROR_INVALID_PASSWORDNAME = 1216,
        ERROR_INVALID_MESSAGENAME = 1217,
        ERROR_INVALID_MESSAGEDEST = 1218,
        ERROR_SESSION_CREDENTIAL_CONFLICT = 1219,
        ERROR_REMOTE_SESSION_LIMIT_EXCEEDED = 1220,
        ERROR_DUP_DOMAINNAME = 1221,
        ERROR_NO_NETWORK = 1222,
        ERROR_CANCELLED = 1223,
        ERROR_USER_MAPPED_FILE = 1224,
        ERROR_CONNECTION_REFUSED = 1225,
        ERROR_GRACEFUL_DISCONNECT = 1226,
        ERROR_ADDRESS_ALREADY_ASSOCIATED = 1227,
        ERROR_ADDRESS_NOT_ASSOCIATED = 1228,
        ERROR_CONNECTION_INVALID = 1229,
        ERROR_CONNECTION_ACTIVE = 1230,
        ERROR_NETWORK_UNREACHABLE = 1231,
        ERROR_HOST_UNREACHABLE = 1232,
        ERROR_PROTOCOL_UNREACHABLE = 1233,
        ERROR_PORT_UNREACHABLE = 1234,
        ERROR_REQUEST_ABORTED = 1235,
        ERROR_CONNECTION_ABORTED = 1236,
        ERROR_RETRY = 1237,
        ERROR_CONNECTION_COUNT_LIMIT = 1238,
        ERROR_LOGIN_TIME_RESTRICTION = 1239,
        ERROR_LOGIN_WKSTA_RESTRICTION = 1240,
        ERROR_INCORRECT_ADDRESS = 1241,
        ERROR_ALREADY_REGISTERED = 1242,
        ERROR_SERVICE_NOT_FOUND = 1243,
        ERROR_NOT_AUTHENTICATED = 1244,
        ERROR_NOT_LOGGED_ON = 1245,
        ERROR_CONTINUE = 1246,
        ERROR_ALREADY_INITIALIZED = 1247,
        ERROR_NO_MORE_DEVICES = 1248,
        ERROR_NOT_ALL_ASSIGNED = 1300,
        ERROR_SOME_NOT_MAPPED = 1301,
        ERROR_NO_QUOTAS_FOR_ACCOUNT = 1302,
        ERROR_LOCAL_USER_SESSION_KEY = 1303,
        ERROR_NULL_LM_PASSWORD = 1304,
        ERROR_UNKNOWN_REVISION = 1305,
        ERROR_REVISION_MISMATCH = 1306,
        ERROR_INVALID_OWNER = 1307,
        ERROR_INVALID_PRIMARY_GROUP = 1308,
        ERROR_NO_IMPERSONATION_TOKEN = 1309,
        ERROR_CANT_DISABLE_MANDATORY = 1310,
        ERROR_NO_LOGON_SERVERS = 1311,
        ERROR_NO_SUCH_LOGON_SESSION = 1312,
        ERROR_NO_SUCH_PRIVILEGE = 1313,
        ERROR_PRIVILEGE_NOT_HELD = 1314,
        ERROR_INVALID_ACCOUNT_NAME = 1315,
        ERROR_USER_EXISTS = 1316,
        ERROR_NO_SUCH_USER = 1317,
        ERROR_GROUP_EXISTS = 1318,
        ERROR_NO_SUCH_GROUP = 1319,
        ERROR_MEMBER_IN_GROUP = 1320,
        ERROR_MEMBER_NOT_IN_GROUP = 1321,
        ERROR_LAST_ADMIN = 1322,
        ERROR_WRONG_PASSWORD = 1323,
        ERROR_ILL_FORMED_PASSWORD = 1324,
        ERROR_PASSWORD_RESTRICTION = 1325,
        ERROR_LOGON_FAILURE = 1326,
        ERROR_ACCOUNT_RESTRICTION = 1327,
        ERROR_INVALID_LOGON_HOURS = 1328,
        ERROR_INVALID_WORKSTATION = 1329,
        ERROR_PASSWORD_EXPIRED = 1330,
        ERROR_ACCOUNT_DISABLED = 1331,
        ERROR_NONE_MAPPED = 1332,
        ERROR_TOO_MANY_LUIDS_REQUESTED = 1333,
        ERROR_LUIDS_EXHAUSTED = 1334,
        ERROR_INVALID_SUB_AUTHORITY = 1335,
        ERROR_INVALID_ACL = 1336,
        ERROR_INVALID_SID = 1337,
        ERROR_INVALID_SECURITY_DESCR = 1338,
        ERROR_BAD_INHERITANCE_ACL = 1340,
        ERROR_SERVER_DISABLED = 1341,
        ERROR_SERVER_NOT_DISABLED = 1342,
        ERROR_INVALID_ID_AUTHORITY = 1343,
        ERROR_ALLOTTED_SPACE_EXCEEDED = 1344,
        ERROR_INVALID_GROUP_ATTRIBUTES = 1345,
        ERROR_BAD_IMPERSONATION_LEVEL = 1346,
        ERROR_CANT_OPEN_ANONYMOUS = 1347,
        ERROR_BAD_VALIDATION_CLASS = 1348,
        ERROR_BAD_TOKEN_TYPE = 1349,
        ERROR_NO_SECURITY_ON_OBJECT = 1350,
        ERROR_CANT_ACCESS_DOMAIN_INFO = 1351,
        ERROR_INVALID_SERVER_STATE = 1352,
        ERROR_INVALID_DOMAIN_STATE = 1353,
        ERROR_INVALID_DOMAIN_ROLE = 1354,
        ERROR_NO_SUCH_DOMAIN = 1355,
        ERROR_DOMAIN_EXISTS = 1356,
        ERROR_DOMAIN_LIMIT_EXCEEDED = 1357,
        ERROR_INTERNAL_DB_CORRUPTION = 1358,
        ERROR_INTERNAL_ERROR = 1359,
        ERROR_GENERIC_NOT_MAPPED = 1360,
        ERROR_BAD_DESCRIPTOR_FORMAT = 1361,
        ERROR_NOT_LOGON_PROCESS = 1362,
        ERROR_LOGON_SESSION_EXISTS = 1363,
        ERROR_NO_SUCH_PACKAGE = 1364,
        ERROR_BAD_LOGON_SESSION_STATE = 1365,
        ERROR_LOGON_SESSION_COLLISION = 1366,
        ERROR_INVALID_LOGON_TYPE = 1367,
        ERROR_CANNOT_IMPERSONATE = 1368,
        ERROR_RXACT_INVALID_STATE = 1369,
        ERROR_RXACT_COMMIT_FAILURE = 1370,
        ERROR_SPECIAL_ACCOUNT = 1371,
        ERROR_SPECIAL_GROUP = 1372,
        ERROR_SPECIAL_USER = 1373,
        ERROR_MEMBERS_PRIMARY_GROUP = 1374,
        ERROR_TOKEN_ALREADY_IN_USE = 1375,
        ERROR_NO_SUCH_ALIAS = 1376,
        ERROR_MEMBER_NOT_IN_ALIAS = 1377,
        ERROR_MEMBER_IN_ALIAS = 1378,
        ERROR_ALIAS_EXISTS = 1379,
        ERROR_LOGON_NOT_GRANTED = 1380,
        ERROR_TOO_MANY_SECRETS = 1381,
        ERROR_SECRET_TOO_LONG = 1382,
        ERROR_INTERNAL_DB_ERROR = 1383,
        ERROR_TOO_MANY_CONTEXT_IDS = 1384,
        ERROR_LOGON_TYPE_NOT_GRANTED = 1385,
        ERROR_NT_CROSS_ENCRYPTION_REQUIRED = 1386,
        ERROR_NO_SUCH_MEMBER = 1387,
        ERROR_INVALID_MEMBER = 1388,
        ERROR_TOO_MANY_SIDS = 1389,
        ERROR_LM_CROSS_ENCRYPTION_REQUIRED = 1390,
        ERROR_NO_INHERITANCE = 1391,
        ERROR_FILE_CORRUPT = 1392,
        ERROR_DISK_CORRUPT = 1393,
        ERROR_NO_USER_SESSION_KEY = 1394,
        ERROR_LICENSE_QUOTA_EXCEEDED = 1395,
        ERROR_INVALID_WINDOW_HANDLE = 1400,
        ERROR_INVALID_MENU_HANDLE = 1401,
        ERROR_INVALID_CURSOR_HANDLE = 1402,
        ERROR_INVALID_ACCEL_HANDLE = 1403,
        ERROR_INVALID_HOOK_HANDLE = 1404,
        ERROR_INVALID_DWP_HANDLE = 1405,
        ERROR_TLW_WITH_WSCHILD = 1406,
        ERROR_CANNOT_FIND_WND_CLASS = 1407,
        ERROR_WINDOW_OF_OTHER_THREAD = 1408,
        ERROR_HOTKEY_ALREADY_REGISTERED = 1409,
        ERROR_CLASS_ALREADY_EXISTS = 1410,
        ERROR_CLASS_DOES_NOT_EXIST = 1411,
        ERROR_CLASS_HAS_WINDOWS = 1412,
        ERROR_INVALID_INDEX = 1413,
        ERROR_INVALID_ICON_HANDLE = 1414,
        ERROR_PRIVATE_DIALOG_INDEX = 1415,
        ERROR_LISTBOX_ID_NOT_FOUND = 1416,
        ERROR_NO_WILDCARD_CHARACTERS = 1417,
        ERROR_CLIPBOARD_NOT_OPEN = 1418,
        ERROR_HOTKEY_NOT_REGISTERED = 1419,
        ERROR_WINDOW_NOT_DIALOG = 1420,
        ERROR_CONTROL_ID_NOT_FOUND = 1421,
        ERROR_INVALID_COMBOBOX_MESSAGE = 1422,
        ERROR_WINDOW_NOT_COMBOBOX = 1423,
        ERROR_INVALID_EDIT_HEIGHT = 1424,
        ERROR_DC_NOT_FOUND = 1425,
        ERROR_INVALID_HOOK_FILTER = 1426,
        ERROR_INVALID_FILTER_PROC = 1427,
        ERROR_HOOK_NEEDS_HMOD = 1428,
        ERROR_GLOBAL_ONLY_HOOK = 1429,
        ERROR_JOURNAL_HOOK_SET = 1430,
        ERROR_HOOK_NOT_INSTALLED = 1431,
        ERROR_INVALID_LB_MESSAGE = 1432,
        ERROR_SETCOUNT_ON_BAD_LB = 1433,
        ERROR_LB_WITHOUT_TABSTOPS = 1434,
        ERROR_DESTROY_OBJECT_OF_OTHER_THREAD = 1435,
        ERROR_CHILD_WINDOW_MENU = 1436,
        ERROR_NO_SYSTEM_MENU = 1437,
        ERROR_INVALID_MSGBOX_STYLE = 1438,
        ERROR_INVALID_SPI_VALUE = 1439,
        ERROR_SCREEN_ALREADY_LOCKED = 1440,
        ERROR_HWNDS_HAVE_DIFF_PARENT = 1441,
        ERROR_NOT_CHILD_WINDOW = 1442,
        ERROR_INVALID_GW_COMMAND = 1443,
        ERROR_INVALID_THREAD_ID = 1444,
        ERROR_NON_MDICHILD_WINDOW = 1445,
        ERROR_POPUP_ALREADY_ACTIVE = 1446,
        ERROR_NO_SCROLLBARS = 1447,
        ERROR_INVALID_SCROLLBAR_RANGE = 1448,
        ERROR_INVALID_SHOWWIN_COMMAND = 1449,
        ERROR_NO_SYSTEM_RESOURCES = 1450,
        ERROR_NONPAGED_SYSTEM_RESOURCES = 1451,
        ERROR_PAGED_SYSTEM_RESOURCES = 1452,
        ERROR_WORKING_SET_QUOTA = 1453,
        ERROR_PAGEFILE_QUOTA = 1454,
        ERROR_COMMITMENT_LIMIT = 1455,
        ERROR_MENU_ITEM_NOT_FOUND = 1456,
        ERROR_INVALID_KEYBOARD_HANDLE = 1457,
        ERROR_HOOK_TYPE_NOT_ALLOWED = 1458,
        ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION = 1459,
        ERROR_TIMEOUT = 1460,
        ERROR_EVENTLOG_FILE_CORRUPT = 1500,
        ERROR_EVENTLOG_CANT_START = 1501,
        ERROR_LOG_FILE_FULL = 1502,
        ERROR_EVENTLOG_FILE_CHANGED = 1503,
        EPT_S_INVALID_ENTRY = 1751,
        EPT_S_CANT_PERFORM_OP = 1752,
        EPT_S_NOT_REGISTERED = 1753,
        ERROR_INVALID_USER_BUFFER = 1784,
        ERROR_UNRECOGNIZED_MEDIA = 1785,
        ERROR_NO_TRUST_LSA_SECRET = 1786,
        ERROR_NO_TRUST_SAM_ACCOUNT = 1787,
        ERROR_TRUSTED_DOMAIN_FAILURE = 1788,
        ERROR_TRUSTED_RELATIONSHIP_FAILURE = 1789,
        ERROR_TRUST_FAILURE = 1790,
        ERROR_NETLOGON_NOT_STARTED = 1792,
        ERROR_ACCOUNT_EXPIRED = 1793,
        ERROR_REDIRECTOR_HAS_OPEN_HANDLES = 1794,
        ERROR_PRINTER_DRIVER_ALREADY_INSTALLED = 1795,
        ERROR_UNKNOWN_PORT = 1796,
        ERROR_UNKNOWN_PRINTER_DRIVER = 1797,
        ERROR_UNKNOWN_PRINTPROCESSOR = 1798,
        ERROR_INVALID_SEPARATOR_FILE = 1799,
        ERROR_INVALID_PRIORITY = 1800,
        ERROR_INVALID_PRINTER_NAME = 1801,
        ERROR_PRINTER_ALREADY_EXISTS = 1802,
        ERROR_INVALID_PRINTER_COMMAND = 1803,
        ERROR_INVALID_DATATYPE = 1804,
        ERROR_INVALID_ENVIRONMENT = 1805,
        ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = 1807,
        ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT = 1808,
        ERROR_NOLOGON_SERVER_TRUST_ACCOUNT = 1809,
        ERROR_DOMAIN_TRUST_INCONSISTENT = 1810,
        ERROR_SERVER_HAS_OPEN_HANDLES = 1811,
        ERROR_RESOURCE_DATA_NOT_FOUND = 1812,
        ERROR_RESOURCE_TYPE_NOT_FOUND = 1813,
        ERROR_RESOURCE_NAME_NOT_FOUND = 1814,
        ERROR_RESOURCE_LANG_NOT_FOUND = 1815,
        ERROR_NOT_ENOUGH_QUOTA = 1816,
        EPT_S_CANT_CREATE = 1899,
        ERROR_INVALID_TIME = 1901,
        ERROR_INVALID_FORM_NAME = 1902,
        ERROR_INVALID_FORM_SIZE = 1903,
        ERROR_ALREADY_WAITING = 1904,
        ERROR_PRINTER_DELETED = 1905,
        ERROR_INVALID_PRINTER_STATE = 1906,
        ERROR_PASSWORD_MUST_CHANGE = 1907,
        ERROR_DOMAIN_CONTROLLER_NOT_FOUND = 1908,
        ERROR_ACCOUNT_LOCKED_OUT = 1909,
        ERROR_NO_BROWSER_SERVERS_FOUND = 6118,
        ERROR_INVALID_PIXEL_FORMAT = 2000,
        ERROR_BAD_DRIVER = 2001,
        ERROR_INVALID_WINDOW_STYLE = 2002,
        ERROR_METAFILE_NOT_SUPPORTED = 2003,
        ERROR_TRANSFORM_NOT_SUPPORTED = 2004,
        ERROR_CLIPPING_NOT_SUPPORTED = 2005,
        ERROR_UNKNOWN_PRINT_MONITOR = 3000,
        ERROR_PRINTER_DRIVER_IN_USE = 3001,
        ERROR_SPOOL_FILE_NOT_FOUND = 3002,
        ERROR_SPL_NO_STARTDOC = 3003,
        ERROR_SPL_NO_ADDJOB = 3004,
        ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED = 3005,
        ERROR_PRINT_MONITOR_ALREADY_INSTALLED = 3006,
        ERROR_INVALID_PRINT_MONITOR = 3007,
        ERROR_PRINT_MONITOR_IN_USE = 3008,
        ERROR_PRINTER_HAS_JOBS_QUEUED = 3009,
        ERROR_SUCCESS_REBOOT_REQUIRED = 3010,
        ERROR_SUCCESS_RESTART_REQUIRED = 3011,
        ERROR_WINS_INTERNAL = 4000,
        ERROR_CAN_NOT_DEL_LOCAL_WINS = 4001,
        ERROR_STATIC_INIT = 4002,
        ERROR_INC_BACKUP = 4003,
        ERROR_FULL_BACKUP = 4004,
        ERROR_REC_NON_EXISTENT = 4005,
        ERROR_RPL_NOT_ALLOWED = 4006,
        E_UNEXPECTED = unchecked((int)0x8000FFFF),
        E_NOTIMPL = unchecked((int)0x80004001),
        E_OUTOFMEMORY = unchecked((int)0x8007000E),
        E_INVALIDARG = unchecked((int)0x80070057),
        E_NOINTERFACE = unchecked((int)0x80004002),
        E_POINTER = unchecked((int)0x80004003),
        E_HANDLE = unchecked((int)0x80070006),
        E_ABORT = unchecked((int)0x80004004),
        E_FAIL = unchecked((int)0x80004005),
        E_ACCESSDENIED = unchecked((int)0x80070005);
        // E_NOTIMPL = unchecked((int)0x80000001);
        // int E_OUTOFMEMORY = unchecked((int)0x80000002);
        // int E_INVALIDARG = unchecked((int)0x80000003);
        // int E_NOINTERFACE = unchecked((int)0x80000004);
        // int E_POINTER = unchecked((int)0x80000005);
        // int E_HANDLE = unchecked((int)0x80000006);
        // int E_ABORT = unchecked((int)0x80000007);
        // int E_FAIL = unchecked((int)0x80000008);
        // int E_ACCESSDENIED = unchecked((int)0x80000009);
        public const int E_PENDING = unchecked((int)0x8000000A),
        ENUM_E_FIRST = unchecked((int)0x800401B0),
        ENUM_E_LAST = unchecked((int)0x800401BF),
        ENUM_S_FIRST = 0x000401B0,
        ENUM_S_LAST = 0x000401BF,
        ERROR = 0,
        ETO_OPAQUE = 0x0002,
        ETO_CLIPPED = 0x0004,
        ETO_GLYPH_INDEX = 0x0010,
        ETO_RTLREADING = 0x0080,
        ETO_IGNORELANGUAGE = 0x1000,
        ENDDOC = 11,
        ENABLEDUPLEX = 28,
        ENUMPAPERBINS = 31,
        EPSPRINTING = 33,
        ENUMPAPERMETRICS = 34,
        EXTTEXTOUT = 512,
        ENABLERELATIVEWIDTHS = 768,
        ENABLEPAIRKERNING = 769,
        END_PATH = 4098,
        EXT_DEVICE_CAPS = 4099,
        ENCAPSULATED_POSTSCRIPT = 4116,
        EASTEUROPE_CHARSET = 238,
        ELF_VENDOR_SIZE = 4,
        ELF_VERSION = 0,
        ELF_CULTURE_LATIN = 0,
        ENHMETA_SIGNATURE = 0x464D4520,
        ENHMETA_STOCK_OBJECT = unchecked((int)0x80000000),
        EMR_HEADER = 1,
        EMR_POLYBEZIER = 2,
        EMR_POLYGON = 3,
        EMR_POLYLINE = 4,
        EMR_POLYBEZIERTO = 5,
        EMR_POLYLINETO = 6,
        EMR_POLYPOLYLINE = 7,
        EMR_POLYPOLYGON = 8,
        EMR_SETWINDOWEXTEX = 9,
        EMR_SETWINDOWORGEX = 10,
        EMR_SETVIEWPORTEXTEX = 11,
        EMR_SETVIEWPORTORGEX = 12,
        EMR_SETBRUSHORGEX = 13,
        EMR_EOF = 14,
        EMR_SETPIXELV = 15,
        EMR_SETMAPPERFLAGS = 16,
        EMR_SETMAPMODE = 17,
        EMR_SETBKMODE = 18,
        EMR_SETPOLYFILLMODE = 19,
        EMR_SETROP2 = 20,
        EMR_SETSTRETCHBLTMODE = 21,
        EMR_SETTEXTALIGN = 22,
        EMR_SETCOLORADJUSTMENT = 23,
        EMR_SETTEXTCOLOR = 24,
        EMR_SETBKCOLOR = 25,
        EMR_OFFSETCLIPRGN = 26,
        EMR_MOVETOEX = 27,
        EMR_SETMETARGN = 28,
        EMR_EXCLUDECLIPRECT = 29,
        EMR_INTERSECTCLIPRECT = 30,
        EMR_SCALEVIEWPORTEXTEX = 31,
        EMR_SCALEWINDOWEXTEX = 32,
        EMR_SAVEDC = 33,
        EMR_RESTOREDC = 34,
        EMR_SETWORLDTRANSFORM = 35,
        EMR_MODIFYWORLDTRANSFORM = 36,
        EMR_SELECTOBJECT = 37,
        EMR_CREATEPEN = 38,
        EMR_CREATEBRUSHINDIRECT = 39,
        EMR_DELETEOBJECT = 40,
        EMR_ANGLEARC = 41,
        EMR_ELLIPSE = 42,
        EMR_RECTANGLE = 43,
        EMR_ROUNDRECT = 44,
        EMR_ARC = 45,
        EMR_CHORD = 46,
        EMR_PIE = 47,
        EMR_SELECTPALETTE = 48,
        EMR_CREATEPALETTE = 49,
        EMR_SETPALETTEENTRIES = 50,
        EMR_RESIZEPALETTE = 51,
        EMR_REALIZEPALETTE = 52,
        EMR_EXTFLOODFILL = 53,
        EMR_LINETO = 54,
        EMR_ARCTO = 55,
        EMR_POLYDRAW = 56,
        EMR_SETARCDIRECTION = 57,
        EMR_SETMITERLIMIT = 58,
        EMR_BEGINPATH = 59,
        EMR_ENDPATH = 60,
        EMR_CLOSEFIGURE = 61,
        EMR_FILLPATH = 62,
        EMR_STROKEANDFILLPATH = 63,
        EMR_STROKEPATH = 64,
        EMR_FLATTENPATH = 65,
        EMR_WIDENPATH = 66,
        EMR_SELECTCLIPPATH = 67,
        EMR_ABORTPATH = 68,
        EMR_GDICOMMENT = 70,
        EMR_FILLRGN = 71,
        EMR_FRAMERGN = 72,
        EMR_INVERTRGN = 73,
        EMR_PAINTRGN = 74,
        EMR_EXTSELECTCLIPRGN = 75,
        EMR_BITBLT = 76,
        EMR_STRETCHBLT = 77,
        EMR_MASKBLT = 78,
        EMR_PLGBLT = 79,
        EMR_SETDIBITSTODEVICE = 80,
        EMR_STRETCHDIBITS = 81,
        EMR_EXTCREATEFONTINDIRECTW = 82,
        EMR_EXTTEXTOUTA = 83,
        EMR_EXTTEXTOUTW = 84,
        EMR_POLYBEZIER16 = 85,
        EMR_POLYGON16 = 86,
        EMR_POLYLINE16 = 87,
        EMR_POLYBEZIERTO16 = 88,
        EMR_POLYLINETO16 = 89,
        EMR_POLYPOLYLINE16 = 90,
        EMR_POLYPOLYGON16 = 91,
        EMR_POLYDRAW16 = 92,
        EMR_CREATEMONOBRUSH = 93,
        EMR_CREATEDIBPATTERNBRUSHPT = 94,
        EMR_EXTCREATEPEN = 95,
        EMR_POLYTEXTOUTA = 96,
        EMR_POLYTEXTOUTW = 97,
        EMR_SETICMMODE = 98,
        EMR_CREATECOLORSPACE = 99,
        EMR_SETCOLORSPACE = 100,
        EMR_DELETECOLORSPACE = 101,
        EMR_GLSRECORD = 102,
        EMR_GLSBOUNDEDRECORD = 103,
        EMR_PIXELFORMAT = 104,
        EMR_MIN = 1,
        EMR_MAX = 104;
        // EMR_MAX = 97;
        public const int EPS_SIGNATURE = 0x46535045,
        ENUM_ALL_CALENDARS = unchecked((int)0xFfffffff),
        ERROR_SEVERITY_SUCCESS = 0x00000000,
        ERROR_SEVERITY_INFORMATIONAL = 0x40000000,
        ERROR_SEVERITY_WARNING = unchecked((int)0x80000000),
        ERROR_SEVERITY_ERROR = unchecked((int)0xC0000000),
        EXCEPTION_NONCONTINUABLE = 0x1,
        EXCEPTION_MAXIMUM_PARAMETERS = 15,
        EVENT_MODIFY_STATE = 0x0002,
        EVENT_OBJECT_SELECTION = 0x8006,
        EVENTLOG_SEQUENTIAL_READ = 0X0001,
        EVENTLOG_SEEK_READ = 0X0002,
        EVENTLOG_FORWARDS_READ = 0X0004,
        EVENTLOG_BACKWARDS_READ = 0X0008,
        EVENTLOG_SUCCESS = 0X0000,
        EVENTLOG_ERROR_TYPE = 0x0001,
        EVENTLOG_WARNING_TYPE = 0x0002,
        EVENTLOG_INFORMATION_TYPE = 0x0004,
        EVENTLOG_AUDIT_SUCCESS = 0x0008,
        EVENTLOG_AUDIT_FAILURE = 0x0010,
        EVENTLOG_START_PAIRED_EVENT = 0x0001,
        EVENTLOG_END_PAIRED_EVENT = 0x0002,
        EVENTLOG_END_ALL_PAIRED_EVENTS = 0x0004,
        EVENTLOG_PAIRED_EVENT_ACTIVE = 0x0008,
        EVENTLOG_PAIRED_EVENT_INACTIVE = 0x0010,
        EDGE_RAISED = (0x0001|0x0004),
                      EDGE_SUNKEN = (0x0002|0x0008),
                                    EDGE_ETCHED = (0x0002|0x0004),
                                                  EDGE_BUMP = (0x0001|0x0008),
                                                              EW_RESTARTWINDOWS = 0x0042,
        EW_REBOOTSYSTEM = 0x0043,
        EW_EXITANDEXECAPP = 0x0044,
        ENDSESSION_LOGOFF = unchecked((int)0x80000000),
        EWX_LOGOFF = 0,
        EWX_SHUTDOWN = 1,
        EWX_REBOOT = 2,
        EWX_FORCE = 4,
        EWX_POWEROFF = 8,
        ESB_ENABLE_BOTH = 0x0000,
        ESB_DISABLE_BOTH = 0x0003,
        ESB_DISABLE_LEFT = 0x0001,
        ESB_DISABLE_RIGHT = 0x0002,
        ESB_DISABLE_UP = 0x0001,
        ESB_DISABLE_DOWN = 0x0002,
        ESB_DISABLE_LTUP = 0x0001,
        ESB_DISABLE_RTDN = 0x0002,
        ES_LEFT = 0x0000,
        ES_CENTER = 0x0001,
        ES_RIGHT = 0x0002,
        ES_MULTILINE = 0x0004,
        ES_UPPERCASE = 0x0008,
        ES_LOWERCASE = 0x0010,
        ES_PASSWORD = 0x0020,
        ES_AUTOVSCROLL = 0x0040,
        ES_AUTOHSCROLL = 0x0080,
        ES_NOHIDESEL = 0x0100,
        ES_OEMCONVERT = 0x0400,
        ES_READONLY = 0x0800,
        ES_WANTRETURN = 0x1000,
        ES_NUMBER = 0x2000,
        EN_SETFOCUS = 0x0100,
        EN_KILLFOCUS = 0x0200,
        EN_CHANGE = 0x0300,
        EN_UPDATE = 0x0400,
        EN_ERRSPACE = 0x0500,
        EN_MAXTEXT = 0x0501,
        EN_HSCROLL = 0x0601,
        EN_VSCROLL = 0x0602,
        EC_LEFTMARGIN = 0x0001,
        EC_RIGHTMARGIN = 0x0002,
        EC_USEFONTINFO = 0xffff,
        EM_GETSEL = 0x00B0,
        EM_SETSEL = 0x00B1,
        EM_GETRECT = 0x00B2,
        EM_SETRECT = 0x00B3,
        EM_SETRECTNP = 0x00B4,
        EM_SCROLL = 0x00B5,
        EM_LINESCROLL = 0x00B6,
        EM_SCROLLCARET = 0x00B7,
        EM_GETMODIFY = 0x00B8,
        EM_SETMODIFY = 0x00B9,
        EM_GETLINECOUNT = 0x00BA,
        EM_LINEINDEX = 0x00BB,
        EM_SETHANDLE = 0x00BC,
        EM_GETHANDLE = 0x00BD,
        EM_GETTHUMB = 0x00BE,
        EM_LINELENGTH = 0x00C1,
        EM_REPLACESEL = 0x00C2,
        EM_GETLINE = 0x00C4,
        EM_LIMITTEXT = 0x00C5,
        EM_CANUNDO = 0x00C6,
        EM_UNDO = 0x00C7,
        EM_FMTLINES = 0x00C8,
        EM_LINEFROMCHAR = 0x00C9,
        EM_SETTABSTOPS = 0x00CB,
        EM_SETPASSWORDCHAR = 0x00CC,
        EM_EMPTYUNDOBUFFER = 0x00CD,
        EM_GETFIRSTVISIBLELINE = 0x00CE,
        EM_SETREADONLY = 0x00CF,
        EM_SETWORDBREAKPROC = 0x00D0,
        EM_GETWORDBREAKPROC = 0x00D1,
        EM_GETPASSWORDCHAR = 0x00D2,
        EM_SETMARGINS = 0x00D3,
        EM_GETMARGINS = 0x00D4,
        EM_SETLIMITTEXT = 0x00C5,
        EM_GETLIMITTEXT = 0x00D5,
        EM_POSFROMCHAR = 0x00D6,
        EM_CHARFROMPOS = 0x00D7,
        ENUM_CURRENT_SETTINGS = (-1),
                                ENUM_REGISTRY_SETTINGS = (-2),
                                                         E_DRAW = unchecked((int)0x80040140),
        EXCEPTION_ACCESS_VIOLATION = (unchecked((int)0xC0000005)),
                                     EXCEPTION_DATATYPE_MISALIGNMENT = (unchecked((int)0x80000002)),
                                                                       EXCEPTION_BREAKPOINT = (unchecked((int)0x80000003)),
                                                                                              EXCEPTION_SINGLE_STEP = (unchecked((int)0x80000004)),
                                                                                                                      EXCEPTION_ARRAY_BOUNDS_EXCEEDED = (unchecked((int)0xC000008C)),
                                                                                                                                                        EXCEPTION_FLT_DENORMAL_OPERAND = (unchecked((int)0xC000008D)),
                                                                                                                                                                                         EXCEPTION_FLT_DIVIDE_BY_ZERO = (unchecked((int)0xC000008E)),
                                                                                                                                                                                                                        EXCEPTION_FLT_INEXACT_RESULT = (unchecked((int)0xC000008F)),
                                                                                                                                                                                                                                                       EXCEPTION_FLT_INVALID_OPERATION = (unchecked((int)0xC0000090)),
                                                                                                                                                                                                                                                                                         EXCEPTION_FLT_OVERFLOW = (unchecked((int)0xC0000091)),
                                                                                                                                                                                                                                                                                                                  EXCEPTION_FLT_STACK_CHECK = (unchecked((int)0xC0000092)),
                                                                                                                                                                                                                                                                                                                                              EXCEPTION_FLT_UNDERFLOW = (unchecked((int)0xC0000093)),
                                                                                                                                                                                                                                                                                                                                                                        EXCEPTION_INT_DIVIDE_BY_ZERO = (unchecked((int)0xC0000094)),
                                                                                                                                                                                                                                                                                                                                                                                                       EXCEPTION_INT_OVERFLOW = (unchecked((int)0xC0000095)),
                                                                                                                                                                                                                                                                                                                                                                                                                                EXCEPTION_PRIV_INSTRUCTION = (unchecked((int)0xC0000096)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                             EXCEPTION_IN_PAGE_ERROR = (unchecked((int)0xC0000006)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       EXCEPTION_ILLEGAL_INSTRUCTION = (unchecked((int)0xC000001D)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       EXCEPTION_NONCONTINUABLE_EXCEPTION = (unchecked((int)0xC0000025)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            EXCEPTION_STACK_OVERFLOW = (unchecked((int)0xC00000FD)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       EXCEPTION_INVALID_DISPOSITION = (unchecked((int)0xC0000026)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       EXCEPTION_GUARD_PAGE = (unchecked((int)0x80000001)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              EXCEPTION_INVALID_HANDLE = (unchecked((int)0xC0000008)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         EVENT_ALL_ACCESS = ((0x000F0000)|(0x00100000)|0x3);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
        



        public const int FNERR_FILENAMECODES = 0x3000,
        FNERR_SUBCLASSFAILURE = 0x3001,
        FNERR_INVALIDFILENAME = 0x3002,
        FNERR_BUFFERTOOSMALL = 0x3003,
        FRERR_FINDREPLACECODES = 0x4000,
        FRERR_BUFFERLENGTHZERO = 0x4001,
        FR_DOWN = 0x00000001,
        FR_WHOLEWORD = 0x00000002,
        FR_MATCHCASE = 0x00000004,
        FR_FINDNEXT = 0x00000008,
        FR_REPLACE = 0x00000010,
        FR_REPLACEALL = 0x00000020,
        FR_DIALOGTERM = 0x00000040,
        FR_SHOWHELP = 0x00000080,
        FR_ENABLEHOOK = 0x00000100,
        FR_ENABLETEMPLATE = 0x00000200,
        FR_NOUPDOWN = 0x00000400,
        FR_NOMATCHCASE = 0x00000800,
        FR_NOWHOLEWORD = 0x00001000,
        FR_ENABLETEMPLATEHANDLE = 0x00002000,
        FR_HIDEUPDOWN = 0x00004000,
        FR_HIDEMATCHCASE = 0x00008000,
        FR_HIDEWHOLEWORD = 0x00010000;
        public const bool FALSE = false;
        public const int frm1 = 0x0434,
        frm2 = 0x0435,
        frm3 = 0x0436,
        frm4 = 0x0437,
        FILEOPENORD = 1536,
        FINDDLGORD = 1540,
        FONTDLGORD = 1542,
        FORMATDLGORD31 = 1543,
        FORMATDLGORD30 = 1544,
        FADF_AUTO = (0x1),
                    FADF_STATIC = (0x2),
                                  FADF_EMBEDDED = (0x4),
                                                  FADF_FIXEDSIZE = (0x10),
                                                                   FADF_BSTR = (0x100),
                                                                               FADF_UNKNOWN = (0x200),
                                                                                              FADF_DISPATCH = (0x400),
                                                                                                              FADF_VARIANT = (unchecked((int)0x800)),
                                                                                                                             FADF_RESERVED = (0xf0e8),
                                                                                                                                             FO_MOVE = 0x0001,
        FO_COPY = 0x0002,
        FO_DELETE = 0x0003,
        FO_RENAME = 0x0004,
        FOF_MULTIDESTFILES = 0x0001,
        FOF_CONFIRMMOUSE = 0x0002,
        FOF_SILENT = 0x0004,
        FOF_RENAMEONCOLLISION = 0x0008,
        FOF_NOCONFIRMATION = 0x0010,
        FOF_WANTMAPPINGHANDLE = 0x0020,
        FOF_ALLOWUNDO = 0x0040,
        FOF_FILESONLY = 0x0080,
        FOF_SIMPLEPROGRESS = 0x0100,
        FOF_NOCONFIRMMKDIR = 0x0200,
        FOF_NOERRORUI = 0x0400,
        FILE_BEGIN = 0,
        FILE_CURRENT = 1,
        FILE_END = 2,
        FILE_FLAG_WRITE_THROUGH = unchecked((int)0x80000000),
        FILE_FLAG_OVERLAPPED = 0x40000000,
        FILE_FLAG_NO_BUFFERING = 0x20000000,
        FILE_FLAG_RANDOM_ACCESS = 0x10000000,
        FILE_FLAG_SEQUENTIAL_SCAN = 0x08000000,
        FILE_FLAG_DELETE_ON_CLOSE = 0x04000000,
        FILE_FLAG_BACKUP_SEMANTICS = 0x02000000,
        FILE_FLAG_POSIX_SEMANTICS = 0x01000000,
        FILE_TYPE_UNKNOWN = 0x0000,
        FILE_TYPE_DISK = 0x0001,
        FILE_TYPE_CHAR = 0x0002,
        FILE_TYPE_PIPE = 0x0003,
        FILE_TYPE_REMOTE = unchecked((int)0x8000),
        FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100,
        FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200,
        FORMAT_MESSAGE_FROM_STRING = 0x00000400,
        FORMAT_MESSAGE_FROM_HMODULE = 0x00000800,
        FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000,
        FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x00002000,
        FORMAT_MESSAGE_MAX_WIDTH_MASK = 0x000000FF,
        FIND_FIRST_EX_CASE_SENSITIVE = 0x00000001,
        FROM_LEFT_1ST_BUTTON_PRESSED = 0x0001,
        FROM_LEFT_2ND_BUTTON_PRESSED = 0x0004,
        FROM_LEFT_3RD_BUTTON_PRESSED = 0x0008,
        FROM_LEFT_4TH_BUTTON_PRESSED = 0x0010,
        FOCUS_EVENT = 0x0010,
        FOREGROUND_BLUE = 0x0001,
        FOREGROUND_GREEN = 0x0002,
        FOREGROUND_RED = 0x0004,
        FOREGROUND_INTENSITY = 0x0008;
        // FALSE = 0;
        public const int FACILITY_WINDOWS = 8,
        FACILITY_STORAGE = 3,
        FACILITY_RPC = 1,
        FACILITY_SSPI = 9,
        FACILITY_WIN32 = 7,
        FACILITY_CONTROL = 10,
        FACILITY_NULL = 0,
        FACILITY_INTERNET = 12,
        FACILITY_ITF = 4,
        FACILITY_DISPATCH = 2,
        FACILITY_CERT = 11,
        FACILITY_NT_BIT = 0x10000000,
        FLUSHOUTPUT = 6,
        FIXED_PITCH = 1,
        FS_LATIN1 = 0x00000001,
        FS_LATIN2 = 0x00000002,
        FS_CYRILLIC = 0x00000004,
        FS_GREEK = 0x00000008,
        FS_TURKISH = 0x00000010,
        FS_HEBREW = 0x00000020,
        FS_ARABIC = 0x00000040,
        FS_BALTIC = 0x00000080,
        FS_VIETNAMESE = 0x00000100,
        FS_THAI = 0x00010000,
        FS_JISJAPAN = 0x00020000,
        FS_CHINESESIMP = 0x00040000,
        FS_WANSUNG = 0x00080000,
        FS_CHINESETRAD = 0x00100000,
        FS_JOHAB = 0x00200000,
        FS_SYMBOL = unchecked((int)0x80000000),
        FF_DONTCARE = (0<<4),
                      FF_ROMAN = (1<<4),
                                 FF_SWISS = (2<<4),
                                            FF_MODERN =(3<<4),
                                                       FF_SCRIPT = (4<<4),
                                                                   FF_DECORATIVE = (5<<4),
                                                                                   FW_DONTCARE = 0,
        FW_THIN = 100,
        FW_EXTRALIGHT = 200,
        FW_LIGHT = 300,
        FW_NORMAL = 400,
        FW_MEDIUM = 500,
        FW_SEMIBOLD = 600,
        FW_BOLD = 700,
        FW_EXTRABOLD = 800,
        FW_HEAVY = 900,
        FW_ULTRALIGHT = 200,
        FW_REGULAR = 400,
        FW_DEMIBOLD = 600,
        FW_ULTRABOLD = 800,
        FW_BLACK = 900,
        FLOODFILLBORDER = 0,
        FLOODFILLSURFACE = 1,
        FLI_MASK = 0x103B,
        FLI_GLYPHS = 0x00040000,
        FONTMAPPER_MAX = 10,
        FILE_READ_DATA = (0x0001),
        FILE_LIST_DIRECTORY = (0x0001),
        FILE_WRITE_DATA = (0x0002),
        FILE_ADD_FILE = (0x0002),
        FILE_APPEND_DATA = (0x0004),
        FILE_ADD_SUBDIRECTORY = (0x0004),
        FILE_CREATE_PIPE_INSTANCE = (0x0004),
        FILE_READ_EA = (0x0008),
        FILE_WRITE_EA = (0x0010),
        FILE_EXECUTE = (0x0020),
        FILE_TRAVERSE = (0x0020),
        FILE_DELETE_CHILD = (0x0040),
        FILE_READ_ATTRIBUTES = (0x0080),
        FILE_WRITE_ATTRIBUTES = (0x0100),
        FILE_SHARE_READ = 0x00000001,
        FILE_SHARE_WRITE = 0x00000002,
        FILE_SHARE_DELETE = 0x00000004,
        FILE_ATTRIBUTE_READONLY = 0x00000001,
        FILE_ATTRIBUTE_HIDDEN = 0x00000002,
        FILE_ATTRIBUTE_SYSTEM = 0x00000004,
        FILE_ATTRIBUTE_DIRECTORY = 0x00000010,
        FILE_ATTRIBUTE_ARCHIVE = 0x00000020,
        FILE_ATTRIBUTE_NORMAL = 0x00000080,
        FILE_ATTRIBUTE_TEMPORARY = 0x00000100,
        FILE_ATTRIBUTE_COMPRESSED = 0x00000800,
        FILE_ATTRIBUTE_OFFLINE = 0x00001000,
        FILE_NOTIFY_CHANGE_FILE_NAME = 0x00000001,
        FILE_NOTIFY_CHANGE_DIR_NAME = 0x00000002,
        FILE_NOTIFY_CHANGE_ATTRIBUTES = 0x00000004,
        FILE_NOTIFY_CHANGE_SIZE = 0x00000008,
        FILE_NOTIFY_CHANGE_LAST_WRITE = 0x00000010,
        FILE_NOTIFY_CHANGE_LAST_ACCESS = 0x00000020,
        FILE_NOTIFY_CHANGE_CREATION = 0x00000040,
        FILE_NOTIFY_CHANGE_SECURITY = 0x00000100,
        FILE_ACTION_ADDED = 0x00000001,
        FILE_ACTION_REMOVED = 0x00000002,
        FILE_ACTION_MODIFIED = 0x00000003,
        FILE_ACTION_RENAMED_OLD_NAME = 0x00000004,
        FILE_ACTION_RENAMED_NEW_NAME = 0x00000005,
        FILE_CASE_SENSITIVE_SEARCH = 0x00000001,
        FILE_CASE_PRESERVED_NAMES = 0x00000002,
        FILE_UNICODE_ON_DISK = 0x00000004,
        FILE_PERSISTENT_ACLS = 0x00000008,
        FILE_FILE_COMPRESSION = 0x00000010,
        FILE_VOLUME_IS_COMPRESSED = 0x00008000,
        FAILED_ACCESS_ACE_FLAG = (unchecked((int)0x80)),
                                 FRAME_FPO = 0,
        FRAME_TRAP = 1,
        FRAME_TSS = 2,
        FRAME_NONFPO = 3,
        FORM_USER = 0x00000000,
        FORM_BUILTIN = 0x00000001,
        FORM_PRINTER = 0x00000002;
        public const int FVIRTKEY = 0x01;
        public const int FNOINVERT = 0x02,
        FSHIFT = 0x04,
        FCONTROL = 0x08,
        FALT = 0x10,
        FKF_FILTERKEYSON = 0x00000001,
        FKF_AVAILABLE = 0x00000002,
        FKF_HOTKEYACTIVE = 0x00000004,
        FKF_CONFIRMHOTKEY = 0x00000008,
        FKF_HOTKEYSOUND = 0x00000010,
        FKF_INDICATOR = 0x00000020,
        FKF_CLICKON = 0x00000040,
        FS_CASE_IS_PRESERVED = 0x00000002,
        FS_CASE_SENSITIVE = 0x00000001,
        FS_UNICODE_STORED_ON_DISK = 0x00000004,
        FS_PERSISTENT_ACLS = 0x00000008,
        FS_VOL_IS_COMPRESSED = 0x00008000,
        FS_FILE_COMPRESSION = 0x00000010,
        FILE_MAP_COPY = 0x0001,
        FILE_MAP_WRITE = 0x0002,
        FILE_MAP_READ = 0x0004,
        FILE_ALL_ACCESS = ((0x000F0000)|(0x00100000)|0x1FF);




        public const int grp1 = 0x0430,
        grp2 = 0x0431,
        grp3 = 0x0432,
        grp4 = 0x0433,
        GCS_COMPREADSTR = 0x0001,
        GCS_COMPREADATTR = 0x0002,
        GCS_COMPREADCLAUSE = 0x0004,
        GCS_COMPSTR = 0x0008,
        GCS_COMPATTR = 0x0010,
        GCS_COMPCLAUSE = 0x0020,
        GCS_CURSORPOS = 0x0080,
        GCS_DELTASTART = 0x0100,
        GCS_RESULTREADSTR = 0x0200,
        GCS_RESULTREADCLAUSE = 0x0400,
        GCS_RESULTSTR = 0x0800,
        GCS_RESULTCLAUSE = 0x1000,
        GGL_LEVEL = 0x00000001,
        GGL_INDEX = 0x00000002,
        GGL_STRING = 0x00000003,
        GGL_PRIVATE = 0x00000004,
        GL_LEVEL_NOGUIDELINE = 0x00000000,
        GL_LEVEL_FATAL = 0x00000001,
        GL_LEVEL_ERROR = 0x00000002,
        GL_LEVEL_WARNING = 0x00000003,
        GL_LEVEL_INFORMATION = 0x00000004,
        GL_ID_UNKNOWN = 0x00000000,
        GL_ID_NOMODULE = 0x00000001,
        GL_ID_NODICTIONARY = 0x00000010,
        GL_ID_CANNOTSAVE = 0x00000011,
        GL_ID_NOCONVERT = 0x00000020,
        GL_ID_TYPINGERROR = 0x00000021,
        GL_ID_TOOMANYSTROKE = 0x00000022,
        GL_ID_READINGCONFLICT = 0x00000023,
        GL_ID_INPUTREADING = 0x00000024,
        GL_ID_INPUTRADICAL = 0x00000025,
        GL_ID_INPUTCODE = 0x00000026,
        GL_ID_INPUTSYMBOL = 0x00000027,
        GL_ID_CHOOSECANDIDATE = 0x00000028,
        GL_ID_REVERSECONVERSION = 0x00000029,
        GL_ID_PRIVATE_FIRST = 0x00008000,
        GL_ID_PRIVATE_LAST = 0x0000FFFF,
        GCL_CONVERSION = 0x0001,
        GCL_REVERSECONVERSION = 0x0002,
        GCL_REVERSE_LENGTH = 0x0003,
        GROUP_NAME = unchecked((int)0x80),
        GMEM_FIXED = 0x0000,
        GMEM_MOVEABLE = 0x0002,
        GMEM_NOCOMPACT = 0x0010,
        GMEM_NODISCARD = 0x0020,
        GMEM_ZEROINIT = 0x0040,
        GMEM_MODIFY = 0x0080,
        GMEM_DISCARDABLE = 0x0100,
        GMEM_NOT_BANKED = 0x1000,
        GMEM_SHARE = 0x2000,
        GMEM_DDESHARE = 0x2000,
        GMEM_NOTIFY = 0x4000,
        GMEM_LOWER = 0x1000,
        GMEM_VALID_FLAGS = 0x7F72,
        GMEM_INVALID_HANDLE = unchecked((int)0x8000),
        GHND = (0x0002|0x0040),
               GPTR = (0x0000|0x0040),
                      GMEM_DISCARDED = 0x4000,
        GMEM_LOCKCOUNT = 0x00FF,
        GET_TAPE_MEDIA_INFORMATION = 0,
        GET_TAPE_DRIVE_INFORMATION = 1,
        GDI_ERROR = (unchecked((int)0xFFFFFFFF)),
                    GETCOLORTABLE = 5,
        GETPHYSPAGESIZE = 12,
        GETPRINTINGOFFSET = 13,
        GETSCALINGFACTOR = 14,
        GETPENWIDTH = 16,
        GETTECHNOLGY = 20,
        GETTECHNOLOGY = 20,
        GETVECTORPENSIZE = 26,
        GETVECTORBRUSHSIZE = 27,
        GETSETPAPERBINS = 29,
        GETSETPRINTORIENT = 30,
        GETSETPAPERMETRICS = 35,
        GETDEVICEUNITS = 42,
        GETEXTENDEDTEXTMETRICS = 256,
        GETEXTENTTABLE = 257,
        GETPAIRKERNTABLE = 258,
        GETTRACKKERNTABLE = 259,
        GETFACENAME = 513,
        GETSETSCREENPARAMS = 3072,
        GB2312_CHARSET = 134,
        GREEK_CHARSET = 161,
        GM_COMPATIBLE = 1,
        GM_ADVANCED = 2,
        GM_LAST = 2,
        GRAY_BRUSH = 2,
        GGO_METRICS = 0,
        GGO_BITMAP = 1,
        GGO_NATIVE = 2,
        GGO_GRAY2_BITMAP = 4,
        GGO_GRAY4_BITMAP = 5,
        GGO_GRAY8_BITMAP = 6,
        GGO_GLYPH_INDEX = 0x0080,
        GCP_DBCS = 0x0001,
        GCP_REORDER = 0x0002,
        GCP_USEKERNING = 0x0008,
        GCP_GLYPHSHAPE = 0x0010,
        GCP_LIGATE = 0x0020,
        GCP_DIACRITIC = 0x0100,
        GCP_KASHIDA = 0x0400,
        GCP_ERROR = unchecked((int)0x8000),
        GCP_JUSTIFY = 0x00010000,
        GCP_CLASSIN = 0x00080000,
        GCP_MAXEXTENT = 0x00100000,
        GCP_JUSTIFYIN = 0x00200000,
        GCP_DISPLAYZWG = 0x00400000,
        GCP_SYMSWAPOFF = 0x00800000,
        GCP_NUMERICOVERRIDE = 0x01000000,
        GCP_NEUTRALOVERRIDE = 0x02000000,
        GCP_NUMERICSLATIN = 0x04000000,
        GCP_NUMERICSLOCAL = 0x08000000,
        GCPCLASS_LATIN = 1,
        GCPCLASS_HEBREW = 2,
        GCPCLASS_ARABIC = 2,
        GCPCLASS_NEUTRAL = 3,
        GCPCLASS_LOCALNUMBER = 4,
        GCPCLASS_LATINNUMBER = 5,
        GCPCLASS_LATINNUMERICTERMINATOR = 6,
        GCPCLASS_LATINNUMERICSEPARATOR = 7,
        GCPCLASS_NUMERICSEPARATOR = 8,
        GCPCLASS_PREBOUNDLTR = unchecked((int)0x80),
        GCPCLASS_PREBOUNDRTL = 0x40,
        GCPCLASS_POSTBOUNDLTR = 0x20,
        GCPCLASS_POSTBOUNDRTL = 0x10,
        GCPGLYPH_LINKBEFORE = unchecked((int)0x8000),
        GCPGLYPH_LINKAFTER = 0x4000,
        GDICOMMENT_IDENTIFIER = 0x43494447,
        GDICOMMENT_WINDOWS_METAFILE = unchecked((int)0x80000001),
        GDICOMMENT_BEGINGROUP = 0x00000002,
        GDICOMMENT_ENDGROUP = 0x00000003,
        GDICOMMENT_MULTIFORMATS = 0x40000004,
        GENERIC_READ = (unchecked((int)0x80000000)),
        GENERIC_WRITE = (0x40000000),
        GENERIC_EXECUTE = (0x20000000),
        GENERIC_ALL = (0x10000000),
        GROUP_SECURITY_INFORMATION = (0X00000002),
        GWL_WNDPROC = (-4),
        GWL_HINSTANCE = (-6),
        GWL_HWNDPARENT = (-8),
        GWL_STYLE = (-16),
        GWL_EXSTYLE = (-20),
        GWL_USERDATA = (-21),
        GWL_ID = (-12),
        GCL_MENUNAME = (-8),
        GCL_HBRBACKGROUND = (-10),
        GCL_HCURSOR = (-12),
        GCL_HICON = (-14),
        GCL_HMODULE = (-16),
        GCL_CBWNDEXTRA = (-18),
        GCL_CBCLSEXTRA = (-20),
        GCL_WNDPROC = (-24),
        GCL_STYLE = (-26),
        GCW_ATOM = (-32),
        GCL_HICONSM = (-34),
        GMDI_USEDISABLED = 0x0001,
        GMDI_GOINTOPOPUPS = 0x0002,
        GW_HWNDFIRST = 0,
        GW_HWNDLAST = 1,
        GW_HWNDNEXT = 2,
        GW_HWNDPREV = 3,
        GW_OWNER = 4,
        GW_CHILD = 5,
        GW_MAX = 5,
        GMR_VISIBLE = 0,
        GMR_DAYSTATE = 1,
        GDTR_MIN = 0x0001,
        GDTR_MAX = 0x0002,
        GDT_ERROR = -1,
        GDT_VALID = 0,
        GDT_NONE = 1;



        public const int HDATA_APPOWNED = 0x0001,
        HANGUP_PENDING = 0x04,
        HANGUP_COMPLETE = 0x05,
        HIGH_PRIORITY_CLASS = 0x00000080,
        HANDLE_FLAG_INHERIT = 0x00000001,
        HANDLE_FLAG_PROTECT_FROM_CLOSE = 0x00000002,
        HINSTANCE_ERROR = 32,
        HW_PROFILE_GUIDLEN = 39,
        HP_ALGID = 0x0001,
        HP_HASHVAL = 0x0002,
        HP_HASHSIZE = 0x0004,
        HALFTONE = 4,
        HANGEUL_CHARSET = 129,
        HEBREW_CHARSET = 177,
        HOLLOW_BRUSH = 5,
        HS_HORIZONTAL = 0,
        HS_VERTICAL = 1,
        HS_FDIAGONAL = 2,
        HS_BDIAGONAL = 3,
        HS_CROSS = 4,
        HS_DIAGCROSS = 5,
        HORZSIZE = 4,
        HORZRES = 8,
        HEAP_NO_SERIALIZE = 0x00000001,
        HEAP_GROWABLE = 0x00000002,
        HEAP_GENERATE_EXCEPTIONS = 0x00000004,
        HEAP_ZERO_MEMORY = 0x00000008,
        HEAP_REALLOC_IN_PLACE_ONLY = 0x00000010,
        HEAP_TAIL_CHECKING_ENABLED = 0x00000020,
        HEAP_FREE_CHECKING_ENABLED = 0x00000040,
        HEAP_DISABLE_COALESCE_ON_FREE = 0x00000080,
        HEAP_CREATE_ALIGN_16 = 0x00010000,
        HEAP_CREATE_ENABLE_TRACING = 0x00020000,
        HEAP_MAXIMUM_TAG = 0x0FFF,
        HEAP_PSEUDO_TAG_FLAG = unchecked((int)0x8000),
        HEAP_TAG_SHIFT = 16,
        HIDE_WINDOW = 0,
        HC_ACTION = 0,
        HC_GETNEXT = 1,
        HC_SKIP = 2,
        HC_NOREMOVE = 3,
        HC_NOREM = 3,
        HC_SYSMODALON = 4,
        HC_SYSMODALOFF = 5,
        HCBT_MOVESIZE = 0,
        HCBT_MINMAX = 1,
        HCBT_QS = 2,
        HCBT_CREATEWND = 3,
        HCBT_DESTROYWND = 4,
        HCBT_ACTIVATE = 5,
        HCBT_CLICKSKIPPED = 6,
        HCBT_KEYSKIPPED = 7,
        HCBT_SYSCOMMAND = 8,
        HCBT_SETFOCUS = 9,
        HSHELL_WINDOWCREATED = 1,
        HSHELL_WINDOWDESTROYED = 2,
        HSHELL_ACTIVATESHELLWINDOW = 3,
        HSHELL_WINDOWACTIVATED = 4,
        HSHELL_GETMINRECT = 5,
        HSHELL_REDRAW = 6,
        HSHELL_TASKMAN = 7,
        HSHELL_LANGUAGE = 8,
        HKL_PREV = 0,
        HKL_NEXT = 1,
        HTERROR = (-2),
        HTTRANSPARENT = (-1),
        HTNOWHERE = 0,
        HTCLIENT = 1,
        HTCAPTION = 2,
        HTSYSMENU = 3,
        HTGROWBOX = 4,
        HTSIZE = 4,
        HTMENU = 5,
        HTHSCROLL = 6,
        HTVSCROLL = 7,
        HTMINBUTTON = 8,
        HTMAXBUTTON = 9,
        HTLEFT = 10,
        HTRIGHT = 11,
        HTTOP = 12,
        HTTOPLEFT = 13,
        HTTOPRIGHT = 14,
        HTBOTTOM = 15,
        HTBOTTOMLEFT = 16,
        HTBOTTOMRIGHT = 17,
        HTBORDER = 18,
        HTREDUCE = 8,
        HTZOOM = 9,
        HTSIZEFIRST = 10,
        HTSIZELAST = 17,
        HTOBJECT = 19,
        HTCLOSE = 20,
        HTHELP = 21,
        HOVER_DEFAULT = unchecked((int)0xFFFFFFFF),
        HELPINFO_WINDOW = 0x0001,
        HELPINFO_MENUITEM = 0x0002,
        HELP_CONTEXT = 0x0001,
        HELP_QUIT = 0x0002,
        HELP_INDEX = 0x0003,
        HELP_CONTENTS = 0x0003,
        HELP_HELPONHELP = 0x0004,
        HELP_SETINDEX = 0x0005,
        HELP_SETCONTENTS = 0x0005,
        HELP_CONTEXTPOPUP = 0x0008,
        HELP_FORCEFILE = 0x0009,
        HELP_KEY = 0x0101,
        HELP_COMMAND = 0x0102,
        HELP_PARTIALKEY = 0x0105,
        HELP_MULTIKEY = 0x0201,
        HELP_SETWINPOS = 0x0203,
        HELP_CONTEXTMENU = 0x000a,
        HELP_FINDER = 0x000b,
        HELP_WM_HELP = 0x000c,
        HELP_SETPOPUP_POS = 0x000d,
        HELP_TCARD = unchecked((int)0x8000),
        HELP_TCARD_DATA = 0x0010,
        HELP_TCARD_OTHER_CALLER = 0x0011,
        HCF_HIGHCONTRASTON = 0x00000001,
        HCF_AVAILABLE = 0x00000002,
        HCF_HOTKEYACTIVE = 0x00000004,
        HCF_CONFIRMHOTKEY = 0x00000008,
        HCF_HOTKEYSOUND = 0x00000010,
        HCF_INDICATOR = 0x00000020,
        HCF_HOTKEYAVAILABLE = 0x00000040,
        HDM_FIRST = 0x1200,
        HDN_FIRST = (0-300),
                    HDN_LAST = (0-399),
                               HDS_HORZ = 0x0000,
        HDS_BUTTONS = 0x0002,
        HDS_HOTTRACK = 0x0004,
        HDS_HIDDEN = 0x0008,
        HDS_DRAGDROP = 0x0040,
        HDS_FULLDRAG = 0x0080,
        HDI_WIDTH = 0x0001,
        HDI_HEIGHT = 0x0001,
        HDI_TEXT = 0x0002,
        HDI_FORMAT = 0x0004,
        HDI_LPARAM = 0x0008,
        HDI_BITMAP = 0x0010,
        HDI_IMAGE = 0x0020,
        HDI_DI_SETITEM = 0x0040,
        HDI_ORDER = 0x0080,
        HDF_LEFT = 0,
        HDF_RIGHT = 1,
        HDF_CENTER = 2,
        HDF_JUSTIFYMASK = 0x0003,
        HDF_RTLREADING = 4,
        HDF_OWNERDRAW = unchecked((int)0x8000),
        HDF_STRING = 0x4000,
        HDF_BITMAP = 0x2000,
        HDF_BITMAP_ON_RIGHT = 0x1000,
        HDF_IMAGE = 0x0800,
        HDM_GETITEMCOUNT = (0x1200+0),
                           HDM_INSERTITEMA = (0x1200+1),
                                             HDM_INSERTITEMW = (0x1200+10),
                                                               HDM_DELETEITEM = (0x1200+2),
                                                                                HDM_GETITEMA = (0x1200+3),
                                                                                               HDM_GETITEMW = (0x1200+11),
                                                                                                              HDM_SETITEMA = (0x1200+4),
                                                                                                                             HDM_SETITEMW = (0x1200+12),
                                                                                                                                            HDM_LAYOUT = (0x1200+5),
                                                                                                                                                         HHT_NOWHERE = 0x0001,
        HHT_ONHEADER = 0x0002,
        HHT_ONDIVIDER = 0x0004,
        HHT_ONDIVOPEN = 0x0008,
        HHT_ABOVE = 0x0100,
        HHT_BELOW = 0x0200,
        HHT_TORIGHT = 0x0400,
        HHT_TOLEFT = 0x0800,
        HDM_HITTEST = (0x1200+6),
                      HDM_GETITEMRECT = (0x1200+7),
                                        HDM_SETIMAGELIST = (0x1200+8),
                                                           HDM_GETIMAGELIST = (0x1200+9),
                                                                              HDM_ORDERTOINDEX = (0x1200+15),
                                                                                                 HDM_CREATEDRAGIMAGE = (0x1200+16),
                                                                                                                       HDM_GETORDERARRAY = (0x1200+17),
                                                                                                                                           HDM_SETORDERARRAY = (0x1200+18),
                                                                                                                                                               HDM_SETHOTDIVIDER = (0x1200+19),
                                                                                                                                                                                   HDN_ITEMCHANGINGA = ((0-300)-0),
                                                                                                                                                                                                       HDN_ITEMCHANGINGW = ((0-300)-20),
                                                                                                                                                                                                                           HDN_ITEMCHANGEDA = ((0-300)-1),
                                                                                                                                                                                                                                              HDN_ITEMCHANGEDW = ((0-300)-21),
                                                                                                                                                                                                                                                                 HDN_ITEMCLICKA = ((0-300)-2),
                                                                                                                                                                                                                                                                                  HDN_ITEMCLICKW = ((0-300)-22),
                                                                                                                                                                                                                                                                                                   HDN_ITEMDBLCLICKA = ((0-300)-3),
                                                                                                                                                                                                                                                                                                                       HDN_ITEMDBLCLICKW = ((0-300)-23),
                                                                                                                                                                                                                                                                                                                                           HDN_DIVIDERDBLCLICKA = ((0-300)-5),
                                                                                                                                                                                                                                                                                                                                                                  HDN_DIVIDERDBLCLICKW = ((0-300)-25),
                                                                                                                                                                                                                                                                                                                                                                                         HDN_BEGINTRACKA = ((0-300)-6),
                                                                                                                                                                                                                                                                                                                                                                                                           HDN_BEGINTRACKW = ((0-300)-26),
                                                                                                                                                                                                                                                                                                                                                                                                                             HDN_ENDTRACKA = ((0-300)-7),
                                                                                                                                                                                                                                                                                                                                                                                                                                             HDN_ENDTRACKW = ((0-300)-27),
                                                                                                                                                                                                                                                                                                                                                                                                                                                             HDN_TRACKA = ((0-300)-8),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          HDN_TRACKW = ((0-300)-28),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       HDN_GETDISPINFOA = ((0-300)-9),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          HDN_GETDISPINFOW = ((0-300)-29),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             HDN_BEGINDRAG = ((0-300)-10),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             HDN_ENDDRAG = ((0-300)-11),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           HIST_BACK = 0,
        HIST_FORWARD = 1,
        HIST_FAVORITES = 2,
        HIST_ADDTOFAVORITES = 3,
        HIST_VIEWTREE = 4,
        HOTKEYF_SHIFT = 0x01,
        HOTKEYF_CONTROL = 0x02,
        HOTKEYF_ALT = 0x04,
        HOTKEYF_EXT = 0x08,
        HKCOMB_NONE = 0x0001,
        HKCOMB_S = 0x0002,
        HKCOMB_C = 0x0004,
        HKCOMB_A = 0x0008,
        HKCOMB_SC = 0x0010,
        HKCOMB_SA = 0x0020,
        HKCOMB_CA = 0x0040,
        HKCOMB_SCA = 0x0080,
        HKM_SETHOTKEY = (0x0400+1),
                        HKM_GETHOTKEY = (0x0400+2),
                                        HKM_SETRULES = (0x0400+3),
                                                       HWND_TOP = 0,
        HWND_BOTTOM = 1,
        HWND_TOPMOST = -1,
        HWND_NOTOPMOST = -2,
        HICF_OTHER = 0x00000000,
        HICF_MOUSE = 0x00000001,
        HICF_ARROWKEYS = 0x00000002,
        HICF_ACCELERATOR = 0x00000004,
        HICF_DUPACCEL = 0x00000008,
        HICF_ENTERING = 0x00000010,
        HICF_LEAVING = 0x00000020,
        HICF_RESELECT = 0x00000040,
        HICF_TOGGLEDROPDOWN = 0x00000100,
        HINST_COMMCTRL = -1;



        public const int ITALIC_FONTTYPE = 0x0200,
        ico1 = 0x043c,
        ico2 = 0x043d,
        ico3 = 0x043e,
        ico4 = 0x043f,
        IMC_GETCANDIDATEPOS = 0x0007,
        IMC_SETCANDIDATEPOS = 0x0008,
        IMC_GETCOMPOSITIONFONT = 0x0009,
        IMC_SETCOMPOSITIONFONT = 0x000A,
        IMC_GETCOMPOSITIONWINDOW = 0x000B,
        IMC_SETCOMPOSITIONWINDOW = 0x000C,
        IMC_GETSTATUSWINDOWPOS = 0x000F,
        IMC_SETSTATUSWINDOWPOS = 0x0010,
        IMC_CLOSESTATUSWINDOW = 0x0021,
        IMC_OPENSTATUSWINDOW = 0x0022,
        ISC_SHOWUICANDIDATEWINDOW = 0x00000001,
        ISC_SHOWUICOMPOSITIONWINDOW = unchecked((int)0x80000000),
        ISC_SHOWUIGUIDELINE = 0x40000000,
        ISC_SHOWUIALLCANDIDATEWINDOW = 0x0000000F,
        ISC_SHOWUIALL = unchecked((int)0xC000000F),
        IME_CHOTKEY_IME_NONIME_TOGGLE = 0x10,
        IME_CHOTKEY_SHAPE_TOGGLE = 0x11,
        IME_CHOTKEY_SYMBOL_TOGGLE = 0x12,
        IME_JHOTKEY_CLOSE_OPEN = 0x30,
        IME_KHOTKEY_SHAPE_TOGGLE = 0x50,
        IME_KHOTKEY_HANJACONVERT = 0x51,
        IME_KHOTKEY_ENGLISH = 0x52,
        IME_THOTKEY_IME_NONIME_TOGGLE = 0x70,
        IME_THOTKEY_SHAPE_TOGGLE = 0x71,
        IME_THOTKEY_SYMBOL_TOGGLE = 0x72,
        IME_HOTKEY_DSWITCH_FIRST = 0x100,
        IME_HOTKEY_DSWITCH_LAST = 0x11F,
        IME_HOTKEY_PRIVATE_FIRST = 0x200,
        IME_ITHOTKEY_RESEND_RESULTSTR = 0x200,
        IME_ITHOTKEY_PREVIOUS_COMPOSITION = 0x201,
        IME_ITHOTKEY_UISTYLE_TOGGLE = 0x202,
        IME_HOTKEY_PRIVATE_LAST = 0x21F,
        IMEVER_0310 = 0x0003000A,
        IMEVER_0400 = 0x00040000,
        IME_PROP_AT_CARET = 0x00010000,
        IME_PROP_SPECIAL_UI = 0x00020000,
        IME_PROP_CANDLIST_START_FROM_1 = 0x00040000,
        IME_PROP_UNICODE = 0x00080000,
        IGP_PROPERTY = 0x00000004,
        IGP_CONVERSION = 0x00000008,
        IGP_SENTENCE = 0x0000000c,
        IGP_UI = 0x00000010,
        IGP_SETCOMPSTR = 0x00000014,
        IGP_SELECT = 0x00000018,
        IME_CMODE_ALPHANUMERIC = 0x0000,
        IME_CMODE_NATIVE = 0x0001,
        IME_CMODE_CHINESE = 0x0001,
        IME_CMODE_HANGEUL = 0x0001,
        IME_CMODE_HANGUL = 0x0001,
        IME_CMODE_JAPANESE = 0x0001,
        IME_CMODE_KATAKANA = 0x0002,
        IME_CMODE_LANGUAGE = 0x0003,
        IME_CMODE_FULLSHAPE = 0x0008,
        IME_CMODE_ROMAN = 0x0010,
        IME_CMODE_CHARCODE = 0x0020,
        IME_CMODE_HANJACONVERT = 0x0040,
        IME_CMODE_SOFTKBD = 0x0080,
        IME_CMODE_NOCONVERSION = 0x0100,
        IME_CMODE_EUDC = 0x0200,
        IME_CMODE_SYMBOL = 0x0400,
        IME_SMODE_NONE = 0x0000,
        IME_SMODE_PLAURALCLAUSE = 0x0001,
        IME_SMODE_SINGLECONVERT = 0x0002,
        IME_SMODE_AUTOMATIC = 0x0004,
        IME_SMODE_PHRASEPREDICT = 0x0008,
        IME_CAND_UNKNOWN = 0x0000,
        IME_CAND_READ = 0x0001,
        IME_CAND_CODE = 0x0002,
        IME_CAND_MEANING = 0x0003,
        IME_CAND_RADICAL = 0x0004,
        IME_CAND_STROKE = 0x0005,
        IMN_CLOSESTATUSWINDOW = 0x0001,
        IMN_OPENSTATUSWINDOW = 0x0002,
        IMN_CHANGECANDIDATE = 0x0003,
        IMN_CLOSECANDIDATE = 0x0004,
        IMN_OPENCANDIDATE = 0x0005,
        IMN_SETCONVERSIONMODE = 0x0006,
        IMN_SETSENTENCEMODE = 0x0007,
        IMN_SETOPENSTATUS = 0x0008,
        IMN_SETCANDIDATEPOS = 0x0009,
        IMN_SETCOMPOSITIONFONT = 0x000A,
        IMN_SETCOMPOSITIONWINDOW = 0x000B,
        IMN_SETSTATUSWINDOWPOS = 0x000C,
        IMN_GUIDELINE = 0x000D,
        IMN_PRIVATE = 0x000E,
        IMM_ERROR_NODATA = (-1),
                           IMM_ERROR_GENERAL = (-2),
                                               IME_CONFIG_GENERAL = 1,
        IME_CONFIG_REGISTERWORD = 2,
        IME_CONFIG_SELECTDICTIONARY = 3,
        IME_ESC_QUERY_SUPPORT = 0x0003,
        IME_ESC_RESERVED_FIRST = 0x0004,
        IME_ESC_RESERVED_LAST = 0x07FF,
        IME_ESC_PRIVATE_FIRST = 0x0800,
        IME_ESC_PRIVATE_LAST = 0x0FFF,
        IME_ESC_SEQUENCE_TO_INTERNAL = 0x1001,
        IME_ESC_GET_EUDC_DICTIONARY = 0x1003,
        IME_ESC_SET_EUDC_DICTIONARY = 0x1004,
        IME_ESC_MAX_KEY = 0x1005,
        IME_ESC_IME_NAME = 0x1006,
        IME_ESC_SYNC_HOTKEY = 0x1007,
        IME_ESC_HANJA_MODE = 0x1008,
        IME_ESC_AUTOMATA = 0x1009,
        IME_ESC_PRIVATE_HOTKEY = 0x100a,
        IME_REGWORD_STYLE_EUDC = 0x00000001,
        IME_REGWORD_STYLE_USER_FIRST = unchecked((int)0x80000000),
        IME_REGWORD_STYLE_USER_LAST = unchecked((int)0xFFFFFFFF),
        IDLFLAG_NONE = ((0)),
                       IDLFLAG_FIN = ((0x1)),
                                     IDLFLAG_FOUT = ((0x2)),
                                                    IDLFLAG_FLCID = ((0x4)),
                                                                    IDLFLAG_FRETVAL = ((unchecked((int)0x8))),
                                                                                      IMPLTYPEFLAG_FDEFAULT = (0x1),
                                                                                                              IMPLTYPEFLAG_FSOURCE = (0x2),
                                                                                                                                     IMPLTYPEFLAG_FRESTRICTED = (0x4),
                                                                                                                                                                IMPLTYPEFLAG_FDEFAULTVTABLE = (unchecked((int)0x8)),
                                                                                                                                                                                              ID_DEFAULTINST = -2,
        ID_PSRESTARTWINDOWS = 0x2,
        ID_PSREBOOTSYSTEM = (0x2|0x1),
                            IDLE_PRIORITY_CLASS = 0x00000040,
        IGNORE = 0,
        INFINITE = unchecked((int)0xFFFFFFFF),
        IE_BADID = (-1),
                   IE_OPEN = (-2),
                             IE_NOPEN = (-3),
                                        IE_MEMORY = (-4),
                                                    IE_DEFAULT = (-5),
                                                                 IE_HARDWARE = (-10),
                                                                               IE_BYTESIZE = (-11),
                                                                                             IE_BAUDRATE = (-12),
                                                                                                           INPLACE_E_NOTUNDOABLE = unchecked((int)0x800401A0),
        INPLACE_E_NOTOOLSPACE = unchecked((int)0x800401A1),
        INPLACE_E_FIRST = unchecked((int)0x800401A0),
        INPLACE_E_LAST = unchecked((int)0x800401AF),
        INPLACE_S_FIRST = 0x000401A0,
        INPLACE_S_LAST = 0x000401AF,
        INPLACE_S_TRUNCATED = 0x000401A0,
        INPUTLANGCHANGE_SYSCHARSET = 0x0001,
        INPUTLANGCHANGE_FORWARD    = 0x0002,
        INPUTLANGCHANGE_BACKWARD   = 0x0004,
        ILLUMINANT_DEVICE_DEFAULT = 0,
        ILLUMINANT_A = 1,
        ILLUMINANT_B = 2,
        ILLUMINANT_C = 3,
        ILLUMINANT_D50 = 4,
        ILLUMINANT_D55 = 5,
        ILLUMINANT_D65 = 6,
        ILLUMINANT_D75 = 7,
        ILLUMINANT_F2 = 8,
        ILLUMINANT_MAX_INDEX = 8,
        ILLUMINANT_TUNGSTEN = 1,
        ILLUMINANT_DAYLIGHT = 3,
        ILLUMINANT_FLUORESCENT = 8,
        ILLUMINANT_NTSC = 3,
        ICM_OFF = 1,
        ICM_ON = 2,
        ICM_QUERY = 3,
        IO_COMPLETION_MODIFY_STATE = 0x0002,
        INHERIT_ONLY_ACE = (unchecked((int)0x8)),
                           IMAGE_DOS_SIGNATURE = 0x5A4D,
        IMAGE_OS2_SIGNATURE = 0x454E,
        IMAGE_OS2_SIGNATURE_LE = 0x454C,
        IMAGE_VXD_SIGNATURE = 0x454C,
        IMAGE_NT_SIGNATURE = 0x00004550,
        IMAGE_SIZEOF_FILE_HEADER = 20,
        IMAGE_FILE_RELOCS_STRIPPED = 0x0001,
        IMAGE_FILE_LINE_NUMS_STRIPPED = 0x0004,
        IMAGE_FILE_LOCAL_SYMS_STRIPPED = 0x0008,
        IMAGE_FILE_AGGRESIVE_WS_TRIM = 0x0010,
        IMAGE_FILE_BYTES_REVERSED_LO = 0x0080,
        IMAGE_FILE_32BIT_MACHINE = 0x0100,
        IMAGE_FILE_DEBUG_STRIPPED = 0x0200,
        IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = 0x0400,
        IMAGE_FILE_NET_RUN_FROM_SWAP = 0x0800,
        IMAGE_FILE_SYSTEM = 0x1000,
        IMAGE_FILE_DLL = 0x2000,
        IMAGE_FILE_UP_SYSTEM_ONLY = 0x4000,
        IMAGE_FILE_BYTES_REVERSED_HI = unchecked((int)0x8000),
        IMAGE_FILE_MACHINE_UNKNOWN = 0,
        IMAGE_FILE_MACHINE_I386 = 0x14c,
        IMAGE_FILE_MACHINE_R3000 = 0x162,
        IMAGE_FILE_MACHINE_R4000 = 0x166,
        IMAGE_FILE_MACHINE_R10000 = 0x168,
        IMAGE_FILE_MACHINE_ALPHA = 0x184,
        IMAGE_FILE_MACHINE_POWERPC = 0x1F0,
        IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16,
        IMAGE_SIZEOF_ROM_OPTIONAL_HEADER = 56,
        IMAGE_SIZEOF_STD_OPTIONAL_HEADER = 28,
        IMAGE_SIZEOF_NT_OPTIONAL_HEADER = 224,
        IMAGE_NT_OPTIONAL_HDR_MAGIC = 0x10b,
        IMAGE_ROM_OPTIONAL_HDR_MAGIC = 0x107,
        IMAGE_SUBSYSTEM_UNKNOWN = 0,
        IMAGE_SUBSYSTEM_NATIVE = 1,
        IMAGE_SUBSYSTEM_WINDOWS_GUI = 2,
        IMAGE_SUBSYSTEM_WINDOWS_CUI = 3,
        IMAGE_SUBSYSTEM_OS2_CUI = 5,
        IMAGE_SUBSYSTEM_POSIX_CUI = 7,
        IMAGE_SUBSYSTEM_RESERVED8 = 8,
        IMAGE_DIRECTORY_ENTRY_EXPORT = 0,
        IMAGE_DIRECTORY_ENTRY_IMPORT = 1,
        IMAGE_DIRECTORY_ENTRY_RESOURCE = 2,
        IMAGE_DIRECTORY_ENTRY_EXCEPTION = 3,
        IMAGE_DIRECTORY_ENTRY_SECURITY = 4,
        IMAGE_DIRECTORY_ENTRY_BASERELOC = 5,
        IMAGE_DIRECTORY_ENTRY_DEBUG = 6,
        IMAGE_DIRECTORY_ENTRY_COPYRIGHT = 7,
        IMAGE_DIRECTORY_ENTRY_GLOBALPTR = 8,
        IMAGE_DIRECTORY_ENTRY_TLS = 9,
        IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG = 10,
        IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = 11,
        IMAGE_DIRECTORY_ENTRY_IAT = 12,
        IMAGE_SIZEOF_SHORT_NAME = 8,
        IMAGE_SIZEOF_SECTION_HEADER = 40,
        IMAGE_SCN_TYPE_NO_PAD = 0x00000008,
        IMAGE_SCN_CNT_CODE = 0x00000020,
        IMAGE_SCN_CNT_INITIALIZED_DATA = 0x00000040,
        IMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x00000080,
        IMAGE_SCN_LNK_OTHER = 0x00000100,
        IMAGE_SCN_LNK_INFO = 0x00000200,
        IMAGE_SCN_LNK_REMOVE = 0x00000800,
        IMAGE_SCN_LNK_COMDAT = 0x00001000,
        IMAGE_SCN_MEM_FARDATA = 0x00008000,
        IMAGE_SCN_MEM_PURGEABLE = 0x00020000,
        IMAGE_SCN_MEM_16BIT = 0x00020000,
        IMAGE_SCN_MEM_LOCKED = 0x00040000,
        IMAGE_SCN_MEM_PRELOAD = 0x00080000,
        IMAGE_SCN_ALIGN_1BYTES = 0x00100000,
        IMAGE_SCN_ALIGN_2BYTES = 0x00200000,
        IMAGE_SCN_ALIGN_4BYTES = 0x00300000,
        IMAGE_SCN_ALIGN_8BYTES = 0x00400000,
        IMAGE_SCN_ALIGN_16BYTES = 0x00500000,
        IMAGE_SCN_ALIGN_32BYTES = 0x00600000,
        IMAGE_SCN_ALIGN_64BYTES = 0x00700000,
        IMAGE_SCN_LNK_NRELOC_OVFL = 0x01000000,
        IMAGE_SCN_MEM_DISCARDABLE = 0x02000000,
        IMAGE_SCN_MEM_NOT_CACHED = 0x04000000,
        IMAGE_SCN_MEM_NOT_PAGED = 0x08000000,
        IMAGE_SCN_MEM_SHARED = 0x10000000,
        IMAGE_SCN_MEM_EXECUTE = 0x20000000,
        IMAGE_SCN_MEM_READ = 0x40000000,
        IMAGE_SCN_MEM_WRITE = unchecked((int)0x80000000),
        IMAGE_SCN_SCALE_INDEX = 0x00000001,
        IMAGE_SIZEOF_SYMBOL = 18,
        IMAGE_SYM_TYPE_NULL = 0x0000,
        IMAGE_SYM_TYPE_VOID = 0x0001,
        IMAGE_SYM_TYPE_CHAR = 0x0002,
        IMAGE_SYM_TYPE_SHORT = 0x0003,
        IMAGE_SYM_TYPE_INT = 0x0004,
        IMAGE_SYM_TYPE_LONG = 0x0005,
        IMAGE_SYM_TYPE_FLOAT = 0x0006,
        IMAGE_SYM_TYPE_DOUBLE = 0x0007,
        IMAGE_SYM_TYPE_STRUCT = 0x0008,
        IMAGE_SYM_TYPE_UNION = 0x0009,
        IMAGE_SYM_TYPE_ENUM = 0x000A,
        IMAGE_SYM_TYPE_MOE = 0x000B,
        IMAGE_SYM_TYPE_BYTE = 0x000C,
        IMAGE_SYM_TYPE_WORD = 0x000D,
        IMAGE_SYM_TYPE_UINT = 0x000E,
        IMAGE_SYM_TYPE_DWORD = 0x000F,
        IMAGE_SYM_TYPE_PCODE = unchecked((int)0x8000),
        IMAGE_SYM_DTYPE_NULL = 0,
        IMAGE_SYM_DTYPE_POINTER = 1,
        IMAGE_SYM_DTYPE_FUNCTION = 2,
        IMAGE_SYM_DTYPE_ARRAY = 3,
        IMAGE_SYM_CLASS_NULL = 0x0000,
        IMAGE_SYM_CLASS_AUTOMATIC = 0x0001,
        IMAGE_SYM_CLASS_STATIC = 0x0003,
        IMAGE_SYM_CLASS_REGISTER = 0x0004,
        IMAGE_SYM_CLASS_LABEL = 0x0006,
        IMAGE_SYM_CLASS_UNDEFINED_LABEL = 0x0007,
        IMAGE_SYM_CLASS_MEMBER_OF_STRUCT = 0x0008,
        IMAGE_SYM_CLASS_ARGUMENT = 0x0009,
        IMAGE_SYM_CLASS_STRUCT_TAG = 0x000A,
        IMAGE_SYM_CLASS_MEMBER_OF_UNION = 0x000B,
        IMAGE_SYM_CLASS_UNION_TAG = 0x000C,
        IMAGE_SYM_CLASS_TYPE_DEFINITION = 0x000D,
        IMAGE_SYM_CLASS_UNDEFINED_STATIC = 0x000E,
        IMAGE_SYM_CLASS_ENUM_TAG = 0x000F,
        IMAGE_SYM_CLASS_MEMBER_OF_ENUM = 0x0010,
        IMAGE_SYM_CLASS_REGISTER_PARAM = 0x0011,
        IMAGE_SYM_CLASS_BIT_FIELD = 0x0012,
        IMAGE_SYM_CLASS_BLOCK = 0x0064,
        IMAGE_SYM_CLASS_FUNCTION = 0x0065,
        IMAGE_SYM_CLASS_END_OF_STRUCT = 0x0066,
        IMAGE_SYM_CLASS_FILE = 0x0067,
        IMAGE_SYM_CLASS_SECTION = 0x0068,
        IMAGE_SIZEOF_AUX_SYMBOL = 18,
        IMAGE_COMDAT_SELECT_NODUPLICATES = 1,
        IMAGE_COMDAT_SELECT_ANY = 2,
        IMAGE_COMDAT_SELECT_SAME_SIZE = 3,
        IMAGE_COMDAT_SELECT_EXACT_MATCH = 4,
        IMAGE_COMDAT_SELECT_ASSOCIATIVE = 5,
        IMAGE_COMDAT_SELECT_LARGEST = 6,
        IMAGE_COMDAT_SELECT_NEWEST = 7,
        IMAGE_SIZEOF_RELOCATION = 10,
        IMAGE_REL_I386_ABSOLUTE = 0x0000,
        IMAGE_REL_I386_DIR16 = 0x0001,
        IMAGE_REL_I386_REL16 = 0x0002,
        IMAGE_REL_I386_DIR32 = 0x0006,
        IMAGE_REL_I386_DIR32NB = 0x0007,
        IMAGE_REL_I386_SEG12 = 0x0009,
        IMAGE_REL_I386_SECTION = 0x000A,
        IMAGE_REL_I386_SECREL = 0x000B,
        IMAGE_REL_I386_REL32 = 0x0014,
        IMAGE_REL_MIPS_ABSOLUTE = 0x0000,
        IMAGE_REL_MIPS_REFHALF = 0x0001,
        IMAGE_REL_MIPS_REFWORD = 0x0002,
        IMAGE_REL_MIPS_JMPADDR = 0x0003,
        IMAGE_REL_MIPS_REFHI = 0x0004,
        IMAGE_REL_MIPS_REFLO = 0x0005,
        IMAGE_REL_MIPS_GPREL = 0x0006,
        IMAGE_REL_MIPS_LITERAL = 0x0007,
        IMAGE_REL_MIPS_SECTION = 0x000A,
        IMAGE_REL_MIPS_SECREL = 0x000B,
        IMAGE_REL_MIPS_SECRELLO = 0x000C,
        IMAGE_REL_MIPS_SECRELHI = 0x000D,
        IMAGE_REL_MIPS_REFWORDNB = 0x0022,
        IMAGE_REL_MIPS_PAIR = 0x0025,
        IMAGE_REL_ALPHA_ABSOLUTE = 0x0000,
        IMAGE_REL_ALPHA_REFLONG = 0x0001,
        IMAGE_REL_ALPHA_REFQUAD = 0x0002,
        IMAGE_REL_ALPHA_GPREL32 = 0x0003,
        IMAGE_REL_ALPHA_LITERAL = 0x0004,
        IMAGE_REL_ALPHA_LITUSE = 0x0005,
        IMAGE_REL_ALPHA_GPDISP = 0x0006,
        IMAGE_REL_ALPHA_BRADDR = 0x0007,
        IMAGE_REL_ALPHA_HINT = 0x0008,
        IMAGE_REL_ALPHA_INLINE_REFLONG = 0x0009,
        IMAGE_REL_ALPHA_REFHI = 0x000A,
        IMAGE_REL_ALPHA_REFLO = 0x000B,
        IMAGE_REL_ALPHA_PAIR = 0x000C,
        IMAGE_REL_ALPHA_MATCH = 0x000D,
        IMAGE_REL_ALPHA_SECTION = 0x000E,
        IMAGE_REL_ALPHA_SECREL = 0x000F,
        IMAGE_REL_ALPHA_REFLONGNB = 0x0010,
        IMAGE_REL_ALPHA_SECRELLO = 0x0011,
        IMAGE_REL_ALPHA_SECRELHI = 0x0012,
        IMAGE_REL_PPC_ABSOLUTE = 0x0000,
        IMAGE_REL_PPC_ADDR64 = 0x0001,
        IMAGE_REL_PPC_ADDR32 = 0x0002,
        IMAGE_REL_PPC_ADDR24 = 0x0003,
        IMAGE_REL_PPC_ADDR16 = 0x0004,
        IMAGE_REL_PPC_ADDR14 = 0x0005,
        IMAGE_REL_PPC_REL24 = 0x0006,
        IMAGE_REL_PPC_REL14 = 0x0007,
        IMAGE_REL_PPC_TOCREL16 = 0x0008,
        IMAGE_REL_PPC_TOCREL14 = 0x0009,
        IMAGE_REL_PPC_ADDR32NB = 0x000A,
        IMAGE_REL_PPC_SECREL = 0x000B,
        IMAGE_REL_PPC_SECTION = 0x000C,
        IMAGE_REL_PPC_IFGLUE = 0x000D,
        IMAGE_REL_PPC_IMGLUE = 0x000E,
        IMAGE_REL_PPC_SECREL16 = 0x000F,
        IMAGE_REL_PPC_REFHI = 0x0010,
        IMAGE_REL_PPC_REFLO = 0x0011,
        IMAGE_REL_PPC_PAIR = 0x0012,
        IMAGE_REL_PPC_SECRELLO = 0x0013,
        IMAGE_REL_PPC_SECRELHI = 0x0014,
        IMAGE_REL_PPC_TYPEMASK = 0x00FF,
        IMAGE_REL_PPC_NEG = 0x0100,
        IMAGE_REL_PPC_BRTAKEN = 0x0200,
        IMAGE_REL_PPC_BRNTAKEN = 0x0400,
        IMAGE_REL_PPC_TOCDEFN = 0x0800,
        IMAGE_SIZEOF_LINENUMBER = 6,
        IMAGE_SIZEOF_BASE_RELOCATION = 8,
        IMAGE_REL_BASED_ABSOLUTE = 0,
        IMAGE_REL_BASED_HIGH = 1,
        IMAGE_REL_BASED_LOW = 2,
        IMAGE_REL_BASED_HIGHLOW = 3,
        IMAGE_REL_BASED_HIGHADJ = 4,
        IMAGE_REL_BASED_MIPS_JMPADDR = 5,
        IMAGE_REL_BASED_SECTION = 6,
        IMAGE_REL_BASED_REL32 = 7,
        IMAGE_ARCHIVE_START_SIZE = 8,
        IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR = 60,
        IMAGE_ORDINAL_FLAG = unchecked((int)0x80000000),
        IMAGE_RESOURCE_NAME_IS_STRING = unchecked((int)0x80000000),
        IMAGE_RESOURCE_DATA_IS_DIRECTORY = unchecked((int)0x80000000),
        IMAGE_DEBUG_TYPE_UNKNOWN = 0,
        IMAGE_DEBUG_TYPE_COFF = 1,
        IMAGE_DEBUG_TYPE_CODEVIEW = 2,
        IMAGE_DEBUG_TYPE_FPO = 3,
        IMAGE_DEBUG_TYPE_MISC = 4,
        IMAGE_DEBUG_TYPE_EXCEPTION = 5,
        IMAGE_DEBUG_TYPE_FIXUP = 6,
        IMAGE_DEBUG_TYPE_OMAP_TO_SRC = 7,
        IMAGE_DEBUG_TYPE_OMAP_FROM_SRC = 8,
        IMAGE_DEBUG_MISC_EXENAME = 1,
        IMAGE_SEPARATE_DEBUG_SIGNATURE = 0x4944,
        IMAGE_SEPARATE_DEBUG_FLAGS_MASK = unchecked((int)0x8000),
        IMAGE_SEPARATE_DEBUG_MISMATCH = unchecked((int)0x8000),
        IS_TEXT_UNICODE_ASCII16 = 0x0001,
        IS_TEXT_UNICODE_REVERSE_ASCII16 = 0x0010,
        IS_TEXT_UNICODE_STATISTICS = 0x0002,
        IS_TEXT_UNICODE_REVERSE_STATISTICS = 0x0020,
        IS_TEXT_UNICODE_CONTROLS = 0x0004,
        IS_TEXT_UNICODE_REVERSE_CONTROLS = 0x0040,
        IS_TEXT_UNICODE_SIGNATURE = 0x0008,
        IS_TEXT_UNICODE_REVERSE_SIGNATURE = 0x0080,
        IS_TEXT_UNICODE_ILLEGAL_CHARS = 0x0100,
        IS_TEXT_UNICODE_ODD_LENGTH = 0x0200,
        IS_TEXT_UNICODE_DBCS_LEADBYTE = 0x0400,
        IS_TEXT_UNICODE_NULL_BYTES = 0x1000,
        IS_TEXT_UNICODE_UNICODE_MASK = 0x000F,
        IS_TEXT_UNICODE_REVERSE_MASK = 0x00F0,
        IS_TEXT_UNICODE_NOT_UNICODE_MASK = 0x0F00,
        IS_TEXT_UNICODE_NOT_ASCII_MASK = 0xF000,
        ICON_SMALL = 0,
        ICON_BIG = 1,
        IDANI_OPEN = 1,
        IDANI_CLOSE = 2,
        IDANI_CAPTION = 3,
        IDHOT_SNAPWINDOW = (-1),
                           IDHOT_SNAPDESKTOP = (-2),
                                               IDC_ARROW = 32512,
        IDC_IBEAM = 32513,
        IDC_WAIT = 32514,
        IDC_CROSS = 32515,
        IDC_UPARROW = 32516,
        IDC_SIZE = 32640,
        IDC_ICON = 32641,
        IDC_SIZENWSE = 32642,
        IDC_SIZENESW = 32643,
        IDC_SIZEWE = 32644,
        IDC_SIZENS = 32645,
        IDC_SIZEALL = 32646,
        IDC_NO = 32648,
        IDC_APPSTARTING = 32650,
        IDC_HELP = 32651,
        IMAGE_BITMAP = 0,
        IMAGE_ICON = 1,
        IMAGE_CURSOR = 2,
        IMAGE_ENHMETAFILE = 3,
        IDI_APPLICATION = 32512,
        IDI_HAND = 32513,
        IDI_QUESTION = 32514,
        IDI_EXCLAMATION = 32515,
        IDI_ASTERISK = 32516,
        IDI_WINLOGO = 32517,
        IDI_WARNING = 32515,
        IDI_ERROR = 32513,
        IDI_INFORMATION = 32516,
        IDOK = 1,
        IDCANCEL = 2,
        IDABORT = 3,
        IDRETRY = 4,
        IDIGNORE = 5,
        IDYES = 6,
        IDNO = 7,
        IDCLOSE = 8,
        IDHELP = 9,
        IDH_NO_HELP = 28440,
        IDH_MISSING_CONTEXT = 28441,
        IDH_GENERIC_HELP_BUTTON = 28442,
        IDH_OK = 28443,
        IDH_CANCEL = 28444,
        IDH_HELP = 28445,
        ICC_LISTVIEW_CLASSES = 0x00000001,
        ICC_TREEVIEW_CLASSES = 0x00000002,
        ICC_BAR_CLASSES = 0x00000004,
        ICC_TAB_CLASSES = 0x00000008,
        ICC_UPDOWN_CLASS = 0x00000010,
        ICC_PROGRESS_CLASS = 0x00000020,
        ICC_HOTKEY_CLASS = 0x00000040,
        ICC_ANIMATE_CLASS = 0x00000080,
        ICC_WIN95_CLASSES = 0x000000FF,
        ICC_DATE_CLASSES = 0x00000100,
        ICC_USEREX_CLASSES = 0x00000200,
        ICC_COOL_CLASSES = 0x00000400,
        ILC_MASK = 0x0001,
        ILC_COLOR = 0x0000,
        ILC_COLORDDB = 0x00FE,
        ILC_COLOR4 = 0x0004,
        ILC_COLOR8 = 0x0008,
        ILC_COLOR16 = 0x0010,
        ILC_COLOR24 = 0x0018,
        ILC_COLOR32 = 0x0020,
        ILC_PALETTE = 0x0800,
        ILD_NORMAL = 0x0000,
        ILD_TRANSPARENT = 0x0001,
        ILD_MASK = 0x0010,
        ILD_IMAGE = 0x0020,
        ILD_ROP = 0x0040,
        ILD_BLEND25 = 0x0002,
        ILD_BLEND50 = 0x0004,
        ILD_OVERLAYMASK = 0x0F00,
        ILD_SELECTED = 0x0004,
        ILD_FOCUS = 0x0002,
        ILD_BLEND = 0x0004,
        ILCF_MOVE = (0x00000000),
                    ILCF_SWAP = (0x00000001),
                                IDB_STD_SMALL_COLOR = 0,
        IDB_STD_LARGE_COLOR = 1,
        IDB_VIEW_SMALL_COLOR = 4,
        IDB_VIEW_LARGE_COLOR = 5,
        IDB_HIST_SMALL_COLOR = 8,
        IDB_HIST_LARGE_COLOR = 9,
        I_INDENTCALLBACK = (-1),
                           I_IMAGECALLBACK = (-1),
                                             I_CHILDRENCALLBACK = (-1),
                                                                  IO_COMPLETION_ALL_ACCESS = ((0x000F0000)|(0x00100000)|0x3),
                                                                                             INVALID_HANDLE_VALUE = (-1),
                                                                                                                    IPN_FIRST = (0-860),
                                                                                                                                IPN_LAST = (0-879);


        public const int JOYERR_BASE = 160,
        JOYERR_NOERROR = (0),
                         JOYERR_PARMS = (160+5),
                                        JOYERR_NOCANDO = (160+6),
                                                         JOYERR_UNPLUGGED = (160+7),
                                                                            JOY_BUTTON1 = 0x0001,
        JOY_BUTTON2 = 0x0002,
        JOY_BUTTON3 = 0x0004,
        JOY_BUTTON4 = 0x0008,
        JOY_BUTTON1CHG = 0x0100,
        JOY_BUTTON2CHG = 0x0200,
        JOY_BUTTON3CHG = 0x0400,
        JOY_BUTTON4CHG = 0x0800,
        JOY_BUTTON5 = 0x00000010,
        JOY_BUTTON6 = 0x00000020,
        JOY_BUTTON7 = 0x00000040,
        JOY_BUTTON8 = 0x00000080,
        JOY_BUTTON9 = 0x00000100,
        JOY_BUTTON10 = 0x00000200,
        JOY_BUTTON11 = 0x00000400,
        JOY_BUTTON12 = 0x00000800,
        JOY_BUTTON13 = 0x00001000,
        JOY_BUTTON14 = 0x00002000,
        JOY_BUTTON15 = 0x00004000,
        JOY_BUTTON16 = 0x00008000,
        JOY_BUTTON17 = 0x00010000,
        JOY_BUTTON18 = 0x00020000,
        JOY_BUTTON19 = 0x00040000,
        JOY_BUTTON20 = 0x00080000,
        JOY_BUTTON21 = 0x00100000,
        JOY_BUTTON22 = 0x00200000,
        JOY_BUTTON23 = 0x00400000,
        JOY_BUTTON24 = 0x00800000,
        JOY_BUTTON25 = 0x01000000,
        JOY_BUTTON26 = 0x02000000,
        JOY_BUTTON27 = 0x04000000,
        JOY_BUTTON28 = 0x08000000,
        JOY_BUTTON29 = 0x10000000,
        JOY_BUTTON30 = 0x20000000,
        JOY_BUTTON31 = 0x40000000,
        JOY_BUTTON32 = unchecked((int)0x80000000),
        JOY_POVFORWARD = 0,
        JOY_POVRIGHT = 9000,
        JOY_POVBACKWARD = 18000,
        JOY_POVLEFT = 27000,
        JOY_RETURNX = 0x00000001,
        JOY_RETURNY = 0x00000002,
        JOY_RETURNZ = 0x00000004,
        JOY_RETURNR = 0x00000008,
        JOY_RETURNU = 0x00000010,
        JOY_RETURNV = 0x00000020,
        JOY_RETURNPOV = 0x00000040,
        JOY_RETURNBUTTONS = 0x00000080,
        JOY_RETURNRAWDATA = 0x00000100,
        JOY_RETURNPOVCTS = 0x00000200,
        JOY_RETURNCENTERED = 0x00000400,
        JOY_USEDEADZONE = 0x00000800,
        JOY_CAL_READALWAYS = 0x00010000,
        JOY_CAL_READXYONLY = 0x00020000,
        JOY_CAL_READ3 = 0x00040000,
        JOY_CAL_READ4 = 0x00080000,
        JOY_CAL_READXONLY = 0x00100000,
        JOY_CAL_READYONLY = 0x00200000,
        JOY_CAL_READ5 = 0x00400000,
        JOY_CAL_READ6 = 0x00800000,
        JOY_CAL_READZONLY = 0x01000000,
        JOY_CAL_READRONLY = 0x02000000,
        JOY_CAL_READUONLY = 0x04000000,
        JOY_CAL_READVONLY = 0x08000000,
        JOYSTICKID1 = 0,
        JOYSTICKID2 = 1,
        JOYCAPS_HASZ = 0x0001,
        JOYCAPS_HASR = 0x0002,
        JOYCAPS_HASU = 0x0004,
        JOYCAPS_HASV = 0x0008,
        JOYCAPS_HASPOV = 0x0010,
        JOYCAPS_POV4DIR = 0x0020,
        JOYCAPS_POVCTS = 0x0040,
        JOHAB_CHARSET = 130,
        JOB_CONTROL_PAUSE = 1,
        JOB_CONTROL_RESUME = 2,
        JOB_CONTROL_CANCEL = 3,
        JOB_CONTROL_RESTART = 4,
        JOB_CONTROL_DELETE = 5,
        JOB_CONTROL_SENT_TO_PRINTER = 6,
        JOB_CONTROL_LAST_PAGE_EJECTED = 7,
        JOB_STATUS_PAUSED = 0x00000001,
        JOB_STATUS_ERROR = 0x00000002,
        JOB_STATUS_DELETING = 0x00000004,
        JOB_STATUS_SPOOLING = 0x00000008,
        JOB_STATUS_PRINTING = 0x00000010,
        JOB_STATUS_OFFLINE = 0x00000020,
        JOB_STATUS_PAPEROUT = 0x00000040,
        JOB_STATUS_PRINTED = 0x00000080,
        JOB_STATUS_DELETED = 0x00000100,
        JOB_STATUS_BLOCKED_DEVQ = 0x00000200,
        JOB_STATUS_USER_INTERVENTION = 0x00000400,
        JOB_STATUS_RESTART = 0x00000800,
        JOB_POSITION_UNSPECIFIED = 0,
        JOB_NOTIFY_TYPE = 0x01,
        JOB_NOTIFY_FIELD_PRINTER_NAME = 0x00,
        JOB_NOTIFY_FIELD_MACHINE_NAME = 0x01,
        JOB_NOTIFY_FIELD_PORT_NAME = 0x02,
        JOB_NOTIFY_FIELD_USER_NAME = 0x03,
        JOB_NOTIFY_FIELD_NOTIFY_NAME = 0x04,
        JOB_NOTIFY_FIELD_DATATYPE = 0x05,
        JOB_NOTIFY_FIELD_PRINT_PROCESSOR = 0x06,
        JOB_NOTIFY_FIELD_PARAMETERS = 0x07,
        JOB_NOTIFY_FIELD_DRIVER_NAME = 0x08,
        JOB_NOTIFY_FIELD_DEVMODE = 0x09,
        JOB_NOTIFY_FIELD_STATUS = 0x0A,
        JOB_NOTIFY_FIELD_STATUS_STRING = 0x0B,
        JOB_NOTIFY_FIELD_SECURITY_DESCRIPTOR = 0x0C,
        JOB_NOTIFY_FIELD_DOCUMENT = 0x0D,
        JOB_NOTIFY_FIELD_PRIORITY = 0x0E,
        JOB_NOTIFY_FIELD_POSITION = 0x0F,
        JOB_NOTIFY_FIELD_SUBMITTED = 0x10,
        JOB_NOTIFY_FIELD_START_TIME = 0x11,
        JOB_NOTIFY_FIELD_UNTIL_TIME = 0x12,
        JOB_NOTIFY_FIELD_TIME = 0x13,
        JOB_NOTIFY_FIELD_TOTAL_PAGES = 0x14,
        JOB_NOTIFY_FIELD_PAGES_PRINTED = 0x15,
        JOB_NOTIFY_FIELD_TOTAL_BYTES = 0x16,
        JOB_NOTIFY_FIELD_BYTES_PRINTED = 0x17,
        JOB_ACCESS_ADMINISTER = 0x00000010;



        public const int KEY_EVENT = 0x0001,
        KP_IV = 1,
        KP_SALT = 2,
        KP_PADDING = 3,
        KP_MODE = 4,
        KP_MODE_BITS = 5,
        KP_PERMISSIONS = 6,
        KP_ALGID = 7,
        KP_BLOCKLEN = 8,
        KEY_QUERY_VALUE = (0x0001),
                          KEY_SET_VALUE = (0x0002),
                                          KEY_CREATE_SUB_KEY = (0x0004),
                                                               KEY_ENUMERATE_SUB_KEYS = (0x0008),
                                                                                        KEY_NOTIFY = (0x0010),
                                                                                                     KEY_CREATE_LINK = (0x0020),
                                                                                                                       KF_EXTENDED = 0x0100,
        KF_DLGMODE = 0x0800,
        KF_MENUMODE = 0x1000,
        KF_ALTDOWN = 0x2000,
        KF_REPEAT = 0x4000,
        KF_UP = unchecked((int)0x8000),
        KLF_ACTIVATE = 0x00000001,
        KLF_SUBSTITUTE_OK = 0x00000002,
        KLF_UNLOADPREVIOUS = 0x00000004,
        KLF_REORDER = 0x00000008,
        KLF_REPLACELANG = 0x00000010,
        KLF_NOTELLSHELL = 0x00000080,
        KL_NAMELENGTH = 9,
        KEYEVENTF_EXTENDEDKEY = 0x0001,
        KEYEVENTF_KEYUP = 0x0002;


        public const int lst1 = 0x0460,
        lst2 = 0x0461,
        lst3 = 0x0462,
        lst4 = 0x0463,
        lst5 = 0x0464,
        lst6 = 0x0465,
        lst7 = 0x0466,
        lst8 = 0x0467,
        lst9 = 0x0468,
        lst10 = 0x0469,
        lst11 = 0x046a,
        lst12 = 0x046b,
        lst13 = 0x046c,
        lst14 = 0x046d,
        lst15 = 0x046e,
        lst16 = 0x046f,
        LZERROR_BADINHANDLE = (-1),
                              LZERROR_BADOUTHANDLE = (-2),
                                                     LZERROR_READ = (-3),
                                                                    LZERROR_WRITE = (-4),
                                                                                    LZERROR_GLOBALLOC = (-5),
                                                                                                        LZERROR_GLOBLOCK = (-6),
                                                                                                                           LZERROR_BADVALUE = (-7),
                                                                                                                                              LZERROR_UNKNOWNALG = (-8),
                                                                                                                                                                   LISTEN_OUTSTANDING = 0x01,
        LMEM_FIXED = 0x0000,
        LMEM_MOVEABLE = 0x0002,
        LMEM_NOCOMPACT = 0x0010,
        LMEM_NODISCARD = 0x0020,
        LMEM_ZEROINIT = 0x0040,
        LMEM_MODIFY = 0x0080,
        LMEM_DISCARDABLE = 0x0F00,
        LMEM_VALID_FLAGS = 0x0F72,
        LMEM_INVALID_HANDLE = unchecked((int)0x8000),
        LHND = (0x0002|0x0040),
               LPTR = (0x0000|0x0040),
                      LMEM_DISCARDED = 0x4000,
        LMEM_LOCKCOUNT = 0x00FF,
        LOAD_DLL_DEBUG_EVENT = 6,
        LPTx = unchecked((int)0x80),
        LOCKFILE_FAIL_IMMEDIATELY = 0x00000001,
        LOCKFILE_EXCLUSIVE_LOCK = 0x00000002,
        LOAD_LIBRARY_AS_DATAFILE = 0x00000002,
        LOAD_WITH_ALTERED_SEARCH_PATH = 0x00000008,
        LOGON32_LOGON_INTERACTIVE = 2,
        LOGON32_LOGON_NETWORK = 3,
        LOGON32_LOGON_BATCH = 4,
        LOGON32_LOGON_SERVICE = 5,
        LOGON32_PROVIDER_DEFAULT = 0,
        LOGON32_PROVIDER_WINNT35 = 1,
        LOGON32_PROVIDER_WINNT40 = 2,
        LEFT_ALT_PRESSED = 0x0002,
        LEFT_CTRL_PRESSED = 0x0008,
        LCS_CALIBRATED_RGB = 0x00000000,
        LCS_DEVICE_RGB = 0x00000001,
        LCS_DEVICE_CMYK = 0x00000002,
        LCS_GM_BUSINESS = 0x00000001,
        LCS_GM_GRAPHICS = 0x00000002,
        LCS_GM_IMAGES = 0x00000004,
        LF_FACESIZE = 32,
        LF_FULLFACESIZE = 64,
        LTGRAY_BRUSH = 1,
        LINECAPS = 30,
        LOGPIXELSX = 88,
        LOGPIXELSY = 90,
        LC_NONE = 0,
        LC_POLYLINE = 2,
        LC_MARKER = 4,
        LC_POLYMARKER = 8,
        LC_WIDE = 16,
        LC_STYLED = 32,
        LC_WIDESTYLED = 64,
        LC_INTERIORS = 128,
        LPD_DOUBLEBUFFER = 0x00000001,
        LPD_STEREO = 0x00000002,
        LPD_SUPPORT_GDI = 0x00000010,
        LPD_SUPPORT_OPENGL = 0x00000020,
        LPD_SHARE_DEPTH = 0x00000040,
        LPD_SHARE_STENCIL = 0x00000080,
        LPD_SHARE_ACCUM = 0x00000100,
        LPD_SWAP_EXCHANGE = 0x00000200,
        LPD_SWAP_COPY = 0x00000400,
        LPD_TRANSPARENT = 0x00001000,
        LPD_TYPE_RGBA = 0,
        LPD_TYPE_COLORINDEX = 1,
        LPSTR_TEXTCALLBACK = -1,
        LCMAP_LOWERCASE = 0x00000100,
        LCMAP_UPPERCASE = 0x00000200,
        LCMAP_SORTKEY = 0x00000400,
        LCMAP_BYTEREV = 0x00000800,
        LCMAP_HIRAGANA = 0x00100000,
        LCMAP_KATAKANA = 0x00200000,
        LCMAP_HALFWIDTH = 0x00400000,
        LCMAP_FULLWIDTH = 0x00800000,
        LCMAP_LINGUISTIC_CASING = 0x01000000,
        LCMAP_SIMPLIFIED_CHINESE = 0x02000000,
        LCMAP_TRADITIONAL_CHINESE = 0x04000000,
        LCID_INSTALLED = 0x00000001,
        LCID_SUPPORTED = 0x00000002,
        LOCALE_NOUSEROVERRIDE = unchecked((int)0x80000000),
        LOCALE_USE_CP_ACP = 0x40000000,
        LOCALE_ILANGUAGE = 0x00000001,
        LOCALE_SLANGUAGE = 0x00000002,
        LOCALE_SENGLANGUAGE = 0x00001001,
        LOCALE_SABBREVLANGNAME = 0x00000003,
        LOCALE_SNATIVELANGNAME = 0x00000004,
        LOCALE_ICOUNTRY = 0x00000005,
        LOCALE_SCOUNTRY = 0x00000006,
        LOCALE_SENGCOUNTRY = 0x00001002,
        LOCALE_SABBREVCTRYNAME = 0x00000007,
        LOCALE_SNATIVECTRYNAME = 0x00000008,
        LOCALE_IDEFAULTLANGUAGE = 0x00000009,
        LOCALE_IDEFAULTCOUNTRY = 0x0000000A,
        LOCALE_IDEFAULTCODEPAGE = 0x0000000B,
        LOCALE_IDEFAULTANSICODEPAGE = 0x00001004,
        LOCALE_IDEFAULTMACCODEPAGE = 0x00001011,
        LOCALE_SLIST = 0x0000000C,
        LOCALE_IMEASURE = 0x0000000D,
        LOCALE_SDECIMAL = 0x0000000E,
        LOCALE_STHOUSAND = 0x0000000F,
        LOCALE_SGROUPING = 0x00000010,
        LOCALE_IDIGITS = 0x00000011,
        LOCALE_ILZERO = 0x00000012,
        LOCALE_INEGNUMBER = 0x00001010,
        LOCALE_SNATIVEDIGITS = 0x00000013,
        LOCALE_SCURRENCY = 0x00000014,
        LOCALE_SINTLSYMBOL = 0x00000015,
        LOCALE_SMONDECIMALSEP = 0x00000016,
        LOCALE_SMONTHOUSANDSEP = 0x00000017,
        LOCALE_SMONGROUPING = 0x00000018,
        LOCALE_ICURRDIGITS = 0x00000019,
        LOCALE_IINTLCURRDIGITS = 0x0000001A,
        LOCALE_ICURRENCY = 0x0000001B,
        LOCALE_INEGCURR = 0x0000001C,
        LOCALE_SDATE = 0x0000001D,
        LOCALE_STIME = 0x0000001E,
        LOCALE_SSHORTDATE = 0x0000001F,
        LOCALE_SLONGDATE = 0x00000020,
        LOCALE_STIMEFORMAT = 0x00001003,
        LOCALE_IDATE = 0x00000021,
        LOCALE_ILDATE = 0x00000022,
        LOCALE_ITIME = 0x00000023,
        LOCALE_ITIMEMARKPOSN = 0x00001005,
        LOCALE_ICENTURY = 0x00000024,
        LOCALE_ITLZERO = 0x00000025,
        LOCALE_IDAYLZERO = 0x00000026,
        LOCALE_IMONLZERO = 0x00000027,
        LOCALE_S1159 = 0x00000028,
        LOCALE_S2359 = 0x00000029,
        LOCALE_ICALENDARTYPE = 0x00001009,
        LOCALE_IOPTIONALCALENDAR = 0x0000100B,
        LOCALE_IFIRSTDAYOFWEEK = 0x0000100C,
        LOCALE_IFIRSTWEEKOFYEAR = 0x0000100D,
        LOCALE_SDAYNAME1 = 0x0000002A,
        LOCALE_SDAYNAME2 = 0x0000002B,
        LOCALE_SDAYNAME3 = 0x0000002C,
        LOCALE_SDAYNAME4 = 0x0000002D,
        LOCALE_SDAYNAME5 = 0x0000002E,
        LOCALE_SDAYNAME6 = 0x0000002F,
        LOCALE_SDAYNAME7 = 0x00000030,
        LOCALE_SABBREVDAYNAME1 = 0x00000031,
        LOCALE_SABBREVDAYNAME2 = 0x00000032,
        LOCALE_SABBREVDAYNAME3 = 0x00000033,
        LOCALE_SABBREVDAYNAME4 = 0x00000034,
        LOCALE_SABBREVDAYNAME5 = 0x00000035,
        LOCALE_SABBREVDAYNAME6 = 0x00000036,
        LOCALE_SABBREVDAYNAME7 = 0x00000037,
        LOCALE_SMONTHNAME1 = 0x00000038,
        LOCALE_SMONTHNAME2 = 0x00000039,
        LOCALE_SMONTHNAME3 = 0x0000003A,
        LOCALE_SMONTHNAME4 = 0x0000003B,
        LOCALE_SMONTHNAME5 = 0x0000003C,
        LOCALE_SMONTHNAME6 = 0x0000003D,
        LOCALE_SMONTHNAME7 = 0x0000003E,
        LOCALE_SMONTHNAME8 = 0x0000003F,
        LOCALE_SMONTHNAME9 = 0x00000040,
        LOCALE_SMONTHNAME10 = 0x00000041,
        LOCALE_SMONTHNAME11 = 0x00000042,
        LOCALE_SMONTHNAME12 = 0x00000043,
        LOCALE_SMONTHNAME13 = 0x0000100E,
        LOCALE_SABBREVMONTHNAME1 = 0x00000044,
        LOCALE_SABBREVMONTHNAME2 = 0x00000045,
        LOCALE_SABBREVMONTHNAME3 = 0x00000046,
        LOCALE_SABBREVMONTHNAME4 = 0x00000047,
        LOCALE_SABBREVMONTHNAME5 = 0x00000048,
        LOCALE_SABBREVMONTHNAME6 = 0x00000049,
        LOCALE_SABBREVMONTHNAME7 = 0x0000004A,
        LOCALE_SABBREVMONTHNAME8 = 0x0000004B,
        LOCALE_SABBREVMONTHNAME9 = 0x0000004C,
        LOCALE_SABBREVMONTHNAME10 = 0x0000004D,
        LOCALE_SABBREVMONTHNAME11 = 0x0000004E,
        LOCALE_SABBREVMONTHNAME12 = 0x0000004F,
        LOCALE_SABBREVMONTHNAME13 = 0x0000100F,
        LOCALE_SPOSITIVESIGN = 0x00000050,
        LOCALE_SNEGATIVESIGN = 0x00000051,
        LOCALE_IPOSSIGNPOSN = 0x00000052,
        LOCALE_INEGSIGNPOSN = 0x00000053,
        LOCALE_IPOSSYMPRECEDES = 0x00000054,
        LOCALE_IPOSSEPBYSPACE = 0x00000055,
        LOCALE_INEGSYMPRECEDES = 0x00000056,
        LOCALE_INEGSEPBYSPACE = 0x00000057,
        LOCALE_FONTSIGNATURE = 0x00000058,
        LOCALE_SISO639LANGNAME = 0x00000059,
        LOCALE_SISO3166CTRYNAME = 0x0000005A,
        LANG_NEUTRAL = 0x00,
        LANG_AFRIKAANS = 0x36,
        LANG_ALBANIAN = 0x1c,
        LANG_ARABIC = 0x01,
        LANG_BASQUE = 0x2d,
        LANG_BELARUSIAN = 0x23,
        LANG_BULGARIAN = 0x02,
        LANG_CATALAN = 0x03,
        LANG_CHINESE = 0x04,
        LANG_CROATIAN = 0x1a,
        LANG_CZECH = 0x05,
        LANG_DANISH = 0x06,
        LANG_DUTCH = 0x13,
        LANG_ENGLISH = 0x09,
        LANG_ESTONIAN = 0x25,
        LANG_FAEROESE = 0x38,
        LANG_FARSI = 0x29,
        LANG_FINNISH = 0x0b,
        LANG_FRENCH = 0x0c,
        LANG_GERMAN = 0x07,
        LANG_GREEK = 0x08,
        LANG_HEBREW = 0x0d,
        LANG_HUNGARIAN = 0x0e,
        LANG_ICELANDIC = 0x0f,
        LANG_INDONESIAN = 0x21,
        LANG_ITALIAN = 0x10,
        LANG_JAPANESE = 0x11,
        LANG_KOREAN = 0x12,
        LANG_LATVIAN = 0x26,
        LANG_LITHUANIAN = 0x27,
        LANG_NORWEGIAN = 0x14,
        LANG_POLISH = 0x15,
        LANG_PORTUGUESE = 0x16,
        LANG_ROMANIAN = 0x18,
        LANG_RUSSIAN = 0x19,
        LANG_SERBIAN = 0x1a,
        LANG_SLOVAK = 0x1b,
        LANG_SLOVENIAN = 0x24,
        LANG_SPANISH = 0x0a,
        LANG_SWEDISH = 0x1d,
        LANG_THAI = 0x1e,
        LANG_TURKISH = 0x1f,
        LANG_UKRAINIAN = 0x22,
        LANG_VIETNAMESE = 0x2a,
        LR_DEFAULTCOLOR = 0x0000,
        LR_MONOCHROME = 0x0001,
        LR_COLOR = 0x0002,
        LR_COPYRETURNORG = 0x0004,
        LR_COPYDELETEORG = 0x0008,
        LR_LOADFROMFILE = 0x0010,
        LR_LOADTRANSPARENT = 0x0020,
        LR_DEFAULTSIZE = 0x0040,
        LR_VGACOLOR = 0x0080,
        LR_LOADMAP3DCOLORS = 0x1000,
        LR_CREATEDIBSECTION = 0x2000,
        LR_COPYFROMRESOURCE = 0x4000,
        LR_SHARED = unchecked((int)0x8000),
        LB_CTLCODE = 0,
        LB_OKAY = 0,
        LB_ERR = (-1),
                 LB_ERRSPACE = (-2),
                               LBN_ERRSPACE = (-2),
                                              LBN_SELCHANGE = 1,
        LBN_DBLCLK = 2,
        LBN_SELCANCEL = 3,
        LBN_SETFOCUS = 4,
        LBN_KILLFOCUS = 5,
        LB_ADDSTRING = 0x0180,
        LB_INSERTSTRING = 0x0181,
        LB_DELETESTRING = 0x0182,
        LB_SELITEMRANGEEX = 0x0183,
        LB_RESETCONTENT = 0x0184,
        LB_SETSEL = 0x0185,
        LB_SETCURSEL = 0x0186,
        LB_GETSEL = 0x0187,
        LB_GETCURSEL = 0x0188,
        LB_GETTEXT = 0x0189,
        LB_GETTEXTLEN = 0x018A,
        LB_GETCOUNT = 0x018B,
        LB_SELECTSTRING = 0x018C,
        LB_DIR = 0x018D,
        LB_GETTOPINDEX = 0x018E,
        LB_FINDSTRING = 0x018F,
        LB_GETSELCOUNT = 0x0190,
        LB_GETSELITEMS = 0x0191,
        LB_SETTABSTOPS = 0x0192,
        LB_GETHORIZONTALEXTENT = 0x0193,
        LB_SETHORIZONTALEXTENT = 0x0194,
        LB_SETCOLUMNWIDTH = 0x0195,
        LB_ADDFILE = 0x0196,
        LB_SETTOPINDEX = 0x0197,
        LB_GETITEMRECT = 0x0198,
        LB_GETITEMDATA = 0x0199,
        LB_SETITEMDATA = 0x019A,
        LB_SELITEMRANGE = 0x019B,
        LB_SETANCHORINDEX = 0x019C,
        LB_GETANCHORINDEX = 0x019D,
        LB_SETCARETINDEX = 0x019E,
        LB_GETCARETINDEX = 0x019F,
        LB_SETITEMHEIGHT = 0x01A0,
        LB_GETITEMHEIGHT = 0x01A1,
        LB_FINDSTRINGEXACT = 0x01A2,
        LB_SETLOCALE = 0x01A5,
        LB_GETLOCALE = 0x01A6,
        LB_SETCOUNT = 0x01A7,
        LB_INITSTORAGE = 0x01A8,
        LB_ITEMFROMPOINT = 0x01A9,
        LB_MSGMAX = 0x01B0;
        // LB_MSGMAX = 0x01A8;
        public const int LBS_NOTIFY = 0x0001,
        LBS_SORT = 0x0002,
        LBS_NOREDRAW = 0x0004,
        LBS_MULTIPLESEL = 0x0008,
        LBS_OWNERDRAWFIXED = 0x0010,
        LBS_OWNERDRAWVARIABLE = 0x0020,
        LBS_HASSTRINGS = 0x0040,
        LBS_USETABSTOPS = 0x0080,
        LBS_NOINTEGRALHEIGHT = 0x0100,
        LBS_MULTICOLUMN = 0x0200,
        LBS_WANTKEYBOARDINPUT = 0x0400,
        LBS_EXTENDEDSEL = 0x0800,
        LBS_DISABLENOSCROLL = 0x1000,
        LBS_NODATA = 0x2000,
        LBS_NOSEL = 0x4000,
        LBS_STANDARD = (0x0001|0x0002|0x00200000|0x00800000),
                       LVM_FIRST = 0x1000,
        LVN_FIRST = (0-100),
                    LVN_LAST = (0-199),
                               LVS_ICON = 0x0000,
        LVS_REPORT = 0x0001,
        LVS_SMALLICON = 0x0002,
        LVS_LIST = 0x0003,
        LVS_TYPEMASK = 0x0003,
        LVS_SINGLESEL = 0x0004,
        LVS_SHOWSELALWAYS = 0x0008,
        LVS_SORTASCENDING = 0x0010,
        LVS_SORTDESCENDING = 0x0020,
        LVS_SHAREIMAGELISTS = 0x0040,
        LVS_NOLABELWRAP = 0x0080,
        LVS_AUTOARRANGE = 0x0100,
        LVS_EDITLABELS = 0x0200,
        LVS_OWNERDATA = 0x1000,
        LVS_NOSCROLL = 0x2000,
        LVS_TYPESTYLEMASK = 0xfc00,
        LVS_ALIGNTOP = 0x0000,
        LVS_ALIGNLEFT = 0x0800,
        LVS_ALIGNMASK = 0x0c00,
        LVS_OWNERDRAWFIXED = 0x0400,
        LVS_NOCOLUMNHEADER = 0x4000,
        LVS_NOSORTHEADER = unchecked((int)0x8000),
        LVM_GETBKCOLOR = (0x1000+0),
                         LVM_SETBKCOLOR = (0x1000+1),
                                          LVM_GETIMAGELIST = (0x1000+2),
                                                             LVSIL_NORMAL = 0,
        LVSIL_SMALL = 1,
        LVSIL_STATE = 2,
        LVM_SETIMAGELIST = (0x1000+3),
                           LVM_GETITEMCOUNT = (0x1000+4),
                                              LVIF_TEXT = 0x0001,
        LVIF_IMAGE = 0x0002,
        LVIF_PARAM = 0x0004,
        LVIF_STATE = 0x0008,
        LVIF_INDENT = 0x0010,
        LVIF_NORECOMPUTE = 0x0800,
        LVIS_FOCUSED = 0x0001,
        LVIS_SELECTED = 0x0002,
        LVIS_CUT = 0x0004,
        LVIS_DROPHILITED = 0x0008,
        LVIS_OVERLAYMASK = 0x0F00,
        LVIS_STATEIMAGEMASK = 0xF000,
        LVM_GETITEMA = (0x1000+5),
                       LVM_GETITEMW = (0x1000+75),
                                      LVM_SETITEMA = (0x1000+6),
                                                     LVM_SETITEMW = (0x1000+76),
                                                                    LVM_INSERTITEMA = (0x1000+7),
                                                                                      LVM_INSERTITEMW = (0x1000+77),
                                                                                                        LVM_DELETEITEM = (0x1000+8),
                                                                                                                         LVM_DELETEALLITEMS = (0x1000+9),
                                                                                                                                              LVM_GETCALLBACKMASK = (0x1000+10),
                                                                                                                                                                    LVM_SETCALLBACKMASK = (0x1000+11),
                                                                                                                                                                                          LVNI_ALL = 0x0000,
        LVNI_FOCUSED = 0x0001,
        LVNI_SELECTED = 0x0002,
        LVNI_CUT = 0x0004,
        LVNI_DROPHILITED = 0x0008,
        LVNI_ABOVE = 0x0100,
        LVNI_BELOW = 0x0200,
        LVNI_TOLEFT = 0x0400,
        LVNI_TORIGHT = 0x0800,
        LVM_GETNEXTITEM = (0x1000+12),
                          LVFI_PARAM = 0x0001,
        LVFI_STRING = 0x0002,
        LVFI_PARTIAL = 0x0008,
        LVFI_WRAP = 0x0020,
        LVFI_NEARESTXY = 0x0040,
        LVM_FINDITEMA = (0x1000+13),
                        LVM_FINDITEMW = (0x1000+83),
                                        LVIR_BOUNDS = 0,
        LVIR_ICON = 1,
        LVIR_LABEL = 2,
        LVIR_SELECTBOUNDS = 3,
        LVM_GETITEMRECT = (0x1000+14),
                          LVM_SETITEMPOSITION = (0x1000+15),
                                                LVM_GETITEMPOSITION = (0x1000+16),
                                                                      LVM_GETSTRINGWIDTHA = (0x1000+17),
                                                                                            LVM_GETSTRINGWIDTHW = (0x1000+87),
                                                                                                                  LVHT_NOWHERE = 0x0001,
        LVHT_ONITEMICON = 0x0002,
        LVHT_ONITEMLABEL = 0x0004,
        LVHT_ONITEMSTATEICON = 0x0008,
        LVHT_ONITEM = (0x0002|0x0004|0x0008),
                      LVHT_ABOVE = 0x0008,
        LVHT_BELOW = 0x0010,
        LVHT_TORIGHT = 0x0020,
        LVHT_TOLEFT = 0x0040,
        LVM_HITTEST = (0x1000+18),
                      LVM_ENSUREVISIBLE = (0x1000+19),
                                          LVM_SCROLL = (0x1000+20),
                                                       LVM_REDRAWITEMS = (0x1000+21),
                                                                         LVA_DEFAULT = 0x0000,
        LVA_ALIGNLEFT = 0x0001,
        LVA_ALIGNTOP = 0x0002,
        LVA_SNAPTOGRID = 0x0005,
        LVM_ARRANGE = (0x1000+22),
                      LVM_EDITLABELA = (0x1000+23),
                                       LVM_EDITLABELW = (0x1000+118),
                                                        LVM_GETEDITCONTROL = (0x1000+24),
                                                                             LVCF_FMT = 0x0001,
        LVCF_WIDTH = 0x0002,
        LVCF_TEXT = 0x0004,
        LVCF_SUBITEM = 0x0008,
        LVCF_IMAGE = 0x0010,
        LVCF_ORDER = 0x0020,
        LVCFMT_LEFT = 0x0000,
        LVCFMT_RIGHT = 0x0001,
        LVCFMT_CENTER = 0x0002,
        LVCFMT_JUSTIFYMASK = 0x0003,
        LVCFMT_IMAGE = 0x0800,
        LVCFMT_BITMAP_ON_RIGHT = 0x1000,
        LVCFMT_COL_HAS_IMAGES = unchecked((int)0x8000),
        LVM_GETCOLUMNA = (0x1000+25),
                         LVM_GETCOLUMNW = (0x1000+95),
                                          LVM_SETCOLUMNA = (0x1000+26),
                                                           LVM_SETCOLUMNW = (0x1000+96),
                                                                            LVM_INSERTCOLUMNA = (0x1000+27),
                                                                                                LVM_INSERTCOLUMNW = (0x1000+97),
                                                                                                                    LVM_DELETECOLUMN = (0x1000+28),
                                                                                                                                       LVM_GETCOLUMNWIDTH = (0x1000+29),
                                                                                                                                                            LVSCW_AUTOSIZE = -1,
        LVSCW_AUTOSIZE_USEHEADER = -2,
        LVM_SETCOLUMNWIDTH = (0x1000+30),
                             LVM_GETHEADER = (0x1000+31),
                                             LVM_CREATEDRAGIMAGE = (0x1000+33),
                                                                   LVM_GETVIEWRECT = (0x1000+34),
                                                                                     LVM_GETTEXTCOLOR = (0x1000+35),
                                                                                                        LVM_SETTEXTCOLOR = (0x1000+36),
                                                                                                                           LVM_GETTEXTBKCOLOR = (0x1000+37),
                                                                                                                                                LVM_SETTEXTBKCOLOR = (0x1000+38),
                                                                                                                                                                     LVM_GETTOPINDEX = (0x1000+39),
                                                                                                                                                                                       LVM_GETCOUNTPERPAGE = (0x1000+40),
                                                                                                                                                                                                             LVM_GETORIGIN = (0x1000+41),
                                                                                                                                                                                                                             LVM_UPDATE = (0x1000+42),
                                                                                                                                                                                                                                          LVM_SETITEMSTATE = (0x1000+43),
                                                                                                                                                                                                                                                             LVM_GETITEMSTATE = (0x1000+44),
                                                                                                                                                                                                                                                                                LVM_GETITEMTEXTA = (0x1000+45),
                                                                                                                                                                                                                                                                                                   LVM_GETITEMTEXTW = (0x1000+115),
                                                                                                                                                                                                                                                                                                                      LVM_SETITEMTEXTA = (0x1000+46),
                                                                                                                                                                                                                                                                                                                                         LVM_SETITEMTEXTW = (0x1000+116),
                                                                                                                                                                                                                                                                                                                                                            LVSICF_NOINVALIDATEALL = 0x00000001,
        LVSICF_NOSCROLL = 0x00000002,
        LVM_SETITEMCOUNT = (0x1000+47),
                           LVM_SORTITEMS = (0x1000+48),
                                           LVM_SETITEMPOSITION32 = (0x1000+49),
                                                                   LVM_GETSELECTEDCOUNT = (0x1000+50),
                                                                                          LVM_GETITEMSPACING = (0x1000+51),
                                                                                                               LVM_GETISEARCHSTRINGA = (0x1000+52),
                                                                                                                                       LVM_GETISEARCHSTRINGW = (0x1000+117),
                                                                                                                                                               LVM_SETICONSPACING = (0x1000+53),
                                                                                                                                                                                    LVM_SETEXTENDEDLISTVIEWSTYLE = (0x1000+54),
                                                                                                                                                                                                                   LVM_GETEXTENDEDLISTVIEWSTYLE = (0x1000+55),
                                                                                                                                                                                                                                                  LVS_EX_GRIDLINES = 0x00000001,
        LVS_EX_SUBITEMIMAGES = 0x00000002,
        LVS_EX_CHECKBOXES = 0x00000004,
        LVS_EX_TRACKSELECT = 0x00000008,
        LVS_EX_HEADERDRAGDROP = 0x00000010,
        LVS_EX_FULLROWSELECT = 0x00000020,
        LVS_EX_ONECLICKACTIVATE = 0x00000040,
        LVS_EX_TWOCLICKACTIVATE = 0x00000080,
        LVS_EX_FLATSB = 0x00000100,
        LVS_EX_REGIONAL = 0x00000200,
        LVS_EX_INFOTIP = 0x00000400,
        LVS_EX_UNDERLINEHOT = 0x00000800,
        LVS_EX_UNDERLINECOLD = 0x00001000,
        LVS_EX_MULTIWORKAREAS = 0x00002000,
        LVM_GETSUBITEMRECT = (0x1000+56),
                             LVM_SUBITEMHITTEST = (0x1000+57),
                                                  LVM_SETCOLUMNORDERARRAY = (0x1000+58),
                                                                            LVM_GETCOLUMNORDERARRAY = (0x1000+59),
                                                                                                      LVM_SETHOTITEM = (0x1000+60),
                                                                                                                       LVM_GETHOTITEM = (0x1000+61),
                                                                                                                                        LVM_SETHOTCURSOR = (0x1000+62),
                                                                                                                                                           LVM_GETHOTCURSOR = (0x1000+63),
                                                                                                                                                                              LVM_APPROXIMATEVIEWRECT = (0x1000+64),
                                                                                                                                                                                                        LVM_SETWORKAREA = (0x1000+65),
                                                                                                                                                                                                                          LVN_ITEMCHANGING = ((0-100)-0),
                                                                                                                                                                                                                                             LVN_ITEMCHANGED = ((0-100)-1),
                                                                                                                                                                                                                                                               LVN_INSERTITEM = ((0-100)-2),
                                                                                                                                                                                                                                                                                LVN_DELETEITEM = ((0-100)-3),
                                                                                                                                                                                                                                                                                                 LVN_DELETEALLITEMS = ((0-100)-4),
                                                                                                                                                                                                                                                                                                                      LVN_BEGINLABELEDITA = ((0-100)-5),
                                                                                                                                                                                                                                                                                                                                            LVN_BEGINLABELEDITW = ((0-100)-75),
                                                                                                                                                                                                                                                                                                                                                                  LVN_ENDLABELEDITA = ((0-100)-6),
                                                                                                                                                                                                                                                                                                                                                                                      LVN_ENDLABELEDITW = ((0-100)-76),
                                                                                                                                                                                                                                                                                                                                                                                                          LVN_COLUMNCLICK = ((0-100)-8),
                                                                                                                                                                                                                                                                                                                                                                                                                            LVN_BEGINDRAG = ((0-100)-9),
                                                                                                                                                                                                                                                                                                                                                                                                                                            LVN_BEGINRDRAG = ((0-100)-11),
                                                                                                                                                                                                                                                                                                                                                                                                                                                             LVN_ODCACHEHINT = ((0-100)-13),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               LVN_ODFINDITEMA = ((0-100)-52),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 LVN_ODFINDITEMW = ((0-100)-79),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   LVN_ITEMACTIVATE = ((0-100)-14),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      LVN_ODSTATECHANGED = ((0-100)-15),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           LVN_GETDISPINFOA = ((0-100)-50),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              LVN_GETDISPINFOW = ((0-100)-77),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 LVN_SETDISPINFOA = ((0-100)-51),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    LVN_SETDISPINFOW = ((0-100)-78),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       LVIF_DI_SETITEM = 0x1000,
        LVN_KEYDOWN = ((0-100)-55),
                      /* nt5 begin */
                      LWA_COLORKEY            = 0x00000001,
        LWA_ALPHA               = 0x00000002,
        /* nt5 end */

        LVN_MARQUEEBEGIN = ((0-100)-56);




        public const int MSGF_DDEMGR = unchecked((int)0x8001),
        MH_CREATE = 1,
        MH_KEEP = 2,
        MH_DELETE = 3,
        MH_CLEANUP = 4,
        MAX_MONITORS = 4,
        MF_HSZ_INFO = 0x01000000,
        MF_SENDMSGS = 0x02000000,
        MF_POSTMSGS = 0x04000000,
        MF_CALLBACKS = 0x08000000,
        MF_ERRORS = 0x10000000,
        MF_LINKS = 0x20000000,
        MF_CONV = 0x40000000,
        MF_MASK = unchecked((int)0xFF000000),
        MULTIFILEOPENORD = 1537,
        MOD_ALT = 0x0001,
        MOD_CONTROL = 0x0002,
        MOD_SHIFT = 0x0004,
        MOD_LEFT = unchecked((int)0x8000),
        MOD_RIGHT = 0x4000,
        MOD_ON_KEYUP = 0x0800,
        MOD_IGNORE_ALL_MODIFIER = 0x0400,
        MDMVOLFLAG_LOW = 0x00000001,
        MDMVOLFLAG_MEDIUM = 0x00000002,
        MDMVOLFLAG_HIGH = 0x00000004,
        MDMVOL_LOW = 0x00000000,
        MDMVOL_MEDIUM = 0x00000001,
        MDMVOL_HIGH = 0x00000002,
        MDMSPKRFLAG_OFF = 0x00000001,
        MDMSPKRFLAG_DIAL = 0x00000002,
        MDMSPKRFLAG_ON = 0x00000004,
        MDMSPKRFLAG_CALLSETUP = 0x00000008,
        MDMSPKR_OFF = 0x00000000,
        MDMSPKR_DIAL = 0x00000001,
        MDMSPKR_ON = 0x00000002,
        MDMSPKR_CALLSETUP = 0x00000003,
        MDM_COMPRESSION = 0x00000001,
        MDM_ERROR_CONTROL = 0x00000002,
        MDM_FORCED_EC = 0x00000004,
        MDM_CELLULAR = 0x00000008,
        MDM_FLOWCONTROL_HARD = 0x00000010,
        MDM_FLOWCONTROL_SOFT = 0x00000020,
        MDM_CCITT_OVERRIDE = 0x00000040,
        MDM_SPEED_ADJUST = 0x00000080,
        MDM_TONE_DIAL = 0x00000100,
        MDM_BLIND_DIAL = 0x00000200,
        MDM_V23_OVERRIDE = 0x00000400,
        MAXPNAMELEN = 32,
        MAXERRORLENGTH = 256,
        MAX_JOYSTICKOEMVXDNAME = 260,
        MM_MICROSOFT = 1,
        MM_MIDI_MAPPER = 1,
        MM_WAVE_MAPPER = 2,
        MM_SNDBLST_MIDIOUT = 3,
        MM_SNDBLST_MIDIIN = 4,
        MM_SNDBLST_SYNTH = 5,
        MM_SNDBLST_WAVEOUT = 6,
        MM_SNDBLST_WAVEIN = 7,
        MM_ADLIB = 9,
        MM_MPU401_MIDIOUT = 10,
        MM_MPU401_MIDIIN = 11,
        MM_PC_JOYSTICK = 12,
        MM_JOY1MOVE = 0x3A0,
        MM_JOY2MOVE = 0x3A1,
        MM_JOY1ZMOVE = 0x3A2,
        MM_JOY2ZMOVE = 0x3A3,
        MM_JOY1BUTTONDOWN = 0x3B5,
        MM_JOY2BUTTONDOWN = 0x3B6,
        MM_JOY1BUTTONUP = 0x3B7,
        MM_JOY2BUTTONUP = 0x3B8,
        MM_MCINOTIFY = 0x3B9,
        MM_WOM_OPEN = 0x3BB,
        MM_WOM_CLOSE = 0x3BC,
        MM_WOM_DONE = 0x3BD,
        MM_WIM_OPEN = 0x3BE,
        MM_WIM_CLOSE = 0x3BF,
        MM_WIM_DATA = 0x3C0,
        MM_MIM_OPEN = 0x3C1,
        MM_MIM_CLOSE = 0x3C2,
        MM_MIM_DATA = 0x3C3,
        MM_MIM_LONGDATA = 0x3C4,
        MM_MIM_ERROR = 0x3C5,
        MM_MIM_LONGERROR = 0x3C6,
        MM_MOM_OPEN = 0x3C7,
        MM_MOM_CLOSE = 0x3C8,
        MM_MOM_DONE = 0x3C9,
        MM_DRVM_OPEN = 0x3D0,
        MM_DRVM_CLOSE = 0x3D1,
        MM_DRVM_DATA = 0x3D2,
        MM_DRVM_ERROR = 0x3D3,
        MM_STREAM_OPEN = 0x3D4,
        MM_STREAM_CLOSE = 0x3D5,
        MM_STREAM_DONE = 0x3D6,
        MM_STREAM_ERROR = 0x3D7,
        MM_MOM_POSITIONCB = 0x3CA,
        MM_MCISIGNAL = 0x3CB,
        MM_MIM_MOREDATA = 0x3CC,
        MM_MIXM_LINE_CHANGE = 0x3D0,
        MM_MIXM_CONTROL_CHANGE = 0x3D1,
        MMSYSERR_BASE = 0,
        MIDIERR_BASE = 64,
        MCIERR_BASE = 256,
        MIXERR_BASE = 1024,
        MCI_STRING_OFFSET = 512,
        MCI_VD_OFFSET = 1024,
        MCI_CD_OFFSET = 1088,
        MCI_WAVE_OFFSET = 1152,
        MCI_SEQ_OFFSET = 1216,
        MMSYSERR_NOERROR = 0,
        MMSYSERR_ERROR = (0+1),
                         MMSYSERR_BADDEVICEID = (0+2),
                                                MMSYSERR_NOTENABLED = (0+3),
                                                                      MMSYSERR_ALLOCATED = (0+4),
                                                                                           MMSYSERR_INVALHANDLE = (0+5),
                                                                                                                  MMSYSERR_NODRIVER = (0+6),
                                                                                                                                      MMSYSERR_NOMEM = (0+7),
                                                                                                                                                       MMSYSERR_NOTSUPPORTED = (0+8),
                                                                                                                                                                               MMSYSERR_BADERRNUM = (0+9),
                                                                                                                                                                                                    MMSYSERR_INVALFLAG = (0+10),
                                                                                                                                                                                                                         MMSYSERR_INVALPARAM = (0+11),
                                                                                                                                                                                                                                               MMSYSERR_HANDLEBUSY = (0+12),
                                                                                                                                                                                                                                                                     MMSYSERR_INVALIDALIAS = (0+13),
                                                                                                                                                                                                                                                                                             MMSYSERR_BADDB = (0+14),
                                                                                                                                                                                                                                                                                                              MMSYSERR_KEYNOTFOUND = (0+15),
                                                                                                                                                                                                                                                                                                                                     MMSYSERR_READERROR = (0+16),
                                                                                                                                                                                                                                                                                                                                                          MMSYSERR_WRITEERROR = (0+17),
                                                                                                                                                                                                                                                                                                                                                                                MMSYSERR_DELETEERROR = (0+18),
                                                                                                                                                                                                                                                                                                                                                                                                       MMSYSERR_VALNOTFOUND = (0+19),
                                                                                                                                                                                                                                                                                                                                                                                                                              MMSYSERR_NODRIVERCB = (0+20),
                                                                                                                                                                                                                                                                                                                                                                                                                                                    MMSYSERR_LASTERROR = (0+20),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         MIDIERR_UNPREPARED = (64+0),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              MIDIERR_STILLPLAYING = (64+1),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     MIDIERR_NOMAP = (64+2),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     MIDIERR_NOTREADY = (64+3),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        MIDIERR_NODEVICE = (64+4),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           MIDIERR_INVALIDSETUP = (64+5),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  MIDIERR_BADOPENMODE = (64+6),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        MIDIERR_DONT_CONTINUE = (64+7),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                MIDIERR_LASTERROR = (64+7),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    MIDIPATCHSIZE = 128,
        MIM_OPEN = 0x3C1,
        MIM_CLOSE = 0x3C2,
        MIM_DATA = 0x3C3,
        MIM_LONGDATA = 0x3C4,
        MIM_ERROR = 0x3C5,
        MIM_LONGERROR = 0x3C6,
        MOM_OPEN = 0x3C7,
        MOM_CLOSE = 0x3C8,
        MOM_DONE = 0x3C9,
        MIM_MOREDATA = 0x3CC,
        MOM_POSITIONCB = 0x3CA,
        MIDI_IO_STATUS = 0x00000020,
        MIDI_CACHE_ALL = 1,
        MIDI_CACHE_BESTFIT = 2,
        MIDI_CACHE_QUERY = 3,
        MIDI_UNCACHE = 4,
        MOD_MIDIPORT = 1,
        MOD_SYNTH = 2,
        MOD_SQSYNTH = 3,
        MOD_FMSYNTH = 4,
        MOD_MAPPER = 5,
        MIDICAPS_VOLUME = 0x0001,
        MIDICAPS_LRVOLUME = 0x0002,
        MIDICAPS_CACHE = 0x0004,
        MIDICAPS_STREAM = 0x0008,
        MHDR_DONE = 0x00000001,
        MHDR_PREPARED = 0x00000002,
        MHDR_INQUEUE = 0x00000004,
        MHDR_ISSTRM = 0x00000008,
        MEVT_F_SHORT = 0x00000000,
        MEVT_F_LONG = unchecked((int)0x80000000),
        MEVT_F_CALLBACK = 0x40000000,
        MEVT_SHORTMSG = (0x00),
                        MEVT_TEMPO = (0x01),
                                     MEVT_NOP = (0x02),
                                                MEVT_LONGMSG = (unchecked((int)0x80)),
                                                               MEVT_COMMENT = (unchecked((int)0x82)),
                                                                              MEVT_VERSION = (unchecked((int)0x84)),
                                                                                             MIDISTRM_ERROR = (-2),
                                                                                                              MIDIPROP_SET = unchecked((int)0x80000000),
        MIDIPROP_GET = 0x40000000,
        MIDIPROP_TIMEDIV = 0x00000001,
        MIDIPROP_TEMPO = 0x00000002,
        MIXER_SHORT_NAME_CHARS = 16,
        MIXER_LONG_NAME_CHARS = 64,
        MIXERR_INVALLINE = (1024+0),
                           MIXERR_INVALCONTROL = (1024+1),
                                                 MIXERR_INVALVALUE = (1024+2),
                                                                     MIXERR_LASTERROR = (1024+2),
                                                                                        MIXER_OBJECTF_HANDLE = unchecked((int)0x80000000),
        MIXER_OBJECTF_MIXER = 0x00000000,
        MIXER_OBJECTF_HMIXER = (unchecked((int)0x80000000)|0x00000000),
                               MIXER_OBJECTF_WAVEOUT = 0x10000000,
        MIXER_OBJECTF_HWAVEOUT = (unchecked((int)0x80000000)|0x10000000),
                                 MIXER_OBJECTF_WAVEIN = 0x20000000,
        MIXER_OBJECTF_HWAVEIN = (unchecked((int)0x80000000)|0x20000000),
                                MIXER_OBJECTF_MIDIOUT = 0x30000000,
        MIXER_OBJECTF_HMIDIOUT = (unchecked((int)0x80000000)|0x30000000),
                                 MIXER_OBJECTF_MIDIIN = 0x40000000,
        MIXER_OBJECTF_HMIDIIN = (unchecked((int)0x80000000)|0x40000000),
                                MIXER_OBJECTF_AUX = 0x50000000,
        MIXERLINE_LINEF_ACTIVE = 0x00000001,
        MIXERLINE_LINEF_DISCONNECTED = 0x00008000,
        MIXERLINE_LINEF_SOURCE = unchecked((int)0x80000000),
        MIXERLINE_COMPONENTTYPE_DST_FIRST = 0x00000000,
        MIXERLINE_COMPONENTTYPE_DST_UNDEFINED = (0x00000000+0),
                                                MIXERLINE_COMPONENTTYPE_DST_DIGITAL = (0x00000000+1),
                                                                                      MIXERLINE_COMPONENTTYPE_DST_LINE = (0x00000000+2),
                                                                                                                         MIXERLINE_COMPONENTTYPE_DST_MONITOR = (0x00000000+3),
                                                                                                                                                               MIXERLINE_COMPONENTTYPE_DST_SPEAKERS = (0x00000000+4),
                                                                                                                                                                                                      MIXERLINE_COMPONENTTYPE_DST_HEADPHONES = (0x00000000+5),
                                                                                                                                                                                                                                               MIXERLINE_COMPONENTTYPE_DST_TELEPHONE = (0x00000000+6),
                                                                                                                                                                                                                                                                                       MIXERLINE_COMPONENTTYPE_DST_WAVEIN = (0x00000000+7),
                                                                                                                                                                                                                                                                                                                            MIXERLINE_COMPONENTTYPE_DST_VOICEIN = (0x00000000+8),
                                                                                                                                                                                                                                                                                                                                                                  MIXERLINE_COMPONENTTYPE_DST_LAST = (0x00000000+8),
                                                                                                                                                                                                                                                                                                                                                                                                     MIXERLINE_COMPONENTTYPE_SRC_FIRST = 0x00001000,
        MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED = (0x00001000+0),
                                                MIXERLINE_COMPONENTTYPE_SRC_DIGITAL = (0x00001000+1),
                                                                                      MIXERLINE_COMPONENTTYPE_SRC_LINE = (0x00001000+2),
                                                                                                                         MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE = (0x00001000+3),
                                                                                                                                                                  MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER = (0x00001000+4),
                                                                                                                                                                                                            MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC = (0x00001000+5),
                                                                                                                                                                                                                                                      MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE = (0x00001000+6),
                                                                                                                                                                                                                                                                                              MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER = (0x00001000+7),
                                                                                                                                                                                                                                                                                                                                      MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT = (0x00001000+8),
                                                                                                                                                                                                                                                                                                                                                                            MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY = (0x00001000+9),
                                                                                                                                                                                                                                                                                                                                                                                                                    MIXERLINE_COMPONENTTYPE_SRC_ANALOG = (0x00001000+10),
                                                                                                                                                                                                                                                                                                                                                                                                                                                         MIXERLINE_COMPONENTTYPE_SRC_LAST = (0x00001000+10),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            MIXERLINE_TARGETTYPE_UNDEFINED = 0,
        MIXERLINE_TARGETTYPE_WAVEOUT = 1,
        MIXERLINE_TARGETTYPE_WAVEIN = 2,
        MIXERLINE_TARGETTYPE_MIDIOUT = 3,
        MIXERLINE_TARGETTYPE_MIDIIN = 4,
        MIXERLINE_TARGETTYPE_AUX = 5,
        MIXER_GETLINEINFOF_DESTINATION = 0x00000000,
        MIXER_GETLINEINFOF_SOURCE = 0x00000001,
        MIXER_GETLINEINFOF_LINEID = 0x00000002,
        MIXER_GETLINEINFOF_COMPONENTTYPE = 0x00000003,
        MIXER_GETLINEINFOF_TARGETTYPE = 0x00000004,
        MIXER_GETLINEINFOF_QUERYMASK = 0x0000000F,
        MIXERCONTROL_CONTROLF_UNIFORM = 0x00000001,
        MIXERCONTROL_CONTROLF_MULTIPLE = 0x00000002,
        MIXERCONTROL_CONTROLF_DISABLED = unchecked((int)0x80000000),
        MIXERCONTROL_CT_CLASS_MASK = unchecked((int)0xF0000000),
        MIXERCONTROL_CT_CLASS_CUSTOM = 0x00000000,
        MIXERCONTROL_CT_CLASS_METER = 0x10000000,
        MIXERCONTROL_CT_CLASS_SWITCH = 0x20000000,
        MIXERCONTROL_CT_CLASS_NUMBER = 0x30000000,
        MIXERCONTROL_CT_CLASS_SLIDER = 0x40000000,
        MIXERCONTROL_CT_CLASS_FADER = 0x50000000,
        MIXERCONTROL_CT_CLASS_TIME = 0x60000000,
        MIXERCONTROL_CT_CLASS_LIST = 0x70000000,
        MIXERCONTROL_CT_SUBCLASS_MASK = 0x0F000000,
        MIXERCONTROL_CT_SC_SWITCH_BOOLEAN = 0x00000000,
        MIXERCONTROL_CT_SC_SWITCH_BUTTON = 0x01000000,
        MIXERCONTROL_CT_SC_METER_POLLED = 0x00000000,
        MIXERCONTROL_CT_SC_TIME_MICROSECS = 0x00000000,
        MIXERCONTROL_CT_SC_TIME_MILLISECS = 0x01000000,
        MIXERCONTROL_CT_SC_LIST_SINGLE = 0x00000000,
        MIXERCONTROL_CT_SC_LIST_MULTIPLE = 0x01000000,
        MIXERCONTROL_CT_UNITS_MASK = 0x00FF0000,
        MIXERCONTROL_CT_UNITS_CUSTOM = 0x00000000,
        MIXERCONTROL_CT_UNITS_BOOLEAN = 0x00010000,
        MIXERCONTROL_CT_UNITS_SIGNED = 0x00020000,
        MIXERCONTROL_CT_UNITS_UNSIGNED = 0x00030000,
        MIXERCONTROL_CT_UNITS_DECIBELS = 0x00040000,
        MIXERCONTROL_CT_UNITS_PERCENT = 0x00050000,
        MIXERCONTROL_CONTROLTYPE_CUSTOM = (0x00000000|0x00000000),
                                          MIXERCONTROL_CONTROLTYPE_BOOLEANMETER = (0x10000000|0x00000000|0x00010000),
                                                                                  MIXERCONTROL_CONTROLTYPE_SIGNEDMETER = (0x10000000|0x00000000|0x00020000),
                                                                                                                         MIXERCONTROL_CONTROLTYPE_PEAKMETER = ((0x10000000|0x00000000|0x00020000)+1),
                                                                                                                                                              MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER = (0x10000000|0x00000000|0x00030000),
                                                                                                                                                                                                       MIXERCONTROL_CONTROLTYPE_BOOLEAN = (0x20000000|0x00000000|0x00010000),
                                                                                                                                                                                                                                          MIXERCONTROL_CONTROLTYPE_ONOFF = ((0x20000000|0x00000000|0x00010000)+1),
                                                                                                                                                                                                                                                                           MIXERCONTROL_CONTROLTYPE_MUTE = ((0x20000000|0x00000000|0x00010000)+2),
                                                                                                                                                                                                                                                                                                           MIXERCONTROL_CONTROLTYPE_MONO = ((0x20000000|0x00000000|0x00010000)+3),
                                                                                                                                                                                                                                                                                                                                           MIXERCONTROL_CONTROLTYPE_LOUDNESS = ((0x20000000|0x00000000|0x00010000)+4),
                                                                                                                                                                                                                                                                                                                                                                               MIXERCONTROL_CONTROLTYPE_STEREOENH = ((0x20000000|0x00000000|0x00010000)+5),
                                                                                                                                                                                                                                                                                                                                                                                                                    MIXERCONTROL_CONTROLTYPE_BUTTON = (0x20000000|0x01000000|0x00010000),
                                                                                                                                                                                                                                                                                                                                                                                                                                                      MIXERCONTROL_CONTROLTYPE_DECIBELS = (0x30000000|0x00040000),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          MIXERCONTROL_CONTROLTYPE_SIGNED = (0x30000000|0x00020000),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            MIXERCONTROL_CONTROLTYPE_UNSIGNED = (0x30000000|0x00030000),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                MIXERCONTROL_CONTROLTYPE_PERCENT = (0x30000000|0x00050000),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   MIXERCONTROL_CONTROLTYPE_SLIDER = (0x40000000|0x00020000),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     MIXERCONTROL_CONTROLTYPE_PAN = ((0x40000000|0x00020000)+1),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    MIXERCONTROL_CONTROLTYPE_QSOUNDPAN = ((0x40000000|0x00020000)+2),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         MIXERCONTROL_CONTROLTYPE_FADER = (0x50000000|0x00030000),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          MIXERCONTROL_CONTROLTYPE_VOLUME = ((0x50000000|0x00030000)+1),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            MIXERCONTROL_CONTROLTYPE_BASS = ((0x50000000|0x00030000)+2),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            MIXERCONTROL_CONTROLTYPE_TREBLE = ((0x50000000|0x00030000)+3),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              MIXERCONTROL_CONTROLTYPE_EQUALIZER = ((0x50000000|0x00030000)+4),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   MIXERCONTROL_CONTROLTYPE_SINGLESELECT = (0x70000000|0x00000000|0x00010000),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           MIXERCONTROL_CONTROLTYPE_MUX = ((0x70000000|0x00000000|0x00010000)+1),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT = (0x70000000|0x01000000|0x00010000),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    MIXERCONTROL_CONTROLTYPE_MIXER = ((0x70000000|0x01000000|0x00010000)+1),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     MIXERCONTROL_CONTROLTYPE_MICROTIME = (0x60000000|0x00000000|0x00030000),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          MIXERCONTROL_CONTROLTYPE_MILLITIME = (0x60000000|0x01000000|0x00030000),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               MIXER_GETLINECONTROLSF_ALL = 0x00000000,
        MIXER_GETLINECONTROLSF_ONEBYID = 0x00000001,
        MIXER_GETLINECONTROLSF_ONEBYTYPE = 0x00000002,
        MIXER_GETLINECONTROLSF_QUERYMASK = 0x0000000F,
        MIXER_GETCONTROLDETAILSF_VALUE = 0x00000000,
        MIXER_GETCONTROLDETAILSF_LISTTEXT = 0x00000001,
        MIXER_GETCONTROLDETAILSF_QUERYMASK = 0x0000000F,
        MIXER_SETCONTROLDETAILSF_VALUE = 0x00000000,
        MIXER_SETCONTROLDETAILSF_CUSTOM = 0x00000001,
        MIXER_SETCONTROLDETAILSF_QUERYMASK = 0x0000000F,
        MMIOERR_BASE = 256,
        MMIOERR_FILENOTFOUND = (256+1),
                               MMIOERR_OUTOFMEMORY = (256+2),
                                                     MMIOERR_CANNOTOPEN = (256+3),
                                                                          MMIOERR_CANNOTCLOSE = (256+4),
                                                                                                MMIOERR_CANNOTREAD = (256+5),
                                                                                                                     MMIOERR_CANNOTWRITE = (256+6),
                                                                                                                                           MMIOERR_CANNOTSEEK = (256+7),
                                                                                                                                                                MMIOERR_CANNOTEXPAND = (256+8),
                                                                                                                                                                                       MMIOERR_CHUNKNOTFOUND = (256+9),
                                                                                                                                                                                                               MMIOERR_UNBUFFERED = (256+10),
                                                                                                                                                                                                                                    MMIOERR_PATHNOTFOUND = (256+11),
                                                                                                                                                                                                                                                           MMIOERR_ACCESSDENIED = (256+12),
                                                                                                                                                                                                                                                                                  MMIOERR_SHARINGVIOLATION = (256+13),
                                                                                                                                                                                                                                                                                                             MMIOERR_NETWORKERROR = (256+14),
                                                                                                                                                                                                                                                                                                                                    MMIOERR_TOOMANYOPENFILES = (256+15),
                                                                                                                                                                                                                                                                                                                                                               MMIOERR_INVALIDFILE = (256+16),
                                                                                                                                                                                                                                                                                                                                                                                     MMIO_RWMODE = 0x00000003,
        MMIO_SHAREMODE = 0x00000070,
        MMIO_CREATE = 0x00001000,
        MMIO_PARSE = 0x00000100,
        MMIO_DELETE = 0x00000200,
        MMIO_EXIST = 0x00004000,
        MMIO_ALLOCBUF = 0x00010000,
        MMIO_GETTEMP = 0x00020000,
        MMIO_DIRTY = 0x10000000,
        MMIO_READ = 0x00000000,
        MMIO_WRITE = 0x00000001,
        MMIO_READWRITE = 0x00000002,
        MMIO_COMPAT = 0x00000000,
        MMIO_EXCLUSIVE = 0x00000010,
        MMIO_DENYWRITE = 0x00000020,
        MMIO_DENYREAD = 0x00000030,
        MMIO_DENYNONE = 0x00000040,
        MMIO_FHOPEN = 0x0010,
        MMIO_EMPTYBUF = 0x0010,
        MMIO_TOUPPER = 0x0010,
        MMIO_INSTALLPROC = 0x00010000,
        MMIO_GLOBALPROC = 0x10000000,
        MMIO_REMOVEPROC = 0x00020000,
        MMIO_UNICODEPROC = 0x01000000,
        MMIO_FINDPROC = 0x00040000,
        MMIO_FINDCHUNK = 0x0010,
        MMIO_FINDRIFF = 0x0020,
        MMIO_FINDLIST = 0x0040,
        MMIO_CREATERIFF = 0x0020,
        MMIO_CREATELIST = 0x0040,
        MMIOM_READ = 0x00000000,
        MMIOM_WRITE = 0x00000001,
        MMIOM_SEEK = 2,
        MMIOM_OPEN = 3,
        MMIOM_CLOSE = 4,
        MMIOM_WRITEFLUSH = 5,
        MMIOM_RENAME = 6,
        MMIOM_USER = unchecked((int)0x8000),
        MMIO_DEFAULTBUFFER = 8192,
        MCIERR_INVALID_DEVICE_ID = (256+1),
                                   MCIERR_UNRECOGNIZED_KEYWORD = (256+3),
                                                                 MCIERR_UNRECOGNIZED_COMMAND = (256+5),
                                                                                               MCIERR_HARDWARE = (256+6),
                                                                                                                 MCIERR_INVALID_DEVICE_NAME = (256+7),
                                                                                                                                              MCIERR_OUT_OF_MEMORY = (256+8),
                                                                                                                                                                     MCIERR_DEVICE_OPEN = (256+9),
                                                                                                                                                                                          MCIERR_CANNOT_LOAD_DRIVER = (256+10),
                                                                                                                                                                                                                      MCIERR_MISSING_COMMAND_STRING = (256+11),
                                                                                                                                                                                                                                                      MCIERR_PARAM_OVERFLOW = (256+12),
                                                                                                                                                                                                                                                                              MCIERR_MISSING_STRING_ARGUMENT = (256+13),
                                                                                                                                                                                                                                                                                                               MCIERR_BAD_INTEGER = (256+14),
                                                                                                                                                                                                                                                                                                                                    MCIERR_PARSER_INTERNAL = (256+15),
                                                                                                                                                                                                                                                                                                                                                             MCIERR_DRIVER_INTERNAL = (256+16),
                                                                                                                                                                                                                                                                                                                                                                                      MCIERR_MISSING_PARAMETER = (256+17),
                                                                                                                                                                                                                                                                                                                                                                                                                 MCIERR_UNSUPPORTED_FUNCTION = (256+18),
                                                                                                                                                                                                                                                                                                                                                                                                                                               MCIERR_FILE_NOT_FOUND = (256+19),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       MCIERR_DEVICE_NOT_READY = (256+20),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 MCIERR_INTERNAL = (256+21),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   MCIERR_DRIVER = (256+22),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   MCIERR_CANNOT_USE_ALL = (256+23),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           MCIERR_MULTIPLE = (256+24),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             MCIERR_EXTENSION_NOT_FOUND = (256+25),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          MCIERR_OUTOFRANGE = (256+26),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              MCIERR_FLAGS_NOT_COMPATIBLE = (256+28),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            MCIERR_FILE_NOT_SAVED = (256+30),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    MCIERR_DEVICE_TYPE_REQUIRED = (256+31),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  MCIERR_DEVICE_LOCKED = (256+32),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         MCIERR_DUPLICATE_ALIAS = (256+33),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  MCIERR_MUST_USE_SHAREABLE = (256+35),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              MCIERR_MISSING_DEVICE_NAME = (256+36),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           MCIERR_BAD_TIME_FORMAT = (256+37),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    MCIERR_NO_CLOSING_QUOTE = (256+38),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              MCIERR_DUPLICATE_FLAGS = (256+39),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       MCIERR_INVALID_FILE = (256+40),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             MCIERR_NULL_PARAMETER_BLOCK = (256+41),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           MCIERR_UNNAMED_RESOURCE = (256+42),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     MCIERR_NEW_REQUIRES_ALIAS = (256+43),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 MCIERR_NOTIFY_ON_AUTO_OPEN = (256+44),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              MCIERR_NO_ELEMENT_ALLOWED = (256+45),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          MCIERR_NONAPPLICABLE_FUNCTION = (256+46),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          MCIERR_ILLEGAL_FOR_AUTO_OPEN = (256+47),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         MCIERR_FILENAME_REQUIRED = (256+48),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    MCIERR_EXTRA_CHARACTERS = (256+49),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              MCIERR_DEVICE_NOT_INSTALLED = (256+50),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            MCIERR_GET_CD = (256+51),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            MCIERR_SET_CD = (256+52),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            MCIERR_SET_DRIVE = (256+53),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               MCIERR_DEVICE_LENGTH = (256+54),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      MCIERR_DEVICE_ORD_LENGTH = (256+55),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 MCIERR_NO_INTEGER = (256+56),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     MCIERR_WAVE_OUTPUTSINUSE = (256+64),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                MCIERR_WAVE_SETOUTPUTINUSE = (256+65),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             MCIERR_WAVE_INPUTSINUSE = (256+66),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       MCIERR_WAVE_SETINPUTINUSE = (256+67),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   MCIERR_WAVE_OUTPUTUNSPECIFIED = (256+68),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   MCIERR_WAVE_INPUTUNSPECIFIED = (256+69),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  MCIERR_WAVE_OUTPUTSUNSUITABLE = (256+70),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  MCIERR_WAVE_SETOUTPUTUNSUITABLE = (256+71),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    MCIERR_WAVE_INPUTSUNSUITABLE = (256+72),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   MCIERR_WAVE_SETINPUTUNSUITABLE = (256+73),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    MCIERR_SEQ_DIV_INCOMPATIBLE = (256+80),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  MCIERR_SEQ_PORT_INUSE = (256+81),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          MCIERR_SEQ_PORT_NONEXISTENT = (256+82),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        MCIERR_SEQ_PORT_MAPNODEVICE = (256+83),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      MCIERR_SEQ_PORT_MISCERROR = (256+84),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  MCIERR_SEQ_TIMER = (256+85),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     MCIERR_SEQ_PORTUNSPECIFIED = (256+86),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  MCIERR_SEQ_NOMIDIPRESENT = (256+87),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             MCIERR_NO_WINDOW = (256+90),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                MCIERR_CREATEWINDOW = (256+91),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      MCIERR_FILE_READ = (256+92),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         MCIERR_FILE_WRITE = (256+93),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             MCIERR_NO_IDENTITY = (256+94),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  MCIERR_CUSTOM_DRIVER_BASE = (256+256),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              MCI_FIRST = 0x0800,
        MCI_OPEN = 0x0803,
        MCI_CLOSE = 0x0804,
        MCI_ESCAPE = 0x0805,
        MCI_PLAY = 0x0806,
        MCI_SEEK = 0x0807,
        MCI_STOP = 0x0808,
        MCI_PAUSE = 0x0809,
        MCI_INFO = 0x080A,
        MCI_GETDEVCAPS = 0x080B,
        MCI_SPIN = 0x080C,
        MCI_SET = 0x080D,
        MCI_STEP = 0x080E,
        MCI_RECORD = 0x080F,
        MCI_SYSINFO = 0x0810,
        MCI_BREAK = 0x0811,
        MCI_SAVE = 0x0813,
        MCI_STATUS = 0x0814,
        MCI_CUE = 0x0830,
        MCI_REALIZE = 0x0840,
        MCI_WINDOW = 0x0841,
        MCI_PUT = 0x0842,
        MCI_WHERE = 0x0843,
        MCI_FREEZE = 0x0844,
        MCI_UNFREEZE = 0x0845,
        MCI_LOAD = 0x0850,
        MCI_CUT = 0x0851,
        MCI_COPY = 0x0852,
        MCI_PASTE = 0x0853,
        MCI_UPDATE = 0x0854,
        MCI_RESUME = 0x0855,
        MCI_DELETE = 0x0856,
        MCI_USER_MESSAGES = (0x0800+0x400),
                            MCI_LAST = 0x0FFF,
        MCI_DEVTYPE_VCR = 513,
        MCI_DEVTYPE_VIDEODISC = 514,
        MCI_DEVTYPE_OVERLAY = 515,
        MCI_DEVTYPE_CD_AUDIO = 516,
        MCI_DEVTYPE_DAT = 517,
        MCI_DEVTYPE_SCANNER = 518,
        MCI_DEVTYPE_ANIMATION = 519,
        MCI_DEVTYPE_DIGITAL_VIDEO = 520,
        MCI_DEVTYPE_OTHER = 521,
        MCI_DEVTYPE_WAVEFORM_AUDIO = 522,
        MCI_DEVTYPE_SEQUENCER = 523,
        MCI_DEVTYPE_FIRST = 513,
        MCI_DEVTYPE_LAST = 523,
        MCI_DEVTYPE_FIRST_USER = 0x1000,
        MCI_MODE_NOT_READY = (512+12),
                             MCI_MODE_STOP = (512+13),
                                             MCI_MODE_PLAY = (512+14),
                                                             MCI_MODE_RECORD = (512+15),
                                                                               MCI_MODE_SEEK = (512+16),
                                                                                               MCI_MODE_PAUSE = (512+17),
                                                                                                                MCI_MODE_OPEN = (512+18),
                                                                                                                                MCI_FORMAT_MILLISECONDS = 0,
        MCI_FORMAT_HMS = 1,
        MCI_FORMAT_MSF = 2,
        MCI_FORMAT_FRAMES = 3,
        MCI_FORMAT_SMPTE_24 = 4,
        MCI_FORMAT_SMPTE_25 = 5,
        MCI_FORMAT_SMPTE_30 = 6,
        MCI_FORMAT_SMPTE_30DROP = 7,
        MCI_FORMAT_BYTES = 8,
        MCI_FORMAT_SAMPLES = 9,
        MCI_FORMAT_TMSF = 10,
        MCI_NOTIFY_SUCCESSFUL = 0x0001,
        MCI_NOTIFY_SUPERSEDED = 0x0002,
        MCI_NOTIFY_ABORTED = 0x0004,
        MCI_NOTIFY_FAILURE = 0x0008,
        MCI_NOTIFY = 0x00000001,
        MCI_WAIT = 0x00000002,
        MCI_FROM = 0x00000004,
        MCI_TO = 0x00000008,
        MCI_TRACK = 0x00000010,
        MCI_OPEN_SHAREABLE = 0x00000100,
        MCI_OPEN_ELEMENT = 0x00000200,
        MCI_OPEN_ALIAS = 0x00000400,
        MCI_OPEN_ELEMENT_ID = 0x00000800,
        MCI_OPEN_TYPE_ID = 0x00001000,
        MCI_OPEN_TYPE = 0x00002000,
        MCI_SEEK_TO_START = 0x00000100,
        MCI_SEEK_TO_END = 0x00000200,
        MCI_STATUS_ITEM = 0x00000100,
        MCI_STATUS_START = 0x00000200,
        MCI_STATUS_LENGTH = 0x00000001,
        MCI_STATUS_POSITION = 0x00000002,
        MCI_STATUS_NUMBER_OF_TRACKS = 0x00000003,
        MCI_STATUS_MODE = 0x00000004,
        MCI_STATUS_MEDIA_PRESENT = 0x00000005,
        MCI_STATUS_TIME_FORMAT = 0x00000006,
        MCI_STATUS_READY = 0x00000007,
        MCI_STATUS_CURRENT_TRACK = 0x00000008,
        MCI_INFO_PRODUCT = 0x00000100,
        MCI_INFO_FILE = 0x00000200,
        MCI_INFO_MEDIA_UPC = 0x00000400,
        MCI_INFO_MEDIA_IDENTITY = 0x00000800,
        MCI_INFO_NAME = 0x00001000,
        MCI_INFO_COPYRIGHT = 0x00002000,
        MCI_GETDEVCAPS_ITEM = 0x00000100,
        MCI_GETDEVCAPS_CAN_RECORD = 0x00000001,
        MCI_GETDEVCAPS_HAS_AUDIO = 0x00000002,
        MCI_GETDEVCAPS_HAS_VIDEO = 0x00000003,
        MCI_GETDEVCAPS_DEVICE_TYPE = 0x00000004,
        MCI_GETDEVCAPS_USES_FILES = 0x00000005,
        MCI_GETDEVCAPS_COMPOUND_DEVICE = 0x00000006,
        MCI_GETDEVCAPS_CAN_EJECT = 0x00000007,
        MCI_GETDEVCAPS_CAN_PLAY = 0x00000008,
        MCI_GETDEVCAPS_CAN_SAVE = 0x00000009,
        MCI_SYSINFO_QUANTITY = 0x00000100,
        MCI_SYSINFO_OPEN = 0x00000200,
        MCI_SYSINFO_NAME = 0x00000400,
        MCI_SYSINFO_INSTALLNAME = 0x00000800,
        MCI_SET_DOOR_OPEN = 0x00000100,
        MCI_SET_DOOR_CLOSED = 0x00000200,
        MCI_SET_TIME_FORMAT = 0x00000400,
        MCI_SET_AUDIO = 0x00000800,
        MCI_SET_VIDEO = 0x00001000,
        MCI_SET_ON = 0x00002000,
        MCI_SET_OFF = 0x00004000,
        MCI_SET_AUDIO_ALL = 0x00000000,
        MCI_SET_AUDIO_LEFT = 0x00000001,
        MCI_SET_AUDIO_RIGHT = 0x00000002,
        MCI_BREAK_KEY = 0x00000100,
        MCI_BREAK_HWND = 0x00000200,
        MCI_BREAK_OFF = 0x00000400,
        MCI_RECORD_INSERT = 0x00000100,
        MCI_RECORD_OVERWRITE = 0x00000200,
        MCI_SAVE_FILE = 0x00000100,
        MCI_LOAD_FILE = 0x00000100,
        MCI_VD_MODE_PARK = (1024+1),
                           MCI_VD_MEDIA_CLV = (1024+2),
                                              MCI_VD_MEDIA_CAV = (1024+3),
                                                                 MCI_VD_MEDIA_OTHER = (1024+4),
                                                                                      MCI_VD_FORMAT_TRACK = 0x4001,
        MCI_VD_PLAY_REVERSE = 0x00010000,
        MCI_VD_PLAY_FAST = 0x00020000,
        MCI_VD_PLAY_SPEED = 0x00040000,
        MCI_VD_PLAY_SCAN = 0x00080000,
        MCI_VD_PLAY_SLOW = 0x00100000,
        MCI_VD_SEEK_REVERSE = 0x00010000,
        MCI_VD_STATUS_SPEED = 0x00004002,
        MCI_VD_STATUS_FORWARD = 0x00004003,
        MCI_VD_STATUS_MEDIA_TYPE = 0x00004004,
        MCI_VD_STATUS_SIDE = 0x00004005,
        MCI_VD_STATUS_DISC_SIZE = 0x00004006,
        MCI_VD_GETDEVCAPS_CLV = 0x00010000,
        MCI_VD_GETDEVCAPS_CAV = 0x00020000,
        MCI_VD_SPIN_UP = 0x00010000,
        MCI_VD_SPIN_DOWN = 0x00020000,
        MCI_VD_GETDEVCAPS_CAN_REVERSE = 0x00004002,
        MCI_VD_GETDEVCAPS_FAST_RATE = 0x00004003,
        MCI_VD_GETDEVCAPS_SLOW_RATE = 0x00004004,
        MCI_VD_GETDEVCAPS_NORMAL_RATE = 0x00004005,
        MCI_VD_STEP_FRAMES = 0x00010000,
        MCI_VD_STEP_REVERSE = 0x00020000,
        MCI_VD_ESCAPE_STRING = 0x00000100,
        MCI_CDA_STATUS_TYPE_TRACK = 0x00004001,
        MCI_CDA_TRACK_AUDIO = (1088+0),
                              MCI_CDA_TRACK_OTHER = (1088+1),
                                                    MCI_WAVE_PCM = (1152+0),
                                                                   MCI_WAVE_MAPPER = (1152+1),
                                                                                     MCI_WAVE_OPEN_BUFFER = 0x00010000,
        MCI_WAVE_SET_FORMATTAG = 0x00010000,
        MCI_WAVE_SET_CHANNELS = 0x00020000,
        MCI_WAVE_SET_SAMPLESPERSEC = 0x00040000,
        MCI_WAVE_SET_AVGBYTESPERSEC = 0x00080000,
        MCI_WAVE_SET_BLOCKALIGN = 0x00100000,
        MCI_WAVE_SET_BITSPERSAMPLE = 0x00200000,
        MCI_WAVE_INPUT = 0x00400000,
        MCI_WAVE_OUTPUT = 0x00800000,
        MCI_WAVE_STATUS_FORMATTAG = 0x00004001,
        MCI_WAVE_STATUS_CHANNELS = 0x00004002,
        MCI_WAVE_STATUS_SAMPLESPERSEC = 0x00004003,
        MCI_WAVE_STATUS_AVGBYTESPERSEC = 0x00004004,
        MCI_WAVE_STATUS_BLOCKALIGN = 0x00004005,
        MCI_WAVE_STATUS_BITSPERSAMPLE = 0x00004006,
        MCI_WAVE_STATUS_LEVEL = 0x00004007,
        MCI_WAVE_SET_ANYINPUT = 0x04000000,
        MCI_WAVE_SET_ANYOUTPUT = 0x08000000,
        MCI_WAVE_GETDEVCAPS_INPUTS = 0x00004001,
        MCI_WAVE_GETDEVCAPS_OUTPUTS = 0x00004002,
        MCI_SEQ_DIV_PPQN = (0+1216),
                           MCI_SEQ_DIV_SMPTE_24 = (1+1216),
                                                  MCI_SEQ_DIV_SMPTE_25 = (2+1216),
                                                                         MCI_SEQ_DIV_SMPTE_30DROP = (3+1216),
                                                                                                    MCI_SEQ_DIV_SMPTE_30 = (4+1216),
                                                                                                                           MCI_SEQ_FORMAT_SONGPTR = 0x4001,
        MCI_SEQ_FILE = 0x4002,
        MCI_SEQ_MIDI = 0x4003,
        MCI_SEQ_SMPTE = 0x4004,
        MCI_SEQ_NONE = 65533,
        MCI_SEQ_MAPPER = 65535,
        MCI_SEQ_STATUS_TEMPO = 0x00004002,
        MCI_SEQ_STATUS_PORT = 0x00004003,
        MCI_SEQ_STATUS_SLAVE = 0x00004007,
        MCI_SEQ_STATUS_MASTER = 0x00004008,
        MCI_SEQ_STATUS_OFFSET = 0x00004009,
        MCI_SEQ_STATUS_DIVTYPE = 0x0000400A,
        MCI_SEQ_STATUS_NAME = 0x0000400B,
        MCI_SEQ_STATUS_COPYRIGHT = 0x0000400C,
        MCI_SEQ_SET_TEMPO = 0x00010000,
        MCI_SEQ_SET_PORT = 0x00020000,
        MCI_SEQ_SET_SLAVE = 0x00040000,
        MCI_SEQ_SET_MASTER = 0x00080000,
        MCI_SEQ_SET_OFFSET = 0x01000000,
        MCI_ANIM_OPEN_WS = 0x00010000,
        MCI_ANIM_OPEN_PARENT = 0x00020000,
        MCI_ANIM_OPEN_NOSTATIC = 0x00040000,
        MCI_ANIM_PLAY_SPEED = 0x00010000,
        MCI_ANIM_PLAY_REVERSE = 0x00020000,
        MCI_ANIM_PLAY_FAST = 0x00040000,
        MCI_ANIM_PLAY_SLOW = 0x00080000,
        MCI_ANIM_PLAY_SCAN = 0x00100000,
        MCI_ANIM_STEP_REVERSE = 0x00010000,
        MCI_ANIM_STEP_FRAMES = 0x00020000,
        MCI_ANIM_STATUS_SPEED = 0x00004001,
        MCI_ANIM_STATUS_FORWARD = 0x00004002,
        MCI_ANIM_STATUS_HWND = 0x00004003,
        MCI_ANIM_STATUS_HPAL = 0x00004004,
        MCI_ANIM_STATUS_STRETCH = 0x00004005,
        MCI_ANIM_INFO_TEXT = 0x00010000,
        MCI_ANIM_GETDEVCAPS_CAN_REVERSE = 0x00004001,
        MCI_ANIM_GETDEVCAPS_FAST_RATE = 0x00004002,
        MCI_ANIM_GETDEVCAPS_SLOW_RATE = 0x00004003,
        MCI_ANIM_GETDEVCAPS_NORMAL_RATE = 0x00004004,
        MCI_ANIM_GETDEVCAPS_PALETTES = 0x00004006,
        MCI_ANIM_GETDEVCAPS_CAN_STRETCH = 0x00004007,
        MCI_ANIM_GETDEVCAPS_MAX_WINDOWS = 0x00004008,
        MCI_ANIM_REALIZE_NORM = 0x00010000,
        MCI_ANIM_REALIZE_BKGD = 0x00020000,
        MCI_ANIM_WINDOW_HWND = 0x00010000,
        MCI_ANIM_WINDOW_STATE = 0x00040000,
        MCI_ANIM_WINDOW_TEXT = 0x00080000,
        MCI_ANIM_WINDOW_ENABLE_STRETCH = 0x00100000,
        MCI_ANIM_WINDOW_DISABLE_STRETCH = 0x00200000,
        MCI_ANIM_WINDOW_DEFAULT = 0x00000000,
        MCI_ANIM_RECT = 0x00010000,
        MCI_ANIM_PUT_SOURCE = 0x00020000,
        MCI_ANIM_PUT_DESTINATION = 0x00040000,
        MCI_ANIM_WHERE_SOURCE = 0x00020000,
        MCI_ANIM_WHERE_DESTINATION = 0x00040000,
        MCI_ANIM_UPDATE_HDC = 0x00020000,
        MCI_OVLY_OPEN_WS = 0x00010000,
        MCI_OVLY_OPEN_PARENT = 0x00020000,
        MCI_OVLY_STATUS_HWND = 0x00004001,
        MCI_OVLY_STATUS_STRETCH = 0x00004002,
        MCI_OVLY_INFO_TEXT = 0x00010000,
        MCI_OVLY_GETDEVCAPS_CAN_STRETCH = 0x00004001,
        MCI_OVLY_GETDEVCAPS_CAN_FREEZE = 0x00004002,
        MCI_OVLY_GETDEVCAPS_MAX_WINDOWS = 0x00004003,
        MCI_OVLY_WINDOW_HWND = 0x00010000,
        MCI_OVLY_WINDOW_STATE = 0x00040000,
        MCI_OVLY_WINDOW_TEXT = 0x00080000,
        MCI_OVLY_WINDOW_ENABLE_STRETCH = 0x00100000,
        MCI_OVLY_WINDOW_DISABLE_STRETCH = 0x00200000,
        MCI_OVLY_WINDOW_DEFAULT = 0x00000000,
        MCI_OVLY_RECT = 0x00010000,
        MCI_OVLY_PUT_SOURCE = 0x00020000,
        MCI_OVLY_PUT_DESTINATION = 0x00040000,
        MCI_OVLY_PUT_FRAME = 0x00080000,
        MCI_OVLY_PUT_VIDEO = 0x00100000,
        MCI_OVLY_WHERE_SOURCE = 0x00020000,
        MCI_OVLY_WHERE_DESTINATION = 0x00040000,
        MCI_OVLY_WHERE_FRAME = 0x00080000,
        MCI_OVLY_WHERE_VIDEO = 0x00100000,
        MAX_LANA = 254,
        MARSHALINTERFACE_MIN = 500,
        MEMBERID_NIL = (-1),
                       MK_ALT = (0x20),
                                MAXPROPPAGES = 100,
        MARKPARITY = 3,
        MS_CTS_ON = (0x0010),
                    MS_DSR_ON = (0x0020),
                                MS_RING_ON = (0x0040),
                                             MS_RLSD_ON = (0x0080),
                                                          MAXINTATOM = unchecked((int)0xC000),
        MOVEFILE_REPLACE_EXISTING = 0x00000001,
        MOVEFILE_COPY_ALLOWED = 0x00000002,
        MOVEFILE_DELAY_UNTIL_REBOOT = 0x00000004,
        MOVEFILE_WRITE_THROUGH = 0x00000008,
        MAX_COMPUTERNAME_LENGTH = 15,
        MAX_PROFILE_LEN = 80,
        MOUSE_MOVED = 0x0001,
        MOUSE_EVENT = 0x0002,
        MENU_EVENT = 0x0008,
        MAXUIDLEN = 64,
        MAX_PATH = 260,
        MARSHAL_E_FIRST = unchecked((int)0x80040120),
        MARSHAL_E_LAST = unchecked((int)0x8004012F),
        MARSHAL_S_FIRST = 0x00040120,
        MARSHAL_S_LAST = 0x0004012F,
        MK_E_FIRST = unchecked((int)0x800401E0),
        MK_E_LAST = unchecked((int)0x800401EF),
        MK_S_FIRST = 0x000401E0,
        MK_S_LAST = 0x000401EF,
        MK_E_CONNECTMANUALLY = unchecked((int)0x800401E0),
        MK_E_EXCEEDEDDEADLINE = unchecked((int)0x800401E1),
        MK_E_NEEDGENERIC = unchecked((int)0x800401E2),
        MK_E_UNAVAILABLE = unchecked((int)0x800401E3),
        MK_E_SYNTAX = unchecked((int)0x800401E4),
        MK_E_NOOBJECT = unchecked((int)0x800401E5),
        MK_E_INVALIDEXTENSION = unchecked((int)0x800401E6),
        MK_E_INTERMEDIATEINTERFACENOTSUPPORTED = unchecked((int)0x800401E7),
        MK_E_NOTBINDABLE = unchecked((int)0x800401E8),
        MK_E_NOTBOUND = unchecked((int)0x800401E9),
        MK_E_CANTOPENFILE = unchecked((int)0x800401EA),
        MK_E_MUSTBOTHERUSER = unchecked((int)0x800401EB),
        MK_E_NOINVERSE = unchecked((int)0x800401EC),
        MK_E_NOSTORAGE = unchecked((int)0x800401ED),
        MK_E_NOPREFIX = unchecked((int)0x800401EE),
        MK_E_ENUMERATION_FAILED = unchecked((int)0x800401EF),
        MK_S_REDUCED_TO_SELF = 0x000401E2,
        MK_S_ME = 0x000401E4,
        MK_S_HIM = 0x000401E5,
        MK_S_US = 0x000401E6,
        MK_S_MONIKERALREADYREGISTERED = 0x000401E7,
        MK_E_NO_NORMALIZED = unchecked((int)0x80080007),
        MEM_E_INVALID_ROOT = unchecked((int)0x80080009),
        MEM_E_INVALID_LINK = unchecked((int)0x80080010),
        MEM_E_INVALID_SIZE = unchecked((int)0x80080011),
        MAXSTRETCHBLTMODE = 4,
        META_SETBKCOLOR = 0x0201,
        META_SETBKMODE = 0x0102,
        META_SETMAPMODE = 0x0103,
        META_SETROP2 = 0x0104,
        META_SETRELABS = 0x0105,
        META_SETPOLYFILLMODE = 0x0106,
        META_SETSTRETCHBLTMODE = 0x0107,
        META_SETTEXTCHAREXTRA = 0x0108,
        META_SETTEXTCOLOR = 0x0209,
        META_SETTEXTJUSTIFICATION = 0x020A,
        META_SETWINDOWORG = 0x020B,
        META_SETWINDOWEXT = 0x020C,
        META_SETVIEWPORTORG = 0x020D,
        META_SETVIEWPORTEXT = 0x020E,
        META_OFFSETWINDOWORG = 0x020F,
        META_SCALEWINDOWEXT = 0x0410,
        META_OFFSETVIEWPORTORG = 0x0211,
        META_SCALEVIEWPORTEXT = 0x0412,
        META_LINETO = 0x0213,
        META_MOVETO = 0x0214,
        META_EXCLUDECLIPRECT = 0x0415,
        META_INTERSECTCLIPRECT = 0x0416,
        META_ARC = 0x0817,
        META_ELLIPSE = 0x0418,
        META_FLOODFILL = 0x0419,
        META_PIE = 0x081A,
        META_RECTANGLE = 0x041B,
        META_ROUNDRECT = 0x061C,
        META_PATBLT = 0x061D,
        META_SAVEDC = 0x001E,
        META_SETPIXEL = 0x041F,
        META_OFFSETCLIPRGN = 0x0220,
        META_TEXTOUT = 0x0521,
        META_BITBLT = 0x0922,
        META_STRETCHBLT = 0x0B23,
        META_POLYGON = 0x0324,
        META_POLYLINE = 0x0325,
        META_ESCAPE = 0x0626,
        META_RESTOREDC = 0x0127,
        META_FILLREGION = 0x0228,
        META_FRAMEREGION = 0x0429,
        META_INVERTREGION = 0x012A,
        META_PAINTREGION = 0x012B,
        META_SELECTCLIPREGION = 0x012C,
        META_SELECTOBJECT = 0x012D,
        META_SETTEXTALIGN = 0x012E,
        META_CHORD = 0x0830,
        META_SETMAPPERFLAGS = 0x0231,
        META_EXTTEXTOUT = 0x0a32,
        META_SETDIBTODEV = 0x0d33,
        META_SELECTPALETTE = 0x0234,
        META_REALIZEPALETTE = 0x0035,
        META_ANIMATEPALETTE = 0x0436,
        META_SETPALENTRIES = 0x0037,
        META_POLYPOLYGON = 0x0538,
        META_RESIZEPALETTE = 0x0139,
        META_DIBBITBLT = 0x0940,
        META_DIBSTRETCHBLT = 0x0b41,
        META_DIBCREATEPATTERNBRUSH = 0x0142,
        META_STRETCHDIB = 0x0f43,
        META_EXTFLOODFILL = 0x0548,
        META_DELETEOBJECT = 0x01f0,
        META_CREATEPALETTE = 0x00f7,
        META_CREATEPATTERNBRUSH = 0x01F9,
        META_CREATEPENINDIRECT = 0x02FA,
        META_CREATEFONTINDIRECT = 0x02FB,
        META_CREATEBRUSHINDIRECT = 0x02FC,
        META_CREATEREGION = 0x06FF,
        MFCOMMENT = 15,
        MOUSETRAILS = 39,
        MWT_IDENTITY = 1,
        MWT_LEFTMULTIPLY = 2,
        MWT_RIGHTMULTIPLY = 3,
        MWT_MIN = 1,
        MWT_MAX = 3,
        MONO_FONT = 8,
        MAC_CHARSET = 77,
        MM_TEXT = 1,
        MM_LOMETRIC = 2,
        MM_HIMETRIC = 3,
        MM_LOENGLISH = 4,
        MM_HIENGLISH = 5,
        MM_TWIPS = 6,
        MM_ISOTROPIC = 7,
        MM_ANISOTROPIC = 8,
        MM_MIN = 1,
        MM_MAX = 8,
        MM_MAX_FIXEDSCALE = 6,
        MAX_LEADBYTES = 12,
        MAX_DEFAULTCHAR = 2,
        MB_PRECOMPOSED = 0x00000001,
        MB_COMPOSITE = 0x00000002,
        MB_USEGLYPHCHARS = 0x00000004,
        MB_ERR_INVALID_CHARS = 0x00000008,
        MAP_FOLDCZONE = 0x00000010,
        MAP_PRECOMPOSED = 0x00000020,
        MAP_COMPOSITE = 0x00000040,
        MAP_FOLDDIGITS = 0x00000080;
        public const long MAXLONGLONG = (0x7fffffffffffffffL);
        public const int MINCHAR = unchecked((int)0x80),
        MAXCHAR = 0x7f,
        MINSHORT = unchecked((int)0x8000),
        MAXSHORT = 0x7fff,
        MINLONG = unchecked((int)0x80000000),
        MAXLONG = 0x7fffffff,
        MAXBYTE = 0xff,
        MAXWORD = 0xffff,
        MAXDWORD = unchecked((int)0xFfffffff),
        MAXIMUM_WAIT_OBJECTS = 64,
        MAXIMUM_SUSPEND_COUNT = 0x7f,
        MAXIMUM_PROCESSORS = 32,
        MUTANT_QUERY_STATE = 0x0001,
        MEM_COMMIT = 0x1000,
        MEM_RESERVE = 0x2000,
        MEM_DECOMMIT = 0x4000,
        MEM_RELEASE = unchecked((int)0x8000),
        MEM_FREE = 0x10000,
        MEM_PRIVATE = 0x20000,
        MEM_MAPPED = 0x40000,
        MEM_RESET = unchecked((int)0x80000),
        MEM_TOP_DOWN = 0x100000,
        MEM_IMAGE = 0x1000000,
        MAILSLOT_NO_MESSAGE = (-1),
        MAILSLOT_WAIT_FOREVER = (-1),
        MAXIMUM_ALLOWED = (0x02000000),
        MESSAGE_RESOURCE_UNICODE = 0x0001,
        MAX_PRIORITY = 99,
        MIN_PRIORITY = 1,
        MSGF_DIALOGBOX = 0,
        MSGF_MESSAGEBOX = 1,
        MSGF_MENU = 2,
        MSGF_MOVE = 3,
        MSGF_SIZE = 4,
        MSGF_SCROLLBAR = 5,
        MSGF_NEXTWINDOW = 6,
        MSGF_MAINLOOP = 8,
        MSGF_MAX = 8,
        MSGF_USER = 4096,
        MENULOOP_WINDOW = 0,
        MENULOOP_POPUP = 1,
        MA_ACTIVATE = 1,
        MA_ACTIVATEANDEAT = 2,
        MA_NOACTIVATE = 3,
        MA_NOACTIVATEANDEAT = 4,
        MK_LBUTTON = 0x0001,
        MK_RBUTTON = 0x0002,
        MK_SHIFT = 0x0004,
        MK_CONTROL = 0x0008,
        MK_MBUTTON = 0x0010,
        MOD_WIN = 0x0008,
        MOUSEEVENTF_MOVE = 0x0001,
        MOUSEEVENTF_LEFTDOWN = 0x0002,
        MOUSEEVENTF_LEFTUP = 0x0004,
        MOUSEEVENTF_RIGHTDOWN = 0x0008,
        MOUSEEVENTF_RIGHTUP = 0x0010,
        MOUSEEVENTF_MIDDLEDOWN = 0x0020,
        MOUSEEVENTF_MIDDLEUP = 0x0040,
        MOUSEEVENTF_WHEEL = 0x0800,
        MOUSEEVENTF_ABSOLUTE = unchecked((int)0x8000),
        MWMO_WAITALL = 0x0001,
        MWMO_ALERTABLE = 0x0002,
        MNC_IGNORE = 0,
        MNC_CLOSE = 1,
        MNC_EXECUTE = 2,
        MNC_SELECT = 3,
        MIIM_STATE = 0x00000001,
        MIIM_ID = 0x00000002,
        MIIM_SUBMENU = 0x00000004,
        MIIM_CHECKMARKS = 0x00000008,
        MIIM_TYPE = 0x00000010,
        MIIM_DATA = 0x00000020,
        MB_OK = 0x00000000,
        MB_OKCANCEL = 0x00000001,
        MB_ABORTRETRYIGNORE = 0x00000002,
        MB_YESNOCANCEL = 0x00000003,
        MB_YESNO = 0x00000004,
        MB_RETRYCANCEL = 0x00000005,
        MB_ICONHAND = 0x00000010,
        MB_ICONQUESTION = 0x00000020,
        MB_ICONEXCLAMATION = 0x00000030,
        MB_ICONASTERISK = 0x00000040,
        MB_USERICON = 0x00000080,
        MB_ICONWARNING = 0x00000030,
        MB_ICONERROR = 0x00000010,
        MB_ICONINFORMATION = 0x00000040,
        MB_DEFBUTTON1 = 0x00000000,
        MB_DEFBUTTON2 = 0x00000100,
        MB_DEFBUTTON3 = 0x00000200,
        MB_DEFBUTTON4 = 0x00000300,
        MB_APPLMODAL = 0x00000000,
        MB_SYSTEMMODAL = 0x00001000,
        MB_TASKMODAL = 0x00002000,
        MB_HELP = 0x00004000,
        MB_NOFOCUS = 0x00008000,
        MB_SETFOREGROUND = 0x00010000,
        MB_DEFAULT_DESKTOP_ONLY = 0x00020000,
        MB_TOPMOST = 0x00040000,
        MB_RIGHT = 0x00080000,
        MB_RTLREADING = 0x00100000,
        MB_SERVICE_NOTIFICATION = 0x00200000;
        // MB_SERVICE_NOTIFICATION = 0x00040000;
        public const int MB_SERVICE_NOTIFICATION_NT3X = 0x00040000,
        MB_TYPEMASK = 0x0000000F,
        MB_ICONMASK = 0x000000F0,
        MB_DEFMASK = 0x00000F00,
        MB_MODEMASK = 0x00003000,
        MB_MISCMASK = 0x0000C000,
        MF_INSERT = 0x00000000,
        MF_CHANGE = 0x00000080,
        MF_APPEND = 0x00000100,
        MF_DELETE = 0x00000200,
        MF_REMOVE = 0x00001000,
        MF_BYCOMMAND = 0x00000000,
        MF_BYPOSITION = 0x00000400,
        MF_SEPARATOR = 0x00000800,
        MF_ENABLED = 0x00000000,
        MF_GRAYED = 0x00000001,
        MF_DISABLED = 0x00000002,
        MF_UNCHECKED = 0x00000000,
        MF_CHECKED = 0x00000008,
        MF_USECHECKBITMAPS = 0x00000200,
        MF_STRING = 0x00000000,
        MF_BITMAP = 0x00000004,
        MF_OWNERDRAW = 0x00000100,
        MF_POPUP = 0x00000010,
        MF_MENUBARBREAK = 0x00000020,
        MF_MENUBREAK = 0x00000040,
        MF_UNHILITE = 0x00000000,
        MF_HILITE = 0x00000080,
        MF_DEFAULT = 0x00001000,
        MF_SYSMENU = 0x00002000,
        MF_HELP = 0x00004000,
        MF_RIGHTJUSTIFY = 0x00004000,
        MF_MOUSESELECT = 0x00008000,
        MF_END = 0x00000080,
        MFT_STRING = 0x00000000,
        MFT_BITMAP = 0x00000004,
        MFT_MENUBARBREAK = 0x00000020,
        MFT_MENUBREAK = 0x00000040,
        MFT_OWNERDRAW = 0x00000100,
        MFT_RADIOCHECK = 0x00000200,
        MFT_SEPARATOR = 0x00000800,
        MFT_RIGHTORDER = 0x00002000,
        MFT_RIGHTJUSTIFY = 0x00004000,
        MFS_GRAYED = 0x00000003,
        MFS_DISABLED = 0x00000003,
        MFS_CHECKED = 0x00000008,
        MFS_HILITE = 0x00000080,
        MFS_ENABLED = 0x00000000,
        MFS_UNCHECKED = 0x00000000,
        MFS_UNHILITE = 0x00000000,
        MFS_DEFAULT = 0x00001000,
        MDIS_ALLCHILDSTYLES = 0x0001,
        MDITILE_VERTICAL = 0x0000,
        MDITILE_HORIZONTAL = 0x0001,
        MDITILE_SKIPDISABLED = 0x0002,
        METRICS_USEDEFAULT = -1,
        MKF_MOUSEKEYSON = 0x00000001,
        MKF_AVAILABLE = 0x00000002,
        MKF_HOTKEYACTIVE = 0x00000004,
        MKF_CONFIRMHOTKEY = 0x00000008,
        MKF_HOTKEYSOUND = 0x00000010,
        MKF_INDICATOR = 0x00000020,
        MKF_MODIFIERS = 0x00000040,
        MKF_REPLACENUMBERS = 0x00000080,
        MCN_FIRST = (0-750),
                    MCN_LAST = (0-759),
                               MSGF_COMMCTRL_BEGINDRAG = 0x4200,
        MSGF_COMMCTRL_SIZEHEADER = 0x4201,
        MSGF_COMMCTRL_DRAGSELECT = 0x4202,
        MSGF_COMMCTRL_TOOLBARCUST = 0x4203,
        MINSYSCOMMAND = 0xF000,
        MCM_FIRST = 0x1000,
        MCM_GETCURSEL = (0x1000+1),
                        MCM_SETCURSEL = (0x1000+2),
                                        MCM_GETMAXSELCOUNT = (0x1000+3),
                                                             MCM_SETMAXSELCOUNT = (0x1000+4),
                                                                                  MCM_GETSELRANGE = (0x1000+5),
                                                                                                    MCM_SETSELRANGE = (0x1000+6),
                                                                                                                      MCM_GETMONTHRANGE = (0x1000+7),
                                                                                                                                          MCM_SETDAYSTATE = (0x1000+8),
                                                                                                                                                            MCM_GETMINREQRECT = (0x1000+9),
                                                                                                                                                                                MCM_SETCOLOR = (0x1000+10),
                                                                                                                                                                                               MCM_GETCOLOR = (0x1000+11),
                                                                                                                                                                                                              MCM_SETTODAY = (0x1000+12),
                                                                                                                                                                                                                             MCM_GETTODAY = (0x1000+13),
                                                                                                                                                                                                                                            MCM_HITTEST = (0x1000+14),
                                                                                                                                                                                                                                                          MCM_SETFIRSTDAYOFWEEK = (0x1000+15),
                                                                                                                                                                                                                                                                                  MCM_GETFIRSTDAYOFWEEK = (0x1000+16),
                                                                                                                                                                                                                                                                                                          MCM_GETRANGE = (0x1000+17),
                                                                                                                                                                                                                                                                                                                         MCM_SETRANGE = (0x1000+18),
                                                                                                                                                                                                                                                                                                                                        MCM_GETMONTHDELTA = (0x1000+19),
                                                                                                                                                                                                                                                                                                                                                            MCM_SETMONTHDELTA = (0x1000+20),
                                                                                                                                                                                                                                                                                                                                                                                MCM_GETMAXTODAYWIDTH = (0x1000+21),
                                                                                                                                                                                                                                                                                                                                                                                                       MCHT_TITLE = 0x00010000,
        MCHT_CALENDAR = 0x00020000,
        MCHT_TODAYLINK = 0x00030000,
        MCHT_NEXT = 0x01000000,
        MCHT_PREV = 0x02000000,
        MCHT_NOWHERE = 0x00000000,
        MCHT_TITLEBK = (0x00010000),
                       MCHT_TITLEMONTH = (0x00010000|0x0001),
                                         MCHT_TITLEYEAR = (0x00010000|0x0002),
                                                          MCHT_TITLEBTNNEXT = (0x00010000|0x01000000|0x0003),
                                                                              MCHT_TITLEBTNPREV = (0x00010000|0x02000000|0x0003),
                                                                                                  MCHT_CALENDARBK = (0x00020000),
                                                                                                                    MCHT_CALENDARDATE = (0x00020000|0x0001),
                                                                                                                                        MCHT_CALENDARDATENEXT = ((0x00020000|0x0001)|0x01000000),
                                                                                                                                                                MCHT_CALENDARDATEPREV = ((0x00020000|0x0001)|0x02000000),
                                                                                                                                                                                        MCHT_CALENDARDAY = (0x00020000|0x0002),
                                                                                                                                                                                                           MCHT_CALENDARWEEKNUM = (0x00020000|0x0003),
                                                                                                                                                                                                                                  MCSC_BACKGROUND = 0,
        MCSC_TEXT = 1,
        MCSC_TITLEBK = 2,
        MCSC_TITLETEXT = 3,
        MCSC_MONTHBK = 4,
        MCSC_TRAILINGTEXT = 5,
        MCN_SELCHANGE = ((0-750)+1),
                        MCN_GETDAYSTATE = ((0-750)+3),
                                          MCN_SELECT = ((0-750)+4),
                                                       MCS_DAYSTATE = 0x0001,
        MCS_MULTISELECT = 0x0002,
        MCS_WEEKNUMBERS = 0x0004,
        MCS_NOTODAYCIRCLE = 0x0008,
        MUTEX_MODIFY_STATE = 0x0001,
        MERGECOPY = 0x00C000CA,
        MERGEPAINT = 0x00BB0226;





        public const int NEWFILEOPENORD = 1547,
        NI_OPENCANDIDATE = 0x0010,
        NI_CLOSECANDIDATE = 0x0011,
        NI_SELECTCANDIDATESTR = 0x0012,
        NI_CHANGECANDIDATELIST = 0x0013,
        NI_FINALIZECONVERSIONRESULT = 0x0014,
        NI_COMPOSITIONSTR = 0x0015,
        NI_SETCANDIDATE_PAGESTART = 0x0016,
        NI_SETCANDIDATE_PAGESIZE = 0x0017,
        NEWTRANSPARENT = 3,
        NCBNAMSZ = 16,
        NAME_FLAGS_MASK = unchecked((int)0x87),
        NCBCALL = 0x10,
        NCBLISTEN = 0x11,
        NCBHANGUP = 0x12,
        NCBSEND = 0x14,
        NCBRECV = 0x15,
        NCBRECVANY = 0x16,
        NCBCHAINSEND = 0x17,
        NCBDGSEND = 0x20,
        NCBDGRECV = 0x21,
        NCBDGSENDBC = 0x22,
        NCBDGRECVBC = 0x23,
        NCBADDNAME = 0x30,
        NCBDELNAME = 0x31,
        NCBRESET = 0x32,
        NCBASTAT = 0x33,
        NCBSSTAT = 0x34,
        NCBCANCEL = 0x35,
        NCBADDGRNAME = 0x36,
        NCBENUM = 0x37,
        NCBUNLINK = 0x70,
        NCBSENDNA = 0x71,
        NCBCHAINSENDNA = 0x72,
        NCBLANSTALERT = 0x73,
        NCBACTION = 0x77,
        NCBFINDNAME = 0x78,
        NCBTRACE = 0x79,
        NRC_GOODRET = 0x00,
        NRC_BUFLEN = 0x01,
        NRC_ILLCMD = 0x03,
        NRC_CMDTMO = 0x05,
        NRC_INCOMP = 0x06,
        NRC_BADDR = 0x07,
        NRC_SNUMOUT = 0x08,
        NRC_NORES = 0x09,
        NRC_SCLOSED = 0x0a,
        NRC_CMDCAN = 0x0b,
        NRC_DUPNAME = 0x0d,
        NRC_NAMTFUL = 0x0e,
        NRC_ACTSES = 0x0f,
        NRC_LOCTFUL = 0x11,
        NRC_REMTFUL = 0x12,
        NRC_ILLNN = 0x13,
        NRC_NOCALL = 0x14,
        NRC_NOWILD = 0x15,
        NRC_INUSE = 0x16,
        NRC_NAMERR = 0x17,
        NRC_SABORT = 0x18,
        NRC_NAMCONF = 0x19,
        NRC_IFBUSY = 0x21,
        NRC_TOOMANY = 0x22,
        NRC_BRIDGE = 0x23,
        NRC_CANOCCR = 0x24,
        NRC_CANCEL = 0x26,
        NRC_DUPENV = 0x30,
        NRC_ENVNOTDEF = 0x34,
        NRC_OSRESNOTAV = 0x35,
        NRC_MAXAPPS = 0x36,
        NRC_NOSAPS = 0x37,
        NRC_NORESOURCES = 0x38,
        NRC_INVADDRESS = 0x39,
        NRC_INVDDID = 0x3B,
        NRC_LOCKFAIL = 0x3C,
        NRC_OPENERR = 0x3f,
        NRC_SYSTEM = 0x40,
        NRC_PENDING = 0xff,
        NUMPRS_LEADING_WHITE = 0x0001,
        NUMPRS_TRAILING_WHITE = 0x0002,
        NUMPRS_LEADING_PLUS = 0x0004,
        NUMPRS_TRAILING_PLUS = 0x0008,
        NUMPRS_LEADING_MINUS = 0x0010,
        NUMPRS_TRAILING_MINUS = 0x0020,
        NUMPRS_HEX_OCT = 0x0040,
        NUMPRS_PARENS = 0x0080,
        NUMPRS_DECIMAL = 0x0100,
        NUMPRS_THOUSANDS = 0x0200,
        NUMPRS_CURRENCY = 0x0400,
        NUMPRS_EXPONENT = 0x0800,
        NUMPRS_USE_ALL = 0x1000,
        NUMPRS_STD = 0x1FFF,
        NUMPRS_NEG = 0x10000,
        NUMPRS_INEXACT = 0x20000,
        NT351_INTERFACE_SIZE = 0x40,
        NIM_ADD = 0x00000000,
        NIM_MODIFY = 0x00000001,
        NIM_DELETE = 0x00000002,
        NIF_MESSAGE = 0x00000001,
        NIF_ICON = 0x00000002,
        NIF_TIP = 0x00000004,
        NONZEROLHND = 0x0002,
        NONZEROLPTR = 0x0000,
        NORMAL_PRIORITY_CLASS = 0x00000020,
        NOPARITY = 0,
        NMPWAIT_WAIT_FOREVER = unchecked((int)0xFfffffff),
        NMPWAIT_NOWAIT = 0x00000001,
        NMPWAIT_USE_DEFAULT_WAIT = 0x00000000,
        NUMLOCK_ON = 0x0020,
        NULL = 0,
        NO_ERROR = 0,
        NOERROR = 0,
        NTE_BAD_UID = unchecked((int)0x80090001),
        NTE_BAD_HASH = unchecked((int)0x80090002),
        NTE_BAD_KEY = unchecked((int)0x80090003),
        NTE_BAD_LEN = unchecked((int)0x80090004),
        NTE_BAD_DATA = unchecked((int)0x80090005),
        NTE_BAD_SIGNATURE = unchecked((int)0x80090006),
        NTE_BAD_VER = unchecked((int)0x80090007),
        NTE_BAD_ALGID = unchecked((int)0x80090008),
        NTE_BAD_FLAGS = unchecked((int)0x80090009),
        NTE_BAD_TYPE = unchecked((int)0x8009000A),
        NTE_BAD_KEY_STATE = unchecked((int)0x8009000B),
        NTE_BAD_HASH_STATE = unchecked((int)0x8009000C),
        NTE_NO_KEY = unchecked((int)0x8009000D),
        NTE_NO_MEMORY = unchecked((int)0x8009000E),
        NTE_EXISTS = unchecked((int)0x8009000F),
        NTE_PERM = unchecked((int)0x80090010),
        NTE_NOT_FOUND = unchecked((int)0x80090011),
        NTE_DOUBLE_ENCRYPT = unchecked((int)0x80090012),
        NTE_BAD_PROVIDER = unchecked((int)0x80090013),
        NTE_BAD_PROV_TYPE = unchecked((int)0x80090014),
        NTE_BAD_PUBLIC_KEY = unchecked((int)0x80090015),
        NTE_BAD_KEYSET = unchecked((int)0x80090016),
        NTE_PROV_TYPE_NOT_DEF = unchecked((int)0x80090017),
        NTE_PROV_TYPE_ENTRY_BAD = unchecked((int)0x80090018),
        NTE_KEYSET_NOT_DEF = unchecked((int)0x80090019),
        NTE_KEYSET_ENTRY_BAD = unchecked((int)0x8009001A),
        NTE_PROV_TYPE_NO_MATCH = unchecked((int)0x8009001B),
        NTE_SIGNATURE_FILE_BAD = unchecked((int)0x8009001C),
        NTE_PROVIDER_DLL_FAIL = unchecked((int)0x8009001D),
        NTE_PROV_DLL_NOT_FOUND = unchecked((int)0x8009001E),
        NTE_BAD_KEYSET_PARAM = unchecked((int)0x8009001F),
        NTE_FAIL = unchecked((int)0x80090020),
        NTE_SYS_ERR = unchecked((int)0x80090021),
        NTE_OP_OK = 0,
        NULLREGION = 1,
        NEWFRAME = 1,
        NEXTBAND = 3,
        NTM_REGULAR = 0x00000040,
        NTM_BOLD = 0x00000020,
        NTM_ITALIC = 0x00000001,
        NONANTIALIASED_QUALITY = 3,
        NULL_BRUSH = 5,
        NULL_PEN = 8,
        NUMBRUSHES = 16,
        NUMPENS = 18,
        NUMMARKERS = 20,
        NUMFONTS = 22,
        NUMCOLORS = 24,
        NUMRESERVED = 106,
        NETPROPERTY_PERSISTENT = 1,
        NETINFO_DLL16 = 0x00000001,
        NETINFO_DISKRED = 0x00000004,
        NETINFO_PRINTERRED = 0x00000008,
        NORM_IGNORECASE = 0x00000001,
        NORM_IGNORENONSPACE = 0x00000002,
        NORM_IGNORESYMBOLS = 0x00000004,
        NORM_IGNOREKANATYPE = 0x00010000,
        NORM_IGNOREWIDTH = 0x00020000,
        NLS_VALID_LOCALE_MASK = 0x000fffff,
        NO_PROPAGATE_INHERIT_ACE = (0x4),
                                   N_BTMASK = 0x000F,
        N_TMASK = 0x0030,
        N_TMASK1 = 0x00C0,
        N_TMASK2 = 0x00F0,
        N_BTSHFT = 4,
        N_TSHIFT = 2,
        NO_PRIORITY = 0,
        NFR_ANSI = 1,
        NFR_UNICODE = 2,
        NF_QUERY = 3,
        NF_REQUERY = 4,
        NM_FIRST = (0-0),
        NM_LAST = (0-99),
        NM_OUTOFMEMORY = ((0-0)-1),
        NM_CLICK = ((0-0)-2),
        NM_DBLCLK = ((0-0)-3),
        NM_RETURN = ((0-0)-4),
        NM_RCLICK = ((0-0)-5),
        NM_RDBLCLK = ((0-0)-6),
        NM_SETFOCUS = ((0-0)-7),
        NM_KILLFOCUS = ((0-0)-8),
        NM_CUSTOMDRAW = ((0-0)-12),
        NM_HOVER = ((0-0)-13),
        NM_RELEASEDCAPTURE = ((0-0)-16),
        NOTSRCCOPY = 0x00330008,
        NOTSRCERASE = 0x001100A6;



        public const int OFN_READONLY = 0x00000001,
        OFN_OVERWRITEPROMPT = 0x00000002,
        OFN_HIDEREADONLY = 0x00000004,
        OFN_NOCHANGEDIR = 0x00000008,
        OFN_SHOWHELP = 0x00000010,
        OFN_ENABLEHOOK = 0x00000020,
        OFN_ENABLETEMPLATE = 0x00000040,
        OFN_ENABLETEMPLATEHANDLE = 0x00000080,
        OFN_NOVALIDATE = 0x00000100,
        OFN_ALLOWMULTISELECT = 0x00000200,
        OFN_EXTENSIONDIFFERENT = 0x00000400,
        OFN_PATHMUSTEXIST = 0x00000800,
        OFN_FILEMUSTEXIST = 0x00001000,
        OFN_CREATEPROMPT = 0x00002000,
        OFN_SHAREAWARE = 0x00004000,
        OFN_NOREADONLYRETURN = 0x00008000,
        OFN_NOTESTFILECREATE = 0x00010000,
        OFN_NONETWORKBUTTON = 0x00020000,
        OFN_NOLONGNAMES = 0x00040000,
        OFN_EXPLORER = 0x00080000,
        OFN_NODEREFERENCELINKS = 0x00100000,
        OFN_ENABLEINCLUDENOTIFY = 0x00400000,
        OFN_ENABLESIZING = 0x00800000,
        OFN_LONGNAMES = 0x00200000,
        OFN_SHAREFALLTHROUGH = 2,
        OFN_SHARENOWARN = 1,
        OFN_SHAREWARN = 0,
        OFN_USESHELLITEM = 0x01000000,
        OFN_DONTADDTORECENT = 0x02000000,
        OFN_FORCESHOWHIDDEN = 0x10000000,
        OLEIVERB_PRIMARY = 0,
        OLEIVERB_SHOW = -1,
        OLEIVERB_OPEN = -2,
        OLEIVERB_HIDE = -3,
        OLEIVERB_UIACTIVATE = -4,
        OLEIVERB_INPLACEACTIVATE = -5,
        OLEIVERB_DISCARDUNDOSTATE = -6,
        OLEIVERB_PROPERTIES = -7,
        OLECREATE_LEAVERUNNING = 0x00000001,
        OPEN_EXISTING = 3,
        OPEN_ALWAYS = 4,
        OUTPUT_DEBUG_STRING_EVENT = 8,
        ODDPARITY = 1,
        ONESTOPBIT = 0,
        ONE5STOPBITS = 1,
        OF_READ = 0x00000000,
        OF_WRITE = 0x00000001,
        OF_READWRITE = 0x00000002,
        OF_SHARE_COMPAT = 0x00000000,
        OF_SHARE_EXCLUSIVE = 0x00000010,
        OF_SHARE_DENY_WRITE = 0x00000020,
        OF_SHARE_DENY_READ = 0x00000030,
        OF_SHARE_DENY_NONE = 0x00000040,
        OF_PARSE = 0x00000100,
        OF_DELETE = 0x00000200,
        OF_VERIFY = 0x00000400,
        OF_CANCEL = 0x00000800,
        OF_CREATE = 0x00001000,
        OF_PROMPT = 0x00002000,
        OF_EXIST = 0x00004000,
        OF_REOPEN = 0x00008000,
        OFS_MAXPATHNAME = 128,
        OR_INVALID_OXID = 1910,
        OR_INVALID_OID = 1911,
        OR_INVALID_SET = 1912,
        OLE_E_OLEVERB = unchecked((int)0x80040000),
        OLE_E_ADVF = unchecked((int)0x80040001),
        OLE_E_ENUM_NOMORE = unchecked((int)0x80040002),
        OLE_E_ADVISENOTSUPPORTED = unchecked((int)0x80040003),
        OLE_E_NOCONNECTION = unchecked((int)0x80040004),
        OLE_E_NOTRUNNING = unchecked((int)0x80040005),
        OLE_E_NOCACHE = unchecked((int)0x80040006),
        OLE_E_BLANK = unchecked((int)0x80040007),
        OLE_E_CLASSDIFF = unchecked((int)0x80040008),
        OLE_E_CANT_GETMONIKER = unchecked((int)0x80040009),
        OLE_E_CANT_BINDTOSOURCE = unchecked((int)0x8004000A),
        OLE_E_STATIC = unchecked((int)0x8004000B),
        OLE_E_PROMPTSAVECANCELLED = unchecked((int)0x8004000C),
        OLE_E_INVALIDRECT = unchecked((int)0x8004000D),
        OLE_E_WRONGCOMPOBJ = unchecked((int)0x8004000E),
        OLE_E_INVALIDHWND = unchecked((int)0x8004000F),
        OLE_E_NOT_INPLACEACTIVE = unchecked((int)0x80040010),
        OLE_E_CANTCONVERT = unchecked((int)0x80040011),
        OLE_E_NOSTORAGE = unchecked((int)0x80040012),
        OLECMDERR_E_NOTSUPPORTED = unchecked((int)0x80040100),
        OLECMDERR_E_DISABLED  = unchecked((int)0x80040101),
        OLECMDERR_E_NOHELP  = unchecked((int)0x80040102),
        OLECMDERR_E_CANCELED  = unchecked((int)0x80040103),
        OLECMDERR_E_UNKNOWNGROUP  = unchecked((int)0x80040104),
        OLEMISC_RECOMPOSEONRESIZE = 0x00000001,
        OLEMISC_ONLYICONIC = 0x00000002,
        OLEMISC_INSERTNOTREPLACE = 0x00000004,
        OLEMISC_STATIC = 0x00000008,
        OLEMISC_CANTLINKINSIDE = 0x00000010,
        OLEMISC_CANLINKBYOLE1 = 0x00000020,
        OLEMISC_ISLINKOBJECT = 0x00000040,
        OLEMISC_INSIDEOUT = 0x00000080,
        OLEMISC_ACTIVATEWHENVISIBLE = 0x0000100,
        OLEMISC_RENDERINGISDEVICEINDEPENDENT = 0x00000200,
        OLEMISC_INVISIBLEATRUNTIME = 0x00000400,
        OLEMISC_ALWAYSRUN = 0x00000800,
        OLEMISC_ACTSLIKEBUTTON = 0x00001000,
        OLEMISC_ACTSLIKELABEL = 0x00002000,
        OLEMISC_NOUIACTIVATE = 0x00004000,
        OLEMISC_ALIGNABLE = 0x00008000,
        OLEMISC_SIMPLEFRAME = 0x00010000,
        OLEMISC_SETCLIENTSITEFIRST = 0x00020000,
        OLEMISC_IMEMODE = 0x00040000,
        OLEOBJ_E_FIRST = unchecked((int)0x80040180),
        OLEOBJ_E_LAST = unchecked((int)0x8004018F),
        OLEOBJ_S_FIRST = 0x00040180,
        OLEOBJ_S_LAST = 0x0004018F,
        OLEOBJ_E_NOVERBS = unchecked((int)0x80040180),
        OLEOBJ_E_INVALIDVERB = unchecked((int)0x80040181),
        OLE_S_USEREG = 0x00040000,
        OLE_S_STATIC = 0x00040001,
        OLE_S_MAC_CLIPFORMAT = 0x00040002,
        OLEOBJ_S_INVALIDVERB = 0x00040180,
        OLEOBJ_S_CANNOT_DOVERB_NOW = 0x00040181,
        OLEOBJ_S_INVALIDHWND = 0x00040182,
        OPENCHANNEL = 4110,
        OBJ_PEN = 1,
        OBJ_BRUSH = 2,
        OBJ_DC = 3,
        OBJ_METADC = 4,
        OBJ_PAL = 5,
        OBJ_FONT = 6,
        OBJ_BITMAP = 7,
        OBJ_REGION = 8,
        OBJ_METAFILE = 9,
        OBJ_MEMDC = 10,
        OBJ_EXTPEN = 11,
        OBJ_ENHMETADC = 12,
        OBJ_ENHMETAFILE = 13,
        OUT_DEFAULT_PRECIS = 0,
        OUT_STRING_PRECIS = 1,
        OUT_CHARACTER_PRECIS = 2,
        OUT_STROKE_PRECIS = 3,
        OUT_TT_PRECIS = 4,
        OUT_DEVICE_PRECIS = 5,
        OUT_RASTER_PRECIS = 6,
        OUT_TT_ONLY_PRECIS = 7,
        OUT_OUTLINE_PRECIS = 8,
        OUT_SCREEN_OUTLINE_PRECIS = 9,
        OEM_CHARSET = 255,
        OPAQUE = 2,
        OEM_FIXED_FONT = 10,
        OBJECT_INHERIT_ACE = (0x1),
                             OWNER_SECURITY_INFORMATION = (0X00000001),
                                                          ODT_MENU = 1,
        ODT_LISTBOX = 2,
        ODT_COMBOBOX = 3,
        ODT_BUTTON = 4,
        ODT_STATIC = 5,
        ODA_DRAWENTIRE = 0x0001,
        ODA_SELECT = 0x0002,
        ODA_FOCUS = 0x0004,

        ODS_CHECKED = 0x0008,
        ODS_COMBOBOXEDIT = 0x1000,
        ODS_DEFAULT = 0x0020,
        ODS_DISABLED = 0x0004,
        ODS_FOCUS = 0x0010,
        ODS_GRAYED = 0x0002,
        ODS_HOTLIGHT       = 0x0040,
        ODS_INACTIVE       = 0x0080,
        ODS_NOACCEL        = 0x0100,
        ODS_NOFOCUSRECT    = 0x0200,
        ODS_SELECTED = 0x0001,

        OBM_CLOSE = 32754,
        OBM_UPARROW = 32753,
        OBM_DNARROW = 32752,
        OBM_RGARROW = 32751,
        OBM_LFARROW = 32750,
        OBM_REDUCE = 32749,
        OBM_ZOOM = 32748,
        OBM_RESTORE = 32747,
        OBM_REDUCED = 32746,
        OBM_ZOOMD = 32745,
        OBM_RESTORED = 32744,
        OBM_UPARROWD = 32743,
        OBM_DNARROWD = 32742,
        OBM_RGARROWD = 32741,
        OBM_LFARROWD = 32740,
        OBM_MNARROW = 32739,
        OBM_COMBO = 32738,
        OBM_UPARROWI = 32737,
        OBM_DNARROWI = 32736,
        OBM_RGARROWI = 32735,
        OBM_LFARROWI = 32734,
        OBM_OLD_CLOSE = 32767,
        OBM_SIZE = 32766,
        OBM_OLD_UPARROW = 32765,
        OBM_OLD_DNARROW = 32764,
        OBM_OLD_RGARROW = 32763,
        OBM_OLD_LFARROW = 32762,
        OBM_BTSIZE = 32761,
        OBM_CHECK = 32760,
        OBM_CHECKBOXES = 32759,
        OBM_BTNCORNERS = 32758,
        OBM_OLD_REDUCE = 32757,
        OBM_OLD_ZOOM = 32756,
        OBM_OLD_RESTORE = 32755,
        OCR_NORMAL = 32512,
        OCR_IBEAM = 32513,
        OCR_WAIT = 32514,
        OCR_CROSS = 32515,
        OCR_UP = 32516,
        OCR_SIZE = 32640,
        OCR_ICON = 32641,
        OCR_SIZENWSE = 32642,
        OCR_SIZENESW = 32643,
        OCR_SIZEWE = 32644,
        OCR_SIZENS = 32645,
        OCR_SIZEALL = 32646,
        OCR_ICOCUR = 32647,
        OCR_NO = 32648,
        OCR_APPSTARTING = 32650,
        OIC_SAMPLE = 32512,
        OIC_HAND = 32513,
        OIC_QUES = 32514,
        OIC_BANG = 32515,
        OIC_NOTE = 32516,
        OIC_WINLOGO = 32517,
        OIC_WARNING = 32515,
        OIC_ERROR = 32513,
        OIC_INFORMATION = 32516,
        ORD_LANGDRIVER = 1,
        ODT_HEADER = 100,
        ODT_TAB = 101,
        ODT_LISTVIEW = 102,
        OLECLOSE_SAVEIFDIRTY = 0,
        OLECLOSE_NOSAVE = 1,
        OLECLOSE_PROMPTSAVE = 2;








        public const int PDERR_PRINTERCODES = 0x1000,
        PDERR_SETUPFAILURE = 0x1001,
        PDERR_PARSEFAILURE = 0x1002,
        PDERR_RETDEFFAILURE = 0x1003,
        PDERR_LOADDRVFAILURE = 0x1004,
        PDERR_GETDEVMODEFAIL = 0x1005,
        PDERR_INITFAILURE = 0x1006,
        PDERR_NODEVICES = 0x1007,
        PDERR_NODEFAULTPRN = 0x1008,
        PDERR_DNDMMISMATCH = 0x1009,
        PDERR_CREATEICFAILURE = 0x100A,
        PDERR_PRINTERNOTFOUND = 0x100B,
        PDERR_DEFAULTDIFFERENT = 0x100C,
        PRINTER_FONTTYPE = 0x4000,
        PD_ALLPAGES = 0x00000000,
        PD_SELECTION = 0x00000001,
        PD_PAGENUMS = 0x00000002,
        PD_CURRENTPAGE = 0x00400000,
        PD_NOSELECTION = 0x00000004,
        PD_NOPAGENUMS = 0x00000008,
        PD_NOCURRENTPAGE = 0x00800000,
        PD_COLLATE = 0x00000010,
        PD_PRINTTOFILE = 0x00000020,
        PD_PRINTSETUP = 0x00000040,
        PD_NOWARNING = 0x00000080,
        PD_RETURNDC = 0x00000100,
        PD_RETURNIC = 0x00000200,
        PD_RETURNDEFAULT = 0x00000400,
        PD_SHOWHELP = 0x00000800,
        PD_ENABLEPRINTHOOK = 0x00001000,
        PD_ENABLESETUPHOOK = 0x00002000,
        PD_ENABLEPRINTTEMPLATE = 0x00004000,
        PD_ENABLESETUPTEMPLATE = 0x00008000,
        PD_ENABLEPRINTTEMPLATEHANDLE = 0x00010000,
        PD_ENABLESETUPTEMPLATEHANDLE = 0x00020000,
        PD_USEDEVMODECOPIES = 0x00040000,
        PD_USEDEVMODECOPIESANDCOLLATE = 0x00040000,
        PD_DISABLEPRINTTOFILE = 0x00080000,
        PD_HIDEPRINTTOFILE = 0x00100000,
        PD_NONETWORKBUTTON = 0x00200000,
        PSD_DEFAULTMINMARGINS = 0x00000000,
        PSD_INWININIINTLMEASURE = 0x00000000,
        PSD_MINMARGINS = 0x00000001,
        PSD_MARGINS = 0x00000002,
        PSD_INTHOUSANDTHSOFINCHES = 0x00000004,
        PSD_INHUNDREDTHSOFMILLIMETERS = 0x00000008,
        PSD_DISABLEMARGINS = 0x00000010,
        PSD_DISABLEPRINTER = 0x00000020,
        PSD_NOWARNING = 0x00000080,
        PSD_DISABLEORIENTATION = 0x00000100,
        PSD_RETURNDEFAULT = 0x00000400,
        PSD_DISABLEPAPER = 0x00000200,
        PSD_SHOWHELP = 0x00000800,
        PSD_ENABLEPAGESETUPHOOK = 0x00002000,
        PSD_ENABLEPAGESETUPTEMPLATE = 0x00008000,
        PSD_ENABLEPAGESETUPTEMPLATEHANDLE = 0x00020000,
        PSD_ENABLEPAGEPAINTHOOK = 0x00040000,
        PSD_DISABLEPAGEPAINTING = 0x00080000,
        PSD_NONETWORKBUTTON = 0x00200000,
        psh1 = 0x0400,
        psh2 = 0x0401,
        psh3 = 0x0402,
        psh4 = 0x0403,
        psh5 = 0x0404,
        psh6 = 0x0405,
        psh7 = 0x0406,
        psh8 = 0x0407,
        psh9 = 0x0408,
        psh10 = 0x0409,
        psh11 = 0x040a,
        psh12 = 0x040b,
        psh13 = 0x040c,
        psh14 = 0x040d,
        psh15 = 0x040e,
        pshHelp = 0x040e,
        psh16 = 0x040f,
        PRINTDLGORD = 1538,
        PRNSETUPDLGORD = 1539,
        PAGESETUPDLGORD = 1546,
        PARAMFLAG_NONE = (0),
                         PARAMFLAG_FIN = (0x1),
                                         PARAMFLAG_FOUT = (0x2),
                                                          PARAMFLAG_FLCID = (0x4),
                                                                            PARAMFLAG_FRETVAL = (unchecked((int)0x8)),
                                                                                                PARAMFLAG_FOPT = (0x10),
                                                                                                                 PARAMFLAG_FHASDEFAULT = (0x20),
                                                                                                                                         PROPSETFLAG_DEFAULT = (0),
                                                                                                                                                               PROPSETFLAG_NONSIMPLE = (1),
                                                                                                                                                                                       PROPSETFLAG_ANSI = (2),
                                                                                                                                                                                                          PID_DICTIONARY = (0),
                                                                                                                                                                                                                           PID_CODEPAGE = (0x1),
                                                                                                                                                                                                                                          PID_FIRST_USABLE = (0x2),
                                                                                                                                                                                                                                                             PID_FIRST_NAME_DEFAULT = (0xfff),
                                                                                                                                                                                                                                                                                      PID_LOCALE = (unchecked((int)0x80000000)),
                                                                                                                                                                                                                                                                                                   PID_MODIFY_TIME = (unchecked((int)0x80000001)),
                                                                                                                                                                                                                                                                                                                     PID_SECURITY = (unchecked((int)0x80000002)),
                                                                                                                                                                                                                                                                                                                                    PID_ILLEGAL = (unchecked((int)0xFfffffff)),
                                                                                                                                                                                                                                                                                                                                                  PIDSI_TITLE = 0x00000002,
        PIDSI_SUBJECT = 0x00000003,
        PIDSI_AUTHOR = 0x00000004,
        PIDSI_KEYWORDS = 0x00000005,
        PIDSI_COMMENTS = 0x00000006,
        PIDSI_TEMPLATE = 0x00000007,
        PIDSI_LASTAUTHOR = 0x00000008,
        PIDSI_REVNUMBER = 0x00000009,
        PIDSI_EDITTIME = 0x0000000a,
        PIDSI_LASTPRINTED = 0x0000000b,
        PIDSI_CREATE_DTM = 0x0000000c,
        PIDSI_LASTSAVE_DTM = 0x0000000d,
        PIDSI_PAGECOUNT = 0x0000000e,
        PIDSI_WORDCOUNT = 0x0000000f,
        PIDSI_CHARCOUNT = 0x00000010,
        PIDSI_THUMBNAIL = 0x00000011,
        PIDSI_APPNAME = 0x00000012,
        PIDSI_DOC_SECURITY = 0x00000013,
        PRSPEC_INVALID = (unchecked((int)0xFfffffff)),
                         PRSPEC_LPWSTR = (0),
                                         PRSPEC_PROPID = (1),
                                                         PROPSETHDR_OSVERSION_UNKNOWN = unchecked((int)0xFFFFFFFF),
        PSP_DEFAULT = 0x0000,
        PSP_DLGINDIRECT = 0x0001,
        PSP_USEHICON = 0x0002,
        PSP_USEICONID = 0x0004,
        PSP_USETITLE = 0x0008,
        PSP_RTLREADING = 0x0010,
        PSP_HASHELP = 0x0020,
        PSP_USEREFPARENT = 0x0040,
        PSP_USECALLBACK = 0x0080,
        PSPCB_RELEASE = 1,
        PSPCB_CREATE = 2,
        PSH_DEFAULT = 0x0000,
        PSH_PROPTITLE = 0x0001,
        PSH_USEHICON = 0x0002,
        PSH_USEICONID = 0x0004,
        PSH_PROPSHEETPAGE = 0x0008,
        PSH_WIZARD = 0x0020,
        PSH_USEPSTARTPAGE = 0x0040,
        PSH_NOAPPLYNOW = 0x0080,
        PSH_USECALLBACK = 0x0100,
        PSH_HASHELP = 0x0200,
        PSH_MODELESS = 0x0400,
        PSH_RTLREADING = 0x0800,
        PSCB_INITIALIZED = 1,
        PSCB_PRECREATE = 2,
        PSN_FIRST = (0-200),
                    PSN_LAST = (0-299),
                               PSN_SETACTIVE = ((0-200)-0),
                                               PSN_KILLACTIVE = ((0-200)-1),
                                                                PSN_APPLY = ((0-200)-2),
                                                                            PSN_RESET = ((0-200)-3),
                                                                                        PSN_HELP = ((0-200)-5),
                                                                                                   PSN_WIZBACK = ((0-200)-6),
                                                                                                                 PSN_WIZNEXT = ((0-200)-7),
                                                                                                                               PSN_WIZFINISH = ((0-200)-8),
                                                                                                                                               PSN_QUERYCANCEL = ((0-200)-9),
                                                                                                                                                                 PSNRET_NOERROR = 0,
        PSNRET_INVALID = 1,
        PSNRET_INVALID_NOCHANGEPAGE = 2,
        PSWIZB_BACK = 0x00000001,
        PSWIZB_NEXT = 0x00000002,
        PSWIZB_FINISH = 0x00000004,
        PSWIZB_DISABLEDFINISH = 0x00000008,
        PSBTN_BACK = 0,
        PSBTN_NEXT = 1,
        PSBTN_FINISH = 2,
        PSBTN_OK = 3,
        PSBTN_APPLYNOW = 4,
        PSBTN_CANCEL = 5,
        PSBTN_HELP = 6,
        PSBTN_MAX = 6,
        PROP_SM_CXDLG = 212,
        PROP_SM_CYDLG = 188,
        PROP_MED_CXDLG = 227,
        PROP_MED_CYDLG = 215,
        PROP_LG_CXDLG = 252,
        PROP_LG_CYDLG = 218,
        PO_DELETE = 0x0013,
        PO_RENAME = 0x0014,
        PO_PORTCHANGE = 0x0020,
        PO_REN_PORT = 0x0034,
        PROGRESS_CONTINUE = 0,
        PROGRESS_CANCEL = 1,
        PROGRESS_STOP = 2,
        PROGRESS_QUIET = 3,
        PIPE_ACCESS_INBOUND = 0x00000001,
        PIPE_ACCESS_OUTBOUND = 0x00000002,
        PIPE_ACCESS_DUPLEX = 0x00000003,
        PIPE_CLIENT_END = 0x00000000,
        PIPE_SERVER_END = 0x00000001,
        PIPE_WAIT = 0x00000000,
        PIPE_NOWAIT = 0x00000001,
        PIPE_READMODE_BYTE = 0x00000000,
        PIPE_READMODE_MESSAGE = 0x00000002,
        PIPE_TYPE_BYTE = 0x00000000,
        PIPE_TYPE_MESSAGE = 0x00000004,
        PIPE_UNLIMITED_INSTANCES = 255,
        PST_UNSPECIFIED = (0x00000000),
                          PST_RS232 = (0x00000001),
                                      PST_PARALLELPORT = (0x00000002),
                                                         PST_RS422 = (0x00000003),
                                                                     PST_RS423 = (0x00000004),
                                                                                 PST_RS449 = (0x00000005),
                                                                                             PST_MODEM = (0x00000006),
                                                                                                         PST_FAX = (0x00000021),
                                                                                                                   PST_SCANNER = (0x00000022),
                                                                                                                                 PST_NETWORK_BRIDGE = (0x00000100),
                                                                                                                                                      PST_LAT = (0x00000101),
                                                                                                                                                                PST_TCPIP_TELNET = (0x00000102),
                                                                                                                                                                                   PST_X25 = (0x00000103),
                                                                                                                                                                                             PCF_DTRDSR = (0x0001),
                                                                                                                                                                                                          PCF_RTSCTS = (0x0002),
                                                                                                                                                                                                                       PCF_RLSD = (0x0004),
                                                                                                                                                                                                                                  PCF_PARITY_CHECK = (0x0008),
                                                                                                                                                                                                                                                     PCF_XONXOFF = (0x0010),
                                                                                                                                                                                                                                                                   PCF_SETXCHAR = (0x0020),
                                                                                                                                                                                                                                                                                  PCF_TOTALTIMEOUTS = (0x0040),
                                                                                                                                                                                                                                                                                                      PCF_INTTIMEOUTS = (0x0080),
                                                                                                                                                                                                                                                                                                                        PCF_SPECIALCHARS = (0x0100),
                                                                                                                                                                                                                                                                                                                                           PCF_16BITMODE = (0x0200),
                                                                                                                                                                                                                                                                                                                                                           PARITY_NONE = (0x0100),
                                                                                                                                                                                                                                                                                                                                                                         PARITY_ODD = (0x0200),
                                                                                                                                                                                                                                                                                                                                                                                      PARITY_EVEN = (0x0400),
                                                                                                                                                                                                                                                                                                                                                                                                    PARITY_MARK = (0x0800),
                                                                                                                                                                                                                                                                                                                                                                                                                  PARITY_SPACE = (0x1000),
                                                                                                                                                                                                                                                                                                                                                                                                                                 PROFILE_USER = 0x10000000,
        PROFILE_KERNEL = 0x20000000,
        PROFILE_SERVER = 0x40000000,
        PURGE_TXABORT = 0x0001,
        PURGE_RXABORT = 0x0002,
        PURGE_TXCLEAR = 0x0004,
        PURGE_RXCLEAR = 0x0008,
        PROCESS_HEAP_REGION = 0x0001,
        PROCESS_HEAP_UNCOMMITTED_RANGE = 0x0002,
        PROCESS_HEAP_ENTRY_BUSY = 0x0004,
        PROCESS_HEAP_ENTRY_MOVEABLE = 0x0010,
        PROCESS_HEAP_ENTRY_DDESHARE = 0x0020,
        PUBLICKEYBLOB = 0x6,
        PRIVATEKEYBLOB = 0x7,
        PKCS5_PADDING = 1,
        PP_ENUMALGS = 1,
        PP_ENUMCONTAINERS = 2,
        PP_IMPTYPE = 3,
        PP_NAME = 4,
        PP_VERSION = 5,
        PP_CONTAINER = 6,
        PP_CLIENT_HWND = 1,
        PROV_RSA_FULL = 1,
        PROV_RSA_SIG = 2,
        PROV_DSS = 3,
        PROV_FORTEZZA = 4,
        PROV_MS_EXCHANGE = 5,
        PROV_SSL = 6,
        PROV_STT_MER = 7,
        PROV_STT_ACQ = 8,
        PROV_STT_BRND = 9,
        PROV_STT_ROOT = 10,
        PROV_STT_ISS = 11,
        PERSIST_E_SIZEDEFINITE = unchecked((int)0x800B0009),
        PERSIST_E_SIZEINDEFINITE = unchecked((int)0x800B000A),
        PERSIST_E_NOTSELFSIZING = unchecked((int)0x800B000B),
        POLYFILL_LAST = 2,
        PASSTHROUGH = 19,
        POSTSCRIPT_DATA = 37,
        POSTSCRIPT_IGNORE = 38,
        POSTSCRIPT_PASSTHROUGH = 4115,
        PR_JOBSTATUS = 0x0000,
        PROOF_QUALITY = 2,
        PANOSE_COUNT = 10,
        PAN_FAMILYTYPE_INDEX = 0,
        PAN_SERIFSTYLE_INDEX = 1,
        PAN_WEIGHT_INDEX = 2,
        PAN_PROPORTION_INDEX = 3,
        PAN_CONTRAST_INDEX = 4,
        PAN_STROKEVARIATION_INDEX = 5,
        PAN_ARMSTYLE_INDEX = 6,
        PAN_LETTERFORM_INDEX = 7,
        PAN_MIDLINE_INDEX = 8,
        PAN_XHEIGHT_INDEX = 9,
        PAN_CULTURE_LATIN = 0,
        PAN_ANY = 0,
        PAN_NO_FIT = 1,
        PAN_FAMILY_TEXT_DISPLAY = 2,
        PAN_FAMILY_SCRIPT = 3,
        PAN_FAMILY_DECORATIVE = 4,
        PAN_FAMILY_PICTORIAL = 5,
        PAN_SERIF_COVE = 2,
        PAN_SERIF_OBTUSE_COVE = 3,
        PAN_SERIF_SQUARE_COVE = 4,
        PAN_SERIF_OBTUSE_SQUARE_COVE = 5,
        PAN_SERIF_SQUARE = 6,
        PAN_SERIF_THIN = 7,
        PAN_SERIF_BONE = 8,
        PAN_SERIF_EXAGGERATED = 9,
        PAN_SERIF_TRIANGLE = 10,
        PAN_SERIF_NORMAL_SANS = 11,
        PAN_SERIF_OBTUSE_SANS = 12,
        PAN_SERIF_PERP_SANS = 13,
        PAN_SERIF_FLARED = 14,
        PAN_SERIF_ROUNDED = 15,
        PAN_WEIGHT_VERY_LIGHT = 2,
        PAN_WEIGHT_LIGHT = 3,
        PAN_WEIGHT_THIN = 4,
        PAN_WEIGHT_BOOK = 5,
        PAN_WEIGHT_MEDIUM = 6,
        PAN_WEIGHT_DEMI = 7,
        PAN_WEIGHT_BOLD = 8,
        PAN_WEIGHT_HEAVY = 9,
        PAN_WEIGHT_BLACK = 10,
        PAN_WEIGHT_NORD = 11,
        PAN_PROP_OLD_STYLE = 2,
        PAN_PROP_MODERN = 3,
        PAN_PROP_EVEN_WIDTH = 4,
        PAN_PROP_EXPANDED = 5,
        PAN_PROP_CONDENSED = 6,
        PAN_PROP_VERY_EXPANDED = 7,
        PAN_PROP_VERY_CONDENSED = 8,
        PAN_PROP_MONOSPACED = 9,
        PAN_CONTRAST_NONE = 2,
        PAN_CONTRAST_VERY_LOW = 3,
        PAN_CONTRAST_LOW = 4,
        PAN_CONTRAST_MEDIUM_LOW = 5,
        PAN_CONTRAST_MEDIUM = 6,
        PAN_CONTRAST_MEDIUM_HIGH = 7,
        PAN_CONTRAST_HIGH = 8,
        PAN_CONTRAST_VERY_HIGH = 9,
        PAN_STROKE_GRADUAL_DIAG = 2,
        PAN_STROKE_GRADUAL_TRAN = 3,
        PAN_STROKE_GRADUAL_VERT = 4,
        PAN_STROKE_GRADUAL_HORZ = 5,
        PAN_STROKE_RAPID_VERT = 6,
        PAN_STROKE_RAPID_HORZ = 7,
        PAN_STROKE_INSTANT_VERT = 8,
        PAN_STRAIGHT_ARMS_HORZ = 2,
        PAN_STRAIGHT_ARMS_WEDGE = 3,
        PAN_STRAIGHT_ARMS_VERT = 4,
        PAN_STRAIGHT_ARMS_SINGLE_SERIF = 5,
        PAN_STRAIGHT_ARMS_DOUBLE_SERIF = 6,
        PAN_BENT_ARMS_HORZ = 7,
        PAN_BENT_ARMS_WEDGE = 8,
        PAN_BENT_ARMS_VERT = 9,
        PAN_BENT_ARMS_SINGLE_SERIF = 10,
        PAN_BENT_ARMS_DOUBLE_SERIF = 11,
        PAN_LETT_NORMAL_CONTACT = 2,
        PAN_LETT_NORMAL_WEIGHTED = 3,
        PAN_LETT_NORMAL_BOXED = 4,
        PAN_LETT_NORMAL_FLATTENED = 5,
        PAN_LETT_NORMAL_ROUNDED = 6,
        PAN_LETT_NORMAL_OFF_CENTER = 7,
        PAN_LETT_NORMAL_SQUARE = 8,
        PAN_LETT_OBLIQUE_CONTACT = 9,
        PAN_LETT_OBLIQUE_WEIGHTED = 10,
        PAN_LETT_OBLIQUE_BOXED = 11,
        PAN_LETT_OBLIQUE_FLATTENED = 12,
        PAN_LETT_OBLIQUE_ROUNDED = 13,
        PAN_LETT_OBLIQUE_OFF_CENTER = 14,
        PAN_LETT_OBLIQUE_SQUARE = 15,
        PAN_MIDLINE_STANDARD_TRIMMED = 2,
        PAN_MIDLINE_STANDARD_POINTED = 3,
        PAN_MIDLINE_STANDARD_SERIFED = 4,
        PAN_MIDLINE_HIGH_TRIMMED = 5,
        PAN_MIDLINE_HIGH_POINTED = 6,
        PAN_MIDLINE_HIGH_SERIFED = 7,
        PAN_MIDLINE_LOW_TRIMMED = 11,
        PAN_MIDLINE_LOW_POINTED = 12,
        PAN_MIDLINE_LOW_SERIFED = 13,
        PAN_XHEIGHT_DUCKING_SMALL = 5,
        PAN_XHEIGHT_DUCKING_STD = 6,
        PAN_XHEIGHT_DUCKING_LARGE = 7,
        PC_RESERVED = 0x01,
        PC_EXPLICIT = 0x02,
        PC_NOCOLLAPSE = 0x04,
        PT_CLOSEFIGURE = 0x01,
        PT_LINETO = 0x02,
        PT_BEZIERTO = 0x04,
        PT_MOVETO = 0x06,
        PS_SOLID = 0,
        PS_DASH = 1,
        PS_DOT = 2,
        PS_DASHDOT = 3,
        PS_DASHDOTDOT = 4,
        PS_NULL = 5,
        PS_INSIDEFRAME = 6,
        PS_USERSTYLE = 7,
        PS_ALTERNATE = 8,
        PS_STYLE_MASK = 0x0000000F,
        PS_ENDCAP_ROUND = 0x00000000,
        PS_ENDCAP_SQUARE = 0x00000100,
        PS_ENDCAP_FLAT = 0x00000200,
        PS_ENDCAP_MASK = 0x00000F00,
        PS_JOIN_ROUND = 0x00000000,
        PS_JOIN_BEVEL = 0x00001000,
        PS_JOIN_MITER = 0x00002000,
        PS_JOIN_MASK = 0x0000F000,
        PS_COSMETIC = 0x00000000,
        PS_GEOMETRIC = 0x00010000,
        PS_TYPE_MASK = 0x000F0000,
        PLANES = 14,
        PDEVICESIZE = 26,
        POLYGONALCAPS = 32,
        PHYSICALWIDTH = 110,
        PHYSICALHEIGHT = 111,
        PHYSICALOFFSETX = 112,
        PHYSICALOFFSETY = 113,
        PC_NONE = 0,
        PC_POLYGON = 1,
        PC_RECTANGLE = 2,
        PC_WINDPOLYGON = 4,
        PC_TRAPEZOID = 4,
        PC_SCANLINE = 8,
        PC_WIDE = 16,
        PC_STYLED = 32,
        PC_WIDESTYLED = 64,
        PC_INTERIORS = 128,
        PC_POLYPOLYGON = 256,
        PC_PATHS = 512,
        PFD_TYPE_RGBA = 0,
        PFD_TYPE_COLORINDEX = 1,
        PFD_MAIN_PLANE = 0,
        PFD_OVERLAY_PLANE = 1,
        PFD_UNDERLAY_PLANE = (-1),
                             PFD_DOUBLEBUFFER = 0x00000001,
        PFD_STEREO = 0x00000002,
        PFD_DRAW_TO_WINDOW = 0x00000004,
        PFD_DRAW_TO_BITMAP = 0x00000008,
        PFD_SUPPORT_GDI = 0x00000010,
        PFD_SUPPORT_OPENGL = 0x00000020,
        PFD_GENERIC_FORMAT = 0x00000040,
        PFD_NEED_PALETTE = 0x00000080,
        PFD_NEED_SYSTEM_PALETTE = 0x00000100,
        PFD_SWAP_EXCHANGE = 0x00000200,
        PFD_SWAP_COPY = 0x00000400,
        PFD_SWAP_LAYER_BUFFERS = 0x00000800,
        PFD_GENERIC_ACCELERATED = 0x00001000,
        PFD_DEPTH_DONTCARE = 0x20000000,
        PFD_DOUBLEBUFFER_DONTCARE = 0x40000000,
        PFD_STEREO_DONTCARE = unchecked((int)0x80000000),
        PP_DISPLAYERRORS = 0x01,
        PROCESS_TERMINATE = (0x0001),
                            PROCESS_CREATE_THREAD = (0x0002),
                                                    PROCESS_VM_OPERATION = (0x0008),
                                                                           PROCESS_VM_READ = (0x0010),
                                                                                             PROCESS_VM_WRITE = (0x0020),
                                                                                                                PROCESS_DUP_HANDLE = (0x0040),
                                                                                                                                     PROCESS_CREATE_PROCESS = (0x0080),
                                                                                                                                                              PROCESS_SET_QUOTA = (0x0100),
                                                                                                                                                                                  PROCESS_SET_INFORMATION = (0x0200),
                                                                                                                                                                                                            PROCESS_QUERY_INFORMATION = (0x0400),
                                                                                                                                                                                                                                        PROCESSOR_INTEL_386 = 386,
        PROCESSOR_INTEL_486 = 486,
        PROCESSOR_INTEL_PENTIUM = 586,
        PROCESSOR_MIPS_R4000 = 4000,
        PROCESSOR_ALPHA_21064 = 21064,
        PROCESSOR_ARCHITECTURE_INTEL = 0,
        PROCESSOR_ARCHITECTURE_MIPS = 1,
        PROCESSOR_ARCHITECTURE_ALPHA = 2,
        PROCESSOR_ARCHITECTURE_PPC = 3,
        PROCESSOR_ARCHITECTURE_UNKNOWN = 0xFFFF,
        PF_FLOATING_POINT_PRECISION_ERRATA = 0,
        PF_FLOATING_POINT_EMULATED = 1,
        PF_COMPARE_EXCHANGE_DOUBLE = 2,
        PF_MMX_INSTRUCTIONS_AVAILABLE = 3,
        PAGE_NOACCESS = 0x01,
        PAGE_READONLY = 0x02,
        PAGE_READWRITE = 0x04,
        PAGE_WRITECOPY = 0x08,
        PAGE_EXECUTE = 0x10,
        PAGE_EXECUTE_READ = 0x20,
        PAGE_EXECUTE_READWRITE = 0x40,
        PAGE_EXECUTE_WRITECOPY = unchecked((int)0x80),
        PAGE_GUARD = 0x100,
        PAGE_NOCACHE = 0x200,
        PRIVILEGE_SET_ALL_NECESSARY = (1),
                                      PERF_DATA_VERSION = 1,
        PERF_DATA_REVISION = 1,
        PERF_NO_INSTANCES = -1,
        PERF_SIZE_DWORD = 0x00000000,
        PERF_SIZE_LARGE = 0x00000100,
        PERF_SIZE_ZERO = 0x00000200,
        PERF_SIZE_VARIABLE_LEN = 0x00000300,
        PERF_TYPE_NUMBER = 0x00000000,
        PERF_TYPE_COUNTER = 0x00000400,
        PERF_TYPE_TEXT = 0x00000800,
        PERF_TYPE_ZERO = 0x00000C00,
        PERF_NUMBER_HEX = 0x00000000,
        PERF_NUMBER_DECIMAL = 0x00010000,
        PERF_NUMBER_DEC_1000 = 0x00020000,
        PERF_COUNTER_VALUE = 0x00000000,
        PERF_COUNTER_RATE = 0x00010000,
        PERF_COUNTER_FRACTION = 0x00020000,
        PERF_COUNTER_BASE = 0x00030000,
        PERF_COUNTER_ELAPSED = 0x00040000,
        PERF_COUNTER_QUEUELEN = 0x00050000,
        PERF_COUNTER_HISTOGRAM = 0x00060000,
        PERF_TEXT_UNICODE = 0x00000000,
        PERF_TEXT_ASCII = 0x00010000,
        PERF_TIMER_TICK = 0x00000000,
        PERF_TIMER_100NS = 0x00100000,
        PERF_OBJECT_TIMER = 0x00200000,
        PERF_DELTA_COUNTER = 0x00400000,
        PERF_DELTA_BASE = 0x00800000,
        PERF_INVERSE_COUNTER = 0x01000000,
        PERF_MULTI_COUNTER = 0x02000000,
        PERF_DISPLAY_NO_SUFFIX = 0x00000000,
        PERF_DISPLAY_PER_SEC = 0x10000000,
        PERF_DISPLAY_PERCENT = 0x20000000,
        PERF_DISPLAY_SECONDS = 0x30000000,
        PERF_DISPLAY_NOSHOW = 0x40000000,
        PERF_COUNTER_HISTOGRAM_TYPE = unchecked((int)0x80000000),
        PERF_DETAIL_NOVICE = 100,
        PERF_DETAIL_ADVANCED = 200,
        PERF_DETAIL_EXPERT = 300,
        PERF_DETAIL_WIZARD = 400,
        PERF_NO_UNIQUE_ID = -1,
        PROVIDER_KEEPS_VALUE_LENGTH = 0x1,
        PRINTER_CONTROL_PAUSE = 1,
        PRINTER_CONTROL_RESUME = 2,
        PRINTER_CONTROL_PURGE = 3,
        PRINTER_CONTROL_SET_STATUS = 4,
        PRINTER_STATUS_PAUSED = 0x00000001,
        PRINTER_STATUS_ERROR = 0x00000002,
        PRINTER_STATUS_PENDING_DELETION = 0x00000004,
        PRINTER_STATUS_PAPER_JAM = 0x00000008,
        PRINTER_STATUS_PAPER_OUT = 0x00000010,
        PRINTER_STATUS_MANUAL_FEED = 0x00000020,
        PRINTER_STATUS_PAPER_PROBLEM = 0x00000040,
        PRINTER_STATUS_OFFLINE = 0x00000080,
        PRINTER_STATUS_IO_ACTIVE = 0x00000100,
        PRINTER_STATUS_BUSY = 0x00000200,
        PRINTER_STATUS_PRINTING = 0x00000400,
        PRINTER_STATUS_OUTPUT_BIN_FULL = 0x00000800,
        PRINTER_STATUS_NOT_AVAILABLE = 0x00001000,
        PRINTER_STATUS_WAITING = 0x00002000,
        PRINTER_STATUS_PROCESSING = 0x00004000,
        PRINTER_STATUS_INITIALIZING = 0x00008000,
        PRINTER_STATUS_WARMING_UP = 0x00010000,
        PRINTER_STATUS_TONER_LOW = 0x00020000,
        PRINTER_STATUS_NO_TONER = 0x00040000,
        PRINTER_STATUS_PAGE_PUNT = 0x00080000,
        PRINTER_STATUS_USER_INTERVENTION = 0x00100000,
        PRINTER_STATUS_OUT_OF_MEMORY = 0x00200000,
        PRINTER_STATUS_DOOR_OPEN = 0x00400000,
        PRINTER_STATUS_SERVER_UNKNOWN = 0x00800000,
        PRINTER_STATUS_POWER_SAVE = 0x01000000,
        PRINTER_ATTRIBUTE_QUEUED = 0x00000001,
        PRINTER_ATTRIBUTE_DIRECT = 0x00000002,
        PRINTER_ATTRIBUTE_DEFAULT = 0x00000004,
        PRINTER_ATTRIBUTE_SHARED = 0x00000008,
        PRINTER_ATTRIBUTE_NETWORK = 0x00000010,
        PRINTER_ATTRIBUTE_HIDDEN = 0x00000020,
        PRINTER_ATTRIBUTE_LOCAL = 0x00000040,
        PRINTER_ATTRIBUTE_ENABLE_DEVQ = 0x00000080,
        PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS = 0x00000100,
        PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST = 0x00000200,
        PRINTER_ATTRIBUTE_WORK_OFFLINE = 0x00000400,
        PRINTER_ATTRIBUTE_ENABLE_BIDI = 0x00000800,
        PRINTER_ATTRIBUTE_RAW_ONLY = 0x00001000,
        PORT_TYPE_WRITE = 0x0001,
        PORT_TYPE_READ = 0x0002,
        PORT_TYPE_REDIRECTED = 0x0004,
        PORT_TYPE_NET_ATTACHED = 0x0008,
        PORT_STATUS_TYPE_ERROR = 1,
        PORT_STATUS_TYPE_WARNING = 2,
        PORT_STATUS_TYPE_INFO = 3,
        PORT_STATUS_OFFLINE = 1,
        PORT_STATUS_PAPER_JAM = 2,
        PORT_STATUS_PAPER_OUT = 3,
        PORT_STATUS_OUTPUT_BIN_FULL = 4,
        PORT_STATUS_PAPER_PROBLEM = 5,
        PORT_STATUS_NO_TONER = 6,
        PORT_STATUS_DOOR_OPEN = 7,
        PORT_STATUS_USER_INTERVENTION = 8,
        PORT_STATUS_OUT_OF_MEMORY = 9,
        PORT_STATUS_TONER_LOW = 10,
        PORT_STATUS_WARMING_UP = 11,
        PORT_STATUS_POWER_SAVE = 12,
        PRINTER_ENUM_DEFAULT = 0x00000001,
        PRINTER_ENUM_LOCAL = 0x00000002,
        PRINTER_ENUM_CONNECTIONS = 0x00000004,
        PRINTER_ENUM_FAVORITE = 0x00000004,
        PRINTER_ENUM_NAME = 0x00000008,
        PRINTER_ENUM_REMOTE = 0x00000010,
        PRINTER_ENUM_SHARED = 0x00000020,
        PRINTER_ENUM_NETWORK = 0x00000040,
        PRINTER_ENUM_EXPAND = 0x00004000,
        PRINTER_ENUM_CONTAINER = 0x00008000,
        PRINTER_ENUM_ICONMASK = 0x00ff0000,
        PRINTER_ENUM_ICON1 = 0x00010000,
        PRINTER_ENUM_ICON2 = 0x00020000,
        PRINTER_ENUM_ICON3 = 0x00040000,
        PRINTER_ENUM_ICON4 = 0x00080000,
        PRINTER_ENUM_ICON5 = 0x00100000,
        PRINTER_ENUM_ICON6 = 0x00200000,
        PRINTER_ENUM_ICON7 = 0x00400000,
        PRINTER_ENUM_ICON8 = 0x00800000,
        PRINTER_NOTIFY_TYPE = 0x00,
        PRINTER_NOTIFY_FIELD_SERVER_NAME = 0x00,
        PRINTER_NOTIFY_FIELD_PRINTER_NAME = 0x01,
        PRINTER_NOTIFY_FIELD_SHARE_NAME = 0x02,
        PRINTER_NOTIFY_FIELD_PORT_NAME = 0x03,
        PRINTER_NOTIFY_FIELD_DRIVER_NAME = 0x04,
        PRINTER_NOTIFY_FIELD_COMMENT = 0x05,
        PRINTER_NOTIFY_FIELD_LOCATION = 0x06,
        PRINTER_NOTIFY_FIELD_DEVMODE = 0x07,
        PRINTER_NOTIFY_FIELD_SEPFILE = 0x08,
        PRINTER_NOTIFY_FIELD_PRINT_PROCESSOR = 0x09,
        PRINTER_NOTIFY_FIELD_PARAMETERS = 0x0A,
        PRINTER_NOTIFY_FIELD_DATATYPE = 0x0B,
        PRINTER_NOTIFY_FIELD_SECURITY_DESCRIPTOR = 0x0C,
        PRINTER_NOTIFY_FIELD_ATTRIBUTES = 0x0D,
        PRINTER_NOTIFY_FIELD_PRIORITY = 0x0E,
        PRINTER_NOTIFY_FIELD_DEFAULT_PRIORITY = 0x0F,
        PRINTER_NOTIFY_FIELD_START_TIME = 0x10,
        PRINTER_NOTIFY_FIELD_UNTIL_TIME = 0x11,
        PRINTER_NOTIFY_FIELD_STATUS = 0x12,
        PRINTER_NOTIFY_FIELD_STATUS_STRING = 0x13,
        PRINTER_NOTIFY_FIELD_CJOBS = 0x14,
        PRINTER_NOTIFY_FIELD_AVERAGE_PPM = 0x15,
        PRINTER_NOTIFY_FIELD_TOTAL_PAGES = 0x16,
        PRINTER_NOTIFY_FIELD_PAGES_PRINTED = 0x17,
        PRINTER_NOTIFY_FIELD_TOTAL_BYTES = 0x18,
        PRINTER_NOTIFY_FIELD_BYTES_PRINTED = 0x19,
        PRINTER_NOTIFY_OPTIONS_REFRESH = 0x01,
        PRINTER_NOTIFY_INFO_DISCARDED = 0x01,
        PRINTER_CHANGE_ADD_PRINTER = 0x00000001,
        PRINTER_CHANGE_SET_PRINTER = 0x00000002,
        PRINTER_CHANGE_DELETE_PRINTER = 0x00000004,
        PRINTER_CHANGE_FAILED_CONNECTION_PRINTER = 0x00000008,
        PRINTER_CHANGE_PRINTER = 0x000000FF,
        PRINTER_CHANGE_ADD_JOB = 0x00000100,
        PRINTER_CHANGE_SET_JOB = 0x00000200,
        PRINTER_CHANGE_DELETE_JOB = 0x00000400,
        PRINTER_CHANGE_WRITE_JOB = 0x00000800,
        PRINTER_CHANGE_JOB = 0x0000FF00,
        PRINTER_CHANGE_ADD_FORM = 0x00010000,
        PRINTER_CHANGE_SET_FORM = 0x00020000,
        PRINTER_CHANGE_DELETE_FORM = 0x00040000,
        PRINTER_CHANGE_FORM = 0x00070000,
        PRINTER_CHANGE_ADD_PORT = 0x00100000,
        PRINTER_CHANGE_CONFIGURE_PORT = 0x00200000,
        PRINTER_CHANGE_DELETE_PORT = 0x00400000,
        PRINTER_CHANGE_PORT = 0x00700000,
        PRINTER_CHANGE_ADD_PRINT_PROCESSOR = 0x01000000,
        PRINTER_CHANGE_DELETE_PRINT_PROCESSOR = 0x04000000,
        PRINTER_CHANGE_PRINT_PROCESSOR = 0x07000000,
        PRINTER_CHANGE_ADD_PRINTER_DRIVER = 0x10000000,
        PRINTER_CHANGE_SET_PRINTER_DRIVER = 0x20000000,
        PRINTER_CHANGE_DELETE_PRINTER_DRIVER = 0x40000000,
        PRINTER_CHANGE_PRINTER_DRIVER = 0x70000000,
        PRINTER_CHANGE_TIMEOUT = unchecked((int)0x80000000),
        PRINTER_CHANGE_ALL = 0x7777FFFF,
        PRINTER_ERROR_INFORMATION = unchecked((int)0x80000000),
        PRINTER_ERROR_WARNING = 0x40000000,
        PRINTER_ERROR_SEVERE = 0x20000000,
        PRINTER_ERROR_OUTOFPAPER = 0x00000001,
        PRINTER_ERROR_JAM = 0x00000002,
        PRINTER_ERROR_OUTOFTONER = 0x00000004,
        PRINTER_ACCESS_ADMINISTER = 0x00000004,
        PRINTER_ACCESS_USE = 0x00000008,
        PWR_OK = 1,
        PWR_FAIL = (-1),
                   PWR_SUSPENDREQUEST = 1,
        PWR_SUSPENDRESUME = 2,
        PWR_CRITICALRESUME = 3,
        PRF_CHECKVISIBLE = 0x00000001,
        PRF_NONCLIENT = 0x00000002,
        PRF_CLIENT = 0x00000004,
        PRF_ERASEBKGND = 0x00000008,
        PRF_CHILDREN = 0x00000010,
        PRF_OWNED = 0x00000020,
        PM_NOREMOVE = 0x0000,
        PM_REMOVE = 0x0001,
        PM_NOYIELD = 0x0002,
        PSM_PAGEINFO = (0x0400+100),
                       PSM_SHEETINFO = (0x0400+101),
                                       PSI_SETACTIVE = 0x0001,
        PSI_KILLACTIVE = 0x0002,
        PSI_APPLY = 0x0003,
        PSI_RESET = 0x0004,
        PSI_HASHELP = 0x0005,
        PSI_HELP = 0x0006,
        PSI_CHANGED = 0x0001,
        PSI_GUISTART = 0x0002,
        PSI_REBOOT = 0x0003,
        PSI_GETSIBLINGS = 0x0004,
        PBS_SMOOTH = 0x01,
        PBS_VERTICAL = 0x04,
        PBM_SETRANGE = (0x0400+1),
                       PBM_SETPOS = (0x0400+2),
                                    PBM_DELTAPOS = (0x0400+3),
                                                   PBM_SETSTEP = (0x0400+4),
                                                                 PBM_STEPIT = (0x0400+5),
                                                                              PBM_SETRANGE32 = (0x0400+6),
                                                                                               PBM_GETRANGE = (0x0400+7),
                                                                                                              PBM_GETPOS = (0x0400+8),
                                                                                                                           PSM_SETCURSEL = (0x0400+101),
                                                                                                                                           PSM_REMOVEPAGE = (0x0400+102),
                                                                                                                                                            PSM_ADDPAGE = (0x0400+103),
                                                                                                                                                                          PSM_CHANGED = (0x0400+104),
                                                                                                                                                                                        PSM_RESTARTWINDOWS = (0x0400+105),
                                                                                                                                                                                                             PSM_REBOOTSYSTEM = (0x0400+106),
                                                                                                                                                                                                                                PSM_CANCELTOCLOSE = (0x0400+107),
                                                                                                                                                                                                                                                    PSM_QUERYSIBLINGS = (0x0400+108),
                                                                                                                                                                                                                                                                        PSM_UNCHANGED = (0x0400+109),
                                                                                                                                                                                                                                                                                        PSM_APPLY = (0x0400+110),
                                                                                                                                                                                                                                                                                                    PSM_SETTITLEA = (0x0400+111),
                                                                                                                                                                                                                                                                                                                    PSM_SETTITLEW = (0x0400+120),
                                                                                                                                                                                                                                                                                                                                    PSM_SETWIZBUTTONS = (0x0400+112),
                                                                                                                                                                                                                                                                                                                                                        PSM_PRESSBUTTON = (0x0400+113),
                                                                                                                                                                                                                                                                                                                                                                          PSM_SETCURSELID = (0x0400+114),
                                                                                                                                                                                                                                                                                                                                                                                            PSM_SETFINISHTEXTA = (0x0400+115),
                                                                                                                                                                                                                                                                                                                                                                                                                 PSM_SETFINISHTEXTW = (0x0400+121),
                                                                                                                                                                                                                                                                                                                                                                                                                                      PSM_GETTABCONTROL = (0x0400+116),
                                                                                                                                                                                                                                                                                                                                                                                                                                                          PSM_ISDIALOGMESSAGE = (0x0400+117),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                PSM_GETCURRENTPAGEHWND = (0x0400+118),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         PATCOPY = 0x00F00021,
        PATPAINT = 0x00FB0A09,
        PATINVERT = 0x005A0049,
        PGN_FIRST = (0-900),
                    PGN_LAST = (0-950);



        public const int QID_SYNC = unchecked((int)0xFFFFFFFF),
        QUERYROPSUPPORT = 40,
        QUERYESCSUPPORT = 8,
        QUERYDIBSUPPORT = 3073,
        QDI_SETDIBITS = 1,
        QDI_GETDIBITS = 2,
        QDI_DIBTOSCREEN = 4,
        QDI_STRETCHDIB = 8,
        QS_KEY = 0x0001,
        QS_MOUSEMOVE = 0x0002,
        QS_MOUSEBUTTON = 0x0004,
        QS_POSTMESSAGE = 0x0008,
        QS_TIMER = 0x0010,
        QS_PAINT = 0x0020,
        QS_SENDMESSAGE = 0x0040,
        QS_HOTKEY = 0x0080,
        QS_ALLPOSTMESSAGE = 0x0100,
        QS_MOUSE = QS_MOUSEMOVE | QS_MOUSEBUTTON,
        QS_INPUT = QS_MOUSE | QS_KEY,
        QS_ALLEVENTS = QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_HOTKEY,
        QS_ALLINPUT = QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_HOTKEY | QS_SENDMESSAGE;
        
        public const int REGULAR_FONTTYPE = 0x0400,
        rad1 = 0x0420,
        rad2 = 0x0421,
        rad3 = 0x0422,
        rad4 = 0x0423,
        rad5 = 0x0424,
        rad6 = 0x0425,
        rad7 = 0x0426,
        rad8 = 0x0427,
        rad9 = 0x0428,
        rad10 = 0x0429,
        rad11 = 0x042a,
        rad12 = 0x042b,
        rad13 = 0x042c,
        rad14 = 0x042d,
        rad15 = 0x042e,
        rad16 = 0x042f,
        rct1 = 0x0438,
        rct2 = 0x0439,
        rct3 = 0x043a,
        rct4 = 0x043b,
        REPLACEDLGORD = 1541,
        REGISTERING = 0x00,
        REGISTERED = 0x04,
        RPC_C_BINDING_INFINITE_TIMEOUT = 10,
        RPC_C_BINDING_MIN_TIMEOUT = 0,
        RPC_C_BINDING_DEFAULT_TIMEOUT = 5,
        RPC_C_BINDING_MAX_TIMEOUT = 9,
        RPC_C_CANCEL_INFINITE_TIMEOUT = -1,
        RPC_C_LISTEN_MAX_CALLS_DEFAULT = 1234,
        RPC_C_PROTSEQ_MAX_REQS_DEFAULT = 10,
        RPC_C_BIND_TO_ALL_NICS = 1,
        RPC_C_USE_INTERNET_PORT = 1,
        RPC_C_USE_INTRANET_PORT = 2,
        RPC_C_STATS_CALLS_IN = 0,
        RPC_C_STATS_CALLS_OUT = 1,
        RPC_C_STATS_PKTS_IN = 2,
        RPC_C_STATS_PKTS_OUT = 3,
        RPC_C_AUTHN_LEVEL_DEFAULT = 0,
        RPC_C_AUTHN_LEVEL_NONE = 1,
        RPC_C_AUTHN_LEVEL_CONNECT = 2,
        RPC_C_AUTHN_LEVEL_CALL = 3,
        RPC_C_AUTHN_LEVEL_PKT = 4,
        RPC_C_AUTHN_LEVEL_PKT_INTEGRITY = 5,
        RPC_C_AUTHN_LEVEL_PKT_PRIVACY = 6,
        RPC_C_IMP_LEVEL_ANONYMOUS = 1,
        RPC_C_IMP_LEVEL_IDENTIFY = 2,
        RPC_C_IMP_LEVEL_IMPERSONATE = 3,
        RPC_C_IMP_LEVEL_DELEGATE = 4,
        RPC_C_QOS_IDENTITY_STATIC = 0,
        RPC_C_QOS_IDENTITY_DYNAMIC = 1,
        RPC_C_QOS_CAPABILITIES_DEFAULT = 0,
        RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH = 1,
        RPC_C_PROTECT_LEVEL_DEFAULT = (0),
                                      RPC_C_PROTECT_LEVEL_NONE = (1),
                                                                 RPC_C_PROTECT_LEVEL_CONNECT = (2),
                                                                                               RPC_C_PROTECT_LEVEL_CALL = (3),
                                                                                                                          RPC_C_PROTECT_LEVEL_PKT = (4),
                                                                                                                                                    RPC_C_PROTECT_LEVEL_PKT_INTEGRITY = (5),
                                                                                                                                                                                        RPC_C_PROTECT_LEVEL_PKT_PRIVACY = (6),
                                                                                                                                                                                                                          RPC_C_AUTHN_NONE = 0,
        RPC_C_AUTHN_DCE_PRIVATE = 1,
        RPC_C_AUTHN_DCE_PUBLIC = 2,
        RPC_C_AUTHN_DEC_PUBLIC = 4,
        RPC_C_AUTHN_WINNT = 10,
        RPC_C_AUTHN_DEFAULT = unchecked((int)0xFFFFFFFF),
        RPC_C_SECURITY_QOS_VERSION = 1,
        RPC_C_AUTHZ_NONE = 0,
        RPC_C_AUTHZ_NAME = 1,
        RPC_C_AUTHZ_DCE = 2,
        RPC_C_EP_ALL_ELTS = 0,
        RPC_C_EP_MATCH_BY_IF = 1,
        RPC_C_EP_MATCH_BY_OBJ = 2,
        RPC_C_EP_MATCH_BY_BOTH = 3,
        RPC_C_VERS_ALL = 1,
        RPC_C_VERS_COMPATIBLE = 2,
        RPC_C_VERS_EXACT = 3,
        RPC_C_VERS_MAJOR_ONLY = 4,
        RPC_C_VERS_UPTO = 5,
        RPC_C_MGMT_INQ_IF_IDS = 0,
        RPC_C_MGMT_INQ_PRINC_NAME = 1,
        RPC_C_MGMT_INQ_STATS = 2,
        RPC_C_MGMT_IS_SERVER_LISTEN = 3,
        RPC_C_MGMT_STOP_SERVER_LISTEN = 4,
        RPC_C_PARM_MAX_PACKET_LENGTH = 1,
        RPC_C_PARM_BUFFER_LENGTH = 2,
        RPC_IF_AUTOLISTEN = 0x0001,
        RPC_IF_OLE = 0x0002,
        RPC_NCA_FLAGS_DEFAULT = 0x00000000,
        RPC_NCA_FLAGS_IDEMPOTENT = 0x00000001,
        RPC_NCA_FLAGS_BROADCAST = 0x00000002,
        RPC_NCA_FLAGS_MAYBE = 0x00000004,
        RPC_BUFFER_COMPLETE = 0x00001000,
        RPC_BUFFER_PARTIAL = 0x00002000,
        RPC_BUFFER_EXTRA = 0x00004000,
        RPCFLG_NON_NDR = unchecked((int)0x80000000),
        RPCFLG_ASYNCHRONOUS = 0x40000000,
        RPCFLG_INPUT_SYNCHRONOUS = 0x20000000,
        RPCFLG_LOCAL_CALL = 0x10000000,
        RPC_FLAGS_VALID_BIT = unchecked((int)0x8000);
        // RPC_FLAGS_VALID_BIT = 0x00008000;
        public const int RPC_INTERFACE_HAS_PIPES = 0x0001,
        RPC_C_NS_SYNTAX_DEFAULT = 0,
        RPC_C_NS_SYNTAX_DCE = 3,
        RPC_C_PROFILE_DEFAULT_ELT = 0,
        RPC_C_PROFILE_ALL_ELT = 1,
        RPC_C_PROFILE_MATCH_BY_IF = 2,
        RPC_C_PROFILE_MATCH_BY_MBR = 3,
        RPC_C_PROFILE_MATCH_BY_BOTH = 4,
        RPC_C_NS_DEFAULT_EXP_AGE = -1,
        RTS_CONTROL_DISABLE = 0x00,
        RTS_CONTROL_ENABLE = 0x01,
        RTS_CONTROL_HANDSHAKE = 0x02,
        RTS_CONTROL_TOGGLE = 0x03,
        REALTIME_PRIORITY_CLASS = 0x00000100,
        RIP_EVENT = 9,
        RESETDEV = 7,
        RIGHT_ALT_PRESSED = 0x0001,
        RIGHT_CTRL_PRESSED = 0x0004,
        RIGHTMOST_BUTTON_PRESSED = 0x0002,
        RPC_S_INVALID_STRING_BINDING = 1700,
        RPC_S_WRONG_KIND_OF_BINDING = 1701,
        RPC_S_INVALID_BINDING = 1702,
        RPC_S_PROTSEQ_NOT_SUPPORTED = 1703,
        RPC_S_INVALID_RPC_PROTSEQ = 1704,
        RPC_S_INVALID_STRING_UUID = 1705,
        RPC_S_INVALID_ENDPOINT_FORMAT = 1706,
        RPC_S_INVALID_NET_ADDR = 1707,
        RPC_S_NO_ENDPOINT_FOUND = 1708,
        RPC_S_INVALID_TIMEOUT = 1709,
        RPC_S_OBJECT_NOT_FOUND = 1710,
        RPC_S_ALREADY_REGISTERED = 1711,
        RPC_S_TYPE_ALREADY_REGISTERED = 1712,
        RPC_S_ALREADY_LISTENING = 1713,
        RPC_S_NO_PROTSEQS_REGISTERED = 1714,
        RPC_S_NOT_LISTENING = 1715,
        RPC_S_UNKNOWN_MGR_TYPE = 1716,
        RPC_S_UNKNOWN_IF = 1717,
        RPC_S_NO_BINDINGS = 1718,
        RPC_S_NO_PROTSEQS = 1719,
        RPC_S_CANT_CREATE_ENDPOINT = 1720,
        RPC_S_OUT_OF_RESOURCES = 1721,
        RPC_S_SERVER_UNAVAILABLE = 1722,
        RPC_S_SERVER_TOO_BUSY = 1723,
        RPC_S_INVALID_NETWORK_OPTIONS = 1724,
        RPC_S_NO_CALL_ACTIVE = 1725,
        RPC_S_CALL_FAILED = 1726,
        RPC_S_CALL_FAILED_DNE = 1727,
        RPC_S_PROTOCOL_ERROR = 1728,
        RPC_S_UNSUPPORTED_TRANS_SYN = 1730,
        RPC_S_UNSUPPORTED_TYPE = 1732,
        RPC_S_INVALID_TAG = 1733,
        RPC_S_INVALID_BOUND = 1734,
        RPC_S_NO_ENTRY_NAME = 1735,
        RPC_S_INVALID_NAME_SYNTAX = 1736,
        RPC_S_UNSUPPORTED_NAME_SYNTAX = 1737,
        RPC_S_UUID_NO_ADDRESS = 1739,
        RPC_S_DUPLICATE_ENDPOINT = 1740,
        RPC_S_UNKNOWN_AUTHN_TYPE = 1741,
        RPC_S_MAX_CALLS_TOO_SMALL = 1742,
        RPC_S_STRING_TOO_LONG = 1743,
        RPC_S_PROTSEQ_NOT_FOUND = 1744,
        RPC_S_PROCNUM_OUT_OF_RANGE = 1745,
        RPC_S_BINDING_HAS_NO_AUTH = 1746,
        RPC_S_UNKNOWN_AUTHN_SERVICE = 1747,
        RPC_S_UNKNOWN_AUTHN_LEVEL = 1748,
        RPC_S_INVALID_AUTH_IDENTITY = 1749,
        RPC_S_UNKNOWN_AUTHZ_SERVICE = 1750,
        RPC_S_NOTHING_TO_EXPORT = 1754,
        RPC_S_INCOMPLETE_NAME = 1755,
        RPC_S_INVALID_VERS_OPTION = 1756,
        RPC_S_NO_MORE_MEMBERS = 1757,
        RPC_S_NOT_ALL_OBJS_UNEXPORTED = 1758,
        RPC_S_INTERFACE_NOT_FOUND = 1759,
        RPC_S_ENTRY_ALREADY_EXISTS = 1760,
        RPC_S_ENTRY_NOT_FOUND = 1761,
        RPC_S_NAME_SERVICE_UNAVAILABLE = 1762,
        RPC_S_INVALID_NAF_ID = 1763,
        RPC_S_CANNOT_SUPPORT = 1764,
        RPC_S_NO_CONTEXT_AVAILABLE = 1765,
        RPC_S_INTERNAL_ERROR = 1766,
        RPC_S_ZERO_DIVIDE = 1767,
        RPC_S_ADDRESS_ERROR = 1768,
        RPC_S_FP_DIV_ZERO = 1769,
        RPC_S_FP_UNDERFLOW = 1770,
        RPC_S_FP_OVERFLOW = 1771,
        RPC_X_NO_MORE_ENTRIES = 1772,
        RPC_X_SS_CHAR_TRANS_OPEN_FAIL = 1773,
        RPC_X_SS_CHAR_TRANS_SHORT_FILE = 1774,
        RPC_X_SS_IN_NULL_CONTEXT = 1775,
        RPC_X_SS_CONTEXT_DAMAGED = 1777,
        RPC_X_SS_HANDLES_MISMATCH = 1778,
        RPC_X_SS_CANNOT_GET_CALL_HANDLE = 1779,
        RPC_X_NULL_REF_POINTER = 1780,
        RPC_X_ENUM_VALUE_OUT_OF_RANGE = 1781,
        RPC_X_BYTE_COUNT_TOO_SMALL = 1782,
        RPC_X_BAD_STUB_DATA = 1783,
        RPC_S_CALL_IN_PROGRESS = 1791,
        RPC_S_NO_MORE_BINDINGS = 1806,
        RPC_S_NO_INTERFACES = 1817,
        RPC_S_CALL_CANCELLED = 1818,
        RPC_S_BINDING_INCOMPLETE = 1819,
        RPC_S_COMM_FAILURE = 1820,
        RPC_S_UNSUPPORTED_AUTHN_LEVEL = 1821,
        RPC_S_NO_PRINC_NAME = 1822,
        RPC_S_NOT_RPC_ERROR = 1823,
        RPC_S_UUID_LOCAL_ONLY = 1824,
        RPC_S_SEC_PKG_ERROR = 1825,
        RPC_S_NOT_CANCELLED = 1826,
        RPC_X_INVALID_ES_ACTION = 1827,
        RPC_X_WRONG_ES_VERSION = 1828,
        RPC_X_WRONG_STUB_VERSION = 1829,
        RPC_X_INVALID_PIPE_OBJECT = 1830,
        RPC_X_INVALID_PIPE_OPERATION = 1831,
        RPC_X_WRONG_PIPE_VERSION = 1832,
        RPC_S_GROUP_MEMBER_NOT_FOUND = 1898,
        RPC_S_INVALID_OBJECT = 1900,
        RPC_S_SEND_INCOMPLETE = 1913,
        REGDB_E_FIRST = unchecked((int)0x80040150),
        REGDB_E_LAST = unchecked((int)0x8004015F),
        REGDB_S_FIRST = 0x00040150,
        REGDB_S_LAST = 0x0004015F,
        REGDB_E_READREGDB = unchecked((int)0x80040150),
        REGDB_E_WRITEREGDB = unchecked((int)0x80040151),
        REGDB_E_KEYMISSING = unchecked((int)0x80040152),
        REGDB_E_INVALIDVALUE = unchecked((int)0x80040153),
        REGDB_E_CLASSNOTREG = unchecked((int)0x80040154),
        REGDB_E_IIDNOTREG = unchecked((int)0x80040155),
        RPC_E_CALL_REJECTED = unchecked((int)0x80010001),
        RPC_E_CALL_CANCELED = unchecked((int)0x80010002),
        RPC_E_CANTPOST_INSENDCALL = unchecked((int)0x80010003),
        RPC_E_CANTCALLOUT_INASYNCCALL = unchecked((int)0x80010004),
        RPC_E_CONNECTION_TERMINATED = unchecked((int)0x80010006),
        RPC_E_SERVER_DIED = unchecked((int)0x80010007),
        RPC_E_CLIENT_DIED = unchecked((int)0x80010008),
        RPC_E_INVALID_DATAPACKET = unchecked((int)0x80010009),
        RPC_E_CANTTRANSMIT_CALL = unchecked((int)0x8001000A),
        RPC_E_CLIENT_CANTMARSHAL_DATA = unchecked((int)0x8001000B),
        RPC_E_CLIENT_CANTUNMARSHAL_DATA = unchecked((int)0x8001000C),
        RPC_E_SERVER_CANTMARSHAL_DATA = unchecked((int)0x8001000D),
        RPC_E_SERVER_CANTUNMARSHAL_DATA = unchecked((int)0x8001000E),
        RPC_E_INVALID_DATA = unchecked((int)0x8001000F),
        RPC_E_INVALID_PARAMETER = unchecked((int)0x80010010),
        RPC_E_CANTCALLOUT_AGAIN = unchecked((int)0x80010011),
        RPC_E_SERVER_DIED_DNE = unchecked((int)0x80010012),
        RPC_E_SYS_CALL_FAILED = unchecked((int)0x80010100),
        RPC_E_OUT_OF_RESOURCES = unchecked((int)0x80010101),
        RPC_E_ATTEMPTED_MULTITHREAD = unchecked((int)0x80010102),
        RPC_E_NOT_REGISTERED = unchecked((int)0x80010103),
        RPC_E_FAULT = unchecked((int)0x80010104),
        RPC_E_SERVERFAULT = unchecked((int)0x80010105),
        RPC_E_CHANGED_MODE = unchecked((int)0x80010106),
        RPC_E_INVALIDMETHOD = unchecked((int)0x80010107),
        RPC_E_DISCONNECTED = unchecked((int)0x80010108),
        RPC_E_RETRY = unchecked((int)0x80010109),
        RPC_E_SERVERCALL_RETRYLATER = unchecked((int)0x8001010A),
        RPC_E_SERVERCALL_REJECTED = unchecked((int)0x8001010B),
        RPC_E_INVALID_CALLDATA = unchecked((int)0x8001010C),
        RPC_E_CANTCALLOUT_ININPUTSYNCCALL = unchecked((int)0x8001010D),
        RPC_E_WRONG_THREAD = unchecked((int)0x8001010E),
        RPC_E_THREAD_NOT_INIT = unchecked((int)0x8001010F),
        RPC_E_VERSION_MISMATCH = unchecked((int)0x80010110),
        RPC_E_INVALID_HEADER = unchecked((int)0x80010111),
        RPC_E_INVALID_EXTENSION = unchecked((int)0x80010112),
        RPC_E_INVALID_IPID = unchecked((int)0x80010113),
        RPC_E_INVALID_OBJECT = unchecked((int)0x80010114),
        RPC_S_CALLPENDING = unchecked((int)0x80010115),
        RPC_S_WAITONTIMER = unchecked((int)0x80010116),
        RPC_E_CALL_COMPLETE = unchecked((int)0x80010117),
        RPC_E_UNSECURE_CALL = unchecked((int)0x80010118),
        RPC_E_TOO_LATE = unchecked((int)0x80010119),
        RPC_E_NO_GOOD_SECURITY_PACKAGES = unchecked((int)0x8001011A),
        RPC_E_ACCESS_DENIED = unchecked((int)0x8001011B),
        RPC_E_REMOTE_DISABLED = unchecked((int)0x8001011C),
        RPC_E_INVALID_OBJREF = unchecked((int)0x8001011D),
        RPC_E_UNEXPECTED = unchecked((int)0x8001FFFF),
        R2_BLACK = 1,
        R2_NOTMERGEPEN = 2,
        R2_MASKNOTPEN = 3,
        R2_NOTCOPYPEN = 4,
        R2_MASKPENNOT = 5,
        R2_NOT = 6,
        R2_XORPEN = 7,
        R2_NOTMASKPEN = 8,
        R2_MASKPEN = 9,
        R2_NOTXORPEN = 10,
        R2_NOP = 11,
        R2_MERGENOTPEN = 12,
        R2_COPYPEN = 13,
        R2_MERGEPENNOT = 14,
        R2_MERGEPEN = 15,
        R2_WHITE = 16,
        R2_LAST = 16,
        RGN_ERROR = 0,
        RGN_AND = 1,
        RGN_OR = 2,
        RGN_XOR = 3,
        RGN_DIFF = 4,
        RGN_COPY = 5,
        RGN_MIN = 1,
        RGN_MAX = 5,
        RESTORE_CTM = 4100,
        RUSSIAN_CHARSET = 204,
        RASTER_FONTTYPE = 0x0001,
        RELATIVE = 2,
        RASTERCAPS = 38,
        RC_BITBLT = 1,
        RC_BANDING = 2,
        RC_SCALING = 4,
        RC_BITMAP64 = 8,
        RC_GDI20_OUTPUT = 0x0010,
        RC_GDI20_STATE = 0x0020,
        RC_SAVEBITMAP = 0x0040,
        RC_DI_BITMAP = 0x0080,
        RC_PALETTE = 0x0100,
        RC_DIBTODEV = 0x0200,
        RC_BIGFONT = 0x0400,
        RC_STRETCHBLT = 0x0800,
        RC_FLOODFILL = 0x1000,
        RC_STRETCHDIB = 0x2000,
        RC_OP_DX_OUTPUT = 0x4000,
        RC_DEVBITS = unchecked((int)0x8000),
        RDH_RECTANGLES = 1,
        RESOURCE_CONNECTED = 0x00000001,
        RESOURCE_GLOBALNET = 0x00000002,
        RESOURCE_REMEMBERED = 0x00000003,
        RESOURCE_RECENT = 0x00000004,
        RESOURCE_CONTEXT = 0x00000005,
        RESOURCETYPE_ANY = 0x00000000,
        RESOURCETYPE_DISK = 0x00000001,
        RESOURCETYPE_PRINT = 0x00000002,
        RESOURCETYPE_RESERVED = 0x00000008,
        RESOURCETYPE_UNKNOWN = unchecked((int)0xFFFFFFFF),
        RESOURCEUSAGE_CONNECTABLE = 0x00000001,
        RESOURCEUSAGE_CONTAINER = 0x00000002,
        RESOURCEUSAGE_NOLOCALDEVICE = 0x00000004,
        RESOURCEUSAGE_SIBLING = 0x00000008,
        RESOURCEUSAGE_ATTACHED = 0x00000010,
        RESOURCEUSAGE_ALL = (0x00000001|0x00000002|0x00000010),
                            RESOURCEUSAGE_RESERVED = unchecked((int)0x80000000),
        RESOURCEDISPLAYTYPE_GENERIC = 0x00000000,
        RESOURCEDISPLAYTYPE_DOMAIN = 0x00000001,
        RESOURCEDISPLAYTYPE_SERVER = 0x00000002,
        RESOURCEDISPLAYTYPE_SHARE = 0x00000003,
        RESOURCEDISPLAYTYPE_FILE = 0x00000004,
        RESOURCEDISPLAYTYPE_GROUP = 0x00000005,
        RESOURCEDISPLAYTYPE_NETWORK = 0x00000006,
        RESOURCEDISPLAYTYPE_ROOT = 0x00000007,
        RESOURCEDISPLAYTYPE_SHAREADMIN = 0x00000008,
        RESOURCEDISPLAYTYPE_DIRECTORY = 0x00000009,
        RESOURCEDISPLAYTYPE_TREE = 0x0000000A,
        RESOURCEDISPLAYTYPE_NDSCONTAINER = 0x0000000B,
        REMOTE_NAME_INFO_LEVEL = 0x00000002,
        RP_LOGON = 0x01,
        RP_INIFILE = 0x02,
        READ_CONTROL = (0x00020000),
                       RTL_CRITSECT_TYPE = 0,
        RTL_RESOURCE_TYPE = 1,
        REG_OPTION_RESERVED = (0x00000000),
                              REG_OPTION_NON_VOLATILE = (0x00000000),
                                                        REG_OPTION_VOLATILE = (0x00000001),
                                                                              REG_OPTION_CREATE_LINK = (0x00000002),
                                                                                                       REG_OPTION_BACKUP_RESTORE = (0x00000004),
                                                                                                                                   REG_OPTION_OPEN_LINK = (0x00000008),
                                                                                                                                                          REG_CREATED_NEW_KEY = (0x00000001),
                                                                                                                                                                                REG_OPENED_EXISTING_KEY = (0x00000002),
                                                                                                                                                                                                          REG_WHOLE_HIVE_VOLATILE = (0x00000001),
                                                                                                                                                                                                                                    REG_REFRESH_HIVE = (0x00000002),
                                                                                                                                                                                                                                                       REG_NO_LAZY_FLUSH = (0x00000004),
                                                                                                                                                                                                                                                                           REG_NOTIFY_CHANGE_NAME = (0x00000001),
                                                                                                                                                                                                                                                                                                    REG_NOTIFY_CHANGE_ATTRIBUTES = (0x00000002),
                                                                                                                                                                                                                                                                                                                                   REG_NOTIFY_CHANGE_LAST_SET = (0x00000004),
                                                                                                                                                                                                                                                                                                                                                                REG_NOTIFY_CHANGE_SECURITY = (0x00000008),
                                                                                                                                                                                                                                                                                                                                                                                             REG_NONE = (0),
                                                                                                                                                                                                                                                                                                                                                                                                        REG_SZ = (1),
                                                                                                                                                                                                                                                                                                                                                                                                                 REG_EXPAND_SZ = (2),
                                                                                                                                                                                                                                                                                                                                                                                                                                 REG_BINARY = (3),
                                                                                                                                                                                                                                                                                                                                                                                                                                              REG_DWORD = (4),
                                                                                                                                                                                                                                                                                                                                                                                                                                                          REG_DWORD_LITTLE_ENDIAN = (4),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    REG_DWORD_BIG_ENDIAN = (5),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           REG_LINK = (6),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      REG_MULTI_SZ = (7),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     REG_RESOURCE_LIST = (8),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         REG_FULL_RESOURCE_DESCRIPTOR = (9),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        REG_RESOURCE_REQUIREMENTS_LIST = (10),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         RT_CURSOR = 1,
        RT_BITMAP = 2,
        RT_ICON = 3,
        RT_MENU = 4,
        RT_DIALOG = 5,
        RT_STRING = 6,
        RT_FONTDIR = 7,
        RT_FONT = 8,
        RT_ACCELERATOR = 9,
        RT_RCDATA = 10,
        RT_MESSAGETABLE = 11,
        RT_GROUP_CURSOR = 1+11,
        RT_GROUP_ICON = 3+11,
        RT_VERSION = 16,
        RT_DLGINCLUDE = 17,
        RT_PLUGPLAY = 19,
        RT_VXD = 20,
        RT_ANICURSOR = 21,
        RT_ANIICON = 22,
        RDW_INVALIDATE = 0x0001,
        RDW_INTERNALPAINT = 0x0002,
        RDW_ERASE = 0x0004,
        RDW_VALIDATE = 0x0008,
        RDW_NOINTERNALPAINT = 0x0010,
        RDW_NOERASE = 0x0020,
        RDW_NOCHILDREN = 0x0040,
        RDW_ALLCHILDREN = 0x0080,
        RDW_UPDATENOW = 0x0100,
        RDW_ERASENOW = 0x0200,
        RDW_FRAME = 0x0400,
        RDW_NOFRAME = 0x0800,
        RES_ICON = 1,
        RES_CURSOR = 2,
        ROTFLAGS_REGISTRATIONKEEPSALIVE = 0x1,
        ROTFLAGS_ALLOWANYCLIENT = 0x2,
        ROT_COMPARE_MAX = 2048,
        RBN_FIRST = (0-831),
                    RBN_LAST = (0-859),
                               RBNM_ID = 0x00000001,
        RBNM_STYLE = 0x00000002,
        RBNM_LPARAM = 0x00000004,
        RBIM_IMAGELIST = 0x00000001,
        RBS_TOOLTIPS = 0x00000100,
        RBS_VARHEIGHT = 0x00000200,
        RBS_BANDBORDERS = 0x00000400,
        RBS_FIXEDORDER = 0x00000800,
        RBS_REGISTERDROP = 0x1000,
        RBS_AUTOSIZE = 0x2000,
        RBS_VERTICALGRIPPER = 0x4000,
        RBS_DBLCLKTOGGLE = unchecked((int)0x8000),
        RBBS_BREAK = 0x00000001,
        RBBS_FIXEDSIZE = 0x00000002,
        RBBS_CHILDEDGE = 0x00000004,
        RBBS_HIDDEN = 0x00000008,
        RBBS_NOVERT = 0x00000010,
        RBBS_FIXEDBMP = 0x00000020,
        RBBS_VARIABLEHEIGHT = 0x00000040,
        RBBS_GRIPPERALWAYS = 0x00000080,
        RBBS_NOGRIPPER = 0x00000100,
        RBBIM_STYLE = 0x00000001,
        RBBIM_COLORS = 0x00000002,
        RBBIM_TEXT = 0x00000004,
        RBBIM_IMAGE = 0x00000008,
        RBBIM_CHILD = 0x00000010,
        RBBIM_CHILDSIZE = 0x00000020,
        RBBIM_SIZE = 0x00000040,
        RBBIM_BACKGROUND = 0x00000080,
        RBBIM_ID = 0x00000100,
        RBBIM_IDEALSIZE = 0x00000200,
        RBBIM_LPARAM = 0x00000400,
        RBBIM_HEADERSIZE = 0x00000800,
        RB_INSERTBANDA = (0x0400+1),
                         RB_DELETEBAND = (0x0400+2),
                                         RB_GETBARINFO = (0x0400+3),
                                                         RB_SETBARINFO = (0x0400+4),
                                                                         RB_GETBANDINFO_OLD = (0x0400+5),
                                                                                              RB_SETBANDINFOA = (0x0400+6),
                                                                                                                RB_SETPARENT = (0x0400+7),
                                                                                                                               RB_HITTEST = (0x0400+8),
                                                                                                                                            RB_GETRECT = (0x0400+9),
                                                                                                                                                         RB_INSERTBANDW = (0x0400+10),
                                                                                                                                                                          RB_SETBANDINFOW = (0x0400+11),
                                                                                                                                                                                            RB_GETBANDCOUNT = (0x0400+12),
                                                                                                                                                                                                              RB_GETROWCOUNT = (0x0400+13),
                                                                                                                                                                                                                               RB_GETROWHEIGHT = (0x0400+14),
                                                                                                                                                                                                                                                 RB_IDTOINDEX = (0x0400+16),
                                                                                                                                                                                                                                                                RB_GETTOOLTIPS = (0x0400+17),
                                                                                                                                                                                                                                                                                 RB_SETTOOLTIPS = (0x0400+18),
                                                                                                                                                                                                                                                                                                  RB_SETBKCOLOR